<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèº üóìÔ∏è üêøÔ∏è Les mines en performance attendent dans les coulisses üìç üë©üèø‚ÄçüöÄ „äóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je parlerai des mines pos√©es sous la performance, ainsi que de leur d√©tection (de pr√©f√©rence avant l'explosion) et de leur √©liminati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les mines en performance attendent dans les coulisses</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443206/"><p>  Dans cet article, je parlerai des mines pos√©es sous la performance, ainsi que de leur d√©tection (de pr√©f√©rence avant l'explosion) et de leur √©limination. </p><br><div class="spoiler">  <b class="spoiler_title">Une image pour attirer l'attention</b> <div class="spoiler_text"><p><img src="https://ic.pics.livejournal.com/ivagkin/26880913/58954/58954_original.jpg" alt="image"></p></div></div><a name="habracut"></a><br><h4 id="chto-takoe-mina">  Qu'est-ce qu'une mine? </h4><br><p>  Commen√ßons par ce qui est √† l'origine de toute connaissance - avec d√©finition.  Les anciens ont dit que nommer correctement signifie comprendre correctement.  Je pense que la d√©finition d'une mine en performance est mieux exprim√©e en la contrastant avec une erreur √©vidente, par exemple, ceci: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... strings)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : strings) { result += str; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  M√™me les d√©veloppeurs d√©butants savent que les lignes sont immuables, et les coller ensemble dans une boucle ne signifie pas ajouter des donn√©es √† la queue d'une ligne existante, mais cr√©er une <strong>nouvelle</strong> ligne √† chaque passage.  Si vous vous trompez, ne vous d√©couragez pas - l '¬´Id√©e¬ª vous avertira imm√©diatement du danger, et le ¬´Sonar¬ª inondera s√ªrement votre assembl√©e. </p><br><p>  Mais ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> attirera beaucoup moins d'attention, et l'id√©e ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avant la version 2018.2</a> ) sera silencieuse: </p><br><pre> <code class="java hljs">Long total = <span class="hljs-number"><span class="hljs-number">0L</span></span>; List&lt;Long&gt; totals = query.getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long element : totals) { total += element == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : element; }</code> </pre> <br><p>  Le probl√®me ici est le m√™me: les wrappers pour les types simples sont immuables, ce qui signifie ajouter 5 unit√©s au num√©ro d'objet signifie cr√©er un nouveau wrapper et y √©crire le num√©ro 6. </p><br><p>  La plaisanterie ici est la pr√©sence en Java de deux repr√©sentations de certains types de donn√©es - simple et objet, ainsi que leur transformation automatique au moyen du langage lui-m√™me.  Pour cette raison, de nombreux d√©veloppeurs novices pensent quelque chose comme ceci: "Eh bien, l'ex√©cution les transforme en quelque sorte par lui-m√™me, c'est juste un nombre." </p><br><p>  En fait, tout n'est pas si simple.  Prenez la <a href="">r√©f√©rence</a> et essayez d'ajouter les nombres de la mani√®re sp√©cifi√©e: </p><br><div class="spoiler">  <b class="spoiler_title">Tout √† coup, il est sorti tr√®s, tr√®s bon march√© (ci-apr√®s JDK 11, sauf indication contraire explicite)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> (size) Mode Cnt Score Error Units wrapper 10 avgt 100 23,5 ¬± 0,1 ns/op wrapper 100 avgt 100 352,3 ¬± 2,1 ns/op wrapper 1000 avgt 100 4424,5 ¬± 25,2 ns/op wrapper 10 avgt 100 0 ¬± 0 B/op wrapper 100 avgt 100 1872 ¬± 0 B/op wrapper 1000 avgt 100 23472 ¬± 0 B/op</code> </pre> <br><p>  Comparez avec un type simple: </p><br><pre> <code class="plaintext hljs">primitive 10 avgt 100 6,4 ¬± 0,0 ns/op primitive 100 avgt 100 39,8 ¬± 0,1 ns/op primitive 1000 avgt 100 252,5 ¬± 1,3 ns/op primitive 10 avgt 100 0 ¬± 0 B/op primitive 100 avgt 100 0 ¬± 0 B/op primitive 1000 avgt 100 0 ¬± 0 B/op</code> </pre> </div></div><br><p>  De l√†, nous d√©rivons l'une des d√©finitions des mines en cours de performance - c'est un code qui n'attire pas l'attention, n'est pas d√©tect√© (au moins au moment o√π vous l'avez rencontr√©) par des analyseurs statiques, mais il peut ralentir dans certaines utilisations.  Dans notre cas, alors que la somme ne d√©passe pas 127 objets sont extraits du cache et <code>Long</code> que 4 fois plus lent que <code>long</code> .  Cependant, pour un tableau de taille 100, la vitesse est presque 10 fois inf√©rieure. </p><br><h4 id="bolshie-melochi">  De grandes petites choses </h4><br><p>  Parfois, un petit changement, qui ne change <em>presque</em> pas le sens de l'ex√©cution, devient dans <em>certains</em> cas un frein puissant. </p><br><p>  Supposons que nous ayons un code: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); if (info == null) { info = getAlias.apply(alias); cache.put(alias, info); } return info; }</span></span></code> </pre> <br><p>  √Ä quoi ressemble la logique de la m√©thode? </p><br><div class="spoiler">  <b class="spoiler_title">Ne vous pr√©cipitez pas pour espionner, pensez</b> <div class="spoiler_text"><p>  C'est <code>ConcurrentHashMap::computeIfAbsent</code> ! </p></div></div><br><p>  Nous avons le "huit" et nous pouvons am√©liorer le code en toute tranquillit√©: remplacez 6 lignes par une, ce qui rend le code plus court et plus facile √† comprendre.  Soit dit en passant, les connaisseurs du multithreading indiqueront probablement une autre am√©lioration apport√©e par <code>ConcurrentHashMap::computeIfAbsent</code> , mais √† ce sujet un peu plus tard;) </p><br><p>  R√©alisons une grande pens√©e: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { return cache.computeIfAbsent(alias, getAlias); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Rassembl√©, commenc√©, pleur√©</b> <div class="spoiler_text"><p>  Pour voir la taille r√©elle, faites un clic droit sur l'image et s√©lectionnez "Ouvrir l'image dans un nouvel onglet" <br><img src="https://habrastorage.org/getpro/habr/post_images/9f0/2aa/0e0/9f02aa0e028903e85a63d08207d93509.png" alt="image"></p></div></div><br><p>  Alors que l'application fonctionnait avec un seul thread, tout √©tait plus ou moins bon.  Les flux sont devenus plus nombreux et sont devenus nettement pires.  Il <code>ConcurrentHashMap::computeIfAbsent</code> av√©r√© que <code>ConcurrentHashMap::computeIfAbsent</code> bloqu√©, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√™me si la cl√© <strong>a d√©j√† √©t√©</strong> ajout√©e au dictionnaire</a> .  Et cela est devenu la raison de tout un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bug</a> dans Spring Date Mongo. </p><br><p>  Vous pouvez le v√©rifier avec une simple <a href="">mesure</a> ("huit").  Voici sa conclusion: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 19,405 ¬± 0,411 ns/op getAndPut avgt 20 4,578 ¬± 0,045 ns/op 2 threads computeIfAbsent avgt 20 66,492 ¬± 2,036 ns/op getAndPut avgt 20 4,454 ¬± 0,110 ns/op 4 threads computeIfAbsent avgt 20 155,975 ¬± 8,850 ns/op getAndPut avgt 20 5,616 ¬± 2,073 ns/op 6 threads computeIfAbsent avgt 20 203,188 ¬± 10,547 ns/op getAndPut avgt 20 7,024 ¬± 0,456 ns/op 8 threads computeIfAbsent avgt 20 302,036 ¬± 31,702 ns/op getAndPut avgt 20 7,990 ¬± 0,144 ns/op</code> </pre> <br><p>  Cela peut-il √™tre clairement consid√©r√© comme une erreur par les d√©veloppeurs?  √Ä mon humble avis, non, non.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> dit: </p><br><blockquote>  Certaines op√©rations de mise √† jour tent√©es sur cette carte par d'autres threads peuvent √™tre bloqu√©es pendant le calcul, donc le calcul doit √™tre court et simple, et ne doit pas tenter de mettre √† jour d'autres mappages de cette carte </blockquote><p>  En d'autres termes, <code>ConcurrentHashMap::computeIfAbsent</code> ferme la cellule contenant la cl√© du monde ext√©rieur (contrairement √† <code>ConcurrentHashMap::get</code> ), ce qui est g√©n√©ralement vrai, car il vous permet d'esquiver la course tout en appelant la m√©thode √† partir de diff√©rents threads lorsque la cl√© n'a pas encore √©t√© ajout√©e. </p><br><p>  En revanche, dans le mode de fonctionnement le plus courant, le calcul de la valeur et sa liaison avec la cl√© ne se produisent qu'au premier appel, et tous les appels suivants ne renvoient que la valeur pr√©c√©demment calcul√©e.  Par cons√©quent, il est logique de modifier la logique de sorte que le verrou ne soit d√©fini que lors du changement.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cela a √©t√© fait ici</a> . </p><br><p>  Dans les √©ditions plus r√©centes (&gt; 8), <code>ConcurrentHashMap::computeIfAbsent</code> devenu <code>ConcurrentHashMap::computeIfAbsent</code> : </p><br><pre> <code class="plaintext hljs">JDK 11 Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 6,983 ¬± 0,066 ns/op getAndPut avgt 20 5,291 ¬± 1,220 ns/op 2 threads computeIfAbsent avgt 20 7,173 ¬± 0,249 ns/op getAndPut avgt 20 5,118 ¬± 0,395 ns/op 4 threads computeIfAbsent avgt 20 7,991 ¬± 0,447 ns/op getAndPut avgt 20 5,270 ¬± 0,366 ns/op 6 threads computeIfAbsent avgt 20 11,919 ¬± 0,865 ns/op getAndPut avgt 20 7,249 ¬± 0,199 ns/op 8 threads computeIfAbsent avgt 20 14,360 ¬± 0,892 ns/op getAndPut avgt 20 8,511 ¬± 0,229 ns/op</code> </pre> <br><p>  Faites attention √† l'insidiosit√© de cet exemple: le contenu s√©mantique <em>n'a</em> pas beaucoup chang√©, car √† premi√®re vue nous venons d'utiliser une syntaxe plus avanc√©e.  Dans le m√™me temps, alors que l'application s'ex√©cute sur un seul thread, l'utilisateur ne sent presque pas la diff√©rence!  Voil√† comment des changements apparemment inoffensifs <del>  le cochon </del>  le mien sous notre performance. </p><br><div class="spoiler">  <b class="spoiler_title">Pourquoi j'ai √©crit ¬´presque inchang√©¬ª</b> <div class="spoiler_text"><p>  <code>ConcurrentHashMap::computeIfAbsent</code> pas toujours interchangeable avec l'expression <code>getAndPut</code> , car <code>ConcurrentHashMap::computeIfAbsent</code> est une op√©ration atomique.  Dans le m√™me code </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { info = getAlias.apply(alias); cache.put(alias, info); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; }</code> </pre> <br><p>  en raison du manque de synchronisation externe <strong>, une course appara√Æt</strong> .  Si la fonction pass√©e √† <code>ConcurrentHashMap::computeIfAbsent</code> pour la cl√© donn√©e retourne toujours la m√™me valeur, alors c'est une course "s√ªre", le plus auquel nous sommes confront√©s est de calculer la m√™me valeur 2 fois ou plus.  S'il n'y a pas de telles garanties, le remplacement m√©canique est lourd d'√©chec de l'application.  Faites attention! </p></div></div><br><h4 id="eti-ruki-nichego-ne-menyali">  Ces mains n'ont rien chang√© </h4><br><p>  Il arrive aussi que le code ne change pas du tout, mais soudain, il commence √† ralentir. </p><br><p>  Imaginez que nous sommes confront√©s √† la t√¢che de d√©placer des √©l√©ments de tableau dans une collection.  Le plus logique serait d'utiliser la <code>Collection::addAll</code> pr√™te √† l'emploi, mais voici la malchance - elle accepte la collection: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span></span>; }</code> </pre> <br><p>  Le moyen le plus simple consiste √† encapsuler le tableau dans <code>Arrays::asList</code> .  Il en r√©sultera quelque chose comme </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.addAll(Arrays.asList(items)); }</code> </pre> <br><p>  Lors de la relecture, des coll√®gues soucieux de performances nous diront probablement qu'il y a deux probl√®mes dans ce code √† la fois: </p><br><ul><li>  encapsuler un tableau dans une liste (objet suppl√©mentaire) </li><li>  cr√©er un it√©rateur (un autre objet suppl√©mentaire) et le traverser </li></ul><br><p>  En fait, dans l'impl√©mentation de r√©f√©rence de <code>Collection::addAll</code> nous verrons ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> modified = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add(e)) modified = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; } }</code> </pre> <br><p>  Un it√©rateur est donc cr√©√© ici et les √©l√©ments sont tri√©s √† l'aide de celui-ci.  Par cons√©quent, des camarades exp√©riment√©s proposent leur solution: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  A l'int√©rieur du code, <em>semblant √†</em> juste titre plus productif: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T element : elements) result |= c.add(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Tout d'abord, un it√©rateur n'est pas cr√©√©.  Deuxi√®mement, la passe se d√©roule dans le cycle de comptage habituel, en outre, les tableaux s'int√®grent bien dans les caches, ses √©l√©ments sont situ√©s en m√©moire de mani√®re s√©quentielle (ce qui signifie qu'il y aura peu de rat√©s de cache), et leur acc√®s par index est tr√®s rapide.  Eh bien, une liste d'encapsuleurs n'est pas cr√©√©e non plus.  √áa sonne bien et sain. </p><br><p>  Enfin, mes coll√®gues citent ultima ratio regum: documentation.  Et l√†, gris sur blanc (ou vert sur noir) dit: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ... * The behavior of this convenience method is identical to that of * c.addAll(Arrays.asList(elements)), but this method is likely * to run significantly faster under most implementations. &lt;---- * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.5 */</span></span> <span class="hljs-meta"><span class="hljs-meta">@SafeVarargs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Autrement dit, les d√©veloppeurs eux-m√™mes (et qui devraient-ils croire, sinon eux?) √âcrivez que pour la plupart des impl√©mentations, la m√©thode utilitaire fonctionne <em>beaucoup</em> plus rapidement.  Et il est vraiment plus rapide.  Parfois. </p><br><p>  Le <a href="">benchmark</a> , que nous lancerons pour le <code>HashSet</code> sur le G8, permettra de <code>HashSet</code> : </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 155,2 ¬± 2,8 ns/op addAll HashSet 100 avgt 100 1884,4 ¬± 37,4 ns/op addAll HashSet 1000 avgt 100 17917,3 ¬± 298,8 ns/op collectionsAddAll HashSet 10 avgt 100 136,1 ¬± 0,8 ns/op collectionsAddAll HashSet 100 avgt 100 1538,3 ¬± 31,4 ns/op collectionsAddAll HashSet 1000 avgt 100 15168,6 ¬± 289,4 ns/op</code> </pre> <br><p>  Il semble que les camarades les plus exp√©riment√©s avaient raison.  Presque. </p><br><p>  Dans les √©ditions ult√©rieures (par exemple, dans 11), l'√©clat de la m√©thode d'utilit√© s'estompe quelque peu: </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 143,1 ¬± 0,6 ns/op addAll HashSet 100 avgt 100 1738,4 ¬± 7,3 ns/op addAll HashSet 1000 avgt 100 16853,9 ¬± 101,0 ns/op collectionsAddAll HashSet 10 avgt 100 132,1 ¬± 1,1 ns/op collectionsAddAll HashSet 100 avgt 100 1661,1 ¬± 7,1 ns/op collectionsAddAll HashSet 1000 avgt 100 15450,9 ¬± 93,9 ns/op</code> </pre> <br><p>  On peut voir que nous ne parlons pas d'un "beaucoup plus rapide".  Et si nous r√©p√©tons l'exp√©rience pour <code>ArrayList</code> -a, il s'av√®re que la m√©thode d'utilit√© commence √† perdre beaucoup (plus elle est forte): </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units JDK 8 addAll ArrayList 10 avgt 100 38,5 ¬± 0,5 ns/op addAll ArrayList 100 avgt 100 188,4 ¬± 7,0 ns/op addAll ArrayList 1000 avgt 100 1278,8 ¬± 42,9 ns/op collectionsAddAll ArrayList 10 avgt 100 62,7 ¬± 0,7 ns/op collectionsAddAll ArrayList 100 avgt 100 495,1 ¬± 2,0 ns/op collectionsAddAll ArrayList 1000 avgt 100 4892,5 ¬± 48,0 ns/op JDK 11 addAll ArrayList 10 avgt 100 26,1 ¬± 0,0 ns/op addAll ArrayList 100 avgt 100 161,1 ¬± 0,4 ns/op addAll ArrayList 1000 avgt 100 1276,7 ¬± 3,7 ns/op collectionsAddAll ArrayList 10 avgt 100 41,6 ¬± 0,0 ns/op collectionsAddAll ArrayList 100 avgt 100 492,6 ¬± 1,5 ns/op collectionsAddAll ArrayList 1000 avgt 100 6792,7 ¬± 165,5 ns/op</code> </pre> <br><p>  Il n'y a rien d'inattendu ici, <code>ArrayList</code> construit autour d'un tableau, donc les d√©veloppeurs ont red√©fini la <code>Collection::addAll</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ Object[] a = c.toArray(); modCount++; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numNew = a.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Object[] elementData; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew &gt; (elementData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, elementData, s, numNew); &lt;---    size = s + numNew; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Revenons maintenant √† nos mines.  Supposons que nous ayons n√©anmoins accept√© la solution propos√©e en relecture et laiss√© ce code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Pour le moment, tout va bien, mais apr√®s avoir ajout√© de nouvelles fonctionnalit√©s, la m√©thode devient parfois chaude et commence √† ralentir.  Nous ouvrons des codes source - le code n'a pas chang√©.  La quantit√© de donn√©es est la m√™me.  Et les performances ont beaucoup baiss√©.  Ceci est un autre type de mine. </p><br><p>  D√©couvrez le d√©bogueur et trouvez la belle: </p><br><p><img src="https://habrastorage.org/webt/nw/og/mu/nwogmu0_mvl-ix_hdyoxdaoydik.png"></p><br><p>  Veuillez noter: nous n'avons pas chang√© l'algorithme, la quantit√© de donn√©es trait√©es n'a pas chang√©, mais leur nature a chang√© et un probl√®me de performance a commenc√© dans notre code: </p><br><pre> <code class="plaintext hljs"> Java 8 Java 11  addAll 10 56,9 25,2 ns/op collectionsAddAll 10 352,2 142,9 ns/op addAll 100 159,9 84,3 ns/op collectionsAddAll 100 4607,1 3964,3 ns/op addAll 1000 1244,2 760,2 ns/op collectionsAddAll 1000 355796,9 364677,0 ns/op</code> </pre> <br><p>  Sur les grands tableaux, la diff√©rence entre <code>Collections::addAll</code> et <code>Collection::addAll</code> est 500 fois modeste.  Le fait est que <code>COWList</code> ne d√©veloppe pas seulement le tableau existant, mais en cr√©e un nouveau chaque fois que des √©l√©ments sont ajout√©s: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (lock) { Object[] es = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = es.length; es = Arrays.copyOf(es, len + <span class="hljs-number"><span class="hljs-number">1</span></span>); &lt;----    es[len] = e; setArray(es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p><del>  Qui est √† bl√¢mer? </del></p><br><div class="spoiler">  <b class="spoiler_title">Que faire</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://bugs.openjdk.java.net/browse/JDK-8193031</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://cr.openjdk.java.net/~martin/webrevs/jdk/Collections-addAll/</a> </p></div></div><br><p>  Le probl√®me principal ici est que la <code>Collections::addAll</code> accepte une interface, tandis que la m√©thode <code>addAll</code> pas de corps.  Aucun corps - aucune entreprise, par cons√©quent, la documentation est √©crite sur la base de l'impl√©mentation existante dans <code>AbstractCollection::addAll</code> , qui est un algorithme g√©n√©ralis√© applicable √† toutes les collections.  Cela signifie que des impl√©mentations plus sp√©cifiques de structures de donn√©es qui sont √† un niveau d'abstraction inf√©rieur peuvent modifier ce comportement. </p><br><div class="spoiler">  <b class="spoiler_title">Maintenant humainement</b> <div class="spoiler_text"><pre> <code class="java hljs"> Collection::addAll ‚Äì   AbstractCollection::addAll ‚Äì   &lt;---    ArrayList::addAll HashSet::addAll ‚Äì   &lt;---      COWList::addAll</code> </pre> </div></div><br><h4 id="eschyo-ob-abstrakciyah">  En savoir plus sur les abstractions </h4><br><p>  Puisque nous parlons des niveaux d'abstraction, je vais vous parler d'un exemple tir√© de la vie. </p><br><p>  Comparons ces deux fa√ßons de sauvegarder le ni√®me nombre d'entit√©s dans la base de donn√©es: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  √Ä premi√®re vue, les performances des deux m√©thodes ne devraient pas √™tre tr√®s diff√©rentes, car </p><br><ul><li>  dans les deux cas, le m√™me nombre d'entit√©s sera stock√© dans la base de donn√©es </li><li>  si la cl√© est extraite de la s√©quence, le nombre d'appels sera le m√™me </li><li>  la quantit√© de donn√©es transf√©r√©es est la m√™me </li></ul><br><p>  <code>SimpleJpaRepository::saveAndFlush</code> √† la <code>SimpleJpaRepository::saveAndFlush</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveAndFlush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ S result = save(entity); flush(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ em.flush(); }</code> </pre> <br><p>  Le point noir ici est la m√©thode <code>flush()</code> .  Pourquoi stupide?  Il me semble que sa divulgation dans l'interface <code>JpaRepository</code> √©tait une erreur des d√©veloppeurs.  Je vais essayer de justifier ma pens√©e.  En r√®gle g√©n√©rale, cette m√©thode n'est pas du tout utilis√©e par le d√©veloppeur, car l'appel √† <code>EntityManager::flush</code> li√© √† l'ach√®vement d'une transaction contr√¥l√©e par Spring: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     @Transactional public void method() { &lt;--  Session::open /*.*/ } &lt;--  Session::flush</span></span></code> </pre> <br><p>  Remarque: <code>EntityManager</code> fait partie de la sp√©cification <code>JPA</code> impl√©ment√©e dans Hibernate en tant que session (interface de session et classe SessionImpl, respectivement).  Spring Date est un framework qui s'ex√©cute au-dessus d'un ORM, dans ce cas, au-dessus d'Hibernate.  Il s'av√®re que la <code>JpaRepository::saveAndFlush</code> nous donne acc√®s aux niveaux inf√©rieurs de l'API, bien que la t√¢che du framework soit de masquer les d√©tails de bas niveau (la situation est quelque peu similaire √† l'histoire Unsafe du JDK). <br>  Dans notre cas, lorsque vous utilisez <code>JpaRepository::saveAndFlush</code> nous entrons dans les couches inf√©rieures de l'application, cassant ainsi quelque chose. </p><br><div class="spoiler">  <b class="spoiler_title">Prenez votre temps pour jeter un coup d'≈ìil, pensez par vous-m√™me</b> <div class="spoiler_text"><p>  La capacit√© d'Hibernate √† envoyer des donn√©es par lots est rompue, un multiple du param√®tre <code>jdbc.batch_size</code> , qui est sp√©cifi√© dans <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate: jdbc.batch_size: 500</code> </pre> <br><p>  Le travail d'Hibernate est construit sur des √©v√©nements, donc lorsque vous enregistrez 1000 entit√©s comme celle-ci </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } }</code> </pre> <br><p>  appeler <code>repository.save(e)</code> ne sauvegarde pas instantan√©ment.  Au lieu de cela, un √©v√©nement est cr√©√© qui est mis en file d'attente.  √Ä la fin de la transaction, les donn√©es sont fusionn√©es √† l'aide de <code>EntityManager::flush</code> , qui divise les insertions / mises √† jour en packs multiples de <code>jdbc.batch_size</code> et cr√©e des requ√™tes √† partir d'eux.  Dans notre cas, <code>jdbc.batch_size: 500</code> , donc sauver 1000 entit√©s en r√©alit√© signifie seulement 2 requ√™tes. </p><br><p>  Mais avec une d√©charge manuelle de la session √† chaque passage du cycle </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  la file d'attente est effac√©e et l'enregistrement de 1 000 entit√©s signifie 1 000 requ√™tes. </p></div></div><br><p>  Ainsi, interf√©rer avec les couches inf√©rieures de l'application peut facilement devenir une mine, et pas seulement une mine de productivit√© (voir Dangereux et son utilisation non contr√¥l√©e). </p><br><p>  Combien cela ralentit-il?  Prenons le meilleur des cas (pour nous) - la base de donn√©es se trouve sur le m√™me h√¥te que l'application.  Ma <a href="">mesure</a> montre l'image suivante: </p><br><pre> <code class="plaintext hljs"> (entityCount) Mode Cnt Score Error Units bulkSave 10 ss 500 16,613 ¬± 1,714 ms/op bulkSave 100 ss 500 31,371 ¬± 1,453 ms/op bulkSave 1000 ss 500 35,687 ¬± 1,973 ms/op bulkSaveUsingFlush 10 ss 500 32,653 ¬± 2,166 ms/op bulkSaveUsingFlush 100 ss 500 61,983 ¬± 6,304 ms/op bulkSaveUsingFlush 1000 ss 500 184,814 ¬± 6,976 ms/op</code> </pre> <br><p>  De toute √©vidence, si la base de donn√©es est situ√©e sur un h√¥te distant, le co√ªt du transfert de donn√©es d√©gradera de plus en plus les performances √† mesure que le volume de donn√©es augmente. </p><br><p>  Ainsi, travailler au mauvais niveau d'abstraction peut facilement cr√©er une bombe √† retardement.  Soit dit en passant, dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un de mes articles pr√©c√©dents,</a> j'ai parl√© d'une curieuse tentative d'am√©lioration de <code>StringBuilder</code> -a: l√†, j'ai √©chou√© juste en essayant d'entrer dans un niveau de code plus abstrait. </p><br><h4 id="granicy-minnyh-poley">  Fronti√®res de champs de mines </h4><br><p>  Jouons un sapeur?  Trouvez le mien: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); Assert.notNull(key, "Null key ..." + context.metadata.operation); // ... return key; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Vous l'avez trouv√©?</b>  <b class="spoiler_title">V√©rifiez la bonne r√©ponse.</b> <div class="spoiler_text"><pre> <code class="java hljs"> | \ / <span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport | \ / Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); | \ / Assert.notNull(key, "Null key ..." + context.metadata.operation); return key; }</span></span></code> </pre> </div></div><br><p>  "Vous plaisantez?", S'exclame le critique. "Mais n'y a-t-il qu'un collage de deux lignes? Qu'est-ce que cela signifie dans un sanglant E.?"  Permettez-moi d'attirer votre attention sur le fait que j'ai mis en √©vidence non seulement le collage de cordes, mais aussi le nom de la classe et le nom de la m√©thode.  En effet, le danger de coller des cha√Ænes ne r√©side pas dans le collage lui-m√™me, mais dans ce qui se passe dans la m√©thode qui cr√©e les cl√©s du cache, c'est-√†-dire que dans certains sc√©narios, nous aurons beaucoup d'appels √† cette m√©thode, ce qui signifie beaucoup de lignes d'ordures. <br>  Par cons√©quent, un message d'erreur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doit √™tre cr√©√© uniquement</a> lorsque cette erreur est r√©ellement lev√©e: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); if (key == null) { throw new IAE("Null key ..." + context.metadata.operation); } // ... return key; }</span></span></code> </pre> <br><p>  Ainsi, les champs de mines ont des limites - c'est la quantit√© de donn√©es, la fr√©quence d'acc√®s √† la m√©thode, etc. des indicateurs quantitatifs, lorsqu'ils atteignent et d√©passent, o√π un l√©ger inconv√©nient devient statistiquement significatif. </p><br><p>  D'un autre c√¥t√©, c'est la caract√©ristique jusqu'√† ce que l'intersection qui complique le code ne donne pas une am√©lioration significative (mesurable). </p><br><p>  C'est une autre conclusion pour le d√©veloppeur: dans la plupart des cas, la tromperie est mauvaise, conduisant √† une complication insignifiante du code.  Dans 99 cas sur 100, nous ne gagnons rien. </p><br><p>  Il ne faut pas oublier qu'il y a toujours </p><br><h4 id="tot-samyy-sotyy-sluchay">  Le centi√®me cas </h4><br><p>  Voici le code que Nitzan Wakart donne dans son article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The volatile read surprise</a> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopyBenchmarks</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"1024"</span></span>, <span class="hljs-string"><span class="hljs-string">"32768"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bunn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { <span class="hljs-comment"><span class="hljs-comment">// good old C style for (the win?) fox.consume(bunn[y]); } } @Benchmark public void sweetLoop(Blackhole fox) { for (byte bunny : bunn) { // syntactic sugar loop goodness fox.consume(bunny); } } }</span></span></code> </pre> <br><p>  Lorsque nous mettrons en place l'exp√©rience, nous d√©couvrirons une diff√©rence incroyable entre les deux fa√ßons d'it√©rer sur un tableau: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoop 32 46.630 0.097 ns/op goodOldLoop 1024 1199.338 0.705 ns/op goodOldLoop 32768 37813.600 56.081 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>  Ici, un d√©veloppeur inexp√©riment√© peut tirer une conclusion aussi √©vidente et √©tay√©e: passer √† travers un tableau en utilisant la nouvelle syntaxe fonctionne plus rapidement qu'un cycle de comptage.  C'est la mauvaise conclusion, car cela vaut la peine de changer un <code>goodOldLoop</code> m√©thode <code>goodOldLoop</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoopReturns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sunn = bunn; <span class="hljs-comment"><span class="hljs-comment">// make a local copy of the field for (int y = 0; y &lt; sunn.length; y++) { fox.consume(sunn[y]); } }</span></span></code> </pre> <br><p>  et ses performances sont comparables √† celles de la m√©thode <code>sweetLoop</code> ¬´plus rapide¬ª: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoopReturns 32 19.306 0.045 ns/op goodOldLoopReturns 1024 476.493 1.190 ns/op goodOldLoopReturns 32768 14292.286 16.046 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>     <code>Blackhole::consume</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//... public volatile byte b1, b2; public volatile BlackholeL2 nullBait = null; /** * Consume object. This call provides a side effect preventing JIT to eliminate dependent computations. * * @param b object to consume. */ public final void consume(byte b) { if (b == b1 &amp; b == b2) { // SHOULD NEVER HAPPEN nullBait.b1 = b; // implicit null pointer exception } }</span></span></code> </pre> <br><p>         ,    ,      .     <code>goodOldLoop</code>       <code>this.bunn</code>    ,  <code>for-each</code>     ,        (,  Java Concurrency In Practice   "  ").      . </p><br><p>    : "      ?   , <code>Blackhole::consume</code> ‚Äî   JMH       .  ,  ,       ?" </p><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>   ? ?  ,    : </p><br><pre> <code class="java hljs">E[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;E&gt; fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>  <code>Iterable::forEach</code> !        ,   ,        ,       (   JDK 13): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); } //Arrays$ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } //CopyOnWriteArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (Object x : getArray()) { @SuppressWarnings("unchecked") E e = (E) x; action.accept(e); } } //ArrayDeque public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final Object[] es = elements; for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i &lt; to; i++) action.accept(elementAt(es, i)); if (to == end) { if (end != tail) throw new ConcurrentModificationException(); break; } } }</span></span></code> </pre> <br><p>     ,          . ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> <code>Collections.nCopies()::forEach</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(action); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n; i++) { action.accept(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } }</code> </pre> <br><p>            , . .   <code>this.n</code>  <code>this.element</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopiesList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> E element; CopiesList(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, E e) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; element = e; }</code> </pre> <br><p>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> <code>@Stable</code> . </p><br><p>  :  99   100  ,     ,    1   100,             .     ,     . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a>          "  volatile". </p><br><h4 id="eho-voyny">   </h4><br><p>      ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.Integer @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); }</span></span></code> </pre> <br><p> -   ,         ( <code>java.lang.Integer</code> , <code>java.lang.Long</code> , <code>java.lang.Short</code> , <code>java.lang.Byte</code> , <code>java.lang.Character</code> ).  ,     ,     </p><br><pre> <code class="java hljs">Integer intgr = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>    . </p><br><p>      : </p><br><pre> <code class="java hljs">Integer intgr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>        ,         ,       <code>Integer::valueOf</code>   . </p><br><p>         :      .                ,   ,      ""  (         ).   ,        ,         <code>Integer::valueOf</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"  "</a> . </p><br><p>   . ,              . ,       .      ,    ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443206/">https://habr.com/ru/post/fr443206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443196/index.html">Pas une minute hors ligne - Choisir un routeur LTE industriel</a></li>
<li><a href="../fr443198/index.html">Mark Zuckerberg dit que Facebook travaille sur une interface neuronale pour lire les pens√©es</a></li>
<li><a href="../fr443200/index.html">Des pirates iraniens volent des t√©raoctets de donn√©es √† Citrix</a></li>
<li><a href="../fr443202/index.html">Rassemblement contre l'isolement de Runet</a></li>
<li><a href="../fr443204/index.html">Frontend Weekly Digest (4-10 mars 2019)</a></li>
<li><a href="../fr443208/index.html">Souris d'entreprise</a></li>
<li><a href="../fr443210/index.html">Tutoriel React Partie 21: Deuxi√®me le√ßon et atelier de rendu conditionnel</a></li>
<li><a href="../fr443212/index.html">Tutoriel React, Partie 22: Septi√®me √©tape de travail sur une application TODO, T√©l√©chargement de donn√©es √† partir de sources externes</a></li>
<li><a href="../fr443214/index.html">Tutoriel React, partie 23: Le√ßon sur les premiers formulaires</a></li>
<li><a href="../fr443216/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 355 (4-10 mars 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>