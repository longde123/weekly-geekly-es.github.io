<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😴 🖕🏼 ✌️ GSM + GPS模块A9G上的Micropython ✝️ 👨🏾‍🤝‍👨🏻 🧑🏼‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这次，我考虑过将GPS追踪器藏在自行车中作为预防措施。 市场上有许多用于跟踪汽车，货物，自行车，行李，儿童和动物的自动装置。 他们中的绝大多数通过短信与用户互动。 更昂贵的选项提供“查找我的电话”功能，但与特定的在线服务相关。 
 理想情况下，我想完全控制跟踪器：在没有SMS和注册的便捷模式下使用它...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GSM + GPS模块A9G上的Micropython</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446090/"><p> 这次，我考虑过将GPS追踪器藏在自行车中作为预防措施。 市场上有许多用于跟踪汽车，货物，自行车，行李，儿童和动物的自动装置。 他们中的绝大多数通过短信与用户互动。 更昂贵的选项提供“查找我的电话”功能，但与特定的在线服务相关。 <br> 理想情况下，我想完全控制跟踪器：在没有SMS和注册的便捷模式下使用它。 肤浅的Google给我带来了几个来自中国的模块，我订购了其中的一个模块（A9G布丁板）（〜15美元）。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7f/b34/fe0/f7fb34fe016bb3a6c532712b9b2e75e1.png" alt="模组"></p><br><p> 本文是关于我如何使python在此模块上工作的。 </p><a name="habracut"></a><br><p> 如果A9G是ESP的类似物（顺便说一句，制造商是相同的），那么布丁板本身就是NodeMCU板的类似物，只是布丁板没有内置的USB-UART转换器。 但是还有许多其他有趣的事情。  <a href="">制造商</a>规格： </p><br><ul><li>  32位核心（RISC），最高312MHz </li><li>  29个GPIO（均已焊接，所有接口均包含在此编号中） </li><li> 手表和看门狗 </li><li>  1个USB 1.1接口（我在那里找不到，但是可以从异地复制）和microUSB供电 </li><li>  2个UART（+1服务） </li><li>  2x SPI（未尝试） </li><li>  3x I2C（未尝试） </li><li>  1个SDMMC（带有物理插槽） </li><li>  2个模拟输入（10位，锂电池控制器可能使用其中之一） </li><li>  4Mb闪存 </li><li>  4Mb PSRAM </li><li>  ADC（麦克风，物理存在于板上）和DAC（扬声器，不存在） </li><li> 电池充电控制器（本身没有电池） </li><li> 实际上，带有SMS，语音和GPRS的GSM（800、900、1800、1900 MHz） </li><li>  GPS通过UART2连接（没有“ A9”模块） </li><li>  SIM卡插槽（nanoSIM） </li><li> 两个按钮（一个复位，另一个-包含和可编程功能） </li><li> 两个LED </li></ul><br><p> 工作电压为3.3V，输入电压为5-3.8V（取决于连接）。 通常，该模块具有所有必需的硬件，以便根据其组装简单的按钮式移动设备。 但是从这些例子中，似乎中国人正在从老虎机或老虎机或类似的东西上购买它来出售。 该模块的替代品是相当流行的SIM800模块，不幸的是，该模块在公共领域中没有SDK（即，这些模块作为AT调制解调器出售）。 </p><br><h1> 开发包 </h1><br><p>该模块随附了令人满意的英语<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SDK</a> 。 在Ubuntu下安装，但是Windows和容器是首选。 一切都可以通过在GUI中戳来完成：此模块的ESPtool尚未还原。 固件本身由Makefile构建。 存在调试器：冻结之前，模块将堆栈跟踪抛出到服务端口中。 但就我个人而言，我无法将地址转换为代码行（gdb报告该地址与任何内容都不对应）。 可能是由于对Linux这样的支持不佳所致。 因此，如果您想修改模块-尝试在Windows下进行（并在github上退订）。 否则，这是Linux的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> 。 安装后，您需要检查.bashrc中路径的正确性，并删除（重命名）所有<code>CSDTK/lib/libQt*</code> ：否则，由于可能与已安装的libQt发生冲突，刷新程序（即调试器）将无法启动。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/955/5bc/7a79555bca02e1ad6363b8da9559c91e.png" alt="闪光器"></p><br><p> 闪光灯上有一条<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指示</a> 。 </p><br><h1> 连接方式 </h1><br><p> 一切都比在NodeMCU上复杂。 这些模块看起来很相似，但是布丁板上没有USB-TTY芯片，microUSB仅用于供电。 因此，您将需要3.3V的USB-TTY。 两种比较好：一种用于调试端口，一种用于UART1：第一种用于上传固件，第二种可以用作常规终端。 为了不将所有这些鼻涕拖到计算机上，我还购买了带两米电缆和外部电源的4端口USB分配器（必需）。 该套件与模块本身的总成本为25-30美元（不带电源：可通过电话使用）。 </p><br><h1> 韧体 </h1><br><p> 该模块随附AT固件：您可以连接到3.3V arduino，并通过UART1将其用作调制解调器。 他们的固件使用C语言编写。make创建了两个固件文件：一个缝制了大约一分钟，另一个缝制得足够快。 只能缝制以下文件中的一个：第一次较大，以后较小。 总的来说，在开发过程中，我在桌面上打开了中文SDK（ <code>coolwatcher</code> ），用于管理模块，miniterm（作为stdio和代码编辑器）。 </p><br><h1>  API </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API</a>的内容反映了上面的列表，类似于ESP8266的早期版本：我花了大约3个小时来启动HelloWorld。 不幸的是，用户可用的功能集非常有限：例如，无法访问SIM卡上的电话簿，有关连接到蜂窝网络的低级信息等等。  API文档甚至还不够完善，因此您必须依靠示例（其中有两个打样）并包含文件。 不过，该模块可以完成许多工作，直至SSL连接：显然，制造商专注于最优先的功能。 </p><br><p> 但是，必须喜欢通过中文API进行中文微控制器的编程。 对于其他所有人，制造商<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始将</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">micropython移植</a>到此模块。 我决定尝试一个开源项目，并继续进行这项出色的工作（本文结尾处的链接）。 </p><br><h1> 微型蟒蛇 </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9a1/b46/e00/9a1b46e00d290db2f478ebb54f7d9e74.jpg" alt="徽标"></p><br><p>  Micropython是一个将cPython移植到微控制器的开源项目。 开发是从两个方向进行的。 首先是对所有微控制器通用的核心库的支持和开发，这些库描述了如何使用python中的主要数据类型：对象，函数，类，字符串，原子类型等。 第二个实际上是端口：对于每个微控制器，有必要“教”该库以使用UART进行输入输出，为虚拟机选择堆栈，指定一组优化。 可选地，描述了与硬件一起使用：GPIO，电源，无线，文件系统。 <br> 所有这些都是用带有宏的纯C语言编写的：micropython有一组建议的配方，从在ROM中声明字符串到编写模块。 除此之外，还完全支持python自写模块（主要是不要忘记内存大小）。 该项目的策展人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将发布dzhanga</a> （带有面包的图片）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">机会</a>作为他们的目标。 作为广告：该项目为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pyboard</a>学生出售自己的开发板，但ESP8266和ESP32模块的端口也很受欢迎。 </p><br><p> 准备好固件并上载后-您只需通过UART连接到微控制器，然后进入Python REPL。 </p><br><pre> <code class="bash hljs">$ miniterm.py /dev/ttyUSB1 115200 --raw MicroPython cd2f742 on 2017-11-29; unicorn with Cortex-M3 Type <span class="hljs-string"><span class="hljs-string">"help()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) hello</code> </pre> <br><p> 之后，您可以开始<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用几乎普通的python3</a>编写代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>而不必担心内存限制。 </p><br><p>  A9G模块不受官方支持（ <code>micropython/ports</code>提供了官方支持的模块列表，其中大约有十二个）。 尽管如此，钢铁制造商分叉了micropython并为A9G端口创建了环境： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>micropython/ports/gprs_a9</code></a> ，为此，他表示了很多谢意。 当我对这个问题感兴趣时，该端口已成功编译，微控制器向我致敬REPL。 但是，不幸的是，在第三方模块中，只能使用文件系统和GPIO：没有与无线网络和GPS相关的内容。 我决定修复此缺陷，并为自己设定了移植GPS跟踪器所需的所有功能的目标。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a>案例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的官方文档</a>过于简洁：因此，我不得不在代码中四处张望。 </p><br><h2> 从哪里开始 </h2><br><p> 首先，转到<code>micropython/ports</code>然后将<code>micropython/ports/minimal</code>复制到端口将位于的新文件夹中。 然后，为您的平台编辑<code>main.c</code> 请记住，所有好吃的东西都在<code>main</code>函数中，您需要在其中调用<code>mp_init()</code>初始化器，之前已<code>mp_init()</code>准备了微控制器和堆栈设置。 然后，对于事件驱动的API，您需要调用<code>pyexec_event_repl_init()</code>并将通过UART输入的字符提供给<code>pyexec_event_repl_process_char(char)</code>函数。 这将通过REPL提供互操作性。 第二个文件是<code>micropython/ports/minimal/uart_core.c</code>描述了阻止UART中的输入和输出。 我为那些懒惰的人带来了STM32的原始代码。 </p><br><p> <code>main.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_dummy; stack_top = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)&amp;stack_dummy; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_GC gc_init(heap, heap + sizeof(heap)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> mp_init(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_COMPILER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_REPL_EVENT_DRIVEN pyexec_event_repl_init(); for (;;) { int c = mp_hal_stdin_rx_chr(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pyexec_event_repl_process_char(c)) { break; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pyexec_friendly_repl(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//do_str("print('hello world!', list(x+1 for x in range(10)), end='eol\\n')", MP_PARSE_SINGLE_INPUT); //do_str("for i in range(10):\r\n print(i)", MP_PARSE_FILE_INPUT); #else pyexec_frozen_module("frozentest.py"); #endif mp_deinit(); return 0; }</span></span></span></span></code> </pre> <br><p> <code>uart_core.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Receive single character int mp_hal_stdin_rx_chr(void) { unsigned char c = 0; #if MICROPY_MIN_USE_STDOUT int r = read(0, &amp;c, 1); (void)r; #elif MICROPY_MIN_USE_STM32_MCU // wait for RXNE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 5)) == 0) { } c = USART1-&gt;DR; #endif return c; } // Send string of given length void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) { #if MICROPY_MIN_USE_STDOUT int r = write(1, str, len); (void)r; #elif MICROPY_MIN_USE_STM32_MCU while (len--) { // wait for TXE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 7)) == 0) { } USART1-&gt;DR = *str++; } #endif }</span></span></code> </pre> <br><p> 之后，您需要使用制造商的建议/编译器重写Makefile：此处的所有操作都是单独的。 理想情况下，所有一切都应该足够：我们收集，填写固件，然后在UART中查看REPL。 <br> 恢复<code>micropython</code>您需要照顾好它的健康：设置垃圾收集器，对Ctrl-D的正确反应（软复位）以及其他我不愿<code>mpconfigport.h</code>其他事项：请参阅<code>mpconfigport.h</code>文件。 </p><br><h2> 创建一个模块 </h2><br><p> 最有趣的是编写自己的模块。 因此，模块（不是必需的，但可取的）以其自己的<code>mod[].c</code>文件开头，该文件由<code>Makefile</code>添加（如果遵循约定， <code>SRC_C</code>变量）。 空模块如下： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// nlr - non-local return:  C  ,      goto-  . //  nlr_raise             . #include "py/nlr.h" //   .  ,  mp_map_elem_t,  ,   . #include "py/obj.h" //   . mp_raise_ValueError(char* msg)  mp_raise_OSError(int errorcode)   . //  ,   mp_call_function_*     Callable (  callback-). #include "py/runtime.h" #include "py/binary.h" //  header   :       #include "portmodules.h" //    --  .     MP_QSTR_[ ]. MP_OBJ_NEW_QSTR   . //             RAM. //      -      __name__ STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, }; //      STATIC MP_DEFINE_CONST_DICT (mp_module_mymodule_globals, mymodule_globals_table); //   :             const mp_obj_module_t mp_module_mymodule = { .base = { &amp;mp_type_module }, .globals = (mp_obj_dict_t*)&amp;mp_module_mymodule_globals, };</span></span></code> </pre> <br><p> 当然，端口本身无法识别<code>mp_module_mymodule</code>常数：必须将其添加到<code>mpconfigport.h</code>端口<code>mpconfigport.h</code>的<code>MICROPY_PORT_BUILTIN_MODULES</code>变量中。 顺便说一句 <del> 无聊的壁纸 </del> 芯片名称和端口名称也在此处更改。 完成所有这些更改后，您可以尝试编译模块并从REPL导入它。 只有一个具有模块名称的<code>__name__</code>属性可用于该模块（这是通过Tab使用REPL检查自动完成的一种好方法）。 </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.__name__ <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span></code> </pre> <br><h2> 常数 </h2><br><p> 复杂性的下一个阶段是添加常量。 设置通常需要常量（ <code>INPUT</code> ， <code>OUTPUT</code> ， <code>HIGH</code> ， <code>LOW</code>等）。这里的一切都很简单。 例如，这里的常数<code>magic_number = 10</code> ： </p><br><pre> <code class="cpp hljs">STATIC <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mp_map_elem_t</span></span> mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, };</code> </pre> <br><p> 测试： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.magic_number <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><h2> 功能介绍 </h2><br><p> 向模块添加功能遵循以下一般原则：声明，包装，添加（我给出的示例比文档中的示例稍微复杂一些）。 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  STATIC mp_obj_t conditional_add_one(mp_obj_t value) { //   int.         -  :   . int value_int = mp_obj_get_int(value); value_int ++; if (value_int == 10) { //  None return mp_const_none; } //   int return mp_obj_new_int(value); } //    .     // runtime.h   . STATIC MP_DEFINE_CONST_FUN_OBJ_1(conditional_add_one_obj, conditional_add_one); //  STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, };</span></span></code> </pre> <br><p> 测试： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">9</span></span>) &gt;&gt;&gt;</code> </pre> <br><h2> 类（类型） </h2><br><p> 使用类（类型），一切也都相对简单。 这是文档中的一个示例（差不多）： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = {}; //   STATIC MP_DEFINE_CONST_DICT(mymodule_hello_locals_dict, mymodule_hello_locals_dict_table); // ,  ,   const mp_obj_type_t mymodule_helloObj_type = { //    { &amp;mp_type_type }, // : helloObj .name = MP_QSTR_helloObj, //  .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, }; //    STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;mymodule_helloObj_type }, };</span></span></code> </pre> <br><p> 测试： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>mymodule.helloObj &lt;type <span class="hljs-string"><span class="hljs-string">'helloObj'</span></span>&gt;</code> </pre> <br><p> 可以继承，比较结果类型，但是它没有构造函数或任何关联数据。 数据被添加到构造函数的“旁边”：建议创建一个单独的结构，在该结构中Python类型将被单独存储，即一个任意数据集。 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -. ,    typedef struct _mymodule_hello_obj_t { //   mp_obj_base_t base; // -  uint8_t hello_number; } mymodule_hello_obj_t;</span></span></code> </pre> <br><p> 如何与这些数据进行交互？ 最困难的方法之一是通过构造函数。 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// -,   (,  ,   mymodule_helloObj_type //   ,     - ),   (args  kwargs)  //        : args, kwargs STATIC mp_obj_t mymodule_hello_make_new( const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args ) { //    mp_arg_check_num(n_args, n_kw, 1, 1, true); //   mymodule_hello_obj_t *self = m_new_obj(mymodule_hello_obj_t); //     self-&gt;base.type = &amp;mymodule_hello_type; //   self-&gt;hello_number = mp_obj_get_int(args[0]) //   return MP_OBJ_FROM_PTR(self); //    __init__, ,  } //      make_new const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, //  .make_new = mymodule_hello_make_new, };</span></span></code> </pre> <br><p> 在其他领域中，还有<code>.print</code> ，我猜想<code>Python3</code>的其他魔力。 </p><br><p> 但是获取一个对象的实例根本不需要<code>make_new</code> ：初始化可以在任意函数中完成。 这是来自<code>micropython/ports/esp32/modsocket.c</code>一个好例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   :       STATIC mp_obj_t get_socket(size_t n_args, const mp_obj_t *args) { socket_obj_t *sock = m_new_obj_with_finaliser(socket_obj_t); sock-&gt;base.type = &amp;socket_type; sock-&gt;domain = AF_INET; sock-&gt;type = SOCK_STREAM; sock-&gt;proto = 0; sock-&gt;peer_closed = false; if (n_args &gt; 0) { sock-&gt;domain = mp_obj_get_int(args[0]); if (n_args &gt; 1) { sock-&gt;type = mp_obj_get_int(args[1]); if (n_args &gt; 2) { sock-&gt;proto = mp_obj_get_int(args[2]); } } } sock-&gt;fd = lwip_socket(sock-&gt;domain, sock-&gt;type, sock-&gt;proto); if (sock-&gt;fd &lt; 0) { exception_from_errno(errno); } _socket_settimeout(sock, UINT64_MAX); return MP_OBJ_FROM_PTR(sock); } //     0-3  STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(get_socket_obj, 0, 3, get_socket);</span></span></code> </pre> <br><h2> 绑定方法 </h2><br><p> 下一步是添加绑定方法。 但是，这与所有其他方法并没有太大区别。 我们从文档中返回示例： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    :     1 (self) STATIC mp_obj_t mymodule_hello_increment(mp_obj_t self_in) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); self-&gt;hello_number += 1; return mp_const_none; } //     MP_DEFINE_CONST_FUN_OBJ_1(mymodule_hello_increment_obj, mymodule_hello_increment); //      'inc' STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR_inc), (mp_obj_t)&amp;mymodule_hello_increment_obj }, }</span></span></code> </pre> <br><p> 仅此而已！ </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.inc()</code> </pre> <br><h2> 所有其他属性： <strong>getattr</strong> ， <strong>setattr</strong> </h2><br><p> 如何使用<code>@property</code>和通常使用自己的<code>__getattr__</code>添加非功能？ 请：通过绕过<code>mymodule_hello_locals_dict_table</code>手动完成。 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ... STATIC void mymodule_hello_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); if (dest[0] != MP_OBJ_NULL) { // __setattr__ if (attr == MP_QSTR_val) { self-&gt;val = dest[1]; dest[0] = MP_OBJ_NULL; } } else { // __getattr__ if (attr == MP_QSTR_val) { dest[0] = self-&gt;val; } } } // ...     attr const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, //     //.locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, .make_new = mymodule_hello_make_new, //   - attr .attr = mymodule_hello_attr, };</span></span></code> </pre><br><p> 您说，简明扼要的attr结果出乎意料。 这些<code>mp_raise_AttributeError</code>都在哪里（ <em>注意</em> ：这样的函数不存在）？ 实际上，将自动调用<code>AttributeError</code> 。 秘密在于<code>dest</code>是两个元素的数组。 第一个元素的含义是“输出”，仅写：如果需要写入该值，则取值<code>MP_OBJ_NULL</code>如果需要读取，则<code>MP_OBJ_NULL</code> 。 因此，在函数退出时，在第一种情况下期望<code>mp_obj_t</code> ，在第二种情况下期望<code>mp_obj_t</code> 。 输入的第二个元素是只读的：如果需要写入该值，则取要写入的对象的值；如果需要读取该值，则取<code>MP_OBJ_NULL</code> 。 您不需要更改它。 </p><br><p> 仅此而已，您可以检查： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.val = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; x.val <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p> 最有趣的是，REPL中的制表符<code>.val</code>仍然可以使用并提供<code>.val</code> ！ 老实说，我不是C语言方面的专家，所以我只能猜测这是怎么发生的（通过重新定义运算符'=='）。 </p><br><h2> 港口 </h2><br><p> 回到A9G模块，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述了</a>对所有基本功能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>支持，即SMS，GPRS（电子信号），GPS，电源管理。 现在，您可以将类似这样的内容上传到模块，并且可以正常工作： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cellular <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usocket <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> machine <span class="hljs-comment"><span class="hljs-comment">#   print("Waiting network registration ...") while not c.is_network_registered(): time.sleep(1) time.sleep(2) #  GPRS print("Activating ...") c.gprs_activate("internet", "", "") print("Local IP:", sock.get_local_ip()) #  GPS gps.on() #    thingspeak host = "api.thingspeak.com" api_key = "some-api-key" fields = ('latitude', 'longitude', 'battery', 'sat_visible', 'sat_tracked') #  ,      ! fields = dict(zip(fields, map(lambda x: "field{}".format(x+1), range(len(fields))) )) x, y = gps.get_location() level = machine.get_input_voltage()[1] sats_vis, sats_tracked = gps.get_satellites() s = sock.socket() print("Connecting ...") s.connect((host, 80)) print("Sending ...") #      ,     HTTP.           HTTP, SSL   print("Sent:", s.send("GET /update?api_key={}&amp;{latitude}={:f}&amp;{longitude}={:f}&amp;{battery}={:f}&amp;{sat_visible}={:d}&amp;{sat_tracked}={:d} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n".format( api_key, x, y, level, sats_vis, sats_tracked, host, **fields ))) print("Receiving ...") print("Received:", s.recv(128)) s.close()</span></span></code> </pre> <br><p> 该项目欢迎任何可行的帮助。 如果您喜欢该项目和/或本文，请不要忘记<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在github上</a>留下一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">赞</a> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446090/">https://habr.com/ru/post/zh-CN446090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446078/index.html">“声音”：讨论有关音频技术的播客</a></li>
<li><a href="../zh-CN446080/index.html">在美国，法院建议禁止进口某些型号的iPhone，因为它们侵犯了高通公司的苹果专利</a></li>
<li><a href="../zh-CN446082/index.html">半环的故事</a></li>
<li><a href="../zh-CN446086/index.html">Linux历史。 第三部分：新市场和旧“敌人”</a></li>
<li><a href="../zh-CN446088/index.html">我在2018年不知道的事情</a></li>
<li><a href="../zh-CN446092/index.html">只有没有双手！ 不重复用户操作的机器人</a></li>
<li><a href="../zh-CN446094/index.html">有生命周期表</a></li>
<li><a href="../zh-CN446096/index.html">《 TasteVill：如何使零售业发生革命，做错一切》</a></li>
<li><a href="../zh-CN446098/index.html">苏联时代的“东方号”和“日出号”飞行控制中心</a></li>
<li><a href="../zh-CN446100/index.html">通过Excel电子表格自动创建Android和iOS本地化文件</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>