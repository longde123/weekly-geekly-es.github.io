<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔬 ⛄️ 🐐 La lucha duradera de la escritura estática frente a la dinámica: TypeScript no ayudará 🤳 ⛸️ 👌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando mi amigo y yo estábamos en edad escolar y aspiramos a convertirnos en desarrolladores de software, soñamos con diseñar algunas cosas interesant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La lucha duradera de la escritura estática frente a la dinámica: TypeScript no ayudará</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437844/"><img src="https://habrastorage.org/webt/jz/qg/1v/jzqg1vxfdtewttliutkgjao5nv8.jpeg"><br><br>  Cuando mi amigo y yo estábamos en edad escolar y aspiramos a convertirnos en desarrolladores de software, soñamos con diseñar algunas cosas interesantes juntas, como un juego o una aplicación mega útil. <br><br>  Elegí aprender C ++ y C #, eligió JavaScript.  Terminamos la escuela, nos graduamos de nuestras universidades, servimos en el ejército y comenzamos nuestros trabajos.  Tuvimos un tiempo bastante ocupado en ingeniería de software industrial, con muchos trabajos y puestos diferentes, y después de que todo comenzó a desgastarnos, recordamos dónde había comenzado todo. <br><br>  Después de reunirnos finalmente como desarrolladores maduros, decidimos trabajar en nuestro propio proyecto: un videojuego en 2D.  Como el dominio de mi amigo era front-end y yo era un desarrollador completo, nuestra elección inmediata de plataforma de desarrollo fue un navegador de Internet.  Como solo estaba acostumbrado a trabajar con TypeScript cuando diseñaba front-end, pensamos, ok, no hay problema, después de todo, TS es solo JavaScript a escala.  Usémoslo y las cosas saldrán bien.  ¡Si supiera lo equivocado que estaba!  Cuando comenzamos a discutir el proyecto, nos encontramos con un gran abismo de malentendidos entre nosotros. <br><a name="habracut"></a><br>  Aquí estaba mi visión del juego.  Estaba como, ok, tenemos tipos como juego, herramienta, elemento, mapa, ubicación.  Tengo una comprensión básica de cómo funcionan juntos, así que los describo, compilo el proyecto y funciona.  Después de todo, el compilador ha verificado mi código, y lo hice bien.  Luego, comienzo a escribir código que usa esos tipos.  Me hacen la vida mucho más fácil.  Mi IDE me da información sobre herramientas y comprueba cualquier error.  Si se puede compilar un proyecto, probablemente funcione.  Pasé algo de esfuerzo en la descripción del tipo y arrojó resultados.  Ese es mi enfoque en pocas palabras. <br><br>  Mi amigo tuvo la idea opuesta: saltar a la escritura de códigos de inmediato sin tomarse el tiempo para describir los tipos.  No estaba listo para definir el problema como una familia de tipos.  No estaba interesado en usarlo como base, ya que no veía el problema como un conjunto de clases, tipos, registros de nada por el estilo.  Pensé que era inconcebible.  Ambos teníamos un punto, es solo que nuestros puntos eran mutuamente excluyentes. <br><br>  En serio, estuvimos hablando durante horas, pero cada uno decía lo suyo, como si estuviéramos hablando idiomas diferentes.  Eso sí, no podría culparnos de que estemos atrapados en nuestras viejas costumbres.  Hace apenas un año, migré sin problemas del mundo de la programación orientada a objetos al mundo de la programación funcional y viceversa.  Además, pasé bastante tiempo aprendiendo JS, y él, aprendiendo varios idiomas estáticamente escritos. <br><br>  Sin embargo, para cualquier desarrollador, la tecnología que usaron para su primer trabajo real a menudo los define en la medida en que dos adultos experimentados simplemente carecen de la paciencia para escucharse mutuamente.  Durante estos años de ingeniería de software, nuestras visiones se formaron de maneras tan diferentes que nuestros enfoques para la resolución de problemas simplemente no encajaban bien. <br><br>  Al final abandonamos la idea de trabajar en equipo.  Su primera respuesta podría ser que el problema estaba en nuestras personalidades.  Puede que tengas razón, pero también vi que esto le sucedía a otros en la industria. <br><br><h2>  La diferencia fundamental e irreconciliable entre tipeo estático y dinámico </h2><br>  Mi código proporciona la solución al problema de cómo trabajar con él, mientras que el código de defensores de la escritura dinámica experimentada resuelve el problema de cómo funciona.  Ambas mentalidades son legítimas y están respaldadas por las herramientas existentes, pero solo una puede tener la máxima prioridad en cualquier momento. <br><br>  La escritura estática es buena para proyectos a gran escala que involucran a cientos de desarrolladores que trabajan en ellos durante años, mientras que la escritura dinámica es buena para equipos y proyectos más pequeños que a menudo requieren código de solo escritura.  La escritura dinámica le permite ahorrar tiempo y esfuerzos al comienzo del desarrollo, mientras que la escritura estática le da un impulso al final. <br><br>  La idea de poner los tipos primero ha afectado seriamente mi pensamiento como desarrollador.  Después de haber elegido C # al comienzo de mi carrera, tengo una escritura estática codificada en mi mentalidad, y ahora estoy pagando el precio de esta inflexibilidad.  Una vez que veo una tarea, trato de imaginar su solución como un conjunto de tipos y reglas de su relación.  Cuando estoy desarrollando un módulo, mi primer paso es definir los tipos que opera y usa para interactuar con su entorno.  Simplemente no recuerdo cómo solía resolver problemas antes de eso. <br><br>  Todo el proceso de aprender a programar en Java se trata de aprender a diseñar y usar tipos.  .NET CLR, el tiempo de ejecución de C #, se basa en tipos y para tipos.  La escritura estática se encuentra en el núcleo del paradigma de programación orientada a objetos (hola, clases JS, decidí darle un descanso).  Las implementaciones canónicas de la mayoría de los patrones OOP están saturadas con la palabra clave Interface, lo que no tiene ningún sentido en un lenguaje de tipo dinámico. <br><br>  Los patrones de diseño en sí mismos son conceptos de lenguaje cruzado, pero ¿alguien puede decirme por qué demonios necesitaría el patrón de estado en un lenguaje de tipo dinámico?  ¿Qué hay de Builder?  Estos patrones no tienen nada que ver con el desarrollo, son principalmente sobre tipos.  Los tipos y OOP tienen un vínculo estrecho. <br><br>  No puede construir su lógica de negocios en los tipos y, sin embargo, no sabe nada sobre ellos cuando comienza a escribir código.  Es por eso que tenemos desarrolladores front-end que arman su código con una increíble cantidad de pruebas unitarias que verifican específicamente la base del código para detectar cualquier tipo de error. <br>  Todos sabemos que la protección basada en la cobertura del código es una ilusión.  Las pruebas se escriben manualmente y, por definición, son menos confiables que el sistema incorporado de verificación de tipos disponible en el idioma. <br><br>  No significa que los idiomas escritos dinámicamente no tengan sentido (aunque confieso que creo que no).  Significa que, al usarlos, debe alejarse de OOP como paradigma dominante.  Toda esta unidad de datos y operaciones basadas en datos es para personas que tienen mecanografía estática. <br><br>  Los desarrolladores con los que me he encontrado no creen que el tipeo estático afecte la forma de codificación en ninguna medida, por lo que simplemente escriben su código como si estuvieran usando un lenguaje dinámico, solo que agregan la verificación de tipo.  Creo que esto es inherentemente incorrecto.  Es especialmente obvio en el caso del front-end moderno. <br><blockquote>  Lo sé, lo sé, hay un tabú para criticar a los desarrolladores front-end.  Mi amigo y yo una vez armamos un robot de inteligencia artificial que controlaba a los usuarios de Twitter, y conseguimos que Brendan Eich lo atacara.  En serio, el creador de JavaScript tuvo un intercambio de comentarios con nuestra red neuronal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/q2/nv/u4q2nvwd7uu-sakanme5nqbqe0u.jpeg"></div><br><br>  Por alguna razón, estos tipos simplemente no están listos para vivir en un mundo donde su visión tiene deficiencias tangibles.  Es por eso que critico solo a aquellos de ellos que manipulan mi proyecto definitivamente tipado para reelaborarlo de una manera relajada, "De cualquier manera". </blockquote><br><h2>  Seguiríamos viviendo en nuestros pequeños mundos, pero TypeScript nos unió </h2><br>  Tómeme por ejemplo: debido a las restricciones de tipo, mi código es imposible de usar incorrectamente.  Cuando estoy trabajando en un proyecto, confío en que otros también usen tipos.  Entonces mi código funcionará tal como está diseñado.  Por lo tanto, deliberadamente no cubro todos los casos en los que este código se puede usar incorrectamente (porque escribir lo hace imposible).  Pero luego un desarrollador de JS se une a mi proyecto, toma mi tipo, lo envuelve en Any y comienza a usarlo incorrectamente, lo que resulta en errores difíciles de replicar. <br><br>  Los desarrolladores de JavaScript confían en que TypeScript es el mismo JS anterior, pero con una opción para agregar verificaciones de tipo estático en caso de que las necesiten.  Esto esta mal.  TypeScript es cien veces más poderoso, pero solo están interesados ​​en una fracción de su potencial. <br><br>  Su argumento asesino es que TypeScript es solo un superconjunto de JS.  En la práctica, uno no puede ignorar el hecho de que TypeScript es un lenguaje independiente, incluso si uno es un maldito rey del front-end.  Porque requiere un enfoque diferente: el de verificación estática, no dinámica. <br><br>  El principal beneficio del tipeo estático es que le brinda garantías.  Si lo usa en un módulo y elige no usarlo en otro, entonces solo pierde su tiempo y energía en describir y diseñar esos tipos, sin obtener ninguna garantía. <br><br>  Muchos piensan que TypeScript es un compromiso de los sistemas de tipos entre JS y Java.  Bueno, no es un compromiso de ningún tipo, tiene un sistema de tipo especial propio. <br><br>  Lo peor de todo es que hoy en día uno de cada dos puestos frontales requiere dominio de TypeScript.  Esto estimula a los desarrolladores de JS a echar un vistazo a las características de TypeScript e inmediatamente saltar a escribir código en él, generando una proliferación de prácticas dañinas.  Las situaciones ocurren cuando realmente no necesitan una verificación de tipo estático, pero se les impuso un poco, por lo que se metieron con eso.  Necesitamos finalmente reconocer que los enfoques de programación con tipeo estático vs dinámico están en conflicto entre sí y no se pueden mezclar. <br><br>  Veo JavaScript como una gran herramienta para escribir código de pirateo rápido que proporciona soluciones sin resolver abstracciones innecesarias.  El ejemplo más escandaloso aquí es el patrón Ice Factory.  Puede alimentar sus instancias y las envolverá en la inmutabilidad de tiempo de ejecución.  Si proceso mi objeto a través de dicha fábrica, devolverá su equivalente, pero si trato de cambiar una de sus propiedades, arrojará una excepción.  WAT?!? <br><br>  El patrón surgió porque los desarrolladores front-end escucharon en algún lugar sobre la inmutabilidad genial, por lo que decidieron arrastrar esta mierda a su idioma, que lo necesita como un agujero en la cabeza.  En TypeScript, puedo diseñar una fábrica similar, pero con una restricción en el tiempo de compilación de mutaciones y sin ninguna excepción. <br><br>  Por otro lado, apenas necesito esto porque existe la programación funcional pura.  Tomemos F #, Haskell, OCaml, Clojure, ReasonML, por ejemplo: tienen una prohibición de mutabilidad lista para usar.  Pero algo me dice que si un desarrollador front-end pone sus manos en un lenguaje funcional, estará dispuesto a actualizarlo para que su comportamiento sea similar al de JavaScript. <br><br>  Eso es porque elegir tu religión de mecanografía es un boleto de ida.  Todas las soluciones intermedias proporcionan una ilusión de compromiso.  O confías en los tipos o no.  No sé si mi vida sería diferente si hubiera comenzado a aprender C # y JavaScript en paralelo.  Hoy estoy tan desesperadamente identificándome con mi mentalidad que simplemente no veo ninguna ventaja de la escritura dinámica (y no deseo verlas).  Existen, solo fuera de mi rango de visibilidad, por lo que todo lo que puedo hacer es cerrar los ojos ante ellos como lo hago ante cualquier fenómeno que tenga que soportar en este mundo.  Sé que estoy equivocado, pero tengo que trabajar aquí y ahora, y no tengo el presupuesto para seguir sentado en la cerca. <br><br>  Así que no quiero buscar compromisos, en su lugar lo aclararé.  Si solo está dando sus primeros pasos en el desarrollo, ¡comience con la escritura estática! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437844/">https://habr.com/ru/post/437844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437832/index.html">Código abierto: código de humor, trucos de código, NO código</a></li>
<li><a href="../437834/index.html">Dos historias sobre cómo tuvieron lugar los eventos de programación en Ekaterimburgo</a></li>
<li><a href="../437836/index.html">Under the hood Screeps: virtualización en el sandbox MMO para programadores</a></li>
<li><a href="../437838/index.html">Las tecnologías de aprendizaje automático aceleran el proceso de adaptación de los pacientes a las prótesis biónicas a veces</a></li>
<li><a href="../437842/index.html">La historia secreta de Donkey Kong: de máquinas recreativas a NES</a></li>
<li><a href="../437846/index.html">bobaoskit - accesorios, dnssd y WebSocket</a></li>
<li><a href="../437848/index.html">Hacemos que el proceso de desarrollo de software pesado para microcontroladores sea más conveniente (no)</a></li>
<li><a href="../437850/index.html">¿Quién es más efectivo en el diseño de PCB?</a></li>
<li><a href="../437852/index.html">Historia de Shipastik</a></li>
<li><a href="../437858/index.html">Conferencias adicionales del curso "Diseño de sistemas altamente cargados" (otoño de 2018) en Technopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>