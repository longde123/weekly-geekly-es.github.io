<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèΩ üíáüèº üë© Incorporation d√©fectueuse de fonctions dans Go üë®üèø‚Äçüíº üíó üë®üèø‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le code ci-dessous est-il √©quivalent en termes de performances? 


// (A). HasPrefix . return strings.HasPrefix(s, "#") // (B). HasPrefix. return len(...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Incorporation d√©fectueuse de fonctions dans Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438636/"><p><img src="https://habrastorage.org/webt/lm/rt/rk/lmrtrkww5knurdsaznutrksterk.jpeg"></p><br><p>  Le code ci-dessous est-il √©quivalent en termes de performances? </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// (A).  HasPrefix  . return strings.HasPrefix(s, "#") // (B).    HasPrefix. return len(s) &gt;= len("#") &amp;&amp; s[:len("#")] == "#"</span></span></code> </pre> <br><p>  La r√©ponse est <strong>non</strong> . </p><br><p>  Pour plus de d√©tails et d'explications, je demande sous cat. </p><a name="habracut"></a><br><hr><br><p>  Bonjour, avant d'ouvrir le sujet, je voudrais me pr√©senter. <br>  Je m'appelle Iskander et de temps en temps j'envoie des commits au d√©p√¥t <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golang / go</a> . </p><br><img src="https://habrastorage.org/webt/ls/jy/t3/lsjyt3z-jg1l5dx2nlecj17lbks.png" alt="image" align="left"><br><p>  J'avais l'habitude de le faire au nom de l'√©quipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel Go</a> , mais nos chemins divergeaient et maintenant je suis un contributeur ind√©pendant.  R√©cemment, j'ai travaill√© en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vk</a> dans l'√©quipe infrastructure. </p><br><p>  Pendant mon temps libre, je cr√©e diff√©rents outils pour Go, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Go-Critic</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Go-consistent</a> .  Je <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dessine</a> √©galement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gaufres</a> . </p><br><p><br></p><br><h1 id="measure-it">  Mesurez-le! </h1><br><p>  Proc√©dez imm√©diatement √† la comparaison et d√©finissez la r√©f√©rence: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"#string"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"#"</span></span>) _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"x"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixInlined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"#"</span></span> _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"x"</span></span> } }</code> </pre> <br><p>  Au lieu de vous recommander <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">benchstat</a> , je vais vous montrer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">benchrun</a> . </p><br><p>  Avec une seule commande, nous pouvons ex√©cuter les deux benchmarks et obtenir une comparaison: </p><br><pre> <code class="bash hljs">go-benchrun HasPrefixCall HasPrefixInlined -v -count=10 . Benchstat results: name old time/op new time/op delta HasPrefixCall-8 9.15ns ¬± 1% 0.36ns ¬± 3% -96.09% (p=0.000 n=10+9)</code> </pre> <br><p>  L'option avec incorporation manuelle est beaucoup plus rapide que le code obtenu en incorporant le corps de la fonction avec le compilateur.  Essayons de comprendre pourquoi cela se produit. </p><br><h1 id="stringshasprefix">  strings.HasPrefix </h1><br><p>  Rappelez l'impl√©mentation des <code>strings.HasPrefix</code> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HasPrefix tests whether the string s begins with prefix. func HasPrefix(s, prefix string) bool { return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix }</span></span></code> </pre> <br><p>  La fonction <code>HasPrefix</code> int√©gr√©e par le compilateur. <br>  Vous pouvez le v√©rifier comme suit: </p><br><pre> <code class="bash hljs">go build -gcflags=<span class="hljs-string"><span class="hljs-string">'-m=2'</span></span> strings 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'can inline HasPrefix'</span></span></code> </pre> <br><p>  Pour appeler <code>strings.HasPrefix</code> partir de l'option <code>(A)</code> nous obtenons le code machine suivant: </p><br><pre> <code class="plaintext hljs"> MOVQ (TLS), CX CMPQ SP, 16(CX) JLS more_stack fn_body: SUBQ $40, SP MOVQ BP, 32(SP) LEAQ 32(SP), BP XCHGL AX, AX MOVQ s+56(SP), AX CMPQ AX, $1 JGE compare_strings XORL AX, AX MOVB AL, ~ret1+64(SP) MOVQ 32(SP), BP ADDQ $40, SP return: RET compare_strings: MOVQ s+48(SP), AX MOVQ AX, (SP) LEAQ go.string."#"(SB), AX MOVQ AX, 8(SP) MOVQ $1, 16(SP) CALL runtime.memequal(SB) MOVBLZX 24(SP), AX JMP return more_stack: CALL runtime.morestack_noctxt(SB) JMP fn_body</code> </pre> <br><p>  Ignorez le fait que le code ressemble √† des nouilles. </p><br><p>  √Ä quoi devez-vous faire attention: </p><br><ul><li>  <code>strings.HasPrefix</code> vraiment √©t√© ins√©r√©, aucun appel. </li><li>  Pour comparer des cha√Ænes, <code>runtime.memequal</code> est <code>runtime.memequal</code> . </li></ul><br><p>  Mais qu'est-ce qui est alors g√©n√©r√© pour la version int√©gr√©e manuellement, le code de l'exemple <code>(B)</code> ? </p><br><pre> <code class="plaintext hljs"> MOVQ s+16(SP), AX CMPQ AX, $1 JLT different_length MOVQ s+8(SP), AX CMPB (AX), $35 // 35 -   "#" SETEQ AL return: MOVB AL, "".~ret1+24(SP) RET different_length: XORL AX, AX JMP 22</code> </pre> <br><p>  Et ici, le compilateur ne g√©n√®re pas d'appel √† <code>runtime.memequal</code> et un seul caract√®re est compar√© directement.  Id√©alement, il aurait d√ª faire de m√™me pour la premi√®re option. </p><br><p>  Nous observons le c√¥t√© faible de l'optimiseur Go, et nous l'analysons. </p><br><h1 id="optimizacii-konstantnyh-vyrazheniy">  Optimisation de l'expression constante </h1><br><p>  La raison pour laquelle l'appel de <code>strings.HasPrefix(s, "#")</code> peut √™tre optimis√© est que l'argument pr√©fixe est une constante.  Nous connaissons sa longueur et son contenu.  Cela n'a aucun sens d'appeler <code>runtime.memequal</code> pour les cha√Ænes courtes, il est plus rapide de faire une comparaison des caract√®res "en place", en √©vitant un appel suppl√©mentaire. </p><br><p>  Comme vous le savez, les compilateurs ont g√©n√©ralement au moins deux parties: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">frontend du</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilateur</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">backend du compilateur</a> .  Le premier fonctionne avec une vue de niveau sup√©rieur, le second est plus proche de la machine et la vue interm√©diaire ressemblera √† un flux d'instructions.  Plusieurs versions de Go ont d√©j√† utilis√© la repr√©sentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSA</a> pour les optimisations dans la partie backend du compilateur. </p><br><p>  Le pliage constant, tel que <code>{10*2 =&gt; 20}</code> , est impl√©ment√© dans le backend.  En g√©n√©ral, la plupart des op√©rations associ√©es √† la r√©duction du co√ªt de calcul des expressions se trouvent dans cette partie du compilateur.  Mais il y a des exceptions. </p><br><p>  Une exception est l'optimisation des comparaisons de cha√Ænes constantes.  Lorsque le compilateur voit une comparaison de cha√Æne (ou de sous-cha√Æne) dans laquelle l'un ou les deux op√©randes sont des constantes, un code plus efficace est g√©n√©r√© qu'un appel √† <code>runtime.memequal</code> . </p><br><p>  Vous pouvez voir le code source responsable de cela dans le fichier <a href="">cmd / compile / internal / gc / walk.go: 3362</a> . </p><br><p>  L'incorporation de fonctions se produit avant le lancement de ces optimisations, mais √©galement dans la partie frontend du compilateur. </p><br><p>  Il semblerait tout de m√™me que cette optimisation ne fonctionne pas dans notre cas? </p><br><h1 id="kak-go-vstraivaet-vyzovy-funkciy">  Comment Go int√®gre les appels de fonction </h1><br><p>  Voici comment l'incorporation se produira: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    : return strings.HasPrefix(s, "#") //  : func HasPrefix(s, prefix string) bool //    : _s, _prefix := s, "#" return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix</span></span></code> </pre> <br><p>  Lors de l'incorporation de fonctions, le compilateur attribue des arguments aux variables temporaires, ce qui rompt les optimisations, car l'algorithme dans <a href="">walk.go</a> ne voit pas les constantes, mais les arguments avec des variables.  Voil√† le probl√®me. </p><br><p>  Soit dit en passant, cela n'interf√®re pas avec les optimisations de backend que le SSA a √† sa disposition.  Mais il y a d'autres probl√®mes, par exemple, l'impossibilit√© de restaurer des constructions de langage de haut niveau pour leur comparaison efficace (le travail pour √©liminer cet inconv√©nient est ¬´pr√©vu¬ª depuis plusieurs ann√©es). </p><br><h1 id="eschyo-odin-primer-escape-analysis">  Un autre exemple: l'analyse d'√©chappement </h1><br><p>  Imaginez une fonction qui est importante pour allouer un tampon temporaire sur la pile: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">// buf    //    . return nil }</span></span></code> </pre> <br><p>  Puisque <code>buf</code> ne "s'ex√©cute" pas, le compilateur peut allouer ces 16 octets sur la pile, sans allouer sur le tas.  Encore une fois, tout cela gr√¢ce √† la valeur constante lors de l'appel de <code>make</code> .  Pour allouer de la m√©moire sur la pile, il est important pour nous de conna√Ætre la taille requise, qui fera partie de la trame allou√©e √† l'appel de fonction. </p><br><p>  Supposons √† l'avenir que nous voulions allouer des tampons temporaires de diff√©rentes tailles et encapsuler une logique dans les m√©thodes.  Nous avons introduit une nouvelle abstraction et d√©cid√© d'utiliser le nouveau type <code>tmpBuf</code> .  La fonction de conception est extr√™mement simple: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTmpBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeHint </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmpBuf</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmpBuf{buf: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeHint)} }</code> </pre> <br><p>  Adaptation de l'exemple d'origine: </p><br><pre> <code class="diff hljs">func businessLogic() error { - buf := make([]byte, 0, 16) + buf := newTmpBuf(16) // buf    //    . return nil }</code> </pre> <br><p>  Le constructeur sera incorpor√©, mais l'allocation sera d√©sormais toujours sur le tas, pour la m√™me raison que les arguments sont pass√©s via des variables temporaires.  L'analyse d'√©chappement verra <code>make([]byte, 0, _sizeHint)</code> qui ne correspond pas √† ses mod√®les de reconnaissance pour <code>make</code> appels <code>make</code> optimis√©s. </p><br><p>  Si nous avions ¬´tout est comme des √™tres humains¬ª, le probl√®me n'existerait pas, apr√®s avoir <code>newTmpBuf</code> constructeur <code>newTmpBuf</code> il serait clair que la taille est toujours connue au stade de la compilation. </p><br><p>  Cela d√©range presque plus que la situation en comparant les cha√Ænes. </p><br><h1 id="gorizonty-go-113">  Horizons Go 1.13 </h1><br><p>  La situation peut √™tre assez facilement corrig√©e et j'ai d√©j√† envoy√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie de la d√©cision</a> . </p><br><img src="https://habrastorage.org/webt/uv/gv/16/uvgv16e70jy6qdip9wju_vqzvog.png" alt="image" align="left"><br><p>  Si vous pensez que le probl√®me d√©crit dans l'article a vraiment besoin d'une solution, veuillez mettre un coup de pouce dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me correspondant</a> . </p><br><p></p><hr><br><br><p>  Ma position est que l'incorporation de code avec vos mains simplement parce qu'il fonctionne plus rapidement dans la version actuelle de Go est erron√©e.  Il est n√©cessaire de corriger ce d√©faut dans l'optimiseur, au moins au point o√π les exemples d√©crits ci-dessus fonctionnent sans r√©gressions de performances inattendues. </p><br><p>  Si tout se d√©roule comme pr√©vu, cette optimisation sera incluse dans la version Go 1.13. </p><br><p>  Merci de votre attention. </p><br><h1 id="dopolnenie-predlozhennoe-reshenie">  Addition: solution propos√©e </h1><br><p>  Cette section s'adresse aux plus courageux, √† ceux qui ne se lassent pas de lire. </p><br><p>  Nous avons donc plusieurs endroits qui fonctionnent moins bien lors de l'utilisation directe de variables au lieu de leurs valeurs.  La solution propos√©e est d'introduire une nouvelle fonction dans le frontend de la partie compilateur, qui vous permet d'obtenir la derni√®re valeur li√©e par nom.  Apr√®s cela, dans chaque optimisation qui attend une valeur constante, n'abandonnez pas lorsqu'une variable est d√©tect√©e, mais recevez cet √©tat pr√©c√©demment enregistr√©. </p><br><p>  La signature de notre nouvelle fonctionnalit√© pourrait ressembler √† ceci: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre> <br><p>  La d√©finition de <code>Node</code> se trouve dans le fichier <a href="">syntax.go</a> . </p><br><p>  Chaque d√©finition de variable a une balise <code>Node</code> avec une balise <code>ONAME</code> .  Dans <code>Node.Name.Defn</code> plupart de ces variables ont une valeur d'initialisation. </p><br><p>  Si <code>Node</code> d√©j√† un litt√©ral, vous n'avez rien √† faire et nous renvoyons simplement <code>n</code> .  S'il s'agit de <code>ONAME</code> (variable), vous pouvez essayer d'extraire la m√™me valeur d'initialisation de <code>n.Name.Defn</code> . </p><br><p>  Mais qu'en est-il des modifications entre d√©clarer et lire une variable pour laquelle nous appelons <code>getConstValue</code> ?  Si nous nous limitons aux variables en lecture seule, alors il n'y a pas de probl√®me.  Le frontend de Go a d√©j√† des drapeaux de n≈ìuds sp√©ciaux qui marquent des noms similaires.  Si la variable a √©t√© modifi√©e, <code>getConstValue</code> ne renverra pas de valeur d'initialisation. </p><br><p>  Les programmeurs, en r√®gle g√©n√©rale, ne modifient pas les arguments d'entr√©e des types num√©riques et cha√Ænes, ce qui permet de couvrir un nombre assez important de cas avec cet algorithme primitif. </p><br><p>  Nous sommes maintenant pr√™ts √† envisager la mise en ≈ìuvre: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ONAME    definition. if n.Op != ONAME || n.Name.Defn == nil { return n } //   ,     . // ,    ,     //      escape analysis' . maybeModified := n.Assigned() || n.Name.Defn.Assigned() || n.Addrtaken() if maybeModified { return n } // OAS - Node  . // n.Name.Defn.Left -  LHS. // n.Name.Defn.Right -  RHS. // consttype(v)     . //   CTxxx,      . if n.Name.Defn.Op == OAS { v := n.Name.Defn.Right if v != nil &amp;&amp; consttype(v) != CTxxx { return v } } return n }</span></span></code> </pre> <br><p>  Voici comment le code change, qui d√©pend des constantes: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- i := indexconst(r) + i := indexconst(getConstValue(r))</span></span></code> </pre> <br><p>  Super, et √ßa marche m√™me: </p><br><pre> <code class="go hljs">n := <span class="hljs-number"><span class="hljs-number">10</span></span> xs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, n) <span class="hljs-comment"><span class="hljs-comment">//     !</span></span></code> </pre> <br><p>  Avant ce changement, l'analyse d'√©chappement ne pouvait pas obtenir la valeur <code>10</code> √† <code>n</code> , c'est pourquoi j'ai fait une hypoth√®se sur la n√©cessit√© de placer <code>xs</code> sur le tas. </p><br><p>  Le code ci-dessus est syntaxiquement similaire √† la situation observ√©e lors de l'incorporation.  <code>n</code> peut √™tre une variable temporaire qui est ajout√©e lorsque l'argument est pass√©. </p><br><p>  Malheureusement, il y a des nuances. </p><br><p>  Nous avons r√©solu le probl√®me des variables locales introduites via <a href="">OAS</a> , mais Go initialise les variables des fonctions <a href="">int√©gr√©es</a> via <a href="">OAS2</a> .  Pour cette raison, nous avons besoin d'un deuxi√®me changement qui √©tend la fonction <code>getConstValue</code> et modifie l√©g√®rement le code de l'inliner lui-m√™me, car, entre autres, <code>OAS2</code> n'a pas de champ <code>Defn</code> appropri√©. </p><br><p>  C'√©tait une mauvaise nouvelle.  Bonne nouvelle: la cha√Æne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#gocontributing</a> est apparue dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langue russe</a> , o√π vous pouvez partager vos id√©es et vos plans, poser des questions et discuter de tout ce qui concerne la participation au d√©veloppement de Go. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438636/">https://habr.com/ru/post/fr438636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438626/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 284 (28 janvier - 3 f√©vrier)</a></li>
<li><a href="../fr438628/index.html">Notification d'√©tat de changement de composant SharedState</a></li>
<li><a href="../fr438630/index.html">Google+ Sic transit gloria mundi ...</a></li>
<li><a href="../fr438632/index.html">Hardcore 2D RPG Gamedev Diaries, vol.0 - INTRO, ou "Comment je suis arriv√© ici"</a></li>
<li><a href="../fr438634/index.html">Dans les bureaux, il fait trop chaud ou trop froid: existe-t-il une meilleure fa√ßon de r√©gler la temp√©rature?</a></li>
<li><a href="../fr438638/index.html">Nous analysons le protocole des messages pager POCSAG, partie 2</a></li>
<li><a href="../fr438640/index.html">Monnaie √©lectronique ouverte √† grande vitesse</a></li>
<li><a href="../fr438642/index.html">Les bases de la programmation r√©active √† l'aide de RxJS</a></li>
<li><a href="../fr438644/index.html">La s√©curit√© des algorithmes d'apprentissage automatique. Protection et test de mod√®les √† l'aide de Python</a></li>
<li><a href="../fr438646/index.html">√Ä propos de la cr√©ation d'images st√©r√©o √† petit budget sur les doigts (st√©r√©ogramme, anaglyphe, st√©r√©oscope)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>