<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèª üåæ ‚ûø Caracter√≠sticas del uso del tipo de datos Symbol en JavaScript ‚Ü©Ô∏è üíç ü¶à</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las primitivas de caracteres son una de las innovaciones del est√°ndar ES6, que trajo algunas caracter√≠sticas valiosas a JavaScript. Los s√≠mbolos repre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caracter√≠sticas del uso del tipo de datos Symbol en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444340/">  Las primitivas de caracteres son una de las innovaciones del est√°ndar ES6, que trajo algunas caracter√≠sticas valiosas a JavaScript.  Los s√≠mbolos representados por el tipo de datos S√≠mbolo son especialmente √∫tiles cuando se usan como identificadores para las propiedades del objeto.  En relaci√≥n con tal escenario de su aplicaci√≥n, surge la pregunta de qu√© pueden y qu√© no pueden hacer las l√≠neas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/iz/wl/9d/izwl9dqxozauowr9lu69j04rvyo.jpeg"></a> <br><br>  En el material, cuya traducci√≥n publicamos hoy, hablaremos sobre el tipo de datos Symbol en JavaScript.  Comenzaremos revisando algunas de las funciones de JavaScript que necesita navegar para manejar los s√≠mbolos. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Informaci√≥n preliminar</font> </h2><br>  En JavaScript, de hecho, hay dos tipos de valores.  El primer tipo - valores primitivos, el segundo - objeto (tambi√©n incluyen funciones).  Los valores primitivos incluyen tipos de datos simples como n√∫meros (esto incluye todo, desde n√∫meros enteros hasta n√∫meros de coma flotante, valores <code>Infinity</code> y <code>NaN</code> ), valores l√≥gicos, cadenas, valores <code>undefined</code> y <code>null</code> .  Tenga en cuenta que mientras se verifica <code>typeof null === 'object'</code> produce <code>true</code> , <code>null</code> es un valor primitivo. <br><br>  Los valores primitivos son inmutables.  No pueden ser cambiados.  Por supuesto, puede escribir algo nuevo en una variable que almacene un valor primitivo.  Por ejemplo, esto escribe un nuevo valor en la variable <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x++;</code> </pre> <br>  Pero al mismo tiempo, no hay cambio (mutaci√≥n) del valor num√©rico primitivo <code>1</code> . <br><br>  En algunos lenguajes, por ejemplo, en C, hay conceptos de pasar argumentos de funciones por referencia y por valor.  JavaScript tambi√©n tiene algo similar.  C√≥mo se organiza exactamente el trabajo con datos depende de su tipo.  Si un valor primitivo representado por una determinada variable se pasa a la funci√≥n, y luego se cambia en esta funci√≥n, el valor almacenado en la variable original no cambia.  Sin embargo, si pasa el valor del objeto representado por la variable a la funci√≥n y lo modifica, lo que est√° almacenado en esta variable tambi√©n cambiar√°. <br><br>  Considere el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primitiveMutator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ val = val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; primitiveMutator(x); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-comment"><span class="hljs-comment">// 1 function objectMutator(val) { val.prop = val.prop + 1; } let obj = { prop: 1 }; objectMutator(obj); console.log(obj.prop); // 2</span></span></code> </pre> <br>  Los valores primitivos (con la excepci√≥n del misterioso <code>NaN</code> , que no es igual a s√≠ mismo) siempre resultan ser iguales a otros valores primitivos que se parecen a ellos mismos.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> + <span class="hljs-string"><span class="hljs-string">"def"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-string"><span class="hljs-string">"ab"</span></span> + <span class="hljs-string"><span class="hljs-string">"cd"</span></span> + <span class="hljs-string"><span class="hljs-string">"ef"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first === second); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Sin embargo, la construcci√≥n de valores de objeto que se vean igual hacia afuera no conducir√° al hecho de que se obtendr√°n entidades, en comparaci√≥n, se revelar√° su igualdad entre s√≠.  Puede verificar esto mediante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1 === obj2); <span class="hljs-comment"><span class="hljs-comment">// false //     .name   : console.log(obj1.name === obj2.name); // true</span></span></code> </pre> <br>  Los objetos juegan un papel fundamental en JavaScript.  Se usan literalmente en todas partes.  Por ejemplo, a menudo se usan en forma de colecciones de clave / valor.  Pero antes del advenimiento del tipo de datos <code>Symbol</code> , solo se pod√≠an usar cadenas como claves de objeto.  Esta fue una limitaci√≥n seria en el uso de objetos en forma de colecciones.  Al intentar asignar un valor que no sea de cadena como una clave de objeto, este valor se convirti√≥ en una cadena.  Puede verificar esto mediante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj.foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj[<span class="hljs-string"><span class="hljs-string">'bar'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; obj[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; obj[{}] = <span class="hljs-string"><span class="hljs-string">'someobj'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { '2': 2, foo: 'foo', bar: 'bar',    '[object Object]': 'someobj' }</span></span></code> </pre> <br>  Por cierto, aunque esto nos aleja un poco del tema de los caracteres, quiero se√±alar que la estructura de datos del <code>Map</code> se cre√≥ para permitir el uso de almacenes de datos de clave / valor en situaciones donde la clave no es una cadena. <br><br><h2>  <font color="#3AC1EF">¬øQu√© es un s√≠mbolo?</font> </h2><br>  Ahora que hemos descubierto las caracter√≠sticas de los valores primitivos en JavaScript, finalmente estamos listos para comenzar a hablar sobre los personajes.  Un s√≠mbolo es un significado primitivo √∫nico.  Si se acerca a los s√≠mbolos desde esta posici√≥n, notar√° que los s√≠mbolos a este respecto son similares a los objetos, ya que la creaci√≥n de varias instancias de los s√≠mbolos conducir√° a la creaci√≥n de diferentes valores.  Pero los s√≠mbolos, adem√°s, son valores primitivos inmutables.  Aqu√≠ hay un ejemplo de trabajo con personajes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === s2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Al crear una instancia de un personaje, puede usar el primer argumento de cadena opcional.  Este argumento es una descripci√≥n del s√≠mbolo que est√° destinado a usarse en la depuraci√≥n.  Este valor no afecta el s√≠mbolo en s√≠. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'debug'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'debug'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'xxyy'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === str); <span class="hljs-comment"><span class="hljs-comment">// false console.log(s1 === s2); // false console.log(s1); // Symbol(debug)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Los s√≠mbolos como claves de propiedad de los objetos.</font> </h2><br>  Los s√≠mbolos se pueden usar como claves de propiedad para objetos.  Esto es muy importante  Aqu√≠ hay un ejemplo de c√≥mo usarlos como tales: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); obj[sym] = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj.bar = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { bar: 'bar' } console.log(sym in obj); // true console.log(obj[sym]); // foo console.log(Object.keys(obj)); // ['bar']</span></span></code> </pre> <br>  Tenga en cuenta que las claves especificadas por los caracteres no se devuelven cuando se <code>Object.keys()</code> m√©todo <code>Object.keys()</code> .  El c√≥digo escrito antes de la aparici√≥n de los caracteres en JS no sabe nada sobre ellos, como resultado, la informaci√≥n sobre las claves de los objetos representados por los caracteres no debe ser devuelta por el antiguo m√©todo <code>Object.keys()</code> . <br><br>  A primera vista, puede parecer que las caracter√≠sticas anteriores de los caracteres le permiten usarlas para crear propiedades privadas de objetos JS.  En muchos otros lenguajes de programaci√≥n, puede crear propiedades de objetos ocultos utilizando clases.  La falta de esta caracter√≠stica ha sido considerada una de las deficiencias de JavaScript. <br><br>  Desafortunadamente, el c√≥digo que funciona con objetos puede acceder libremente a sus claves de cadena.  El c√≥digo tambi√©n puede acceder a las teclas especificadas por los caracteres, adem√°s, incluso si el c√≥digo desde el que trabajan con el objeto no tiene acceso al car√°cter correspondiente.  Por ejemplo, utilizando el m√©todo <code>Reflect.ownKeys()</code> , puede obtener una lista de todas las claves de un objeto, tanto las que son cadenas como las que son caracteres: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToAddPrivate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ o[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'Pseudo Private'</span></span>)] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span> }; tryToAddPrivate(obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(obj));       <span class="hljs-comment"><span class="hljs-comment">// [ 'prop', Symbol(Pseudo Private) ] console.log(obj[Reflect.ownKeys(obj)[1]]); // 42</span></span></code> </pre> <br>  Tenga en cuenta que actualmente se est√° trabajando para equipar a las clases con la capacidad de usar propiedades privadas.  Esta caracter√≠stica se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Campos privados</a> .  Es cierto que no afecta absolutamente a todos los objetos, sino que se refiere solo a aquellos creados a partir de clases preparadas previamente.  El soporte para campos privados ya est√° disponible en el navegador Chrome versi√≥n 72 y anteriores. <br><br><h2>  <font color="#3AC1EF">Prevenir colisiones de nombres de propiedades de objetos</font> </h2><br>  Los s√≠mbolos, por supuesto, no agregan a JavaScript la capacidad de crear propiedades privadas de objetos, pero son una innovaci√≥n valiosa en el lenguaje por otras razones.  Es decir, son √∫tiles en situaciones en las que ciertas bibliotecas necesitan agregar propiedades a los objetos descritos fuera de ellas y, al mismo tiempo, no temer una colisi√≥n de los nombres de las propiedades de los objetos. <br><br>  Considere un ejemplo en el que dos bibliotecas diferentes desean agregar metadatos a un objeto.  Es posible que ambas bibliotecas necesiten equipar el objeto con algunos identificadores.  Si simplemente usa algo como una cadena de <code>id</code> de dos letras para el nombre de dicha propiedad, puede encontrar una situaci√≥n en la que una biblioteca sobrescribe la propiedad especificada por la otra. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Si usamos los s√≠mbolos en nuestro ejemplo, cada biblioteca puede generar, tras la inicializaci√≥n, los s√≠mbolos que necesita.  Estos s√≠mbolos se pueden usar para asignar propiedades a los objetos y acceder a estas propiedades. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib1'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library1property] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib2'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library2property] = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Al observar este escenario, puede beneficiarse de la aparici√≥n de caracteres en JavaScript. <br><br>  Sin embargo, puede haber una pregunta con respecto al uso de bibliotecas para los nombres de propiedades de objetos, cadenas aleatorias o cadenas con una estructura compleja, que incluye, por ejemplo, el nombre de la biblioteca.  Cadenas similares pueden formar algo as√≠ como espacios de nombres para los identificadores utilizados por las bibliotecas.  Por ejemplo, podr√≠a verse as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//       function lib1tag(obj) { obj[library1property] = 42; } const library2property = 'LIB2-NAMESPACE-id'; //     function lib2tag(obj) { obj[library2property] = 369; }</span></span></code> </pre> <br>  En general, puedes hacerlo.  Enfoques similares, de hecho, son muy similares a lo que sucede cuando se usan s√≠mbolos.  Y si, utilizando identificadores aleatorios o espacios de nombres, un par de bibliotecas no generar√°n, por casualidad, los mismos nombres de propiedad, entonces no habr√° problemas con los nombres. <br><br>  Un lector astuto dir√≠a ahora que los dos enfoques considerados para nombrar propiedades de objeto no son completamente equivalentes.  Los nombres de propiedades que se generan aleatoriamente o que usan espacios de nombres tienen un inconveniente: las claves correspondientes son muy f√°ciles de encontrar, especialmente si el c√≥digo busca las claves de los objetos o las serializa.  Considere el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-string"><span class="hljs-string">'LIB2-NAMESPACE-id'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    function lib2tag(obj) { obj[library2property] = 369; } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); JSON.stringify(user); // '{"name":"Thomas Hunter II","age":32,"LIB2-NAMESPACE-id":369}'</span></span></code> </pre> <br>  Si se utilizara un s√≠mbolo para el nombre de la clave en esta situaci√≥n, la representaci√≥n JSON del objeto no contendr√≠a el valor del s√≠mbolo.  ¬øPor qu√© es esto as√≠?  El hecho es que el hecho de que haya aparecido un nuevo tipo de datos en JavaScript no significa que se hayan realizado cambios en la especificaci√≥n JSON.  JSON admite, como claves de propiedad, solo cadenas.  Al serializar un objeto, no se intenta representar a los personajes de ninguna manera especial. <br><br>  El problema considerado de obtener nombres de propiedad en la representaci√≥n JSON de objetos se puede resolver utilizando <code>Object.defineProperty()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//   function lib2tag(obj) { Object.defineProperty(obj, library2property, {   enumerable: false,   value: 369 }); } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); // '{"name":"Thomas Hunter II",  "age":32,"f468c902-26ed-4b2e-81d6-5775ae7eec5d":369}' console.log(JSON.stringify(user)); console.log(user[library2property]); // 369</span></span></code> </pre> <br>  Las teclas de cadena que est√°n "ocultas" configurando su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descriptor</a> <code>enumerable</code> en <code>false</code> comportan de la misma manera que las teclas representadas por caracteres.  Ambos no se muestran cuando <code>Object.keys()</code> llama <code>Object.keys()</code> , y ambos se pueden detectar usando <code>Reflect.ownKeys()</code> .  As√≠ es como se ve: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>()] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumberable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// [] console.log(Reflect.ownKeys(obj)); // [ 'foo', Symbol() ] console.log(JSON.stringify(obj)); // {}</span></span></code> </pre> <br>  Aqu√≠, debo decir, casi recreamos las posibilidades de los s√≠mbolos, utilizando otros medios de JS.  En particular, ambas claves representadas por s√≠mbolos y claves privadas no entran en la representaci√≥n JSON de un objeto.  Ambos pueden reconocerse haciendo referencia al m√©todo <code>Reflect.ownKeys()</code> .  Como resultado, a ambos no se les puede llamar verdaderamente privados.  Si suponemos que se utilizan algunos valores aleatorios o espacios de nombres de biblioteca para generar nombres clave, entonces esto significa que nos libramos del riesgo de colisiones de nombres. <br><br>  Sin embargo, hay una peque√±a diferencia entre usar nombres de s√≠mbolos y nombres creados usando otros mecanismos.  Dado que las cadenas son inmutables y se garantiza que los caracteres ser√°n √∫nicos, siempre existe la posibilidad de que alguien, despu√©s de pasar por todas las combinaciones posibles de caracteres en una cadena, cause una colisi√≥n de nombres.  Desde un punto de vista matem√°tico, esto significa que los personajes realmente nos dan una valiosa oportunidad que las cadenas no tienen. <br><br>  En Node.js, al examinar objetos (por ejemplo, usando <code>console.log()</code> ), si <code>inspect</code> detecta un m√©todo de objeto llamado <code>inspect</code> , este m√©todo se utiliza para obtener una representaci√≥n de cadena del objeto y luego mostrarlo en la pantalla.  Es f√°cil entender que absolutamente todos no pueden tener esto en cuenta, por lo tanto, tal comportamiento del sistema puede conducir a una llamada al m√©todo de <code>inspect</code> objetos, que est√° dise√±ado para resolver problemas que no est√°n relacionados con la formaci√≥n de la representaci√≥n de cadena del objeto.  Esta caracter√≠stica est√° en desuso en Node.js 10, en la versi√≥n 11, los m√©todos con un nombre similar simplemente se ignoran.  Ahora, para implementar esta caracter√≠stica, <code>require('util').inspect.custom</code> .  Esto significa que nadie podr√° interrumpir inadvertidamente el sistema creando un m√©todo de objeto llamado <code>inspect</code> . <br><br><h2>  <font color="#3AC1EF">Imitaci√≥n de propiedades privadas.</font> </h2><br>  Aqu√≠ hay un enfoque interesante que puede usar para simular las propiedades privadas de los objetos.  Este enfoque implica el uso de otra caracter√≠stica moderna de JavaScript: los objetos proxy.  Dichos objetos sirven como envoltorios para otros objetos que permiten al programador intervenir en las acciones realizadas con estos objetos. <br><br>  Los objetos proxy ofrecen muchas formas de interceptar las acciones realizadas en los objetos.  Estamos interesados ‚Äã‚Äãen la capacidad de controlar la operaci√≥n de lectura de claves de un objeto.  No entraremos en detalles sobre los objetos proxy aqu√≠.  Si est√° interesado, eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> publicaci√≥n. <br><br>  Podemos usar proxies para controlar qu√© propiedades del objeto son visibles desde el exterior.  En este caso, queremos crear un proxy que oculte dos propiedades que conocemos.  Uno tiene el nombre de cadena <code>_favColor</code> , y el segundo est√° representado por un car√°cter escrito en la variable <code>favBook</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> proxy; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> favBook = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'fav book'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {   <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas Hunter II'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>,   <span class="hljs-attr"><span class="hljs-attr">_favColor</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>,   [favBook]: <span class="hljs-string"><span class="hljs-string">'Metro 2033'</span></span>,   [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'visible'</span></span>)]: <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">ownKeys</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reportedKeys = [];     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actualKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(target);     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actualKeys) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key === favBook || key === <span class="hljs-string"><span class="hljs-string">'_favColor'</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;       }       reportedKeys.push(key);     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reportedKeys;   } }; proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(proxy)); <span class="hljs-comment"><span class="hljs-comment">// [ 'name', 'age' ] console.log(Reflect.ownKeys(proxy)); // [ 'name', 'age', Symbol(visible) ] console.log(Object.getOwnPropertyNames(proxy)); // [ 'name', 'age' ] console.log(Object.getOwnPropertySymbols(proxy)); // [Symbol(visible)] console.log(proxy._favColor); // 'blue</span></span></code> </pre> <br>  Tratar con una propiedad cuyo nombre est√° representado por la cadena <code>_favColor</code> no es dif√≠cil: solo lea el c√≥digo fuente.  Las teclas din√°micas (como las teclas uuid que vimos anteriormente) se pueden combinar con la fuerza bruta.  Pero sin referencia al s√≠mbolo, no puede acceder al valor de <code>Metro 2033</code> desde el objeto <code>proxy</code> . <br><br>  Cabe se√±alar que en Node.js hay una caracter√≠stica que viola la privacidad de los objetos proxy.  Esta caracter√≠stica no existe en el lenguaje en s√≠, por lo que no es relevante para otros tiempos de ejecuci√≥n de JS, como un navegador.  El hecho es que esta caracter√≠stica le permite acceder al objeto oculto detr√°s del objeto proxy, si tiene acceso al objeto proxy.  Aqu√≠ hay un ejemplo que demuestra la capacidad de eludir los mecanismos que se muestran en el fragmento de c√≥digo anterior: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [originalObject] = process .binding(<span class="hljs-string"><span class="hljs-string">'util'</span></span>) .getProxyDetails(proxy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(originalObject); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allKeys[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Symbol(fav book)</span></span></code> </pre> <br>  Ahora, para evitar el uso de esta funci√≥n en una instancia espec√≠fica de Node.js, debe modificar el objeto <code>Reflect</code> global o el enlace del proceso <code>util</code> .  Sin embargo, esta es otra tarea.  Si est√° interesado, eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> publicaci√≥n sobre la protecci√≥n de las API basadas en JavaScript. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En este art√≠culo, hablamos sobre el tipo de datos de <code>Symbol</code> , sobre las caracter√≠sticas que proporciona a los desarrolladores de JavaScript y sobre qu√© mecanismos de lenguaje existentes se pueden usar para simular estas caracter√≠sticas. <br><br>  <b>Estimados lectores!</b>  ¬øUtiliza s√≠mbolos en sus proyectos de JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444340/">https://habr.com/ru/post/444340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444328/index.html">El redise√±o de la interfaz de usuario suele ser una p√©rdida de tiempo</a></li>
<li><a href="../444330/index.html">El CMS sin servidor es finalmente un digno competidor para Wordpress</a></li>
<li><a href="../444332/index.html">Seguridad de la informaci√≥n y restauraci√≥n: c√≥mo piensan los gerentes acerca de los productos de TI</a></li>
<li><a href="../444336/index.html">Listas de captura r√°pida: ¬øcu√°l es la diferencia entre enlaces d√©biles, fuertes y no propios?</a></li>
<li><a href="../444338/index.html">Encapsulaci√≥n en Python 3</a></li>
<li><a href="../444342/index.html">Desarrollar aplicaciones JavaScript simples y modernas utilizando Webpack y tecnolog√≠as web avanzadas</a></li>
<li><a href="../444344/index.html">10 pasos para un proyecto exitoso de Python</a></li>
<li><a href="../444346/index.html">GraphQL y Golang</a></li>
<li><a href="../444348/index.html">¬øEn qu√© se diferencian los componentes funcionales de React de los componentes basados ‚Äã‚Äãen clases?</a></li>
<li><a href="../444350/index.html">Por alguna raz√≥n, MVP (producto m√≠nimo viable) no se inicia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>