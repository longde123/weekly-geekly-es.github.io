<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👺 🛀🏽 🎗️ Suspension sur blocage 🅰️ 👩🏾‍🔧 ⏺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article vise à montrer comment utiliser Kotlin Coroutines et supprimer Reaxtive eXtensions (Rx) . 
 Bénéfices 


 Pour commencer, considérons quat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suspension sur blocage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465529/"><p>  Cet article vise à montrer comment utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kotlin Coroutines</a> et supprimer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reaxtive eXtensions (Rx)</a> . </p><br><h2 id="benefits">  Bénéfices </h2><br><p>  Pour commencer, considérons quatre avantages de Coroutines par rapport à Rx: </p><br><h3 id="suspending-over-blocking">  Suspension sur blocage </h3><br><p>  Pour exécuter du code non bloquant à l'aide de Rx, vous devez écrire quelque chose comme ceci: </p><br><pre><code class="kotlin hljs">Observable.interval(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS) .subscribe { textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$it</span></span></span><span class="hljs-string"> seconds have passed"</span></span> }</code> </pre> <br><p>  Ce qui crée effectivement un nouveau fil.  Les threads sont des objets lourds en termes de mémoire et de performances. </p><br><p>  Les deux sont essentiels dans le monde du développement mobile. </p><br><p>  Vous pouvez obtenir le même comportement à l'aide de l'extrait de code suivant: </p><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>){ textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it++}</span></span></span><span class="hljs-string"> seconds have passed"</span></span> delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) } }</code> </pre> <br><p>  Essentiellement, les Coroutines sont des threads légers mais nous ne créons aucun vrai thread. <br>  Ici, nous utilisons la fonction delay () non bloquante, qui est une fonction de suspension spéciale qui ne bloque pas un thread mais suspend la Coroutine. <a name="habracut"></a></p><br><h3 id="natural-backpressure-handling-over-manual">  Manipulation naturelle de la contre-pression par rapport au manuel </h3><br><p>  La contre-pression se produit lorsque les observables produisent des objets plus rapidement que leurs observateurs ne les consomment. <br>  Lorsque vous utilisez Rx, vous devez spécifier explicitement comment vous allez gérer la contre-pression. <br>  Il existe 2 approches de base: </p><br><ul><li>  Utiliser des opérateurs de limitation, de tampons ou de fenêtres </li><li>  Le modèle de traction réactive </li></ul><br><p>  Alors que les Coroutines peuvent suspendre, elles fournissent une réponse naturelle à la gestion de la contre-pression. <br>  Ainsi, aucune action supplémentaire n'est requise. </p><br><h3 id="sync-code-style-over-async">  Synchroniser le style de code sur async </h3><br><p>  La nature de base d'une application mobile est de réagir aux actions des utilisateurs.  C'est pourquoi Reactive eXtensions serait un bon choix. </p><br><p>  Cependant, vous devez écrire un code dans un style fonctionnel.  Si vous écriviez de façon impérative, cela pourrait être un peu difficile. </p><br><p>  Tandis que les Coroutines vous permettent d'écrire du code asynchrone comme s'il s'agissait de fonctions de synchronisation habituelles.  Par exemple, </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTextFromRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = remote.getText() textView.text = text }</code> </pre> <br><p>  Même si je travaille avec le style fonctionnel depuis longtemps, il est toujours plus facile de lire et de déboguer un code impératif. </p><br><h3 id="native-over-3rd-party-lib">  Native sur la bibliothèque tierce </h3><br><p>  Les coroutines sont une fonctionnalité native intégrée de Kotlin. </p><br><p>  Vous n'avez pas besoin d'ajouter de dépendances supplémentaires.  Actuellement, toutes les bibliothèques principales pourraient traiter des coroutines. </p><br><p>  Par exemple, </p><br><p>  Retrofit </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : List&lt;User&gt; }</code> </pre> <br><p>  Pièce </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Ainsi, vous pouvez créer une application qui est complètement suspendue - en commençant la couche d'interface utilisateur, en passant par le domaine et en terminant par la couche de données. </p><br><h2 id="app">  L'appli </h2><br><p>  Passons aux affaires.  Nous allons créer une application maître-détail classique. <br>  La première page contiendrait une liste infinie de livraisons. <br>  Au clic sur l'élément, nous ouvrirons une page de détails. <br>  De plus, nous prendrons en charge le mode hors ligne - toutes les données seront mises en cache. <br>  De plus, j'utiliserai l'architecture MVVM où le rôle ViewModel est joué par Fragment au lieu de ViewModel d'AAC.  Il y a plusieurs raisons: <br>  Les fragments sont généralement très chauves - il suffit de lier viewModel à XML. </p><br><p>  Des fonctionnalités telles que la définition de la couleur de la barre d'état ne pouvaient pas être effectuées dans AAC ViewModel - vous devez déclencher la méthode du fragment.  L'utilisation de fragment comme ViewModel nous permettrait de stocker toutes les fonctionnalités associées (gérer un écran donné) dans une classe. </p><br><p>  Commençons par créer BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO){ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: B <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewBinding: V <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) retainInstance = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: View? { viewBinding = DataBindingUtil.inflate(inflater, layoutId, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewBinding.root } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.lifecycleOwner = viewLifecycleOwner viewBinding.setVariable(BR.bindings, bindings) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() } }</code> </pre> <br><p>  Nous marquons notre ViewModel comme CoroutineScope afin de pouvoir démarrer des coroutines à l'intérieur des modèles de vue et toute coroutine lancée serait limitée au cycle de vie d'un fragment. </p><br><p>  Nous devons explicitement spécifier la fin de la durée de vie de la portée appelant la méthode <code>cancel()</code> pour annuler toutes les demandes en cours afin d'éviter les fuites de mémoire. </p><br><p>  Nous définissons <code>retainInstance = true</code> afin que dans les changements de configuration, le fragment ne soit pas recréé afin que nous puissions terminer toutes les demandes de longue durée. </p><br><p>  De plus, nous devons définir lifecycleOwner sur binding pour activer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la liaison de données bidirectionnelle</a> . </p><br><h2 id="exception-handling">  Gestion des exceptions </h2><br><p>  Selon la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de</a> Coroutines: </p><br><pre> <code class="plaintext hljs">Coroutine builders come in two flavors: propagating exceptions automatically (launch and actor) or exposing them to users (async and produce). The former treat exceptions as unhandled, similar to Java's Thread.uncaughtExceptionHandler</code> </pre> <br><p>  Puisque nous utilisons le générateur de lancement dans la plupart des cas, nous devons spécifier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoroutineExceptionHandler</a> <br>  CoroutineExceptionHandler est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoroutineContext.Element</a> qui peut être utilisé pour créer un contexte de coroutine à l'aide de l'opérateur plus. <br>  Je déclarerai le gestionnaire statique comme suit: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; Timber.e(throwable) }</code> </pre> <br><p>  Et changez BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO + exceptionHandler)</code> </pre> <br><p>  À partir de là, toute exception survenue dans la coroutine lancée à l'intérieur de la portée de ViewModel serait livrée au gestionnaire donné. <br>  Ensuite, je dois déclarer mon API et DAO: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveriesApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"deliveries"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"offset"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"limit"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;DeliveryResponse&gt; } <span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM </span></span><span class="hljs-subst"><span class="hljs-meta"><span class="hljs-meta-string"><span class="hljs-subst">${DeliveryEntity.TABLE_NAME}</span></span></span></span><span class="hljs-meta"><span class="hljs-meta-string">"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: DataSource.Factory&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, DeliveryEntity&gt; <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Comme vous pouvez le voir, j'ai marqué les méthodes comme suspendues afin que nous puissions simplement déclarer les objets de réponse attendus.  De plus, l'annulation de la coroutine parent annulera également l'appel réseau. <br>  La même chose pour DAO. <br>  La seule différence est que nous voulons offrir la possibilité d'observer la base de données. <br>  Le moyen le plus simple consiste à utiliser la prise en charge intégrée des données en direct.  Mais si nous marquions getAll () comme suspendu, cela provoquerait une erreur de compilation <br>  erreur: </p><br><pre> <code class="plaintext hljs">Not sure how to convert a Cursor to this method's return type ...</code> </pre> <br><p>  Ici, nous n'avons pas besoin de suspendre car: </p><br><ul><li>  Les requêtes DB sont effectuées en arrière-plan par défaut </li><li>  LiveData résultant est conscient du cycle de vie afin que nous n'ayons pas besoin de l'annuler manuellement </li></ul><br><p>  Nous devons en quelque sorte combiner des sources de données distantes et locales. <br>  Il convient de s'en souvenir - il ne devrait y avoir qu'un seul point de vérité. <br>  Selon la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conception hors ligne</a> , ce serait du stockage local.  Ainsi, nous observerions l'état de la base de données.  Lorsqu'il n'y a rien à récupérer, nous demandons des données à distance et les insérons dans la base de données. <br>  Nous présenterons la classe Listing </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listing</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagedList: LiveData&lt;PagedList&lt;T&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refresh: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retry: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )</code> </pre> <br><p>  Allons val par val: </p><br><ul><li>  pagedList - les données principales qui sont construites comme PagedList pour permettre le défilement infini et enveloppées avec LiveData pour permettre l'observation des données </li><li>  dataState - l'un des trois états dans lesquels nos données peuvent être: succès, en cours d'exécution, erreur.  Également enveloppé dans LiveData pour observer les changements </li><li>  refreshState - lorsque nous déclenchons l'actualisation des données par balayage pour actualiser, nous avons besoin d'un outil permettant de faire la distinction entre les commentaires de demande de rafraîchissement et les commentaires de demande de page suivante.  Pour le premier, nous voulons afficher une erreur à la fin de la liste mais pour une erreur de rafraîchissement, nous voulons afficher un message toast et masquer un chargeur. </li><li>  refresh () - rappel à déclencher lors d'un balayage pour rafraîchir </li><li><p>  retry () - rappel à déclencher en cas d'erreur de chargement de pagedList <br>  Ensuite, modèle de vue de liste: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryListViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryListBindings, DeliveryListBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery_list <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryListBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> listing = deliveryGateway.getDeliveries() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = listing.dataState <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isRefreshing = Transformations.switchMap(listing.refreshState) { MutableLiveData(it == DataState.Loading) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) setupList() setupRefresh() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter = DeliveriesAdapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) viewBinding.deliveries.adapter = adapter viewBinding.deliveries.setHasFixedSize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) listing.pagedList.observe(viewLifecycleOwner, Observer { adapter.submitList(it) }) listing.dataState.observe(viewLifecycleOwner, Observer { adapter.updateDataState(it) }) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refreshState.observe(viewLifecycleOwner, Observer { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DataState.Error) { Toast.makeText(context, it.message, LENGTH_SHORT).show() } }) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refresh() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDeliveryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Delivery</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { view?.findNavController()?.navigate(DeliveryListViewModelDirections.toDetails(delivery)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRetryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.retry() } }</code> </pre> <br><p>  Commençons par la déclaration de classe. </p><br></li></ul><br><p>  Tout d'abord DeliveryListBindings et DeliveryListBinding.  Le premier est notre interface déclarée pour coller le modèle de vue avec la vue XML.  La seconde est la classe autogénérée basée sur XML.  Nous avons besoin du second pour définir notre interface de liaisons et notre cycle de vie en XML. </p><br><p>  De plus, il est recommandé de référencer les vues à l'aide de cette liaison autogénérée plutôt que d'utiliser la synthèse de kotlin. </p><br><p>  Cela peut être le cas lorsque le référentiel via la vue synthétique n'existe pas dans la vue actuelle.  Avec la liaison de données, vous échouerez rapidement même à l'étape de la compilation. </p><br><p>  Ensuite, trois interfaces: DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings. </p><br><ol><li>  <em>DeliveryListBindings</em> - liaisons pour l'écran lui-même.  Par exemple, il contient la méthode refresh () qui est appelée lors d'un balayage vertical. </li><li>  <em>DeliveryListItemBindings</em> - liaisons pour un élément de la liste.  Par exemple, onClicked () </li><li>  <em>DeliveryListErrorBindings</em> - liaisons pour la vue d'erreur qui est également l'élément de liste affiché sur l'état d'erreur.  Par exemple, il contient la méthode retry () </li></ol><br><p>  Ainsi, nous traitons tout dans le modèle à vue unique, car il s'agit d'un seul écran, mais également du principe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">séparation d'interface</a> </p><br><p>  Tournons une attention particulière sur cette ligne: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }</code> </pre> <br><p>  <em>DeliveryGateway</em> doit effectuer des requêtes à partir du thread principal.  Il doit donc déclarer les méthodes suspendues ou CoroutineScope pour lancer de nouvelles coroutines sur cette étendue.  Nous choisirions la deuxième approche car nous avons besoin de nos LiveData depuis le début, puis nous attendrions simplement les mises à jour.  C'est très similaire à l'abonnement à une instance liveData lorsque nous transmettons lifecycleOwner (qui fait souvent référence à «ceci»).  Voici de la même manière que nous passons «ceci» comme CoroutineScope </p><br><p>  L'interface CoroutineScope se compose d'un seul champ - CoroutineContext.  En substance, une portée et un contexte sont les mêmes choses.  La différence entre un contexte et une portée réside dans leur objectif. </p><br><p>  Pour en savoir plus, je recommanderais un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> de Roman Elizarov.  Ainsi, fournir une portée à <em>DeliveryGateway</em> entraînera également l'utilisation du même contexte.  Spécifiquement thread, job et gestionnaire d'exceptions. <br>  Jetons maintenant un œil à DeliveryGateway lui-même: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryBoundGateway</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> db: DataBase, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: DeliveriesApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryDao: DeliveryDao, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineScope: CoroutineScope ) : DeliveryGateway { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boundaryCallback = DeliveriesBoundaryCallback( api = api, coroutineScope = coroutineScope, handleResponse = { insertIntoDatabase(it) } ) <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Listing&lt;Delivery&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshTrigger = MutableLiveData&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState = Transformations.switchMap(refreshTrigger) { refresh() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagingConfig = Config( initialLoadSizeHint = PAGE_SIZE, pageSize = PAGE_SIZE, prefetchDistance = PAGE_SIZE ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = deliveryDao.getAll() .toLiveData( config = pagingConfig, boundaryCallback = boundaryCallback ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Listing( pagedList = deliveries, dataState = boundaryCallback.dataState, retry = { boundaryCallback.helper.retryAllFailed() }, refresh = { refreshTrigger.value = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }, refreshState = refreshState ) } <span class="hljs-comment"><span class="hljs-comment">/** * When refresh is called, we simply run a fresh network request and when it arrives, clear * the database table and insert all new items in a transaction. * &lt;p&gt; * Since the PagedList already uses a database bound data source, it will automatically be * updated after the database transaction is finished. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: LiveData&lt;DataState&gt; { boundaryCallback.refresh() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = MutableLiveData&lt;DataState&gt;() dataState.value = DataState.Loading coroutineScope.launch { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = api.getDeliveries(<span class="hljs-number"><span class="hljs-number">0</span></span>, PAGE_SIZE) db.withTransaction { deliveryDao.clear() insertIntoDatabase(deliveries) } dataState.postValue(DataState.Loaded) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Timber.w(throwable) dataState.postValue(DataState.Error(throwable.message)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataState } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertIntoDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(deliveries: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { deliveries.forEach { delivery -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> entity = deliveryConverter.fromNetwork(delivery) deliveryDao.insert(entity) } } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PAGE_SIZE = <span class="hljs-number"><span class="hljs-number">20</span></span> } }</code> </pre> <br><p>  Ici, nous construisons la structure LiveData depuis le début, puis en utilisant les coroutines, chargez les données et postez-les dans LiveData.  De plus, nous utilisons l'implémentation de <em>PagedList.BoundaryCallback () pour coller la base de données locale et l'API distante.</em>  <em>Lorsque nous atteignons la fin de la liste paginée, <em>borderCallback</em> est déclenché et charge le prochain bloc de données.</em> <br></p><p>  Comme vous pouvez le voir, nous utilisons coroutineScope pour lancer de nouvelles coroutines. </p><br><p>  Étant donné que cette portée est égale au cycle de vie du fragment - toutes les demandes en attente seraient annulées lors du rappel <code>onDestroy()</code> du fragment. </p><br><p>  La page de détail de livraison est assez simple - nous passons simplement un objet de livraison en tant que colis à partir de l'écran principal à l'aide du plug-in de sauvegarde du composant de navigation.  Sur l'écran des détails, liez simplement un objet à un XML. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryBindings, DeliveryBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> args: DeliveryViewModelArgs <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> navArgs() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.delivery = args.delivery viewBinding.image.clipToOutline = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h2 id="contact-me">  Contactez moi </h2><br><p>  Voici le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> vers le code source de github. </p><br><p>  Vous êtes invités à laisser des commentaires et des questions ouvertes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465529/">https://habr.com/ru/post/fr465529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465519/index.html">Exposition PRO // Movement.Expo</a></li>
<li><a href="../fr465521/index.html">Fly-fly-petal ... ou un conte sur la façon dont le designer UX a promu son produit sur Instagram</a></li>
<li><a href="../fr465523/index.html">Encore un autre serpent Android avec Kivy, Python</a></li>
<li><a href="../fr465525/index.html">Rapports mobiles sur Oracle BI EE 12c - un, deux, trois. Méthodologie du cours de CAO Oracle BI EE 12c</a></li>
<li><a href="../fr465527/index.html">Le long voyage de la RFC 4357 à la RFC 8645 ou comment gérer les clés de chiffrement</a></li>
<li><a href="../fr465531/index.html">Déballage des listes imbriquées de profondeur indéfinie</a></li>
<li><a href="../fr465535/index.html">Qui implémente IPv6 et ce qui entrave son développement</a></li>
<li><a href="../fr465537/index.html">Yandex: une maison intelligente pour adultes</a></li>
<li><a href="../fr465539/index.html">766 km - un nouveau record d'autonomie pour LoRaWAN</a></li>
<li><a href="../fr465541/index.html">De l'entreprise à la PME: nous partageons notre expérience dans l'adaptation de solutions d'entreprise pour les petites et moyennes entreprises avec la monétisation en utilisant le modèle SaaS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>