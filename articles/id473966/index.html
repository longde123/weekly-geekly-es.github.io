<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏻 💏 🧙🏼 Atas permintaan Pengembang Tertanam: Mendeteksi Kesalahan di Amazon FreeRTOS ✌🏻 🧝🏼 🌓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siapa pun yang memprogram pengendali mikrokontroler mungkin tahu tentang FreeRTOS, atau setidaknya pernah mendengar tentang sistem operasi ini. Pengem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Atas permintaan Pengembang Tertanam: Mendeteksi Kesalahan di Amazon FreeRTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/473966/">  Siapa pun yang memprogram pengendali mikrokontroler mungkin tahu tentang FreeRTOS, atau setidaknya pernah mendengar tentang sistem operasi ini.  Pengembang Amazon memutuskan untuk meningkatkan kemampuan sistem operasi ini untuk bekerja dengan layanan AWS Internet of Things.  Ini adalah bagaimana Amazon FreeRTOS muncul.  Kami, pengembang alat analisis kode statis PVS-Studio, diminta melalui pos dan dalam komentar untuk memeriksa proyek-proyek ini.  Nah, sekarang dapatkan apa yang Anda minta.  Teruslah membaca untuk mencari tahu apa yang keluar darinya. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cee/9b7/a98/cee9b7a984f45dc365b4baea89adb019.png"></div><br><a name="habracut"></a><br><h2>  Secara singkat tentang proyek </h2><br>  Untuk memulainya, saya akan memberi tahu Anda sedikit tentang pelopor proyek yang sedang diuji - FreeRTOS (kode sumber tersedia di sini melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ).  Seperti yang dinyatakan Wikipedia, FreeRTOS adalah sistem operasi multitasking waktu-nyata untuk sistem tertanam. <br><br>  Ini ditulis dalam C tua yang baik, yang tidak mengherankan - sistem operasi ini harus bekerja dalam kondisi khas mikrokontroler: daya pemrosesan rendah, sejumlah kecil RAM, dan sejenisnya.  Bahasa C memungkinkan Anda untuk bekerja dengan sumber daya pada tingkat rendah dan memiliki kinerja tinggi, sehingga sangat cocok untuk mengembangkan OS semacam itu. <br><br>  Sekarang kembali ke Amazon, yang selalu bergerak mengembangkan berbagai arah yang menjanjikan.  Misalnya, Amazon sedang mengembangkan mesin AAA Amazon Lumberyard, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga</a> telah kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">periksa</a> . <br><br>  Salah satu arahan tersebut adalah Internet of Things (IoT).  Untuk mengembangkan di bidang ini, Amazon memutuskan untuk menulis sistem operasi mereka sendiri - dan mereka mengambil inti FreeRTOS sebagai dasar. <br><br>  Sistem yang dihasilkan, Amazon FreeRTOS, diposisikan untuk "menyediakan koneksi aman ke Amazon Web Services, seperti AWS IoT Core atau AWS IoT Greengrass."  Kode sumber proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini tersedia</a> di Github. <br><br>  Dalam artikel ini, kami akan mencari tahu apakah ada kesalahan dalam FreeRTOS serta seberapa aman sistem operasi Amazon dalam hal analisis kode statis. <br><br><h2>  Jalannya cek </h2><br>  Pemeriksaan dilakukan menggunakan alat pencari kesalahan otomatis - alat analisa kode statis PVS-Studio.  Itu mampu mendeteksi kesalahan dalam program yang ditulis dalam C, C ++, C #, dan Java. <br><br>  Sebelum analisis, kita harus membangun proyek.  Dengan cara ini, saya akan yakin bahwa saya memiliki semua dependensi yang diperlukan dan proyek siap untuk diperiksa.  Satu dapat memeriksa proyek dalam sejumlah cara - misalnya, menggunakan sistem pemantauan kompilasi.  Dalam hal ini, saya melakukan analisis menggunakan plugin untuk Visual Studio - ada baiknya repositori dari kedua proyek berisi set file proyek yang membuatnya mudah dibangun di bawah Windows. <br><br>  Saya hanya harus membangun proyek untuk memastikan bahwa saya sudah semuanya siap untuk cek.  Selanjutnya saya menjalankan analisis dan - voila!  - Saya memiliki laporan analisa yang sudah jadi di depan saya. <br><br>  Perpustakaan pihak ketiga yang termasuk dalam proyek-proyek ini juga dapat mengandung kesalahan, dan mereka, tentu saja, juga dapat mempengaruhi program.  Namun, saya telah mengecualikan mereka dari analisis demi kemurnian narasi. <br><br>  Jadi, proyek dianalisis, laporan diterima, kesalahan menarik disorot.  Sudah waktunya untuk mendapatkan ulasan mereka! <br><br><h2>  Apa yang disembunyikan FreeRTOS </h2><br>  Awalnya, saya berharap untuk menulis dua artikel terpisah: satu untuk setiap sistem operasi.  Saya sudah menggosok tangan saya?  ketika saya bersiap untuk menulis artikel yang bagus tentang FreeRTOS.  Mengantisipasi penemuan setidaknya beberapa bug berair (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-457</a> ), saya sedang melihat melalui sedikit peringatan dari penganalisa, dan ... tidak menemukan apa pun.  Saya tidak menemukan kesalahan yang menarik. <br><br>  Banyak peringatan yang dikeluarkan oleh analis tidak relevan dengan FreeRTOS.  Sebagai contoh, peringatan tersebut adalah kesalahan 64-bit seperti casting <i>size_t</i> ke <i>uint32_t</i> .  Ini terkait dengan fakta bahwa FreeRTOS dimaksudkan untuk bekerja pada perangkat dengan ukuran pointer tidak lebih besar dari 32 bit. <br><br>  Saya telah memeriksa semua peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1027 dengan seksama yang</a> mengindikasikan pengecoran antara pointer ke struktur yang tidak terkait.  Jika struktur yang dicor memiliki keberpihakan yang sama, maka pengecoran semacam itu merupakan kesalahan.  Dan saya belum menemukan satu casting berbahaya! <br><br>  Semua tempat mencurigakan lainnya dikaitkan dengan gaya pengkodean atau dikelola dengan komentar yang menjelaskan mengapa itu dilakukan seperti itu dan mengapa itu bukan kesalahan. <br><br>  Jadi saya ingin menarik pengembang FreeRTOS.  Kawan, kau luar biasa!  Kami hampir tidak pernah melihat proyek bersih dan berkualitas tinggi seperti milik Anda.  Dan menyenangkan membaca kode yang bersih, rapi, dan terdokumentasi dengan baik.  Angkat topi untuk kalian. <br><br>  Meskipun saya tidak dapat menemukan bug yang menarik hari itu, saya tahu saya tidak akan berhenti di situ.  Saya pulang dengan keyakinan bahwa versi Amazon akan 100% memiliki sesuatu yang menarik, dan besok saya pasti akan mengambil cukup banyak bug untuk artikel itu.  Seperti yang Anda duga, saya benar. <br><br><h2>  Apa yang disembunyikan Amazon FreeRTOS </h2><br>  Versi sistem Amazon ternyata ... secara halus, sedikit lebih buruk.  Warisan FreeRTOS tetap bersih sementara perbaikan baru menyembunyikan banyak masalah menarik. <br><br>  Beberapa fragmen memiliki logika program rusak, beberapa pointer ditangani dengan tidak benar.  Di beberapa tempat, kode dapat menyebabkan perilaku yang tidak terdefinisi, dan ada kasus-kasus di mana programmer tidak tahu tentang pola kesalahan yang dibuatnya.  Saya bahkan menemukan beberapa potensi kerentanan serius. <br><br>  Sepertinya saya sudah memperketat dengan pendahuluan.  Mari kita mulai mencari tahu kesalahan! <br><br><h3>  Pemecahan logika program </h3><br>  Mari kita mulai dengan tempat-tempat bermasalah yang jelas-jelas menunjukkan bahwa program bekerja tidak seperti yang diharapkan oleh programmer.  Penanganan array yang mencurigakan akan didahulukan: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Pool of request and associated response buffers, * handles, and configurations. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _requestPool_t _requestPool = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _scheduleAsyncRequest(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reqIndex, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> currentRange) { .... <span class="hljs-comment"><span class="hljs-comment">/* Set the user private data to use in the asynchronous callback context. */</span></span> _requestPool.pRequestDatas[reqIndex].pConnHandle = &amp;_connHandle; _requestPool.pRequestDatas[reqIndex].pConnConfig = &amp;_connConfig; _requestPool.pRequestDatas[reqIndex].reqNum = reqIndex; _requestPool.pRequestDatas[reqIndex].currRange = currentRange; _requestPool.pRequestDatas[reqIndex].currDownloaded = <span class="hljs-number"><span class="hljs-number">0</span></span>; _requestPool.pRequestDatas[reqIndex].numReqBytes = numReqBytes; .... _requestPool.pRequestDatas-&gt;scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  PVS-Studio mengeluarkan dua peringatan untuk kode ini: <br><br><ul><li>  V619 Array '_requestPool.pRequestDatas' digunakan sebagai penunjuk ke objek tunggal.  iot_demo_https_s3_download_async.c 973 </li><li>  V574 Pointer '_requestPool.pRequestDatas' digunakan secara bersamaan sebagai array dan sebagai pointer ke objek tunggal.  Periksa baris: 931, 973. iot_demo_https_s3_download_async.c 973 </li></ul><br>  Untuk jaga-jaga, izinkan saya mengingatkan Anda: nama array adalah pointer ke elemen pertama.  Yaitu, jika <i>_requestPool.pRequestDatas</i> adalah susunan struktur, <i>_requestPool.pRequestDatas [i] .scheduled</i> adalah nilai untuk anggota yang <i>dijadwalkan</i> dari struktur <i>i</i> array. Dan jika kita menulis <i>_requestPool.pRequestDatas-&gt; terjadwal</i> , maka akan tema ini yaitu struktur array pertama akan diakses. <br><br>  Dalam kutipan kode di atas, itulah yang terjadi.  Di baris terakhir, nilai hanya anggota dari struktur array pertama diubah.  Dalam dirinya sendiri, pengaksesan semacam itu sudah mencurigakan, tetapi di sini kasusnya bahkan lebih jelas: array <i>_requestPool.pRequestDatas</i> dinilai oleh indeks di seluruh badan fungsi.  Tetapi pada akhirnya operasi pengindeksan itu dilupakan. <br><br>  Seperti yang saya pahami, baris terakhir akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">_requestPool.pRequestDatas[reqIndex].scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  Kesalahan berikutnya terletak pada fungsi kecil, jadi saya akan memberikannya sepenuhnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Return true if the string " pcString" is found * inside the token pxTok in JSON file pcJson. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prvGGDJsoneq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcJson, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">jsmntok_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pxTok, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcString )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStringSize = ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;end - ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;start; BaseType_t xStatus = pdFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pxTok-&gt;type == JSMN_STRING ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( pcString ) == ulStringSize ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span>( &amp;pcJson[ pxTok-&gt;start ], <span class="hljs-comment"><span class="hljs-comment">// &lt;= pcString, ulStringSize ) == 0 ) { xStatus = pdTRUE; } } } return xStatus; }</span></span></code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V642 [CWE-197] Menyimpan hasil fungsi 'strncmp' di dalam variabel tipe 'pendek' tidak tepat.  Bit signifikan bisa hilang melanggar logika program.  aws_greengrass_discovery.c 637 <br><br>  Mari kita lihat definisi fungsi strncmp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strncmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span></span>;</code> </pre> <br>  Dalam contoh, hasil dari tipe <i>int</i> , yang berukuran 32 bit dikonversi dalam variabel tipe <i>int16_t</i> .  Dengan konversi "penyempitan" ini, bit yang lebih lama dari nilai yang dikembalikan akan hilang.  Misalnya, jika fungsi <i>strncmp</i> mengembalikan <i>0x00010000</i> , unit akan hilang selama konversi, dan kondisi akan dieksekusi. <br><br>  Sebenarnya aneh melihat casting dalam kondisi seperti itu.  Mengapa ini diperlukan di sini, jika <i>int</i> biasa dapat dibandingkan dengan nol?  Di sisi lain, jika seorang programmer ingin fungsi ini kadang-kadang mengembalikan <i>true</i> bahkan jika tidak seharusnya, mengapa tidak mendukung perilaku rumit seperti itu dengan komentar?  Tapi dengan cara ini semacam pintu belakang.  Lagi pula, saya cenderung berpikir itu adalah kesalahan.  Apa yang kamu pikirkan <br><br><h3>  Perilaku dan petunjuk yang tidak terdefinisi </h3><br>  Inilah contoh besar.  Ini menutupi dereference null pointer potensial: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _networkReceiveCallback(....) { IotHttpsReturnCode_t status = IOT_HTTPS_OK; _httpsResponse_t* pCurrentHttpsResponse = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; IotLink_t* pQItem = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-comment"><span class="hljs-comment">/* Get the response from the response queue. */</span></span> IotMutex_Lock(&amp;(pHttpsConnection-&gt;connectionMutex)); pQItem = IotDeQueue_PeekHead(&amp;(pHttpsConnection-&gt;respQ)); IotMutex_Unlock(&amp;(pHttpsConnection-&gt;connectionMutex)); <span class="hljs-comment"><span class="hljs-comment">/* If the receive callback is invoked * and there is no response expected, * then this a violation of the HTTP/1.1 protocol. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pQItem == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { IotLogError(....); fatalDisconnect = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; status = IOT_HTTPS_NETWORK_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> iotCleanup; } .... iotCleanup : <span class="hljs-comment"><span class="hljs-comment">/* Report errors back to the application. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != IOT_HTTPS_OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pCurrentHttpsResponse-&gt;isAsync &amp;&amp; pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback) { pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback(....); } pCurrentHttpsResponse-&gt;syncStatus = status; } .... }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V522 [CWE-690] Mungkin ada dereferensi dari penunjuk null potensial 'pCurrentHttpsResponse'.  iot_https_client.c 1184 <br><br>  Blok <i>if</i> terakhir berisi dereferensi bermasalah.  Mari cari tahu apa yang terjadi di sini. <br><br>  Fungsi dimulai dengan variabel <i>pCurrentHttpsResponse</i> dan <i>pQItem</i> diinisialisasi oleh nilai <i>NULL</i> dan variabel <i>status</i> diinisialisasi oleh nilai <i>IOT_HTTPS_OK</i> , yang berarti semuanya benar. <br><br>  Selanjutnya <i>pQItem</i> diberi nilai, dikembalikan dari fungsi <i>IotDeQueue_PeekHead</i> , yang mengembalikan pointer ke awal antrian yang ditautkan ganda. <br><br>  Apa yang terjadi jika antrian kosong?  Dalam hal ini, fungsi <i>IotDeQueue_PeekHead</i> akan mengembalikan <i>NULL:</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotDeQueue_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotDeQueue_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pQueue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IotListDouble_PeekHead(pQueue); } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotListDouble_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotListDouble_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pList)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* @[declare_linear_containers_list_double_peekhead] */</span></span></span><span class="hljs-function"> </span></span>{ IotLink_t* pHead = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pList != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IotListDouble_IsEmpty(pList) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { pHead = pList-&gt;pNext; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pHead; }</code> </pre> <br>  Selanjutnya kondisi <i>pQItem == NULL</i> akan menjadi benar dan aliran kontrol akan diteruskan oleh <i>goto</i> ke bagian bawah fungsi.  Pada saat ini, pointer <i>pCurrentHttpsResponse</i> akan tetap nol, sementara <i>statusnya</i> tidak akan sama dengan <i>IOT_HTTPS_OK</i> .  Pada akhirnya, kita akan sampai ke cabang <i>if yang</i> sama, dan ... boom!  Nah, Anda tahu tentang konsekuensi dari dereference semacam itu. <br><br>  Baiklah  Itu adalah contoh yang agak rumit.  Sekarang saya sarankan agar Anda melihat dereferencing potensial yang sangat sederhana dan dapat dipahami: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PKI_mbedTLSSignatureToPkcs11Signature</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxSignaturePKCS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxMbedSignature )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * pxNextLength; <span class="hljs-comment"><span class="hljs-comment">/* The 4th byte contains the length of the R component */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ucSigComponentLength = pxMbedSignature[ <span class="hljs-number"><span class="hljs-number">3</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if( ( pxSignaturePKCS == NULL ) || ( pxMbedSignature == NULL ) ) { xReturn = FAILURE; } .... }</span></span></code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V595 [CWE-476] Pointer 'pxMbedSignature' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 52, 54. iot_pki_utils.c 52 <br><br>  Fungsi ini menerima pointer ke <i>uint8_t</i> .  Kedua petunjuk diperiksa untuk <i>NULL</i> , yang merupakan praktik yang baik - situasi seperti itu harus segera dikerjakan. <br><br>  Tapi inilah masalahnya: pada saat <i>pxMbedSignature</i> dicentang, itu sudah akan direferensikan secara harfiah satu baris di atas.  Ta-daa! <br><br>  Contoh lain dari kode spekulatif: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CK_RV </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vAppendSHA256AlgorithmIdentifierSequence</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x32ByteHashedMessage, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x51ByteHashOidBuffer )</span></span></span><span class="hljs-function"> </span></span>{ CK_RV xResult = CKR_OK; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> xOidSequence[] = pkcs11STUFF_APPENDED_TO_RSA_SIG; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( x32ByteHashedMessage == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) || ( x51ByteHashOidBuffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) { xResult = CKR_ARGUMENTS_BAD; } <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( x51ByteHashOidBuffer, xOidSequence, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( &amp;x51ByteHashOidBuffer[ <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ], x32ByteHashedMessage, <span class="hljs-number"><span class="hljs-number">32</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xResult; }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V1004 [CWE-628] Pointer 'x51ByteHashOidBuffer' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 275, 280. iot_pkcs11.c 280 </li><li>  V1004 [CWE-628] Pointer 'x32ByteHashedMessage' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 275, 281. iot_pkcs11.c 281 </li></ul><br>  Penganalisis memperingatkan bahwa parameter fungsi yang merupakan pointer, tidak aman digunakan setelah mereka memeriksa <i>NULL</i> .  Memang, argumen diperiksa.  Tetapi jika salah satu dari mereka bukan <i>NULL</i> , tidak ada tindakan yang diambil kecuali untuk menulis di <i>xResult.</i>  Bagian kode ini mengatakan: "Ya, jadi argumennya ternyata buruk.  Kami akan mencatatnya sekarang, dan Anda - teruskan, teruskan. " <br><br>  Hasil: <i>NULL</i> akan diteruskan ke <i>memcpy.</i>  Apa yang bisa terjadi?  Di mana nilai-nilai akan disalin dan yang mana?  Faktanya, menebak tidak akan membantu, karena standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan jelas menyatakan</a> bahwa panggilan seperti itu mengarah pada perilaku yang tidak terdefinisi (lihat bagian 1). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/7d6/856/cf77d6856666f6a1529a1744832bd5bf.png" alt="Gambar 3"></div><br><br>  Ada contoh lain penanganan pointer yang salah dalam laporan analisa yang ditemukan di Amazon FreeRTOS, tetapi saya pikir, contoh yang diberikan cukup untuk menunjukkan kemampuan PVS-Studio dalam mendeteksi kesalahan tersebut.  Mari kita lihat sesuatu yang baru. <br><br><h3>  BENAR! = 1 </h3><br>  Ada beberapa kesalahan terkait dengan pola, yang, sayangnya, sering diabaikan. <br><br>  Faktanya adalah bahwa tipe <i>bool</i> (dari C ++) berbeda dari tipe <i>BOOL</i> (umumnya digunakan dalam C).  Yang pertama hanya bisa berisi nilai <i>benar</i> atau <i>salah</i> .  Yang kedua adalah typedef dari tipe integer ( <i>int</i> , <i>long</i> , dan lainnya).  Nilai <i>0</i> adalah "salah" untuk itu, dan nilai lain yang berbeda dari nol adalah "benar". <br><br>  Karena tidak ada tipe Boolean bawaan di C, konstanta ini didefinisikan untuk kenyamanan: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FALSE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRUE 1</span></span></code> </pre> <br>  Mari kita lihat contohnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mbedtls_hardware_poll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* output, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* olen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lStatus = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; HCRYPTPROV hProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Unferenced parameter. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)data; <span class="hljs-comment"><span class="hljs-comment">/* * This is port-specific for the Windows simulator, * so just use Crypto API. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptAcquireContextA( &amp;hProv, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptGenRandom(hProv, len, output)) { lStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; *olen = len; } CryptReleaseContext(hProv, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lStatus; }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V676 [CWE-253] Tidak benar membandingkan variabel tipe BOOL dengan TRUE.  aws_entropy_hardware_poll.c 48 </li><li>  V676 [CWE-253] Tidak benar membandingkan variabel tipe BOOL dengan TRUE.  Ekspresi yang benar adalah: 'FALSE! = CryptGenRandom (hProv, len, output)'.  aws_entropy_hardware_poll.c 51 </li></ul><br>  Apakah Anda menemukan kesalahan?  Jangan ragu, ada di sini :) Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>CryptAcquireContextA</i></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>CryptGenRandom</i></a> adalah fungsi standar dari header <i>wincrypt.h</i> .  Jika berhasil, mereka mengembalikan nilai bukan nol.  Izinkan saya menekankan bahwa ini <i>bukan nol</i> .  Jadi, secara teoretis, nilai itu bisa berbeda dari nol: <i>1</i> , <i>314</i> , <i>42</i> , <i>420</i> . <br><br>  Rupanya, programmer yang menulis fungsi dari contoh, tidak memikirkan itu, dan pada akhirnya, nilai yang dihasilkan dibandingkan dengan satu. <br><br>  Seberapa besar kemungkinan <i>TRUE == CryptGenRandom (....)</i> kondisi tidak terpenuhi?  Sulit dikatakan.  Mungkin, <i>CryptGenRandom</i> mungkin mengembalikan 1 lebih sering daripada nilai-nilai lain, tapi mungkin itu hanya mengembalikan 1. Kita tidak bisa mengetahui ini dengan pasti: implementasi fungsi kriptografi ini disembunyikan dari mata programmer fana :) <br><br>  Penting untuk diingat bahwa perbandingan semacam itu berpotensi berbahaya.  Alih-alih: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == GetBOOL())</code> </pre> <br>  Gunakan versi kode yang lebih aman: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FALSE != GetBOOL())</code> </pre> <br><h3>  Masalah optimasi </h3><br>  Beberapa peringatan dari penganalisa terkait dengan struktur yang beroperasi secara perlahan.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">"/"</span></span>); .... }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V817 Lebih efisien untuk mencari karakter '/' daripada string.  iot_demo_https_common.c 205 <br><br>  Ini pendek dan sederhana, bukan?  Fungsi <i>strstr</i> digunakan di sini untuk mencari hanya satu karakter, diteruskan dalam parameter sebagai string (itu dalam tanda kutip ganda). <br><br>  Tempat ini berpotensi dioptimalkan dengan mengganti <i>strstr</i> dengan <i>strchr</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); .... }</code> </pre> <br>  Dengan cara ini, pencarian akan bekerja sedikit lebih cepat.  Suatu hal yang kecil, tapi menyenangkan. <br><br>  Yah, optimasi seperti itu bagus, tetapi analisanya juga telah menemukan tempat lain, yang dapat dioptimalkan dengan cara yang jauh lebih terlihat: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vRunOTAUpdateDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; ; ) { .... xConnectInfo.cleanSession = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; xConnectInfo.clientIdentifierLength = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(clientcredentialIOT_THING_NAME); xConnectInfo.pClientIdentifier = clientcredentialIOT_THING_NAME; .... } }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> V814 Penurunan kinerja.  Fungsi 'strlen' disebut beberapa kali di dalam tubuh loop.  aws_iot_ota_update_demo.c 235 <br><br>  Hmm ... Di dalam loop, dengan setiap <i>strlen</i> iterasi disebut yang mengevaluasi panjang garis yang sama setiap kali.  Bukan operasi yang paling efektif :) <br><br>  Mari kita lihat definisi <i>clientcredentialIOT_THING_NAME</i> : <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * @brief Host name. * * @todo Set this to the unique name of your IoT Thing. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> clientcredentialIOT_THING_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span></span></code> </pre> <br>  Pengguna diminta untuk memasukkan nama perangkat mereka di sini.  Secara default, ini kosong, dan dalam hal ini, semuanya baik-baik saja.  Bagaimana jika pengguna ingin memasukkan nama yang panjang dan indah di sana?  Sebagai contoh, saya ingin menyebut gagasan saya " <i>Mesin Kopi yang Bergairah dan Canggih BarBarista-N061E Edisi Tertinggi</i> ."  Bisakah Anda bayangkan seperti apa kejutan saya jika mesin kopi cantik saya mulai bekerja sedikit lebih lambat setelah itu?  Gangguan! <br><br>  Untuk memperbaiki kesalahan, ada baiknya mengambil <i>strlen di</i> luar body loop.  Lagi pula, nama perangkat tidak berubah selama program bekerja.  Oh, <i>constexpr</i> dari C ++ akan cocok di sini ... <br><br>  Oke, well, jangan menyepuh lily.  Seperti kolega saya Andrey Karpov catat, kompiler modern tahu apa itu <i>strlen</i> dan dia secara pribadi menyaksikan mereka menggunakan konstanta dalam kode biner jika mereka mendapatkan bahwa panjang garis tidak dapat berubah.  Jadi ada kemungkinan besar bahwa dalam mode rilis rilis, alih-alih evaluasi panjang garis nyata, nilai pra-evaluasi akan digunakan.  Namun, ini tidak selalu berhasil, jadi menulis kode seperti itu bukan praktik yang baik. <br><br><h2>  Beberapa kata tentang MISRA </h2><br>  Alat analisa PVS-Studio memiliki seperangkat aturan besar untuk memeriksa kode Anda untuk kepatuhan dengan standar MISRA C dan MISRA C.  Apa standar ini? <br><br>  MISRA adalah standar pengkodean untuk sistem tertanam yang sangat bertanggung jawab.  Ini berisi seperangkat aturan ketat dan pedoman untuk menulis kode dan menyiapkan proses pengembangan.  Aturan-aturan ini cukup banyak, dan mereka ditujukan tidak hanya untuk menghilangkan kesalahan serius, tetapi juga pada berbagai "bau kode".  Ini juga bertujuan untuk menulis kode yang paling mudah dipahami dan dibaca. <br><br>  Dengan demikian, mengikuti standar MISRA tidak hanya membantu menghindari kesalahan dan kerentanan, tetapi juga secara signifikan mengurangi kemungkinan kemunculan mereka dalam kode yang sudah ada. <br><br>  MISRA digunakan dalam industri dirgantara, medis, otomotif dan militer, di mana kehidupan manusia bergantung pada kualitas perangkat lunak yang disematkan. <br><br>  Tampaknya, pengembang FreeRTOS Amazon tahu tentang standar ini, dan sebagian besar mengikutinya.  Pendekatan semacam itu benar-benar masuk akal: jika Anda menulis OS berbasis luas untuk sistem embedded, maka Anda harus memikirkan keamanan. <br><br>  Namun, saya telah menemukan banyak pelanggaran terhadap standar MISRA.  Saya tidak akan memberikan contoh aturan seperti "jangan gunakan serikat" atau "fungsi seharusnya hanya memiliki satu pengembalian di akhir tubuh" - sayangnya, mereka tidak spektakuler, seperti kebanyakan aturan MISRA.  Saya lebih suka memberi Anda contoh-contoh pelanggaran yang berpotensi menimbulkan konsekuensi serius. <br><br>  Mari kita mulai dengan makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FreeRTOS_ms_to_tick(ms) ( ( ms * configTICK_RATE_HZ + 500 ) / 1000 )</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOCKETS_htonl( ulIn ) ( ( uint32_t ) \ ( ( ( ulIn &amp; 0xFF ) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24 ) | ( ( ulIn &amp; 0xFF00 ) &lt;&lt; 8 ) \ | ( ( ulIn &amp; 0xFF0000 ) &gt;&gt; 8 ) | ( ( ulIn &amp; 0xFF000000 ) &gt;&gt; 24 ) ) )</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEFT_ROTATE( x, c ) ( ( x </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; c ) | ( x &gt;&gt; ( 32 - c ) ) )</span></span></span></span></code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V2546 [MISRA C 20.7] Makro dan parameternya harus dilampirkan dalam tanda kurung.  Pertimbangkan untuk memeriksa parameter 'ms' dari makro 'FreeRTOS_ms_to_tick'.  FreeRTOS_IP.h 201 </li><li>  V2546 [MISRA C 20.7] Makro dan parameternya harus dilampirkan dalam tanda kurung.  Pertimbangkan untuk memeriksa parameter 'ulIn' dari makro 'SOCKETS_htonl'.  iot_secure_sockets.h 512 </li><li>  V2546 [MISRA C 20.7] Makro dan parameternya harus dilampirkan dalam tanda kurung.  Pertimbangkan untuk memeriksa parameter 'x', 'c' dari makro 'LEFT_ROTATE'.  iot_device_metrics.c 90 </li></ul><br>  Ya, itulah yang Anda pikirkan.  Parameter makro ini tidak diberi tanda kurung.  Jika seseorang secara tidak sengaja menulis sesuatu seperti <br><br><pre> <code class="cpp hljs">val = LEFT_ROTATE(A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span>, B);</code> </pre> <br>  "panggilan" makro semacam itu akan berkembang menjadi: <br><br><pre> <code class="cpp hljs">val = ( ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; B ) | ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; ( <span class="hljs-number"><span class="hljs-number">32</span></span> - B ) ) );</code> </pre> <br>  Ingat prioritas operasi?  Pertama, perubahan bitwise dilakukan, dan hanya setelah itu - bitwise "atau".  Karena itu, logika program akan rusak.  Contoh yang lebih sederhana: apa yang akan terjadi jika ekspresi " <i>x + y</i> " dilewatkan di makro <i>FreeRTOS_ms_to_tick</i> ?  Salah satu tujuan utama MISRA adalah untuk mencegah situasi seperti itu. <br><br>  Beberapa mungkin berpendapat, "Jika Anda memiliki programmer yang tidak tahu tentang ini, tidak ada standar yang dapat membantu Anda!"  Saya tidak akan setuju dengan itu.  Programmer juga orang, dan tidak peduli seberapa berpengalaman seseorang, mereka juga bisa lelah dan membuat kesalahan di akhir hari.  Ini adalah salah satu alasan mengapa MISRA sangat merekomendasikan menggunakan alat analisis otomatis untuk menguji kepatuhan proyek. <br><br>  Biarkan saya mengatasi pengembang Amazon FreeRTOS: PVS-Studio telah menemukan 12 makro yang lebih tidak aman, jadi Anda perlu berhati-hati dengan mereka :) <br><br>  Pelanggaran MISRA lain yang menarik: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Callback for an asynchronous request to notify * that the response is complete. * * @param[in] 0pPrivData - User private data configured * with the HTTPS Client library request configuration. * @param[in] respHandle - Identifier for the current response finished. * @param[in] rc - Return code from the HTTPS Client Library * signaling a possible error. * @param[in] status - The HTTP response status. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _responseCompleteCallback(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pPrivData, IotHttpsResponseHandle_t respHandle, IotHttpsReturnCode_t rc, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> status) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>* pUploadSuccess = (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>*)pPrivData; <span class="hljs-comment"><span class="hljs-comment">/* When the remote server response with 200 OK, the file was successfully uploaded. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == IOT_HTTPS_STATUS_OK) { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Post to the semaphore that the upload is finished. */</span></span> IotSemaphore_Post(&amp;(_uploadFinishedSem)); }</code> </pre> <br>  Bisakah Anda menemukan bug sendiri? <br><br>  <b>Peringatan PVS-Studio:</b> V2537 [MISRA C 2.7] Fungsi tidak boleh memiliki parameter yang tidak digunakan.  Pertimbangkan memeriksa parameter: 'rc'.  iot_demo_https_s3_upload_async.c 234 <br><br>  Lihatlah lebih dekat: parameter <i>rc</i> tidak digunakan di mana saja di badan fungsi.  Sementara komentar fungsi dengan jelas mengatakan bahwa parameter ini adalah kode pengembalian fungsi lain, dan bahwa itu dapat menandakan kesalahan.  Mengapa parameter ini tidak ditangani dengan cara apa pun?  Jelas ada yang salah di sini. <br><br>  Namun, bahkan tanpa komentar seperti itu, parameter yang tidak digunakan sering menunjukkan logika program yang rusak.  Kalau tidak, mengapa Anda membutuhkannya di tanda tangan fungsi? <br><br>  Di sini saya telah memberikan fungsi kecil yang bagus untuk contoh di artikel.  Selain itu, saya menemukan 10 parameter lain yang tidak digunakan.  Banyak dari mereka digunakan dalam fungsi yang lebih besar, dan tidak mudah untuk dideteksi. <br><br>  Yang mencurigakan, mereka belum ditemukan sebelumnya.  Bagaimanapun, kompiler dengan mudah mendeteksi kasus-kasus seperti itu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/6c7/bb9/b806c7bb94c335ce2712e9b46cffc560.png" alt="Gambar 1"></div><br><br><h2>  Kesimpulan </h2><br>  Ini tidak semua masalah yang ditemukan oleh penganalisa, tetapi artikel itu ternyata cukup besar.  Saya berharap bahwa berkat itu, pengembang FreeRTOS amazon akan dapat memperbaiki beberapa kekurangan, dan bahkan mungkin ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencoba PVS-Studio</a> sendiri.  Dengan cara ini akan lebih mudah untuk menyelidiki peringatan secara menyeluruh.  Dan faktanya - bekerja dengan antarmuka yang nyaman jauh lebih mudah daripada melihat laporan teks. <br><br>  Terima kasih telah membaca artikel kami!  Sampai jumpa di publikasi berikutnya: D <br><br>  PS Kebetulan artikel ini diterbitkan pada 31 Oktober. Selamat Halloween, cowok dan cewek! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473966/">https://habr.com/ru/post/id473966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473952/index.html">Seperti yang saya tulis AI untuk strategi turn-based</a></li>
<li><a href="../id473956/index.html">Informasi rahasia dari perusahaan telepon pengedar narkoba</a></li>
<li><a href="../id473958/index.html">Jepang dari NICT memperkenalkan cluster serat yang bekerja dengan bandwidth 1 Pbit / s</a></li>
<li><a href="../id473960/index.html">Strategi Pelokalan Konten</a></li>
<li><a href="../id473962/index.html">Mode gelap sekarang ada di mana-mana. Apakah ini sangat berguna? (di akhir post survey)</a></li>
<li><a href="../id473972/index.html">Atas perintah pengembang Tertanam: mencari bug di Amazon FreeRTOS</a></li>
<li><a href="../id473974/index.html">Intercom'19 - sebuah konferensi tentang otomatisasi komunikasi dari Voximplant akan diadakan pada 14 November</a></li>
<li><a href="../id473976/index.html">AWS Elasticsearch: Produk Cacat Secara fundamental</a></li>
<li><a href="../id473978/index.html">Seperti rasa sakit, rasa sakit, kasir sebagai layanan 2: 0</a></li>
<li><a href="../id473980/index.html">Teknologi dan dunia nyata: 4 Start-up yang mengubah masa depan desain interior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>