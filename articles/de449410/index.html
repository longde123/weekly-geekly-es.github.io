<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè• üé´ üåñ Interview: Schnell. Fragen und Antworten üë®üèª‚Äçüåæ üìÅ ü•Ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Programmiersprache Swift ist erst vier Jahre alt, wird jedoch bereits zur Hauptentwicklungssprache f√ºr iOS. Swift wurde zu Version 5.0 entwickelt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interview: Schnell. Fragen und Antworten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449410/">  Die Programmiersprache <b>Swift</b> ist erst vier Jahre alt, wird jedoch bereits zur Hauptentwicklungssprache f√ºr iOS.  Swift wurde zu Version 5.0 entwickelt und ist zu einer komplexen und leistungsstarken Sprache geworden, die sowohl einem objektorientierten als auch einem funktionalen Paradigma entspricht.  Und mit jeder neuen Version werden noch mehr Funktionen hinzugef√ºgt. <br><br>  Aber wie gut kennst du Swift <b>wirklich</b> ?  In diesem Artikel finden Sie Beispielfragen f√ºr ein Swift-Interview. <br><br>  Sie k√∂nnen diese Fragen verwenden, um Kandidaten zu interviewen, um ihr Wissen zu testen, oder Sie k√∂nnen Ihre eigenen testen.  Wenn Sie die Antwort nicht kennen, machen Sie sich keine Sorgen: Auf jede Frage gibt es eine Antwort. <br><a name="habracut"></a><br>  Die Fragen sind in drei Gruppen unterteilt: <br><br><ul><li>  <b>Anf√§nger</b> : f√ºr Anf√§nger.  Sie haben ein paar B√ºcher gelesen und Swift in Ihren eigenen Anwendungen angewendet. </li><li>  <b>Mittelstufe</b> : Geeignet f√ºr diejenigen, die sich wirklich f√ºr die Sprache interessieren.  Sie haben bereits viel dar√ºber gelesen und oft experimentiert. </li><li>  <b>Fortgeschritten</b> : Geeignet f√ºr die fortgeschrittensten Entwickler - diejenigen, die gerne in den Dschungel der Syntax eintauchen und fortgeschrittene Techniken anwenden m√∂chten. </li></ul><br>  F√ºr jedes Level gibt es zwei Arten von Fragen: <br><br><ul><li>  <b>geschrieben</b> : Geeignet zum Testen per E-Mail, da sie das Schreiben von Code vorschlagen. </li><li>  <b>m√ºndlich</b> : Kann verwendet werden, wenn Sie telefonieren oder pers√∂nlich sprechen, da es gen√ºgend Antworten in Worten gibt. </li></ul><br>  Halten Sie beim Lesen dieses Artikels den <b>Spielplatz</b> offen, damit Sie den Code aus der Frage √ºberpr√ºfen k√∂nnen.  Alle Antworten wurden auf <b>Xcode 10.2</b> und <b>Swift 5</b> getestet. <br><br><ul><li><h2>  <font color="#009000">Anf√§nger</font> </h2><br><div class="spoiler">  <b class="spoiler_title">schriftliche Fragen</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Frage 1</b> <div class="spoiler_text">  Betrachten Sie den folgenden Code: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tutorial</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> difficulty: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tutorial1 = <span class="hljs-type"><span class="hljs-type">Tutorial</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tutorial2 = tutorial1 tutorial2.difficulty = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Was sind die Werte von <b>tutorial1.difficulty</b> und <b>tutorial2.difficulty</b> ?  W√ºrde es einen Unterschied geben, wenn das <b>Tutorial</b> eine Klasse w√§re?  Warum? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  tutorial1.difficulty ist 1 und tutorial2.difficulty ist 2. <br><br>  In Swift sind Strukturen Werttypen.  Sie werden kopiert und nicht referenziert.  Die folgende Zeile kopiert <b>tutorial1</b> und weist es <b>tutorial2 zu</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tutorial2 = tutorial1</code> </pre> <br>  √Ñnderungen an <b>Tutorial2 wirken</b> sich nicht auf <b>Tutorial1 aus</b> . <br><br>  Wenn Tutorial eine Klasse w√§re, w√§ren <b>tutorial1.difficulty</b> und <b>tutorial2.difficulty</b> gleich 2. Klassen in Swift sind Referenztypen.  Wenn Sie die Eigenschaft tutorial1 √§ndern, wird dieselbe √Ñnderung f√ºr tutorial2 angezeigt - und umgekehrt. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 2</b> <div class="spoiler_text">  Sie haben <b>view1</b> mit <b>var</b> und <b>view2</b> mit <b>let</b> <b>deklariert</b> .  Was ist der Unterschied und wird die letzte Zeile kompiliert? <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit var view1 = UIView() view1.alpha = 0.5 let view2 = UIView() view2.alpha = 0.5 <span class="hljs-comment"><span class="hljs-comment">//   ?</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Ja, die letzte Zeile wird kompiliert.  <b>view1</b> ist eine Variable, und Sie k√∂nnen ihren Wert einer neuen Instanz von UIView zuweisen.  Mit <b>let</b> k√∂nnen Sie einen Wert nur einmal zuweisen, sodass der folgende Code nicht kompiliert wird: <br><br><pre> <code class="swift hljs">view2 = view1 <span class="hljs-comment"><span class="hljs-comment">// : view2 is immutable</span></span></code> </pre> <br>  UIView ist jedoch eine Klasse mit referenzieller Semantik, sodass Sie die Eigenschaften von view2 √§ndern k√∂nnen. Dies bedeutet, dass der Code <b>kompiliert wird</b> . </div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 3</b> <div class="spoiler_text">  Dieser Code sortiert das Array alphabetisch.  Vereinfachen Sie den Verschluss so weit wie m√∂glich. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animals = [<span class="hljs-string"><span class="hljs-string">"fish"</span></span>, <span class="hljs-string"><span class="hljs-string">"cat"</span></span>, <span class="hljs-string"><span class="hljs-string">"chicken"</span></span>, <span class="hljs-string"><span class="hljs-string">"dog"</span></span>] animals.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> { (one: <span class="hljs-type"><span class="hljs-type">String</span></span>, two: <span class="hljs-type"><span class="hljs-type">String</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> one &lt; two } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(animals)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Swift <b>ermittelt automatisch die</b> Art der Schlie√üparameter und die R√ºckgabeart, sodass Sie sie <b>entfernen k√∂nnen</b> : <br><br><pre> <code class="swift hljs">animals.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> { (one, two) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> one &lt; two }</code> </pre> <br>  Sie k√∂nnen Parameternamen mit der Notation <b>$ i</b> ersetzen: <br><br><pre> <code class="swift hljs">animals.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Abschl√ºsse, die aus einer einzelnen Anweisung bestehen, enthalten m√∂glicherweise nicht das Schl√ºsselwort <b>return</b> .  Der Wert der zuletzt ausgef√ºhrten Anweisung wird zum R√ºckgabeergebnis des Abschlusses: <br><br><pre> <code class="swift hljs">animals.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Da Swift wei√ü, dass die Elemente des Arrays dem <b>Equatable-</b> Protokoll entsprechen, k√∂nnen Sie einfach schreiben: <br><br><pre> <code class="swift hljs">animals.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(by: &lt;)</code> </pre> <br><br>  Upd: hummingbirddj noch mehr vereinfacht: <br><blockquote>  In diesem Fall k√∂nnen Sie noch k√ºrzer: <pre> <code class="swift hljs"> animals.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>()</code> </pre>  - Sortiert aufsteigend, funktioniert f√ºr Typen, die Comparable implementieren. </blockquote><br></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 4</b> <div class="spoiler_text">  Dieser Code erstellt zwei Klassen: <b>Adresse</b> und <b>Person</b> .  Es werden auch zwei Instanzen der <b>Person-</b> Klasse ( <b>Ray</b> und <b>Brian</b> ) erstellt. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullAddress: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fullAddress: <span class="hljs-type"><span class="hljs-type">String</span></span>, city: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fullAddress = fullAddress <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.city = city } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address: <span class="hljs-type"><span class="hljs-type">Address</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, address: <span class="hljs-type"><span class="hljs-type">Address</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.address = address } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headquarters = <span class="hljs-type"><span class="hljs-type">Address</span></span>(fullAddress: <span class="hljs-string"><span class="hljs-string">"123 Tutorial Street"</span></span>, city: <span class="hljs-string"><span class="hljs-string">"Appletown"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ray = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ray"</span></span>, address: headquarters) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brian = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Brian"</span></span>, address: headquarters)</code> </pre> <br>  Angenommen, <b>Brian ist</b> an eine neue Adresse umgezogen und Sie m√∂chten seinen Datensatz wie folgt aktualisieren: <br><br><pre> <code class="swift hljs">brian.address.fullAddress = <span class="hljs-string"><span class="hljs-string">"148 Tutorial Street"</span></span></code> </pre> <br>  Dies wird kompiliert und l√§uft fehlerfrei.  Wenn Sie jetzt die Adresse von <b>Ray</b> √ºberpr√ºfen, werden Sie feststellen, dass er sich ebenfalls <b>‚Äûbewegt‚Äú hat</b> . <br><br>  Was ist hier passiert und wie k√∂nnen wir das beheben? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  <b>Adresse</b> ist eine Klasse und hat <b>Referenzsemantik</b> .  Das <b>Hauptquartier</b> ist also dieselbe Instanz der Klasse, die Ray und Brian gemeinsam haben.  Durch √Ñndern des Hauptsitzes wird die Adresse von beiden ge√§ndert. <br>  Um dies zu beheben, k√∂nnen Sie <b>eine neue Instanz der Adressklasse erstellen</b> und Brian zuweisen oder <b>Adresse als Struktur anstelle einer Klasse deklarieren</b> . <br></div></div></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">m√ºndliche Fragen</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Frage 1</b> <div class="spoiler_text">  Was ist <b>optional</b> und welche Probleme l√∂sen sie? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  <b>Mit optional</b> kann eine Variable eines beliebigen Typs eine Situation <b>ohne Wert darstellen</b> .  In Objective-C war "kein Wert" nur in Referenztypen mit dem speziellen <b>Nullwert</b> verf√ºgbar.  Werttypen wie <b>int</b> oder <b>float</b> hatten diese Funktion nicht. <br>  Swift hat das Konzept "kein Wert" auf Werttypen erweitert.  Die <b>optionale</b> Variable kann entweder einen Wert oder <b>Null enthalten</b> , was auf das Fehlen eines Werts hinweist. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 2</b> <div class="spoiler_text">  Listen Sie kurz die Hauptunterschiede zwischen <b>Struktur</b> und <b>Klasse auf</b> . <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Klassen unterst√ºtzen die Vererbung, Strukturen jedoch nicht. <br>  Klassen sind ein Referenztyp, Strukturen sind ein Werttyp. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 3</b> <div class="spoiler_text">  Was sind <b>Generika</b> und wof√ºr sind sie? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  In Swift k√∂nnen Sie <b>Generika</b> in Klassen, Strukturen und Aufz√§hlungen verwenden. <br><br>  <b>Generika</b> beheben das Problem der Codeduplizierung.  Wenn Sie eine Methode haben, die Parameter eines Typs akzeptiert, m√ºssen Sie manchmal Code duplizieren, um mit Parametern eines anderen Typs zu arbeiten. <br><br>  In diesem Code ist die zweite Funktion beispielsweise ein "Klon" der ersten, au√üer dass sie Zeichenfolgenparameter und keine Ganzzahlen enth√§lt. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">areIntEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == y } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">areStringsEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x: String, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == y } areStringsEqual(<span class="hljs-string"><span class="hljs-string">"ray"</span></span>, <span class="hljs-string"><span class="hljs-string">"ray"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// true areIntEqual(1, 1) // true</span></span></code> </pre> <br>  Mit Generika kombinieren Sie zwei Funktionen in einer und sorgen gleichzeitig f√ºr die Typensicherheit: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">areTheyEqual</span></span></span><span class="hljs-function">&lt;T: Equatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x: T, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y: T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == y } areTheyEqual(<span class="hljs-string"><span class="hljs-string">"ray"</span></span>, <span class="hljs-string"><span class="hljs-string">"ray"</span></span>) areTheyEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Da Sie die Gleichheit testen, beschr√§nken Sie die Typen auf diejenigen, die dem <b>Equatable-</b> Protokoll entsprechen.  Dieser Code liefert das gew√ºnschte Ergebnis und verhindert die √úbertragung von Parametern des falschen Typs. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 4</b> <div class="spoiler_text">  In einigen F√§llen ist es nicht m√∂glich, die implizit <b>ausgepackten Optionen</b> zu vermeiden.  Wann und warum? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Die h√§ufigsten Gr√ºnde f√ºr die Verwendung implizit ausgepackter Optionen sind: <br><br><ul><li>  Wenn Sie eine Eigenschaft nicht initialisieren k√∂nnen, die zum Zeitpunkt der Erstellung nicht Null ist.  Ein typisches Beispiel ist die <b>Steckdose</b> bei Interface Builder, die immer nach ihrem Eigent√ºmer initialisiert wird.  In diesem speziellen Fall, wenn in Interface Builder alles richtig konfiguriert ist, ist sichergestellt, dass die Steckdose vor der Verwendung nicht Null ist. </li><li>  um das Problem der <b>Schleife starker Referenzen</b> zu l√∂sen, wenn zwei Instanzen von Klassen aufeinander verweisen und eine Nicht-Null-Referenz auf eine andere Instanz erforderlich ist.  In diesem Fall markieren Sie den Link auf der einen Seite als nicht <b>besessen</b> und verwenden auf der anderen Seite die implizite optionale Erweiterung. </li></ul></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 5</b> <div class="spoiler_text">  Welche M√∂glichkeiten zur optionalen Bereitstellung gibt es?  Bewerten Sie sie in Bezug auf die Sicherheit. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x : <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"Test"</span></span></code> </pre> <br><blockquote>  Hinweis: Nur 7 M√∂glichkeiten. </blockquote><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  <b>Das erzwungene Auspacken</b> ist unsicher. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span> = x!</code> </pre> <br>  <b>Die implizite Bereitstellung beim Deklarieren einer Variablen</b> ist unsicher. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = x!</code> </pre> <br>  <b>Optionale Bindung</b> ist sicher. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = x { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"x was successfully unwrapped and is = \(a)"</span></span>) }</code> </pre> <br>  <b>Optionale Verkettung</b> ist sicher. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = x?.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span></code> </pre> <br>  <b>Kein Koaleszenzbetreiber</b> ist sicher. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = x ?? <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre> <br>  Die <b>Guard-</b> Anweisung ist sicher. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  <b>Optionales Muster</b> - sicher. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a? = x { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(a) }</code> </pre> <br></div></div><br></div></div><br></div></div><br></li><li><h2>  <font color="#000090">Mittelstufe</font> </h2><br><div class="spoiler">  <b class="spoiler_title">schriftliche Fragen</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Frage 1</b> <div class="spoiler_text">  Was ist der Unterschied zwischen <b>null</b> und <b>.none</b> ? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Es gibt keinen Unterschied, <b>Optional.none</b> (kurz <b>.none</b> ) und <b>nil sind</b> gleichwertig. <br>  Tats√§chlich gibt die folgende Anweisung <b>true zur√ºck</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-literal"><span class="hljs-literal">nil</span></span> == .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span></code> </pre> <br><br>  Die Verwendung von <b>Null wird</b> allgemein akzeptiert und empfohlen. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 2</b> <div class="spoiler_text">  Hier ist ein Thermometermodell in Form von Klasse und Struktur.  Der Compiler beschwert sich √ºber die letzte Zeile.  Was ist da falsch? <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThermometerClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temperature: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> temperature: Double)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.temperature = temperature } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> thermometerClass = <span class="hljs-type"><span class="hljs-type">ThermometerClass</span></span>() thermometerClass.registerTemperature(<span class="hljs-number"><span class="hljs-number">56.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThermometerStruct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temperature: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> temperature: Double)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.temperature = temperature } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> thermometerStruct = <span class="hljs-type"><span class="hljs-type">ThermometerStruct</span></span>() thermometerStruct.registerTemperature(<span class="hljs-number"><span class="hljs-number">56.0</span></span>)</code> </pre><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  <b>ThermometerStruct wird</b> korrekt mit einer <b>Mutationsfunktion</b> deklariert, um die interne Variable zu √§ndern.  Der Compiler beschwert sich, dass Sie die <b>registerTemperature-</b> Methode der Instanz aufrufen, die mit <b>let erstellt wurde</b> , sodass diese Instanz unver√§nderlich ist.  <b>Durch √Ñndern von let in var wird</b> der Kompilierungsfehler behoben. <br><br>  In Strukturen sollten Sie Methoden, die interne Variablen √§ndern, als <b>mutierend</b> markieren. Sie k√∂nnen diese Methoden jedoch nicht mit einer unver√§nderlichen Instanz aufrufen. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 3</b> <div class="spoiler_text">  Was wird dieser Code ausgeben und warum? <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-string"><span class="hljs-string">"cars"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> closure = { [thing] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I love \(thing)"</span></span>) } thing = <span class="hljs-string"><span class="hljs-string">"airplanes"</span></span> closure()</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Es wird gedruckt: Ich liebe Autos.  Die Erfassungsliste erstellt eine Kopie der Variablen, wenn der Abschluss deklariert wird.  Dies bedeutet, dass die erfasste Variable ihren Wert auch nach dem Zuweisen eines neuen Werts nicht √§ndert. <br><br>  Wenn Sie die Erfassungsliste im Abschluss weglassen, verwendet der Compiler den Link und nicht die Kopie.  Der Abschlussaufruf spiegelt die √Ñnderung der Variablen wider: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-string"><span class="hljs-string">"cars"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> closure = { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"I love \(thing)"</span></span>) } thing = <span class="hljs-string"><span class="hljs-string">"airplanes"</span></span> closure() <span class="hljs-comment"><span class="hljs-comment">// Prints: "I love airplanes"</span></span></code> </pre> <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 4</b> <div class="spoiler_text">  Dies ist eine Funktion, die die Anzahl der eindeutigen Werte in einem Array z√§hlt: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUniques</span></span></span><span class="hljs-function">&lt;T: Comparable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: Array&lt;T&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sorted = array.sorted() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> initial: (<span class="hljs-type"><span class="hljs-type">T?</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) = (.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reduced = sorted.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(initial) { ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">0.0</span></span> == $<span class="hljs-number"><span class="hljs-number">1</span></span> ? $<span class="hljs-number"><span class="hljs-number">0.1</span></span> : $<span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduced.<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Es wird sortiert verwendet, daher werden nur Typen verwendet, die dem Comparable-Protokoll entsprechen. <br><br>  Sie k√∂nnen es so nennen: <br><br><pre> <code class="swift hljs">countUniques([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//  3</span></span></code> </pre> <br><br>  Schreiben Sie diese Funktion als Array-Erweiterung neu, damit Sie sie folgenderma√üen verwenden k√∂nnen: <br><br><pre> <code class="swift hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].countUniques() <span class="hljs-comment"><span class="hljs-comment">//   3</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Anmerkung des √úbersetzers</b> <div class="spoiler_text">  Etwas zu Schmerzhaftes ist eine monstr√∂se Funktion.  Warum nicht: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUniques</span></span></span><span class="hljs-function">&lt;T: Hashable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: Array&lt;T&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Set</span></span>(array).<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUniques</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sortedValues = sorted() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> initial: (<span class="hljs-type"><span class="hljs-type">Element?</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) = (.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reduced = sortedValues.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(initial) { ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">0.0</span></span> == $<span class="hljs-number"><span class="hljs-number">1</span></span> ? $<span class="hljs-number"><span class="hljs-number">0.1</span></span> : $<span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduced.<span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 5</b> <div class="spoiler_text">  Hier ist eine Funktion, die zwei optionale Doppel teilt.  Es gibt drei Bedingungen, die erf√ºllt sein m√ºssen: <br><ul><li>  Dividende sollte nicht Null sein </li><li>  Der Teiler sollte nicht Null sein </li><li>  Der Divisor darf nicht 0 sein </li></ul><br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend: Double?, by divisor: Double?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dividend == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> divisor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> divisor == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dividend! / divisor! }</code> </pre> <br>  Schreiben Sie diese Funktion mit der <b>Guard-</b> Anweisung neu und ohne erzwungenes Entpacken. <br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Die in Swift 2.0 eingef√ºhrte <b>Guard-</b> Anweisung bietet einen Exit, wenn die Bedingung nicht erf√ºllt ist.  Hier ist ein Beispiel: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> dividend != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><br>  Sie k√∂nnen die Guard-Anweisung auch f√ºr die <b>optionale Bindung verwenden</b> . Danach ist die erweiterte Variable <b>au√üerhalb der Guard-Anweisung</b> verf√ºgbar: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dividend = dividend <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> }</code> </pre> <br><br>  Sie k√∂nnen die Funktion also folgenderma√üen umschreiben: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend: Double?, by divisor: Double?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dividend = dividend <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> divisor = divisor <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> divisor != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dividend / divisor }</code> </pre> <br>  Beachten Sie das Fehlen eines erzwungenen Entpackens, da wir Dividende und Divisor bereits entpackt und in nicht optionale unver√§nderliche Variablen eingef√ºgt haben. <br><br>  Beachten Sie auch, dass das Ergebnis der entpackten Optionen in der Guard-Anweisung auch au√üerhalb der Guard-Anweisung verf√ºgbar ist. <br><br>  Sie k√∂nnen die Funktion weiter vereinfachen, indem Sie Guard-Anweisungen gruppieren: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend: Double?, by divisor: Double?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dividend = dividend, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> divisor = divisor, divisor != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dividend / divisor }</code> </pre> <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 6</b> <div class="spoiler_text">  Schreiben Sie die Methode aus Frage 5 mit der <b>if let-Anweisung neu</b> . <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Mit der if let-Anweisung k√∂nnen Sie Optionen entpacken und diesen Wert in diesem Codeblock verwenden.  Au√üerhalb davon sind diese Werte nicht verf√ºgbar. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend: Double?, by divisor: Double?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dividend = dividend, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> divisor = divisor, divisor != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dividend / divisor } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br></div></div><br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">m√ºndliche Fragen</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Frage 1</b> <div class="spoiler_text">  In Objective-C deklarieren Sie eine Konstante wie folgt: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> number = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Und so in Swift: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Was ist der Unterschied? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  In <b>Objective-C</b> wird <b>zur Kompilierungszeit</b> <b>eine</b> Konstante <b>mit einem</b> Wert initialisiert <b>,</b> der an dieser Stelle bekannt sein sollte. <br><br>  Ein mit <b>let</b> erstellter unver√§nderlicher Wert ist eine <b>zur Laufzeit</b> definierte Konstante.  Sie k√∂nnen es mit einem statischen oder dynamischen Ausdruck initialisieren.  Deshalb k√∂nnen wir dies tun: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> higherNumber = number + <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><br>  Bitte beachten Sie, dass eine solche Zuordnung nur einmal durchgef√ºhrt werden kann. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 2</b> <div class="spoiler_text">  Um eine statische Eigenschaft oder Funktion f√ºr Werttypen zu deklarieren, wird der <b>statische</b> Modifikator verwendet.  Hier ist ein Beispiel f√ºr die Struktur: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sun</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">illuminate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre><br>  Und f√ºr Klassen ist es m√∂glich, <b>statische</b> oder <b>Klassenmodifikatoren zu verwenden</b> .  Das Ergebnis ist das gleiche, aber es gibt einen Unterschied.  Beschreibe es. <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  <b>static</b> macht eine Eigenschaft oder Funktion statisch und <b>nicht √ºberlappend</b> .  Die Verwendung von class <b>√ºberschreibt eine</b> Eigenschaft oder Funktion. <br><br>  Hier schw√∂rt der Compiler bei dem Versuch, <b>illuminate ()</b> zu √ºberschreiben: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Star</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spin</span></span></span><span class="hljs-class">() </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">illuminate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sun</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Star</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spin</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.spin() } <span class="hljs-comment"><span class="hljs-comment">// error: class method overrides a 'final' class method override static func illuminate() { super.illuminate() } }</span></span></code> </pre> <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 3</b> <div class="spoiler_text">  Ist es m√∂glich, einem Typ mit der <b>Erweiterung</b> eine <b>gespeicherte Eigenschaft</b> hinzuzuf√ºgen?  Wie oder warum nicht? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Nein, das ist nicht m√∂glich.  Wir k√∂nnen die Erweiterung verwenden, um einem vorhandenen Typ neues Verhalten hinzuzuf√ºgen, aber wir k√∂nnen den Typ selbst oder seine Schnittstelle nicht √§ndern.  Zum Speichern der neuen gespeicherten Eigenschaft ben√∂tigen wir zus√§tzlichen Speicher, und die Erweiterung kann dies nicht tun. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 4</b> <div class="spoiler_text">  Was ist ein Protokoll in Swift? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Ein Protokoll ist ein Typ, der eine √úbersicht √ºber Methoden, Eigenschaften usw. definiert.  Eine Klasse, Struktur oder Aufz√§hlung kann ein Protokoll ben√∂tigen, um all dies zu implementieren.  Das Protokoll selbst implementiert die Funktionalit√§t nicht, sondern definiert sie. <br></div></div><br></div></div><br></div></div><br></li><li><h2>  <font color="#900000">Erweitert</font> </h2><br><div class="spoiler">  <b class="spoiler_title">schriftliche Fragen</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Frage 1</b> <div class="spoiler_text">  Angenommen, wir haben eine Struktur, die das Modell eines Thermometers definiert: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thermometer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temperature: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(temperature: <span class="hljs-type"><span class="hljs-type">Double</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.temperature = temperature } }</code> </pre> <br>  Um eine Instanz zu erstellen, schreiben wir: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t: <span class="hljs-type"><span class="hljs-type">Thermometer</span></span> = <span class="hljs-type"><span class="hljs-type">Thermometer</span></span>(temperature:<span class="hljs-number"><span class="hljs-number">56.8</span></span>)</code> </pre> <br>  Aber so etwas w√§re viel bequemer: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thermometer: <span class="hljs-type"><span class="hljs-type">Thermometer</span></span> = <span class="hljs-number"><span class="hljs-number">56.8</span></span></code> </pre> <br>  Ist es m√∂glich?  Wie? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Swift definiert Protokolle, mit denen Sie einen Typ mithilfe von Literalen durch Zuweisung initialisieren k√∂nnen.  Durch Anwenden des entsprechenden Protokolls und Bereitstellen eines √∂ffentlichen Initialisierers wird die Initialisierung mithilfe von Literalen erm√∂glicht.  Im Fall von Thermometer implementieren wir <b>ExpressibleByFloatLiteral</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thermometer</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressibleByFloatLiteral</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(floatLiteral value: <span class="hljs-type"><span class="hljs-type">FloatLiteralType</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(temperature: value) } }</code> </pre> <br><br>  Jetzt k√∂nnen wir eine Instanz wie folgt erstellen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thermometer: <span class="hljs-type"><span class="hljs-type">Thermometer</span></span> = <span class="hljs-number"><span class="hljs-number">56.8</span></span></code> </pre><br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 2</b> <div class="spoiler_text">  Swift verf√ºgt √ºber eine Reihe vordefinierter Operatoren f√ºr arithmetische und logische Operationen.  Sie k√∂nnen damit auch eigene Operatoren erstellen, sowohl un√§re als auch bin√§re. <br><br>  Definieren und implementieren Sie Ihren eigenen Potenzierungsoperator (^^) gem√§√ü den folgenden Anforderungen: <br><ul><li>  nimmt zwei int als Parameter </li><li>  Gibt das Ergebnis des Erh√∂hens des ersten Parameters auf die Potenz des zweiten zur√ºck </li><li>  verarbeitet die Reihenfolge der algebraischen Operationen korrekt </li><li>  ignoriert m√∂gliche √úberlauffehler </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Die Erstellung eines neuen Operators erfolgt in zwei Schritten: Ank√ºndigung und Implementierung. <br><br>  Die Deklaration verwendet das <b>Operator-</b> Schl√ºsselwort, um den Typ (un√§r oder bin√§r) anzugeben, um die Zeichenfolge des neuen Operators, seine Assoziativit√§t und den Vorrang der Ausf√ºhrung anzugeben. <br><br>  Hier ist der Operator ^^ und sein Typ ist infix (bin√§r).  Assoziativit√§t ist richtig. <br><br>  Swift hat kein vordefiniertes Dienstalter f√ºr die Potenzierung.  In der Algebra muss die Exponentiation vor der Multiplikation / Division berechnet werden.  Daher erstellen wir eine benutzerdefinierte Ausf√ºhrungsreihenfolge, indem wir die Exponentiation h√∂her als die Multiplikation platzieren. <br><br>  Diese Ank√ºndigung: <br><br><pre> <code class="swift hljs">precedencegroup <span class="hljs-type"><span class="hljs-type">ExponentPrecedence</span></span> { higherThan: <span class="hljs-type"><span class="hljs-type">MultiplicationPrecedence</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associativity</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ^^: <span class="hljs-type"><span class="hljs-type">ExponentPrecedence</span></span></code> </pre> <br><br>  Dies ist die Implementierung: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ^^</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base: Int, exponent: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> l = <span class="hljs-type"><span class="hljs-type">Double</span></span>(base) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r = <span class="hljs-type"><span class="hljs-type">Double</span></span>(exponent) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = pow(l, r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>(p) }</code> </pre> <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 3</b> <div class="spoiler_text">  Der folgende Code definiert die Struktur von <b>Pizza</b> und das <b>Pizzeria-</b> Protokoll mit einer Erweiterung f√ºr die Standardimplementierung der Methode <b>makeMargherita ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pizza</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ingredients: [<span class="hljs-type"><span class="hljs-type">String</span></span>] } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pizzeria</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePizza</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ingredients: [String])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Pizza</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeMargherita</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Pizza</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pizzeria</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeMargherita</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Pizza</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makePizza([<span class="hljs-string"><span class="hljs-string">"tomato"</span></span>, <span class="hljs-string"><span class="hljs-string">"mozzarella"</span></span>]) } }</code> </pre> <br><br>  Jetzt definieren wir das Restaurant <b>Lombardis</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lombardis</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pizzeria</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePizza</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ingredients: [String])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Pizza</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Pizza</span></span>(ingredients: ingredients) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeMargherita</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Pizza</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makePizza([<span class="hljs-string"><span class="hljs-string">"tomato"</span></span>, <span class="hljs-string"><span class="hljs-string">"basil"</span></span>, <span class="hljs-string"><span class="hljs-string">"mozzarella"</span></span>]) } }</code> </pre><br>  Der folgende Code erstellt zwei Instanzen von <b>Lombardis</b> .  Welche von ihnen machen Margarita mit Basilikum? <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lombardis1: <span class="hljs-type"><span class="hljs-type">Pizzeria</span></span> = <span class="hljs-type"><span class="hljs-type">Lombardis</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lombardis2: <span class="hljs-type"><span class="hljs-type">Lombardis</span></span> = <span class="hljs-type"><span class="hljs-type">Lombardis</span></span>() lombardis1.makeMargherita() lombardis2.makeMargherita()</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  In beiden.  Das <b>Pizzeria-</b> Protokoll deklariert die Methode <b>makeMargherita ()</b> und bietet eine Standardimplementierung.  Die <b>Lombardis-</b> Implementierung √ºberschreibt die Standardmethode.  Da wir die Methode im Protokoll an zwei Stellen deklariert haben, wird die korrekte Implementierung aufgerufen. <br><br>  Was aber, wenn das Protokoll die Methode <b>makeMargherita ()</b> nicht deklariert hat und die Erweiterung weiterhin die Standardimplementierung wie <b>folgt bereitstellt</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pizzeria</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePizza</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ingredients: [String])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Pizza</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pizzeria</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeMargherita</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Pizza</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makePizza([<span class="hljs-string"><span class="hljs-string">"tomato"</span></span>, <span class="hljs-string"><span class="hljs-string">"mozzarella"</span></span>]) } }</code> </pre> <br>  In diesem Fall h√§tte nur lombardis2 Pizza mit Basilikum, w√§hrend lombardis1 keine Pizza h√§tte, da die in der Erweiterung definierte Methode verwendet w√ºrde. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 4</b> <div class="spoiler_text">  Der folgende Code wird nicht kompiliert.  K√∂nnen Sie erkl√§ren, was mit ihm los ist?  Schlagen Sie L√∂sungen f√ºr das Problem vor. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kitten</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showKitten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kitten: Kitten?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = kitten <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"There is no kitten"</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(k) }</code> </pre> <br><blockquote>  Hinweis: Es gibt drei M√∂glichkeiten, um den Fehler zu beheben. </blockquote><br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Der <b>else-</b> Block der <b>Guard-</b> Anweisung erfordert eine Exit-Option, entweder mit <b>return</b> , <b>Ausl√∂sen</b> einer Ausnahme oder Aufrufen von <b>@noreturn</b> .  Die einfachste L√∂sung besteht darin, eine <b>return-Anweisung</b> hinzuzuf√ºgen. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showKitten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kitten: Kitten?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = kitten <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"There is no kitten"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(k) }</code> </pre> <br>  Diese L√∂sung l√∂st eine Ausnahme aus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KittenError</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NoKitten</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kitten</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showKitten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kitten: Kitten?)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = kitten <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"There is no kitten"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-type"><span class="hljs-type">KittenError</span></span>.<span class="hljs-type"><span class="hljs-type">NoKitten</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(k) } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> showKitten(kitten: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><br>  Schlie√ülich ist hier der Aufruf von <b>fatalError ()</b> , der Funktion <b>@noreturn</b> . <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kitten</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showKitten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kitten: Kitten?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = kitten <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"There is no kitten"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>() } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(k) }</code> </pre> <br></div></div><br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">m√ºndliche Fragen</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Frage 1</b> <div class="spoiler_text">  Sind Verschl√ºsse ein Referenztyp oder ein Werttyp? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  <b>Verschl√ºsse sind ein Referenztyp.</b>  Wenn Sie einer Variablen einen Abschluss zuweisen und ihn dann in eine andere Variable kopieren, kopieren Sie den Link zu demselben Abschluss und seiner Erfassungsliste. <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 2</b> <div class="spoiler_text">  Sie verwenden den <b>UInt-</b> Typ, um eine vorzeichenlose Ganzzahl zu speichern.  Es implementiert einen Initialisierer zum Konvertieren von einem Ganzen mit einem Vorzeichen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> value: <span class="hljs-type"><span class="hljs-type">Int</span></span>)</code> </pre><br>  Der folgende Code wird jedoch nicht kompiliert, wenn Sie einen negativen Wert angeben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myNegative = <span class="hljs-type"><span class="hljs-type">UInt</span></span>(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Vorzeichenbehaftete Ganzzahlen k√∂nnen per Definition nicht negativ sein.  Es ist jedoch m√∂glich, die Darstellung einer negativen Zahl im Speicher zu verwenden, um sie in eine vorzeichenlose Zahl zu √ºbersetzen. <br><br>  Wie kann ich eine negative Ganzzahl in UInt konvertieren, w√§hrend ihre Darstellung im Speicher bleibt? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Hierf√ºr gibt es einen Initialisierer: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">UInt</span></span>(bitPattern: <span class="hljs-type"><span class="hljs-type">Int</span></span>)</code> </pre> <br><br>  Und benutze: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myNegative = <span class="hljs-type"><span class="hljs-type">UInt</span></span>(bitPattern: -<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 3</b> <div class="spoiler_text">  Zirkelverweise in Swift beschreiben?  Wie k√∂nnen sie behoben werden? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Zirkelverweise treten auf, wenn zwei Instanzen einen starken Bezug zueinander haben, was zu einem Speicherverlust f√ºhrt, da keine dieser Instanzen freigegeben werden kann.  Eine Instanz kann nicht freigegeben werden, solange noch starke Verweise darauf vorhanden sind, aber eine Instanz enth√§lt die andere. <br><br>  Dies kann behoben werden, indem der Link auf einer Seite durch Angabe des Schl√ºsselworts <b>schwach</b> oder nicht <b>besessen ersetzt wird</b> . <br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Frage 4</b> <div class="spoiler_text">  Mit Swift k√∂nnen Sie rekursive Aufz√§hlungen erstellen.  Hier ist ein Beispiel f√ºr eine solche Aufz√§hlung, die eine Knotenvariante mit zwei assoziativen Typen, T und Liste, enth√§lt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> node(<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;) }</code> </pre><br>  Es wird ein Kompilierungsfehler auftreten.  Was haben wir vermisst? <br><br><div class="spoiler">  <b class="spoiler_title">die Antwort</b> <div class="spoiler_text">  Wir haben das <b>indirekte</b> Schl√ºsselwort vergessen, das √§hnliche rekursive Aufz√§hlungsoptionen erm√∂glicht: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">indirect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> node(<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;) }</code> </pre> <br></div></div><br></div></div><br></div></div><br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449410/">https://habr.com/ru/post/de449410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449388/index.html">Drucken ... Leidenschaft?</a></li>
<li><a href="../de449390/index.html">Benchmarking Emely</a></li>
<li><a href="../de449392/index.html">Abrufen von Statistiken f√ºr alle Clients aus der Yandex.Direct-API nach Tagen mithilfe von Python</a></li>
<li><a href="../de449398/index.html">Mikhail Larionov, Circles.is: √úber Karrieren auf Facebook, Unternehmertum, Community Building und Produktdenken</a></li>
<li><a href="../de449408/index.html">Advantech HMI-basiertes HMI-Bedienfeld</a></li>
<li><a href="../de449412/index.html">Was die Verbrauchergemeinschaft tut, um Open Source-Software zu zerst√∂ren</a></li>
<li><a href="../de449414/index.html">Wurzelvaginalmikroben</a></li>
<li><a href="../de449418/index.html">Erstellen Sie ein Widget mit benutzerdefinierten CSS-Eigenschaften: Betten Sie einen benutzerdefinierten Link zur NHL-Website ein</a></li>
<li><a href="../de449422/index.html">Alarm! Alarm!: Wie Fische Verwandte vor Gefahren warnen</a></li>
<li><a href="../de449424/index.html">3 Amigo - eine Art der Kommunikation, um ein Qualit√§tsprodukt zu schaffen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>