<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿 🔤 🏡 Offline-Modus unter iOS und Funktionen seiner Implementierung unter Realm ⛈️ 👩🏽‍🚀 👨‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gepostet von Ekaterina Semashko, Starke Junior iOS-Entwicklerin, DataArt 

 Ein wenig über das Projekt: eine mobile Anwendung für die iOS-Plattform, g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Offline-Modus unter iOS und Funktionen seiner Implementierung unter Realm</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataart/blog/432422/"><img src="https://habrastorage.org/webt/mz/rf/z2/mzrfz2k1ntkzycx5hxev_211qrc.jpeg"><br><br>  <i>Gepostet von Ekaterina Semashko, Starke Junior iOS-Entwicklerin, DataArt</i> <br><br>  Ein wenig über das Projekt: eine mobile Anwendung für die iOS-Plattform, geschrieben in Swift.  Der Zweck der Anwendung ist die Möglichkeit, Rabattkarten zwischen Mitarbeitern des Unternehmens und ihren Freunden zu teilen. <br><br>  Eines der Ziele des Projekts war es, beliebte Technologien und Bibliotheken zu lernen und zu üben.  Realm wurde zum Speichern lokaler Daten ausgewählt, Alamofire wurde für die Arbeit mit dem Server verwendet, Google Sign-In wurde zur Authentifizierung verwendet, PINRemoteImage wurde zum Hochladen von Bildern verwendet. <br><br>  Die Hauptfunktionen der Anwendung: <br><br><ul><li>  Hinzufügen einer Karte, Bearbeiten und Löschen; </li><li>  Anzeigen der Karten anderer Personen; </li><li>  Suche nach Karten nach Geschäftsname / Benutzername; </li><li>  Fügen Sie Ihren Favoriten Karten für den schnellen Zugriff hinzu. </li></ul><br>  Die Möglichkeit, die Anwendung ohne Verbindung zum Netzwerk zu verwenden, wurde von Anfang an vorausgesetzt, jedoch nur im Lesemodus.  Das heißt,  Wir konnten Informationen über Karten anzeigen, aber ohne das Internet nicht ändern.  Zu diesem Zweck verfügte die Anwendung immer über eine Kopie aller Karten und Marken der Datenbank vom Server sowie über eine Liste der Favoriten für den aktuellen Benutzer.  Die Suche wurde auch lokal implementiert. <br><br>  Später beschlossen wir, offline durch Hinzufügen eines Aufnahmemodus zu erweitern.  Informationen zu vom Benutzer vorgenommenen Änderungen wurden gespeichert und synchronisiert, als eine Internetverbindung hergestellt wurde.  Die Implementierung eines solchen Lese- / Schreib-Offline-Modus wird diskutiert. <a name="habracut"></a><br><br><hr><br>  Was ist für einen vollständigen Offline-Modus in einer mobilen Anwendung erforderlich?  Wir müssen die Abhängigkeit des Benutzers von der Qualität der Internetverbindung beseitigen, insbesondere: <br><br><ol><li>  Entfernen Sie die Abhängigkeit der Antworten des Benutzers von seinen Aktionen in der Benutzeroberfläche vom Server.  Zunächst wird die Anforderung mit dem lokalen Speicher interagiert und dann an den Server gesendet. </li><li>  Lokale Änderungen markieren und speichern. </li><li>  Implementieren eines Synchronisationsmechanismus - Wenn eine Internetverbindung angezeigt wird, müssen Sie Änderungen an den Server senden. </li><li>  Zeigen Sie dem Benutzer, welche Änderungen synchronisiert sind, welche nicht. </li></ol><br><h2>  Offline-First-Ansatz </h2><br>  Zunächst musste ich den vorhandenen Mechanismus für die Interaktion mit dem Server und der Datenbank ändern.  Ziel war es, den Benutzer daran zu hindern, von der Anwesenheit oder Abwesenheit des Internets abhängig zu sein.  Zunächst sollte es mit dem lokalen Data Warehouse interagieren und Serveranforderungen sollten im Hintergrund stehen. <br><br>  In der vorherigen Version bestand eine starke Verbindung zwischen der Datenspeicherschicht und der Netzwerkschicht.  Der Mechanismus für die Arbeit mit Daten war wie folgt: Zuerst wurde über die NetworkManager-Klasse eine Anforderung an den Server gestellt, wir haben auf das Ergebnis gewartet, danach wurden die Daten über die Repository-Klasse in der Datenbank gespeichert.  Dann wurde das Ergebnis an die Benutzeroberfläche übergeben, wie im Diagramm gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/n9/8d/twn98dmriqa0uuzej10hjhntw78.png"></div><br>  Um den Offline-First-Ansatz zu implementieren, habe ich die Datenspeicherschicht und die Netzwerkschicht getrennt und eine neue Flow-Klasse eingeführt, die die Reihenfolge steuert, in der NetworkManager und Repository aufgerufen wurden.  Jetzt werden die Daten zuerst über die Repository-Klasse in der Datenbank gespeichert, dann wird das Ergebnis an die Benutzeroberfläche gesendet und der Benutzer arbeitet weiterhin mit der Anwendung.  Im Hintergrund wird eine Anforderung an den Server gesendet. Nach der Antwort werden die Informationen in der Datenbank und der Benutzeroberfläche aktualisiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wi/ru/yd/wiruyd-reybblt8x0zp1lzcgd14.png"></div><br><h2>  Arbeiten Sie mit Objektkennungen </h2><br>  Mit der neuen Architektur wurden mehrere neue Aufgaben angezeigt, von denen eine mit ID-Objekten arbeitet.  Zuvor haben wir sie beim Erstellen des Objekts vom Server erhalten.  Jetzt wurde das Objekt lokal erstellt. Dementsprechend musste eine ID generiert und nach der Synchronisierung auf die aktuellen aktualisiert werden.  Hier bin ich auf die erste Einschränkung von Realm gestoßen: Nach dem Erstellen eines Objekts können Sie dessen Primärschlüssel nicht mehr ändern. <br><br>  Die erste Option bestand darin, den Primärschlüssel im Objekt aufzugeben und id zu einem regulären Feld zu machen.  Gleichzeitig gingen jedoch die Vorteile der Verwendung des Primärschlüssels verloren: Realm-Indizierung, die das Abrufen des Objekts beschleunigt, die Möglichkeit, das Objekt mit dem Flag create zu aktualisieren (ein Objekt erstellen, falls es nicht vorhanden ist) und die Einhaltung der Eindeutigkeit des Objekts. <br><br>  Ich wollte den Primärschlüssel speichern, aber es konnte nicht die ID des Objekts vom Server sein.  Infolgedessen bestand die funktionierende Lösung darin, zwei Bezeichner zu haben, einen Server, ein optionales Feld und den zweiten lokalen Bezeichner, der der Primärschlüssel sein würde. <br><br>  Infolgedessen wird beim lokalen Erstellen des Objekts auf dem Client eine lokale ID generiert. Wenn das Objekt vom Server stammt, entspricht es der Server-ID.  Da es in der einzigen Quelle der Wahrheitsanwendung eine Datenbank gibt, wird das Objekt beim Empfang von Daten vom Server mit der aktuellen lokalen Kennung aktualisiert und arbeitet nur damit.  Beim Senden von Daten an den Server wird die Server-ID übertragen. <br><br><h2>  Speicherung nicht synchronisierter Änderungen </h2><br>  Änderungen an Objekten, die noch nicht an den Server gesendet wurden, müssen lokal gespeichert werden.  Dies kann auf folgende Arten implementiert werden: <br><br><ol><li>  Hinzufügen von Feldern zu vorhandenen Objekten </li><li>  Speichern nicht synchronisierter Objekte in separaten Tabellen; </li><li>  Speichern einzelner Feldänderungen in einem bestimmten Format. </li></ol><br><br>  Ich verwende Realm-Objekte nicht direkt in meinen Klassen, sondern mache ihre Zuordnung selbst, um Probleme mit Multithreading zu vermeiden.  Die automatische Aktualisierung der Benutzeroberfläche erfolgt anhand von Beispielen für die automatische Aktualisierung der Ergebnisse, bei denen ich Aktualisierungsanforderungen abonniere.  Nur der erste Ansatz funktionierte mit meiner aktuellen Architektur, daher fiel die Wahl auf das Hinzufügen von Feldern zu vorhandenen Objekten. <br><br>  Das Kartenobjekt hat die meisten Änderungen erfahren: <br><br><ul><li>  synchronisiert - Gibt es Daten auf dem Server? </li><li>  gelöscht - true, wenn die Karte nur lokal gelöscht wird, ist eine Synchronisierung erforderlich. </li></ul><br>  Bezeichner, die im vorherigen Teil besprochen wurden: <br><br><ul><li>  localId - der Primärschlüssel der Entität in der Anwendung, entweder gleich der Server-ID oder lokal generiert; </li><li>  serverId - ID vom Server. </li></ul><br>  Besonders erwähnenswert ist die Speicherung von Bildern.  Im Wesentlichen wurde das Anhangsfeld diskURL zum serverURL-Feld des Images auf dem Server hinzugefügt, in dem die Adresse des lokalen nicht synchronisierten Images gespeichert ist.  Bei der Synchronisierung des Bildes wurde das lokale Bild gelöscht, um den Speicher des Geräts nicht zu verstopfen. <br><br><h2>  Serversynchronisierung </h2><br>  Um mit dem Server zu synchronisieren, wurde die Arbeit mit Erreichbarkeit hinzugefügt, sodass der Synchronisierungsmechanismus gestartet wird, wenn das Internet angezeigt wird. <br><br>  Zunächst wird geprüft, ob Änderungen an der Datenbank vorliegen, die übermittelt werden müssen.  Anschließend wird eine Anforderung an den Server für eine tatsächliche Datenübertragung gesendet. Infolgedessen werden Änderungen, die nicht an den Client gesendet werden müssen, herausgefiltert (z. B. eine Änderung an einem Objekt, das bereits auf dem Server gelöscht wurde).  Die verbleibenden Änderungen stellen Anforderungen an den Server in die Warteschlange. <br><br>  Um Änderungen zu senden, war es möglich, Massenaktualisierungen zu implementieren, die Änderungen in einem Array zu senden oder eine große Anforderung zum Synchronisieren aller Daten zu stellen.  Zu diesem Zeitpunkt war der Backend-Entwickler jedoch bereits mit einem anderen Projekt beschäftigt und half uns nur in unserer Freizeit. Daher erstellen wir eine Anfrage für jede Art von Änderung. <br><br>  Ich habe die Warteschlange über OperationQueue implementiert und jede Anforderung in eine asynchrone Operation eingeschlossen.  Einige Operationen hängen voneinander ab. Beispielsweise können wir das Kartenbild vor dem Erstellen der Karte nicht laden. Daher habe ich die Abhängigkeit der Bildoperation zur Kartenoperation hinzugefügt.  Außerdem hatte das Hochladen von Bildern auf den Server eine niedrigere Priorität als alle anderen, und ich habe sie aufgrund ihrer Schwere auch zuletzt in die Warteschlange aufgenommen. <br><br>  Bei der Planung des Offline-Modus bestand die große Frage darin, Konflikte mit dem Server während der Synchronisierung zu lösen.  Als wir jedoch während der Implementierung an diesen Punkt kamen, stellten wir fest, dass der Fall, dass ein Benutzer dieselben Daten auf verschiedenen Geräten ändert, sehr selten ist.  Es reicht uns also, den Mechanismus für die letzten Writer-Gewinne zu implementieren.  Während der Synchronisierung haben nicht gesendete Änderungen auf dem Client immer Vorrang, sie werden nicht gerieben. <br><br>  Die Fehlerbehandlung steckt noch in den Kinderschuhen. Wenn die Synchronisierung fehlschlägt, wird das Objekt beim nächsten Erscheinen des Internets zur Änderungswarteschlange hinzugefügt.  Und wenn es nach dem Zusammenführen immer noch nicht synchron ist, entscheidet der Benutzer, ob er es verlassen oder löschen möchte. <br><br><h2>  Zusätzliche Problemumgehung bei der Arbeit mit Realm </h2><br>  Bei der Arbeit mit Realm gab es einige weitere Probleme.  Vielleicht ist diese Erfahrung auch für jemanden nützlich. <br><br>  Bei der Sortierung nach Zeichenfolge richtet sich die Reihenfolge nach der Zeichenreihenfolge in UTF-8. Es gibt keine Unterstützung für die Suche zwischen Groß- und Kleinschreibung.  Wir sind mit einer Situation konfrontiert, in der die Namen in Kleinbuchstaben nach den Namen in Großbuchstaben stehen, zum Beispiel: Magnet, Pyaterochka, Ribbon.  Wenn die Liste sehr groß ist, werden alle Namen in Kleinbuchstaben unten angezeigt, was sehr unangenehm ist. <br><br>  Um die Sortierreihenfolge unabhängig von der Groß- und Kleinschreibung beizubehalten, mussten wir ein neues Feld für den Namen mit niedrigerem Fall einführen, es beim Aktualisieren des Namens aktualisieren und danach sortieren. <br><br>  Außerdem wurde ein neues Feld zum Sortieren nach dem Vorhandensein einer Karte in den Favoriten hinzugefügt, da dies im Wesentlichen eine Unterabfrage für die Beziehungen des Objekts erfordert. <br><br>  Bei der Suche in Realm gibt es die CONTAINS [c]% @ -Methode für Suchvorgänge ohne Berücksichtigung der Groß- und Kleinschreibung.  Aber leider funktioniert es nur mit dem lateinischen Alphabet.  Für russische Marken mussten wir auch separate Felder erstellen und danach suchen.  Später stellte sich heraus, dass es in unseren Händen lag, Sonderzeichen bei der Suche auszuschließen. <br><br><hr><br>  Wie Sie sehen können, ist es für mobile Anwendungen durchaus möglich, einen Offline-Modus zu implementieren, in dem Änderungen gespeichert und mit wenig Blut synchronisiert werden, manchmal sogar mit minimalen Änderungen im Backend. <br><br>  Trotz einiger Schwierigkeiten können Sie Realm verwenden, um es zu implementieren, und gleichzeitig alle Vorteile in Form von Live-Updates, einer Nullkopie-Architektur und einer praktischen API erhalten. <br><br>  Es gibt also keinen Grund, Ihren Benutzern jederzeit den Zugriff auf Daten zu verweigern, unabhängig von der Qualität der Verbindung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432422/">https://habr.com/ru/post/de432422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432412/index.html">Highload ++: So helfen Sie dem ERP-System, 500.000 Anfragen pro Sekunde zu bewältigen</a></li>
<li><a href="../de432414/index.html">Alte Geheimnisse für schnelles Debuggen: Animieren des Quellcodes</a></li>
<li><a href="../de432416/index.html">Abhängige Typen - Die Zukunft der Programmiersprachen</a></li>
<li><a href="../de432418/index.html">Analysieren von Lambda-Ausdrücken in Java</a></li>
<li><a href="../de432420/index.html">Einführung in Git Merge und Git Rebase: Warum und wann sie verwendet werden sollen</a></li>
<li><a href="../de432424/index.html">HyperFlex Certified Infrastructure für SAP HANA</a></li>
<li><a href="../de432426/index.html">Debuggen eines Fehlers, der nicht abgespielt wird</a></li>
<li><a href="../de432428/index.html">Zentraler Bus gegen Service Mesh: Wie man einen Mitap in eine Schlacht verwandelt</a></li>
<li><a href="../de432432/index.html">Die neue Technologie der Océ ColorWave-Serie verbessert den Druck</a></li>
<li><a href="../de432434/index.html">Rover-Entwickler der nächsten Generation verwenden KI, um die Rover-Effizienz zu steigern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>