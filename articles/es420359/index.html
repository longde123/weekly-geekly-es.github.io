<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖ∞Ô∏è üìã üë®üèª‚Äç‚öïÔ∏è Var, let o const? Problemas de alcance variable y ES6 ‚úåüèΩ ü§≥üèº ü§æ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los √°mbitos en JavaScript siempre han sido un tema complicado, especialmente en comparaci√≥n con lenguajes m√°s estrictamente organizados como C y Java....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Var, let o const? Problemas de alcance variable y ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420359/"> Los √°mbitos en JavaScript siempre han sido un tema complicado, especialmente en comparaci√≥n con lenguajes m√°s estrictamente organizados como C y Java.  Durante muchos a√±os, el alcance en JS no fue particularmente discutido, ya que el lenguaje simplemente no ten√≠a ning√∫n medio que afectara significativamente la situaci√≥n actual.  Pero en ECMAScript 6 hay algunas caracter√≠sticas nuevas que permiten a los desarrolladores controlar mejor el alcance de las variables.  Estas caracter√≠sticas ahora son muy compatibles con los navegadores, son bastante accesibles para la mayor√≠a de los desarrolladores.  Sin embargo, las nuevas palabras clave para declarar variables, teniendo en cuenta el hecho de que la antigua palabra clave <code>var</code> no ha desaparecido, significan no solo nuevas oportunidades, sino tambi√©n la aparici√≥n de nuevas preguntas.  ¬øCu√°ndo usar las palabras clave <code>let</code> y <code>const</code> ?  ¬øC√≥mo se comportan?  ¬øEn qu√© situaciones la palabra clave <code>var</code> sigue siendo relevante?  El material, cuya traducci√≥n publicamos hoy, tiene como objetivo explorar el problema del alcance de las variables en JavaScript. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/v4/6q/as/v46qas_2e_rx9sypmgyz4trnhr0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">√Åmbitos variables: una visi√≥n general</font> </h2><br>  El alcance de una variable es un concepto importante en la programaci√≥n, que, sin embargo, puede confundir a algunos desarrolladores, especialmente a los novatos.  El alcance de una variable es la parte del programa en la que se puede acceder a esta variable. <br><br>  Eche un vistazo al siguiente ejemplo: <br><br><pre> <code class="hljs matlab">var myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  ¬øCu√°l ser√° el resultado del m√©todo <code>console.log</code> ?  La respuesta a esta pregunta no sorprender√° a nadie: generar√° <code>2</code> .  La variable <code>myVar</code> declara fuera de una funci√≥n, lo que nos dice que se declara en el √°mbito global.  Por lo tanto, cualquier funci√≥n declarada en el mismo alcance podr√° acceder a <code>myVar</code> .  De hecho, cuando se trata de c√≥digo ejecutado en un navegador, incluso las funciones declaradas en otros archivos conectados a la p√°gina tendr√°n acceso a esta variable. <br><br>  Ahora eche un vistazo al siguiente c√≥digo: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Exteriormente, sus cambios, en comparaci√≥n con el ejemplo anterior, son insignificantes.  Es decir, simplemente colocamos la declaraci√≥n de variable dentro de la funci√≥n.  ¬øCu√°l ser√° la salida de <code>console.log</code> ahora?  De hecho, nada, ya que esta variable no se declara y cuando intenta acceder a ella, se mostrar√° un mensaje sobre un error <code>ReferenceError</code> no manejado.  Sucedi√≥ porque la variable se declar√≥ dentro de la funci√≥n utilizando la palabra clave <code>var</code> .  Como resultado, el alcance de esta variable se limita al alcance interno de la funci√≥n.  Se puede acceder en el cuerpo de esta funci√≥n, las funciones integradas en esta funci√≥n pueden funcionar con ella, pero no es accesible desde el exterior.  Si necesitamos varias funciones en el mismo nivel para usar una determinada variable, debemos declarar esta variable en el mismo lugar donde se declaran estas funciones, es decir, un nivel m√°s alto que su alcance interno. <br><br>  Aqu√≠ hay una observaci√≥n interesante: el c√≥digo de la mayor√≠a de los sitios web y aplicaciones web no se aplica al trabajo de ning√∫n programador.  La mayor√≠a de los proyectos de software son el resultado del desarrollo del equipo y, adem√°s, utilizan bibliotecas y marcos de terceros.  Incluso si solo un programador est√° involucrado en el desarrollo de un sitio web, generalmente utiliza recursos externos.  Debido a esto, generalmente no se recomienda declarar variables en el √°mbito global, ya que no puede saber de antemano qu√© variables ser√°n declaradas por otros desarrolladores cuyo c√≥digo se utilizar√° en el proyecto.  Para solucionar este problema, puede usar algunos trucos, en particular, el patr√≥n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√≥dulo</a> " y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IIFE</a> al aplicar el enfoque orientado a objetos para el desarrollo de JavaScript, aunque la encapsulaci√≥n de datos y funciones en objetos comunes puede lograr el mismo efecto.  En general, se puede observar que las variables cuyo alcance va m√°s all√° de lo que necesitan suelen ser un problema con el que hay que hacer algo. <br><br><h2>  <font color="#3AC1EF">Problema de palabra clave var</font> </h2><br>  Entonces, descubrimos el concepto de "alcance".  Ahora pasemos a cosas m√°s complejas.  Echa un vistazo al siguiente c√≥digo: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = 0; i &lt; 3; i++)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  ¬øQu√© llegar√° a la consola despu√©s de su ejecuci√≥n?  Est√° claro que los valores del contador creciente <code>i</code> : <code>0</code> , <code>1</code> y <code>2</code> se mostrar√°n dentro del bucle.  Una vez que finaliza el ciclo, el programa contin√∫a ejecut√°ndose.  Ahora estamos intentando acceder a la misma variable de contador que se declar√≥ en el bucle <code>for</code> , fuera de este bucle.  ¬øQu√© saldr√° de esto? <br><br>  Despu√©s de llamar a <code>i</code> fuera del ciclo, 3 ingresar√° a la consola, ya que la palabra clave <code>var</code> act√∫a en el nivel de funci√≥n.  Si declara una variable usando <code>var</code> , puede acceder a ella en una funci√≥n incluso despu√©s de salir de la construcci√≥n donde se declar√≥. <br><br>  Esto puede convertirse en un problema cuando las funciones se vuelven m√°s complejas.  Considere el siguiente ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  ¬øQu√© llegar√° a la consola ahora?  <code>2</code> y <code>2</code> .  Declaramos una variable, la inicializamos con el n√∫mero 1 y luego intentamos redefinir la misma variable dentro de la <code>if</code> .  Dado que estas dos declaraciones existen en el mismo √°mbito, no podemos declarar una nueva variable con el mismo nombre, aunque obviamente queremos hacer exactamente eso.  Como resultado, la primera variable se sobrescribe dentro de la <code>if</code> . <br><br>  Este es precisamente el mayor defecto de la palabra clave <code>var</code> .  El alcance de las variables declaradas al usarlo es demasiado grande.  Esto puede conducir a la sobrescritura involuntaria de datos y otros errores.  Grandes √°reas de visibilidad a menudo conducen a programas inexactos.  En general, una variable debe tener un alcance limitado por sus necesidades, pero sin excederlas.  Ser√≠a bueno poder declarar variables cuyo alcance no sea tan grande como cuando se usa <code>var</code> , lo que har√≠a posible, si es necesario, usar construcciones de software m√°s estables y mejores a prueba de errores.  En realidad, ECMAScript 6 nos brinda tales oportunidades. <br><br><h2>  <font color="#3AC1EF">Nuevas formas de declarar variables</font> </h2><br>  El est√°ndar ECMAScript 6 (un nuevo conjunto de caracter√≠sticas de JavaScript, tambi√©n conocido como ES6 y ES2015) nos ofrece dos nuevas formas de declarar variables que difieren en alcance, en comparaci√≥n con <code>var</code> , y tienen algunas caracter√≠sticas m√°s.  Estas son las palabras clave <code>let</code> y <code>const</code> .  Ambos nos dan el llamado alcance de bloque.  Esto significa que el alcance de su uso puede limitarse a un bloque de c√≥digo, como un bucle <code>for</code> o una <code>if</code> .  Esto le da al desarrollador m√°s flexibilidad para elegir el alcance de las variables.  Considere las nuevas palabras clave. <br><br><h3>  <font color="#3AC1EF">‚ñçUso de la palabra clave let</font> </h3><br>  La palabra clave <code>let</code> es muy similar a <code>var</code> , la principal diferencia es el alcance limitado de las variables declaradas con ella.  Reescribimos uno de los ejemplos anteriores, reemplazando <code>var</code> con <code>let</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  En este caso, los n√∫meros <code>2</code> y <code>1</code> llegar√°n a la consola.  Esto sucede porque la <code>if</code> establece un nuevo alcance para la variable declarada con la palabra clave <code>let</code> .  Esto lleva al hecho de que la segunda variable declarada es una entidad completamente independiente, no relacionada con la primera.  Puede trabajar con ellos independientemente uno del otro.  Sin embargo, esto no significa que los bloques de c√≥digo anidados, como nuestra <code>if</code> , est√©n completamente separados de las variables declaradas con la palabra clave <code>let</code> en el √°mbito en el que se encuentran.  Echa un vistazo al siguiente c√≥digo: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  En este ejemplo, la consola obtendr√° el n√∫mero <code>1</code> .  El c√≥digo dentro de la <code>if</code> tiene acceso a la variable que creamos fuera de ella.  Por lo tanto, muestra su valor en la consola.  ¬øY qu√© pasa si intentas mezclar el alcance?  Por ejemplo, haz esto: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar);   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  Puede parecer que la primera llamada <code>console.log</code> generar√° <code>1</code> , pero de hecho, cuando intente ejecutar este c√≥digo, aparecer√° un error de <code>ReferenceError</code> que nos indica que la variable <code>myVar</code> para este alcance no est√° definida o no est√° inicializada (el texto de este error difiere en diferentes navegadores)  En JavaScript, existe la posibilidad de elevar las variables a la parte superior de su alcance.  Es decir, si una variable se declara en un determinado √°mbito, JavaScript le reserva un lugar incluso antes de que se ejecute el comando para declararla.  C√≥mo exactamente esto sucede difiere cuando se usa <code>var</code> y <code>let</code> . <br><br>  Considere el siguiente ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(varTest); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> varTest = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letTest); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letTest = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  En ambos casos, intentamos usar la variable antes de declararla.  Pero los comandos de salida de la consola se comportan de manera diferente.  El primero, usar una variable que luego se declarar√° usando la palabra clave <code>var</code> , generar√° un resultado <code>undefined</code> , es decir, lo que se escribir√° en esta variable.  El segundo comando, que intenta acceder a la variable, que luego se declarar√° utilizando la palabra clave <code>let</code> , arrojar√° un <code>ReferenceError</code> y nos dir√° que estamos tratando de usar la variable antes de declararla o inicializarla.  Que pasa <br><br>  Pero el hecho es que antes de que se ejecute el c√≥digo, los mecanismos responsables de su ejecuci√≥n observan este c√≥digo, descubren si se declarar√°n variables en √©l y, de ser as√≠, los plantean con reserva de espacio para ellos.  En este caso, las variables declaradas usando la palabra clave <code>var</code> se inicializan a <code>undefined</code> dentro de su alcance, incluso si se accede a ellas antes de declararlas.  El problema principal aqu√≠ es que el valor <code>undefined</code> en una variable no siempre indica que est√°n tratando de usar la variable antes de su declaraci√≥n.  Eche un vistazo al siguiente ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  En este caso, aunque <code>var1</code> y <code>var2</code> declaran de manera diferente, ambas llamadas a <code>console.log</code> saldr√°n <code>undefined</code> .  El punto aqu√≠ es que en las variables declaradas con <code>var</code> , pero no inicializadas, el valor <code>undefined</code> escribe autom√°ticamente.  Al mismo tiempo, como ya dijimos, las variables declaradas usando <code>var</code> , a las que se accede antes de declararse, tambi√©n contienen <code>undefined</code> .  Como resultado, si algo sale mal en dicho c√≥digo, no ser√° posible entender cu√°l es exactamente la fuente del error: usar una variable no inicializada o usar una variable antes de su declaraci√≥n. <br><br>  El lugar para las variables declaradas con la palabra clave <code>let</code> est√° reservado en su bloque, pero, antes de ser declaradas, caen en la zona muerta temporal (TDZ, Zona muerta temporal).  Esto lleva al hecho de que no se pueden usar antes de que se declaren, y un intento de acceder a dicha variable conduce a un error.  Sin embargo, el sistema conoce exactamente la causa del problema y lo informa.  Esto se ve claramente en este ejemplo: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var1); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var2); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Aqu√≠, la primera llamada a <code>console.log</code> saldr√° <code>undefined</code> , y la segunda arrojar√° un error <code>ReferenceError</code> , dici√©ndonos que la variable a√∫n no ha sido declarada o inicializada. <br><br>  Como resultado, si el uso de <code>var</code> aparece <code>undefined</code> , no sabemos la raz√≥n de este comportamiento del programa.  Una variable puede declararse y no inicializarse, o puede que a√∫n no se declare en este √°mbito, pero se declarar√° en el c√≥digo ubicado debajo del comando para acceder a ella.  Usando la palabra clave <code>let</code> , podemos entender qu√© est√° sucediendo exactamente, lo cual es mucho m√°s √∫til para la depuraci√≥n. <br><br><h3>  <font color="#3AC1EF">‚ñçUso de la palabra clave const</font> </h3><br>  La palabra clave <code>const</code> es muy similar a <code>let</code> , pero tienen una diferencia importante.  Esta palabra clave se usa para declarar constantes.  Los valores de las constantes no se pueden cambiar despu√©s de su inicializaci√≥n.  Cabe se√±alar que esto se aplica solo a valores de tipos primitivos, agua, cadenas o n√∫meros.  Si la constante es algo m√°s complejo, por ejemplo, un objeto o una matriz, la estructura interna de dicha entidad puede modificarse, no puede simplemente reemplazarla por otra.  Echa un vistazo al siguiente c√≥digo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> mutableVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> immutableVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">mutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">immutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  Este c√≥digo se ejecutar√° hasta la √∫ltima l√≠nea.  Intentar asignar un nuevo valor a una constante dar√° como resultado un error <code>TypeError</code> .  As√≠ es como se comportan las constantes, pero, como ya se mencion√≥, los objetos que las constantes se inicializan pueden cambiar, pueden sufrir mutaciones, lo que puede llevar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sorpresas</a> . <br><br>  Quiz√°s usted, como desarrollador de JavaScript, se pregunte por qu√© es importante la inmunidad de las variables.  Las constantes son un fen√≥meno nuevo en JavaScript, mientras que son una parte esencial de lenguajes como C o Java.  ¬øPor qu√© es tan popular este concepto?  El hecho es que el uso de constantes nos hace pensar en c√≥mo funciona nuestro c√≥digo.  En algunas situaciones, cambiar el valor de una variable puede alterar el c√≥digo, por ejemplo, si se escribe el n√∫mero Pi y se accede a √©l constantemente, o si la variable tiene un enlace a un elemento HTML con el que necesita trabajar constantemente.  Digamos, aqu√≠ hay una constante en la que se escribe un enlace a un bot√≥n determinado: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#my-button'</span></span>);</code> </pre> <br>  Si el c√≥digo depende del enlace al elemento HTML, entonces debemos asegurarnos de la inmutabilidad de este enlace.  Como resultado, podemos decir que la palabra clave <code>const</code> no solo va por el camino de las mejoras en el campo de visibilidad, sino tambi√©n por el camino de limitar la posibilidad de modificar los valores de las constantes declaradas usando esta palabra clave.  Recuerde c√≥mo dijimos que una variable deber√≠a tener exactamente el alcance que necesita.  Esta idea puede continuar presentando una recomendaci√≥n, seg√∫n la cual una variable solo debe tener la capacidad de cambiar, lo cual es necesario para un trabajo adecuado con ella, y nada m√°s.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ hay un</a> buen material sobre el tema de la inmunidad, del cual se puede sacar una conclusi√≥n importante, seg√∫n la cual el uso de variables inmutables nos hace pensar m√°s cuidadosamente sobre nuestro c√≥digo, lo que conduce a una mejora en la pureza del c√≥digo y a una reducci√≥n en el n√∫mero de sorpresas desagradables que surgen de su funcionamiento. <br><br>  Cuando comenc√© a usar las palabras clave <code>let</code> y <code>const</code> , b√°sicamente us√© <code>let</code> , recurriendo a <code>const</code> solo cuando escribir un nuevo valor en una variable declarada con <code>let</code> podr√≠a da√±ar el programa.  Pero, aprendiendo m√°s sobre programaci√≥n, cambi√© de opini√≥n al respecto.  Ahora mi herramienta principal es <code>const</code> , y me <code>let</code> usarla solo cuando el valor de la variable necesita ser reescrito.  Esto me hace pensar si es realmente necesario cambiar el valor de una determinada variable.  En la mayor√≠a de los casos, esto no es necesario. <br><br><h2>  <font color="#3AC1EF">¬øNecesitamos la palabra clave var?</font> </h2><br>  Las palabras clave <code>let</code> y <code>const</code> contribuyen a un enfoque de programaci√≥n m√°s responsable.  ¬øHay situaciones en las que todav√≠a se necesita la palabra clave <code>var</code> ?  Si los hay.  Hay varias situaciones en las que esta palabra clave sigue siendo √∫til para nosotros.  Considere cuidadosamente de qu√© hablaremos antes de cambiar <code>var</code> para <code>let</code> o <code>const</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Nivel de soporte de palabras clave Var por navegadores</font> </h3><br>  Las variables declaradas con la palabra clave <code>var</code> tienen una caracter√≠stica muy importante que <code>let</code> y <code>const</code> falta.  Es decir, estamos hablando del hecho de que absolutamente todos los navegadores admiten esta palabra clave.  Aunque el soporte para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">let</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">const por parte de los</a> navegadores es muy bueno, existe el riesgo de que su programa termine en un navegador que no los admite.  Para comprender las consecuencias de tal incidente, debe considerar c√≥mo los navegadores manejan el c√≥digo JavaScript no compatible, en lugar de, por ejemplo, c√≥mo reaccionan al c√≥digo CSS que no entienden. <br><br>  Si el navegador no admite alguna funci√≥n de CSS, esto b√°sicamente conduce a cierta distorsi√≥n de lo que se mostrar√° en la pantalla.  Un sitio en un navegador que no admite ninguno de los estilos utilizados por el sitio no se ver√° como se esperaba, pero es muy probable que se pueda usar.  Si usa, por ejemplo, <code>let</code> , y el navegador no admite esta palabra clave, entonces su c√≥digo JS simplemente no funcionar√° all√≠.  No ser√°, eso es todo.  Dado que JavaScript es uno de los componentes importantes de la web moderna, esto puede convertirse en un problema grave si necesita que sus programas funcionen en navegadores obsoletos. <br><br>  Cuando las personas hablan sobre la compatibilidad del navegador para los sitios, generalmente preguntan en qu√© navegador funcionar√° el sitio de manera √≥ptima.  Si estamos hablando de un sitio cuya funcionalidad se basa en el uso de <code>let</code> y <code>const</code> , entonces una pregunta similar tendr√° que plantearse de manera diferente: "¬øEn qu√© navegadores no funcionar√° nuestro sitio?".  Y esto es mucho m√°s serio que hablar sobre si usar <code>display: flex</code> o no.  Para la mayor√≠a de los sitios web, la cantidad de usuarios con navegadores obsoletos no ser√° lo suficientemente grande como para preocuparse.  Sin embargo, si estamos hablando de algo como una tienda en l√≠nea o sitios cuyos propietarios compran publicidad, esto puede ser una consideraci√≥n muy importante.  Antes de utilizar nuevas oportunidades en tales proyectos, eval√∫e el nivel de riesgo. <br><br>  Si necesita admitir navegadores realmente antiguos, pero desea utilizar <code>let</code> , <code>const</code> y otras caracter√≠sticas nuevas de ES6, una de las soluciones a este problema es utilizar un transportador de JavaScript como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Babel</a> .  Los transpiladores proporcionan la traducci√≥n del nuevo c√≥digo a lo que los navegadores antiguos entender√°n.  Con Babel, puede escribir c√≥digo moderno que use las √∫ltimas caracter√≠sticas del lenguaje y luego convertirlo en c√≥digo que puedan ejecutar los navegadores m√°s antiguos. <br><br>   ,   ?   ,        . ,      ,     ,     ,   .  ,   .  ,      ,      .     ES6-,     Babel,   Babel   ,      ,   .      ,      ,      .     .     ?   -  IE8     ? ,           ,  ,   ,  ,     . <br><br><h3> <font color="#3AC1EF">‚ñç var     </font> </h3><br>    ,     <code>var</code>  ,    .    .   : <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     myVar    ! }</span></span></code> </pre> <br> ,     <code>myVar</code>    ,      ,        .  ,         .     ,    , ,    ,      .     ,        .        <code>var</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(window.myVar); // 1 }</span></span></code> </pre> <br>          <code>var</code> ,       <code>window</code> .   <code>let</code>  <code>const</code>   .       ,     JS-   ,          (,  ,     )  ,     . <br><br>  ,         .       ,           .    ,  ,   ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myGlobalVars = {}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; myGlobalVars.myVar = myVar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(myGlobalVars.myVar); // 1 }</span></span></code> </pre> <br> ,     ,     ,      , .   ,  ,      <code>var</code>  , ,     ,   ,  ,   . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br> ,  ?   ?      : <br><br><ul><li>    IE10  -  ?              ‚Äî       <code>var</code> . </li><li>         JavaScript,    ,  ,      <code>var</code> ,  <code>const</code> .  -      (,      ,        ) ‚Äî  <code>let</code> . </li></ul><br>    <code>let</code>  <code>const</code> ,   ECMAScript 6,           ( )   -  -.       ,    ,       ,    . ,    - ,    ¬´¬ª  ¬´¬ª     , ,  <code>let</code>  <code>const</code> ,          . <br><br> <b> !</b>     ,       <code>const</code>       <code>var</code> ,   <code>let</code>    ,   ,   ,  ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420359/">https://habr.com/ru/post/es420359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420349/index.html">Lista de verificaci√≥n de outsourcing de TI: trabajar sin riesgos</a></li>
<li><a href="../es420351/index.html">C√≥mo hacer b√∫squedas de usuarios en GitHub usando Vue</a></li>
<li><a href="../es420353/index.html">Hacemos que Shrimp sea a√∫n m√°s √∫til: agregue la transcodificaci√≥n de im√°genes a otros formatos</a></li>
<li><a href="../es420355/index.html">Reloj inteligente Pebble: c√≥mo convertirse en una rareza de la noche a la ma√±ana</a></li>
<li><a href="../es420357/index.html">Vuex: estructurando grandes proyectos y trabajando con m√≥dulos</a></li>
<li><a href="../es420361/index.html">Error al ejecutar TextBox.GetLineText en .NET WPF</a></li>
<li><a href="../es420363/index.html">Seminarios web de HPE en agosto-octubre: nuevos temas (+ SHD, pr√°ctica de IA, almacenamiento de petabytes llave en mano)</a></li>
<li><a href="../es420367/index.html">Apocalipsis con aire acondicionado: escenario de apag√≥n de red inteligente</a></li>
<li><a href="../es420369/index.html">Extreme Extended Edge, o IEEE 802.1BR Switching</a></li>
<li><a href="../es420371/index.html">Sobre el tema de la construcci√≥n de bicicletas en el campo del almacenamiento de correo el√©ctrico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>