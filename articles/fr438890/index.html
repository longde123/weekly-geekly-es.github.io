<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèæ üèÜ üõ´ Postgres r√©trospectivement üîà üóúÔ∏è üî¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous attirons votre attention sur une traduction de l' article de Joseph Hellerstein ¬´Looking Back at Postgres¬ª , publi√© sous la version 4.0 de l' aff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres r√©trospectivement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/438890/">  <em>Nous attirons votre attention sur une traduction de <strong>l'</strong> article de <strong>Joseph Hellerstein ¬´Looking Back at Postgres¬ª</strong> , publi√© sous la version 4.0 de l' <strong>affirmation des droits d'auteur</strong> Creative Commons (CC-BY 4.0).</em>  <em>Les auteurs se r√©servent le droit de diffuser ce travail sur des sites Web personnels et d'entreprise avec un lien appropri√© vers la source.</em> <br><br>  <em>Traduction r√©alis√©e par Elena Indrupskaya.</em>  <em>J'ajouterai de moi-m√™me qu '"un programmeur qui voulait d√©sesp√©r√©ment construire un syst√®me avec plusieurs versions" semble √™tre Vadim Mikheev, mais nous connaissons tous les "volontaires de Russie" qui ont r√©√©crit GiST.</em> <br><br><h1>  Annotation </h1><br>  Il s'agit d'un souvenir du projet Postgres, dirig√© √† l'Universit√© de Californie √† Berkeley et dirig√© par Mike Stonebraker du milieu des ann√©es 1980 au milieu des ann√©es 1990.  Comme l'un des nombreux souvenirs personnels et historiques, cet article a √©t√© demand√© pour le livre [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bro19</a> ] on Stonebreaker's Turing Award.  Par cons√©quent, l'article se concentre sur le r√¥le principal de Stonebreaker et ses r√©flexions sur le design.  Mais Stonebreaker n'a jamais √©t√© programmeur et n'a pas interf√©r√© avec son √©quipe de d√©veloppement.  La base de code Postgres √©tait le travail d'une √©quipe d'√©tudiants brillants et parfois de programmeurs universitaires √† temps plein qui avaient un peu plus d'exp√©rience (et seulement un salaire l√©g√®rement plus √©lev√©) que les √©tudiants.  J'ai eu la chance de rejoindre cette √©quipe en tant qu'√©tudiant au cours des derni√®res ann√©es du projet.  J'ai re√ßu du mat√©riel utile pour cet article de certains des √©tudiants plus √¢g√©s impliqu√©s dans le projet, mais toutes les erreurs ou omissions sont les miennes.  Si vous en remarquez, contactez-moi et je vais essayer de les r√©parer. <br><a name="habracut"></a><br><h1>  1. Introduction </h1><br>  Postgres √©tait le projet le plus ambitieux de Michael Stonebreaker - sa tentative s√©rieuse de cr√©er un syst√®me de base de donn√©es universel.  Pendant une d√©cennie, le projet a g√©n√©r√© plus d'articles, de doctorats, de professeurs et d'entreprises que toute autre activit√© Stonebreaker.  Le projet couvrait √©galement plus du domaine technique que tout autre syst√®me qu'il avait construit.  Malgr√© le risque inh√©rent de cette ampleur, Postgres est √©galement devenu l'artefact logiciel le plus r√©ussi issu des √©quipes de recherche de Stonebreaker, et sa principale contribution √† l'open source.  Ceci est un exemple d'un ¬´deuxi√®me syst√®me¬ª [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bro75</a> ] qui a r√©ussi.  Au moment de la r√©daction, plus de trente ans depuis le d√©but du projet, le syst√®me open source PostgreSQL est le syst√®me de base de donn√©es open source ind√©pendant le plus populaire au monde et le quatri√®me syst√®me de base de donn√©es le plus populaire.  Parall√®lement, les entreprises cr√©√©es √† partir de Postgres ont g√©n√©r√© un total de plus de 2,6 milliards de dollars (en co√ªt d'acquisition).  √Ä tous √©gards, la vision du Postgres Stonebreaker avait une √©norme r√©sonance durable. <br><br><h2>  1.1.  Contexte </h2><br>  Stonebreaker a connu un √©norme succ√®s au d√©but de sa carri√®re avec le projet de recherche Ingres Berkeley [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SHWK76</a> ] et la startup suivante, qu'il a fond√©e avec Larry Rowe et Eugene Wong: Relational Technology, Inc.  (RTI). <br><br>  Au fur et √† mesure que RTI se d√©veloppait au d√©but des ann√©es 1980, Stonebreaker a commenc√© √† travailler sur la prise en charge des types de donn√©es dans les SGBD qui allaient au-del√† des lignes et colonnes traditionnelles du mod√®le relationnel Codd d'origine (Edgar Frank Codd).  Un exemple motivant √† l'√©poque √©tait le besoin de bases de donn√©es pour prendre en charge les outils de conception assist√©e par ordinateur (CAO) pour l'industrie micro√©lectronique.  Dans un article de 1983 de Stonebreaker et d'√©tudiants, Brad Rubenstein et Antonin Guttman ont expliqu√© √† quel point cette industrie avait besoin de prendre en charge ¬´de nouveaux types de donn√©es tels que les polygones, les rectangles, les cha√Ænes de texte, etc.¬ª, ¬´ recherche spatiale efficace ¬ª,¬´ contraintes d'int√©grit√© complexes ¬ª, ainsi que¬´ hi√©rarchies de conception et repr√©sentations multiples ¬ªdans les m√™mes structures physiques [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SRG83</a> ].  Avec cette motivation, le groupe a commenc√© √† travailler sur l'indexation (y compris l'utilisation des arbres R de Guttman pour l'indexation spatiale [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gut84</a> ]) et sur l'ajout de types de donn√©es abstraits (ADT) au syst√®me de base de donn√©es relationnelle.  √Ä cette √©poque, les ADT √©taient une nouvelle conception populaire des langages de programmation, qui a d'abord √©t√© introduite par Barbara Liskov, plus tard laur√©ate du prix Turing, et explor√©e dans la programmation d'applications de base de donn√©es par Lonely Rowe, un nouveau collaborateur de Stonebreaker.  Un article dans un enregistrement SIGMOD de 1983 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OFS83</a> ] Stonebreaker et les √©tudiants James Ong et Dennis Fogg d√©crivent une √©tude de ce concept dans l'extension Ingres appel√©e ADT-Ingres, qui incorpore de nombreux concepts de pr√©sentation √©tudi√©s plus profond√©ment et avec un meilleur support du syst√®me dans Postgres. <br><br><h1>  2. Postgres: informations g√©n√©rales </h1><br>  Comme son nom l'indique, Postgres est Post-Ingres: un syst√®me con√ßu pour prendre ce qu'Ingres pourrait faire et aller au-del√†.  Une caract√©ristique distinctive de Postgres √©tait l'introduction de ce qu'elle a finalement appel√© les propri√©t√©s objet-relationnelles de la base de donn√©es: la prise en charge du concept de programmation orient√©e objet dans le mod√®le de donn√©es et le langage de requ√™te d√©clarative du syst√®me de base de donn√©es.  Mais Stonebreaker a √©galement pr√©vu de r√©soudre un certain nombre d'autres probl√®mes technologiques ind√©pendants du support orient√© objet dans Postgres, tels que les r√®gles de base de donn√©es actives, les donn√©es versionn√©es, le stockage tertiaire et la concurrence. <br><br>  Deux articles ont √©t√© √©crits sur la conception Postgres: une description de la conception ancienne en 1986 SIGMOD [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SR86</a> ] et une description interm√©diaire dans CACM 1991 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SK91</a> ].  Le projet de recherche Postgres a progressivement √©chou√© en 1992 avec la fondation d'Illustra, une startup qui a impliqu√© Stonebreaker, l'√©tudiant dipl√¥m√© principal Wei Hong et plus tard devenu programmeur en chef Jeff Meredith.  Dans la liste ci-dessous, les opportunit√©s mentionn√©es dans l'article de 1986 sont marqu√©es d'un ast√©risque * et les opportunit√©s de l'article de 1991, qui ne figuraient pas dans l'article de 1986, sont marqu√©es d'un poignard <sup>‚Ä†</sup> .  Les autres t√¢ches √©num√©r√©es ci-dessous ont √©t√© prises dans la documentation sur le syst√®me et la recherche, mais elles ne figurent dans aucune sp√©cification de conception.  Beaucoup de ces sujets ont √©t√© abord√©s chez Postgres bien avant d'√™tre √©tudi√©s ou r√©invent√©s par d'autres.  Dans de nombreux cas, Postgres √©tait trop en avance sur son temps, et l'int√©r√™t pour les sujets a explos√© plus tard, dans une perspective moderne. <br><br><ol><li>  Prise en charge d'ADT dans le syst√®me de base de donn√©es <br><ul><li>  Objets complexes (c.-√†-d. Donn√©es imbriqu√©es ou donn√©es de forme non premi√®re normale (forme non premi√®re normale - NF2)) * </li><li>  Types et fonctions de donn√©es abstraites personnalis√©es * </li><li>  M√©thodes d'acc√®s extensibles pour les nouveaux types de donn√©es * </li><li>  Traitement optimis√© des requ√™tes avec des fonctionnalit√©s co√ªteuses d√©finies par l'utilisateur </li></ul></li><li>  Bases de donn√©es et syst√®mes de r√®gles actifs (d√©clencheurs, avertissements) * <br><ul><li>  R√®gles impl√©ment√©es lors de la r√©√©criture des demandes <sup>‚Ä†</sup> </li><li>  R√®gles impl√©ment√©es comme d√©clencheurs de niveau d'enregistrement <sup>‚Ä†</sup> </li></ul></li><li>  Stockage et r√©cup√©ration bas√©s sur les journaux <br><ul><li>  Code de r√©cup√©ration √† complexit√© r√©duite qui traite le journal comme des donn√©es *, en utilisant de la m√©moire non volatile pour l'√©tat de validation <sup>‚Ä†</sup> </li><li>  Stockage non r√©√©crit et requ√™tes temporelles <sup>‚Ä†</sup> </li></ul></li><li>  Prise en charge des nouvelles technologies de stockage en profondeur, en particulier les disques optiques * </li><li>  Prise en charge des multiprocesseurs et des processeurs sp√©cialis√©s * </li><li>  Prise en charge de divers mod√®les de langue <br><ul><li>  Modifications minimales du mod√®le relationnel et prise en charge des requ√™tes d√©claratives * </li><li>  Acc√®s √† la ¬´voie rapide¬ª √† partir des API internes en contournant le langage de requ√™te <sup>‚Ä†</sup> </li><li>  Multilinguisme <sup>‚Ä†</sup> </li></ul></li></ol><br>  Nous discuterons bri√®vement de la contribution de Postgres pour chacun de ces √©l√©ments par rapport aux travaux ult√©rieurs dans le domaine de l'informatique. <br><br><h2>  2.1.  Prise en charge d'ADT dans le syst√®me de base de donn√©es </h2><br>  L'objectif clair de Postgres √©tait de prendre en charge de nouvelles propri√©t√©s relationnelles-objet: √©tendre la technologie de base de donn√©es pour fournir les avantages du traitement des requ√™tes relationnelles et de la programmation orient√©e objet.  Au fil du temps, le concept relationnel-objet qui est apparu pour la premi√®re fois dans Postgres est devenu une fonctionnalit√© standard dans la plupart des syst√®mes de bases de donn√©es modernes. <br><br><h3>  2.1.1.  Objets complexes </h3><br>  Tr√®s souvent, les donn√©es sont repr√©sent√©es comme des entit√©s imbriqu√©es ou des ¬´objets¬ª.  Un exemple classique est un bon de commande, qui comprend un ensemble int√©gr√© de produits, leurs quantit√©s et leurs prix.  La religion de la mod√©lisation relationnelle a dict√© que ces donn√©es doivent √™tre restructur√©es et enregistr√©es dans un format sans imbrication, en utilisant plusieurs tables plates d'objets (commandes, produits) avec des tables plates de relations (product_in_order).  Une raison typique de cet aplatissement est qu'il r√©duit la duplication des donn√©es (car le produit est d√©crit de mani√®re redondante dans de nombreux bons de commande), ce qui √©vite √† son tour la complexit√© ou les erreurs lors de la mise √† jour de toutes les copies redondantes.  Mais dans certains cas, vous souhaitez conserver la sous-vue, car elle est naturelle pour l'application (par exemple, le m√©canisme de disposition du circuit en CAO), et les mises √† jour sont rares.  Ce d√©bat sur la mod√©lisation des donn√©es est au moins aussi ancien que le mod√®le relationnel. <br><br>  L'approche cl√© de Postgres √©tait de ¬´s'asseoir sur deux chaises¬ª en termes de mod√©lisation des donn√©es: Postgres a enregistr√© les tables en tant que type de donn√©es ¬´le plus externe¬ª, mais a permis aux colonnes d'avoir des types ¬´complexes¬ª, y compris des tuples ou des tables imbriqu√©s.  L'une de ses impl√©mentations les moins courantes, explor√©e pour la premi√®re fois dans le prototype ADT-Ingres, √©tait de permettre la d√©claration d√©clarative d'une colonne de type de table comme d√©finition de requ√™te: ¬´Quel comme type de donn√©es¬ª [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SAHR84</a> ] <em>(Quel - Ingres Query Language - Approx. .)</em> . <br><br>  Le th√®me ¬´post-relationnel¬ª de la prise en charge √† la fois des requ√™tes d√©claratives et des donn√©es int√©gr√©es est r√©apparu au fil des ans, souvent g√©n√©r√© par des diff√©rends sur ce qui est le mieux.  √Ä l'√©poque de Postgres dans les ann√©es 1980 et 1990, certains groupes impliqu√©s dans les bases de donn√©es orient√©es objet ont repris cette id√©e et l'ont d√©velopp√©e dans le langage OQL standard, qui a ensuite cess√© d'√™tre utilis√©. <br><br>  Au tournant du mill√©naire, les requ√™tes d√©claratives sur les objets imbriqu√©s sont devenues une obsession de la recherche pour le segment de la communaut√© des d√©veloppeurs de bases de donn√©es sous forme de bases de donn√©es XML.  Le langage XQuery r√©sultant (dirig√© par Don Chamberlin, le personnage de SQL) est n√©cessaire pour prendre en charge des objets complexes dans le langage Postgel de Postgres.  XQuery est largement utilis√© et largement utilis√© dans l'industrie, mais n'a jamais √©t√© populaire aupr√®s des utilisateurs.  Aujourd'hui, ces concepts sont r√©examin√©s dans des projets de langage de requ√™te pour le mod√®le de donn√©es JSON, populaire dans les applications bas√©es sur un navigateur.  Comme OQL, dans les groupes qui ont initialement rejet√© les requ√™tes d√©claratives en faveur de la programmation orient√©e d√©veloppeur (le mouvement ¬´NoSQL¬ª), ces langages n'apparaissent souvent comme un ajout tardif que du d√©sir de rajouter des requ√™tes au syst√®me.  Dans le m√™me temps, au fur et √† mesure que Postgres a grandi au fil des ans (et est pass√© du langage de requ√™te Postquel √† des versions SQL qui r√©pondent √† de nombreux objectifs pris en compte), il a inclus la prise en charge des donn√©es int√©gr√©es, telles que XML et JSON, dans les SGBD √† usage g√©n√©ral, sans n√©cessiter aucune ou refonte importante.  La controverse se d√©roule avec plus ou moins de succ√®s, et l'approche de Postgres pour √©tendre la structure relationnelle en utilisant des extensions pour les donn√©es imbriqu√©es s'est r√©v√©l√©e √† plusieurs reprises √™tre un √©tat final naturel pour toutes les parties apr√®s la fin des arguments. <br><br><h3>  2.1.2.  Types et fonctions de donn√©es abstraites personnalis√©es </h3><br>  En plus de sugg√©rer des types imbriqu√©s, Postgres a avanc√© l'id√©e d'introduire des ADT opaques et extensibles qui sont stock√©s dans la base de donn√©es mais non interpr√©t√©s par le noyau.  Fondamentalement, cela a toujours fait partie du mod√®le relationnel de Codd: les entiers et les cha√Ænes √©taient traditionnels, mais en fait le mod√®le relationnel englobe tout type de donn√©es atomiques avec des pr√©dicats.  La t√¢che consistait √† fournir une telle flexibilit√© math√©matique dans les logiciels.  Pour utiliser des requ√™tes qui interpr√®tent ces objets et les manipulent, un programmeur d'application doit √™tre en mesure d'enregistrer des fonctions d√©finies par l'utilisateur (UDF) pour ces types dans le syst√®me et d'appeler ces fonctions dans des requ√™tes.  Il est √©galement souhaitable que les fonctions d'agr√©gation d√©finies par l'utilisateur (UDA) r√©sument les collections de ces objets dans les requ√™tes.  Le syst√®me de base de donn√©es Postgres a √©t√© innovant et prend en charge ces fonctionnalit√©s de mani√®re compl√®te. <br><br>  Pourquoi mettre une telle fonctionnalit√© dans un SGBD, plut√¥t que dans des applications de haut niveau?  La r√©ponse typique √† cette question √©tait un avantage significatif dans la performance du code plac√© sur les donn√©es par rapport √† la ¬´traction¬ª des donn√©es vers le code.  Postgres a montr√© que cela est tout √† fait naturel dans le cadre d'un environnement relationnel: seules des modifications mineures ont √©t√© n√©cessaires dans le catalogue de m√©tadonn√©es relationnelles et des m√©canismes d'appel de code tiers ont √©t√© cr√©√©s, mais la syntaxe de requ√™te, la s√©mantique et l'architecture du syst√®me ont fonctionn√© de mani√®re simple et √©l√©gante. <br><br>  Postgres est un peu en avance sur son temps pour explorer cette fonctionnalit√©.  En particulier, √† cette √©poque, la communaut√© des chercheurs en bases de donn√©es n'√©tait pas particuli√®rement inqui√®te des implications s√©curitaires du t√©l√©chargement de code non s√©curis√© sur le serveur.  Cela a commenc√© √† √™tre per√ßu comme un probl√®me lorsque la technologie a √©t√© remarqu√©e dans l'industrie.  Stonebreaker a mis Postgres sur le march√© dans sa startup Illustra, qu'Informix a acquise dans une large mesure pour sa capacit√© √† prendre en charge les packages d'extension DataBlade, y compris UDF.  Informix, avec sa technologie bas√©e sur Postgres et ses solides offres de bases de donn√©es parall√®les, est devenu une menace importante pour Oracle.  Oracle a investi massivement dans la commercialisation n√©gative des risques associ√©s √† la capacit√© d'Informix √† ex√©cuter du code C utilisateur ¬´non s√©curis√©¬ª.  Certains attribuent la mort d'Informix √† cette campagne, bien que la fraude financi√®re d'Informix (et les poursuites f√©d√©rales ult√©rieures contre son PDG d'alors) aient certainement pos√© des probl√®mes plus graves.  Maintenant, des d√©cennies plus tard, tous les principaux fournisseurs de bases de donn√©es prennent en charge des fonctions personnalis√©es dans une ou plusieurs langues, en utilisant de nouvelles technologies pour se prot√©ger contre les pannes de serveur ou la corruption de donn√©es. <br><br>  Pendant ce temps, les piles technologiques des m√©gadonn√©es des ann√©es 2000, y compris le ph√©nom√®ne MapReduce, qui a ¬´g√¢t√© beaucoup de sang¬ª par Stonebreaker et David DeWitt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DS08</a> ], sont une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©impl√©mentation</a> de l'id√©e de Postgres - code utilisateur publi√© dans le cadre de la demande.  Il semble que MapReduce combine en grande partie les id√©es de d√©veloppement de logiciels Postgres avec des id√©es de concurrence de syst√®mes tels que Gamma et Teradata, avec quelques innovations mineures autour du red√©marrage du processus de requ√™te pour les charges de travail avec une √©volutivit√© extr√™me.  Les startups bas√©es sur Postgres, Greenplum et Aster, vers 2007, ont montr√© que la parall√©lisation de Postgres pouvait conduire √† quelque chose de beaucoup plus fonctionnel et pratique que MapReduce pour la plupart des clients, mais en 2008, le march√© n'√©tait toujours pas pr√™t pour cette technologie. .  √Ä l'heure actuelle, en 2018, presque chaque pile de Big Data g√®re essentiellement la charge de travail SQL parall√®le avec UDF, ce qui est tr√®s similaire √† la conception que Stonebreaker et l'√©quipe ont utilis√©e pour la premi√®re fois dans Postgres. <br><br><h3>  2.1.3.  M√©thodes d'acc√®s extensibles pour les nouveaux types de donn√©es </h3><br>  Les bases de donn√©es relationnelles se sont d√©velopp√©es √† peu pr√®s au m√™me moment que les arbres B au d√©but des ann√©es 1970, et les arbres B ont contribu√© √† donner √† Codd un r√™ve ¬´d'ind√©pendance par rapport au stockage de donn√©es physiques¬ª: l'indexation avec les arbres B fournit un niveau d'indirection qui R√©organise le stockage physique de mani√®re adaptative sans n√©cessiter de modifications d'application.  La principale limitation des arbres B et de leurs structures associ√©es est qu'ils ne prennent en charge la recherche et les requ√™tes d'√©galit√© que dans la plage unidimensionnelle.  Mais que faire si vous avez des requ√™tes de plage bidimensionnelles typiques des applications de cartographie et de CAO?  Ce probl√®me √©tait connu lors de Postgres, et l'arbre R [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gut84</a> ], d√©velopp√© par Antonin Guttman dans le groupe Stonebreaker, √©tait l'un des nouveaux index les plus r√©ussis con√ßus pour r√©soudre ce probl√®me dans la pratique.  Cependant, l'invention de la structure d'index ne r√©sout pas le probl√®me de la prise en charge de plages multidimensionnelles dans un SGBD pour des syst√®mes complexes.  Il y a beaucoup de questions.  Pouvez-vous facilement ajouter une m√©thode d'acc√®s, telle que des arborescences R, √† votre SGBD?  Pouvez-vous apprendre √† l'optimiseur √† comprendre que la m√©thode d'acc√®s sp√©cifi√©e sera utile pour certaines requ√™tes?  Pouvez-vous obtenir une r√©cup√©ration correcte et un acc√®s simultan√©?  C'√©tait un point tr√®s audacieux dans le plan d'action de Postgres: un probl√®me d'architecture logicielle affectant la plupart du moteur de base de donn√©es, de l'optimiseur au niveau de stockage, ainsi que le syst√®me de journalisation et de r√©cup√©ration.  Les arbres R de Postgres sont devenus une force motrice puissante et un excellent exemple de l'extensibilit√© √©l√©gante de la couche de m√©thode d'acc√®s et de son int√©gration dans l'optimiseur de requ√™tes.  Postgres a montr√©, √† l'aide d'un ADT opaque, comment enregistrer une m√©thode d'acc√®s d√©crite de mani√®re abstraite (dans ce cas, un arbre R), et comment un optimiseur de requ√™te peut reconna√Ætre un pr√©dicat de s√©lection abstrait (dans ce cas, un choix de plage) et le faire correspondre avec cette m√©thode d'acc√®s d√©crite de mani√®re abstraite.  Une attention moindre a √©t√© accord√©e au contr√¥le d'acc√®s simultan√© dans les travaux initiaux: le manque de classement unidimensionnel des cl√©s a rendu la serrure utilis√©e dans les arbres B dans ce cas inapplicable. <br><br>  <em>Les caract√©ristiques prometteuses des m√©thodes d'acc√®s extensibles de Postgres ont inspir√© l'un de mes premiers projets de recherche √† la fin des √©tudes sup√©rieures: Generalized Search Trees - GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HNP95</a> ] et le concept ult√©rieur de th√©orie de l'indexation [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HKM <sup>+</sup> 02</a> ].</em>  <em>J'ai impl√©ment√© GiST dans Postgres pendant un semestre apr√®s avoir termin√© mon doctorat, ce qui a rendu l'ajout de la nouvelle logique d'indexation √† Postgres encore plus facile.</em>  <em>La th√®se de Marcel Kornacker de Berkeley (Marcel Kornacker) a r√©solu les probl√®mes complexes de r√©cup√©ration et d'acc√®s simultan√©, pos√©s par le type d'index extensible "mod√®le" GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KMH97</a> ].</em> <br><br>  Aujourd'hui, PostgreSQL combine avantageusement l'architecture logicielle originale des m√©thodes d'acc√®s extensibles (il a des index B-tree, GiST, SP-GiST et Gin) avec l'extensibilit√© et l'acc√®s concurrentiel intense de l'interface d'arbre de recherche g√©n√©ralis√©e (GiST).  Les index GiST prennent en charge le populaire syst√®me de g√©o-information PostGIS bas√© sur PostgreSQL.  Les index Gin fournissent une prise en charge de l'indexation de texte interne dans PostgreSQL. <br><br><h3>  2.1.4.  Optimiseur de requ√™te avec UDF co√ªteux </h3><br>  Dans l'optimisation de requ√™te traditionnelle, la t√¢che consistait √† minimiser la quantit√© de flux de tuple (et donc les op√©rations d'E / S) cr√©√©es lors du traitement de la demande.  Cela signifie que les instructions qui filtrent les tuples (extraction) sont bonnes au d√©but du plan de requ√™te, tandis que les instructions qui peuvent g√©n√©rer de nouveaux tuples (jointure) doivent √™tre ex√©cut√©es plus tard.  Par cons√©quent, les optimiseurs de requ√™tes ¬´poussent¬ª les op√©rateurs d'extraction sous les connexions et les organisent de mani√®re al√©atoire, en se concentrant plut√¥t sur une optimisation intelligente des connexions et des acc√®s au disque.  Les FDU ont chang√© l'approche: si vous avez des FDU co√ªteuses dans vos exemples d'instructions, l'ordre d'ex√©cution des FDU peut √™tre critique pour optimiser les performances.  De plus, si l'UDF dans l'op√©rateur de s√©lection prend vraiment beaucoup de temps, il est possible que la s√©lection soit effectu√©e apr√®s les connexions (c'est-√†-dire que la s√©lection doit √™tre ¬´pull up¬ª - s√©lection ¬´pullup¬ª).  La prise en compte de ces facteurs a compliqu√© l'espace de recherche de l'optimiseur.  J'ai pris ce probl√®me comme la premi√®re t√¢che difficile √† l'√©cole sup√©rieure, et il a fini par faire l'objet de mon travail de ma√Ætrise avec Stonebreaker √† Berkeley et de mon doctorat au Wisconsin sous la direction de Jeff Naughton, mais avec l'aide constante des conseils de Stonebreaker.  Postgres a √©t√© le premier SGBD √† stocker le co√ªt et la s√©lectivit√© des fonctions d√©finies par l'utilisateur dans un r√©pertoire de base de donn√©es.  Nous avons abord√© le probl√®me d'optimisation, ayant trouv√© l'ordre optimal des op√©rations d'√©chantillonnage, puis l'alternance optimale des op√©rations d'√©chantillonnage le long des branches de chaque arbre de connexion consid√©r√© dans la recherche de plan.         System R           . <br><br> <em>    ,      ,               . ,     ,     .</em> <br><br>          PostgreSQL       ,            . ,   ,     , ,  2018       . , ,         ,      ,   ,       .    ,  Postgres    . <br><br> <em>  , ,    ,        PostgreSQL       (Neil Conway),                      ¬´ ¬ª .</em> <br><br><h2>  2.2.       </h2><br>  Postgres                   .       :  ,      ¬´  ¬ª,     1990- . <br><br>              .  ‚Äî         Datalog.   ¬´  ¬ª  : , ,                . <br><br> <em>Datalog                ,  -   . Datalog ‚Äî     ¬´ ¬ª     .        ,     ,             .</em> <br><br>   ,     ,     ,             ,       .             . <br><br>             (Eric Hanson),     Ingres,       Postgres.         (Spyros Potamianos)  PRS2: Postgres Rules System 2.           .    ‚Äî     .      ,      Ingres.      ¬´   ¬ª   ¬´       ¬ª. ,   ¬´      ¬ª     ¬´    10%¬ª.     ,     ¬´   ¬ª,           .         (     ),    . <br><br> <em>      PRS2 ,   , .     Postgres       (,  )    Postgres  3.1  1991  (  ):</em> <br><br><pre> <em><font></font>
*        :<font></font>
*     .        <font></font>
*  (. .        <font></font>
* "" )    .   -  <font></font>
*   () .        .<font></font>
*   .    .     <font></font>
*   .  ...<font></font>
* ,  , ? ,    ,  .<font></font>
*         , <font></font>
*  ...</em> </pre><br>       Postgres    ,          ¬´¬ª ‚Äî      .            PostgreSQL,     -           . <br><br>   Postgres          ¬´  ¬ª     IBM Starburst  MCC HiPAC.      SQL        .      .      ,  ,   ,      ,    ¬´  ¬ª:        ,      .  ,   -       ,    ,    ,  ,   .       ,     ,      ,         ,     Postgres. <br><br><h2>  2.3. X      </h2><br>       Postgres  : <br><blockquote>    Postgres,      - .            (write-ahead log ‚Äî WAL),   ,     .  ,   Ingres 1970-     ,         . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SK91</a> ] <br></blockquote>   ,    ,       .               ,    IBM  Tandem    .           :      -  ,   ,      ,    . <br><br> X Postgres             .       ,           ,   , ‚Äî     ¬´  ¬ª  ¬´  ¬ª      .   ,  , ‚Äî         .     ,    ¬´¬ª       .      :                ,      .     Postgres,   ,           ,             ,      [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto87</a> ].    Postgres   . <br><br>    ¬´ ¬ª           ,      ,        .                    .  ,        ,      ,        ,      Postgres.     Postgres      .         PostgreSQL      . <br><br> <em> , PostgreSQL       :        .   ,  PostgreSQL    ,      Postgres,   ,       Postgres  .    ,      (snapshot isolation) Oracle       -,             .</em> <br><br> <em>  (Mike Olson) ,       ,    B- Postgres    B-   Berkeley DB,       Postgres.         .    Berkeley DB     Sleepycat Corp.,    ()  PostgreSQL       ¬´ ¬ª.  :    ,        (MVCC),       ,   .</em> <br><br> <em>   PostgreSQL     .  Greenplum  PostgreSQL        .      (Matt McCline)‚Äî    (Jim Gray)   Tandem.      .</em> <br><br>         .  ,                   NoSQL (  ,   WAL),        (MMDB ‚Äî main memory databases,        ).              ,            .  ,             . <br><br><h2>  2.4.           </h2><br>  Au milieu du projet Postgres, Stonebreaker s'est inscrit comme l'un des cadres pour une grande subvention num√©rique de science des terres appel√©e Project Sequoia.  Une partie de la proposition de subvention portait sur le traitement de quantit√©s sans pr√©c√©dent d'images num√©riques par satellite, n√©cessitant jusqu'√† 100 t√©raoctets de m√©moire, c'est-√†-dire une quantit√© de donn√©es beaucoup plus importante qu'il ne serait sage de stocker sur des disques magn√©tiques √† l'√©poque.  La base de la solution propos√©e √©tait d'√©tudier l'id√©e de cr√©er un SGBD (√† savoir Postgres), qui facilite l'acc√®s au stockage ¬´tertiaire¬ª semi-autonome fourni par les lecteurs robotiques avec remplacement automatique du disque pour g√©rer les disques optiques ou les biblioth√®ques de bandes. <br><br>  Cela a conduit √† plusieurs √©tudes diff√©rentes.  L'un d'eux √©tait le syst√®me de fichiers Inversion - une tentative de fournir une abstraction du syst√®me de fichiers UNIX sur un SGBD relationnel.  Dans un article de synth√®se pour Sequoia, Stonebreaker l'a d√©crit dans son style habituel de ¬´simple exercice¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">condescendant</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto95</a> ].  En fait, Mike Olson, √©tudiant √† Stonebreaker (et fondateur de Cloudera par la suite), s'occupe de cela depuis plusieurs ann√©es, et le r√©sultat final n'a pas √©t√© tr√®s simple [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ols93</a> ] et n'a pas surv√©cu dans la pratique. <br><br>  <em>Quelques ann√©es plus tard, Inversion Bill Gates ¬´a combattu les m√™mes moulins √† vent¬ª dans WinFS - une tentative de recr√©er le syst√®me de fichiers le plus utilis√© au monde sur l'arri√®re d'une base de donn√©es relationnelle.</em>  <em>WinFS a √©t√© livr√© dans les versions de d√©veloppement de Windows, mais n'est jamais entr√© sur le march√©.</em>  <em>Gates l'a appel√© plus tard sa plus grande d√©ception chez Microsoft.</em> <br><br>  Un autre domaine de recherche principal sur ce front a √©t√© l'inclusion d'un r√©f√©rentiel tertiaire sur la pile de bases de donn√©es relationnelles plus typiques, qui a fait l'objet d'une th√®se de doctorat de Sunita Sarawagi.  Le sujet principal √©tait de changer l'√©chelle dans laquelle vous envisagez de g√©rer l'espace (c'est-√†-dire les donn√©es stock√©es et la hi√©rarchie de la m√©moire) et le temps (coordonner la planification des requ√™tes et le cache pour minimiser les E / S ind√©sirables).  L'un des principaux probl√®mes de ce travail √©tait de stocker de grands tableaux multidimensionnels dans un stockage tertiaire et de les r√©cup√©rer, ce qui fait √©cho aux travaux dans le domaine de l'indexation multidimensionnelle.  Les id√©es cl√©s comprenaient la division du tableau en parties et le stockage ensemble des parties s√©lectionn√©es ensemble, ainsi que la r√©plication des parties afin que la partie de donn√©es puisse avoir plusieurs ¬´voisins¬ª physiques.  Le deuxi√®me probl√®me est de r√©fl√©chir √† la fa√ßon dont le disque devient un cache pour le stockage tertiaire.  Enfin, l'optimisation et la planification des requ√™tes doivent tenir compte du temps de chargement long des donn√©es du stockage tertiaire et de l'importance des hits (hits) du cache disque.  Cela affecte √† la fois le plan choisi par l'optimiseur de requ√™tes et le temps n√©cessaire pour terminer le plan. <br><br>  Les robots sur bandes et disques optiques ne sont actuellement pas largement utilis√©s.  Mais les probl√®mes de stockage tertiaire sont tr√®s courants dans le cloud, qui en 2018 a une hi√©rarchie de stockage profonde: des SSD attach√©s aux services de stockage fiables de type disque (par exemple, AWS EBS), au stockage d'archives (par exemple, dans AWS S3), au stockage profond (par exemple , AWS Glacier).  Aujourd'hui, ces niveaux de stockage sont encore relativement s√©par√©s, et le raisonnement sur le stockage de bout en bout englobant ces niveaux n'est pratiquement pas pris en charge par la base de donn√©es.  Je ne serais pas surpris que les questions examin√©es √† ce sujet dans Postgres soient r√©examin√©es prochainement. <br><br><h2>  2.5.  Prise en charge multiprocesseur: XPRS </h2><br>  Stonebreaker n'a jamais cr√©√© un grand syst√®me de base de donn√©es parall√®le, mais il a dirig√© de nombreuses discussions difficiles dans ce domaine.  Son article ¬´Case for Shared Nothing¬ª [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto86</a> ] a document√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> solutions architecturales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modulaires √†</a> grande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©chelle</a> dans ce domaine.  Il a popularis√© la terminologie utilis√©e dans l'industrie et a intrigu√© le support des architectures sans ressources partag√©es, telles que Gamma et Teradata, qui ont √©t√© red√©couvertes dans les ann√©es 2000 par la communaut√© du Big Data. <br><br>  Ironiquement, la contribution la plus importante de Stonebreaker dans le domaine des bases de donn√©es parall√®les √©tait l'architecture de ¬´m√©moire partag√©e¬ª appel√©e XPRS, qui signifiait ¬´PostgreSQL √©tendu sur RAID et Sprite¬ª.  Au d√©but des ann√©es 1990, XPRS √©tait la ¬´ligue de justice¬ª pour les syst√®mes Berkeley: il combine le syst√®me abr√©g√© Postgres Stonebreaker, John Ousterhout, le syst√®me d'exploitation Sprite distribu√©, et l'architecture RAID Dave Patterson et Randy Katz RAID )  Comme pour de nombreux emplois inter-facultaires, la mise en ≈ìuvre du projet XPRS a en fait √©t√© d√©termin√©e par les √©tudiants dipl√¥m√©s qui y ont travaill√©.  Il s'est av√©r√© que la principale contribution a √©t√© apport√©e par Wei Hong, qui a r√©dig√© sa th√®se de doctorat sur l'optimisation des requ√™tes parall√®les dans XPRS.  Ainsi, la principale contribution de XPRS √† la litt√©rature et √† l'industrie a √©t√© d'optimiser les requ√™tes simultan√©es sans aborder de mani√®re significative les probl√®mes associ√©s √† RAID ou Sprite. <br><br>  <em>De ces trois projets, Postgres et RAID ont eu un impact √©norme sur l'avenir.</em>  <em>Sprite est le meilleur souvenir de la th√®se de doctorat de Mendel Rosenblum sur les syst√®mes de fichiers structur√©s (LFS), qui n'avait rien √† voir avec les syst√®mes d'exploitation distribu√©s.</em>  <em>Les trois projets contenaient de nouvelles id√©es pour le stockage sur disque, en plus de modifier les copies individuelles en place.</em>  <em>LFS et le gestionnaire de r√©f√©rentiel Postgres sont assez similaires dans leur nouveau traitement de la revue comme r√©f√©rentiel principal et la n√©cessit√© d'une r√©organisation en arri√®re-plan co√ªteuse.</em>  <em>Une fois, j'ai soigneusement sond√© le Stonebreaker sur la rivalit√© entre LFS et Postgres ou les "faits frits" acad√©miques sur leur relation, mais je n'ai jamais rien appris d'int√©ressant de sa part.</em>  <em>Peut-√™tre qu'√† ce moment-l√†, √† Berkeley, quelqu'un ¬´remuait de l'eau¬ª.</em> <br><br>  En principe, la concurrence ¬´explose¬ª l'espace des plans de l'optimiseur de requ√™tes, multipliant les choix traditionnels effectu√©s lors de l'optimisation des requ√™tes (acc√®s aux donn√©es, algorithmes de connexion, ordre de connexion) par toutes les mani√®res possibles de parall√©liser chaque choix.  L'id√©e principale de ¬´l'optimiseur Wei Hong¬ª appel√© par Stonebreaker √©tait de diviser le probl√®me en deux: lancer l'optimiseur de requ√™te traditionnel dans l'esprit du syst√®me R pour un n≈ìud, puis ¬´parall√©liser¬ª le plan r√©sultant, planifier le degr√© de parall√©lisme et le placement de chaque op√©rateur en fonction de la repr√©sentation configuration des donn√©es et du syst√®me.  Cette approche est heuristique, mais en elle la simultan√©it√© augmente le co√ªt de l'optimisation de requ√™te traditionnelle de mani√®re additive, plut√¥t que multiplicative. <br><br>  Bien que l'optimiseur de Wei Hong ait √©t√© d√©velopp√© dans le contexte de Postgres, il est devenu l'approche standard pour de nombreux optimiseurs de requ√™tes simultan√©s dans l'industrie. <br><br><h2>  2.6.  Prise en charge de divers mod√®les de langue </h2><br>  Parmi les int√©r√™ts de Stonebreaker, renouvel√© √† plusieurs reprises depuis l'√©poque d'Ingres, figurait l'interface de programmation d'application (API) du syst√®me de base de donn√©es.  Dans ses conf√©rences de la s√©rie Database Systems, il a souvent inclus le langage GEM Carlo Zaniolo comme un sujet qu'il est important de comprendre pour les partisans du syst√®me de base de donn√©es.  Cet int√©r√™t pour le langage l'a sans aucun doute amen√© √† s'associer avec Larry Rowe dans Postgres, qui √† son tour a profond√©ment influenc√© la conception du mod√®le de donn√©es Postgres et son approche relationnelle objet.  Leur travail √©tait principalement ax√© sur les applications pour travailler avec un grand volume de donn√©es de la sph√®re commerciale, y compris le traitement des informations commerciales et les nouvelles applications telles que CAD / CAM et GIS. <br><br>  L'un des probl√®mes qui a √©t√© impos√© √† Stonebreaker √† l'√©poque √©tait l'id√©e de ¬´cacher¬ª les fronti√®res entre les constructions du langage de programmation et le r√©f√©rentiel de base de donn√©es.  Divers projets de recherche et entreprises concurrentes qui recherchent des bases de donn√©es orient√©es objet (OODB) ont cibl√© la soi-disant ¬´perte de conformit√©¬ª entre les langages de programmation orient√©s objet imp√©ratifs tels que Smalltalk, C ++ et Java, et les relations d√©claratives mod√®le.  L'id√©e d'OODB √©tait de rendre les objets du langage de programmation, si d√©sir√©, marqu√©s comme ¬´permanents¬ª et automatiquement trait√©s par le SGBD int√©gr√©.  Postgres a pris en charge le stockage d'objets imbriqu√©s et de types de donn√©es abstraits, mais son interface, bas√©e sur des requ√™tes d√©claratives dans un style relationnel, a suppos√© un acc√®s non naturel √† la base de donn√©es pour le programmeur (cela n√©cessitait l'utilisation de requ√™tes d√©claratives), qui √©taient √©galement co√ªteuses (n√©cessitant une analyse et optimisation).  Pour concurrencer les fournisseurs OODB, Postgres a fourni la soi-disant interface Fast Path: essentiellement l'API C / C ++ pour le stockage de base de donn√©es interne.  Cela a permis √† Postgres d'avoir des performances de r√©f√©rence acad√©miques OODB moyennes, mais cela n'a jamais r√©solu le probl√®me de laisser les programmeurs dans diff√©rentes langues √©viter le probl√®me de la perte de conformit√©.  Au lieu de cela, Stonebreaker a qualifi√© Postgres de label ¬´objet-relationnel¬ª et a simplement contourn√© l'utilisation de bases de donn√©es orient√©es objet en tant que march√© √† z√©ro milliard de dollars.  Aujourd'hui, presque tous les syst√®mes de bases de donn√©es relationnelles commerciales sont des syst√®mes de bases de donn√©es ¬´relationnels-objets¬ª. <br><br>  Cela s'est av√©r√© √™tre une solution raisonnable.  Aujourd'hui, aucun des produits OODB n'existe sous sa forme pr√©vue, et l'id√©e d '"objets persistants" dans les langages de programmation a √©t√© largement √©cart√©e.  En revanche, l'utilisation de couches de cartographie relationnelle objet (ORM) est tr√®s r√©pandue, aliment√©e par des travaux ant√©rieurs, tels que Java Hibernate et Ruby on Rails, qui permettent ¬´d'adapter¬ª les bases de donn√©es d√©claratives √† presque tous les objets imp√©ratifs de mani√®re relativement fluide. langage de programmation orient√© comme biblioth√®ques.  Cette approche au niveau de l'application diff√®re des bases de donn√©es relationnelles objet OODB et Stonebreaker.  En outre, des stockages de valeurs-cl√©s l√©gers sont √©galement utilis√©s avec succ√®s sous des formes non transactionnelles et transactionnelles.  Leur d√©couvreur √©tait l'√©tudiant dipl√¥m√© de Stonebreaker Margo Seltzer, qui a travaill√© sur la base de donn√©es Berkeley DB dans le cadre de sa th√®se de doctorat en m√™me temps que le groupe Postgres, qui pr√©voyait la croissance des r√©f√©rentiels de valeurs-cl√©s NoSQL distribu√©s tels que Dynamo , MongoDB et Cassandra. <br><br><h1>  3. Impact sur les logiciels </h1><br><h2>  3.1.  Open source </h2><br>  Postgres a toujours √©t√© un projet open source avec des versions coh√©rentes, mais au d√©but, il √©tait destin√© √† √™tre utilis√© pour la recherche plut√¥t que pour la production. <br><br>  Comme le projet de recherche Postgres a √©t√© interrompu, deux √©tudiants de Stonebreaker, Andrew Yu et Jolly Chen, ont modifi√© l'analyseur syst√®me pour remplacer le langage Postquel original par une variante SQL extensible.  La premi√®re version de Postgres prenant en charge SQL √©tait Postgres95, et la suivante s'appelait PostgreSQL. <br><br>  Une √©quipe de d√©veloppement open source s'est int√©ress√©e √† PostgreSQL et l'a ¬´accept√©e¬ª m√™me si les int√©r√™ts du reste de l'√©quipe de Berkeley ont chang√©.  L'√©quipe centrale de PostgreSQL est rest√©e relativement stable au fil du temps et le projet open source est devenu tr√®s d√©velopp√©.  Initialement, les efforts √©taient concentr√©s sur la stabilit√© du code et des fonctionnalit√©s visibles par l'utilisateur, mais au fil du temps, la communaut√© des logiciels open source a consid√©rablement chang√© et am√©lior√© le c≈ìur du syst√®me, de l'optimiseur aux m√©thodes d'acc√®s et au principal syst√®me de transaction et de stockage.  Depuis le milieu des ann√©es 1990, une tr√®s petite fraction des composants internes de PostgreSQL provenait de l'√©quipe acad√©mique de Berkeley.  Sa derni√®re contribution a peut-√™tre √©t√© ma mise en ≈ìuvre de GiST dans la seconde moiti√© des ann√©es 1990, mais m√™me elle a √©t√© substantiellement r√©√©crite et approuv√©e par des b√©n√©voles de la communaut√© open source (dans ce cas, la Russie).  La partie de la communaut√© open source qui travaille sur PostgreSQL m√©rite les plus grands √©loges pour son processus rationalis√©, qui pendant des d√©cennies a servi √† cr√©er un projet tr√®s efficace et √† long terme. <br><br>  Bien que beaucoup de choses aient chang√© au cours des 25 derni√®res ann√©es, l'architecture sous-jacente de PostgreSQL reste tr√®s similaire aux versions universitaires de Postgres au d√©but des ann√©es 1990, et les d√©veloppeurs familiaris√©s avec le code source actuel de PostgreSQL trouveront facile de lire le code source de Postgres 3.1 (1991).  Tout, de la structure du r√©pertoire du code source aux structures de processus et aux structures de donn√©es, reste √©tonnamment similaire.  Le code de l'√©quipe Postgres √† Berkeley avait une grande colonne vert√©brale. <br><br>  Aujourd'hui, PostgreSQL est sans aucun doute le syst√®me de gestion de base de donn√©es open source le plus performant, et il prend en charge des fonctionnalit√©s que l'on ne trouve souvent pas dans les produits commerciaux.  Il s'agit √©galement (selon un site de notation influent) du SGBD ind√©pendant open source le plus populaire au monde, et son influence ne cesse de cro√Ætre: en 2017 et 2018, il s'agissait de la base de donn√©es ayant la popularit√© la plus rapide au monde [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DE19c</a> ].  PostgreSQL est utilis√© dans une grande vari√©t√© d'industries et de t√¢ches, ce qui n'est pas surprenant, √©tant donn√© sa concentration sur de nombreuses opportunit√©s. <br><br>  <em>Selon DB-Engines, PostgreSQL est aujourd'hui la quatri√®me base de donn√©es la plus populaire au monde, apr√®s Oracle, MySQL et MS SQL Server, tous trois propos√©s par des soci√©t√©s sp√©cifiques (MySQL a √©t√© acquis par Oracle il y a de nombreuses ann√©es) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DE19a</a> ].</em>  <em>Les r√®gles de classement sont discut√©es dans la description de la m√©thodologie de classement DB-Engines [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DE19b</a> ].</em> <br><br>  Heroku est le fournisseur de cloud SaaS qui fait d√©sormais partie de Salesforce.  Postgres a √©t√© introduit dans Heroku en 2010 comme base de donn√©es par d√©faut pour sa plate-forme.  Heroku a choisi Postgres pour sa fiabilit√©.  Avec la prise en charge de Heroku, de plus grandes plates-formes de d√©veloppement d'applications telles que Ruby on Rails et Python pour Django ont commenc√© √† recommander Postgres comme base de donn√©es par d√©faut. <br><br>  Aujourd'hui, PostgreSQL prend en charge une infrastructure d'extension qui facilite l'ajout de fonctionnalit√©s suppl√©mentaires au syst√®me via des fonctions d√©finies par l'utilisateur et les modifications associ√©es.  Il existe maintenant un √©cosyst√®me d'extensions PostgreSQL, semblable au concept llustra des packages d'extension DataBlade, mais avec du code open source.  Les extensions les plus int√©ressantes incluent, par exemple, la biblioth√®que Apache MADlib pour l'apprentissage automatique dans l'interface SQL et la biblioth√®que Citus pour l'ex√©cution de requ√™tes parall√®les. <br><br>  L'une des applications open source les plus int√©ressantes reposant sur Postgres est le syst√®me d'information g√©ographique PostGIS, qui utilise de nombreuses fonctionnalit√©s Postgres qui ont inspir√© Stonebreaker √† l'origine pour d√©marrer le projet. <br><br><h2>  3.2.  Mise en ≈ìuvre commerciale </h2><br>  PostgreSQL est depuis longtemps un point de d√©part attrayant pour la cr√©ation de syst√®mes de bases de donn√©es commerciales, √©tant donn√© son utilisation sous la licence logicielle open source ¬´tout autoris√©e¬ª, son code fiable, sa flexibilit√© et ses nombreuses fonctionnalit√©s.  En r√©sumant les co√ªts d'acquisition √©num√©r√©s ci-dessous, nous constatons que Postgres a re√ßu plus de 2,6 milliards de dollars en co√ªts d'acquisition. <br><br>  <em>Veuillez noter qu'il s'agit d'une mesure en dollars de transactions financi√®res r√©elles et est beaucoup plus importante que les valeurs qui sont souvent utilis√©es en haute technologie.</em>  <em>Les chiffres en milliards sont souvent utilis√©s pour d√©crire la valeur estim√©e des blocs d'actions, mais sont souvent surestim√©s de 10 fois ou plus par rapport √† la valeur actuelle dans l'espoir de son importance future.</em>  <em>Les dollars de transaction d'acquisition de la soci√©t√© mesurent sa valeur marchande r√©elle au moment de l'acquisition.</em>  <em>Il est juste de dire que Postgres a cr√©√© plus de 2,6 milliards de dollars de valeur commerciale r√©elle.</em> <br><br>  De nombreux efforts commerciaux associ√©s √† PostgreSQL se sont concentr√©s sur ce qui est probablement sa principale limitation: la capacit√© d'√©voluer vers une architecture parall√®le sans partager les ressources. <br><br>  <em>La parall√©lisation de PostgreSQL n√©cessite beaucoup de travail, mais est hautement r√©alisable par une petite √©quipe exp√©riment√©e.</em>  <em>Aujourd'hui, les branches de l'industrie open source PostgreSQL telles que Greenplum et CitusDB offrent une telle opportunit√©.</em>  <em>Il est regrettable que PostgreSQL n'ait pas √©t√© correctement parall√©lis√© en open source beaucoup plus t√¥t.</em>  <em>Si PostgreSQL avait √©t√© d√©velopp√© dans l'open source avec le support d'une architecture sans partage de ressources au d√©but des ann√©es 2000, il est possible que la direction du big data open source se soit d√©velopp√©e d'une mani√®re compl√®tement diff√©rente et plus efficace.</em> <br><br><ol><li>  Illustra √©tait la deuxi√®me plus grande startup de Stonebreaker, fond√©e en 1992 pour commercialiser Postgres, lorsque RTI a lanc√© Ingres sur le march√©. <br><br>  <em>Illustra √©tait en fait le troisi√®me nom propos√© pour l'entreprise.</em>  <em>Poursuivant le th√®me de la peinture, √©tant donn√© le nom d'Ingres, Illustra s'appelait √† l'origine Miro.</em>  <em>En raison de probl√®mes de marque, le nom a √©t√© chang√© pour Montage, mais il a √©galement rencontr√© des probl√®mes de marque.</em> <br><br>  L'√©quipe fondatrice comprenait une partie du noyau de l'√©quipe Postgres, y compris Wei Hong, r√©cemment dipl√¥m√© de l'√©cole sup√©rieure et Jeff Meredith, alors programmeur senior, ainsi que des dipl√¥m√©s d'Ingres Paula Hawthorn et Michael Ubell.  Mike Olson, √©tudiant dipl√¥m√© de Postgres, a rejoint l'√©quipe peu de temps apr√®s sa fondation et j'ai travaill√© chez Illustra pour optimiser des fonctionnalit√©s co√ªteuses dans le cadre de mon doctorat.  Illustra    :  SQL92      ,    Postquel,    Postgres               DataBlade ‚Äî       . Illustra   Informix  1997     400 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mon96</a> ],    DataBlade         Informix  Informix Universal Server. <br></li><li> Netezza  ,   1999 ,    PostgreSQL             FPGA. Netezza     ,        2007 .       IBM  1,7 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBM10</a> ]. <br></li><li> Greenplum         PostgreSQL   .   2003 , Greenplum     PostgreSQL,      API PostgreSQL,  API   .    , Greenplum  PostgreSQL         ,   ,   Orca. Greenplum   EMC  2010   300 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mal10</a> ],   2012  EMC  Greenplum     Pivotal.  2015  Pivotal    Greenplum  Orca    .    Greenplum   Postgres API   MADlib     SQL [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HRS+12</a> ]. MADlib     Apache.        ,   Greenplum,  Apache HAWQ,   Pivotal,   ¬´ ¬ª Greenplum (. .         PostgreSQL)    ,     Hadoop. <br></li><li> EnterpriseDB    2004   ,          PostgreSQL   ,             .    EnterpriseDB Advanced Server      Oracle,     Oracle. <br></li><li>  Aster Data    2005    ,      .        PostgreSQL. Aster             ,        SQL  MapReduce. Aster Data    Teradata  2011   263 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sho11</a> ].  Teradata    Aster       ,  -  Aster             Teradata. <br></li><li>  ParAccel    2006 ,    PostgreSQL      . ParAccel   Postgres        .  2011  Amazon   ParAccel,   2012   AWS Redshift ‚Äî             ParAccel.  2013  ParAccel    Actian (   Ingres)    ,  ,        Actian.    AWS Redshift     Amazon ‚Äî            Amazon,   ,            ,   Teradata  Oracle Exadata.    Postgres       . <br></li><li>  CitusDB <em>(CitusDB ‚Äî  ;   Citus Data. ‚Äî . .)</em>    2010 ,     PostgreSQL   .      PostgreSQL,  2016  CitusDB    API  PostgreSQL        PostgreSQL.  2016   CitusDB     . <br></li></ol><br><h1> 4.  </h1><br>        Postgres,       . <br><br>   ,   ,   ,  Postgres   ¬´  ¬ª (Second System Effect)    (Fred Brooks) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bro75</a> ].  ,          ,    -    . Postgres    ,  , ,     .      ,     ,       .     ‚Äî    Postgres     ,      .               :     ,    .  , ¬´ ¬ª  .    ,    ,      .       ¬´-¬ª    ,      ¬´-¬ª    . <br><br>     ,    , ¬´   ¬ª,       ,    .     <em>( 2001           (). ‚Äî . .)</em>          2000-   ¬´    ¬ª.          ,         Postgres. ,            ,       . <br><br> <em>   (Ralph Waldo Emerson), ¬´  ‚Äî   ¬ª.</em> <br><br> ,     ¬´    ¬ª (       ),   ,      ,      , ,               .  ,           .   ,        ,       - .    ,   .          ,     . <br><br>  ,     Postgres, ‚Äî   ,          .        ¬´ ¬ª  PostgreSQL,       ,        .  ,    : <br><blockquote>  ,  ,            ,          1995 .  Postgres,     ,     .       ,     ,            ,       . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto14</a> ] <br></blockquote>  ,   ,     ,  ,   ¬´ ¬ª   .      ¬´ ¬ª.   , ,  ,         ,       Postgres.     - ,    : ¬´ -      ¬ª.   (  ),         . <br><br><h1> 5.  </h1><br>       Postgres  ,          ,     (Craig Kerstiens)      PostgreSQL. <br><br><h1>  Litt√©rature </h1><br><ul><li><a name="Bro75"></a> [Bro75] Frederick P Brooks. The mythical man-month, 1975. </li><li><a name="Bro19"></a> [Bro19] Michael L. Brodie, editor. Making Databases Work. Morgan &amp; Claypool, 2019. </li><li><a name="DE19a"></a> [DE19a] DB-Engines. DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">db-engines.com/en/ranking</a> . (Last accessed January 4, 2019). </li><li><a name="DE19b"></a> [DE19b] DB-Engines. Method of calculating the scores of the DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019). </li><li><a name="DE19c"></a> [DE19c] DB-Engines. PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019). </li><li><a name="DS08"></a> [DS08] David DeWitt and Michael Stonebraker. Mapreduce: A major step backwards. The Database Column, 1:23, 2008. </li><li><a name="Gut84"></a> [Gut84] Antonin Guttman. R-trees: A dynamic index structure for spatial searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 47‚Äì57, New York, NY, USA, 1984. ACM. </li><li><a name="HKM02"></a> [HKM <sup>+</sup> 02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas. On a model of indexability and its bounds for range queries. J. ACM, 49(1):35‚Äì55, January 2002. </li><li><a name="HNP95"></a> [HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Proceedings of the 21th International Conference on Very Large Data Bases, VLDB '95, pages 562‚Äì573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc. </li><li><a name="HRS12"></a> [HRS <sup>+</sup> 12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al. The MADlib analytics library: or MAD skills, the SQL. Proceedings of the VLDB Endowment, 5(12):1700‚Äì1711, 2012. </li><li><a name="IBM10"></a> [IBM10] IBM to acquire Netezza, September 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018). </li><li><a name="KMH97"></a> [KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein. Concurrency and recovery in generalized search trees. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, SIGMOD '97, pages 62‚Äì72, New York, NY, USA, 1997. ACM. </li><li><a name="Mal10"></a> [Mal10] Om Malik. Big Data = Big Money: EMC Buys Greenplum. In GigaOm, July 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gigaom.com/2010/07/06/emc-buys-greenplum</a> . </li><li><a name="Mon96"></a> [Mon96] John Monroe. Informix acquires illustra for complex data management. In Federal Computer Week, January 1996. </li><li><a name="OFS83"></a> [OFS83] James Ong, Dennis Fogg, and Michael Stonebraker. Implementation of data abstraction in the relational database system ingres. ACM Sigmod Record, 14(1):1‚Äì14, 1983. </li><li><a name="Ols93"></a> [Ols93] Michael A. Olson. The design and implementation of the inversion file system. 1993. </li><li><a name="SAHR84"></a> [SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein. Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 208‚Äì214, New York, NY, USA, 1984. ACM. </li><li><a name="Sho11"></a> [Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018). </li><li><a name="SHWK76"></a> [SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189‚Äì222, 1976. </li><li><a name="SK91"></a> [SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78‚Äì92, October 1991. </li><li><a name="SR86"></a> [SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD '86, pages 340‚Äì355, New York, NY, USA, 1986. ACM. </li><li><a name="SRG83"></a> [SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983. </li><li><a name="Sto86"></a> [Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4‚Äì9, 1986. </li><li><a name="Sto87"></a> [Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB '87, pages 289‚Äì300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc. </li><li><a name="Sto95"></a> [Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39‚Äì49, 1995. </li><li><a name="Sto14"></a> [Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438890/">https://habr.com/ru/post/fr438890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438878/index.html">L'apparition du film en torrents apr√®s la premi√®re augmente le box-office de 3%</a></li>
<li><a href="../fr438880/index.html">Quand utiliser var, let et const en Javascript [traduction de l'article de Tyler McGinnis]</a></li>
<li><a href="../fr438882/index.html">La probabilit√© de gagner un match avec une probabilit√© connue de gagner un point</a></li>
<li><a href="../fr438884/index.html">Histoire vraie d'une agence de publicit√© de l'outback: hauts, bas et impl√©mentation CRM</a></li>
<li><a href="../fr438886/index.html">Morty, nous sommes √† UltraHD! Comment regarder n'importe quel film en 4K, en le compl√©tant via un r√©seau neuronal peu connu</a></li>
<li><a href="../fr438892/index.html">Qu'est-ce qu'une blockchain d'entreprise?</a></li>
<li><a href="../fr438894/index.html">Pourquoi le d√©veloppement Web sur Go est plus agr√©able que sur PHP</a></li>
<li><a href="../fr438896/index.html">Ne pleure pas</a></li>
<li><a href="../fr438898/index.html">Installation invers√©e et d'extension de Chrome</a></li>
<li><a href="../fr438900/index.html">En route vers les principes physiques de l'√©volution biologique. Fin + texte int√©gral de la traduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>