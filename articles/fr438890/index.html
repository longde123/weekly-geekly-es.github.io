<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜ğŸ¾ ğŸ† ğŸ›« Postgres rÃ©trospectivement ğŸ”ˆ ğŸ—œï¸ ğŸ”¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous attirons votre attention sur une traduction de l' article de Joseph Hellerstein Â«Looking Back at PostgresÂ» , publiÃ© sous la version 4.0 de l' aff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres rÃ©trospectivement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/438890/">  <em>Nous attirons votre attention sur une traduction de <strong>l'</strong> article de <strong>Joseph Hellerstein Â«Looking Back at PostgresÂ»</strong> , publiÃ© sous la version 4.0 de l' <strong>affirmation des droits d'auteur</strong> Creative Commons (CC-BY 4.0).</em>  <em>Les auteurs se rÃ©servent le droit de diffuser ce travail sur des sites Web personnels et d'entreprise avec un lien appropriÃ© vers la source.</em> <br><br>  <em>Traduction rÃ©alisÃ©e par Elena Indrupskaya.</em>  <em>J'ajouterai de moi-mÃªme qu '"un programmeur qui voulait dÃ©sespÃ©rÃ©ment construire un systÃ¨me avec plusieurs versions" semble Ãªtre Vadim Mikheev, mais nous connaissons tous les "volontaires de Russie" qui ont rÃ©Ã©crit GiST.</em> <br><br><h1>  Annotation </h1><br>  Il s'agit d'un souvenir du projet Postgres, dirigÃ© Ã  l'UniversitÃ© de Californie Ã  Berkeley et dirigÃ© par Mike Stonebraker du milieu des annÃ©es 1980 au milieu des annÃ©es 1990.  Comme l'un des nombreux souvenirs personnels et historiques, cet article a Ã©tÃ© demandÃ© pour le livre [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bro19</a> ] on Stonebreaker's Turing Award.  Par consÃ©quent, l'article se concentre sur le rÃ´le principal de Stonebreaker et ses rÃ©flexions sur le design.  Mais Stonebreaker n'a jamais Ã©tÃ© programmeur et n'a pas interfÃ©rÃ© avec son Ã©quipe de dÃ©veloppement.  La base de code Postgres Ã©tait le travail d'une Ã©quipe d'Ã©tudiants brillants et parfois de programmeurs universitaires Ã  temps plein qui avaient un peu plus d'expÃ©rience (et seulement un salaire lÃ©gÃ¨rement plus Ã©levÃ©) que les Ã©tudiants.  J'ai eu la chance de rejoindre cette Ã©quipe en tant qu'Ã©tudiant au cours des derniÃ¨res annÃ©es du projet.  J'ai reÃ§u du matÃ©riel utile pour cet article de certains des Ã©tudiants plus Ã¢gÃ©s impliquÃ©s dans le projet, mais toutes les erreurs ou omissions sont les miennes.  Si vous en remarquez, contactez-moi et je vais essayer de les rÃ©parer. <br><a name="habracut"></a><br><h1>  1. Introduction </h1><br>  Postgres Ã©tait le projet le plus ambitieux de Michael Stonebreaker - sa tentative sÃ©rieuse de crÃ©er un systÃ¨me de base de donnÃ©es universel.  Pendant une dÃ©cennie, le projet a gÃ©nÃ©rÃ© plus d'articles, de doctorats, de professeurs et d'entreprises que toute autre activitÃ© Stonebreaker.  Le projet couvrait Ã©galement plus du domaine technique que tout autre systÃ¨me qu'il avait construit.  MalgrÃ© le risque inhÃ©rent de cette ampleur, Postgres est Ã©galement devenu l'artefact logiciel le plus rÃ©ussi issu des Ã©quipes de recherche de Stonebreaker, et sa principale contribution Ã  l'open source.  Ceci est un exemple d'un Â«deuxiÃ¨me systÃ¨meÂ» [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bro75</a> ] qui a rÃ©ussi.  Au moment de la rÃ©daction, plus de trente ans depuis le dÃ©but du projet, le systÃ¨me open source PostgreSQL est le systÃ¨me de base de donnÃ©es open source indÃ©pendant le plus populaire au monde et le quatriÃ¨me systÃ¨me de base de donnÃ©es le plus populaire.  ParallÃ¨lement, les entreprises crÃ©Ã©es Ã  partir de Postgres ont gÃ©nÃ©rÃ© un total de plus de 2,6 milliards de dollars (en coÃ»t d'acquisition).  Ã€ tous Ã©gards, la vision du Postgres Stonebreaker avait une Ã©norme rÃ©sonance durable. <br><br><h2>  1.1.  Contexte </h2><br>  Stonebreaker a connu un Ã©norme succÃ¨s au dÃ©but de sa carriÃ¨re avec le projet de recherche Ingres Berkeley [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SHWK76</a> ] et la startup suivante, qu'il a fondÃ©e avec Larry Rowe et Eugene Wong: Relational Technology, Inc.  (RTI). <br><br>  Au fur et Ã  mesure que RTI se dÃ©veloppait au dÃ©but des annÃ©es 1980, Stonebreaker a commencÃ© Ã  travailler sur la prise en charge des types de donnÃ©es dans les SGBD qui allaient au-delÃ  des lignes et colonnes traditionnelles du modÃ¨le relationnel Codd d'origine (Edgar Frank Codd).  Un exemple motivant Ã  l'Ã©poque Ã©tait le besoin de bases de donnÃ©es pour prendre en charge les outils de conception assistÃ©e par ordinateur (CAO) pour l'industrie microÃ©lectronique.  Dans un article de 1983 de Stonebreaker et d'Ã©tudiants, Brad Rubenstein et Antonin Guttman ont expliquÃ© Ã  quel point cette industrie avait besoin de prendre en charge Â«de nouveaux types de donnÃ©es tels que les polygones, les rectangles, les chaÃ®nes de texte, etc.Â», Â« recherche spatiale efficace Â»,Â« contraintes d'intÃ©gritÃ© complexes Â», ainsi queÂ« hiÃ©rarchies de conception et reprÃ©sentations multiples Â»dans les mÃªmes structures physiques [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SRG83</a> ].  Avec cette motivation, le groupe a commencÃ© Ã  travailler sur l'indexation (y compris l'utilisation des arbres R de Guttman pour l'indexation spatiale [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gut84</a> ]) et sur l'ajout de types de donnÃ©es abstraits (ADT) au systÃ¨me de base de donnÃ©es relationnelle.  Ã€ cette Ã©poque, les ADT Ã©taient une nouvelle conception populaire des langages de programmation, qui a d'abord Ã©tÃ© introduite par Barbara Liskov, plus tard laurÃ©ate du prix Turing, et explorÃ©e dans la programmation d'applications de base de donnÃ©es par Lonely Rowe, un nouveau collaborateur de Stonebreaker.  Un article dans un enregistrement SIGMOD de 1983 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OFS83</a> ] Stonebreaker et les Ã©tudiants James Ong et Dennis Fogg dÃ©crivent une Ã©tude de ce concept dans l'extension Ingres appelÃ©e ADT-Ingres, qui incorpore de nombreux concepts de prÃ©sentation Ã©tudiÃ©s plus profondÃ©ment et avec un meilleur support du systÃ¨me dans Postgres. <br><br><h1>  2. Postgres: informations gÃ©nÃ©rales </h1><br>  Comme son nom l'indique, Postgres est Post-Ingres: un systÃ¨me conÃ§u pour prendre ce qu'Ingres pourrait faire et aller au-delÃ .  Une caractÃ©ristique distinctive de Postgres Ã©tait l'introduction de ce qu'elle a finalement appelÃ© les propriÃ©tÃ©s objet-relationnelles de la base de donnÃ©es: la prise en charge du concept de programmation orientÃ©e objet dans le modÃ¨le de donnÃ©es et le langage de requÃªte dÃ©clarative du systÃ¨me de base de donnÃ©es.  Mais Stonebreaker a Ã©galement prÃ©vu de rÃ©soudre un certain nombre d'autres problÃ¨mes technologiques indÃ©pendants du support orientÃ© objet dans Postgres, tels que les rÃ¨gles de base de donnÃ©es actives, les donnÃ©es versionnÃ©es, le stockage tertiaire et la concurrence. <br><br>  Deux articles ont Ã©tÃ© Ã©crits sur la conception Postgres: une description de la conception ancienne en 1986 SIGMOD [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SR86</a> ] et une description intermÃ©diaire dans CACM 1991 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SK91</a> ].  Le projet de recherche Postgres a progressivement Ã©chouÃ© en 1992 avec la fondation d'Illustra, une startup qui a impliquÃ© Stonebreaker, l'Ã©tudiant diplÃ´mÃ© principal Wei Hong et plus tard devenu programmeur en chef Jeff Meredith.  Dans la liste ci-dessous, les opportunitÃ©s mentionnÃ©es dans l'article de 1986 sont marquÃ©es d'un astÃ©risque * et les opportunitÃ©s de l'article de 1991, qui ne figuraient pas dans l'article de 1986, sont marquÃ©es d'un poignard <sup>â€ </sup> .  Les autres tÃ¢ches Ã©numÃ©rÃ©es ci-dessous ont Ã©tÃ© prises dans la documentation sur le systÃ¨me et la recherche, mais elles ne figurent dans aucune spÃ©cification de conception.  Beaucoup de ces sujets ont Ã©tÃ© abordÃ©s chez Postgres bien avant d'Ãªtre Ã©tudiÃ©s ou rÃ©inventÃ©s par d'autres.  Dans de nombreux cas, Postgres Ã©tait trop en avance sur son temps, et l'intÃ©rÃªt pour les sujets a explosÃ© plus tard, dans une perspective moderne. <br><br><ol><li>  Prise en charge d'ADT dans le systÃ¨me de base de donnÃ©es <br><ul><li>  Objets complexes (c.-Ã -d. DonnÃ©es imbriquÃ©es ou donnÃ©es de forme non premiÃ¨re normale (forme non premiÃ¨re normale - NF2)) * </li><li>  Types et fonctions de donnÃ©es abstraites personnalisÃ©es * </li><li>  MÃ©thodes d'accÃ¨s extensibles pour les nouveaux types de donnÃ©es * </li><li>  Traitement optimisÃ© des requÃªtes avec des fonctionnalitÃ©s coÃ»teuses dÃ©finies par l'utilisateur </li></ul></li><li>  Bases de donnÃ©es et systÃ¨mes de rÃ¨gles actifs (dÃ©clencheurs, avertissements) * <br><ul><li>  RÃ¨gles implÃ©mentÃ©es lors de la rÃ©Ã©criture des demandes <sup>â€ </sup> </li><li>  RÃ¨gles implÃ©mentÃ©es comme dÃ©clencheurs de niveau d'enregistrement <sup>â€ </sup> </li></ul></li><li>  Stockage et rÃ©cupÃ©ration basÃ©s sur les journaux <br><ul><li>  Code de rÃ©cupÃ©ration Ã  complexitÃ© rÃ©duite qui traite le journal comme des donnÃ©es *, en utilisant de la mÃ©moire non volatile pour l'Ã©tat de validation <sup>â€ </sup> </li><li>  Stockage non rÃ©Ã©crit et requÃªtes temporelles <sup>â€ </sup> </li></ul></li><li>  Prise en charge des nouvelles technologies de stockage en profondeur, en particulier les disques optiques * </li><li>  Prise en charge des multiprocesseurs et des processeurs spÃ©cialisÃ©s * </li><li>  Prise en charge de divers modÃ¨les de langue <br><ul><li>  Modifications minimales du modÃ¨le relationnel et prise en charge des requÃªtes dÃ©claratives * </li><li>  AccÃ¨s Ã  la Â«voie rapideÂ» Ã  partir des API internes en contournant le langage de requÃªte <sup>â€ </sup> </li><li>  Multilinguisme <sup>â€ </sup> </li></ul></li></ol><br>  Nous discuterons briÃ¨vement de la contribution de Postgres pour chacun de ces Ã©lÃ©ments par rapport aux travaux ultÃ©rieurs dans le domaine de l'informatique. <br><br><h2>  2.1.  Prise en charge d'ADT dans le systÃ¨me de base de donnÃ©es </h2><br>  L'objectif clair de Postgres Ã©tait de prendre en charge de nouvelles propriÃ©tÃ©s relationnelles-objet: Ã©tendre la technologie de base de donnÃ©es pour fournir les avantages du traitement des requÃªtes relationnelles et de la programmation orientÃ©e objet.  Au fil du temps, le concept relationnel-objet qui est apparu pour la premiÃ¨re fois dans Postgres est devenu une fonctionnalitÃ© standard dans la plupart des systÃ¨mes de bases de donnÃ©es modernes. <br><br><h3>  2.1.1.  Objets complexes </h3><br>  TrÃ¨s souvent, les donnÃ©es sont reprÃ©sentÃ©es comme des entitÃ©s imbriquÃ©es ou des Â«objetsÂ».  Un exemple classique est un bon de commande, qui comprend un ensemble intÃ©grÃ© de produits, leurs quantitÃ©s et leurs prix.  La religion de la modÃ©lisation relationnelle a dictÃ© que ces donnÃ©es doivent Ãªtre restructurÃ©es et enregistrÃ©es dans un format sans imbrication, en utilisant plusieurs tables plates d'objets (commandes, produits) avec des tables plates de relations (product_in_order).  Une raison typique de cet aplatissement est qu'il rÃ©duit la duplication des donnÃ©es (car le produit est dÃ©crit de maniÃ¨re redondante dans de nombreux bons de commande), ce qui Ã©vite Ã  son tour la complexitÃ© ou les erreurs lors de la mise Ã  jour de toutes les copies redondantes.  Mais dans certains cas, vous souhaitez conserver la sous-vue, car elle est naturelle pour l'application (par exemple, le mÃ©canisme de disposition du circuit en CAO), et les mises Ã  jour sont rares.  Ce dÃ©bat sur la modÃ©lisation des donnÃ©es est au moins aussi ancien que le modÃ¨le relationnel. <br><br>  L'approche clÃ© de Postgres Ã©tait de Â«s'asseoir sur deux chaisesÂ» en termes de modÃ©lisation des donnÃ©es: Postgres a enregistrÃ© les tables en tant que type de donnÃ©es Â«le plus externeÂ», mais a permis aux colonnes d'avoir des types Â«complexesÂ», y compris des tuples ou des tables imbriquÃ©s.  L'une de ses implÃ©mentations les moins courantes, explorÃ©e pour la premiÃ¨re fois dans le prototype ADT-Ingres, Ã©tait de permettre la dÃ©claration dÃ©clarative d'une colonne de type de table comme dÃ©finition de requÃªte: Â«Quel comme type de donnÃ©esÂ» [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SAHR84</a> ] <em>(Quel - Ingres Query Language - Approx. .)</em> . <br><br>  Le thÃ¨me Â«post-relationnelÂ» de la prise en charge Ã  la fois des requÃªtes dÃ©claratives et des donnÃ©es intÃ©grÃ©es est rÃ©apparu au fil des ans, souvent gÃ©nÃ©rÃ© par des diffÃ©rends sur ce qui est le mieux.  Ã€ l'Ã©poque de Postgres dans les annÃ©es 1980 et 1990, certains groupes impliquÃ©s dans les bases de donnÃ©es orientÃ©es objet ont repris cette idÃ©e et l'ont dÃ©veloppÃ©e dans le langage OQL standard, qui a ensuite cessÃ© d'Ãªtre utilisÃ©. <br><br>  Au tournant du millÃ©naire, les requÃªtes dÃ©claratives sur les objets imbriquÃ©s sont devenues une obsession de la recherche pour le segment de la communautÃ© des dÃ©veloppeurs de bases de donnÃ©es sous forme de bases de donnÃ©es XML.  Le langage XQuery rÃ©sultant (dirigÃ© par Don Chamberlin, le personnage de SQL) est nÃ©cessaire pour prendre en charge des objets complexes dans le langage Postgel de Postgres.  XQuery est largement utilisÃ© et largement utilisÃ© dans l'industrie, mais n'a jamais Ã©tÃ© populaire auprÃ¨s des utilisateurs.  Aujourd'hui, ces concepts sont rÃ©examinÃ©s dans des projets de langage de requÃªte pour le modÃ¨le de donnÃ©es JSON, populaire dans les applications basÃ©es sur un navigateur.  Comme OQL, dans les groupes qui ont initialement rejetÃ© les requÃªtes dÃ©claratives en faveur de la programmation orientÃ©e dÃ©veloppeur (le mouvement Â«NoSQLÂ»), ces langages n'apparaissent souvent comme un ajout tardif que du dÃ©sir de rajouter des requÃªtes au systÃ¨me.  Dans le mÃªme temps, au fur et Ã  mesure que Postgres a grandi au fil des ans (et est passÃ© du langage de requÃªte Postquel Ã  des versions SQL qui rÃ©pondent Ã  de nombreux objectifs pris en compte), il a inclus la prise en charge des donnÃ©es intÃ©grÃ©es, telles que XML et JSON, dans les SGBD Ã  usage gÃ©nÃ©ral, sans nÃ©cessiter aucune ou refonte importante.  La controverse se dÃ©roule avec plus ou moins de succÃ¨s, et l'approche de Postgres pour Ã©tendre la structure relationnelle en utilisant des extensions pour les donnÃ©es imbriquÃ©es s'est rÃ©vÃ©lÃ©e Ã  plusieurs reprises Ãªtre un Ã©tat final naturel pour toutes les parties aprÃ¨s la fin des arguments. <br><br><h3>  2.1.2.  Types et fonctions de donnÃ©es abstraites personnalisÃ©es </h3><br>  En plus de suggÃ©rer des types imbriquÃ©s, Postgres a avancÃ© l'idÃ©e d'introduire des ADT opaques et extensibles qui sont stockÃ©s dans la base de donnÃ©es mais non interprÃ©tÃ©s par le noyau.  Fondamentalement, cela a toujours fait partie du modÃ¨le relationnel de Codd: les entiers et les chaÃ®nes Ã©taient traditionnels, mais en fait le modÃ¨le relationnel englobe tout type de donnÃ©es atomiques avec des prÃ©dicats.  La tÃ¢che consistait Ã  fournir une telle flexibilitÃ© mathÃ©matique dans les logiciels.  Pour utiliser des requÃªtes qui interprÃ¨tent ces objets et les manipulent, un programmeur d'application doit Ãªtre en mesure d'enregistrer des fonctions dÃ©finies par l'utilisateur (UDF) pour ces types dans le systÃ¨me et d'appeler ces fonctions dans des requÃªtes.  Il est Ã©galement souhaitable que les fonctions d'agrÃ©gation dÃ©finies par l'utilisateur (UDA) rÃ©sument les collections de ces objets dans les requÃªtes.  Le systÃ¨me de base de donnÃ©es Postgres a Ã©tÃ© innovant et prend en charge ces fonctionnalitÃ©s de maniÃ¨re complÃ¨te. <br><br>  Pourquoi mettre une telle fonctionnalitÃ© dans un SGBD, plutÃ´t que dans des applications de haut niveau?  La rÃ©ponse typique Ã  cette question Ã©tait un avantage significatif dans la performance du code placÃ© sur les donnÃ©es par rapport Ã  la Â«tractionÂ» des donnÃ©es vers le code.  Postgres a montrÃ© que cela est tout Ã  fait naturel dans le cadre d'un environnement relationnel: seules des modifications mineures ont Ã©tÃ© nÃ©cessaires dans le catalogue de mÃ©tadonnÃ©es relationnelles et des mÃ©canismes d'appel de code tiers ont Ã©tÃ© crÃ©Ã©s, mais la syntaxe de requÃªte, la sÃ©mantique et l'architecture du systÃ¨me ont fonctionnÃ© de maniÃ¨re simple et Ã©lÃ©gante. <br><br>  Postgres est un peu en avance sur son temps pour explorer cette fonctionnalitÃ©.  En particulier, Ã  cette Ã©poque, la communautÃ© des chercheurs en bases de donnÃ©es n'Ã©tait pas particuliÃ¨rement inquiÃ¨te des implications sÃ©curitaires du tÃ©lÃ©chargement de code non sÃ©curisÃ© sur le serveur.  Cela a commencÃ© Ã  Ãªtre perÃ§u comme un problÃ¨me lorsque la technologie a Ã©tÃ© remarquÃ©e dans l'industrie.  Stonebreaker a mis Postgres sur le marchÃ© dans sa startup Illustra, qu'Informix a acquise dans une large mesure pour sa capacitÃ© Ã  prendre en charge les packages d'extension DataBlade, y compris UDF.  Informix, avec sa technologie basÃ©e sur Postgres et ses solides offres de bases de donnÃ©es parallÃ¨les, est devenu une menace importante pour Oracle.  Oracle a investi massivement dans la commercialisation nÃ©gative des risques associÃ©s Ã  la capacitÃ© d'Informix Ã  exÃ©cuter du code C utilisateur Â«non sÃ©curisÃ©Â».  Certains attribuent la mort d'Informix Ã  cette campagne, bien que la fraude financiÃ¨re d'Informix (et les poursuites fÃ©dÃ©rales ultÃ©rieures contre son PDG d'alors) aient certainement posÃ© des problÃ¨mes plus graves.  Maintenant, des dÃ©cennies plus tard, tous les principaux fournisseurs de bases de donnÃ©es prennent en charge des fonctions personnalisÃ©es dans une ou plusieurs langues, en utilisant de nouvelles technologies pour se protÃ©ger contre les pannes de serveur ou la corruption de donnÃ©es. <br><br>  Pendant ce temps, les piles technologiques des mÃ©gadonnÃ©es des annÃ©es 2000, y compris le phÃ©nomÃ¨ne MapReduce, qui a Â«gÃ¢tÃ© beaucoup de sangÂ» par Stonebreaker et David DeWitt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DS08</a> ], sont une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rÃ©implÃ©mentation</a> de l'idÃ©e de Postgres - code utilisateur publiÃ© dans le cadre de la demande.  Il semble que MapReduce combine en grande partie les idÃ©es de dÃ©veloppement de logiciels Postgres avec des idÃ©es de concurrence de systÃ¨mes tels que Gamma et Teradata, avec quelques innovations mineures autour du redÃ©marrage du processus de requÃªte pour les charges de travail avec une Ã©volutivitÃ© extrÃªme.  Les startups basÃ©es sur Postgres, Greenplum et Aster, vers 2007, ont montrÃ© que la parallÃ©lisation de Postgres pouvait conduire Ã  quelque chose de beaucoup plus fonctionnel et pratique que MapReduce pour la plupart des clients, mais en 2008, le marchÃ© n'Ã©tait toujours pas prÃªt pour cette technologie. .  Ã€ l'heure actuelle, en 2018, presque chaque pile de Big Data gÃ¨re essentiellement la charge de travail SQL parallÃ¨le avec UDF, ce qui est trÃ¨s similaire Ã  la conception que Stonebreaker et l'Ã©quipe ont utilisÃ©e pour la premiÃ¨re fois dans Postgres. <br><br><h3>  2.1.3.  MÃ©thodes d'accÃ¨s extensibles pour les nouveaux types de donnÃ©es </h3><br>  Les bases de donnÃ©es relationnelles se sont dÃ©veloppÃ©es Ã  peu prÃ¨s au mÃªme moment que les arbres B au dÃ©but des annÃ©es 1970, et les arbres B ont contribuÃ© Ã  donner Ã  Codd un rÃªve Â«d'indÃ©pendance par rapport au stockage de donnÃ©es physiquesÂ»: l'indexation avec les arbres B fournit un niveau d'indirection qui RÃ©organise le stockage physique de maniÃ¨re adaptative sans nÃ©cessiter de modifications d'application.  La principale limitation des arbres B et de leurs structures associÃ©es est qu'ils ne prennent en charge la recherche et les requÃªtes d'Ã©galitÃ© que dans la plage unidimensionnelle.  Mais que faire si vous avez des requÃªtes de plage bidimensionnelles typiques des applications de cartographie et de CAO?  Ce problÃ¨me Ã©tait connu lors de Postgres, et l'arbre R [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gut84</a> ], dÃ©veloppÃ© par Antonin Guttman dans le groupe Stonebreaker, Ã©tait l'un des nouveaux index les plus rÃ©ussis conÃ§us pour rÃ©soudre ce problÃ¨me dans la pratique.  Cependant, l'invention de la structure d'index ne rÃ©sout pas le problÃ¨me de la prise en charge de plages multidimensionnelles dans un SGBD pour des systÃ¨mes complexes.  Il y a beaucoup de questions.  Pouvez-vous facilement ajouter une mÃ©thode d'accÃ¨s, telle que des arborescences R, Ã  votre SGBD?  Pouvez-vous apprendre Ã  l'optimiseur Ã  comprendre que la mÃ©thode d'accÃ¨s spÃ©cifiÃ©e sera utile pour certaines requÃªtes?  Pouvez-vous obtenir une rÃ©cupÃ©ration correcte et un accÃ¨s simultanÃ©?  C'Ã©tait un point trÃ¨s audacieux dans le plan d'action de Postgres: un problÃ¨me d'architecture logicielle affectant la plupart du moteur de base de donnÃ©es, de l'optimiseur au niveau de stockage, ainsi que le systÃ¨me de journalisation et de rÃ©cupÃ©ration.  Les arbres R de Postgres sont devenus une force motrice puissante et un excellent exemple de l'extensibilitÃ© Ã©lÃ©gante de la couche de mÃ©thode d'accÃ¨s et de son intÃ©gration dans l'optimiseur de requÃªtes.  Postgres a montrÃ©, Ã  l'aide d'un ADT opaque, comment enregistrer une mÃ©thode d'accÃ¨s dÃ©crite de maniÃ¨re abstraite (dans ce cas, un arbre R), et comment un optimiseur de requÃªte peut reconnaÃ®tre un prÃ©dicat de sÃ©lection abstrait (dans ce cas, un choix de plage) et le faire correspondre avec cette mÃ©thode d'accÃ¨s dÃ©crite de maniÃ¨re abstraite.  Une attention moindre a Ã©tÃ© accordÃ©e au contrÃ´le d'accÃ¨s simultanÃ© dans les travaux initiaux: le manque de classement unidimensionnel des clÃ©s a rendu la serrure utilisÃ©e dans les arbres B dans ce cas inapplicable. <br><br>  <em>Les caractÃ©ristiques prometteuses des mÃ©thodes d'accÃ¨s extensibles de Postgres ont inspirÃ© l'un de mes premiers projets de recherche Ã  la fin des Ã©tudes supÃ©rieures: Generalized Search Trees - GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HNP95</a> ] et le concept ultÃ©rieur de thÃ©orie de l'indexation [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HKM <sup>+</sup> 02</a> ].</em>  <em>J'ai implÃ©mentÃ© GiST dans Postgres pendant un semestre aprÃ¨s avoir terminÃ© mon doctorat, ce qui a rendu l'ajout de la nouvelle logique d'indexation Ã  Postgres encore plus facile.</em>  <em>La thÃ¨se de Marcel Kornacker de Berkeley (Marcel Kornacker) a rÃ©solu les problÃ¨mes complexes de rÃ©cupÃ©ration et d'accÃ¨s simultanÃ©, posÃ©s par le type d'index extensible "modÃ¨le" GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KMH97</a> ].</em> <br><br>  Aujourd'hui, PostgreSQL combine avantageusement l'architecture logicielle originale des mÃ©thodes d'accÃ¨s extensibles (il a des index B-tree, GiST, SP-GiST et Gin) avec l'extensibilitÃ© et l'accÃ¨s concurrentiel intense de l'interface d'arbre de recherche gÃ©nÃ©ralisÃ©e (GiST).  Les index GiST prennent en charge le populaire systÃ¨me de gÃ©o-information PostGIS basÃ© sur PostgreSQL.  Les index Gin fournissent une prise en charge de l'indexation de texte interne dans PostgreSQL. <br><br><h3>  2.1.4.  Optimiseur de requÃªte avec UDF coÃ»teux </h3><br>  Dans l'optimisation de requÃªte traditionnelle, la tÃ¢che consistait Ã  minimiser la quantitÃ© de flux de tuple (et donc les opÃ©rations d'E / S) crÃ©Ã©es lors du traitement de la demande.  Cela signifie que les instructions qui filtrent les tuples (extraction) sont bonnes au dÃ©but du plan de requÃªte, tandis que les instructions qui peuvent gÃ©nÃ©rer de nouveaux tuples (jointure) doivent Ãªtre exÃ©cutÃ©es plus tard.  Par consÃ©quent, les optimiseurs de requÃªtes Â«poussentÂ» les opÃ©rateurs d'extraction sous les connexions et les organisent de maniÃ¨re alÃ©atoire, en se concentrant plutÃ´t sur une optimisation intelligente des connexions et des accÃ¨s au disque.  Les FDU ont changÃ© l'approche: si vous avez des FDU coÃ»teuses dans vos exemples d'instructions, l'ordre d'exÃ©cution des FDU peut Ãªtre critique pour optimiser les performances.  De plus, si l'UDF dans l'opÃ©rateur de sÃ©lection prend vraiment beaucoup de temps, il est possible que la sÃ©lection soit effectuÃ©e aprÃ¨s les connexions (c'est-Ã -dire que la sÃ©lection doit Ãªtre Â«pull upÂ» - sÃ©lection Â«pullupÂ»).  La prise en compte de ces facteurs a compliquÃ© l'espace de recherche de l'optimiseur.  J'ai pris ce problÃ¨me comme la premiÃ¨re tÃ¢che difficile Ã  l'Ã©cole supÃ©rieure, et il a fini par faire l'objet de mon travail de maÃ®trise avec Stonebreaker Ã  Berkeley et de mon doctorat au Wisconsin sous la direction de Jeff Naughton, mais avec l'aide constante des conseils de Stonebreaker.  Postgres a Ã©tÃ© le premier SGBD Ã  stocker le coÃ»t et la sÃ©lectivitÃ© des fonctions dÃ©finies par l'utilisateur dans un rÃ©pertoire de base de donnÃ©es.  Nous avons abordÃ© le problÃ¨me d'optimisation, ayant trouvÃ© l'ordre optimal des opÃ©rations d'Ã©chantillonnage, puis l'alternance optimale des opÃ©rations d'Ã©chantillonnage le long des branches de chaque arbre de connexion considÃ©rÃ© dans la recherche de plan.         System R           . <br><br> <em>    ,      ,               . ,     ,     .</em> <br><br>          PostgreSQL       ,            . ,   ,     , ,  2018       . , ,         ,      ,   ,       .    ,  Postgres    . <br><br> <em>  , ,    ,        PostgreSQL       (Neil Conway),                      Â« Â» .</em> <br><br><h2>  2.2.       </h2><br>  Postgres                   .       :  ,      Â«  Â»,     1990- . <br><br>              .  â€”         Datalog.   Â«  Â»  : , ,                . <br><br> <em>Datalog                ,  -   . Datalog â€”     Â« Â»     .        ,     ,             .</em> <br><br>   ,     ,     ,             ,       .             . <br><br>             (Eric Hanson),     Ingres,       Postgres.         (Spyros Potamianos)  PRS2: Postgres Rules System 2.           .    â€”     .      ,      Ingres.      Â«   Â»   Â«       Â». ,   Â«      Â»     Â«    10%Â».     ,     Â«   Â»,           .         (     ),    . <br><br> <em>      PRS2 ,   , .     Postgres       (,  )    Postgres  3.1  1991  (  ):</em> <br><br><pre> <em><font></font>
*        :<font></font>
*     .        <font></font>
*  (. .        <font></font>
* "" )    .   -  <font></font>
*   () .        .<font></font>
*   .    .     <font></font>
*   .  ...<font></font>
* ,  , ? ,    ,  .<font></font>
*         , <font></font>
*  ...</em> </pre><br>       Postgres    ,          Â«Â» â€”      .            PostgreSQL,     -           . <br><br>   Postgres          Â«  Â»     IBM Starburst  MCC HiPAC.      SQL        .      .      ,  ,   ,      ,    Â«  Â»:        ,      .  ,   -       ,    ,    ,  ,   .       ,     ,      ,         ,     Postgres. <br><br><h2>  2.3. X      </h2><br>       Postgres  : <br><blockquote>    Postgres,      - .            (write-ahead log â€” WAL),   ,     .  ,   Ingres 1970-     ,         . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SK91</a> ] <br></blockquote>   ,    ,       .               ,    IBM  Tandem    .           :      -  ,   ,      ,    . <br><br> X Postgres             .       ,           ,   , â€”     Â«  Â»  Â«  Â»      .   ,  , â€”         .     ,    Â«Â»       .      :                ,      .     Postgres,   ,           ,             ,      [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto87</a> ].    Postgres   . <br><br>    Â« Â»           ,      ,        .                    .  ,        ,      ,        ,      Postgres.     Postgres      .         PostgreSQL      . <br><br> <em> , PostgreSQL       :        .   ,  PostgreSQL    ,      Postgres,   ,       Postgres  .    ,      (snapshot isolation) Oracle       -,             .</em> <br><br> <em>  (Mike Olson) ,       ,    B- Postgres    B-   Berkeley DB,       Postgres.         .    Berkeley DB     Sleepycat Corp.,    ()  PostgreSQL       Â« Â».  :    ,        (MVCC),       ,   .</em> <br><br> <em>   PostgreSQL     .  Greenplum  PostgreSQL        .      (Matt McCline)â€”    (Jim Gray)   Tandem.      .</em> <br><br>         .  ,                   NoSQL (  ,   WAL),        (MMDB â€” main memory databases,        ).              ,            .  ,             . <br><br><h2>  2.4.           </h2><br>  Au milieu du projet Postgres, Stonebreaker s'est inscrit comme l'un des cadres pour une grande subvention numÃ©rique de science des terres appelÃ©e Project Sequoia.  Une partie de la proposition de subvention portait sur le traitement de quantitÃ©s sans prÃ©cÃ©dent d'images numÃ©riques par satellite, nÃ©cessitant jusqu'Ã  100 tÃ©raoctets de mÃ©moire, c'est-Ã -dire une quantitÃ© de donnÃ©es beaucoup plus importante qu'il ne serait sage de stocker sur des disques magnÃ©tiques Ã  l'Ã©poque.  La base de la solution proposÃ©e Ã©tait d'Ã©tudier l'idÃ©e de crÃ©er un SGBD (Ã  savoir Postgres), qui facilite l'accÃ¨s au stockage Â«tertiaireÂ» semi-autonome fourni par les lecteurs robotiques avec remplacement automatique du disque pour gÃ©rer les disques optiques ou les bibliothÃ¨ques de bandes. <br><br>  Cela a conduit Ã  plusieurs Ã©tudes diffÃ©rentes.  L'un d'eux Ã©tait le systÃ¨me de fichiers Inversion - une tentative de fournir une abstraction du systÃ¨me de fichiers UNIX sur un SGBD relationnel.  Dans un article de synthÃ¨se pour Sequoia, Stonebreaker l'a dÃ©crit dans son style habituel de Â«simple exerciceÂ» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">condescendant</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto95</a> ].  En fait, Mike Olson, Ã©tudiant Ã  Stonebreaker (et fondateur de Cloudera par la suite), s'occupe de cela depuis plusieurs annÃ©es, et le rÃ©sultat final n'a pas Ã©tÃ© trÃ¨s simple [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ols93</a> ] et n'a pas survÃ©cu dans la pratique. <br><br>  <em>Quelques annÃ©es plus tard, Inversion Bill Gates Â«a combattu les mÃªmes moulins Ã  ventÂ» dans WinFS - une tentative de recrÃ©er le systÃ¨me de fichiers le plus utilisÃ© au monde sur l'arriÃ¨re d'une base de donnÃ©es relationnelle.</em>  <em>WinFS a Ã©tÃ© livrÃ© dans les versions de dÃ©veloppement de Windows, mais n'est jamais entrÃ© sur le marchÃ©.</em>  <em>Gates l'a appelÃ© plus tard sa plus grande dÃ©ception chez Microsoft.</em> <br><br>  Un autre domaine de recherche principal sur ce front a Ã©tÃ© l'inclusion d'un rÃ©fÃ©rentiel tertiaire sur la pile de bases de donnÃ©es relationnelles plus typiques, qui a fait l'objet d'une thÃ¨se de doctorat de Sunita Sarawagi.  Le sujet principal Ã©tait de changer l'Ã©chelle dans laquelle vous envisagez de gÃ©rer l'espace (c'est-Ã -dire les donnÃ©es stockÃ©es et la hiÃ©rarchie de la mÃ©moire) et le temps (coordonner la planification des requÃªtes et le cache pour minimiser les E / S indÃ©sirables).  L'un des principaux problÃ¨mes de ce travail Ã©tait de stocker de grands tableaux multidimensionnels dans un stockage tertiaire et de les rÃ©cupÃ©rer, ce qui fait Ã©cho aux travaux dans le domaine de l'indexation multidimensionnelle.  Les idÃ©es clÃ©s comprenaient la division du tableau en parties et le stockage ensemble des parties sÃ©lectionnÃ©es ensemble, ainsi que la rÃ©plication des parties afin que la partie de donnÃ©es puisse avoir plusieurs Â«voisinsÂ» physiques.  Le deuxiÃ¨me problÃ¨me est de rÃ©flÃ©chir Ã  la faÃ§on dont le disque devient un cache pour le stockage tertiaire.  Enfin, l'optimisation et la planification des requÃªtes doivent tenir compte du temps de chargement long des donnÃ©es du stockage tertiaire et de l'importance des hits (hits) du cache disque.  Cela affecte Ã  la fois le plan choisi par l'optimiseur de requÃªtes et le temps nÃ©cessaire pour terminer le plan. <br><br>  Les robots sur bandes et disques optiques ne sont actuellement pas largement utilisÃ©s.  Mais les problÃ¨mes de stockage tertiaire sont trÃ¨s courants dans le cloud, qui en 2018 a une hiÃ©rarchie de stockage profonde: des SSD attachÃ©s aux services de stockage fiables de type disque (par exemple, AWS EBS), au stockage d'archives (par exemple, dans AWS S3), au stockage profond (par exemple , AWS Glacier).  Aujourd'hui, ces niveaux de stockage sont encore relativement sÃ©parÃ©s, et le raisonnement sur le stockage de bout en bout englobant ces niveaux n'est pratiquement pas pris en charge par la base de donnÃ©es.  Je ne serais pas surpris que les questions examinÃ©es Ã  ce sujet dans Postgres soient rÃ©examinÃ©es prochainement. <br><br><h2>  2.5.  Prise en charge multiprocesseur: XPRS </h2><br>  Stonebreaker n'a jamais crÃ©Ã© un grand systÃ¨me de base de donnÃ©es parallÃ¨le, mais il a dirigÃ© de nombreuses discussions difficiles dans ce domaine.  Son article Â«Case for Shared NothingÂ» [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto86</a> ] a documentÃ© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> solutions architecturales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modulaires Ã </a> grande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ã©chelle</a> dans ce domaine.  Il a popularisÃ© la terminologie utilisÃ©e dans l'industrie et a intriguÃ© le support des architectures sans ressources partagÃ©es, telles que Gamma et Teradata, qui ont Ã©tÃ© redÃ©couvertes dans les annÃ©es 2000 par la communautÃ© du Big Data. <br><br>  Ironiquement, la contribution la plus importante de Stonebreaker dans le domaine des bases de donnÃ©es parallÃ¨les Ã©tait l'architecture de Â«mÃ©moire partagÃ©eÂ» appelÃ©e XPRS, qui signifiait Â«PostgreSQL Ã©tendu sur RAID et SpriteÂ».  Au dÃ©but des annÃ©es 1990, XPRS Ã©tait la Â«ligue de justiceÂ» pour les systÃ¨mes Berkeley: il combine le systÃ¨me abrÃ©gÃ© Postgres Stonebreaker, John Ousterhout, le systÃ¨me d'exploitation Sprite distribuÃ©, et l'architecture RAID Dave Patterson et Randy Katz RAID )  Comme pour de nombreux emplois inter-facultaires, la mise en Å“uvre du projet XPRS a en fait Ã©tÃ© dÃ©terminÃ©e par les Ã©tudiants diplÃ´mÃ©s qui y ont travaillÃ©.  Il s'est avÃ©rÃ© que la principale contribution a Ã©tÃ© apportÃ©e par Wei Hong, qui a rÃ©digÃ© sa thÃ¨se de doctorat sur l'optimisation des requÃªtes parallÃ¨les dans XPRS.  Ainsi, la principale contribution de XPRS Ã  la littÃ©rature et Ã  l'industrie a Ã©tÃ© d'optimiser les requÃªtes simultanÃ©es sans aborder de maniÃ¨re significative les problÃ¨mes associÃ©s Ã  RAID ou Sprite. <br><br>  <em>De ces trois projets, Postgres et RAID ont eu un impact Ã©norme sur l'avenir.</em>  <em>Sprite est le meilleur souvenir de la thÃ¨se de doctorat de Mendel Rosenblum sur les systÃ¨mes de fichiers structurÃ©s (LFS), qui n'avait rien Ã  voir avec les systÃ¨mes d'exploitation distribuÃ©s.</em>  <em>Les trois projets contenaient de nouvelles idÃ©es pour le stockage sur disque, en plus de modifier les copies individuelles en place.</em>  <em>LFS et le gestionnaire de rÃ©fÃ©rentiel Postgres sont assez similaires dans leur nouveau traitement de la revue comme rÃ©fÃ©rentiel principal et la nÃ©cessitÃ© d'une rÃ©organisation en arriÃ¨re-plan coÃ»teuse.</em>  <em>Une fois, j'ai soigneusement sondÃ© le Stonebreaker sur la rivalitÃ© entre LFS et Postgres ou les "faits frits" acadÃ©miques sur leur relation, mais je n'ai jamais rien appris d'intÃ©ressant de sa part.</em>  <em>Peut-Ãªtre qu'Ã  ce moment-lÃ , Ã  Berkeley, quelqu'un Â«remuait de l'eauÂ».</em> <br><br>  En principe, la concurrence Â«exploseÂ» l'espace des plans de l'optimiseur de requÃªtes, multipliant les choix traditionnels effectuÃ©s lors de l'optimisation des requÃªtes (accÃ¨s aux donnÃ©es, algorithmes de connexion, ordre de connexion) par toutes les maniÃ¨res possibles de parallÃ©liser chaque choix.  L'idÃ©e principale de Â«l'optimiseur Wei HongÂ» appelÃ© par Stonebreaker Ã©tait de diviser le problÃ¨me en deux: lancer l'optimiseur de requÃªte traditionnel dans l'esprit du systÃ¨me R pour un nÅ“ud, puis Â«parallÃ©liserÂ» le plan rÃ©sultant, planifier le degrÃ© de parallÃ©lisme et le placement de chaque opÃ©rateur en fonction de la reprÃ©sentation configuration des donnÃ©es et du systÃ¨me.  Cette approche est heuristique, mais en elle la simultanÃ©itÃ© augmente le coÃ»t de l'optimisation de requÃªte traditionnelle de maniÃ¨re additive, plutÃ´t que multiplicative. <br><br>  Bien que l'optimiseur de Wei Hong ait Ã©tÃ© dÃ©veloppÃ© dans le contexte de Postgres, il est devenu l'approche standard pour de nombreux optimiseurs de requÃªtes simultanÃ©s dans l'industrie. <br><br><h2>  2.6.  Prise en charge de divers modÃ¨les de langue </h2><br>  Parmi les intÃ©rÃªts de Stonebreaker, renouvelÃ© Ã  plusieurs reprises depuis l'Ã©poque d'Ingres, figurait l'interface de programmation d'application (API) du systÃ¨me de base de donnÃ©es.  Dans ses confÃ©rences de la sÃ©rie Database Systems, il a souvent inclus le langage GEM Carlo Zaniolo comme un sujet qu'il est important de comprendre pour les partisans du systÃ¨me de base de donnÃ©es.  Cet intÃ©rÃªt pour le langage l'a sans aucun doute amenÃ© Ã  s'associer avec Larry Rowe dans Postgres, qui Ã  son tour a profondÃ©ment influencÃ© la conception du modÃ¨le de donnÃ©es Postgres et son approche relationnelle objet.  Leur travail Ã©tait principalement axÃ© sur les applications pour travailler avec un grand volume de donnÃ©es de la sphÃ¨re commerciale, y compris le traitement des informations commerciales et les nouvelles applications telles que CAD / CAM et GIS. <br><br>  L'un des problÃ¨mes qui a Ã©tÃ© imposÃ© Ã  Stonebreaker Ã  l'Ã©poque Ã©tait l'idÃ©e de Â«cacherÂ» les frontiÃ¨res entre les constructions du langage de programmation et le rÃ©fÃ©rentiel de base de donnÃ©es.  Divers projets de recherche et entreprises concurrentes qui recherchent des bases de donnÃ©es orientÃ©es objet (OODB) ont ciblÃ© la soi-disant Â«perte de conformitÃ©Â» entre les langages de programmation orientÃ©s objet impÃ©ratifs tels que Smalltalk, C ++ et Java, et les relations dÃ©claratives modÃ¨le.  L'idÃ©e d'OODB Ã©tait de rendre les objets du langage de programmation, si dÃ©sirÃ©, marquÃ©s comme Â«permanentsÂ» et automatiquement traitÃ©s par le SGBD intÃ©grÃ©.  Postgres a pris en charge le stockage d'objets imbriquÃ©s et de types de donnÃ©es abstraits, mais son interface, basÃ©e sur des requÃªtes dÃ©claratives dans un style relationnel, a supposÃ© un accÃ¨s non naturel Ã  la base de donnÃ©es pour le programmeur (cela nÃ©cessitait l'utilisation de requÃªtes dÃ©claratives), qui Ã©taient Ã©galement coÃ»teuses (nÃ©cessitant une analyse et optimisation).  Pour concurrencer les fournisseurs OODB, Postgres a fourni la soi-disant interface Fast Path: essentiellement l'API C / C ++ pour le stockage de base de donnÃ©es interne.  Cela a permis Ã  Postgres d'avoir des performances de rÃ©fÃ©rence acadÃ©miques OODB moyennes, mais cela n'a jamais rÃ©solu le problÃ¨me de laisser les programmeurs dans diffÃ©rentes langues Ã©viter le problÃ¨me de la perte de conformitÃ©.  Au lieu de cela, Stonebreaker a qualifiÃ© Postgres de label Â«objet-relationnelÂ» et a simplement contournÃ© l'utilisation de bases de donnÃ©es orientÃ©es objet en tant que marchÃ© Ã  zÃ©ro milliard de dollars.  Aujourd'hui, presque tous les systÃ¨mes de bases de donnÃ©es relationnelles commerciales sont des systÃ¨mes de bases de donnÃ©es Â«relationnels-objetsÂ». <br><br>  Cela s'est avÃ©rÃ© Ãªtre une solution raisonnable.  Aujourd'hui, aucun des produits OODB n'existe sous sa forme prÃ©vue, et l'idÃ©e d '"objets persistants" dans les langages de programmation a Ã©tÃ© largement Ã©cartÃ©e.  En revanche, l'utilisation de couches de cartographie relationnelle objet (ORM) est trÃ¨s rÃ©pandue, alimentÃ©e par des travaux antÃ©rieurs, tels que Java Hibernate et Ruby on Rails, qui permettent Â«d'adapterÂ» les bases de donnÃ©es dÃ©claratives Ã  presque tous les objets impÃ©ratifs de maniÃ¨re relativement fluide. langage de programmation orientÃ© comme bibliothÃ¨ques.  Cette approche au niveau de l'application diffÃ¨re des bases de donnÃ©es relationnelles objet OODB et Stonebreaker.  En outre, des stockages de valeurs-clÃ©s lÃ©gers sont Ã©galement utilisÃ©s avec succÃ¨s sous des formes non transactionnelles et transactionnelles.  Leur dÃ©couvreur Ã©tait l'Ã©tudiant diplÃ´mÃ© de Stonebreaker Margo Seltzer, qui a travaillÃ© sur la base de donnÃ©es Berkeley DB dans le cadre de sa thÃ¨se de doctorat en mÃªme temps que le groupe Postgres, qui prÃ©voyait la croissance des rÃ©fÃ©rentiels de valeurs-clÃ©s NoSQL distribuÃ©s tels que Dynamo , MongoDB et Cassandra. <br><br><h1>  3. Impact sur les logiciels </h1><br><h2>  3.1.  Open source </h2><br>  Postgres a toujours Ã©tÃ© un projet open source avec des versions cohÃ©rentes, mais au dÃ©but, il Ã©tait destinÃ© Ã  Ãªtre utilisÃ© pour la recherche plutÃ´t que pour la production. <br><br>  Comme le projet de recherche Postgres a Ã©tÃ© interrompu, deux Ã©tudiants de Stonebreaker, Andrew Yu et Jolly Chen, ont modifiÃ© l'analyseur systÃ¨me pour remplacer le langage Postquel original par une variante SQL extensible.  La premiÃ¨re version de Postgres prenant en charge SQL Ã©tait Postgres95, et la suivante s'appelait PostgreSQL. <br><br>  Une Ã©quipe de dÃ©veloppement open source s'est intÃ©ressÃ©e Ã  PostgreSQL et l'a Â«acceptÃ©eÂ» mÃªme si les intÃ©rÃªts du reste de l'Ã©quipe de Berkeley ont changÃ©.  L'Ã©quipe centrale de PostgreSQL est restÃ©e relativement stable au fil du temps et le projet open source est devenu trÃ¨s dÃ©veloppÃ©.  Initialement, les efforts Ã©taient concentrÃ©s sur la stabilitÃ© du code et des fonctionnalitÃ©s visibles par l'utilisateur, mais au fil du temps, la communautÃ© des logiciels open source a considÃ©rablement changÃ© et amÃ©liorÃ© le cÅ“ur du systÃ¨me, de l'optimiseur aux mÃ©thodes d'accÃ¨s et au principal systÃ¨me de transaction et de stockage.  Depuis le milieu des annÃ©es 1990, une trÃ¨s petite fraction des composants internes de PostgreSQL provenait de l'Ã©quipe acadÃ©mique de Berkeley.  Sa derniÃ¨re contribution a peut-Ãªtre Ã©tÃ© ma mise en Å“uvre de GiST dans la seconde moitiÃ© des annÃ©es 1990, mais mÃªme elle a Ã©tÃ© substantiellement rÃ©Ã©crite et approuvÃ©e par des bÃ©nÃ©voles de la communautÃ© open source (dans ce cas, la Russie).  La partie de la communautÃ© open source qui travaille sur PostgreSQL mÃ©rite les plus grands Ã©loges pour son processus rationalisÃ©, qui pendant des dÃ©cennies a servi Ã  crÃ©er un projet trÃ¨s efficace et Ã  long terme. <br><br>  Bien que beaucoup de choses aient changÃ© au cours des 25 derniÃ¨res annÃ©es, l'architecture sous-jacente de PostgreSQL reste trÃ¨s similaire aux versions universitaires de Postgres au dÃ©but des annÃ©es 1990, et les dÃ©veloppeurs familiarisÃ©s avec le code source actuel de PostgreSQL trouveront facile de lire le code source de Postgres 3.1 (1991).  Tout, de la structure du rÃ©pertoire du code source aux structures de processus et aux structures de donnÃ©es, reste Ã©tonnamment similaire.  Le code de l'Ã©quipe Postgres Ã  Berkeley avait une grande colonne vertÃ©brale. <br><br>  Aujourd'hui, PostgreSQL est sans aucun doute le systÃ¨me de gestion de base de donnÃ©es open source le plus performant, et il prend en charge des fonctionnalitÃ©s que l'on ne trouve souvent pas dans les produits commerciaux.  Il s'agit Ã©galement (selon un site de notation influent) du SGBD indÃ©pendant open source le plus populaire au monde, et son influence ne cesse de croÃ®tre: en 2017 et 2018, il s'agissait de la base de donnÃ©es ayant la popularitÃ© la plus rapide au monde [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DE19c</a> ].  PostgreSQL est utilisÃ© dans une grande variÃ©tÃ© d'industries et de tÃ¢ches, ce qui n'est pas surprenant, Ã©tant donnÃ© sa concentration sur de nombreuses opportunitÃ©s. <br><br>  <em>Selon DB-Engines, PostgreSQL est aujourd'hui la quatriÃ¨me base de donnÃ©es la plus populaire au monde, aprÃ¨s Oracle, MySQL et MS SQL Server, tous trois proposÃ©s par des sociÃ©tÃ©s spÃ©cifiques (MySQL a Ã©tÃ© acquis par Oracle il y a de nombreuses annÃ©es) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DE19a</a> ].</em>  <em>Les rÃ¨gles de classement sont discutÃ©es dans la description de la mÃ©thodologie de classement DB-Engines [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DE19b</a> ].</em> <br><br>  Heroku est le fournisseur de cloud SaaS qui fait dÃ©sormais partie de Salesforce.  Postgres a Ã©tÃ© introduit dans Heroku en 2010 comme base de donnÃ©es par dÃ©faut pour sa plate-forme.  Heroku a choisi Postgres pour sa fiabilitÃ©.  Avec la prise en charge de Heroku, de plus grandes plates-formes de dÃ©veloppement d'applications telles que Ruby on Rails et Python pour Django ont commencÃ© Ã  recommander Postgres comme base de donnÃ©es par dÃ©faut. <br><br>  Aujourd'hui, PostgreSQL prend en charge une infrastructure d'extension qui facilite l'ajout de fonctionnalitÃ©s supplÃ©mentaires au systÃ¨me via des fonctions dÃ©finies par l'utilisateur et les modifications associÃ©es.  Il existe maintenant un Ã©cosystÃ¨me d'extensions PostgreSQL, semblable au concept llustra des packages d'extension DataBlade, mais avec du code open source.  Les extensions les plus intÃ©ressantes incluent, par exemple, la bibliothÃ¨que Apache MADlib pour l'apprentissage automatique dans l'interface SQL et la bibliothÃ¨que Citus pour l'exÃ©cution de requÃªtes parallÃ¨les. <br><br>  L'une des applications open source les plus intÃ©ressantes reposant sur Postgres est le systÃ¨me d'information gÃ©ographique PostGIS, qui utilise de nombreuses fonctionnalitÃ©s Postgres qui ont inspirÃ© Stonebreaker Ã  l'origine pour dÃ©marrer le projet. <br><br><h2>  3.2.  Mise en Å“uvre commerciale </h2><br>  PostgreSQL est depuis longtemps un point de dÃ©part attrayant pour la crÃ©ation de systÃ¨mes de bases de donnÃ©es commerciales, Ã©tant donnÃ© son utilisation sous la licence logicielle open source Â«tout autorisÃ©eÂ», son code fiable, sa flexibilitÃ© et ses nombreuses fonctionnalitÃ©s.  En rÃ©sumant les coÃ»ts d'acquisition Ã©numÃ©rÃ©s ci-dessous, nous constatons que Postgres a reÃ§u plus de 2,6 milliards de dollars en coÃ»ts d'acquisition. <br><br>  <em>Veuillez noter qu'il s'agit d'une mesure en dollars de transactions financiÃ¨res rÃ©elles et est beaucoup plus importante que les valeurs qui sont souvent utilisÃ©es en haute technologie.</em>  <em>Les chiffres en milliards sont souvent utilisÃ©s pour dÃ©crire la valeur estimÃ©e des blocs d'actions, mais sont souvent surestimÃ©s de 10 fois ou plus par rapport Ã  la valeur actuelle dans l'espoir de son importance future.</em>  <em>Les dollars de transaction d'acquisition de la sociÃ©tÃ© mesurent sa valeur marchande rÃ©elle au moment de l'acquisition.</em>  <em>Il est juste de dire que Postgres a crÃ©Ã© plus de 2,6 milliards de dollars de valeur commerciale rÃ©elle.</em> <br><br>  De nombreux efforts commerciaux associÃ©s Ã  PostgreSQL se sont concentrÃ©s sur ce qui est probablement sa principale limitation: la capacitÃ© d'Ã©voluer vers une architecture parallÃ¨le sans partager les ressources. <br><br>  <em>La parallÃ©lisation de PostgreSQL nÃ©cessite beaucoup de travail, mais est hautement rÃ©alisable par une petite Ã©quipe expÃ©rimentÃ©e.</em>  <em>Aujourd'hui, les branches de l'industrie open source PostgreSQL telles que Greenplum et CitusDB offrent une telle opportunitÃ©.</em>  <em>Il est regrettable que PostgreSQL n'ait pas Ã©tÃ© correctement parallÃ©lisÃ© en open source beaucoup plus tÃ´t.</em>  <em>Si PostgreSQL avait Ã©tÃ© dÃ©veloppÃ© dans l'open source avec le support d'une architecture sans partage de ressources au dÃ©but des annÃ©es 2000, il est possible que la direction du big data open source se soit dÃ©veloppÃ©e d'une maniÃ¨re complÃ¨tement diffÃ©rente et plus efficace.</em> <br><br><ol><li>  Illustra Ã©tait la deuxiÃ¨me plus grande startup de Stonebreaker, fondÃ©e en 1992 pour commercialiser Postgres, lorsque RTI a lancÃ© Ingres sur le marchÃ©. <br><br>  <em>Illustra Ã©tait en fait le troisiÃ¨me nom proposÃ© pour l'entreprise.</em>  <em>Poursuivant le thÃ¨me de la peinture, Ã©tant donnÃ© le nom d'Ingres, Illustra s'appelait Ã  l'origine Miro.</em>  <em>En raison de problÃ¨mes de marque, le nom a Ã©tÃ© changÃ© pour Montage, mais il a Ã©galement rencontrÃ© des problÃ¨mes de marque.</em> <br><br>  L'Ã©quipe fondatrice comprenait une partie du noyau de l'Ã©quipe Postgres, y compris Wei Hong, rÃ©cemment diplÃ´mÃ© de l'Ã©cole supÃ©rieure et Jeff Meredith, alors programmeur senior, ainsi que des diplÃ´mÃ©s d'Ingres Paula Hawthorn et Michael Ubell.  Mike Olson, Ã©tudiant diplÃ´mÃ© de Postgres, a rejoint l'Ã©quipe peu de temps aprÃ¨s sa fondation et j'ai travaillÃ© chez Illustra pour optimiser des fonctionnalitÃ©s coÃ»teuses dans le cadre de mon doctorat.  Illustra    :  SQL92      ,    Postquel,    Postgres               DataBlade â€”       . Illustra   Informix  1997     400 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mon96</a> ],    DataBlade         Informix  Informix Universal Server. <br></li><li> Netezza  ,   1999 ,    PostgreSQL             FPGA. Netezza     ,        2007 .       IBM  1,7 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBM10</a> ]. <br></li><li> Greenplum         PostgreSQL   .   2003 , Greenplum     PostgreSQL,      API PostgreSQL,  API   .    , Greenplum  PostgreSQL         ,   ,   Orca. Greenplum   EMC  2010   300 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mal10</a> ],   2012  EMC  Greenplum     Pivotal.  2015  Pivotal    Greenplum  Orca    .    Greenplum   Postgres API   MADlib     SQL [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HRS+12</a> ]. MADlib     Apache.        ,   Greenplum,  Apache HAWQ,   Pivotal,   Â« Â» Greenplum (. .         PostgreSQL)    ,     Hadoop. <br></li><li> EnterpriseDB    2004   ,          PostgreSQL   ,             .    EnterpriseDB Advanced Server      Oracle,     Oracle. <br></li><li>  Aster Data    2005    ,      .        PostgreSQL. Aster             ,        SQL  MapReduce. Aster Data    Teradata  2011   263 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sho11</a> ].  Teradata    Aster       ,  -  Aster             Teradata. <br></li><li>  ParAccel    2006 ,    PostgreSQL      . ParAccel   Postgres        .  2011  Amazon   ParAccel,   2012   AWS Redshift â€”             ParAccel.  2013  ParAccel    Actian (   Ingres)    ,  ,        Actian.    AWS Redshift     Amazon â€”            Amazon,   ,            ,   Teradata  Oracle Exadata.    Postgres       . <br></li><li>  CitusDB <em>(CitusDB â€”  ;   Citus Data. â€” . .)</em>    2010 ,     PostgreSQL   .      PostgreSQL,  2016  CitusDB    API  PostgreSQL        PostgreSQL.  2016   CitusDB     . <br></li></ol><br><h1> 4.  </h1><br>        Postgres,       . <br><br>   ,   ,   ,  Postgres   Â«  Â» (Second System Effect)    (Fred Brooks) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bro75</a> ].  ,          ,    -    . Postgres    ,  , ,     .      ,     ,       .     â€”    Postgres     ,      .               :     ,    .  , Â« Â»  .    ,    ,      .       Â«-Â»    ,      Â«-Â»    . <br><br>     ,    , Â«   Â»,       ,    .     <em>( 2001           (). â€” . .)</em>          2000-   Â«    Â».          ,         Postgres. ,            ,       . <br><br> <em>   (Ralph Waldo Emerson), Â«  â€”   Â».</em> <br><br> ,     Â«    Â» (       ),   ,      ,      , ,               .  ,           .   ,        ,       - .    ,   .          ,     . <br><br>  ,     Postgres, â€”   ,          .        Â« Â»  PostgreSQL,       ,        .  ,    : <br><blockquote>  ,  ,            ,          1995 .  Postgres,     ,     .       ,     ,            ,       . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sto14</a> ] <br></blockquote>  ,   ,     ,  ,   Â« Â»   .      Â« Â».   , ,  ,         ,       Postgres.     - ,    : Â« -      Â».   (  ),         . <br><br><h1> 5.  </h1><br>       Postgres  ,          ,     (Craig Kerstiens)      PostgreSQL. <br><br><h1>  LittÃ©rature </h1><br><ul><li><a name="Bro75"></a> [Bro75] Frederick P Brooks. The mythical man-month, 1975. </li><li><a name="Bro19"></a> [Bro19] Michael L. Brodie, editor. Making Databases Work. Morgan &amp; Claypool, 2019. </li><li><a name="DE19a"></a> [DE19a] DB-Engines. DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">db-engines.com/en/ranking</a> . (Last accessed January 4, 2019). </li><li><a name="DE19b"></a> [DE19b] DB-Engines. Method of calculating the scores of the DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019). </li><li><a name="DE19c"></a> [DE19c] DB-Engines. PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019). </li><li><a name="DS08"></a> [DS08] David DeWitt and Michael Stonebraker. Mapreduce: A major step backwards. The Database Column, 1:23, 2008. </li><li><a name="Gut84"></a> [Gut84] Antonin Guttman. R-trees: A dynamic index structure for spatial searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 47â€“57, New York, NY, USA, 1984. ACM. </li><li><a name="HKM02"></a> [HKM <sup>+</sup> 02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas. On a model of indexability and its bounds for range queries. J. ACM, 49(1):35â€“55, January 2002. </li><li><a name="HNP95"></a> [HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Proceedings of the 21th International Conference on Very Large Data Bases, VLDB '95, pages 562â€“573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc. </li><li><a name="HRS12"></a> [HRS <sup>+</sup> 12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al. The MADlib analytics library: or MAD skills, the SQL. Proceedings of the VLDB Endowment, 5(12):1700â€“1711, 2012. </li><li><a name="IBM10"></a> [IBM10] IBM to acquire Netezza, September 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018). </li><li><a name="KMH97"></a> [KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein. Concurrency and recovery in generalized search trees. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, SIGMOD '97, pages 62â€“72, New York, NY, USA, 1997. ACM. </li><li><a name="Mal10"></a> [Mal10] Om Malik. Big Data = Big Money: EMC Buys Greenplum. In GigaOm, July 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gigaom.com/2010/07/06/emc-buys-greenplum</a> . </li><li><a name="Mon96"></a> [Mon96] John Monroe. Informix acquires illustra for complex data management. In Federal Computer Week, January 1996. </li><li><a name="OFS83"></a> [OFS83] James Ong, Dennis Fogg, and Michael Stonebraker. Implementation of data abstraction in the relational database system ingres. ACM Sigmod Record, 14(1):1â€“14, 1983. </li><li><a name="Ols93"></a> [Ols93] Michael A. Olson. The design and implementation of the inversion file system. 1993. </li><li><a name="SAHR84"></a> [SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein. Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 208â€“214, New York, NY, USA, 1984. ACM. </li><li><a name="Sho11"></a> [Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018). </li><li><a name="SHWK76"></a> [SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189â€“222, 1976. </li><li><a name="SK91"></a> [SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78â€“92, October 1991. </li><li><a name="SR86"></a> [SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD '86, pages 340â€“355, New York, NY, USA, 1986. ACM. </li><li><a name="SRG83"></a> [SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983. </li><li><a name="Sto86"></a> [Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4â€“9, 1986. </li><li><a name="Sto87"></a> [Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB '87, pages 289â€“300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc. </li><li><a name="Sto95"></a> [Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39â€“49, 1995. </li><li><a name="Sto14"></a> [Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438890/">https://habr.com/ru/post/fr438890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438878/index.html">L'apparition du film en torrents aprÃ¨s la premiÃ¨re augmente le box-office de 3%</a></li>
<li><a href="../fr438880/index.html">Quand utiliser var, let et const en Javascript [traduction de l'article de Tyler McGinnis]</a></li>
<li><a href="../fr438882/index.html">La probabilitÃ© de gagner un match avec une probabilitÃ© connue de gagner un point</a></li>
<li><a href="../fr438884/index.html">Histoire vraie d'une agence de publicitÃ© de l'outback: hauts, bas et implÃ©mentation CRM</a></li>
<li><a href="../fr438886/index.html">Morty, nous sommes Ã  UltraHD! Comment regarder n'importe quel film en 4K, en le complÃ©tant via un rÃ©seau neuronal peu connu</a></li>
<li><a href="../fr438892/index.html">Qu'est-ce qu'une blockchain d'entreprise?</a></li>
<li><a href="../fr438894/index.html">Pourquoi le dÃ©veloppement Web sur Go est plus agrÃ©able que sur PHP</a></li>
<li><a href="../fr438896/index.html">Ne pleure pas</a></li>
<li><a href="../fr438898/index.html">Installation inversÃ©e et d'extension de Chrome</a></li>
<li><a href="../fr438900/index.html">En route vers les principes physiques de l'Ã©volution biologique. Fin + texte intÃ©gral de la traduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>