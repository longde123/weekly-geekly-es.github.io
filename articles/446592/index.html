<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèº üë©üèª‚Äçüî¨ üõÇ Comprobando el c√≥digo fuente de Roslyn üå∂Ô∏è üêó üïî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De vez en cuando, volvemos a proyectos que previamente probamos con PVS-Studio y escribimos art√≠culos al respecto. Hay dos razones para hacer esto. En...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprobando el c√≥digo fuente de Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446592/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio vs Roslyn"></div><br>  De vez en cuando, volvemos a proyectos que previamente probamos con PVS-Studio y escribimos art√≠culos al respecto.  Hay dos razones para hacer esto.  En primer lugar, para comprender cu√°nto mejor se ha vuelto nuestro analizador.  En segundo lugar, para rastrear si los autores del proyecto prestaron atenci√≥n a nuestro art√≠culo, as√≠ como al informe de errores que generalmente les proporcionamos.  Por supuesto, los errores pueden corregirse sin nuestra participaci√≥n.  Pero siempre es bueno cuando exactamente nuestros esfuerzos ayudan a mejorar un proyecto.  Roslyn no fue la excepci√≥n.  Un art√≠culo de revisi√≥n anterior sobre este proyecto data del 23 de diciembre de 2015.  Esto es bastante tiempo, dado el camino que nuestro analizador ha recorrido en su desarrollo durante este tiempo.  Para nosotros personalmente, Roslyn tambi√©n es de inter√©s adicional por el hecho de que el n√∫cleo del analizador C # PVS-Studio se basa en √©l.  Por lo tanto, estamos muy interesados ‚Äã‚Äãen la calidad del c√≥digo para este proyecto.  Organizaremos una segunda verificaci√≥n y descubriremos qu√© hay de nuevo e interesante (pero esperemos que nada significativo) PVS-Studio pueda encontrar all√≠. <br><a name="habracut"></a><br>  Roslyn (o la plataforma del compilador .NET) probablemente sea familiar para muchos de nuestros lectores.  En resumen, es un conjunto de compiladores de c√≥digo abierto y API para an√°lisis de c√≥digo para los lenguajes C # y Visual Basic .NET de Microsoft.  El c√≥digo fuente del proyecto est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br>  No dar√© una descripci√≥n detallada de esta plataforma, pero recomiendo a todos los interesados ‚Äã‚Äãen el art√≠culo de mi colega Sergey Vasiliev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a Roslyn. Uso de herramientas de an√°lisis est√°tico para desarrollar</a> ".  En este art√≠culo, puede aprender no solo sobre las caracter√≠sticas de la arquitectura de Roslyn, sino tambi√©n c√≥mo usamos exactamente esta plataforma. <br><br>  Como mencion√© anteriormente, han pasado m√°s de tres a√±os desde la redacci√≥n del √∫ltimo art√≠culo de mi colega Andrei Karpov sobre el cheque de Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lanzamiento de A√±o Nuevo de PVS-Studio 6.00: chequeo de Roslyn</a> ".  Durante este tiempo, el analizador C # PVS-Studio ha adquirido muchas caracter√≠sticas nuevas.  En general, el art√≠culo de Andrey era una especie de "bola de prueba", porque el analizador C # solo se agreg√≥ a PVS-Studio en ese momento.  A pesar de esto, incluso entonces, en un proyecto incondicionalmente de alta calidad, Roslyn logr√≥ encontrar errores interesantes.  ¬øQu√© ha cambiado en el analizador para el c√≥digo C # hasta ahora, lo que potencialmente permitir√° un an√°lisis m√°s profundo? <br><br>  En el pasado, tanto el n√∫cleo del analizador como la infraestructura se han desarrollado.  Se agreg√≥ soporte para Visual Studio 2017 y Roslyn 2.0, as√≠ como una profunda integraci√≥n con MSBuild.  Puede leer m√°s sobre nuestro enfoque de integraci√≥n con MSBuild y sobre los motivos que nos llevaron a aceptarlo en el art√≠culo de mi colega Pavel Yeremeyev, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte para Visual Studio 2017 y Roslyn 2.0 en PVS-Studio: a veces, usar soluciones preparadas no es tan f√°cil como parece de un vistazo</a> ". <br><br>  Ahora estamos trabajando activamente en la transici√≥n a Roslyn 3.0 de acuerdo con el mismo esquema que inicialmente admitimos Visual Studio 2017, es decir, a trav√©s de nuestro propio conjunto de herramientas, que viene con el "c√≥digo auxiliar" en el kit de distribuci√≥n PVS-Studio como un archivo MSBuild.exe vac√≠o.  A pesar de que parece una "muleta" (la API de MSBuild no es muy amigable para su reutilizaci√≥n en proyectos de terceros debido a la baja portabilidad de las bibliotecas), este enfoque ya nos ha ayudado a revivir varias actualizaciones de Roslyn sin problemas durante la vida de Visual Studio 2017. y ahora, aunque con muchas superposiciones, sobrevive a la actualizaci√≥n a Visual Studio 2019, as√≠ como tambi√©n mantiene la compatibilidad y el rendimiento anteriores en sistemas con versiones anteriores de MSBuild. <br><br>  El n√∫cleo del analizador tambi√©n ha experimentado una serie de mejoras.  Una de las principales innovaciones es un an√°lisis interprocedural completo, teniendo en cuenta los valores de entrada y salida de los m√©todos, teniendo en cuenta, dependiendo de estos par√°metros, la accesibilidad de las ramas de ejecuci√≥n y los puntos de retorno. <br><br>  La tarea de rastrear par√°metros dentro de los m√©todos ya est√° cerca de completarse, al tiempo que conserva las anotaciones autom√°ticas de lo que sucede con estos par√°metros all√≠ (por ejemplo, una desreferenciaci√≥n potencialmente peligrosa).  Esto permitir√° que cualquier diagn√≥stico que utilice el mecanismo de flujo de datos tenga en cuenta las situaciones peligrosas que se producen al pasar un par√°metro a un m√©todo.  Anteriormente, al analizar lugares tan peligrosos, no se generaba una advertencia, ya que no pod√≠amos conocer todos los valores de entrada posibles para dicho m√©todo.  Ahora podemos detectar el peligro, ya que en todos los lugares donde se llama a este m√©todo, estos par√°metros de entrada se tendr√°n en cuenta. <br><br>  Nota: puede familiarizarse con los mecanismos principales del analizador, como el flujo de datos y otros, del art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tecnolog√≠as utilizadas en el analizador de c√≥digo PVS-Studio para encontrar errores y vulnerabilidades potenciales</a> ". <br><br>  El an√°lisis interprocedural en PVS-Studio C # no est√° limitado por los par√°metros de entrada o la profundidad.  La √∫nica limitaci√≥n son los m√©todos virtuales en clases que no se cerraron por herencia y cayeron en recursi√≥n (nos detendremos cuando veamos en la pila una llamada repetida a un m√©todo ya calculado).  Adem√°s, el m√©todo recursivo en s√≠ mismo se calcular√° en √∫ltima instancia suponiendo que se desconoce el valor de retorno de su autorrecurrencia. <br><br>  Otra gran innovaci√≥n en el analizador C # es la posibilidad de desreferenciar un puntero potencialmente nulo.  Anteriormente, el analizador jur√≥ una posible excepci√≥n de referencia nula si estaba seguro de que en todas las ramas de ejecuci√≥n el valor de la variable ser√≠a nulo.  Por supuesto, a veces se equivocaba, por lo que los diagn√≥sticos del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> se llamaban anteriormente referencia nula potencial. <br><br>  Ahora el analizador recuerda que la variable podr√≠a ser nula en una de las ramas de ejecuci√≥n (por ejemplo, bajo cierta condici√≥n en if).  Si ve acceso a dicha variable sin verificar, recibir√° un mensaje V3080, pero con un nivel de importancia menor que si ve nulo en todas las ramas.  En combinaci√≥n con un an√°lisis interprocedural mejorado, dicho mecanismo permite encontrar errores muy dif√≠ciles de detectar.  Un ejemplo es una larga cadena de llamadas a m√©todos, la √∫ltima de las cuales no est√° familiarizado, y que, por ejemplo, devuelve nulo bajo ciertas circunstancias, pero no se protegi√≥ de esto porque simplemente no lo sab√≠a.  En este caso, el analizador solo jura cuando ve con precisi√≥n la asignaci√≥n de nulo.  En nuestra opini√≥n, esto distingue cualitativamente nuestro enfoque de una innovaci√≥n de C # 8.0 como el tipo de referencia anulable, que, de hecho, se reduce a establecer verificaciones nulas en cada m√©todo.  Ofrecemos una alternativa: hacer comprobaciones solo donde realmente puede existir nulo, y nuestro analizador ahora puede buscar tales situaciones. <br><br>  Entonces, sin demora, pasemos a "debriefing": analizar los resultados de la verificaci√≥n de Roslyn.  Primero, veamos los errores encontrados gracias a las innovaciones descritas anteriormente.  En general, esta vez se emitieron bastantes advertencias para el c√≥digo de Roslyn.  Creo que esto se debe al hecho de que la plataforma se est√° desarrollando de manera muy activa (la base de c√≥digo actualmente se encuentra en aproximadamente 2,770,000 l√≠neas de c√≥digo, excluyendo las vac√≠as), y no hemos hecho un an√°lisis de este proyecto durante mucho tiempo.  Sin embargo, no hay tantos errores cr√≠ticos, es decir, son de inter√©s para el art√≠culo.  Y s√≠, hay bastantes pruebas en Roslyn que, como siempre, exclu√≠ de las pruebas. <br><br>  Comenzar√© con los errores V3080, con un nivel de criticidad medio, en el que el analizador detect√≥ un posible acceso a trav√©s de un enlace cero, pero no en todos los casos posibles (ramificaciones de c√≥digo). <br><br>  <b>Posible desreferencia nula - Media</b> <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'actual'.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Considere el m√©todo <i>GetNode</i> .  El analizador considera que el acceso por referencia nula es posible en la condici√≥n del bloque <i>while</i> .  En el cuerpo del bloque <i>while</i> , a la variable <i>actual</i> se le asignar√° un valor, el resultado de la ejecuci√≥n del m√©todo <i>AsNode</i> .  Y este valor en algunos casos ser√° <i>nulo</i> .  Un buen ejemplo de an√°lisis interprocedural en acci√≥n. <br><br>  Ahora considere un caso similar en el que el an√°lisis interprocedural se realiz√≥ a trav√©s de dos llamadas a m√©todos. <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'directorio'.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  La variable de <i>directorio</i> en el cuerpo del m√©todo <i>ExpandFileNamePattern</i> obtiene el valor del m√©todo <i>GetDirectoryName (string)</i> .  Eso, a su vez, devolver√° el resultado del <i>m√©todo GetDirectoryName (string, bool)</i> sobrecargado, <i>cuyo</i> valor puede ser <i>nulo</i> .  Como m√°s adelante en el cuerpo del m√©todo <i>ExpandFileNamePattern</i> , la variable de <i>directorio</i> se usa sin verificar primero la igualdad <i>nula</i> , podemos hablar sobre la legitimidad de la advertencia por parte del analizador.  Este es un dise√±o potencialmente inseguro. <br><br>  Otra pieza de c√≥digo con el error V3080, m√°s precisamente, inmediatamente con dos errores emitidos para una l√≠nea de c√≥digo.  Aqu√≠, el an√°lisis interprocedural no era necesario. <br><br>  V3080 Posible desreferencia nula.  Considere la posibilidad de inspeccionar 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Las <i>variables</i> <i>spanStartLocation</i> y <i>spanEndLocationExclusive</i> son de tipo <i>nullable int</i> y se inicializan en <i>nulo</i> .  Adem√°s en el c√≥digo se les pueden asignar valores, pero solo si se cumplen ciertas condiciones.  En algunos casos, su valor seguir√° siendo igual a <i>nulo</i> .  Adem√°s en el c√≥digo, se accede a estas variables por referencia sin verificar primero la igualdad <i>nula</i> , como lo indica el analizador. <br><br>  El c√≥digo de Roslyn contiene bastantes errores de este tipo, m√°s de 100. A menudo, el patr√≥n de estos errores es el mismo.  Hay alg√∫n m√©todo general que potencialmente devuelve <i>nulo</i> .  El resultado de este m√©todo se utiliza en una gran cantidad de lugares, a veces a trav√©s de docenas de llamadas a m√©todos intermedios o verificaciones adicionales.  Es importante comprender que estos errores no son fatales, pero potencialmente pueden conducir al acceso a trav√©s de un enlace nulo.  Y detectar tales errores es muy dif√≠cil.  Por lo tanto, en algunos casos, debe considerar refactorizar el c√≥digo, en el que se generar√≠a una excepci√≥n si el m√©todo devuelve <i>nulo</i> .  De lo contrario, puede asegurar su c√≥digo solo con verificaciones totales, lo cual es bastante tedioso y poco confiable.  Por supuesto, en cada caso, la decisi√≥n debe tomarse sobre la base del proyecto. <br><br>  Nota  Sucede que en este momento no hay situaciones (datos de entrada) en las que el m√©todo devuelva <i>nulo</i> y no haya un error real.  Sin embargo, dicho c√≥digo a√∫n no es confiable, ya que todo puede cambiar cuando se realizan cambios en el c√≥digo. <br><br>  Para cerrar el tema con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> , echemos un vistazo a los errores obvios con el nivel de confianza alto, cuando el acceso a trav√©s de un enlace nulo es m√°s probable o incluso inevitable. <br><br>  <b>Posible desreferencia nula - Alta</b> <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Debido a un error tipogr√°fico en la condici√≥n (en lugar del operador <i>||</i> que usamos <i>&amp;&amp;</i> ), el c√≥digo no funciona en absoluto seg√∫n lo previsto, y se acceder√° a la variable <i>collectionType.Type</i> si es <i>nulo</i> .  La condici√≥n debe corregirse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Por cierto, la segunda variante del desarrollo de eventos tambi√©n es posible: en la primera parte, las condiciones est√°n mezcladas por los operadores <i>==</i> y <i>! =</i> .  Entonces el c√≥digo corregido ser√≠a: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Esta versi√≥n del c√≥digo es menos l√≥gica, pero tambi√©n corrige el error.  La decisi√≥n final depende de los autores del proyecto. <br><br>  Otro error similar. <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'acci√≥n'.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Se produjo un error al redactar un mensaje para una excepci√≥n.  Al mismo tiempo, se intenta acceder a la propiedad <i>action.DisplayText a</i> trav√©s de la variable <i>action</i> , que obviamente es <i>nula</i> . <br><br>  Y el √∫ltimo error es el alto nivel V3080. <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'tipo'.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  El m√©todo es peque√±o, as√≠ que le doy su c√≥digo completo.  La condici√≥n en el bloque de <i>retorno</i> es incorrecta.  En algunos casos, es posible lanzar una <i>NullReferenceException</i> al acceder a <i>type.FullName</i> .  Utilizo corchetes (no cambiar√°n el comportamiento aqu√≠) para aclarar la situaci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  As√≠ es como, de acuerdo con la prioridad de las operaciones, este c√≥digo funcionar√°.  Si la variable de <i>tipo</i> es <i>nula</i> , <i>ingresamos</i> a una comprobaci√≥n de otra cosa, donde, asegur√°ndonos de que la variable <i>targetTypeName</i> es <i>nula</i> , usamos la referencia de <i>tipo</i> nulo.  Puede arreglar el c√≥digo, por ejemplo, as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Creo que ah√≠ es donde puede completar el estudio de los errores V3080 y ver qu√© m√°s interesante analizador PVS-Studio encontr√≥ en el c√≥digo de Roslyn. <br><br>  <b>Error tipogr√°fico</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3005</a> La variable 'SourceCodeKind' se asigna a s√≠ misma.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Debido a un nombre de variable fallido, se realiz√≥ un error tipogr√°fico en el constructor de la clase <i>DynamicFileInfo</i> .  Al <i>campo SourceCodeKind se le</i> asigna su propio valor, en lugar de usar el par√°metro <i>sourceCodeKind</i> .  Para minimizar la probabilidad de tales errores, se recomienda que utilice el prefijo de subrayado para los nombres de los par√°metros en tales casos.  Dar√© un ejemplo de una versi√≥n corregida del c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Descuido</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3006</a> El objeto fue creado pero no se est√° utilizando.  Podr√≠a faltar la palabra clave 'throw': lanzar una nueva InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Bajo cierta condici√≥n, el destructor debe lanzar una excepci√≥n, pero esto no sucede, y el objeto de excepci√≥n simplemente se crea.  Se omiti√≥ la palabra clave <i>throw</i> .  Versi√≥n corregida del c√≥digo: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  El tema de trabajar con destructores en C # y lanzar excepciones de ellos es un tema para una discusi√≥n separada, que est√° m√°s all√° del alcance de este art√≠culo. <br><br>  <b>Cuando el resultado no es importante</b> <br><br>  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">han</a> recibido una serie de advertencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3009</a> para los m√©todos que devuelven el mismo valor en todos los casos.  A veces esto no es cr√≠tico, o el c√≥digo de retorno simplemente no se verifica en el c√≥digo de llamada.  Me perd√≠ tales advertencias.  Pero algunas piezas de c√≥digo me parecieron sospechosas.  Citar√© uno de ellos: <br><br>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  El m√©todo <i>TryExecuteCommand</i> devuelve solo <i>verdadero</i> , y nada m√°s que <i>verdadero</i> .  Al mismo tiempo, el valor de retorno est√° involucrado en algunas verificaciones en el c√≥digo de llamada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Es dif√≠cil decir cu√°n peligroso es este comportamiento.  Pero si no se necesita el resultado, puede valer la pena reemplazar el tipo de retorno con void y realizar cambios m√≠nimos en el m√©todo de llamada.  Esto har√° que el c√≥digo sea m√°s comprensible y seguro. <br><br>  Otras advertencias similares: <br><br><ul><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  JsonRpcClient.cs 138 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'falso'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  ObjectList.cs 173 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  ObjectList.cs 249 </li></ul><br>  <b>No verificado</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3019</a> Posiblemente, una variable incorrecta se compara con nulo despu√©s de la conversi√≥n de tipo usando la palabra clave 'as'.  Verifique las variables 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  El <i>valor de la</i> variable es de tipo <i>NamingStylePreferences</i> .  El problema es seguir esta verificaci√≥n.  Incluso si la variable de <i>valor</i> no es nula, esto no garantiza que la conversi√≥n de tipo haya sido exitosa y que <i>valueToSerialize</i> no contenga <i>nulo</i> .  Se <i>puede lanzar</i> una <i>NullReferenceException</i> .  El c√≥digo debe repararse de la siguiente manera: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Y un error similar m√°s. <br><br>  V3019 Posiblemente, una variable incorrecta se compara con nulo despu√©s de la conversi√≥n de tipo usando la palabra clave 'as'.  Verifique las variables 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  La variable <i>columnState</i> es de tipo <i>ColumnState2</i> .  Sin embargo, el resultado de la operaci√≥n, la variable <i>columnState2</i> , ya no se verifica como <i>nulo</i> .  En cambio, la variable <i>columnState se</i> verifica utilizando la declaraci√≥n <i>nula</i> condicional.  ¬øCu√°l es el peligro de este c√≥digo?  Como en el ejemplo anterior, la conversi√≥n de tipos con el operador <i>as</i> puede fallar, y la variable <i>columnState2</i> ser√° <i>nula</i> , lo que generar√° una excepci√≥n.  Por cierto, un error tipogr√°fico puede ser el culpable.  Tenga en cuenta la condici√≥n en el bloque <i>if</i> .  Quiz√°s en lugar de <i>columnState? .Name</i> quisieran escribir <i>columnState2? .Name</i> .  Esto es muy probable dado los nombres de variables bastante desafortunados <i>columnState y columnState2.</i> <br><br>  <b>Cheques redundantes</b> <br><br>  Se emiti√≥ una cantidad bastante grande de advertencias (m√°s de 100) para construcciones no cr√≠ticas, pero potencialmente inseguras, asociadas con verificaciones redundantes.  Por ejemplo, dar√© uno de ellos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3022 La</a> expresi√≥n 'navInfo == null' siempre es falsa.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Quiz√°s no haya un error real aqu√≠.  Solo una buena raz√≥n para demostrar la combinaci√≥n de tecnolog√≠as "an√°lisis interprocedural + an√°lisis de flujo de datos" en acci√≥n.  El analizador considera que la segunda verificaci√≥n <i>navInfo == null es</i> redundante.  De hecho, antes de eso, el valor para asignar <i>navInfo</i> se obtendr√° del m√©todo <i>libraryService.NavInfoFactory.CreateForProject</i> , que construir√° y devolver√° un nuevo objeto de la clase <i>NavInfo</i> .  Pero no es <i>nulo</i> de ninguna manera.  La pregunta es, ¬øpor qu√© el analizador no <i>gener√≥ una</i> advertencia para la primera verificaci√≥n <i>navInfo == null</i> ?  Hay una explicaci√≥n para esto.  En primer lugar, si la variable del <i>s√≠mbolo</i> resulta ser <i>nula</i> , entonces el valor de <i>navInfo</i> seguir√° siendo una referencia nula.  En segundo lugar, incluso si <i>navInfo</i> obtiene el valor del m√©todo <i>libraryService.NavInfoFactory.CreateForSymbol</i> , este valor puede ser <i>nulo</i> .  Por lo tanto, la primera comprobaci√≥n de <i>navInfo == null es</i> realmente necesaria. <br><br>  <b>No hay suficientes cheques</b> <br><br>  Y ahora la situaci√≥n es lo contrario de lo anterior.  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recibieron</a> varias advertencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3042</a> para el c√≥digo al que se pod√≠a acceder mediante una referencia nula.  Adem√°s, solo uno o dos cheques peque√±os podr√≠an arreglarlo todo. <br><br>  Considere una pieza interesante de c√≥digo que contiene dos de esos errores. <br><br>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'receptor' Binder_Expressions.cs 7770 <br><br>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'receptor' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  La variable del <i>receptor</i> puede ser <i>nula</i> .  El autor del c√≥digo sabe esto porque usa el operador <i>nulo</i> condicional en la condici√≥n del bloque <i>if</i> para acceder al <i>receptor? .Sintaxis</i> .  Adem√°s en el c√≥digo, el <i>receptor</i> variable <i>se</i> usa sin ninguna comprobaci√≥n para acceder a <i>receptor.Tipo</i> , <i>receptor.Sintaxis</i> y <i>receptor.TieneErrores</i> .  Estos errores deben corregirse: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Tambi√©n debe asegurarse de que el constructor <i>BoundConditionalReceiver</i> admite obtener valores <i>nulos</i> para sus par√°metros o realizar una refactorizaci√≥n adicional. <br><br>  Otros errores similares: <br><br><ul><li>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'contienenType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'expresi√≥n' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'expresi√≥n' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Error en la condici√≥n</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3057</a> La funci√≥n ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subcadena</a> ' podr√≠a recibir el valor '-1' mientras se espera un valor no negativo.  Inspeccione el segundo argumento.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Si la variable de <i>dos puntos</i> es 0, lo que permite una condici√≥n en el c√≥digo, el m√©todo <i>Substring</i> arrojar√° una <i>excepci√≥n ArgumentOutOfRangeException</i> .  Correcci√≥n requerida: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>El error tipogr√°fico es posible</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> par√°metro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3065</a> 't2' no se utiliza dentro del cuerpo del m√©todo.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Se pasan dos par√°metros a la expresi√≥n lambda: t1 y t2.  Sin embargo, solo se usa t1.  Parece sospechoso, considerando lo f√°cil que es cometer un error al usar variables con estos nombres. <br><br>  <b>Descuido</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3083</a> Invocaci√≥n insegura del evento 'TagsChanged', NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  El evento <i>TagsChanged se</i> desencadena de forma insegura.  Entre verificar la igualdad <i>nula</i> y llamar a un evento, pueden tener tiempo para darse de baja y luego se lanzar√° una excepci√≥n.  Adem√°s, en el cuerpo del bloque <i>if</i> , inmediatamente antes de la llamada del evento, se realizan otras operaciones.  Llam√© a este error "Inatenci√≥n", porque en otros lugares del c√≥digo trabajan con este evento con mayor precisi√≥n, por ejemplo, as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  El uso de la variable del <i>controlador</i> opcional elimina el problema.  En el m√©todo <i>OnTextBufferChanged</i> , debe realizar cambios para la misma operaci√≥n segura con el evento. <br><br>  <b>Rangos de intersecci√≥n</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3092 Las</a> intersecciones de rango son posibles dentro de expresiones condicionales.  Ejemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} m√°s if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Para una mejor comprensi√≥n, volver√© a escribir este fragmento de c√≥digo, reemplazando los nombres constantes con sus valores reales: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Probablemente, no hay un error real, pero la condici√≥n parece extra√±a.  La segunda parte ( <i>si no</i> ) se realizar√° solo para el rango de valores de 2147483648 + 1 a 4294967295. <br><br>  Un par m√°s de estas advertencias: <br><br><ul><li>  V3092 Las intersecciones de rango son posibles dentro de expresiones condicionales.  Ejemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} m√°s if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Las intersecciones de rango son posibles dentro de expresiones condicionales.  Ejemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} m√°s if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>M√°s informaci√≥n sobre las verificaciones de igualdad nula (o la falta de ellas)</b> <br><br>  Unos pocos errores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3095</a> sobre la comprobaci√≥n de una variable para <i>nulo</i> despu√©s de usarlo.  El primero es ambiguo, considere el c√≥digo. <br><br>  V3095 El objeto 'displayName' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Se supone que la referencia de <i>tee</i> puede ser nula.  Para hacer esto, verifique <i>Debug.Assert</i> .  No est√° claro por qu√© va despu√©s de usar la cadena.  Tambi√©n debe tenerse en <i>cuenta</i> que para otras configuraciones que no sean Debug, el compilador <i>eliminar√° Debug.Assert</i> del c√≥digo.  ¬øEsto significa que solo para Debug es posible obtener una referencia nula?  Y si esto no es as√≠, ¬øpor qu√© no comprob√≥ <i>string.IsNullOrEmpty (string)</i> , por ejemplo.  Estas son preguntas para los autores del c√≥digo. <br><br>  El siguiente error es m√°s obvio. <br><br>  V3095 El objeto 'scriptArgsOpt' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Creo que este c√≥digo no requiere explicaci√≥n.  Dar√© la versi√≥n corregida: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  El c√≥digo de Roslyn encontr√≥ otros 15 errores de este tipo: <br><br><ul><li>  V3095 El objeto 'LocalFunctions' se us√≥ antes de que se verificara contra nulo.  L√≠neas de verificaci√≥n: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 El objeto 'resolution.OverloadResolutionResult' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 El objeto 'resolution.MethodGroup' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 El objeto 'TouchFilesLogger' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 El objeto 'newExceptionRegionsOpt' se us√≥ antes de que se verificara contra nulo.  L√≠neas de verificaci√≥n: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 El objeto 's√≠mbolo' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 El objeto '_state.BaseTypeOrInterfaceOpt' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 El objeto 'elemento' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 El objeto 'idiomas' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 El objeto 'memberType' se us√≥ antes de que se verificara contra nulo.  L√≠neas de verificaci√≥n: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 El objeto 'validTypeDeclarations' se us√≥ antes de que se verificara contra nulo. Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere los errores de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aqu√≠ usamos el operador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> condicional </font><font style="vertical-align: inherit;">al inicializar la variable, y de aqu√≠ en adelante en el c√≥digo se usa la variable sin verificar la igualdad </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nula</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente error se se√±ala inmediatamente mediante dos advertencias. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 'documentId' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo. NullReferenceException es posible. CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 'documentId' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo. NullReferenceException es posible. CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se puede inicializar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como resultado, la creaci√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terminar√° arrojando una excepci√≥n. </font><font style="vertical-align: inherit;">El c√≥digo necesita ser reparado:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, m√°s adelante en el c√≥digo, es necesario prever la posibilidad de igualdad de </font><font style="vertical-align: inherit;">variables </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pasadas al constructor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otros errores similares en el c√≥digo:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 's√≠mbolo' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo. </font><font style="vertical-align: inherit;">NullReferenceException es posible. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 's√≠mbolo' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo. </font><font style="vertical-align: inherit;">NullReferenceException es posible. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioridades y corchetes </font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quiz√°s el operador '?:' Funciona de una manera diferente a la esperada. Su prioridad es inferior a la prioridad de otros operadores en su condici√≥n. Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La condici√≥n en el bloque de retorno no se calcula en absoluto como pens√≥ el desarrollador. </font><font style="vertical-align: inherit;">Se supuso que la primera condici√≥n ser√≠a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d (por lo tanto, el </font><i><font style="vertical-align: inherit;">ajuste de</font></i><font style="vertical-align: inherit;"> l√≠nea se realiz√≥ despu√©s de esta condici√≥n), y luego los bloques de condici√≥n con el operador " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Se calcular√≠an secuencialmente </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De hecho, la primera condici√≥n ser√° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp; (_oldNode == null)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto se debe a que el operador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene una prioridad m√°s alta que el operador " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Para corregir el error, es necesario poner entre par√©ntesis todas las expresiones del operador " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ":</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto concluye la descripci√≥n de los errores encontrados. </font></font><br><br>  <b>Conclusiones</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de la cantidad significativa de errores que pude detectar, en t√©rminos del tama√±o del c√≥digo del proyecto Roslyn (2,770,000 l√≠neas), esta ser√° una cantidad bastante peque√±a. Al igual que Andrei en el art√≠culo anterior, tambi√©n estoy listo para reconocer la alta calidad de este proyecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiero se√±alar que tales comprobaciones de c√≥digo ocasionales no tienen nada que ver con la metodolog√≠a del an√°lisis est√°tico y pr√°cticamente no aportan ning√∫n beneficio. El an√°lisis est√°tico debe aplicarse regularmente, y no de un caso a otro. Luego, muchos errores se corregir√°n en las primeras etapas y, por lo tanto, el costo de corregirlos ser√° diez veces menor. Esta idea se describe con m√°s detalle en este peque√±o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , con el que le pido que se familiarice.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede buscar independientemente m√°s errores tanto en el proyecto considerado como en cualquier otro. </font><font style="vertical-align: inherit;">Para hacer esto, solo necesita </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descargar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y probar nuestro analizador.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Sergey Khrenov. </font></font> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprobaci√≥n del c√≥digo fuente de Roslyn</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446592/">https://habr.com/ru/post/446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446576/index.html">Sustituci√≥n de importaciones, o c√≥mo los helic√≥pteros rusos hicieron algo mal</a></li>
<li><a href="../446578/index.html">Lenguaje de programaci√≥n basado en postales</a></li>
<li><a href="../446582/index.html">Reflexiones sobre el alojamiento solar para abejas</a></li>
<li><a href="../446588/index.html">Comprobaci√≥n del c√≥digo fuente de Roslyn</a></li>
<li><a href="../446590/index.html">39 nuevas funciones estar√°n disponibles en Java 12</a></li>
<li><a href="../446598/index.html">Recreando Fuentes CRT</a></li>
<li><a href="../446602/index.html">Corriente DC m√°xima a trav√©s del transistor de efecto de campo</a></li>
<li><a href="../446604/index.html">ESET: Nuevos esquemas de entrega de puerta trasera Oceanberg de Cybergroup</a></li>
<li><a href="../446606/index.html">Comprueba lo bueno que eres en tecnolog√≠a aditiva</a></li>
<li><a href="../446608/index.html">Superando la Tercera Ley de Gravedad Organizacional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>