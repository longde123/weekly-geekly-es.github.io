<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏿 ➕ 🧑🏾‍🤝‍🧑🏻 数据库读写平衡 🚓 ↔️ 🕍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章中，我描述了基于功能而不是关系数据库中的表和字段构建的数据库的概念和实现。 它提供了许多示例，显示了此方法相对于经典方法的优势。 许多人发现他们没有足够的说服力。 

 在本文中，我将展示该概念如何使您能够快速方便地平衡对数据库的读写，而无需改变工作逻辑。 他们试图在现代商业DBMS（特...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>数据库读写平衡</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lsfusion/blog/459066/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0w/wi/gl/0wwiglioocbaxcpjodrzg5x1ocs.jpeg" alt="图片"></div><br> 在上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章中，</a>我描述了基于功能而不是关系数据库中的表和字段构建的数据库的概念和实现。 它提供了许多示例，显示了此方法相对于经典方法的优势。 许多人发现他们没有足够的说服力。 <br><br> 在本文中，我将展示该概念如何使您能够快速方便地平衡对数据库的读写，而无需改变工作逻辑。 他们试图在现代商业DBMS（特别是Oracle和Microsoft SQL Server）中实现类似的功能。 在文章的最后，我将温和地（不是很）说明他们发生了什么。 <br><a name="habracut"></a><br><h3> 内容描述 </h3><br> 与以前一样，为了更好地理解，我将从示例开始进行描述。 假设我们需要实现一个逻辑，该逻辑将返回一个部门列表，其中包含员工人数及其总薪水。 <br><br> 在功能数据库中，它将如下所示： <br><div class="scrollable-table"><table><tbody><tr><td><code><font color="#a626a4">CLASS</font> Department ''; <br> name '' = <font color="#a626a4">DATA</font> <font color="#a626a4">STRING</font> [ <font color="#986801">100</font> ] (Department); <br> <br> <font color="#a626a4">CLASS</font> Employee ''; <br> department '' = <font color="#a626a4">DATA</font> Department (Employee); <br> salary '' = <font color="#a626a4">DATA</font> <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] (Employee); <br> <br> countEmployees '- ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> department(Employee e) = d; <br> salarySum ' ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d; <br> <br> SELECT name(Department d), countEmployees(d), salarySum(d); <br></code> </td></tr></tbody></table></div> 在任何DBMS中执行此查询的复杂度将等于<i>O（雇员数）</i> ，因为进行此计算时，您需要扫描整个雇员表，然后按部门对他们进行分组。 根据所选择的计划<i>O（雇员的对数）</i>或<i>O（部门的数目）</i>进行分组，还会有一些小的（我们认为雇员比部门多）的增加。 <br><br> 显然，在不同的DBMS中执行的开销可能有所不同，但是复杂性不会以任何方式改变。 <br><br> 在建议的实现中，功能DBMS将形成一个子查询，该子查询将计算部门的必要值，然后与部门表进行JOIN以获取名称。 但是，对于每个函数，在声明时都可以指定特殊的MATERIALIZED标记。 系统将自动为每个此类功能创建一个适当的字段。 当函数值更改时，字段值将在同一事务中更改。 使用该功能时，已经对计算所得的字段产生了吸引力。 <br><br> 特别是，如果将MATERIALIZED用作函数<i>countEmployees</i>和<i>SalarySum</i> ，则在带有部门列表的表中，将添加两个字段，其中将存储雇员人数及其总薪水。 如果员工，他们的工资或与部门有附属关系发生任何变化，系统将自动更改这些字段的值。 上面的查询将开始直接访问这些字段，并将对<i>O（部门数）执行</i> 。 <br><br> 有什么限制？ 只有一件事：此类函数必须具有有限数量的输入值，并为其定义了其值。 否则，将不可能建立一个存储所有值的表，因为不可能有无限行的表。 <br><br> 一个例子： <br><div class="scrollable-table"><table><tbody><tr><td> <code>employeesCount '    &gt; N' (Department d, <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] N) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d <font color="#a626a4">AND</font> salary(e) &gt; N; <br></code> </td></tr></tbody></table></div> 此函数是为N个数字的无限个值定义的（例如，任何负值都适用）。 因此，不能将其材料化。 因此，这是逻辑上的限制，而不是技术上的限制（也就是说，不是因为我们无法实现此限制）。 否则，没有任何限制。 您可以使用分组，排序，与与或，分区，递归等。 <br><br> 例如，在上一篇文章的任务2.2中，可以将MATERIALIZED放在两个函数上： <br><div class="scrollable-table"><table><tbody><tr><td> <code>bought <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> sum(Detail d) <font color="#a626a4">IF</font> <br> customer(order(d)) = c <font color="#a626a4">AND</font> <br> product(d) = p <font color="#a626a4">AND</font> <br> extractYear(date(order(d))) = y <font color="#a626a4">MATERIALIZED</font> ; <br> rating <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">PARTITION</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">ORDER</font> <font color="#a626a4">DESC</font> bought(c, p, y), p <font color="#a626a4">BY</font> c, y <font color="#a626a4">MATERIALIZED</font> ; <br> SELECT contactName(Customer c), name(Product p) <font color="#a626a4">WHERE</font> rating(c, p, <font color="#986801">1997</font> ) &lt; <font color="#986801">3</font> ; <br></code> </td></tr></tbody></table></div> 系统本身将创建一个具有类型为<i>Customer</i> ， <i>Product</i>和<i>INTEGER的</i>键的表，向其中添加两个字段，并将使用其中的任何更新来更新其中的字段值。 进一步调用这些函数时，将不会计算它们，但会读取相应字段中的值。 <br><br> 使用此机制，例如，您可以摆脱查询中的递归（CTE）。 特别是，考虑使用子/父关系构成树的组（每个组都有指向其父级的链接）： <br><div class="scrollable-table"><table><tbody><tr><td> <code>parent = <font color="#a626a4">DATA</font> Group (Group); <br></code> </td></tr></tbody></table></div> 在功能数据库中，递归逻辑可以定义如下： <br><div class="scrollable-table"><table><tbody><tr><td> <code>level (Group child, Group parent) = <font color="#a626a4">RECURSION</font> <font color="#986801">1l</font> <font color="#a626a4">IF</font> child <font color="#a626a4">IS</font> Group <font color="#a626a4">AND</font> parent == child <br> <font color="#a626a4">STEP</font> <font color="#986801">2l</font> <font color="#a626a4">IF</font> parent == parent($parent); <br> isParent (Group child, Group parent) = <font color="#a626a4">TRUE</font> <font color="#a626a4">IF</font> level(child, parent) <font color="#a626a4">MATERIALIZED</font> ; <br></code> </td></tr></tbody></table></div> 由于为<i>isParent</i>函数附加了MATERIALIZED，因此将为其创建带有两个键（组）的表，其中只有第一个键是第二个键的后代时， <i>isParent</i>字段才为true。 该表中的条目数将等于组数乘以树的平均深度。 例如，如果有必要计算特定组的后代数量，则可以访问此功能： <br><div class="scrollable-table"><table><tbody><tr><td> <code>childrenCount (Group g) = <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> isParent(Group child, g); <br></code> </td></tr></tbody></table></div>  SQL查询中将没有CTE。 相反，将有一个简单的GROUP BY。 <br><br> 使用此机制，还可以根据需要轻松地对数据库进行非规范化： <br><div class="scrollable-table"><table><tbody><tr><td> <code><font color="#a626a4">CLASS</font> Order <font color="#50a14f">''</font> ; <br> date <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> <font color="#a626a4">DATE</font> (Order); <br> <br> <font color="#a626a4">CLASS</font> OrderDetail <font color="#50a14f">' '</font> ; <br> order <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> Order (OrderDetail); <br> date <font color="#50a14f">''</font> (OrderDetail d) = date(order(d)) <font color="#a626a4">MATERIALIZED</font> <font color="#a626a4">INDEXED</font> ; <br></code> </td></tr></tbody></table></div> 当您为订单行调用<i>日期</i>函数时，将从具有索引的字段的订单行的表中进行读取。 更改订单日期时，系统本身将自动重新计算行中的非规范化日期。 <br><br><h3> 好处 </h3><br> 为什么需要整个机制？ 在经典的DBMS中，无需重写查询，开发人员或DBA只能更改索引，确定统计信息并告诉查询计划者如何执行它们（此外，仅在商用DBMS中提供HINT）。 无论他们如何努力，如果不更改请求和添加触发器，他们将无法满足文章中对<i>O（部门数）的</i>第一个请求。 在拟议的方案中，在开发阶段，您不必考虑数据存储的结构以及要使用的聚合。 所有这些都可以直接在运行中轻松更改。 <br><br> 实际上，如下。 有些人直接根据任务开发逻辑。 他们不精通算法及其复杂性，也不精通执行计划，不精通join'ov的类型，也不精通任何其他技术组件。 这些人比开发人员更多的是业务分析师。 然后，它们全部进入测试或运行状态。 启用长查询日志记录。 当检测到长请求时，其他人（实际上是DBA）则决定将MATERIALIZED包含在某些中间功能上。 因此，记录会稍慢一些（因为需要更新事务中的其他字段）。 但是，不仅此请求显着加速，而且所有其他使用此功能的请求也得到了加速。 同时，决定要实现的特定功能相对简单。 两个主要参数：可能的输入值的数量（恰好在对应表中有多少条记录），以及在其他函数中使用该记录的频率。 <br><br><h3> 类似物 </h3><br> 现代的商用DBMS具有类似的机制：具有快速刷新功能的材料化视图（Oracle）和具有索引功能的视图（Microsoft SQL Server）。 在PostgreSQL中，MATERIALIZED VIEW无法在事务中更新，而只能在请求时（甚至有非常严格的限制）进行更新，因此我们不考虑它。 但是它们有几个问题，极大地限制了它们的使用。 <br><br> 首先，仅当您已经创建了常规VIEW时，才能启用实现。 否则，您将必须重写其余访问新创建视图的请求，才能使用此实现。 或保留所有内容，但是如果已经计算出某些数据，它将至少无效，但是许多查询并不总是使用它们，而是重新计算。 <br><br> 其次，它们有很多限制： <br><br><div class="spoiler">  <b class="spoiler_title">甲骨文</b> <div class="spoiler_text"><blockquote><h5>  5.3.8.4快速刷新的一般限制 </h5><br> 物化视图的定义查询受到如下限制： <br><ul><li> 实例化视图不得包含对非重复表达式（如<code>SYSDATE</code>和<code>ROWNUM</code>引用。 </li><li> 实例化视图不得包含对<code>RAW</code>或<code>LONG</code> <code>RAW</code>数据类型的引用。 </li><li> 它不能包含<code>SELECT</code>列表子查询。 </li><li> 它不能在<code>SELECT</code>子句中包含分析函数（例如<code>RANK</code> ）。 </li><li> 它不能引用在其上定义了<code>XMLIndex</code>索引的表。 </li><li> 它不能包含<code>MODEL</code>子句。 </li><li> 它不能包含带有子查询的<code>HAVING</code>子句。 </li><li> 它不能包含具有<code>ANY</code> ， <code>ALL</code>或<code>NOT</code> <code>EXISTS</code>嵌套查询。 </li><li> 它不能包含<code>[START WITH …] CONNECT BY</code>子句。 </li><li> 它不能在不同站点包含多个明细表。 </li><li>  <code>COMMIT</code>化视图不能具有远程明细表。 </li><li> 嵌套的物化视图必须具有联接或聚集。 </li><li> 带有<code>GROUP</code> <code>BY</code>子句的<code>GROUP</code> <code>BY</code>视图和实例化聚合视图不能从索引组织的表中选择。 </li></ul><br><h5>  5.3.8.5仅具有联接的物化视图快速刷新的限制 </h5><br> 定义仅具有联接且没有聚合的物化视图查询对快速刷新具有以下限制： <br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速刷新的一般限制</a> ”中的所有限制。 </li><li> 它们不能具有<code>GROUP</code> <code>BY</code>子句或聚合。 </li><li>  <code>FROM</code>列表中所有表的Rowid必须出现在查询的<code>SELECT</code>列表中。 </li><li> 在查询的<code>FROM</code>列表中，物化视图日志必须存在所有基表的行<code>FROM</code> 。 </li><li> 您不能从具有简单连接的多个表创建快速刷新的物化视图，这些简单连接在<code>SELECT</code>语句中包含对象类型列。 </li></ul><br> 同样，在以下情况下，您选择的刷新方法也不会达到最佳效率： <br><ul><li> 定义查询使用行为类似于内部联接的外部联接。 如果定义查询包含此类联接，请考虑重写定义查询以包含内部联接。 </li><li>  <code>SELECT</code>化视图的<code>SELECT</code>列表包含来自多个表的列上的表达式。 </li></ul><br><h5>  5.3.8.6带有集合的物化视图快速刷新的限制 </h5><br> 使用聚合或联接定义物化视图的查询对快速刷新具有以下限制： <br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速刷新的一般限制</a> ”中的所有限制。 </li></ul><br>  <code>ON</code> <code>COMMIT</code>和<code>ON</code> <code>DEMAND</code>化视图都支持快速刷新，但是存在以下限制： <br><ul><li> 实例化视图中的所有表都必须具有实例化视图日志，并且实例化视图日志必须： <br><ul><li> 包含实例化视图中引用的表中的所有列。 </li><li> 使用<code>ROWID</code>指定并包含<code>NEW</code> <code>VALUES</code> 。 </li><li> 如果期望该表包含插入/直接加载，删除和更新的混合，则指定<code>SEQUENCE</code>子句。 </li></ul><br></li><li> 仅支持<code>SUM</code> ， <code>COUNT</code> ， <code>AVG</code> ， <code>VARIANCE</code> ， <code>VARIANCE</code> ， <code>MIN</code>和<code>MAX</code>进行快速刷新。 </li><li> 必须指定<code>COUNT(*)</code> 。 </li><li> 聚合函数只能出现在表达式的最外层。 即，不允许使用<code>AVG(AVG(x))</code>或<code>AVG(x)</code> + <code>AVG(x)</code>类的<code>AVG(x)</code> 。 </li><li> 对于每个聚合，例如<code>AVG(expr)</code> ，必须存在相应的<code>COUNT(expr)</code> 。  Oracle建议指定<code>SUM(expr)</code> 。 </li><li> 如果指定了<code>VARIANCE(expr)</code>或<code>STDDEV(expr</code> ），则必须指定<code>COUNT(expr)</code>和<code>SUM(expr)</code> 。  Oracle建议指定<code>SUM(expr *expr)</code> 。 </li><li> 定义查询中的<code>SELECT</code>列不能是包含多个基本表中的列的复杂表达式。 一个可能的解决方法是使用嵌套的物化视图。 </li><li>  <code>SELECT</code>列表必须包含所有<code>GROUP</code> <code>BY</code>列。 </li><li> 物化视图不是基于一个或多个远程表。 </li><li> 如果在<code>CHAR</code>化视图日志的过滤器列中使用<code>CHAR</code>数据类型，则主站点和实例化视图的字符集必须相同。 </li><li> 如果实例化视图具有以下内容之一，则仅在常规DML插入和直接载荷上支持快速刷新。 <br><ul><li> 具有<code>MIN</code>或<code>MAX</code>聚合的<code>MIN</code>视图 </li><li> 具有<code>SUM(expr)</code>但没有<code>COUNT(expr)</code> <code>SUM(expr)</code>视图 </li><li> 没有<code>COUNT(*)</code>视图 </li></ul><br> 这种实例化视图称为仅插入的实例化视图。 </li><li> 如果删除或混合DML语句不具有<code>WHERE</code>子句，则具有<code>MAX</code>或<code>MIN</code>的实例化视图可在其后快速刷新。 <br> 删除或混合DML后的max / min快速刷新与仅插入情况下的行为不同。 它删除并重新计算受影响组的最大值/最小值。 您需要了解其性能影响。 </li><li> 只要可以完全合并视图，可以快速刷新在<code>FROM</code>子句中具有命名视图或子查询的<code>FROM</code>视图。 有关将合并哪些视图的信息，请参见《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Oracle数据库SQL语言参考》</a> 。 </li><li> 如果没有外部联接，则可以在<code>WHERE</code>子句中进行任意选择和联接。 </li><li> 如果仅修改了外部表，则在常规DML和直接加载之后，具有外部联接的实例化聚合视图可以快速刷新。 此外，内部联接表的联接列上必须存在唯一约束。 如果存在外部联接，则所有联接必须通过<code>AND</code>进行连接<code>AND</code>并且必须使用等于（ <code>=</code> ）运算符。 </li><li> 对于具有<code>CUBE</code> ， <code>ROLLUP</code> ，分组集或它们的串联的<code>ROLLUP</code>化视图，适用以下限制： <br><ul><li>  <code>SELECT</code>列表应包含分组区分<code>GROUPING_ID</code> ，它可以是所有<code>GROUP</code> <code>BY</code>表达式上的<code>GROUPING_ID</code>函数，也可以是每个<code>GROUP</code> <code>BY</code>表达式上的<code>GROUPING</code>函数。 例如，如果实例化视图的<code>GROUP</code> <code>BY</code>子句是“ <code>GROUP</code> <code>BY</code> <code>CUBE(a, b)</code> ”，那么<code>SELECT</code>列表应包含“ <code>GROUPING_ID(a, b)</code> ”或“ <code>GROUPING(a)</code> <code>AND</code> <code>GROUPING(b)</code> “以使实例化视图能够快速刷新。 </li><li>  <code>GROUP</code> <code>BY</code>不应导致任何重复的分组。 例如，“ <code>GROUP BY a, ROLLUP(a, b)</code> ”不能快速刷新，因为它会导致重复的分组“ <code>(a), (a, b), AND (a)</code> ”。 </li></ul></li></ul><br><h5>  5.3.8.7使用UNION ALL快速刷新实例化视图的限制 </h5><br> 如果满足以下条件，则使用<code>UNION</code> <code>ALL</code>集合运算符的实例化视图将支持<code>REFRESH</code> <code>FAST</code>选项： <br><ul><li> 定义查询必须在顶层具有<code>UNION</code> <code>ALL</code>运算符。 <br><br>  <code>UNION</code> <code>ALL</code>运算符不能嵌入到子查询中，但有一个例外： <code>UNION</code> <code>ALL</code>可以位于<code>FROM</code>子句的子查询中，条件是定义的查询采用<code>SELECT * FROM</code>形式（使用<code>UNION</code> <code>ALL</code>视图或子查询），如下所示：例如： <br><pre> 创建视图view_with_unionall AS
 （选择c.rowid crid，c.cust_id，2个umarker
 来自客户c在哪里c.cust_last_name ='Smith'
 全联盟
  SELECT c.rowid crid，c.cust_id，3个umarker
 来自客户c的位置c.cust_last_name ='Jones'）;<font></font>
<font></font>
创建材料视图unionall_inside_view_mv
按需快速刷新
 SELECT * FROM view_with_unionall;
</pre> 请注意，视图<code>view_with_unionall</code>满足快速刷新的要求。 </li><li>  <code>UNION</code> <code>ALL</code>查询中的每个查询块必须满足具有聚合的可快速刷新的实例化视图或具有联接的可快速刷新的实例化视图的要求。 <br><br> 必须根据相应类型的快速可刷新实例化视图的要求，在表上创建适当的实例化视图日志。 <br> 请注意，只有在<code>SELECT</code>列表和实例化视图日志中包含<code>ROWID</code>列的情况下，Oracle数据库还允许具有连接的单个表实例化视图的特殊情况。 这在视图<code>view_with_unionall</code>的定义查询中显示。 </li><li> 每个查询的<code>SELECT</code>列表必须包含<code>UNION</code> <code>ALL</code>标记，并且<code>UNION</code> <code>ALL</code>列在每个<code>UNION</code> <code>ALL</code>分支中必须具有不同的常量数字或字符串值。 此外，标记列必须出现在每个查询块的<code>SELECT</code>列表中的相同顺序位置。 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UNION ALL标记</a>的更多信息，请参见“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UNION ALL标记和查询重写</a> ”。 </li><li> 带有<code>UNION</code> <code>ALL</code>实例化视图不支持外部联接，仅插入的聚合实例化视图查询和远程表等某些功能。 但是请注意，使用<code>UNION</code> <code>ALL</code>或远程表时，可以快速刷新复制中使用的实例化视图，其中不包含联接或聚合。 </li><li> 兼容性初始化参数必须设置为9.2.0或更高版本，才能使用<code>UNION</code> <code>ALL</code>创建快速可刷新的物化视图。 </li></ul></blockquote></div></div><br> 我不想冒犯Oracle爱好者，但是从他们的限制列表来看，似乎这种机制不是在一般情况下使用某种模型编写的，而是数千名印度人编写的，每个人都可以编写自己的线程，并且每个人都可以并且做到了。 使用这种机制实现真正的逻辑就像在雷区中漫步一样。 在任何时候，您都可以找到一个地雷，击中不明显的限制之一。 这是如何工作的也是一个单独的问题，但这不在本文的讨论范围之内。 <br><br><div class="spoiler">  <b class="spoiler_title">Microsoft SQL服务器</b> <div class="spoiler_text"><blockquote><h3> 附加要求 </h3><br> 除了SET选项和确定性功能要求外，还必须满足以下要求： <br><ul><li> 执行<code>CREATE INDEX</code>的用户必须是视图的所有者。 </li><li> 创建索引时，必须将<code>IGNORE_DUP_KEY</code>选项设置为OFF（默认设置）。 </li><li> 表必须由两部分名称<em>schema</em>引用<strong>。</strong> 视图定义中的<em>表名</em> 。 </li><li> 必须使用<code>WITH SCHEMABINDING</code>选项创建视图中引用的用户定义函数。 </li><li> 视图中引用的任何用户定义函数都必须由两部分名称<em>&lt;schema&gt;</em>引用<strong>。</strong>  <em>&lt;功能&gt;</em> 。 </li><li> 用户定义函数的数据访问属性必须为<code>NO SQL</code> ，外部访问属性必须为<code>NO</code> 。 </li><li> 公共语言运行时（CLR）函数可以出现在视图的选择列表中，但不能成为聚集索引键的定义的一部分。  CLR函数不能出现在视图的WHERE子句或视图中的JOIN操作的ON子句中。 </li><li> 视图定义中使用的CLR用户定义类型的CLR函数和方法必须具有如下表所示的属性集。 <br><div class="scrollable-table"><table><thead><tr><th> 物业资料 </th><th> 注意事项 </th></tr></thead><tbody><tr><td> 确定性= TRUE </td><td> 必须明确声明为Microsoft .NET Framework方法的属性。 </td></tr><tr><td> 精确=真 </td><td> 必须明确声明为.NET Framework方法的属性。 </td></tr><tr><td> 数据访问=无SQL </td><td> 通过将DataAccess属性设置为DataAccessKind.None和将SystemDataAccess属性设置为SystemDataAccessKind.None来确定。 </td></tr><tr><td> 外部访问=否 </td><td> 对于CLR例程，此属性默认为NO。 </td></tr><tr><td></td><td></td></tr></tbody></table></div></li><li> 必须使用<code>WITH SCHEMABINDING</code>选项创建<code>WITH SCHEMABINDING</code> 。 </li><li> 该视图必须仅引用与该视图位于同一数据库中的基表。 该视图无法引用其他视图。 </li><li> 视图定义中的SELECT语句不得包含以下Transact-SQL元素： <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  ROWSET函数（ <code>OPENDATASOURCE</code> ， <code>OPENQUERY</code> ， <code>OPENROWSET</code>和<code>OPENXML</code> ） </td><td>  <code>OUTER</code>联接（ <code>LEFT</code> ， <code>RIGHT</code>或<code>FULL</code> ） </td></tr><tr><td> 派生表（通过在<code>FROM</code>子句中指定<code>SELECT</code>语句定义） </td><td> 自我加入 </td><td> 通过使用<code>SELECT *</code>或<code>SELECT &lt;table_name&gt;.*</code>指定列<code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> ， <code>STDEVP</code> ， <code>VAR</code> ， <code>VARP</code>或<code>AVG</code> </td><td> 公用表表达式（CTE） </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> ， <strong>text</strong> ， <strong>ntext</strong> ， <strong>image</strong> ， <strong>XML</strong>或<strong>filestream</strong>列 </td><td> 子查询 </td><td>  <code>OVER</code>子句，其中包括排名或汇总窗口函数 </td></tr><tr><td> 全文谓词（ <code>CONTAINS</code> ， <code>FREETEXT</code> ） </td><td> 引用可为空的表达式的<code>SUM</code>函数 </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  CLR用户定义的聚合函数 </td><td> <code>TOP</code> </td> <td>  <code>CUBE</code> ， <code>ROLLUP</code>或<code>GROUPING SETS</code>运算符 </td></tr><tr><td>  <code>MIN</code> ， <code>MAX</code> </td><td>  <code>UNION</code> ， <code>EXCEPT</code>或<code>INTERSECT</code>运算符 </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td> 表变量 </td><td>  <code>OUTER APPLY</code>或<code>CROSS APPLY</code> </td><td>  <code>UNPIVOT</code> </td></tr><tr><td> 稀疏列集 </td><td> 内联（TVF）或多语句表值函数（MSTVF） </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><br>  <sup>1</sup>索引视图可以包含<strong>浮点</strong>列； 但是，此类列不能包含在聚集索引键中。 </li><li> 如果存在<code>GROUP BY</code> ，则VIEW定义必须包含<code>COUNT_BIG(*)</code>并且不能包含<code>HAVING</code> 。 这些<code>GROUP BY</code>限制仅适用于索引视图定义。 即使查询不满足这些<code>GROUP BY</code>限制，也可以在其执行计划中使用索引视图。 </li><li> 如果视图定义包含<code>GROUP BY</code>子句，则唯一聚集索引的键只能引用<code>GROUP BY</code>子句中指定的列。 </li></ul></blockquote></div></div><br> 在这里，您可以看到印第安人并没有受到吸引，因为他们决定按照该计划这样做：“我们只会做点小事，但是会做得很好。” 也就是说，他们在野外有更多的地雷，但是它们的位置更加透明。 最令人困扰的是这个限制： <br><blockquote> 该视图必须仅引用与该视图位于同一数据库中的基表。 该视图无法引用其他视图。 </blockquote><br> 用我们的术语来说，这意味着一个函数不能访问另一个物化函数。 它削减了整个意识形态。 <br> 同样，此限制（以及本文中的进一步限制）大大减少了用例： <br><blockquote> 视图定义中的SELECT语句不得包含以下Transact-SQL元素： <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  ROWSET函数（ <code>OPENDATASOURCE</code> ， <code>OPENQUERY</code> ， <code>OPENROWSET</code>和<code>OPENXML</code> ） </td><td>  <code>OUTER</code>联接（ <code>LEFT</code> ， <code>RIGHT</code>或<code>FULL</code> ） </td></tr><tr><td> 派生表（通过在<code>FROM</code>子句中指定<code>SELECT</code>语句定义） </td><td> 自我加入 </td><td> 通过使用<code>SELECT *</code>或<code>SELECT &lt;table_name&gt;.*</code>指定列<code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> ， <code>STDEVP</code> ， <code>VAR</code> ， <code>VARP</code>或<code>AVG</code> </td><td> 公用表表达式（CTE） </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> ， <strong>text</strong> ， <strong>ntext</strong> ， <strong>image</strong> ， <strong>XML</strong>或<strong>filestream</strong>列 </td><td> 子查询 </td><td>  <code>OVER</code>子句，其中包括排名或汇总窗口函数 </td></tr><tr><td> 全文谓词（ <code>CONTAINS</code> ， <code>FREETEXT</code> ） </td><td> 引用可为空的表达式的<code>SUM</code>函数 </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  CLR用户定义的聚合函数 </td><td> <code>TOP</code> </td> <td>  <code>CUBE</code> ， <code>ROLLUP</code>或<code>GROUPING SETS</code>运算符 </td></tr><tr><td>  <code>MIN</code> ， <code>MAX</code> </td><td>  <code>UNION</code> ， <code>EXCEPT</code>或<code>INTERSECT</code>运算符 </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td> 表变量 </td><td>  <code>OUTER APPLY</code>或<code>CROSS APPLY</code> </td><td>  <code>UNPIVOT</code> </td></tr><tr><td> 稀疏列集 </td><td> 内联（TVF）或多语句表值函数（MSTVF） </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div></blockquote><br> 禁止使用外部联接，UNION，ORDER BY等。 也许指出可以使用的总比未使用的要容易。 该列表可能会小得多。 <br><br> 总结一下：在LGPL技术中，每个DBMS（我注意到商业版）中都有大量的限制，而没有限制（只有一个逻辑而不是技术上的限制）。 但是，应该注意的是，在关系逻辑中实现此机制比在所描述的功能中要复杂得多。 <br><br><h3> 实作 </h3><br> 如何运作？  PostgreSQL被用作“虚拟机”。 里面有一个构建查询的复杂算法。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> 。 而且，不仅存在大量带有ifs的启发式方法。 因此，如果您有几个月的学习时间，则可以尝试了解该体系结构。 <br><br> 它有效吗？ 足够有效。 不幸的是，很难证明这一点。 我只能说，如果考虑大型应用程序中的数千个请求，那么平均而言，它们比一个好的开发人员更有效。 优秀的SQL程序员可以更有效地编写任何查询，但是只要执行一千个查询，他就根本没有动力也没有时间去做。 现在，我唯一能证明其有效性的是，在基于此DBMS的平台的基础上，开展了多个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ERP系统</a>项目，其中有成千上万种不同的MATERIALIZED功能，具有成千上万个用户和terrabyte数据库，并具有数亿条记录在常规双处理器服务器上。 但是，任何人都可以通过下载<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">平台</a>和PostgreSQL， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启用</a> SQL查询日志记录并尝试更改其中的逻辑和数据来测试/反驳有效性。 <br><br> 在以下文章中，我还将讨论如何在函数上挂起限制，如何使用更改会话等等。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459066/">https://habr.com/ru/post/zh-CN459066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459046/index.html">如何分两步独立实施（存在证明）</a></li>
<li><a href="../zh-CN459050/index.html">强大的Vuex输入模块</a></li>
<li><a href="../zh-CN459052/index.html">如何进行比较：市场调查和大数据中的“惊人的汽车”和“丑陋的小屋”</a></li>
<li><a href="../zh-CN459054/index.html">点击热图-用户在网站上的行为</a></li>
<li><a href="../zh-CN459062/index.html">＃305移动开发人员的有趣材料摘要（7月1日至7日）</a></li>
<li><a href="../zh-CN459068/index.html">Windows Server 2008 R2-国王死了，国王万岁</a></li>
<li><a href="../zh-CN459070/index.html">在Unity中创建塔防：塔与射击敌人</a></li>
<li><a href="../zh-CN459074/index.html">小小快乐＃7：三者合一的价格-控制台动画，算法和调试</a></li>
<li><a href="../zh-CN459078/index.html">CERN切换到开源软件-为什么？</a></li>
<li><a href="../zh-CN459080/index.html">java.net的HttpUrlConnection功能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>