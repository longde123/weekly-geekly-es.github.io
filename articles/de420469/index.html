<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèª üèπ üåá Merkmale der Verwendung von Druiden am Beispiel von Klassenkameraden üë©‚Äç‚ù§Ô∏è‚Äçüë® üçê üöá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Yuri Nevinitsin und ich besch√§ftige mich mit dem System der internen Statistik in OK. Ich m√∂chte dar√ºber sprechen, wie wir ein 50-Teraby...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merkmale der Verwendung von Druiden am Beispiel von Klassenkameraden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/420469/"><img src="https://habrastorage.org/webt/jd/0-/fd/jd0-fdngd2psn0-j-hkq1gmcm_a.jpeg"><br><br>  Mein Name ist Yuri Nevinitsin und ich besch√§ftige mich mit dem System der internen Statistik in OK.  Ich m√∂chte dar√ºber sprechen, wie wir ein 50-Terabyte-Analysesystem in Echtzeit, in dem t√§glich Milliarden von Ereignissen protokolliert werden, von Microsoft SQL auf eine Spaltenbasis namens Druid √ºbertragen haben.  Gleichzeitig lernen Sie einige Rezepte f√ºr die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Druiden</a> . <br><a name="habracut"></a><br><h2>  Warum brauchen wir Statistiken? </h2><br>  Wir m√∂chten alles √ºber unsere Site wissen und protokollieren daher nicht nur das Verhalten von Festplatten, Prozessoren usw., sondern auch jede Benutzeraktion, jede Interaktion zwischen Subsystemen und allen internen Prozessen fast aller unserer Systeme.  Das Statistiksystem ist eng in den Entwicklungsprozess eingebunden. <br><br>  Basierend auf den Daten aus dem Statistiksystem legen unsere Manager Ziele f√ºr die Teams fest, verfolgen deren Leistung und Schl√ºsselindikatoren.  Administratoren und Entwickler √ºberwachen den Betrieb aller Systeme, untersuchen Vorf√§lle und Anomalien.  Die automatische √úberwachung √ºberwacht st√§ndig und erkennt fr√ºhzeitig Probleme und prognostiziert Grenz√ºberschreitungen.  Au√üerdem werden st√§ndig Funktionen und Experimente gestartet, Aktualisierungen und √Ñnderungen vorgenommen.  Und wir √ºberwachen die Auswirkungen all dieser Aktionen √ºber das Statistiksystem.  Wenn sie sich weigert, k√∂nnen wir keine √Ñnderungen an der Website vornehmen. <br><br>  Unsere Statistiken werden haupts√§chlich in Form von Grafiken dargestellt.  In der Regel wird das Diagramm mehrere Tage gleichzeitig angezeigt, damit die Dynamik klar ist.  Hier ist ein Beispiel meiner Experimente mit Druiden.  Hier ist ein Diagramm des Datenladens (Linien / 5 min). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b4/66b/1b1/9b466b1b191463f97dd3d192a8c4da42.jpg"><br><br>  Ich verlangsamte den Download (das rote Diagramm st√ºrzt auf Null ab), wartete eine Weile, startete den Download neu und beobachtete, wie schnell Druid die gesammelten Daten laden konnte (Spitzen nach Fehlern). <br><br>  Jeder Zeitplan kann um einen beliebigen Parameter erweitert werden, z. B. nach Host, Tabelle, Operation usw.  Wir haben auch Langzeit-Charts mit j√§hrlicher Dynamik.  Im Folgenden sehen Sie beispielsweise ein Diagramm der t√§glichen Zunahme der Anzahl der Eintr√§ge in Druid. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9d/b52/45d/d9db5245dca91cc7cbdeee071b3529fa.png"><br><br>  Wir k√∂nnen auch mehrere Diagramme in separaten Bedienfeldern (Dashboards) kombinieren, was sich als sehr praktisch herausstellte.  Und selbst wenn der Benutzer nur ein paar Hundert Diagramme sehen muss, √∂ffnet er sie nicht einzeln, sondern im Bedienfeld, was die Belastung des Systems erh√∂ht. <br><br><h2>  Das Problem </h2><br>  Obwohl das Datenvolumen gering war, haben wir SQL recht gut gemeistert.  Mit zunehmendem Datenvolumen verlangsamte sich jedoch die Diagrammausgabe.  Am Ende verz√∂gerte sich die Statistik zur Hauptverkehrszeit um eine halbe Stunde, und die durchschnittliche Antwortzeit eines Diagramms erreichte 6 Sekunden.  Das hei√üt, jemand erhielt den Zeitplan in 2 Sekunden, jemand in 10-20 und jemand in einer Minute.  (Informationen zur Entwicklung des Systems in SQL finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) <br><br>  Wenn Sie eine Anomalie oder einen Vorfall untersuchen, m√ºssen Sie normalerweise ein Dutzend Diagramme √∂ffnen und anzeigen, von denen jedes aus dem vorherigen folgt. Sie k√∂nnen nicht gleichzeitig ge√∂ffnet werden.  Ich musste 10 mal 10-20 Sekunden warten.  Es war sehr nervig. <br><br><h2>  Die Migration </h2><br>  Sie k√∂nnten immer noch etwas aus dem System herausdr√ºcken, Server hinzuf√ºgen ... Aber ungef√§hr zur gleichen Zeit √§nderte Microsoft seine Lizenzierungsrichtlinie.  Wenn wir weiterhin SQL Server verwenden w√ºrden, m√ºssten wir Millionen von Dollar verschenken.  Daher beschlossen sie, zu migrieren. <br><br>  Die Anforderungen waren wie folgt: <br><br><ul><li>  Statistiken sollten nicht verz√∂gert werden (mehr als 2 Minuten). </li><li>  Das Diagramm sollte sich in nicht mehr als 2 Sekunden √∂ffnen. </li><li>  Das gesamte Bedienfeld sollte sich in nicht mehr als 10 Sekunden √∂ffnen. </li><li>  Das System muss fehlertolerant sein und den Verlust eines Rechenzentrums √ºberstehen k√∂nnen. </li><li>  Das System muss leicht skalierbar sein. </li><li>  Das System sollte leicht zu modifizieren sein, daher wollten wir, dass es in Java ist. </li></ul><br>  All dies wurde uns nur von Druiden angeboten.  Es verf√ºgt auch √ºber eine vorl√§ufige Aggregation, mit der Sie etwas mehr Volumen sparen und w√§hrend des Einf√ºgens von Daten indizieren k√∂nnen.  Druid unterst√ºtzt alle Arten von Abfragen, die f√ºr unsere Statistiken ben√∂tigt werden.  Daher schien es, dass wir SQL Server leicht durch Druid ersetzen konnten. <br><br>  Nat√ºrlich haben wir nicht nur Druiden als Kandidaten f√ºr den Umzug in Betracht gezogen.  Mein erster Gedanke war, Microsoft SQL Server durch PostgreSQL zu ersetzen.  Dies w√ºrde jedoch nur das Problem der finanziellen Kosten l√∂sen, aber nicht zur Erreichbarkeit und Skalierung beitragen. <br><br>  Wir haben auch Influx analysiert, aber es stellte sich heraus, dass der Teil, der f√ºr hohe Verf√ºgbarkeit und Skalierbarkeit verantwortlich ist, geschlossen ist.  Prometheus ist bei allem Respekt vor seiner Leistung besser auf die √úberwachung abgestimmt und kann sich weder einer hohen Verf√ºgbarkeit noch einer einfachen Skalierbarkeit r√ºhmen.  OpenTSDB eignet sich auch besser zur √úberwachung, es verf√ºgt nicht √ºber Indizes f√ºr alle Felder.  Click House haben wir nicht in Betracht gezogen, da es zu diesem Zeitpunkt noch nicht da war. <br><br>  Setzen Sie Druide.  Terabyte Daten wurden migriert.  Unmittelbar nach dem Wechsel von SQL Server zu Druid wurde die Anzahl der Diagrammansichten um das F√ºnffache erh√∂ht.  Dann fingen sie an, "schwere" Statistiken zu erstellen, f√ºr die sie Angst hatten, fr√ºher zu f√ºhren, weil  SQL w√ºrde kaum damit umgehen. <br><br>  Jetzt nimmt Druide von 12 Knoten (40 Kerne, 196 GB RAM) 500.000 Ereignisse pro Sekunde pro Hauptverkehrszeit auf, w√§hrend es einen gro√üen Sicherheitsspielraum gibt (MAX-Spalte: fast das F√ºnffache des CPU-Spielraums). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/833/336/d09/833336d095db6e9d32da19dae981d474.png" width="500"><br><br>  Diese Zahlen basieren auf Produktionsdaten.  Ich werde Ihnen sagen, wie wir dies erreicht haben, aber zuerst werde ich Druiden genauer beschreiben. <br><br><h2>  Druide </h2><br>  Dies ist ein verteiltes Spalten-Zeitreihen-OLAP-System.  Die Dokumentation enth√§lt nicht die √ºblichen Konzepte der SQL-Welt f√ºr eine Tabelle (stattdessen Datenquelle) oder eine Zeichenfolge (stattdessen Ereignis), aber ich werde sie zur einfacheren Beschreibung verwenden. <br><br>  Druide basieren auf mehreren Datenannahmen (Einschr√§nkungen): <br><br><ul><li>  Jede Datenzeile hat einen Zeitstempel, der monoton w√§chst (standardm√§√üig innerhalb eines Fensters von 10 Minuten). </li><li>  Daten √§ndern sich nicht, nur Einf√ºgen (Aktualisierungsvorgang nicht). </li></ul><br>  Auf diese Weise k√∂nnen Sie Daten in sogenannte Zeitsegmente schneiden.  Ein Segment ist eine minimale unteilbare und unver√§nderliche "Partition" einer Tabelle f√ºr einen bestimmten Zeitraum.  Alle Datenoperationen, alle Abfragen werden segmentweise ausgef√ºhrt. <br><br>  Jedes Segment ist autark: Neben der in Spaltenform geschriebenen Haupttabelle enth√§lt es auch Verzeichnisse und Indizes, die f√ºr die Ausf√ºhrung von Abfragen erforderlich sind.  Wir k√∂nnen sagen, dass ein Segment eine schreibgesch√ºtzte Datenbank mit kleinen Spalten ist (eine detailliertere Beschreibung des Segmentger√§ts wird unten gegeben). <br><br>  Dies f√ºhrt wiederum zu einer ‚ÄûVerteilung‚Äú: Die F√§higkeit, eine gro√üe Datenmenge in kleine Segmente zu unterteilen, um Berechnungen parallel durchzuf√ºhren (sowohl auf einer Maschine als auch auf vielen gleichzeitig). <br><br>  Wenn Sie mindestens eine Zeile ‚Äûaktualisieren‚Äú m√ºssen, m√ºssen Sie das gesamte Segment erneut laden.  Es ist m√∂glich und alles ist daf√ºr bereit.  Jedes Segment hat eine Version, und ein Segment mit einer neueren Version ersetzt automatisch das Segment mit der alten Version (wenn jedoch regelm√§√üig Updates erforderlich sind, sollte neu bewertet werden, ob Druid f√ºr diesen Anwendungsfall geeignet ist). <br><br>  Zur Beschreibung des Ger√§tesegments betrachten wir ein einfaches Beispiel in der √ºblichen tabellarischen Form: <br><br><img src="https://habrastorage.org/webt/7l/pb/hw/7lpbhwalmq7ogn5qnaq2gjrkzua.png" width="600"><br><br>  In dieser Tabelle ist die Anzahl der Anrufe in zwei f√ºnf Minuten von vier Hosts angegeben (beachten Sie, dass f√ºr den web1-Host in jedem F√ºnf-Minuten-Zeitraum zwei Leitungen vorhanden sind). <br><br>  Alle Datenzellen aus Sicht des Druiden sind in drei Typen unterteilt: <br><br><ul><li>  Zeitstempel - UTC-Zeitstempel in ms (im Beispiel ist es Zeit). </li><li>  Metriken m√ºssen berechnet werden (Summe, Min, Max, Anzahl, ...), und Sie m√ºssen sie f√ºr jede Tabelle im Voraus kennen (im Beispiel ist dies Aufrufe, und wir berechnen die Summe). </li><li>  Dimensionen - Dies k√∂nnen Sie gruppieren und filtern (Sie m√ºssen sie nicht im Voraus kennen und k√∂nnen im laufenden Betrieb ge√§ndert werden) (im Beispiel ist dies Host). </li></ul><br>  Beim Einf√ºgen werden alle Zeilen nach dem vollst√§ndigen Satz von Dimensionen + Zeitstempel gruppiert. Wenn sie mit jeder der Metriken √ºbereinstimmen, wird die Aggregationsfunktion "ihre" angewendet (daher gibt es keine Zeilen mit demselben Satz von Dimensionen + Zeitstempel).  So sieht unser Beispiel nach dem Einf√ºgen in den Druiden folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb8/8b9/e64/eb88b9e64bdafc870ca39646e4c0a4fb.png" width="500"><br><br>  Der Zeitstempel und alle Metriken (in unserem Fall Time and Calls) werden als Arrays mit Zahlen vom Typ long geschrieben (float und double werden ebenfalls unterst√ºtzt).  F√ºr jede der Dimensionen (in unserem Fall Host) wird ein W√∂rterbuch erstellt - ein sortierter Satz von Zeichenfolgen (mit Hostnamen).  Die Hostspalte selbst wird als int-Array geschrieben und gibt die Zahlen im W√∂rterbuch an. <br><br>  Bitte beachten Sie, dass nach dem Einf√ºgen in den Druiden Zeilenpaare f√ºr den web1-Host mit demselben Zeitstempel aggregiert wurden und der Gesamtbetrag in Anrufen aufgezeichnet wurde (es ist unm√∂glich, die Anfangsdaten aus dem Druiden zu extrahieren). <br><br>  F√ºr eine schnelle Datenfilterung sind Indizes erforderlich, da Millionen von Zeilen und Tausende von Hosts vorhanden sein k√∂nnen.  Indizes sind Bitmaps, eine f√ºr jede Zeile im W√∂rterbuch. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f32/bb5/edd/f32bb5eddba3c14b6ef241057f061724.png" width="500"><br><br>  Einheiten geben Zeilennummern an, an denen dieser Host teilnimmt.  Um zwei Hosts zu filtern, m√ºssen Sie zwei Bitmaps nehmen, sie durch ODER kombinieren und die Zeilennummern in Einheiten der resultierenden Bitmap ausw√§hlen. <br><br><h2>  Ein Druide besteht aus vielen Komponenten. </h2><br>  Erstens hat es mehrere externe Abh√§ngigkeiten. <br><br><img src="https://habrastorage.org/webt/rd/zs/uo/rdzsuo03og7v4whzfi5rz4m6qss.png" width="400"><br><br><ol><li>  Lagerung  Dort speichert Druid die Segmente einfach in komprimierter Form.  Es kann ein lokales Verzeichnis sein, HDFS, Amazon S3.  Hier wird nur Platz verwendet, es werden keine Berechnungen durchgef√ºhrt. </li><li>  Meta: Eine Datenbank f√ºr Meta-Informationen.  Diese Datenbank speichert die vollst√§ndige Datenkarte: Welche Segmente sind relevant, welche sind veraltet, welcher Pfad ist gespeichert. </li><li>  Mit ZooKeeper f√ºhrt das System eine Ermittlung durch und gibt bekannt, auf welchen Druidenknoten welche Segmente zur Abfrage verf√ºgbar sind. </li><li>  Der Cache der ausgef√ºhrten Anforderungen kann zwischengespeichert oder ein lokaler Cache im Java-Heap sein. </li></ol><br>  Zweitens besteht Druide selbst aus mehreren Arten von Komponenten. <br><br><ol><li>  Echtzeitknoten laden den Strom frischer Daten in der Reihenfolge ihres Empfangs und bedienen Anforderungen daf√ºr. </li><li>  Historische Knoten enthalten die gesamte Datenmasse und bedienen Anforderungen daf√ºr.  Wenn wir sagen, dass wir einen 300-TB-Cluster haben, meinen wir historische Knoten. </li><li>  Der Broker ist f√ºr die Verteilung der Berechnungen zwischen historischen und Echtzeitknoten verantwortlich. </li><li>  Der Koordinator ist f√ºr die Zuordnung von Segmenten zu historischen Knoten und f√ºr die Replikation verantwortlich. </li><li>  Indizierungsdienst, mit dem Sie Daten in Stapeln (erneut) laden k√∂nnen, um beispielsweise einen Teil der Daten zu "aktualisieren". </li></ol><br><h2>  Datenstrom </h2><br><img src="https://habrastorage.org/webt/gh/yg/pc/ghygpcnsakfac9x6dqrjtjjagdc.png" width="400"><br>  <i>Fettgedruckte Pfeile zeigen einen Datenstrom an, d√ºnne Pfeile zeigen einen Metadatenstrom an.</i> <br><br>  Ein Echtzeitknoten nimmt Daten, Indizes und schneidet nach Zeit, z. B. nach Tag, in Segmente. <br><br>  Jedes neue Segment eines Echtzeitknotens schreibt in den Speicher und hinterl√§sst eine Kopie, um Anforderungen daf√ºr zu bearbeiten.  Dann zeichnet es Metadaten auf, dass ein neues Segment entlang eines solchen und eines solchen Pfades im Repository angezeigt wurde. <br><br>  Diese Informationen werden vom Koordinator empfangen und die Metadatenbasis regelm√§√üig erneut gelesen.  Wenn er ein neues Segment findet, befiehlt er (√ºber ZooKeeper) mehreren historischen Knoten, dieses Segment herunterzuladen.  Sie laden herunter und geben (√ºber ZooKeeper) bekannt, dass sie ein neues Segment haben.  Wenn ein Echtzeitknoten diese Nachricht empf√§ngt (√ºber ZooKeeper), l√∂scht er seine Kopie, um Platz f√ºr neue Daten zu schaffen. <br><br><h2>  Anfrage bearbeiten </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c1f/8f5/e8f/c1f8f5e8fcc11c157c7ab10311ae977a.png"><br><br>  Drei Arten von Knoten nehmen an der Anforderungsverarbeitung teil: Broker, Echtzeit und Verlauf.  Die Anfrage geht an den Broker, der wei√ü, auf welchen Knoten sich welche Segmente befinden.  Es verteilt die Anforderung nach historischen (und Echtzeit-) Knoten, die die gew√ºnschten Segmente speichern.  Historische Knoten parallelisieren die Berechnungen so weit wie m√∂glich, senden die Ergebnisse an den Broker und er gibt sie an den Kunden weiter.  Durch die Kombination dieses Schemas mit der Speicherung von Spaltendaten kann Druid sehr schnell gro√üe Informationsmengen verarbeiten. <br><br><h2>  Hohe Verf√ºgbarkeit </h2><br>  Wie Sie sich erinnern, hat Druid in der Liste der Abh√§ngigkeiten eine Basis f√ºr Metadaten, die MySQL oder PostgreSQL sein k√∂nnen.  Apache Derby wird ebenfalls erw√§hnt, aber dieses Produkt kann nicht f√ºr die Produktion verwendet werden, sondern nur f√ºr die Entwicklung (so wie ich es verstehe, wird Derby in einer eingebetteten Form verwendet, um mysql / pgsql in einer jungfr√§ulichen Umgebung nicht zu erh√∂hen). <br><br>  Was passiert, wenn diese Basis ausf√§llt (und / oder Speicher und / oder der Koordinator)?  Ein Echtzeitknoten kann keine Metadaten (und / oder Segmente) schreiben.  Dann kann der Koordinator sie nicht erneut lesen und findet kein neues Segment.  Der historische Knoten l√§dt ihn nicht herunter und der Echtzeitknoten l√∂scht seine Kopie nicht, l√§dt jedoch weiterhin die neuesten Daten herunter.  Infolgedessen beginnen sich Daten in Echtzeitknoten anzusammeln.  Dies kann nicht auf unbestimmte Zeit so weitergehen.  Es ist jedoch bekannt, welche Ressourcen auf Echtzeitknoten verf√ºgbar sind und welche Art von Datenfluss wir haben.  Daher haben wir eine vorhersehbare Zeitspanne, f√ºr die wir die ausgefallene Basis (und / oder Speicher und / oder Koordinator) reparieren k√∂nnen. <br><br>  Da die unterst√ºtzten mysql / pgsql keine sofortige Hochverf√ºgbarkeit garantieren, haben wir uns entschlossen, auf Nummer sicher zu gehen, und unsere eigene (vorgefertigte) L√∂sung auf Basis von Cassandra verwendet, da sie sofort eine hohe Verf√ºgbarkeit bietet (mehr dazu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br>  Dar√ºber hinaus haben wir die Echtzeitknoten so finalisiert, dass bei √ºberm√§√üiger Akkumulation die √§ltesten Daten gel√∂scht werden und Speicherplatz f√ºr neue frei wird.  Dies ist f√ºr uns sehr wichtig, da die Situation, in der wir die ausgefallene Basis (und / oder Speicher und / oder den Koordinator) nicht √ºber einen l√§ngeren Zeitraum erh√∂hen k√∂nnen und sich viele Daten ansammeln, h√∂chstwahrscheinlich eine Folge eines gro√üen Unfalls ist.  Und in diesem Moment sind die neuesten Daten am wichtigsten. <br><br><h2>  Druide und ZooKeeper </h2><br>  Mit ZooKeeper ist alles besser und schlechter.  Besser, da ZooKeeper selbst fehlertolerant ist, ist die Replikation sofort einsatzbereit.  Es scheint, dass das passieren k√∂nnte? <br><br>  Im Allgemeinen ist dieses Kapitel nicht mehr relevant.  Und dies ist keine Erfolgsgeschichte, dies ist ein Schmerz, den (sowohl wir als auch der frische Druide) beschlossen haben, fast alle Daten von ZooKeeper radikal zu entfernen, und jetzt fordern die Druiden-Knoten sie direkt √ºber HTTP voneinander an. <br><br>  ZooKeeper hat zwei Arten von Zeit√ºberschreitungen.  Das Verbindungszeitlimit ist ein einfaches Netzwerkzeitlimit, nach dem der Client erneut eine Verbindung zu ZooKeeper herstellt und versucht, seine Sitzung wiederherzustellen.  Das Sitzungszeitlimit, nach dem die Sitzung gel√∂scht und alle in dieser Sitzung erstellten <i>kurzlebigen</i> Daten gel√∂scht werden (von ZooKeeper selbst), wird allen anderen ZooKeeper-Clients mitgeteilt. <br><br>  Auf dieser Grundlage funktioniert die Erkennung im Druiden: Beim Start erstellt jeder Knoten eine neue Sitzung in ZooKeeper und zeichnet <i>kurzlebige</i> Daten √ºber sich selbst auf: Host: Port, Knotentyp (Broker / Echtzeit / Historisch / ...), Verbindungszeitstempel usw. ... Andere Druidenknoten erhalten Benachrichtigungen von ZooKeeper und lesen diese Daten, damit sie erfahren, dass ein neuer Druidenknoten gestiegen ist und um welche Art von Knoten es sich handelt.  Wenn ein Druidenknoten nach dem Timeout seiner Sitzung ausf√§llt, werden die Daten dar√ºber von ZooKeeper gel√∂scht, und die anderen Druidenknoten wissen davon.  Damit sie schneller davon erfahren, bevorzugen wir eine kleine Sitzungszeit√ºberschreitung. <br><br>  Wenn ein Echtzeit- oder historischer Knoten ansteigt, schreibt er neben Daten √ºber sich selbst auch eine Liste der Segmente in ZooKeeper (dies sind auch <i>kurzlebige</i> Daten).  Weiter auf dem Weg werden Segmente auf Echtzeit- und historischen Knoten erstellt, neue und alte werden gel√∂scht, und jeder Knoten spiegelt dies in seiner Liste in ZooKeeper wider.  Diese Liste kann gro√ü sein, daher wird sie in Teile aufgeteilt, sodass nicht die gesamte Liste, sondern nur der ge√§nderte Teil √ºberschrieben wird. <br>  Wenn der Broker wiederum einen neuen Echtzeit- oder historischen Knoten sieht, subtrahiert er auch seine Liste der Segmente von ZooKeeper, um Anforderungen an diesen Knoten zu verteilen.  Echtzeitknoten lesen diese Liste, um ihre Kopie des Segments zu entfernen, das auf dem historischen Knoten angezeigt wurde.  Da die Liste in Teile unterteilt und in Teile √ºberschrieben ist, teilt Ihnen ZooKeeper mit, welcher Teil ge√§ndert wurde, nur dass er erneut gelesen wird. <br><br>  Wie gesagt, diese Liste kann lang sein.  Wenn in ZooKeeper viele Daten vorhanden sind, stellt sich heraus, dass diese nicht mehr so ‚Äã‚Äãstabil sind.  In unserem Fall begannen offensichtliche Probleme, als die Anzahl der Segmente etwa 7 Millionen erreichte. Der ZooKeeper-Snapshot belegte dann 6 GB. <br>  Was passiert, wenn ein Druidenknoten den Kontakt zu ZooKeeper verliert? <br><br>  Druid arbeitet mit ZooKeeper so zusammen, dass im Falle eines Sitzungszeitlimits jeder Knoten eine neue Sitzung erstellt und alle seine Daten dort schreibt und die Daten anderer Knoten erneut liest.  Da es viele Daten gibt, nimmt der Verkehr auf ZooKeeper ab.  Dies kann zu einer Zeit√ºberschreitung auf anderen Knoten des Druiden f√ºhren, dann beginnen auch diese neu zu schreiben und neu zu lesen.  Somit w√§chst der Datenverkehr wie eine Lawine bis zu dem Punkt, an dem ZooKeeper die Synchronisation zwischen seinen Instanzen verliert und Snapshots hin und her treibt. <br><br>  Was sieht der Benutzer gerade? <br><br>  Wenn ein Broker den Kontakt zu ZooKeeper verliert (und ein Sitzungszeitlimit auftritt), wei√ü er nicht mehr, welche Segmente auf welchen historischen Knoten liegen.  Und gibt leere Antworten.  Das hei√üt, wenn ZooKeeper nicht verf√ºgbar ist, funktioniert Druid nicht.  Es ist v√∂llig unm√∂glich, es zu ‚Äûheilen‚Äú, aber es ist an einigen Stellen m√∂glich, Strohhalme zu verbreiten. <br>  Erstens k√∂nnen Sie Daten aus ZooKeeper l√∂schen.  Es ist in Ordnung, wenn sie sich verlaufen: Druide werden sie einfach √ºberschreiben.  Wenn das Problem mit ZooKeeper bereits begonnen hat, wird f√ºr die schnellste L√∂sung empfohlen, ZooKeeper zu deaktivieren, die Daten zu l√∂schen und leer zu lassen und nicht darauf zu warten, dass sie sich selbst beheben. <br><br>  Jetzt erh√∂hen wir das Sitzungszeitlimit.  Was passiert in diesem Fall? <br><br>  Angenommen, der historische Knoten wurde nicht korrekt neu gestartet und die alte Sitzung nicht aus ZooKeeper gel√∂scht, w√§hrend eine neue Sitzung erstellt und dort eine Reihe von Daten geschrieben wurden.  W√§hrend die alte Sitzung noch aktiv ist und das Zeitlimit nicht abgelaufen ist, werden zwei Kopien der Daten in ZooKeeper gespeichert.  Wenn viele solcher Knoten sofort neu gestartet werden, werden viele Daten dupliziert.  Daher m√ºssen Sie Speicher f√ºr ZooKeeper bereitstellen, damit dieser nicht ausgeht und ZooKeeper nicht nicht mehr funktioniert.  Warum konnten die Daten der alten Sitzung nicht gel√∂scht werden? <br><br>  Aus dem gleichen Grund ist es notwendig, den Betrieb historischer Knoten korrekt abzuschlie√üen, da sie zu diesem Zeitpunkt ihre Daten aus ZooKeeper l√∂schen und dies f√ºr eine lange Zeit tun k√∂nnen.  Die Fertigstellung historischer Knoten dauert etwa eine halbe Stunde. <br><br>  Historische Knoten haben eine weitere Funktion.  Wenn sie beginnen, sehen sie sich an, welche Segmente auf ihnen gespeichert sind, und dann werden Informationen dazu in ZooKeeper geschrieben.  Und da die Daten mehr oder weniger gleichm√§√üig √ºber historische Knoten verteilt sind, werden sie ungef√§hr zur gleichen Zeit in ZooKeeper geschrieben, wenn Sie sie gleichzeitig ausf√ºhren.  Dies erh√∂ht wiederum die Wahrscheinlichkeit eines wellenartigen Verkehrswachstums und von Zeit√ºberschreitungen.  Daher m√ºssen Sie historische Knoten nacheinander ausf√ºhren, um die Aufzeichnungssitzungen in ZooKeeper rechtzeitig zu verteilen. <br><br>  Wir haben auch zwei weitere Optimierungen vorgenommen: <br><br><ul><li>  Wir haben die Arbeit mit ZooKeeper etwas neu programmiert, sodass nur die Knoten, die sie ben√∂tigen, von Druid gelesen werden.     realtime,   ,    .    ,        .          ,    . </li><li>  ,    ZooKeeper,       ,     .      ZooKeeper  6   2  (  ). </li></ul><br>          8 ;         . <br><br><h2>   Druid </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/71b/9a9/2f471b9a9927b4075e3dcc9bba8333cc.png"><br><br>     realtime    ,      .      - (   , , ).       ,     MMAP (   ).          .     . <br><br> -, realtime-   ,       JVM    ,      . <br><br><img src="https://habrastorage.org/webt/on/uk/w1/onukw1xyab_eojgwxynlsxjr6qc.png" width="500"><br><br>    .         : 1)     2)       .       ,       . ,  ,  .     ,   ,      ,  . (  ,      ,   ). <br><br>    ,    realtime-       ,     , ..      ,     ,   ,     (  ). <br><br>  ,     .       ,      ,  . <br><br>     ,       Druid   .    ,       ,       ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f32/bb5/edd/f32bb5eddba3c14b6ef241057f061724.png" width="500"><br><br>  ,      . ,          (web%, api%). <br><br><ul><li> Druid     ‚Äî  .           . </li><li>   ,      . </li><li>  Druid   ,  ,    :   ,  , ,    . </li><li>   Druid        ,   ,        calls. </li></ul><br>     ,     5 %     ,  95 % ‚Äî  . <br><br>  ,  ,  realtime-         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/30d/618/76b30d618474a0cd9afdf6aa40af6b90.png" width="500"><br><br>   ,   ( 10:45)  .  -   ,   -.  ,    ( 10:50)  ,   -.  Usw.    ,   ,   ¬´calls¬ª, ¬´time¬ª  ¬´host¬ª     . <br>       -.         ,    ¬´¬ª      .    ,    ,      .          (   95% )      ,    :   ,    .         100 ,          1000. <br><br>     ?    ,   . ,          realtime ,     .      (..      historical     realtime-),     . <br><br>    ,         :          . ,       ,    .    100 . ,   .           . <br><br>    .  80% ,   ,      ,    .             .    .      ,     selector,            .      ,   . <br><br><h2>   </h2><br>   ,      ,  ,    . ,        .        , 8    .     Druid.   ,    ,    Druid,       .      ,        .  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/917/10e/c6d91710e3436dc0feede42b3138baa0.png" width="500"><br><br>      ,  ,  .       .     ,       ,   .    .   27  . ,    27 , 27 . <br><br>   ,   .       27   ,    9,  9 ,    . <br>       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/710/585/fcb/710585fcb1dcf69e39a4a8e2faacc62f.png" width="500"><br><br>  ‚Äî : , , .   ‚Äî : , , .   ‚Äî :  ,  ,  .        ‚Äî ,        .    ,     .         ,      27.   9,  .          (   95% )    9 .        27    . <br><br>      14 . . ,      14 .   14 . .  ,          ,      10 ,     .    . <br><br><h2>   </h2><br>          ,  2 .       11   ,    74 .  ,       .        74 ?  ,         . <br> Druid    .      ,  ,    ,       .  ,         ,    .  ,    ,       .  ,    ,  . <br><br>    ,   Druid        .   ,      ( ) ,    .     5 :     ,       .       .          (     java),      .   Druid  ,    . <br><br><h2>  Zusammenfassung </h2><br>   , ,    SQL Server,       Microsoft. <br><br>     ,     /   . <br><br>         ,   ,       . <br><br>       20 ,          ,     18    . <br><br>       one-cloud ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/company/odnoklassniki/blog/346868/</a> ),      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420469/">https://habr.com/ru/post/de420469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420459/index.html">Symbol mit einem Z√§hler in der oberen Symbolleiste: Ein Beispiel f√ºr verschiedene Ans√§tze f√ºr eine Aufgabe</a></li>
<li><a href="../de420461/index.html">10 Zitate von schlechten Designern</a></li>
<li><a href="../de420463/index.html">ICO ist zu Recht im Niedergang, aber sie haben eine Chance, sich zu √§ndern</a></li>
<li><a href="../de420465/index.html">Nginx-Variablen mit njs: einfach, schmerzlos und √ºber JavaScript</a></li>
<li><a href="../de420467/index.html">C ++ - Wrapper f√ºr "alle" Echtzeitbetriebssysteme f√ºr CortexM4</a></li>
<li><a href="../de420471/index.html">Drei technische Berichte zur RIT 2018 von Plesk</a></li>
<li><a href="../de420473/index.html">B√ºcher f√ºr Anf√§nger oder warum es so wichtig ist zu lesen</a></li>
<li><a href="../de420475/index.html">Vergleich von Raylogic 11G- und Raylogic V12-Laserschneidmaschinen</a></li>
<li><a href="../de420477/index.html">HyperX Cloud Stinger Core-Test: Ein leichtes und robustes Charakter-Headset</a></li>
<li><a href="../de420479/index.html">Abh√§ngigkeitsinjektion im Apache Ignite.NET-Dienst</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>