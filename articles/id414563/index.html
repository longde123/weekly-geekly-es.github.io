<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍿 👨🏾‍🔧 🥠 Apa itu tes komponen, dan bagaimana rasanya menjadi SDET 👼🏾 👩🏿‍🤝‍👨🏼 👩‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anotasi 


 Artikel tersebut berbicara tentang bentuk tes yang tidak konvensional, tetapi bermanfaat, dan juga merangkum hasil tujuh tahun kerja dalam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa itu tes komponen, dan bagaimana rasanya menjadi SDET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414563/"><h1 id="annotaciya">  Anotasi </h1><br><p>  Artikel tersebut berbicara tentang bentuk tes yang tidak konvensional, tetapi bermanfaat, dan juga merangkum hasil tujuh tahun kerja dalam pengembangan tes. </p><br><h1 id="zachem-nuzhny-komponentnye-testy">  Mengapa Anda memerlukan tes komponen? </h1><br><p>  Bagaimanapun, ada, katakanlah, unit test yang menguji secara detail jeroan komponen.  Mereka benar-benar memverifikasi bahwa komponen bekerja sesuai dengan maksud pengembang.  Namun seringkali ini merupakan cek tombol, dan bukan bagaimana setelannya secara keseluruhan berada.  Dan tidak selalu perilaku yang dikandung oleh programmer bertepatan dengan apa yang diinginkan pelanggan. </p><br><p>  Dan ada, misalnya, tes penerimaan.  Dan mereka menghilangkan semua kekurangan ini.  Namun, sayangnya, mereka memperkenalkan yang baru.  Mereka lambat, sering tidak stabil, dan biasanya jinak.  Namun, mereka hanya menunjukkan masalah, tetapi tidak melokalkannya. </p><br><p>  Jelas, perlu muncul untuk tes menengah, yang akan menjadi rata-rata emas antara tes unit dan penerimaan.  Jalan tengah ini mungkin merupakan tes komponen. </p><a name="habracut"></a><br><h1 id="chto-takoe-komponentnye-testy">  Apa itu tes komponen? </h1><br><p>  Ini adalah tes untuk API komponen publik.  Dengan demikian, mereka ditulis dalam bahasa yang sama dengan komponen.  Tujuan Tes: </p><br><ul><li>  verifikasi kepatuhan komponen dengan kontrak Anda </li><li>  periksa kepatuhan <br>  Yang terakhir ini sangat penting sejak itu  unit test biasanya ditulis berdasarkan harapan pengembang, tetapi di sini Anda perlu memeriksa harapan pelanggan. </li></ul><br><p>  Jelas, tes komponen masuk akal ketika Anda memiliki komponen khusus dengan antarmuka yang luas.  Misalnya, perpustakaan dinamis atau objek COM.  Kemudian tes komponen akan memberikan efek maksimal. </p><br><h1 id="plyusy-k-testov">  Pro-tes k: </h1><br><ul><li>  <strong>Berikan stabilitas untuk pembangunan.</strong>  Jelas, pemeriksaan komprehensif antarmuka publik memungkinkan Anda untuk menjaga komponen dalam bentuk yang lebih atau kurang efisien. </li><li>  <strong>Secara akurat melokalisasi masalah.</strong>  Bahkan jika tes komponen itu sendiri cukup umum, itu selalu dapat didebug secara mendalam, dengan cepat mencapai kode pertempuran.  Dalam hal ini, lingkungan pengujian akan minimal dan secara otomatis dikonfigurasi. </li><li>  <strong>Mempercepat pengembangan dengan sejumlah pengembang yang kritis.</strong>  Programmer dikenal seperti kuda.  Jika seekor kuda menarik kereta dengan kapasitas 1 liter.  s., kemudian delapan kuda ditarik dengan kapasitas hanya sekitar 4 liter.  s  Dan penambahan pengembang lain ke tim (terutama di akhir proyek) sering tidak hanya tidak mempercepat, tetapi juga memperlambatnya.  Sementara penambahan pengembang uji komponen selalu merupakan nilai tambah, karena ia bertindak relatif independen dari tim: ia melakukan tes (pada dasarnya eksternal), mempercepat pembangunan build, mengoptimalkan file assembly, dll. </li><li>  <strong>Perjelas (dan kemudian verifikasi) persyaratan pelanggan.</strong>  Karena pengembang tes komponen tidak terikat pada implementasi, ia kurang terpengaruh oleh efek "Saya tahu bagaimana melakukannya sendiri".  Dalam hal persyaratan yang ambigu, pengembang biasa cenderung melakukannya dengan nyaman (lebih menarik, lebih cepat, lebih mudah).  Sedangkan ct-developer dalam hal ini cenderung menentukan apa yang sebenarnya diharapkan oleh pelanggan. </li><li>  <strong>Relatif stabil dan relatif cepat</strong> (dibandingkan dengan tes manual dan tes otomatis melalui antarmuka pengguna). </li></ul><br><h1 id="minusy-k-testov">  Kontra dari K-tes: </h1><br><ul><li>  <strong>Waktu untuk pengembangan dan dukungan.</strong>  Jelas, versi alpha produk, jika sebagian waktu dihabiskan untuk menulis tes komponen, akan muncul nanti.  Apakah akan ada keuntungan secara umum?  Apakah akan ada rilis lebih cepat?  Ini pertanyaan yang bagus.  Pendapat saya: ketika mengembangkan dengan tes komponen, rilis akan dirilis pada waktu yang hampir bersamaan.  Tapi - dengan rumor yang lebih sedikit dan lebih mudah diprediksi dari segi waktu.  Waktu pengembangan secara alami akan meningkat, waktu perbaikan bug dan stabilisasi akan berkurang.  Karena bagian kedua jauh kurang dapat diprediksi, pengurangannya akan memiliki efek menguntungkan pada jumlah pemrosesan dan kerumitan.  Namun, ini hanya pengalaman saya, dan kenyataannya mungkin berbeda.  Ada kemungkinan bahwa waktu yang dialokasikan untuk pengujian komponen akan tidak layak dihabiskan untuk menduplikasi pengujian unit yang ada. </li><li>  <strong>Kurang dipertukarkan.</strong>  Pemisahan peran meningkatkan efisiensi, tetapi mengurangi pertukaran.  Pengembang jarang ingin masuk jauh ke dalam pengujian komponen, yang dapat memiliki (atau mensimulasikan) lingkungan yang cukup kompleks.  Para pengembang tes komponen jauh dari mengetahui kode pertempuran dengan baik sehingga dapat dengan mudah diedit. </li><li>  <strong>Duplikasi yang menjengkelkan.</strong>  Dengan tes unit yang baik, uji komponen sering berubah menjadi kebanyakan berlebihan.  Ini menjengkelkan dan mempertanyakan kebutuhan mereka.  Koordinasi rencana unit dan pengujian komponen membantu, tetapi biasanya duplikasi tidak sepenuhnya dihilangkan. </li><li>  <strong>Kebutuhan untuk mengikuti alur kerja yang benar.</strong>  Setelah menerima persyaratan, tugas harus dilakukan secara bersamaan pada pengembang dan pengembang tes.  Kemudian mereka selesai bekerja pada waktu yang hampir bersamaan.  Komponen dijalankan melalui pengujian, kesalahan dengan cepat ditangkap dan diperbaiki, dan produk jadi lebih atau kurang digunakan untuk keluar.  Dalam hal ini, manfaat dari pengujian komponen dimaksimalkan.  Tetapi sering terjadi bahwa tenggat waktu lama tidak senonoh, semua ditinggalkan untuk menulis kode saja, dan komponen dikirim ke pengujian manual tanpa tes.  Dan hanya pada saat itu mereka mengundang pengembang tes - mereka mengatakan itu tidak baik bahwa kode tanpa tes telah dirilis, perlu menambahkannya.  Dalam hal ini, sebagian besar bug adalah penguji genggam, pengembang membuat koreksi secara membabi buta (atau menguji pengeditan sendiri dengan tangan mereka), dan tes post-factum hanya menemukan sejumlah kecil kesalahan (yang secara negatif mempengaruhi moral penulis mereka).  Penggunaan tes komponen seperti itu tidak berguna sama sekali, dan sulit untuk memastikannya. </li><li>  <strong>Ada beberapa orang yang cocok.</strong>  Pengembang tes komponen harus, di satu sisi, dapat menulis kode dalam bahasa komponen (dan ini, misalnya, C ++).  Selain itu, jika lingkungan untuk meluncurkan komponen sangat luas, kodenya bisa sangat rumit.  Dan di sisi lain, dapat dengan cermat menguji pekerjaan orang lain.  Tidak banyak orang seperti itu, dan mereka biasanya langsung pergi ke pengembang.  Tetapi masih ada orang-orang seperti itu, dan bagian selanjutnya tentang mereka. </li></ul><br><h1 id="rezyume-1">  Ringkasan 1 </h1><br><p>  Tes komponen baik, tetapi hanya jika Anda memiliki semua kondisi untuk mereka: API publik yang luas, alur kerja yang tepat, dan orang yang tepat dalam tim. </p><br><h1 id="kakovo-byt-sdetom">  Seperti apa rasanya menjadi SDET? </h1><br><p>  Jelas, SDET - Software Development Engineer dalam Test adalah kandidat yang ideal untuk menulis tes komponen.  Dia tahu cara menulis kode, dan tahu cara berpikir dalam ujian.  Ini juga memberikan pendapat kedua, yang juga meningkatkan kualitas tes dan kode.  Semua ini terdengar menarik dan menggoda - mungkin Anda sudah ingin menjadi satu.  Di sini saya secara singkat akan memberi tahu Anda bagaimana pekerjaan SDET berbeda dari pekerjaan pengembang murni. </p><br><h1 id="plyusy-raboty-sdetom">  Keuntungan bekerja dengan SDET: </h1><br><ul><li>  <strong>Kode baru</strong>  Hampir selalu, SDET menulis tes dari awal.  Dan cukup sering, suatu lingkungan ditulis dari awal.  Ini sangat bagus dan memberi ruang besar untuk kreativitas. </li><li>  <strong>Ketergantungan yang rendah pada kode sebelumnya.</strong>  Tidak peduli seberapa buruk kode pertempuran itu, tes untuk itu dapat dilakukan dengan kompeten dan indah.  Tentu saja, kode yang dirancang dengan buruk menghasilkan tes yang jelek, tetapi tetap saja mereka dapat dibuat urutan besarnya lebih baik daripada kode itu sendiri. </li><li>  <strong>Refactoring yang lebih sering.</strong>  Perubahan dalam tes jauh lebih tidak berbahaya, oleh karena itu, mereka lebih sering disetujui.  Ini adalah peluang bagus untuk mengatasi bug dan berlatih menulis kode bersih melalui refactoring. </li><li>  <strong>Perkembangan pemikiran kritis.</strong>  Autotests adalah pencarian menarik untuk memecahkan kode orang lain.  Selain itu, pencarian tidak bodoh, tidak duduk dan menyodok, tetapi dengan bantuan logika, kombinatorik dan kemampuan untuk melihat kerentanan.  Ditambah sekali dibuat cek akan terus bekerja untuk Anda secara konstan. </li><li>  <strong>Mengembangkan kemampuan untuk menguji kode.</strong>  Dalam pelatihan tempur tangan-ke-tangan, mereka sering memberikan kata-kata pengantar: "sekarang kita hanya bekerja dengan kaki kita; sekarang kita hanya bekerja dengan kepala kita."  Hanya menggunakan satu mekanisme (dalam kasus kami, autotes) memungkinkan Anda untuk mengasahnya untuk penguasaan. </li><li>  <strong>Jumlah rumor lebih sedikit.</strong>  SDET ditarik jauh lebih sedikit untuk akhir pekan.  Mereka tidak harus segera bekerja untuk memperbaiki bug yang kritis.  Yah, mereka memiliki peluang jauh lebih rendah untuk melakukan kesalahan serius. </li></ul><br><h1 id="minusy-raboty-sdetom">  Kontra bekerja dengan SDET: </h1><br><ul><li>  <strong>Kompleksitas coding rendah.</strong>  Kode tes biasanya masih lebih sederhana daripada kode pertempuran.  Prasyarat, memanggil kode pertempuran, postkondisi - dan seterusnya untuk setiap tes.  Kode untuk menciptakan lingkungan lebih rumit, tetapi masih belum mencapai pertempuran.  Pemilihan algoritma yang optimal, merancang struktur data yang kompleks, membangun hierarki kelas - biasanya semua ini dilewati oleh pengembang pengujian. </li><li>  <strong>Pengalaman semakin lambat</strong> .  Variasi dan kompleksitas situasi di mana pengembang tes jatuh jauh lebih sedikit.  Kegagalan jalur perakitan, tes merah, kadang-kadang dump - ini adalah set utama yang biasanya harus Anda kerjakan.  Pengembang memiliki jauh lebih banyak masalah: mulai dari menghubungkan dan variasi perakitan, melanjutkan dengan gangguan pada pelanggan tertentu dan membuat dump, berakhir dengan mencari bug di kompiler dan perpustakaan pihak ketiga.  Dan tidak hanya ... </li><li>  <strong>Perbedaan utama dalam gaya pengujian dengan pengembang.</strong>  Biasanya, SDET lebih suka tes ekspresif kompak yang memungkinkan Anda untuk membuat lingkungan yang kompleks hanya dalam beberapa baris, dan pemeriksaan atom dalam gaya sama / tidak sama (yaitu, persyaratan terpenuhi atau tidak).  Kadang-kadang datang ke DSL-nya.  Sederhananya, pengembang lebih suka tes dengan menyesuaikan lingkungan dan berbagai tes dari berbagai aspek perilaku program, yang mengarah ke tes multi-line.  Kadang-kadang menyangkut copy-paste (yang bahkan pengembang terbaik tidak menganggap dosa dalam kasus ini).  Di sini Anda dapat berdiskusi lama tentang cara terbaik atau bahkan menulis artikel terpisah, tetapi faktanya adalah ketika pengembang mencoba memodifikasi tes SDET (atau sebaliknya), ini sering mengarah pada diskusi yang panjang dan tidak efektif. </li><li>  <strong>Di bawah ini adalah "kelas".</strong>  Mungkin karena kode lebih sederhana dan kurang tanggung jawab, tetapi pada akhirnya tidak penting.  Biasanya seperti itu. </li><li>  <strong>Lebih sulit untuk pindah ke posisi baru.</strong>  SDET mungkin mendapatkan pertanyaan di dahi: Anda telah menulis tes begitu lama, yaitu, sebenarnya, Anda baru saja memanggil fungsi dan membandingkan hasilnya - dapatkah Anda menulis kode nyata?  Apakah Anda tahu semua perangkap bahasa?  Apakah Anda memecahkan masalah yang rumit?  Apakah Anda harus membongkar bug atau dump berornamen?  Apakah ada pengalaman dengan multithreading?  Apakah Anda, bagaimanapun, memiliki ambisi? </li></ul><br><h1 id="rezyume-2">  Ringkasan 2 </h1><br><p>  Sebagai orang yang bekerja sebagai pengembang selama bertahun-tahun, kemudian pergi ke SDET selama beberapa tahun, dan kemudian kembali ke pengembangan lagi, saya dapat mengatakan yang berikut. </p><br><p>  Saya sangat merekomendasikan menghabiskan SDET untuk setidaknya satu atau dua tahun.  Ini adalah pengalaman yang sangat berharga bagi pengembang mana pun.  Tetapi untuk tinggal di sana, menurut saya, tidak sepadan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414563/">https://habr.com/ru/post/id414563/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414549/index.html">3.000 mata untuk kecerdasan buatan. Apa sistem pemantauan struktur dari Pusat Lakhta?</a></li>
<li><a href="../id414551/index.html">Petunjuk Pendaftaran PhD AS</a></li>
<li><a href="../id414555/index.html">Bagaimana kami mentransfer 36 juta pelanggan ke layanan dukungan teknis digital</a></li>
<li><a href="../id414557/index.html">Peretasan smart meter di PHDays 8: analisis kontes MeterH3cker</a></li>
<li><a href="../id414561/index.html">Sekolah video game Prancis: Dunia Lain</a></li>
<li><a href="../id414565/index.html">Lampu untuk perabotan, dapur, atau kamar mandi</a></li>
<li><a href="../id414567/index.html">Pengumuman RamblerFront & # 5</a></li>
<li><a href="../id414569/index.html">Terumbu karang menyimpan rahasia masa lalu dan masa depan lautan</a></li>
<li><a href="../id414571/index.html">Relativitas GPS yang tak terduga masuk ke dalam otak</a></li>
<li><a href="../id414573/index.html">IP DoorBell - Bel Interaktif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>