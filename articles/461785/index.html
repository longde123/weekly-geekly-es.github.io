<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèª üÜô üïâÔ∏è Desventajas de RISC-V üë©üèΩ‚Äçü§ù‚Äçüë©üèª üé™ üë®üèΩ‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inicialmente, escrib√≠ este documento hace varios a√±os, como un ingeniero de verificaci√≥n de ejecuci√≥n en ARM. Por supuesto, mi opini√≥n fue influenciad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desventajas de RISC-V</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461785/">  Inicialmente, escrib√≠ este documento hace varios a√±os, como un ingeniero de verificaci√≥n de ejecuci√≥n en ARM.  Por supuesto, mi opini√≥n fue influenciada por el trabajo en profundidad con los n√∫cleos ejecutivos de diferentes procesadores.  As√≠ que hazlo con un descuento, por favor: tal vez soy demasiado categ√≥rico. <br><br>  Sin embargo, todav√≠a creo que los creadores de RISC-V podr√≠an hacerlo mucho mejor.  Por otro lado, si hubiera dise√±ado un procesador de 32 bits o 64 bits hoy, probablemente habr√≠a implementado tal arquitectura para aprovechar las herramientas existentes. <br><br>  El art√≠culo describi√≥ originalmente el conjunto de instrucciones RISC-V 2.0.  Para la versi√≥n 2.2, realiz√≥ algunas actualizaciones. <br><a name="habracut"></a><br><h1>  Pr√≥logo original: alguna opini√≥n personal </h1><br>  El conjunto de instrucciones RISC-V se ha reducido a un m√≠nimo absoluto.  Se presta mucha atenci√≥n a minimizar el n√∫mero de instrucciones, normalizar la codificaci√≥n, etc. Este deseo de minimalismo ha llevado a una ortogonalidad falsa (como reutilizar la misma instrucci√≥n para transiciones, llamadas y devoluciones) y verbosidad obligatoria, que infla el tama√±o y la cantidad. instrucciones <br><br>  Por ejemplo, aqu√≠ est√° el c√≥digo C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readidx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[idx]; }</code> </pre> <br>  Este es un caso simple de indexar una matriz, una operaci√≥n muy com√∫n.  Esta es la compilaci√≥n para x86_64: <br><br><pre> <code class="plaintext hljs">mov eax, [rdi+rsi*4] ret</code> </pre> <br>  o BRAZO: <br><br><pre> <code class="plaintext hljs">ldr r0, [r0, r1, lsl #2] bx lr // return</code> </pre> <br>  Sin embargo, para RISC-V, se requiere el siguiente c√≥digo: <br><br><pre> <code class="plaintext hljs">slli a1, a1, 2 add a0, a1, a1 lw a0, a0, 0 jalr r0, r1, 0 // return</code> </pre> <br>  Simplificaci√≥n RISC-V simplifica el decodificador (es decir, el front-end de la CPU) al ejecutar m√°s instrucciones.  Pero escalar el ancho de la tuber√≠a es un problema dif√≠cil, mientras que la decodificaci√≥n de instrucciones irregulares ligeramente (o muy fuertes) est√° bien implementada (la principal dificultad surge cuando es dif√≠cil determinar la longitud de la instrucci√≥n: esto es especialmente evidente en el conjunto de instrucciones x86 con numerosos prefijos). <br><br>  La simplificaci√≥n del conjunto de instrucciones no debe llevarse al l√≠mite.  El registro y la suma de registros con un cambio de la memoria de registro es una instrucci√≥n simple y muy com√∫n en los programas, y es muy f√°cil para el procesador implementarla de manera efectiva.  Si el procesador no puede implementar la instrucci√≥n directamente, entonces puede ser relativamente f√°cil dividirla en sus componentes;  Este es un problema mucho m√°s simple que fusionar secuencias de operaciones simples. <br><br>  Debemos distinguir entre las instrucciones espec√≠ficas "complejas" de los procesadores CISC (instrucciones complicadas, poco utilizadas e ineficientes) de las instrucciones "funcionales" comunes a los procesadores CISC y RISC, que combinan una peque√±a secuencia de operaciones.  Estos √∫ltimos se utilizan con frecuencia y con alto rendimiento. <br><br><h1>  Implementaci√≥n mediocre </h1><br><ul><li>  Extensibilidad casi ilimitada.  Aunque este es el objetivo de RISC-V, crea un ecosistema fragmentado e incompatible que debe manejarse con extrema precauci√≥n. <br></li><li>  La misma instrucci√≥n ( <code>JALR</code> ) se usa para llamadas y para devoluciones, y para ramas indirectas de registro, donde se requiere decodificaci√≥n adicional para la predicci√≥n de ramas <br><ul><li>  Llamar: <code>Rd</code> = <code>R1</code> <br></li><li>  Retorno: <code>Rd</code> = <code>R0</code> , <code>Rs</code> = <code>R1</code> <br></li><li>  Transici√≥n indirecta: <code>Rd</code> = <code>R0</code> , <code>Rs</code> ‚â† <code>R1</code> <br></li><li>  (Transici√≥n extra√±a: <code>Rd</code> ‚â† <code>R0</code> , <code>Rd</code> ‚â† <code>R1</code> ) </li></ul></li><li>  La codificaci√≥n de longitud variable del campo de grabaci√≥n no se sincroniza autom√°ticamente (esto es com√∫n, por ejemplo, un problema similar con x86 y Thumb-2), pero esto causa varios problemas con la implementaci√≥n y la seguridad, por ejemplo, la programaci√≥n orientada hacia atr√°s, es decir, ataques ROP ) <br></li><li>  RV64I requiere una extensi√≥n de caracteres para todos los valores de 32 bits.  Esto lleva al hecho de que la mitad superior de los registros de 64 bits se vuelve imposible de usar para almacenar resultados intermedios, lo que lleva a una colocaci√≥n especial innecesaria de la mitad superior de los registros.  Es m√°s √≥ptimo usar la extensi√≥n con ceros (ya que reduce el n√∫mero de conmutaciones y, por lo general, puede optimizarse rastreando el bit "cero" cuando se sabe que la mitad superior es cero) <br></li><li>  La multiplicaci√≥n es opcional.  Aunque los bloques de multiplicaci√≥n r√°pida pueden ocupar un √°rea bastante considerable en cristales diminutos, siempre puede usar circuitos ligeramente m√°s lentos que usan activamente la ALU existente para m√∫ltiples ciclos de multiplicaci√≥n. <br></li><li>  <code>LR</code> / <code>SC</code> requisitos de progresi√≥n estrictos para un subconjunto limitado de aplicaciones.  Aunque esta restricci√≥n es bastante estricta, potencialmente crea algunos problemas para implementaciones peque√±as (especialmente sin un cach√©) <br><ul><li>  Esto parece un reemplazo para la instrucci√≥n CAS, vea el comentario a continuaci√≥n </li></ul></li><li>  Los bits fijos de memoria FP y el modo de redondeo est√°n en el mismo registro.  Esto requiere la serializaci√≥n del canal FP si la operaci√≥n RMW se realiza para cambiar el modo de redondeo. <br></li><li>  <code>FP</code> instrucciones de <code>FP</code> est√°n codificadas para una precisi√≥n de 32, 64 y 128 bits, pero no de 16 bits (que es mucho m√°s com√∫n en hardware que 128 bits) <br><ul><li>  Esto se puede solucionar f√°cilmente: el c√≥digo de dimensi√≥n <code>0b10</code> gratuito. <br></li><li>  <i>Actualizaci√≥n: el</i> marcador de posici√≥n <i>decimal</i> apareci√≥ en la versi√≥n 2.2, pero no hay un marcador de posici√≥n de media precisi√≥n.  La mente es incomprensible. </li></ul></li><li>  La forma en que se representan los valores FP en el archivo de registro FP no est√° definida, pero es observable (a trav√©s de carga / almacenamiento) <br><ul><li>  Los autores del emulador te odiar√°n <br></li><li>  La migraci√≥n de m√°quinas virtuales puede volverse imposible <br></li><li>  <i>Actualizaci√≥n: la</i> versi√≥n 2.2 requiere valores de boxeo NaN m√°s amplios </li></ul></li></ul><br><h1>  Mal </h1><br><ul><li>  No hay c√≥digos de condici√≥n, y en su lugar se utilizan las declaraciones de comparaci√≥n y ramificaci√≥n.  Esto no es un problema en s√≠ mismo, pero las consecuencias son desagradables: <br><ul><li>  Espacio de codificaci√≥n reducido en ramas condicionales debido a la necesidad de codificar uno o dos especificadores de registro <br></li><li>  Sin elecci√≥n condicional (√∫til para transiciones muy impredecibles) <br></li><li>  Sin transferencia / sustracci√≥n con transferencia o pr√©stamo <br></li><li>  (Tenga en cuenta que esto es a√∫n mejor que los conjuntos de comandos que escriben banderas en el registro general y luego cambian a las banderas recibidas) </li></ul></li><li>  Parece que <i>se requieren</i> contadores de alta precisi√≥n (ciclos de hardware) en un ISA sin privilegios.  En la pr√°ctica, proporcionarles aplicaciones es un excelente vector para ataques en canales de terceros. <br></li><li>  La multiplicaci√≥n y la divisi√≥n son parte de la misma extensi√≥n, y parece que si uno se implementa, el otro tambi√©n deber√≠a serlo.  La multiplicaci√≥n es mucho m√°s simple que la divisi√≥n, y es com√∫n en la mayor√≠a de los procesadores, pero la divisi√≥n no lo es. <br></li><li>  No hay instrucciones at√≥micas en la arquitectura del conjunto de instrucciones b√°sicas.  Los microcontroladores multin√∫cleo se est√°n volviendo m√°s comunes, por lo que las instrucciones at√≥micas como LL / SC son econ√≥micas (para una implementaci√≥n m√≠nima dentro de un √∫nico procesador [multin√∫cleo], solo se necesita 1 bit de estado del procesador) <br></li><li>  <code>LR</code> / <code>SC</code> est√°n en la misma extensi√≥n que las instrucciones at√≥micas m√°s complejas, lo que limita la flexibilidad para implementaciones peque√±as <br></li><li>  Las instrucciones at√≥micas generales (no <code>LR</code> / <code>SC</code> ) no incluyen primitiva <code>CAS</code> <br><ul><li>  El <code>CmpHi:CmpLo</code> evitar la necesidad de una instrucci√≥n que lea cinco registros ( <code>Addr</code> , <code>CmpHi:CmpLo</code> , <code>SwapHi:SwapLo</code> ), pero esto probablemente impondr√° menos sobrecarga de implementaci√≥n que el <code>LR</code> / <code>SC</code> reenv√≠o garantizado, que se proporciona como reemplazos </li></ul></li><li>  Se ofrecen instrucciones at√≥micas que funcionan en valores de 32 bits y 64 bits, pero no en valores de 8 o 16 bits. <br></li><li>  Para RV32I, no hay forma de transferir el valor DP FP entre un n√∫mero entero y un archivo de registro FP, excepto a trav√©s de la memoria, es decir, desde registros enteros de 32 bits es imposible hacer un n√∫mero de coma flotante de precisi√≥n doble de 64 bits, primero debe escribir el valor intermedio en la memoria y cargar √©l en el archivo de registro desde all√≠ <br></li><li>  Por ejemplo, la instrucci√≥n <code>ADD</code> 32 bits en RV32I y la <code>ADD</code> 64 bits en RVI64 tienen las mismas codificaciones, y en RVI64 se agrega otra codificaci√≥n <code>ADD.W</code>  Esta es una complicaci√≥n innecesaria para un procesador que implementa ambas instrucciones; ser√≠a preferible agregar una nueva codificaci√≥n de 64 bits. <br></li><li>  No hay instrucciones <code>MOV</code> .  El ensamblador traduce el c√≥digo mnem√≥nico del comando <code>MV</code> a la instrucci√≥n <code>MV rD, rS</code> -&gt; <code>ADDI rD, rS, 0</code> .  Los procesadores de alto rendimiento generalmente optimizan las instrucciones <code>MOV</code> , mientras reordenan ampliamente las instrucciones.  Se eligi√≥ una instrucci√≥n con un operando directo de 12 bits como la forma can√≥nica de la instrucci√≥n <code>MV</code> en RISC-V. <br><ul><li>  En ausencia de <code>MOV</code> la instrucci√≥n <code>ADD rD, rS, r0</code> vuelve preferible al <code>MOV</code> can√≥nico, ya que es m√°s f√°cil de decodificar, y las operaciones con registro cero (r0) en la CPU generalmente est√°n optimizadas </li></ul></li></ul><br><h1>  Horrible </h1><br><ul><li>  <code>JAL</code> gasta 5 bits en la codificaci√≥n del registro de comunicaci√≥n, que siempre es igual a <code>R1</code> (o <code>R0</code> para las transiciones) <br><ul><li>  Esto significa que el RV32I usa un desplazamiento de rama de 21 bits.  Esto no es suficiente para aplicaciones grandes, por ejemplo, navegadores web, sin usar m√∫ltiples secuencias de comandos y / o "islas sucursales" <br></li><li>  ¬°Esto es un deterioro en comparaci√≥n con la versi√≥n 1.0 de la arquitectura de comandos! </li></ul></li><li>  A pesar del gran esfuerzo para codificar uniformemente, las instrucciones de carga / almacenamiento se codifican de manera diferente (el caso y los campos inmediatos cambian) <br><ul><li>  Aparentemente, la ortogonalidad de codificaci√≥n del registro de salida era preferible a la ortogonalidad de codificaci√≥n de dos instrucciones fuertemente relacionadas.  Esta elecci√≥n parece un poco extra√±a dado que la generaci√≥n de direcciones es m√°s cr√≠tica en el tiempo. </li></ul></li><li>  No hay instrucciones de carga de memoria con compensaciones de registro ( <code>Rbase</code> + <code>Roffset</code> ) o √≠ndices ( <code>Rbase</code> + <code>Rindex</code> &lt;&lt; <code>Scale</code> ). <br></li><li>  <code>FENCE.I</code> implica una sincronizaci√≥n completa del cach√© de instrucciones con todos los repositorios anteriores, con o sin vallado.  Las implementaciones deben borrar todo I $ en la cerca o buscar D $ y el b√∫fer de almacenamiento <br></li><li>  En RV32I, la lectura de contadores de 64 bits requiere leer la mitad superior dos veces, comparar y ramificar en el caso de transferir entre la mitad inferior y superior durante una operaci√≥n de lectura <br><ul><li>  Normalmente, los ISA de 32 bits incluyen una instrucci√≥n de registro de lectura de pares especiales para evitar este problema. </li></ul></li><li>  No hay un espacio definido arquitect√≥nicamente para la codificaci√≥n de sugerencias, por lo que las instrucciones de este espacio no causan un error en los procesadores m√°s antiguos (procesados ‚Äã‚Äãcomo <code>NOP</code> ), sino que hacen algo en las CPU m√°s modernas <br><ul><li>  Ejemplos t√≠picos de pistas de NOP puro son cosas como el rendimiento de spinlock <br></li><li>  Los procesadores m√°s nuevos tambi√©n tienen pistas m√°s sofisticadas (con efectos secundarios visibles en los procesadores m√°s nuevos; por ejemplo, las instrucciones de verificaci√≥n de bordes x86 est√°n codificadas en el espacio de pistas para que los binarios sigan siendo compatibles con versiones anteriores) </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461785/">https://habr.com/ru/post/461785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461771/index.html">Di no al silencio: de la guarder√≠a a la oficina</a></li>
<li><a href="../461773/index.html">Airtest IDE: ¬øuna nueva forma de probar la automatizaci√≥n de los juegos m√≥viles?</a></li>
<li><a href="../461775/index.html">3 casos para usar Celery en una aplicaci√≥n Django</a></li>
<li><a href="../461779/index.html">El 80% de los datos de su empresa no est√° disponible para usted. ¬øQu√© hacer al respecto?</a></li>
<li><a href="../461781/index.html">"Ycombinator Startup School 2019." Video de las primeras tres semanas</a></li>
<li><a href="../461787/index.html">Pantalla de texto de Android</a></li>
<li><a href="../461793/index.html">Ivan Ponomarev sobre Kafka Streams API en la reuni√≥n jug.msk.ru</a></li>
<li><a href="../461797/index.html">Cuentos de servicio. Una publicaci√≥n fr√≠vola sobre trabajo serio</a></li>
<li><a href="../461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../461803/index.html">Data Version Control (DVC): control de versiones de datos y reproducibilidad de experimentos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>