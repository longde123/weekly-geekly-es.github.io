<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèº üòÜ üñáÔ∏è C√≥mo funciona JS: clases y herencia, transpilaci√≥n en Babel y TypeScript ‚õèÔ∏è ü•ó üå∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las clases son una de las formas m√°s populares de estructurar proyectos de software en estos d√≠as. Este enfoque de programaci√≥n tambi√©n se usa en Java...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona JS: clases y herencia, transpilaci√≥n en Babel y TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415377/">  Las clases son una de las formas m√°s populares de estructurar proyectos de software en estos d√≠as.  Este enfoque de programaci√≥n tambi√©n se usa en JavaScript.  Hoy publicamos una traducci√≥n de la parte 15 de la serie de ecosistemas JS.  Este art√≠culo discutir√° varios enfoques para implementar clases en JavaScript, mecanismos de herencia y transpiraci√≥n.  Comenzaremos dici√©ndole c√≥mo funcionan los prototipos y analizando varias formas de simular la herencia basada en clases en bibliotecas populares.  A continuaci√≥n, hablaremos sobre c√≥mo, gracias a la transpilaci√≥n, es posible escribir programas JS que utilicen funciones que no est√°n disponibles en el idioma o, aunque existen en forma de nuevos est√°ndares o propuestas que se encuentran en diferentes etapas de aprobaci√≥n, a√∫n no se implementan en JS- motores  En particular, hablaremos sobre Babel y TypeScript y las clases ECMAScript 2015. Despu√©s de eso, veremos algunos ejemplos que demuestran las caracter√≠sticas de la implementaci√≥n interna de clases en el motor V8 JS. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/196/736/c87/196736c87449034c2354db7c52f1cd08.png" alt="imagen"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[Recomendar lectura] Las otras 19 partes del ciclo</b> <div class="spoiler_text"> Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de los componentes internos V8 y la optimizaci√≥n del c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrar la memoria, cuatro tipos de p√©rdidas de memoria y tratar con ellas</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bucle de eventos, as√≠ncrono y cinco formas de mejorar su c√≥digo con as√≠ncrono / espera</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebSocket y HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que elegir</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caracter√≠sticas y alcance de WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores web y cinco escenarios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores de servicio</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notificaciones push web</a> <br>  Parte 10: realizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los cambios en el DOM con MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motores de representaci√≥n de p√°ginas web y consejos para optimizar su rendimiento</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Animaci√≥n con CSS y JavaScript.</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: clases y herencia, transpilaci√≥n en Babel y TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: almacenamiento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: tecnolog√≠a Shadow DOM y componentes web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Mecanismos de comunicaci√≥n WebRTC y P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Elementos personalizados</a> </div></div><br><h2>  <font color="#3AC1EF">Revisar</font> </h2><br>  En JavaScript, nos enfrentamos constantemente con objetos, incluso cuando parece que estamos trabajando con tipos de datos primitivos.  Por ejemplo, cree un literal de cadena: <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>;</code> </pre> <br>  Despu√©s de eso, podemos pasar inmediatamente al <code>name</code> para llamar a varios m√©todos de un objeto de tipo <code>String</code> , al que el literal de cadena que creamos se convertir√° autom√°ticamente. <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">2</span></span>)); // SessionStackSessionStack console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.toLowerCase()); // sessionstack</code> </pre> <br>  A diferencia de otros lenguajes, en JavaScript, despu√©s de haber creado una variable que contiene, por ejemplo, una cadena o un n√∫mero, podemos, sin realizar una conversi√≥n expl√≠cita, trabajar con esta variable como si se hubiera creado originalmente usando la <code>new</code> palabra clave y el constructor correspondiente.  Como resultado, debido a la creaci√≥n autom√°tica de objetos que encapsulan valores primitivos, puede trabajar con valores como si fueran objetos, en particular, consulte sus m√©todos y propiedades. <br><br>  Otro hecho notable con respecto al sistema de tipo JavaScript es que, por ejemplo, las matrices tambi√©n son objetos.  Si observa el resultado del comando <code>typeof</code> para la matriz, puede ver que informa que la entidad bajo investigaci√≥n tiene el tipo de datos del <code>object</code> .  Como resultado, resulta que los √≠ndices de los elementos de la matriz son solo propiedades de un objeto en particular.  Por lo tanto, cuando accedemos a un elemento de una matriz por √≠ndice, todo se reduce a trabajar con una propiedad de un objeto de tipo <code>Array</code> y obtener el valor de esta propiedad.  Si hablamos de c√≥mo se almacenan los datos dentro de objetos y matrices ordinarios, las siguientes dos construcciones conducen a la creaci√≥n de estructuras de datos casi id√©nticas: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = [<span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = { <span class="hljs-string"><span class="hljs-string">"0"</span></span>: <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>, <span class="hljs-string"><span class="hljs-string">"length"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Como resultado, el acceso a los elementos de la matriz y a las propiedades del objeto se realiza a la misma velocidad.  El autor de este art√≠culo dice que descubri√≥ en el curso de la resoluci√≥n de un problema complejo.  Es decir, una vez que necesitaba llevar a cabo una optimizaci√≥n seria de una pieza de c√≥digo muy importante en el proyecto.  Despu√©s de intentar muchos enfoques simples, decidi√≥ reemplazar todos los objetos utilizados en este c√≥digo con matrices.  En teor√≠a, acceder a los elementos de la matriz es m√°s r√°pido que trabajar con claves de tabla hash.  Para su sorpresa, este reemplazo no afect√≥ el rendimiento de ninguna manera, ya que trabajar con matrices y trabajar con objetos en JavaScript se reduce a interactuar con las teclas de tabla hash, lo que, en cualquier caso, requiere la misma cantidad de tiempo. <br><br><h2>  <font color="#3AC1EF">Simulando clases usando prototipos</font> </h2><br>  Cuando pensamos en objetos, lo primero que viene a la mente son las clases.  Quiz√°s cada uno de los que se dedican a la programaci√≥n de hoy cre√≥ aplicaciones cuya estructura se basa en las clases y en las relaciones entre ellas.  Aunque los objetos en JavaScript se pueden encontrar literalmente en todas partes, el lenguaje no utiliza un sistema tradicional de herencia basado en clases.  JavaScript usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prototipos</a> para resolver problemas similares. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/ba7/cab/633ba7cabdf251ed3747fb2a3764b344.png"></div><br>  <i><font color="#999999">Objeto y su prototipo</font></i> <br><br>  En JavaScript, cada objeto est√° asociado con otro objeto, con su propio prototipo.  Cuando intenta acceder a una propiedad o m√©todo de un objeto, la b√∫squeda de lo que necesita se realiza primero en el objeto mismo.  Si la b√∫squeda no tiene √©xito, contin√∫a en el prototipo del objeto. <br><br>  Considere un ejemplo simple que describe una funci√≥n constructora para la clase base <code>Component</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content); }</code> </pre> <br>  Aqu√≠ asignamos la funci√≥n <code>render()</code> al m√©todo prototipo, ya que necesitamos cada instancia de la clase <code>Component</code> para usar este m√©todo.  Cuando, en cualquier caso de <code>Component</code> , se llama al m√©todo de representaci√≥n, su b√∫squeda comienza en el propio objeto para el que se llama.  Luego, la b√∫squeda contin√∫a en el prototipo, donde el sistema encuentra este m√©todo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/6d8/74d/5536d874d81cc44b164174953614f725.png"></div><br>  <i><font color="#999999">Prototipo y dos instancias de la clase Componente</font></i> <br><br>  Ahora intentemos extender la clase <code>Component</code> .  <code>InputField</code> un constructor para una nueva clase - <code>InputField</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   this.content = `&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{value}"</span></span> /&gt;`; }</code> </pre> <br>  Si necesitamos la clase <code>InputField</code> ampliar la funcionalidad de la clase <code>Component</code> y poder llamar a su m√©todo de <code>render</code> , debemos cambiar su prototipo.  Cuando se llama a un m√©todo en una instancia de una clase secundaria, buscarlo en un prototipo vac√≠o no tiene sentido.  Necesitamos, en la b√∫squeda de este m√©todo, encontrarnos en la clase <code>Component</code> .  Por lo tanto, debemos hacer lo siguiente: <br><br><pre> <code class="hljs pgsql">InputField.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Component());</code> </pre> <br>  Ahora, cuando trabaje con una instancia de la clase <code>InputField</code> y llame al m√©todo de la clase <code>Component</code> , este m√©todo se encontrar√° en el prototipo de la clase <code>Component</code> .  Para implementar el sistema de herencia, debe conectar el prototipo <code>InputField</code> a una instancia de la clase <code>Component</code> .  Muchas bibliotecas usan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.setPrototypeOf ()</a> para resolver este problema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/c43/ba8/f5cc43ba8e7a66cf1bb5c8aecec04572.png"></div><br>  <i><font color="#999999">Extendiendo la Clase Componente con la Clase InputField</font></i> <br><br>  Sin embargo, las acciones anteriores no son suficientes para implementar un mecanismo similar a la herencia tradicional.  Cada vez que ampliamos la clase, debemos realizar las siguientes acciones: <br><br><ul><li>  Convierta el prototipo de la clase descendiente en una instancia de la clase padre. </li><li>  Llame, en el constructor de la clase descendiente, al constructor de la clase principal para asegurarse de que la clase principal se inicialice correctamente. </li><li>  Proporcione un mecanismo para llamar a los m√©todos de la clase principal en situaciones en las que la clase descendiente anula el m√©todo principal, pero es necesario llamar a la implementaci√≥n original de este m√©todo desde la clase principal. </li></ul><br>  Como puede ver, si un desarrollador de JS quiere usar las capacidades de herencia basada en clases, tendr√° que realizar constantemente los pasos anteriores.  En el caso de que necesite crear muchas clases, todo esto puede hacerse en forma de funciones adecuadas para su reutilizaci√≥n. <br><br>  De hecho, la tarea de organizar la herencia basada en clases se resolvi√≥ inicialmente en la pr√°ctica del desarrollo JS de esta manera.  En particular, utilizando varias bibliotecas.  Tales soluciones se hicieron muy populares, lo que indicaba claramente que faltaba algo en JavaScript.  Es por eso que ECMAScript 2015 introdujo nuevas construcciones sint√°cticas destinadas a apoyar el trabajo con clases y a implementar los mecanismos de herencia correspondientes. <br><br><h2>  <font color="#3AC1EF">Transpilaci√≥n de clase</font> </h2><br>  Despu√©s de que se propusieron las nuevas caracter√≠sticas de ECMAScript 2015 (ES6), la comunidad de desarrolladores de JS quer√≠a usarlas lo antes posible, sin esperar la finalizaci√≥n del largo proceso de agregar soporte para estas caracter√≠sticas en los motores y navegadores JS.  Al resolver tales problemas, la transpilaci√≥n es buena.  En este caso, la compilaci√≥n se reduce a transformar el c√≥digo JS escrito de acuerdo con las reglas de ES6 en una vista que sea comprensible para los navegadores que a√∫n no admiten las capacidades de ES6.  Como resultado, por ejemplo, es posible declarar clases e implementar mecanismos de herencia basados ‚Äã‚Äãen clases de acuerdo con las reglas de ES6 y convertir estas construcciones en c√≥digo que funcione en cualquier navegador.  Esquem√°ticamente, este proceso, usando el ejemplo de procesar una funci√≥n de flecha por un transpilador (otra nueva funci√≥n de lenguaje que necesita tiempo para ser compatible), se puede representar como se muestra en la figura a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/37b/f2c/80237bf2c453fb8f9d7913c310a21384.png"></div><br>  <i><font color="#999999">Transpilacion</font></i> <br><br>  Uno de los transpiladores JavaScript m√°s populares es Babel.js.  Veamos c√≥mo funciona realizando una compilaci√≥n del c√≥digo de declaraci√≥n de la clase <code>Component</code> , del que hablamos anteriormente.  Entonces aqu√≠ est√° el c√≥digo ES6: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-string"><span class="hljs-string">'SessionStack'</span></span>); component.render();</code> </pre> <br>  Y esto es en lo que se convierte este c√≥digo despu√©s de la transpilaci√≥n: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Component = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Component);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } _createClass(Component, [{   <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'render'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content);   } }]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Component; }();</code> </pre> <br>  Como puede ver, el c√≥digo ECMAScript 5 se obtiene a la salida del transpilador, que puede ejecutarse en cualquier entorno.  Adem√°s, aqu√≠ se agregan las llamadas a algunas funciones que forman parte de la biblioteca est√°ndar de Babel. <br><br>  Estamos hablando de las <code>_classCallCheck()</code> y <code>_createClass()</code> incluidas en el c√≥digo transpilado.  La primera funci√≥n, <code>_classCallCheck()</code> , est√° dise√±ada para evitar que la funci√≥n constructora se llame como una funci√≥n regular.  Para hacer esto, verifica si el contexto en el que se llama la funci√≥n es el contexto de instancia de la clase <code>Component</code> .  El c√≥digo verifica si la palabra clave this apunta a una instancia similar.  La segunda funci√≥n, <code>_createClass()</code> , crea propiedades de objeto que se le pasan como una matriz de objetos que contienen claves y sus valores. <br><br>  Para entender c√≥mo funciona la herencia, analizamos la clase <code>InputField</code> , que es el descendiente de la clase <code>Component</code> .  As√≠ es como se unen las relaciones de clase en ES6: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Aqu√≠ est√° el resultado de transpilar este c√≥digo usando Babel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_Component</span></span></span><span class="hljs-function">) </span></span>{ _inherits(InputField, _Component); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, InputField);   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">'&lt;input type="text" value="'</span></span> + value + <span class="hljs-string"><span class="hljs-string">'" /&gt;'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _possibleConstructorReturn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InputField.__proto__ || <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(InputField)).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component);</code> </pre> <br>  En este ejemplo, la l√≥gica de los mecanismos de herencia se encapsula en una llamada a la funci√≥n <code>_inherits()</code> .  Realiza las mismas acciones que describimos anteriormente, asociadas, en particular, a escribir en el prototipo de la clase descendiente una instancia de la clase padre. <br><br>  Para transponer el c√≥digo, Babel realiza varias de sus transformaciones.  Primero, el c√≥digo ES6 se analiza y se convierte en una representaci√≥n intermedia llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol de sintaxis abstracta</a> .  Luego, el √°rbol de sintaxis abstracta resultante se convierte en otro √°rbol, cada nodo del cual se transforma en su equivalente ES5.  Como resultado, este √°rbol se convierte en c√≥digo JS. <br><br><h2>  <font color="#3AC1EF">√Årbol de sintaxis abstracta en Babel</font> </h2><br>  Un √°rbol de sintaxis abstracta contiene nodos, cada uno de los cuales tiene solo un nodo primario.  Babel tiene un tipo base para nodos.  Contiene informaci√≥n sobre qu√© es el nodo y d√≥nde se puede encontrar en el c√≥digo.  Existen varios tipos de nodos, por ejemplo, nodos para representar literales, como cadenas, n√∫meros, valores <code>null</code> , etc.  Adem√°s, hay nodos para representar expresiones utilizadas para controlar el flujo de ejecuci√≥n del programa ( <code>if</code> construcci√≥n) y nodos para bucles ( <code>for</code> , <code>while</code> ).  Tambi√©n hay un tipo especial de nodo para representar clases.  Es un descendiente de la clase base <code>Node</code> .  Extiende esta clase agregando campos para almacenar referencias a la clase base y al cuerpo de la clase como un nodo separado. <br>  Convierta el siguiente fragmento de c√≥digo en un √°rbol de sintaxis abstracta: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() {   console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } }</code> </pre> <br>  As√≠ es como se ver√° su representaci√≥n esquem√°tica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8b/4c5/c1d/a8b4c5c1d077388bac770d1b452e51ed.png"></div><br>  <i><font color="#999999">√Årbol de sintaxis abstracta</font></i> <br><br>  Despu√©s de crear un √°rbol, cada uno de sus nodos se transforma en su nodo ES5 correspondiente, despu√©s de lo cual este nuevo √°rbol se convierte en c√≥digo que se ajusta al est√°ndar ECMAScript 5. Durante el proceso de conversi√≥n, primero encuentre el nodo que se encuentra m√°s alejado del nodo ra√≠z, despu√©s de lo cual este nodo se convierte en c√≥digo utilizando fragmentos generados para cada nodo.  Despu√©s de eso, el proceso se repite.  Esta t√©cnica se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda profunda</a> . <br><br>  En el ejemplo anterior, el c√≥digo para los dos nodos <code>MethodDefinition</code> se generar√° primero, despu√©s de lo cual se generar√° el c√≥digo para el nodo <code>ClassBody</code> y, finalmente, el c√≥digo para el nodo <code>ClassDeclaration</code> . <br><br><h2>  <font color="#3AC1EF">Transcripci√≥n de TypeScript</font> </h2><br>  Otro sistema popular que utiliza la transpilaci√≥n es TypeScript.  Este es un lenguaje de programaci√≥n cuyo c√≥digo se transforma en c√≥digo ECMAScript 5 que es comprensible para cualquier motor JS.  Ofrece una nueva sintaxis para escribir aplicaciones JS.  Aqu√≠ se explica c√≥mo implementar la clase <code>Component</code> en TypeScript: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   content: string;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content: string) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content;   }   render() {       console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content)   } }</code> </pre> <br>  Aqu√≠ est√° el √°rbol de sintaxis abstracta para este c√≥digo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/806/ad0/332806ad0bd9882f32c58c0280a8ae40.png"></div><br>  <i><font color="#999999">√Årbol de sintaxis abstracta</font></i> <br><br>  TypeScript admite herencia. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value: string) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Aqu√≠ est√° el resultado de la transpilaci√≥n de este c√≥digo: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-comment"><span class="hljs-comment">/** @class */</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_super)</span></span></span><span class="hljs-function"> </span></span>{   __extends(InputField, _super);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">"&lt;input type=\"text\" value=\""</span></span> + value + <span class="hljs-string"><span class="hljs-string">"\" /&gt;"</span></span>;       _this = _super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _this;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component));</code> </pre> <br>  Como puede ver, este es nuevamente un c√≥digo ES5, en el que, adem√°s de las construcciones est√°ndar, hay llamadas a algunas funciones desde la biblioteca TypeScript.  Las capacidades de la funci√≥n <code>__extends()</code> similares a las que mencionamos al principio de este material. <br><br>  Gracias a la adopci√≥n generalizada de Babel y TypeScript, los mecanismos para declarar clases y organizar la herencia basada en clases se han convertido en herramientas est√°ndar para estructurar aplicaciones JS.  Esto contribuy√≥ a la adici√≥n de soporte para estos mecanismos en los navegadores. <br><br><h2>  <font color="#3AC1EF">Soporte de clase de navegador</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El soporte de clase</a> apareci√≥ en el navegador Chrome en 2014.  Esto permite que el navegador trabaje con declaraciones de clase sin el uso de la transpilaci√≥n o cualquier biblioteca auxiliar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/860/a55/ad5860a550c7956d6bbf17cd1b0afbb6.png"></div><br>  <i><font color="#999999">Trabajando con clases en la consola Chrome JS</font></i> <br><br>  De hecho, el soporte del navegador para estos mecanismos no es m√°s que az√∫car sint√°ctica.  Estas construcciones se convierten en las mismas estructuras b√°sicas que ya son compatibles con el lenguaje.  Como resultado, incluso si usa la nueva sintaxis, en un nivel inferior, todo se ver√° como crear constructores y manipular prototipos de objetos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/d1c/a5b/b61d1ca5b3d35b3b1f431ae8e82c48bd.png"></div><br>  <i><font color="#999999">El apoyo de clase es az√∫car sint√°ctico</font></i> <br><br><h2>  <font color="#3AC1EF">Soporte de clase en V8</font> </h2><br>  Hablemos sobre c√≥mo funciona el soporte de clase ES6 en el motor V8 JS.  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> sobre √°rboles de sintaxis abstracta, hablamos sobre el hecho de que al preparar el c√≥digo JS para su ejecuci√≥n, el sistema lo analiza y forma un √°rbol de sintaxis abstracta sobre su base.  Al analizar construcciones de declaraciones de clase, los nodos de tipo <a href="">ClassLiteral</a> entran en el √°rbol de sintaxis abstracta. <br><br>  Estos nodos almacenan un par de cosas interesantes.  En primer lugar, es un constructor como una funci√≥n separada y, en segundo lugar, es una lista de propiedades de clase.  Pueden ser m√©todos, captadores, establecedores, campos p√∫blicos o privados.  Dicho nodo, adem√°s, almacena una referencia a la clase padre, que extiende la clase para la cual se forma el nodo, que, nuevamente, almacena el constructor, la lista de propiedades y un enlace a su propia clase padre. <br><br>  Despu√©s de que el nuevo nodo <code>ClassLiteral</code> <a href="">transforma en c√≥digo</a> , se convierte en construcciones que consisten en funciones y prototipos. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  El autor de este material dice que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SessionStack se</a> esfuerza por optimizar el c√≥digo de su biblioteca lo m√°s completamente posible, ya que tiene que resolver tareas dif√≠ciles de recopilar informaci√≥n sobre todo lo que sucede en las p√°ginas web.  En el curso de la resoluci√≥n de estos problemas, la biblioteca no debe ralentizar el trabajo de la p√°gina analizada.  La optimizaci√≥n de este nivel requiere tener en cuenta los detalles m√°s peque√±os del ecosistema de JavaScript que afectan el rendimiento, en particular, teniendo en cuenta las caracter√≠sticas de c√≥mo se organizan las clases y los mecanismos de herencia en ES6. <br><br>  <b>Estimados lectores!</b>  ¬øUtiliza construcciones de sintaxis ES6 para trabajar con clases en JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415377/">https://habr.com/ru/post/es415377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415367/index.html">¬øQu√© pasa si los extraterrestres resultan ser m√°quinas con inteligencia artificial?</a></li>
<li><a href="../es415369/index.html">Precio de refactorizaci√≥n</a></li>
<li><a href="../es415371/index.html">Privacidad de criptomonedas</a></li>
<li><a href="../es415373/index.html">NumPy en Python. Parte 4</a></li>
<li><a href="../es415375/index.html">Ovejas Ocultas y Arqueolog√≠a Tipogr√°fica</a></li>
<li><a href="../es415381/index.html">Juega con Kubernetes: servicio para un conocimiento pr√°ctico de los K8</a></li>
<li><a href="../es415383/index.html">El comerciante novato hizo tratos por valor de 5.500 millones de euros debido a un error en el sistema del corredor brit√°nico.</a></li>
<li><a href="../es415385/index.html">La situaci√≥n de DCIM: c√≥mo ha cambiado la gesti√≥n de la infraestructura del centro de datos en los √∫ltimos a√±os</a></li>
<li><a href="../es415387/index.html">Todo desarrollador quiere saber c√≥mo entrar en el phishing.</a></li>
<li><a href="../es415389/index.html">Hoy, el sistema de pago "VKontakte"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>