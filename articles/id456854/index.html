<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•´ï¸ ğŸš¬ ğŸˆ´ Dari UI-kit hingga sistem desain ğŸ“… ğŸ  ğŸ•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengalaman Film Online Ivy 

 Ketika pada awal 2017, kami pertama kali berpikir tentang menciptakan sistem kami sendiri untuk mengirimkan desain ke ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari UI-kit hingga sistem desain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ivi/blog/456854/">  <i><font color="#999999">Pengalaman Film Online Ivy</font></i> <br><br>  Ketika pada awal 2017, kami pertama kali berpikir tentang menciptakan sistem kami sendiri untuk mengirimkan desain ke kode, banyak yang membicarakan hal ini dan seseorang bahkan melakukannya.  Namun, sedikit yang diketahui tentang pengalaman membangun sistem desain lintas platform hingga hari ini, dan tidak ada resep yang jelas dan terbukti yang menggambarkan teknologi dan metode untuk transformasi proses implementasi desain menjadi produk yang sudah berfungsi.  Dan "komponen dalam kode" seringkali memiliki arti yang sangat berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/wj/nk/vbwjnkrs2vmsiuxuru0t1fxlml8.jpeg"></div><br>  Sementara itu, perusahaan menggandakan stafnya dari tahun ke tahun - perlu untuk skala departemen desain dan mengoptimalkan proses menciptakan dan mentransfer layout untuk pengembangan.  Kami melipatgandakan semua ini dengan "kebun binatang" platform yang perlu didukung, dan kami mendapatkan kemiripan dengan Babel crowding, yang sama sekali tidak mampu "secara normal" dan menghasilkan pendapatan.  Pengembangan platform sering berjalan secara paralel, dan fungsionalitas yang sama bisa keluar pada platform yang berbeda dengan jeda beberapa bulan. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w8/jj/x4/w8jjx4_ia9mrzzrg8zqinsiaoeo.png"></div><br>  <i><font color="#999999">Set tata letak terpisah untuk setiap platform</font></i> <br><br>  Secara tradisional, kami mulai dengan masalah bahwa sistem desain akan membantu memecahkan dan merumuskan persyaratan untuk desainnya.  Selain menciptakan bahasa visual tunggal, meningkatkan kecepatan pembuatan prototipe dan pengembangan, meningkatkan kualitas produk secara keseluruhan, sangat penting untuk menyatukan desain sebanyak mungkin.  Ini diperlukan agar pengembangan fungsionalitas dapat segera dilakukan di semua platform kami secara bersamaan: Web, iOS, Android, Smart TV, tvOS, Android TV, Windows 10, xBox One, PS4, Roku - tanpa mengerjakan masing-masing secara terpisah .  Dan kami berhasil! <br><br><h2>  <font color="#fd004c">Desain â†’ Data</font> </h2><br>  Ketika perjanjian utama dari departemen produk dan pengembangan tercapai, kami duduk untuk memilih tumpukan teknologi dan mempelajari detail dari seluruh proses - dari tata letak hingga rilis.  Untuk sepenuhnya mengotomatiskan proses transfer desain ke pengembangan, kami menyelidiki opsi dengan parser parameter komponen langsung dari file Sketsa dengan tata letak.  Ternyata menemukan potongan-potongan kode yang kami butuhkan dan mengekstraksi parameter yang kami butuhkan adalah pekerjaan yang rumit dan berbahaya.  Pertama, desainer harus sangat berhati-hati dalam memberi nama semua lapisan kode sumber, kedua, itu hanya bekerja untuk komponen yang paling sederhana, dan ketiga, ketergantungan pada teknologi orang lain dan struktur kode tata letak Sketsa asli membahayakan masa depan seluruh proyek.  Kami memutuskan untuk meninggalkan otomatisasi di bidang ini.  Jadi, orang pertama muncul dalam tim sistem desain, di pintu masuk yang tata letak desain diajukan, dan pada output - data yang menggambarkan semua parameter komponen dan disusun secara hierarkis sesuai dengan metodologi desain atom. <br><br>  Masalahnya tetap kecil: di mana dan bagaimana menyimpan data, bagaimana mentransfernya ke pengembangan, dan bagaimana menafsirkannya dalam pengembangan di semua platform yang didukung oleh kami.  Malam itu berhenti menjadi lesu ... Hasil pertemuan rutin kelompok kerja, yang terdiri dari desainer dan pemimpin tim dari setiap platform, adalah kesepakatan sebagai berikut. <br><br>  Kami mem-parsing visual menjadi elemen atom: font, warna, transparansi, indentasi, fillet, ikon, gambar, dan durasi untuk animasi.  Dan kami kumpulkan dari tombol ini, input, kotak centang, widget kartu bank, dll. Kami menetapkan nama non-semantik untuk gaya level mana pun, kecuali untuk ikon, misalnya, nama kota, nama nimfa, Pokemon, merek mobil ... Hanya ada satu syarat - daftar tidak boleh kehabisan sebelumnya , gaya apa yang akan berakhir dengan - tunjukkan tiang pergi dia!  Anda tidak boleh terbawa oleh semantik sehingga Anda tidak perlu menambahkan tombol tengah antara "kecil" dan "sedang", misalnya. <br><br><h2>  <font color="#fd004c">Bahasa visual</font> </h2><br>  Para pengembang pergi untuk memikirkan bagaimana cara menyimpan dan mentransfer data sehingga sesuai dengan semua platform, dan desain harus merancang elemen antarmuka yang dapat terlihat sama baiknya dan bekerja secara efektif di seluruh armada perangkat yang didukung. <br><br>  Sebelumnya, kami berhasil "menjalankan" sebagian besar elemen desain dalam aplikasi untuk Windows 10, yang pada saat itu merupakan platform baru bagi kami, yaitu, rendering dan pengembangan dari awal diperlukan.  Dengan menggambarnya, kami dapat mempersiapkan dan menguji sebagian besar komponen dan memahami komponen mana yang akan dimasukkan dalam sistem desain Ivy mendatang.  Tanpa kotak pasir seperti itu, pengalaman seperti itu hanya dapat diperoleh dengan sejumlah besar iterasi pada platform yang sudah bekerja, dan ini akan memakan waktu lebih dari satu tahun. <br><br>  Menggunakan kembali komponen yang sama pada platform yang berbeda mengurangi jumlah tata letak dan susunan data dari sistem desain di kali, sehingga desain harus memecahkan masalah lain yang sebelumnya tidak dijelaskan dalam praktik desain dan pengembangan produk - bagaimana, misalnya, untuk menggunakan kembali tombol untuk ponsel dan tablet di TV?  Dan apa yang secara prinsip seharusnya dengan ukuran font dan elemen pada platform yang berbeda? <br><br>  Jelas, itu perlu untuk merancang grid modular lintas-platform yang akan mengatur ukuran teks dan elemen yang kami butuhkan untuk setiap platform tertentu.  Untuk titik referensi untuk grid, kami memilih ukuran dan jumlah poster film yang ingin kami lihat di layar tertentu dan, berdasarkan ini, merumuskan aturan untuk membangun kolom grid, asalkan lebar satu kolom sama dengan lebar poster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/5i/ka/ei5ikag2hv8buxma47yw_keeutk.png"></div><br>  Sekarang Anda perlu membawa semua layar besar ke ukuran tata letak yang sama dan memasangkannya ke dalam kisi-kisi umum.  Apple TV dan Roku sedang dikembangkan dalam ukuran 1920x1080, Android TV - 960x540, Smart TV, tergantung pada vendor mereka sama, dan ada 1280x720.  Ketika aplikasi dirender dan ditampilkan pada layar Full HD, 960 dikalikan dengan 2, 1280 oleh 1.33, dan 1920 ditampilkan sebagaimana adanya. <br><br>  Dengan mengabaikan detail yang membosankan, kami sampai pada kesimpulan bahwa secara umum semua layar, termasuk layar TV dalam hal elemen dan ukurannya, dicakup oleh satu tata letak desain, dan semua layar TV adalah kasus khusus dari grid lintas platform yang umum, dan terdiri dari lima atau enam kolom, seperti tablet rata-rata atau desktop.  Siapa yang peduli dengan detailnya, buka komentar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/iv/bj/nsivbjcvwummuddabcatfjeeyec.png"></div><br>  <i><font color="#999999">UI terpadu untuk semua platform</font></i> <br><br>  Sekarang, untuk menggambar fitur baru, kita tidak perlu menggambar tata letak untuk setiap platform, ditambah opsi adaptasi untuk masing-masing platform.  Cukup untuk menunjukkan satu tata letak dan kemampuan beradaptasi untuk semua platform dan perangkat dengan lebar apa pun: telepon - 320-599, segalanya - 600-1280. <br><br><h2>  <font color="#fd004c">Data â†’ Pengembangan</font> </h2><br>  Tentu saja, tidak peduli bagaimana kami ingin sampai pada desain yang sepenuhnya terpadu, setiap platform memiliki fitur uniknya sendiri.  Terlepas dari kenyataan bahwa baik web dan Smart TV menggunakan tumpukan ReactJS + TypeScript, aplikasi Smart TV berjalan pada klien WebKit dan Presto lama, dan karenanya tidak dapat menggunakan gaya umum dengan web.  Dan buletin email sepenuhnya dipaksa untuk bekerja dengan tata letak tabel.  Pada saat yang sama, tidak satu pun platform non-html menggunakan atau berencana untuk menggunakan React Native atau analognya, karena takut akan penurunan kinerja, karena kami memiliki terlalu banyak tata letak khusus, koleksi dengan logika pembaruan kompleks, gambar, dan video.  Oleh karena itu, skema umum tidak cocok untuk kami - untuk menyediakan gaya CSS siap pakai atau komponen Bereaksi.  Oleh karena itu, kami memutuskan untuk mentransfer data dalam format JSON, menggambarkan nilai-nilai dalam bentuk deklaratif abstrak. <br><blockquote> Jadi properti <code>rounding: 8</code> , aplikasi Windows 10 dikonversi ke <code>CornerRadius="8"</code> , web - <code>border-radius: 8px</code> , Android - <code>android:radius="8dp"</code> , iOS - <code>self.layer.cornerRadius = 8.0</code> . <br>  <code>offsetTop: 12</code> OffsetTop <code>offsetTop: 12</code> klien web yang sama dapat diartikan dalam kasus yang berbeda seperti <code>top</code> , <code>margin-top</code> , <code>padding-top</code> atau <code>transform</code> </blockquote><br>  Sifat deklaratif deskripsi juga menunjukkan bahwa jika platform secara teknis tidak dapat menggunakan properti atau nilainya, ia dapat mengabaikannya.  Dalam hal terminologi, kami membuat semacam bahasa Esperanto: kami mengambil sesuatu dari Android, beberapa dari SVG, beberapa dari CSS. <br><br>  Jika perlu untuk menampilkan elemen dengan cara berbeda pada platform tertentu, kami telah mengimplementasikan kemampuan untuk mentransfer pembuatan data terkait sebagai file JSON yang terpisah.  Misalnya, statusnya â€œfokusâ€ untuk Smart TV, ia menentukan perubahan posisi teks di bawah poster, jadi untuk platform ini komponen ini dalam nilai properti â€œindentâ€ akan berisi 8 titik indent yang dibutuhkan.  Meskipun ini merumitkan infrastruktur sistem desain, ini memberikan tingkat kebebasan tambahan, memberi kita kesempatan untuk mengelola "ketidaksamaan" visual dari platform itu sendiri, dan tidak menjadi sandera pada arsitektur yang kami buat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/kv/lq/spkvlqlhtbncrtsof8ymcj8ejeq.png"></div><br><h2>  <font color="#fd004c">Piktogram</font> </h2><br>  Ikonografi dalam produk digital selalu merupakan sub proyek yang banyak dan tidak mudah, seringkali memiliki perancang yang terpisah.  Selalu ada banyak mesin terbang, masing-masing memiliki beberapa ukuran dan warna, apalagi, platform membutuhkannya, sebagai aturan dalam format yang berbeda.  Secara umum, tidak ada alasan untuk tidak membawa semua ini ke dalam sistem desain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/jy/ho/yijyho-f2jr1eyv3brxuw9qve38.png"></div><br>  Mesin terbang dimuat dalam format vektor SVG, dan nilai warna secara otomatis diganti dengan variabel.  Aplikasi klien dapat membuatnya siap digunakan - dalam format dan warna apa pun. <br><br><h2>  <font color="#fd004c">Pratinjau</font> </h2><br>  Di atas JSON dengan data, kami menulis alat untuk melihat pratinjau komponen - aplikasi JS yang melewatkan data JSON melalui markup dan generator gaya dengan cepat dan menampilkan berbagai variasi setiap komponen di browser.  Bahkan, pratinjau klien persis sama dengan aplikasi platform, dan bekerja dengan data yang sama. <br><br>  Memahami cara kerja komponen tertentu paling mudah dengan berinteraksi dengannya.  Oleh karena itu, kami tidak menggunakan alat seperti Storybook, tetapi melakukan pratinjau interaktif - Anda dapat menyentuh, mengarahkan, klik ... Ketika Anda menambahkan komponen baru ke sistem desain, itu muncul di pratinjau sehingga platform memiliki sesuatu untuk fokus ketika memperkenalkannya. <br><br><h2>  <font color="#fd004c">Dokumentasi</font> </h2><br>  Berdasarkan data yang dikirimkan dalam bentuk JSON ke platform, dokumentasi komponen dihasilkan secara otomatis.  Daftar properti dan kemungkinan jenis nilai di masing-masing dijelaskan.  Setelah pembuatan otomatis, informasi dapat diklarifikasi secara manual, tambahkan deskripsi teks.  Pratinjau dan dokumentasi dilengkapi dengan rujukan silang satu sama lain di tingkat masing-masing komponen, dan semua informasi yang termasuk dalam dokumentasi tersedia untuk pengembang dalam bentuk file JSON tambahan. <br><br><h2>  <font color="#fd004c">Deprecator</font> </h2><br>  Kebutuhan lain adalah kemampuan untuk mengganti dan meningkatkan komponen yang ada seiring waktu.  Sistem desain telah belajar memberi tahu pengembang mana properti atau bahkan seluruh komponen yang tidak dapat digunakan dan menghapusnya segera setelah mereka tidak lagi digunakan pada semua platform.  Masih ada banyak pekerjaan â€œmanualâ€ dalam proses ini, tetapi kami tidak tinggal diam. <br><br><h2>  <font color="#fd004c">Pengembangan pelanggan</font> </h2><br>  Tidak diragukan lagi, interpretasi data sistem desain dalam kode semua platform yang didukung oleh kami menjadi tahap yang paling luas dalam kompleksitas.  Jika, misalnya, kisi modular di web bukanlah hal baru, maka pengembang aplikasi seluler asli untuk iOS dan Android berkeringat cukup keras sebelum mereka menemukan cara untuk hidup dengannya. <br><br>  Untuk tata letak layar aplikasi iOS, kami menggunakan dua mekanisme dasar yang iviUIKit sediakan: tata letak elemen gratis dan tata letak koleksi elemen.  Kami menggunakan VIPER, dan semua interaksi dengan iviUIKit terkonsentrasi di View, dan sebagian besar interaksi dengan Apple UIKit terkonsentrasi di iviUIKit.  Ukuran dan pengaturan elemen ditentukan dalam hal kolom dan konstruksi sintaksis yang bekerja di atas konstanta SDK iOS asli, membuatnya lebih diterapkan.  Ini terutama menyederhanakan hidup kita ketika bekerja dengan UICollectionView.  Kami menulis beberapa tata letak yang dapat disesuaikan untuk tata letak, termasuk yang cukup rumit.  Kode klien berubah minimum dan menjadi deklaratif. <br><br>  Untuk menghasilkan gaya dalam proyek Android, kami menggunakan Gradle, mengubah data sistem desain menjadi gaya format XML.  Pada saat yang sama, kami memiliki beberapa generator dari berbagai tingkatan: <br><br><ul><li>  <b>Dasar</b>  Parsing data primitif untuk generator tingkat yang lebih tinggi. </li><li>  <b>Sumberdaya</b> .  Unduh gambar, ikon, dan grafik lainnya. </li><li>  <b>Komponen</b>  Mereka ditulis untuk setiap komponen, yang menggambarkan properti apa dan bagaimana menerjemahkan ke gaya. </li></ul><br><h2>  <font color="#fd004c">Rilis aplikasi</font> </h2><br>  Setelah desainer menggambar komponen baru atau mengerjakan yang sudah ada, perubahan ini masuk ke dalam sistem desain.  Pengembang setiap platform menyelesaikan pembuatan kode mereka, memberikan dukungan untuk perubahan.  Setelah itu, dapat digunakan dalam implementasi fungsi baru, di mana komponen ini diperlukan.  Dengan demikian, interaksi dengan sistem desain tidak terjadi secara real time, tetapi hanya pada saat merakit rilis baru.  Pendekatan ini juga memungkinkan Anda untuk lebih mengontrol proses transfer data dan menjamin kinerja kode dalam proyek pengembangan klien. <br><br><h2>  <font color="#fd004c">Ringkasan</font> </h2><br>  Segera, sebagai sistem desain, setahun menjadi bagian dari infrastruktur yang melayani pengembangan bioskop online Ivy, dan beberapa kesimpulan sudah dapat ditarik: <br><br><ul><li>  Ini adalah proyek besar dan sulit untuk dilaksanakan, membutuhkan sumber daya yang dialokasikan konstan. </li><li>  Ini memungkinkan kami untuk membuat bahasa visual lintas platform unik kami sendiri yang memenuhi tujuan layanan video online. </li><li>  Kami tidak lagi memiliki platform yang tertinggal secara visual dan fungsional. </li></ul><br>  Pratinjau komponen sistem desain Ivy - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">design.ivi.ru</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456854/">https://habr.com/ru/post/id456854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456844/index.html">Strategi samaran: analisis permainan tentang informasi rahasia</a></li>
<li><a href="../id456846/index.html">Seminar "Manajemen Kerentanan: Standar, Realitas, Peralatan", 4 Juli, Moskow</a></li>
<li><a href="../id456848/index.html">Apa jenis musik "kabel" di OS populer</a></li>
<li><a href="../id456850/index.html">Puppy Eyes: co-evolusi 30.000 tahun anjing dan manusia</a></li>
<li><a href="../id456852/index.html">Sederhanakan menggambar Bendera Enum dalam Persatuan</a></li>
<li><a href="../id456856/index.html">Cara memilih tempat terbaik untuk membuka cabang dan memvisualisasikan hasil di peta</a></li>
<li><a href="../id456858/index.html">Ansible: pembaruan dalam solusi utama untuk mengotomatisasi dunia Anda</a></li>
<li><a href="../id456860/index.html">Sakelar Wawasan Jaringan Ekstrim Atau mengapa pada switch mesin virtual</a></li>
<li><a href="../id456862/index.html">Apa yang saya pelajari dari pengalaman pahit saya (lebih dari 30 tahun dalam pengembangan perangkat lunak)</a></li>
<li><a href="../id456866/index.html">Ketika mereka akan membuat "cheburnet" dari Internet: ikhtisar proyek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>