<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ üë®üèº‚Äçüî¨ üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ Princ√≠pio aberto-fechado üõÄüèΩ üßóüèª üë®üèæ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Aqui est√° a tradu√ß√£o de um artigo de Robert Martin, do Princ√≠pio Aberto-Fechado , que ele publicou em janeiro de 1996. O artigo, para dizer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Princ√≠pio aberto-fechado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Ol√° Habr!  Aqui est√° a tradu√ß√£o de um artigo de Robert Martin, do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20060822033314/">Princ√≠pio Aberto-Fechado</a> , que ele publicou em janeiro de 1996.  O artigo, para dizer o m√≠nimo, n√£o √© o mais recente.  Mas no RuNet, os artigos do tio Bob sobre o SOLID s√£o recontados apenas de forma truncada, ent√£o pensei que uma tradu√ß√£o completa n√£o seria sup√©rflua. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  Decidi come√ßar com a letra O, j√° que o princ√≠pio de abertura-fechamento √© de fato central.  Entre outras coisas, h√° muitas sutilezas importantes que merecem aten√ß√£o: </p><br><ul><li>  Nenhum programa pode ser "fechado" 100%. </li><li>  A programa√ß√£o orientada a objetos (OOP) opera n√£o com objetos f√≠sicos do mundo real, mas com conceitos - por exemplo, o conceito de "ordena√ß√£o". <a name="habracut"></a></li></ul><br><p>  Este √© o primeiro artigo da minha coluna <em>Engineer Notes</em> para <em>The C ++ Report</em> .  Os artigos publicados nesta coluna se concentrar√£o no uso de C ++ e OOP e abordar√£o as dificuldades no desenvolvimento de software.  Vou tentar tornar os materiais pragm√°ticos e √∫teis para a pr√°tica de engenheiros.  Para a documenta√ß√£o do design orientado a objetos nestes artigos, utilizarei a nota√ß√£o de Buch. </p><br><p>  Existem muitas heur√≠sticas associadas √† programa√ß√£o orientada a objetos.  Por exemplo, ‚Äútodas as vari√°veis ‚Äã‚Äãde membro devem ser privadas‚Äù ou ‚Äúvari√°veis ‚Äã‚Äãglobais devem ser evitadas‚Äù ou ‚Äúa determina√ß√£o de tipo em tempo de execu√ß√£o √© perigosa‚Äù.  Qual o motivo de tais heur√≠sticas?  Por que eles s√£o verdadeiros?  Eles <em>sempre s√£o</em> verdadeiros?  Esta coluna explora o princ√≠pio de design subjacente a essas heur√≠sticas - o princ√≠pio de abertura-fechamento. <br>  Ivar Jacobson disse: ‚ÄúTodos os sistemas mudam durante o ciclo de vida.  Isso deve ser lembrado ao projetar um sistema com mais de uma vers√£o esperada. ‚Äù  Como podemos projetar um sistema para que ele seja est√°vel diante das mudan√ßas e que tenha mais de uma vers√£o esperada?  Bertrand Meyer nos contou sobre isso em 1988, quando o agora famoso princ√≠pio da abertura-proximidade foi formulado: </p><br><p>  <strong>As entidades do programa (classes, m√≥dulos, fun√ß√µes, etc.) devem estar abertas para expans√£o e fechadas para altera√ß√µes.</strong> </p><br><p>  Se uma altera√ß√£o no programa envolve uma cascata de altera√ß√µes nos m√≥dulos dependentes, sinais indesej√°veis ‚Äã‚Äãde um design "ruim" aparecem no programa. </p><br><p>  O programa se torna fr√°gil, inflex√≠vel, imprevis√≠vel e sem uso.  O princ√≠pio da abertura-proximidade resolve esses problemas de maneira muito direta.  Ele diz que √© necess√°rio projetar m√≥dulos que nunca <em>mudam</em> .  Quando os requisitos mudam, voc√™ precisa expandir o comportamento de tais m√≥dulos adicionando novo c√≥digo, em vez de alterar o c√≥digo antigo que j√° est√° funcionando. </p><br><h1>  Descri√ß√£o do produto </h1><br><p>  M√≥dulos que atendem ao princ√≠pio de abertura-proximidade t√™m duas caracter√≠sticas principais: </p><br><ol><li>  <strong>Aberto para expans√£o.</strong>  Isso significa que o comportamento do m√≥dulo pode ser expandido.  Ou seja, podemos adicionar um novo comportamento ao m√≥dulo de acordo com os requisitos vari√°veis ‚Äã‚Äãdo aplicativo ou para atender √†s necessidades de novos aplicativos. </li><li>  <strong>Fechado para mudan√ßa.</strong>  O c√≥digo fonte desse m√≥dulo √© intoc√°vel.  Ningu√©m tem o direito de fazer altera√ß√µes. </li></ol><br><p>  Parece que esses dois sinais n√£o se encaixam.  A maneira padr√£o de estender o comportamento de um m√≥dulo √© fazer altera√ß√µes nele.  Um m√≥dulo que n√£o pode ser alterado geralmente √© pensado como um m√≥dulo com comportamento fixo.  Como essas duas condi√ß√µes opostas podem ser cumpridas? </p><br><h1>  A chave da solu√ß√£o √© a abstra√ß√£o. </h1><br><p>  No C ++, usando os princ√≠pios do design orientado a objetos, √© poss√≠vel criar abstra√ß√µes fixas que podem representar um conjunto ilimitado de comportamentos poss√≠veis. </p><br><p>  Abstra√ß√µes s√£o classes b√°sicas abstratas e um conjunto ilimitado de comportamentos poss√≠veis √© representado por todas as classes poss√≠veis poss√≠veis.  Um m√≥dulo pode manipular a abstra√ß√£o.  Esse m√≥dulo est√° fechado para altera√ß√µes, pois depende de uma abstra√ß√£o fixa.  Al√©m disso, o comportamento do m√≥dulo pode ser expandido criando novos descendentes da abstra√ß√£o. </p><br><p> O diagrama abaixo mostra uma op√ß√£o de design simples que n√£o atende ao princ√≠pio de abertura-proximidade.  Ambas as classes, <code>Client</code> e <code>Server</code> , n√£o s√£o abstratas.  N√£o h√° garantia de que as fun√ß√µes que s√£o membros da classe <code>Server</code> sejam virtuais.  A classe <code>Client</code> usa a classe <code>Server</code> .  Se queremos que o objeto da classe <code>Client</code> use um objeto de servidor diferente, devemos alterar a classe <code>Client</code> para se referir √† nova classe de servidor. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="imagem"><br>  <em>Cliente fechado</em> </p><br><p>  E o diagrama a seguir mostra a op√ß√£o de design correspondente, que atende ao princ√≠pio de abertura-proximidade.  Nesse caso, a classe <code>AbstractServer</code> √© uma classe abstrata, cujas fun√ß√µes de membro s√£o virtuais.  A classe <code>Client</code> usa abstra√ß√£o.  No entanto, os objetos da classe <code>Client</code> usar√£o objetos da classe sucessora do <code>Server</code> .  Se quisermos que objetos da classe <code>Client</code> usem uma classe de servidor diferente, apresentaremos um novo descendente da classe <code>AbstractServer</code> .  A classe <code>Client</code> permanecer√° inalterada. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="imagem"><br>  <em>Cliente aberto</em> </p><br><h1>  Resumo da <code>Shape</code> </h1><br><p>  Considere um aplicativo que deve desenhar c√≠rculos e quadrados em uma GUI padr√£o.  C√≠rculos e quadrados devem ser desenhados em uma ordem espec√≠fica.  Na ordem correspondente, uma lista de c√≠rculos e quadrados ser√° compilada, o programa deve passar por essa lista na ordem e desenhar cada c√≠rculo ou quadrado. </p><br><p>  Em C, usando t√©cnicas de programa√ß√£o procedural que n√£o atendem ao princ√≠pio de abertura / fechamento, podemos resolver esse problema, como mostra a Listagem 1. Aqui vemos muitas estruturas de dados com o mesmo primeiro elemento.  Este elemento √© um c√≥digo de tipo que identifica a estrutura de dados como um c√≠rculo ou quadrado.  A fun√ß√£o <code>DrawAllShapes</code> passa por uma matriz de ponteiros para essas estruturas de dados, reconhecendo o c√≥digo de tipo e chamando a fun√ß√£o correspondente ( <code>DrawCircle</code> ou <code>DrawSquare</code> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  A fun√ß√£o <code>DrawAllShapes</code> n√£o atende ao princ√≠pio do fechamento de abertura, porque n√£o pode ser "fechado" a partir de novos tipos de formas.  Se eu quisesse expandir essa fun√ß√£o com a capacidade de desenhar formas de uma lista que inclui tri√¢ngulos, precisaria alterar a fun√ß√£o.  Na verdade, preciso alterar a fun√ß√£o para cada novo tipo de forma que preciso desenhar. </p><br><p>  Obviamente, este programa √© apenas um exemplo.  Na vida real, o operador do <code>DrawAllShapes</code> fun√ß√£o <code>DrawAllShapes</code> seria repetido v√°rias vezes em v√°rias fun√ß√µes em todo o aplicativo e cada uma faria algo diferente.  Adicionar novas formas a esse aplicativo significa encontrar todos os locais onde essas <code>switch</code> (ou <code>if/else</code> cadeia) s√£o usadas e adicionar uma nova forma a cada uma delas.  Al√©m disso, √© muito improv√°vel que todas as <code>switch</code> e cadeias <code>if/else</code> sejam t√£o bem estruturadas quanto no <code>DrawAllShapes</code> .  √â muito mais prov√°vel que predicados em <code>if</code> sejam combinadas com operadores l√≥gicos ou blocos de casos de <code>switch</code> de <code>switch</code> sejam combinados de forma a "simplificar" um local espec√≠fico no c√≥digo.  Portanto, o problema de encontrar e entender todos os locais em que voc√™ precisa adicionar uma nova figura pode n√£o ser trivial. </p><br><p>  Na Listagem 2, mostrarei o c√≥digo que demonstra uma solu√ß√£o quadrada / circular que atende ao princ√≠pio do fechamento de abertura.  Uma classe <code>Shape</code> abstrata √© introduzida.  Esta classe abstrata cont√©m uma fun√ß√£o <code>Draw</code> pura e virtual.  As classes <code>Circle</code> e <code>Square</code> s√£o descendentes da classe <code>Shape</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Observe que, se quisermos estender o comportamento da fun√ß√£o <code>DrawAllShapes</code> na Listagem 2 para desenhar um novo tipo de forma, tudo o que precisamos fazer √© adicionar um novo descendente da classe <code>Shape</code> .  N√£o h√° necessidade de alterar a fun√ß√£o <code>DrawAllShapes</code> .  Portanto, <code>DrawAllShapes</code> atende ao princ√≠pio de abertura-proximidade.  Seu comportamento pode ser expandido sem alterar a pr√≥pria fun√ß√£o. </p><br><p>  No mundo real, a classe <code>Shape</code> conteria muitos outros m√©todos.  Ainda assim, adicionar uma nova forma ao aplicativo ainda √© muito simples, pois tudo que voc√™ precisa fazer √© inserir um novo herdeiro e implementar essas fun√ß√µes.  N√£o h√° necessidade de vasculhar todo o aplicativo em busca de locais que exigem mudan√ßas. </p><br><p>  Portanto, os programas que atendem ao princ√≠pio da abertura-proximidade s√£o alterados adicionando novo c√≥digo, e n√£o alterando o existente; eles n√£o transformam em cascata as altera√ß√µes caracter√≠sticas dos programas que n√£o correspondem a esse princ√≠pio. </p><br><h1>  Estrat√©gia de entrada fechada </h1><br><p>  Obviamente, nenhum programa pode ser 100% fechado.  Por exemplo, o que acontece com a fun√ß√£o <code>DrawAllShapes</code> na Listagem 2 se decidirmos que c√≠rculos e quadrados devem ser desenhados primeiro?  A fun√ß√£o <code>DrawAllShapes</code> n√£o <code>DrawAllShapes</code> fechada para esse tipo de altera√ß√£o.  Em geral, n√£o importa o qu√£o "fechado" o m√≥dulo esteja, sempre h√° algum tipo de altera√ß√£o da qual ele n√£o est√° fechado. </p><br><p>  Como o fechamento n√£o pode ser completo, ele deve ser introduzido estrategicamente.  Ou seja, o designer deve escolher os tipos de altera√ß√µes das quais o programa ser√° fechado.  Isso requer alguma experi√™ncia.  Um desenvolvedor experiente conhece os usu√°rios e o setor suficientemente bem para calcular a probabilidade de v√°rias altera√ß√µes.  Ele ent√£o garante que o princ√≠pio da abertura-proximidade seja respeitado nas mudan√ßas mais prov√°veis. </p><br><h2>  Uso de abstra√ß√£o para obter proximidade adicional </h2><br><p>  Como podemos fechar a fun√ß√£o <code>DrawAllShapes</code> de altera√ß√µes na ordem do desenho?  Lembre-se de que o fechamento √© baseado na abstra√ß√£o.  Portanto, para fechar <code>DrawAllShapes</code> do pedido, precisamos de algum tipo de "abstra√ß√£o do pedido".  Um caso especial de pedido, apresentado acima, √© desenhar figuras de um tipo na frente de figuras de outro tipo. </p><br><p>  A pol√≠tica de pedidos implica que, com dois objetos, voc√™ pode determinar qual deles deve ser desenhado primeiro.  Portanto, podemos definir um m√©todo para a classe <code>Shape</code> chamada <code>Precedes</code> , que pega outro objeto <code>Shape</code> como argumento e retorna um valor booleano <code>true</code> se o objeto <code>Shape</code> que recebeu essa mensagem precisar ser classificado antes do objeto <code>Shape</code> que foi passado como argumento. </p><br><p>  No C ++, essa fun√ß√£o pode ser representada como uma sobrecarga do operador "&lt;".  A Listagem 3 mostra a classe <code>Shape</code> com m√©todos de classifica√ß√£o. </p><br><p>  Agora que temos uma maneira de determinar a ordem dos objetos da classe <code>Shape</code> , podemos classific√°-los e desenh√°-los.  A Listagem 4 mostra o c√≥digo C ++ correspondente.  Ele usa as classes <code>Set</code> , <code>OrderedSet</code> e <code>Iterator</code> da categoria <code>Components</code> desenvolvida em meu livro (Designing Applications C ++ Orientados a Objetos usando o M√©todo Booch, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Portanto, implementamos a ordem dos objetos da classe <code>Shape</code> e os desenhamos na ordem apropriada.  Mas ainda n√£o temos uma implementa√ß√£o da abstra√ß√£o do pedido.  Obviamente, todo objeto <code>Shape</code> deve substituir o m√©todo <code>Precedes</code> para determinar a ordem.  Como isso pode funcionar?  Que c√≥digo precisa ser escrito em <code>Circle::Precedes</code> para que os c√≠rculos sejam desenhados em quadrados?  Preste aten√ß√£o na lista 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  √â claro que essa fun√ß√£o n√£o atende ao princ√≠pio da abertura-proximidade.  N√£o h√° como fech√°-lo dos novos descendentes da classe <code>Shape</code> .  Cada vez que um novo descendente da classe <code>Shape</code> aparece, essa fun√ß√£o precisa ser alterada. </p><br><h2>  Usando uma abordagem orientada a dados para obter o fechamento </h2><br><p>  A proximidade dos herdeiros da classe <code>Shape</code> pode ser obtida usando uma abordagem tabular que n√£o provoca altera√ß√µes em cada classe herdada.  Um exemplo dessa abordagem √© mostrado na Listagem 6. </p><br><p>  Usando essa abordagem, fechamos com √™xito a fun√ß√£o <code>DrawAllShapes</code> das altera√ß√µes relacionadas √† ordem e a cada descendente da classe <code>Shape</code> - da introdu√ß√£o de um novo descendente ou de uma altera√ß√£o na pol√≠tica de ordena√ß√£o de objetos da classe <code>Shape</code> dependendo do tipo (por exemplo, objetos da classe <code>Squares</code> ser desenhado primeiro). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  O √∫nico elemento que n√£o est√° impedido de alterar a ordem das formas de desenho √© uma tabela.  A tabela pode ser colocada em um m√≥dulo separado, separado de todos os outros m√≥dulos e, portanto, suas altera√ß√µes n√£o afetar√£o outros m√≥dulos. </p><br><h2>  Fechamento adicional </h2><br><p>  Este n√£o √© o fim da hist√≥ria.  Fechamos a hierarquia da classe <code>Shape</code> e a fun√ß√£o <code>DrawAllShapes</code> de alterar a pol√≠tica de pedidos com base no tipo de formas.  No entanto, os descendentes da classe <code>Shape</code> n√£o est√£o fechados das pol√≠ticas de pedidos que n√£o est√£o associadas aos tipos de <code>Shape</code> .  Parece que precisamos organizar o desenho das formas de acordo com uma estrutura de n√≠vel superior.  Um estudo completo desses problemas est√° al√©m do escopo deste artigo;  no entanto, um leitor interessado pode pensar em como resolver esse problema usando a classe abstrata <code>OrderedObject</code> contida na classe <code>OrderedShape</code> , que herda das <code>OrderedObject</code> <code>Shape</code> e <code>OrderedObject</code> . </p><br><h1>  Heur√≠sticas e Conven√ß√µes </h1><br><p>  Como j√° mencionado no in√≠cio do artigo, o princ√≠pio de abertura-proximidade √© a principal motiva√ß√£o por tr√°s de muitas heur√≠sticas e conven√ß√µes que surgiram ao longo dos muitos anos de desenvolvimento do paradigma OOP.  A seguir, s√£o os mais importantes. </p><br><h2>  Tornar todas as vari√°veis ‚Äã‚Äãde membro privadas </h2><br><p>  Esta √© uma das conven√ß√µes mais duradouras da OLP.  As vari√°veis ‚Äã‚Äãde membro devem ser conhecidas apenas pelos m√©todos da classe em que est√£o definidas.  Membros vari√°veis ‚Äã‚Äãn√£o devem ser conhecidos por nenhuma outra classe, incluindo classes derivadas.  Portanto, eles devem ser declarados com um modificador de acesso <code>private</code> , n√£o <code>public</code> ou <code>protected</code> . <br>  √Ä luz do princ√≠pio da abertura-proximidade, a raz√£o de tal conven√ß√£o √© compreens√≠vel.  Quando as vari√°veis ‚Äã‚Äãdos membros da classe mudam, cada fun√ß√£o que depende delas deve mudar.  Ou seja, a fun√ß√£o n√£o est√° fechada de altera√ß√µes nessas vari√°veis. </p><br><p>  Em OOP, esperamos que os m√©todos de uma classe n√£o sejam fechados para altera√ß√µes nas vari√°veis ‚Äã‚Äãque s√£o membros dessa classe.  No entanto, esperamos que qualquer outra classe, incluindo subclasses, seja fechada de altera√ß√µes nessas vari√°veis.  Isso √© chamado de encapsulamento. </p><br><p>  Mas e se voc√™ tiver uma vari√°vel sobre a qual tenha certeza de que ela nunca mudar√°?  Faz sentido torn√°-lo <code>private</code> ?  Por exemplo, a Listagem 7 mostra a classe <code>Device</code> que cont√©m o <code>bool status</code> membro vari√°vel.  Ele armazena o status da √∫ltima opera√ß√£o.  Se a opera√ß√£o foi bem-sucedida, o valor da vari√°vel <code>status</code> ser√° <code>true</code> , caso contr√°rio, <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Sabemos que o tipo ou significado dessa vari√°vel nunca ser√° alterado.  Ent√£o, por que n√£o torn√°-lo <code>public</code> e dar ao cliente acesso direto a ele?  Se a vari√°vel realmente nunca mudar, se todos os clientes seguirem as regras e apenas lerem essa vari√°vel, n√£o haver√° nada de errado com o fato de a vari√°vel ser p√∫blica.  No entanto, considere o que acontecer√° se um dos clientes aproveitar a oportunidade para gravar nessa vari√°vel e alterar seu valor. </p><br><p>  De repente, esse cliente pode afetar a opera√ß√£o de qualquer outro cliente da classe <code>Device</code> .  Isso significa que √© imposs√≠vel fechar os clientes da classe <code>Device</code> das altera√ß√µes neste m√≥dulo incorreto.  Isso √© muito risco. </p><br><p>  Por outro lado, suponha que tenhamos a classe <code>Time</code> , mostrada na Listagem 8. Qual √© o perigo de publicidade das vari√°veis ‚Äã‚Äãque s√£o membros dessa classe?  √â muito improv√°vel que eles mudem.  Al√©m disso, n√£o importa se os m√≥dulos do cliente alteram os valores dessas vari√°veis ‚Äã‚Äãou n√£o, pois √© assumida uma altera√ß√£o nessas vari√°veis.  Tamb√©m √© muito improv√°vel que classes herdadas possam depender do valor de uma vari√°vel de membro espec√≠fica.  Ent√£o, h√° algum problema? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  A √∫nica reclama√ß√£o que eu poderia apresentar ao c√≥digo da Listagem 8 √© que a mudan√ßa de hor√°rio n√£o √© at√¥mica.  Ou seja, o cliente pode alterar o valor da vari√°vel de <code>minutes</code> sem alterar o valor da vari√°vel de <code>hours</code> .  Isso pode fazer com que um objeto da classe <code>Time</code> contenha dados inconsistentes.  Eu preferiria introduzir uma √∫nica fun√ß√£o para definir a hora, que levaria tr√™s argumentos, o que tornaria a configura√ß√£o da hora uma opera√ß√£o at√¥mica.  Mas este √© um argumento fraco. </p><br><p>  √â f√°cil criar outras condi√ß√µes sob as quais a publicidade dessas vari√°veis ‚Äã‚Äãpossa levar a problemas.  Em √∫ltima an√°lise, no entanto, n√£o h√° motivos convincentes para torn√°-los <code>private</code> .  Eu ainda acho que tornar essas vari√°veis ‚Äã‚Äãp√∫blicas √© um estilo ruim, mas talvez n√£o seja um design ruim.  Eu acredito que esse √© um estilo ruim, porque n√£o custa quase nada entrar nas fun√ß√µes apropriadas para acessar esses membros, e definitivamente vale a pena se proteger do pequeno risco associado √† poss√≠vel ocorr√™ncia de problemas com o fechamento. </p><br><p>  Portanto, em casos t√£o raros, quando o princ√≠pio de abertura-fechamento n√£o √© violado, a proibi√ß√£o de vari√°veis <code>public</code> - e <code>protected</code> depende mais do estilo e n√£o do conte√∫do. </p><br><h2>  Nenhuma vari√°vel global ... de jeito nenhum! </h2><br><p>  O argumento contra vari√°veis ‚Äã‚Äãglobais √© o mesmo que o argumento contra vari√°veis ‚Äã‚Äãmembro p√∫blicas.  Nenhum m√≥dulo que depende de uma vari√°vel global pode ser fechado a partir de um m√≥dulo que possa gravar nela.  Qualquer m√≥dulo que use essa vari√°vel de uma maneira n√£o pretendida por outros m√≥dulos quebrar√° esses m√≥dulos.  √â muito arriscado ter muitos m√≥dulos, dependendo dos caprichos de um √∫nico m√≥dulo malicioso. <br>  Por outro lado, nos casos em que vari√°veis ‚Äã‚Äãglobais t√™m um pequeno n√∫mero de m√≥dulos dependentes delas ou n√£o podem ser usadas da maneira errada, elas n√£o causam danos.  O designer deve avaliar quanta privacidade √© sacrificada e determinar se a conveni√™ncia fornecida pela vari√°vel global vale a pena. </p><br><p>  Aqui, novamente, problemas de estilo entram em cena.  Alternativas ao uso de vari√°veis ‚Äã‚Äãglobais geralmente s√£o baratas.  Nesses casos, o uso de uma t√©cnica que introduz, embora pequena, mas um risco de fechamento, em vez de uma t√©cnica que elimina completamente esse risco, √© um sinal de mau estilo.  No entanto, √†s vezes o uso de vari√°veis ‚Äã‚Äãglobais √© realmente conveniente.  Um exemplo t√≠pico s√£o as vari√°veis ‚Äã‚Äãglobais cout e cin.  Nesses casos, se o princ√≠pio de abertura-proximidade n√£o for violado, voc√™ poder√° sacrificar o estilo por conveni√™ncia. </p><br><h2>  RTTI √© perigoso </h2><br><p>  Outra proibi√ß√£o comum √© o uso de <code>dynamic_cast</code> .  Freq√ºentemente, <code>dynamic_cast</code> ou alguma outra forma de determina√ß√£o do tipo de tempo de execu√ß√£o (RTTI) √© acusada de ser uma t√©cnica extremamente perigosa e, portanto, deve ser evitada.  Ao mesmo tempo, eles geralmente d√£o um exemplo da Lista 9, que obviamente viola o princ√≠pio de abertura-proximidade.  No entanto, a Listagem 10 mostra um exemplo de programa semelhante que usa <code>dynamic_cast</code> sem violar o princ√≠pio de abertura e fechamento. </p><br><p>  A diferen√ßa entre eles √© que, no primeiro caso, mostrado na Listagem 9, o c√≥digo precisa ser alterado toda vez que um novo descendente da classe <code>Shape</code> aparece (sem mencionar que essa √© uma solu√ß√£o absolutamente rid√≠cula).  No entanto, na Listagem 10, nenhuma mudan√ßa √© necess√°ria neste caso.  Portanto, o c√≥digo na Listagem 10 n√£o viola o princ√≠pio de abertura e fechamento. <br>  Nesse caso, a regra geral √© que o RTTI pode ser usado se o princ√≠pio do fechamento da abertura n√£o for violado. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Conclus√£o </h1><br><p>  Eu poderia falar por um longo tempo sobre o princ√≠pio da abertura-proximidade.  De muitas maneiras, esse princ√≠pio √© mais importante para a programa√ß√£o orientada a objetos.  A conformidade com esse princ√≠pio espec√≠fico fornece as principais vantagens da tecnologia orientada a objetos, como a reutiliza√ß√£o e o suporte. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472186/">https://habr.com/ru/post/pt472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472174/index.html">Personalidade e som: Paul Voight - ‚ÄúSennheiser 30s‚Äù, o pai da banda larga, um cruzamento mec√¢nico e linhas de transmiss√£o</a></li>
<li><a href="../pt472176/index.html">Museu Virtual Pushkin</a></li>
<li><a href="../pt472178/index.html">Holivar. Hist√≥ria do Runet. Parte 7. YouTube: comediantes, guinchos e Vale do Sil√≠cio</a></li>
<li><a href="../pt472182/index.html">An√∫ncio do .NET Core 3.1 Preview 1</a></li>
<li><a href="../pt472184/index.html">SSH remoto: dicas e truques</a></li>
<li><a href="../pt472188/index.html">O que voc√™ precisa saber sobre a Verifica√ß√£o de cheque na App Store (recibo da App Store)</a></li>
<li><a href="../pt472190/index.html">Execute scripts PHP via php-fpm sem um servidor web. Ou seu cliente FastCGI (sob o cap√¥)</a></li>
<li><a href="../pt472196/index.html">"A√ß√∫car" caseiro para um projeto Android ou "Como n√£o fazer"</a></li>
<li><a href="../pt472198/index.html">Localiza√ß√£o de mensagens push em aplicativos m√≥veis</a></li>
<li><a href="../pt472200/index.html">Moderniza√ß√£o da aula de ci√™ncia da computa√ß√£o em uma escola russa de framboesa: barato e alegre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>