<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾 👨🏼‍🔬 🧑🏽‍🤝‍🧑🏽 Princípio aberto-fechado 🛀🏽 🧗🏻 👨🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Aqui está a tradução de um artigo de Robert Martin, do Princípio Aberto-Fechado , que ele publicou em janeiro de 1996. O artigo, para dizer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Princípio aberto-fechado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Olá Habr!  Aqui está a tradução de um artigo de Robert Martin, do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20060822033314/">Princípio Aberto-Fechado</a> , que ele publicou em janeiro de 1996.  O artigo, para dizer o mínimo, não é o mais recente.  Mas no RuNet, os artigos do tio Bob sobre o SOLID são recontados apenas de forma truncada, então pensei que uma tradução completa não seria supérflua. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  Decidi começar com a letra O, já que o princípio de abertura-fechamento é de fato central.  Entre outras coisas, há muitas sutilezas importantes que merecem atenção: </p><br><ul><li>  Nenhum programa pode ser "fechado" 100%. </li><li>  A programação orientada a objetos (OOP) opera não com objetos físicos do mundo real, mas com conceitos - por exemplo, o conceito de "ordenação". <a name="habracut"></a></li></ul><br><p>  Este é o primeiro artigo da minha coluna <em>Engineer Notes</em> para <em>The C ++ Report</em> .  Os artigos publicados nesta coluna se concentrarão no uso de C ++ e OOP e abordarão as dificuldades no desenvolvimento de software.  Vou tentar tornar os materiais pragmáticos e úteis para a prática de engenheiros.  Para a documentação do design orientado a objetos nestes artigos, utilizarei a notação de Buch. </p><br><p>  Existem muitas heurísticas associadas à programação orientada a objetos.  Por exemplo, “todas as variáveis ​​de membro devem ser privadas” ou “variáveis ​​globais devem ser evitadas” ou “a determinação de tipo em tempo de execução é perigosa”.  Qual o motivo de tais heurísticas?  Por que eles são verdadeiros?  Eles <em>sempre são</em> verdadeiros?  Esta coluna explora o princípio de design subjacente a essas heurísticas - o princípio de abertura-fechamento. <br>  Ivar Jacobson disse: “Todos os sistemas mudam durante o ciclo de vida.  Isso deve ser lembrado ao projetar um sistema com mais de uma versão esperada. ”  Como podemos projetar um sistema para que ele seja estável diante das mudanças e que tenha mais de uma versão esperada?  Bertrand Meyer nos contou sobre isso em 1988, quando o agora famoso princípio da abertura-proximidade foi formulado: </p><br><p>  <strong>As entidades do programa (classes, módulos, funções, etc.) devem estar abertas para expansão e fechadas para alterações.</strong> </p><br><p>  Se uma alteração no programa envolve uma cascata de alterações nos módulos dependentes, sinais indesejáveis ​​de um design "ruim" aparecem no programa. </p><br><p>  O programa se torna frágil, inflexível, imprevisível e sem uso.  O princípio da abertura-proximidade resolve esses problemas de maneira muito direta.  Ele diz que é necessário projetar módulos que nunca <em>mudam</em> .  Quando os requisitos mudam, você precisa expandir o comportamento de tais módulos adicionando novo código, em vez de alterar o código antigo que já está funcionando. </p><br><h1>  Descrição do produto </h1><br><p>  Módulos que atendem ao princípio de abertura-proximidade têm duas características principais: </p><br><ol><li>  <strong>Aberto para expansão.</strong>  Isso significa que o comportamento do módulo pode ser expandido.  Ou seja, podemos adicionar um novo comportamento ao módulo de acordo com os requisitos variáveis ​​do aplicativo ou para atender às necessidades de novos aplicativos. </li><li>  <strong>Fechado para mudança.</strong>  O código fonte desse módulo é intocável.  Ninguém tem o direito de fazer alterações. </li></ol><br><p>  Parece que esses dois sinais não se encaixam.  A maneira padrão de estender o comportamento de um módulo é fazer alterações nele.  Um módulo que não pode ser alterado geralmente é pensado como um módulo com comportamento fixo.  Como essas duas condições opostas podem ser cumpridas? </p><br><h1>  A chave da solução é a abstração. </h1><br><p>  No C ++, usando os princípios do design orientado a objetos, é possível criar abstrações fixas que podem representar um conjunto ilimitado de comportamentos possíveis. </p><br><p>  Abstrações são classes básicas abstratas e um conjunto ilimitado de comportamentos possíveis é representado por todas as classes possíveis possíveis.  Um módulo pode manipular a abstração.  Esse módulo está fechado para alterações, pois depende de uma abstração fixa.  Além disso, o comportamento do módulo pode ser expandido criando novos descendentes da abstração. </p><br><p> O diagrama abaixo mostra uma opção de design simples que não atende ao princípio de abertura-proximidade.  Ambas as classes, <code>Client</code> e <code>Server</code> , não são abstratas.  Não há garantia de que as funções que são membros da classe <code>Server</code> sejam virtuais.  A classe <code>Client</code> usa a classe <code>Server</code> .  Se queremos que o objeto da classe <code>Client</code> use um objeto de servidor diferente, devemos alterar a classe <code>Client</code> para se referir à nova classe de servidor. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="imagem"><br>  <em>Cliente fechado</em> </p><br><p>  E o diagrama a seguir mostra a opção de design correspondente, que atende ao princípio de abertura-proximidade.  Nesse caso, a classe <code>AbstractServer</code> é uma classe abstrata, cujas funções de membro são virtuais.  A classe <code>Client</code> usa abstração.  No entanto, os objetos da classe <code>Client</code> usarão objetos da classe sucessora do <code>Server</code> .  Se quisermos que objetos da classe <code>Client</code> usem uma classe de servidor diferente, apresentaremos um novo descendente da classe <code>AbstractServer</code> .  A classe <code>Client</code> permanecerá inalterada. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="imagem"><br>  <em>Cliente aberto</em> </p><br><h1>  Resumo da <code>Shape</code> </h1><br><p>  Considere um aplicativo que deve desenhar círculos e quadrados em uma GUI padrão.  Círculos e quadrados devem ser desenhados em uma ordem específica.  Na ordem correspondente, uma lista de círculos e quadrados será compilada, o programa deve passar por essa lista na ordem e desenhar cada círculo ou quadrado. </p><br><p>  Em C, usando técnicas de programação procedural que não atendem ao princípio de abertura / fechamento, podemos resolver esse problema, como mostra a Listagem 1. Aqui vemos muitas estruturas de dados com o mesmo primeiro elemento.  Este elemento é um código de tipo que identifica a estrutura de dados como um círculo ou quadrado.  A função <code>DrawAllShapes</code> passa por uma matriz de ponteiros para essas estruturas de dados, reconhecendo o código de tipo e chamando a função correspondente ( <code>DrawCircle</code> ou <code>DrawSquare</code> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  A função <code>DrawAllShapes</code> não atende ao princípio do fechamento de abertura, porque não pode ser "fechado" a partir de novos tipos de formas.  Se eu quisesse expandir essa função com a capacidade de desenhar formas de uma lista que inclui triângulos, precisaria alterar a função.  Na verdade, preciso alterar a função para cada novo tipo de forma que preciso desenhar. </p><br><p>  Obviamente, este programa é apenas um exemplo.  Na vida real, o operador do <code>DrawAllShapes</code> função <code>DrawAllShapes</code> seria repetido várias vezes em várias funções em todo o aplicativo e cada uma faria algo diferente.  Adicionar novas formas a esse aplicativo significa encontrar todos os locais onde essas <code>switch</code> (ou <code>if/else</code> cadeia) são usadas e adicionar uma nova forma a cada uma delas.  Além disso, é muito improvável que todas as <code>switch</code> e cadeias <code>if/else</code> sejam tão bem estruturadas quanto no <code>DrawAllShapes</code> .  É muito mais provável que predicados em <code>if</code> sejam combinadas com operadores lógicos ou blocos de casos de <code>switch</code> de <code>switch</code> sejam combinados de forma a "simplificar" um local específico no código.  Portanto, o problema de encontrar e entender todos os locais em que você precisa adicionar uma nova figura pode não ser trivial. </p><br><p>  Na Listagem 2, mostrarei o código que demonstra uma solução quadrada / circular que atende ao princípio do fechamento de abertura.  Uma classe <code>Shape</code> abstrata é introduzida.  Esta classe abstrata contém uma função <code>Draw</code> pura e virtual.  As classes <code>Circle</code> e <code>Square</code> são descendentes da classe <code>Shape</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Observe que, se quisermos estender o comportamento da função <code>DrawAllShapes</code> na Listagem 2 para desenhar um novo tipo de forma, tudo o que precisamos fazer é adicionar um novo descendente da classe <code>Shape</code> .  Não há necessidade de alterar a função <code>DrawAllShapes</code> .  Portanto, <code>DrawAllShapes</code> atende ao princípio de abertura-proximidade.  Seu comportamento pode ser expandido sem alterar a própria função. </p><br><p>  No mundo real, a classe <code>Shape</code> conteria muitos outros métodos.  Ainda assim, adicionar uma nova forma ao aplicativo ainda é muito simples, pois tudo que você precisa fazer é inserir um novo herdeiro e implementar essas funções.  Não há necessidade de vasculhar todo o aplicativo em busca de locais que exigem mudanças. </p><br><p>  Portanto, os programas que atendem ao princípio da abertura-proximidade são alterados adicionando novo código, e não alterando o existente; eles não transformam em cascata as alterações características dos programas que não correspondem a esse princípio. </p><br><h1>  Estratégia de entrada fechada </h1><br><p>  Obviamente, nenhum programa pode ser 100% fechado.  Por exemplo, o que acontece com a função <code>DrawAllShapes</code> na Listagem 2 se decidirmos que círculos e quadrados devem ser desenhados primeiro?  A função <code>DrawAllShapes</code> não <code>DrawAllShapes</code> fechada para esse tipo de alteração.  Em geral, não importa o quão "fechado" o módulo esteja, sempre há algum tipo de alteração da qual ele não está fechado. </p><br><p>  Como o fechamento não pode ser completo, ele deve ser introduzido estrategicamente.  Ou seja, o designer deve escolher os tipos de alterações das quais o programa será fechado.  Isso requer alguma experiência.  Um desenvolvedor experiente conhece os usuários e o setor suficientemente bem para calcular a probabilidade de várias alterações.  Ele então garante que o princípio da abertura-proximidade seja respeitado nas mudanças mais prováveis. </p><br><h2>  Uso de abstração para obter proximidade adicional </h2><br><p>  Como podemos fechar a função <code>DrawAllShapes</code> de alterações na ordem do desenho?  Lembre-se de que o fechamento é baseado na abstração.  Portanto, para fechar <code>DrawAllShapes</code> do pedido, precisamos de algum tipo de "abstração do pedido".  Um caso especial de pedido, apresentado acima, é desenhar figuras de um tipo na frente de figuras de outro tipo. </p><br><p>  A política de pedidos implica que, com dois objetos, você pode determinar qual deles deve ser desenhado primeiro.  Portanto, podemos definir um método para a classe <code>Shape</code> chamada <code>Precedes</code> , que pega outro objeto <code>Shape</code> como argumento e retorna um valor booleano <code>true</code> se o objeto <code>Shape</code> que recebeu essa mensagem precisar ser classificado antes do objeto <code>Shape</code> que foi passado como argumento. </p><br><p>  No C ++, essa função pode ser representada como uma sobrecarga do operador "&lt;".  A Listagem 3 mostra a classe <code>Shape</code> com métodos de classificação. </p><br><p>  Agora que temos uma maneira de determinar a ordem dos objetos da classe <code>Shape</code> , podemos classificá-los e desenhá-los.  A Listagem 4 mostra o código C ++ correspondente.  Ele usa as classes <code>Set</code> , <code>OrderedSet</code> e <code>Iterator</code> da categoria <code>Components</code> desenvolvida em meu livro (Designing Applications C ++ Orientados a Objetos usando o Método Booch, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Portanto, implementamos a ordem dos objetos da classe <code>Shape</code> e os desenhamos na ordem apropriada.  Mas ainda não temos uma implementação da abstração do pedido.  Obviamente, todo objeto <code>Shape</code> deve substituir o método <code>Precedes</code> para determinar a ordem.  Como isso pode funcionar?  Que código precisa ser escrito em <code>Circle::Precedes</code> para que os círculos sejam desenhados em quadrados?  Preste atenção na lista 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  É claro que essa função não atende ao princípio da abertura-proximidade.  Não há como fechá-lo dos novos descendentes da classe <code>Shape</code> .  Cada vez que um novo descendente da classe <code>Shape</code> aparece, essa função precisa ser alterada. </p><br><h2>  Usando uma abordagem orientada a dados para obter o fechamento </h2><br><p>  A proximidade dos herdeiros da classe <code>Shape</code> pode ser obtida usando uma abordagem tabular que não provoca alterações em cada classe herdada.  Um exemplo dessa abordagem é mostrado na Listagem 6. </p><br><p>  Usando essa abordagem, fechamos com êxito a função <code>DrawAllShapes</code> das alterações relacionadas à ordem e a cada descendente da classe <code>Shape</code> - da introdução de um novo descendente ou de uma alteração na política de ordenação de objetos da classe <code>Shape</code> dependendo do tipo (por exemplo, objetos da classe <code>Squares</code> ser desenhado primeiro). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  O único elemento que não está impedido de alterar a ordem das formas de desenho é uma tabela.  A tabela pode ser colocada em um módulo separado, separado de todos os outros módulos e, portanto, suas alterações não afetarão outros módulos. </p><br><h2>  Fechamento adicional </h2><br><p>  Este não é o fim da história.  Fechamos a hierarquia da classe <code>Shape</code> e a função <code>DrawAllShapes</code> de alterar a política de pedidos com base no tipo de formas.  No entanto, os descendentes da classe <code>Shape</code> não estão fechados das políticas de pedidos que não estão associadas aos tipos de <code>Shape</code> .  Parece que precisamos organizar o desenho das formas de acordo com uma estrutura de nível superior.  Um estudo completo desses problemas está além do escopo deste artigo;  no entanto, um leitor interessado pode pensar em como resolver esse problema usando a classe abstrata <code>OrderedObject</code> contida na classe <code>OrderedShape</code> , que herda das <code>OrderedObject</code> <code>Shape</code> e <code>OrderedObject</code> . </p><br><h1>  Heurísticas e Convenções </h1><br><p>  Como já mencionado no início do artigo, o princípio de abertura-proximidade é a principal motivação por trás de muitas heurísticas e convenções que surgiram ao longo dos muitos anos de desenvolvimento do paradigma OOP.  A seguir, são os mais importantes. </p><br><h2>  Tornar todas as variáveis ​​de membro privadas </h2><br><p>  Esta é uma das convenções mais duradouras da OLP.  As variáveis ​​de membro devem ser conhecidas apenas pelos métodos da classe em que estão definidas.  Membros variáveis ​​não devem ser conhecidos por nenhuma outra classe, incluindo classes derivadas.  Portanto, eles devem ser declarados com um modificador de acesso <code>private</code> , não <code>public</code> ou <code>protected</code> . <br>  À luz do princípio da abertura-proximidade, a razão de tal convenção é compreensível.  Quando as variáveis ​​dos membros da classe mudam, cada função que depende delas deve mudar.  Ou seja, a função não está fechada de alterações nessas variáveis. </p><br><p>  Em OOP, esperamos que os métodos de uma classe não sejam fechados para alterações nas variáveis ​​que são membros dessa classe.  No entanto, esperamos que qualquer outra classe, incluindo subclasses, seja fechada de alterações nessas variáveis.  Isso é chamado de encapsulamento. </p><br><p>  Mas e se você tiver uma variável sobre a qual tenha certeza de que ela nunca mudará?  Faz sentido torná-lo <code>private</code> ?  Por exemplo, a Listagem 7 mostra a classe <code>Device</code> que contém o <code>bool status</code> membro variável.  Ele armazena o status da última operação.  Se a operação foi bem-sucedida, o valor da variável <code>status</code> será <code>true</code> , caso contrário, <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Sabemos que o tipo ou significado dessa variável nunca será alterado.  Então, por que não torná-lo <code>public</code> e dar ao cliente acesso direto a ele?  Se a variável realmente nunca mudar, se todos os clientes seguirem as regras e apenas lerem essa variável, não haverá nada de errado com o fato de a variável ser pública.  No entanto, considere o que acontecerá se um dos clientes aproveitar a oportunidade para gravar nessa variável e alterar seu valor. </p><br><p>  De repente, esse cliente pode afetar a operação de qualquer outro cliente da classe <code>Device</code> .  Isso significa que é impossível fechar os clientes da classe <code>Device</code> das alterações neste módulo incorreto.  Isso é muito risco. </p><br><p>  Por outro lado, suponha que tenhamos a classe <code>Time</code> , mostrada na Listagem 8. Qual é o perigo de publicidade das variáveis ​​que são membros dessa classe?  É muito improvável que eles mudem.  Além disso, não importa se os módulos do cliente alteram os valores dessas variáveis ​​ou não, pois é assumida uma alteração nessas variáveis.  Também é muito improvável que classes herdadas possam depender do valor de uma variável de membro específica.  Então, há algum problema? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  A única reclamação que eu poderia apresentar ao código da Listagem 8 é que a mudança de horário não é atômica.  Ou seja, o cliente pode alterar o valor da variável de <code>minutes</code> sem alterar o valor da variável de <code>hours</code> .  Isso pode fazer com que um objeto da classe <code>Time</code> contenha dados inconsistentes.  Eu preferiria introduzir uma única função para definir a hora, que levaria três argumentos, o que tornaria a configuração da hora uma operação atômica.  Mas este é um argumento fraco. </p><br><p>  É fácil criar outras condições sob as quais a publicidade dessas variáveis ​​possa levar a problemas.  Em última análise, no entanto, não há motivos convincentes para torná-los <code>private</code> .  Eu ainda acho que tornar essas variáveis ​​públicas é um estilo ruim, mas talvez não seja um design ruim.  Eu acredito que esse é um estilo ruim, porque não custa quase nada entrar nas funções apropriadas para acessar esses membros, e definitivamente vale a pena se proteger do pequeno risco associado à possível ocorrência de problemas com o fechamento. </p><br><p>  Portanto, em casos tão raros, quando o princípio de abertura-fechamento não é violado, a proibição de variáveis <code>public</code> - e <code>protected</code> depende mais do estilo e não do conteúdo. </p><br><h2>  Nenhuma variável global ... de jeito nenhum! </h2><br><p>  O argumento contra variáveis ​​globais é o mesmo que o argumento contra variáveis ​​membro públicas.  Nenhum módulo que depende de uma variável global pode ser fechado a partir de um módulo que possa gravar nela.  Qualquer módulo que use essa variável de uma maneira não pretendida por outros módulos quebrará esses módulos.  É muito arriscado ter muitos módulos, dependendo dos caprichos de um único módulo malicioso. <br>  Por outro lado, nos casos em que variáveis ​​globais têm um pequeno número de módulos dependentes delas ou não podem ser usadas da maneira errada, elas não causam danos.  O designer deve avaliar quanta privacidade é sacrificada e determinar se a conveniência fornecida pela variável global vale a pena. </p><br><p>  Aqui, novamente, problemas de estilo entram em cena.  Alternativas ao uso de variáveis ​​globais geralmente são baratas.  Nesses casos, o uso de uma técnica que introduz, embora pequena, mas um risco de fechamento, em vez de uma técnica que elimina completamente esse risco, é um sinal de mau estilo.  No entanto, às vezes o uso de variáveis ​​globais é realmente conveniente.  Um exemplo típico são as variáveis ​​globais cout e cin.  Nesses casos, se o princípio de abertura-proximidade não for violado, você poderá sacrificar o estilo por conveniência. </p><br><h2>  RTTI é perigoso </h2><br><p>  Outra proibição comum é o uso de <code>dynamic_cast</code> .  Freqüentemente, <code>dynamic_cast</code> ou alguma outra forma de determinação do tipo de tempo de execução (RTTI) é acusada de ser uma técnica extremamente perigosa e, portanto, deve ser evitada.  Ao mesmo tempo, eles geralmente dão um exemplo da Lista 9, que obviamente viola o princípio de abertura-proximidade.  No entanto, a Listagem 10 mostra um exemplo de programa semelhante que usa <code>dynamic_cast</code> sem violar o princípio de abertura e fechamento. </p><br><p>  A diferença entre eles é que, no primeiro caso, mostrado na Listagem 9, o código precisa ser alterado toda vez que um novo descendente da classe <code>Shape</code> aparece (sem mencionar que essa é uma solução absolutamente ridícula).  No entanto, na Listagem 10, nenhuma mudança é necessária neste caso.  Portanto, o código na Listagem 10 não viola o princípio de abertura e fechamento. <br>  Nesse caso, a regra geral é que o RTTI pode ser usado se o princípio do fechamento da abertura não for violado. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Conclusão </h1><br><p>  Eu poderia falar por um longo tempo sobre o princípio da abertura-proximidade.  De muitas maneiras, esse princípio é mais importante para a programação orientada a objetos.  A conformidade com esse princípio específico fornece as principais vantagens da tecnologia orientada a objetos, como a reutilização e o suporte. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472186/">https://habr.com/ru/post/pt472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472174/index.html">Personalidade e som: Paul Voight - “Sennheiser 30s”, o pai da banda larga, um cruzamento mecânico e linhas de transmissão</a></li>
<li><a href="../pt472176/index.html">Museu Virtual Pushkin</a></li>
<li><a href="../pt472178/index.html">Holivar. História do Runet. Parte 7. YouTube: comediantes, guinchos e Vale do Silício</a></li>
<li><a href="../pt472182/index.html">Anúncio do .NET Core 3.1 Preview 1</a></li>
<li><a href="../pt472184/index.html">SSH remoto: dicas e truques</a></li>
<li><a href="../pt472188/index.html">O que você precisa saber sobre a Verificação de cheque na App Store (recibo da App Store)</a></li>
<li><a href="../pt472190/index.html">Execute scripts PHP via php-fpm sem um servidor web. Ou seu cliente FastCGI (sob o capô)</a></li>
<li><a href="../pt472196/index.html">"Açúcar" caseiro para um projeto Android ou "Como não fazer"</a></li>
<li><a href="../pt472198/index.html">Localização de mensagens push em aplicativos móveis</a></li>
<li><a href="../pt472200/index.html">Modernização da aula de ciência da computação em uma escola russa de framboesa: barato e alegre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>