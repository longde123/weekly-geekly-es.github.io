<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â¬›ï¸ â­ï¸ ğŸ§¡ Mengapa seorang pria di dunia Jawa menjadi pendukung Node.js dan JavaScript yang bersemangat? ğŸ‘©ğŸ¿â€ğŸ’» ğŸ‘ŒğŸ¿ ğŸ¤˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="David Harron, penulis materi yang kami terbitkan hari ini, mengajukan pertanyaan berikut: â€œHaruskah seseorang yang telah bekerja selama lebih dari 10 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa seorang pria di dunia Jawa menjadi pendukung Node.js dan JavaScript yang bersemangat?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/421741/">  David Harron, penulis materi yang kami terbitkan hari ini, mengajukan pertanyaan berikut: â€œHaruskah seseorang yang telah bekerja selama lebih dari 10 tahun di Sun Microsystems, di tim Java SE, sampai nafas terakhir hanya memikirkan Java bytecode dan membuat instance antarmuka abstrak? ".  Dia mengajukan pertanyaan ini sehubungan dengan dirinya sendiri, dan baginya platform Node.js, setelah Jawa, ternyata seperti embusan angin segar.  David mengatakan bahwa ketika dia dipecat dari Sun pada Januari 2009 (tepat sebelum pengambilalihan perusahaan Oracle ini), dia mengetahui tentang Node.js.  Teknologi ini mengaitkannya.  Apa artinya "ketagihan"?  Sejak 2010, ia banyak menulis tentang pemrograman untuk Node.js.  Yaitu, ia menulis beberapa buku, termasuk Node.js Web Development, edisi keempat yang dirilis tahun ini.  Dia telah menyiapkan banyak materi kecil tentang Node.js yang diterbitkan di Internet.  Bahkan, ia menghabiskan banyak waktu dan upaya untuk berbicara tentang platform Node.js dan fitur JavaScript.  Mengapa mereka yang sebelumnya bekerja secara eksklusif di Jawa begitu tertarik dengan Node.js dan JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a7f/04b/29b/a7f04b29bb9ae083524906ac68f0d47b.jpg" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tentang Dunia Jawa</font> </h2><br>  Saat bekerja di Sun, saya percaya pada teknologi Java.  Saya membuat presentasi di JavaONE, berpartisipasi dalam pengembangan kelas java.awt.Robot, menyelenggarakan acara Mustang Regressions Contestions (itu adalah kompetisi yang bertujuan menemukan bug di Jawa 1.6), membantu meluncurkan proyek Lisensi Distribusi untuk Java, yang berfungsi sebagai jawaban untuk pertanyaan tentang distribusi JDK Linux sebelum kedatangan OpenJDK.  Kemudian, saya memainkan peran dalam meluncurkan proyek OpenJDK.  Sepanjang jalan, selama sekitar 6 tahun, saya menerbitkan materi blog di java.net (sekarang situs ini ditutup).  Ini adalah 1-2 artikel per minggu yang didedikasikan untuk peristiwa penting di ekosistem Jawa.  Peran penting dalam pekerjaan saya dimainkan dengan melindungi Jawa dari mereka yang memperkirakan masa depan suram untuk teknologi ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d9/adb/964/0d9adb9644509d8a25f21ebda093c506.jpg"><br>  <i><font color="#999999">Penghargaan ini, Penghargaan Duke, diberikan kepada karyawan Sun yang paling terkemuka.</font></i>  <i><font color="#999999">Saya mendapatkannya setelah saya menyelenggarakan Kontes Regresi Mustang</font></i> <br><br>  Apa yang terjadi pada orang yang melakukan banyak hal dengan segala hal yang berhubungan dengan Jawa?  Sebenarnya, di sini saya ingin berbicara tentang bagaimana saya berubah dari penggemar Java menjadi pendukung Node.js dan JavaScript yang bersemangat. <br><br>  Saya harus mengatakan bahwa apa yang terjadi pada saya tidak dapat disebut sebagai pengabaian sepenuhnya terhadap Jawa.  Selama 3 tahun terakhir, saya telah menulis cukup banyak kode Java, menggunakan Spring dan Hibernate.  Meskipun apa yang sekarang saya lakukan di bidang ini saya sangat suka (saya bekerja di industri energi surya, melakukan apa yang saya sukai, misalnya - saya menulis permintaan untuk bekerja dengan data dari sektor energi), pemrograman Java di mata saya sekarang kehilangan kemegahannya sebelumnya. <br><br>  Dua tahun pengembangan dengan menggunakan Pegas memungkinkan saya untuk dengan jelas mengklarifikasi satu hal penting: upaya untuk menyembunyikan mekanisme kompleks tidak mengarah pada kesederhanaan, itu hanya mengarah pada penampilan struktur yang lebih kompleks. <br><br>  Di sini, secara singkat, adalah ide-ide utama yang akan saya sentuh dalam materi ini: <br><br><ul><li>  Program Java penuh dengan kode boilerplate yang menyembunyikan niat programmer. </li><li>  Bekerja dengan Spring and Spring Boot telah memberi saya pelajaran yang baik, yaitu bahwa mencoba menyembunyikan mekanisme yang rumit mengarah pada konstruksi yang lebih kompleks. </li><li>  Platform Java EE adalah proyek yang dibuat, dengan kata lain, oleh "upaya bersama", yang mencakup sepenuhnya semua kebutuhan pengembangan aplikasi perusahaan.  Akibatnya, platform Java EE telah terbukti menghambat. </li><li>  Berkembang bersama Spring adalah, sampai titik tertentu, pengalaman yang menyenangkan.  Ilusi ini menghilang pada hari ketika pengecualian yang benar-benar mustahil untuk dipahami muncul dari kedalaman suatu subsistem yang belum pernah Anda dengar, dan dibutuhkan setidaknya tiga hari untuk mencari tahu apa masalahnya. </li><li>  Mekanisme bantu apa yang membuat beban berlebihan pada sistem yang Anda butuhkan kerangka kerja yang dapat "menulis" kode untuk programmer? </li><li>  Meskipun IDE seperti Eclipse adalah aplikasi yang kuat, mereka adalah indikator kompleksitas ekosistem Java. </li><li>  Platform Node.js muncul sebagai hasil dari upaya satu orang untuk meningkatkan visinya tentang arsitektur berbasis event yang ringan. </li><li>  Komunitas JavaScript tampaknya sangat antusias untuk menyingkirkan kode boilerplate, yang memungkinkan pemrogram mengekspresikan niat mereka sejelas mungkin. </li><li>  Async / await adalah solusi untuk masalah neraka panggilan balik JS, yang merupakan contoh penolakan kode templat dan berkontribusi pada kejelasan ekspresi niat pemrogram. </li><li>  Pemrograman untuk Node.js adalah kesenangan nyata. </li><li>  Tidak ada ketikan kuat khusus untuk Java dalam JavaScript.  Inilah berkah dan kutukan lidah.  Ini membuatnya lebih mudah untuk menulis kode, tetapi untuk memverifikasi kebenarannya, Anda harus mencurahkan lebih banyak waktu untuk pengujian. </li><li>  Sistem manajemen paket yang diperkenalkan oleh npm / benang mudah dan menyenangkan untuk digunakan.  Dia tidak bisa dibandingkan dengan Maven. </li><li>  Baik Java dan Node.js menawarkan kinerja hebat.  Ini bertentangan dengan mitos bahwa JavaScript adalah bahasa yang lambat, yang penggunaannya menyebabkan kinerja platform Node.js yang buruk. </li><li>  Performance Node.js dibangun berdasarkan upaya Google untuk meningkatkan V8, mesin yang memengaruhi kecepatan browser Chrome. </li><li>  Persaingan sengit antara produsen mesin JS berbasis browser berkontribusi pada pengembangan JavaScript, dan ini sangat bermanfaat bagi Node.js. </li></ul><br><h2>  <font color="#3AC1EF">Tentang Masalah Pembangunan Jawa</font> </h2><br>  Beberapa alat atau benda adalah hasil dari upaya bertahun-tahun oleh para insinyur untuk memperbaikinya.  Pemrogram mencoba ide yang berbeda, menghapus atribut yang tidak perlu, dan sebagai hasilnya mereka mendapatkan entitas di mana ada secara eksklusif apa yang diperlukan untuk memecahkan masalah tertentu.  Seringkali, teknologi semacam itu memiliki semacam kesederhanaan yang sangat menarik yang menyembunyikan kemampuan kuat.  Ini tidak berlaku untuk Java. <br><br>  Spring adalah kerangka kerja populer untuk mengembangkan aplikasi web berbasis Java. <br><br>  Tujuan utama Spring, dan khususnya Spring Boot, adalah untuk memberikan kemampuan untuk menggunakan Java EE stack yang telah dikonfigurasi sebelumnya.  Programmer yang menggunakan Spring tidak boleh, untuk membuat sistem yang sudah jadi, merawat servlet, sistem penyimpanan persisten, server aplikasi, dan apa yang masih belum diketahui.  Semua masalah ini diteruskan ke Spring, dan programmer menulis kode yang mengimplementasikan logika aplikasi.  Misalnya, mekanisme JPARepository bertanggung jawab untuk menghasilkan kueri basis data untuk metode yang namanya mirip dengan <code>findUserByFirstName</code> .  Programmer tidak perlu menulis kode untuk metode seperti itu.  Cukup mengirimkan deskripsi metode ke sistem, dan Spring akan melakukan sisanya. <br><br>  Semuanya terdengar sangat bagus, senang bekerja dengan gaya ini, tetapi - sampai sesuatu yang tidak terduga terjadi. <br><br>  Maksudku situasi di mana, misalnya, Hibernate <code>PersistentObjectException</code> dilemparkan dengan pesan yang <code>detached entity passed to persist</code> .  Apa artinya itu?  Butuh beberapa hari untuk mengetahuinya.  Ternyata, jika Anda menggambarkan semuanya dengan cara yang sangat sederhana, ini berarti bahwa data JSON yang diterima di titik akhir REST memiliki bidang ID dengan beberapa nilai.  Hibernasi, sekali lagi, jika tidak masuk ke detail, berusaha untuk mengontrol nilai ID, dan, sebagai hasilnya, melempar pengecualian yang tidak jelas di atas.  Ada ribuan pesan kesalahan seperti itu yang membingungkan dan sulit dibaca.  Mempertimbangkan bahwa ada seluruh kaskade subsistem berdasarkan satu sama lain di Musim Semi, tumpukan Spring terlihat seperti musuh bebuyutan seorang programmer yang mengawasinya dan menunggu programmer membuat kesalahan sekecil apa pun, dan ketika ini terjadi, melempar pengecualian yang tidak kompatibel dengannya. operasi normal aplikasi. <br><br>  Selanjutnya, di sini Anda dapat mengingat jejak tumpukan terpanjang.  Mereka mewakili beberapa layar penuh dengan segala macam metode abstrak.  Musim semi jelas menciptakan konfigurasi yang diperlukan untuk mengimplementasikan apa yang dinyatakan dalam kode.  Tingkat abstraksi seperti itu, tidak diragukan lagi, memerlukan sejumlah besar logika bantu, yang bertujuan menemukan segala yang diperlukan agar kode berfungsi, misalnya, untuk memenuhi permintaan.  Dan jejak tumpukan panjang belum tentu buruk.  Hal-hal semacam itu lebih cenderung merupakan gejala, yang mengarah pada pertanyaan tentang jenis beban apa pada sistem yang diciptakan oleh mekanisme bantu. <br><br>  Bagaimana metode <code>findUserByFirstName</code> , mengingat bahwa programmer tidak menulis kode untuk metode seperti itu?  Kerangka kerja perlu mem-parsing nama metode, memahami maksud programmer, membuat sesuatu seperti pohon sintaksis abstrak, menghasilkan beberapa jenis kode SQL, dan sebagainya.  Bagaimana semua ini memuat sistem?  Dan semua ini hanya ada sehingga programmer tidak perlu menulis kode? <br><br>  Setelah Anda harus melalui beberapa puluh kali melalui sesuatu seperti mencari makna kesalahan di atas, menghabiskan berminggu-minggu mencoba mengungkap rahasia yang, pada umumnya, Anda tidak boleh mengungkap, Anda bisa sampai pada kesimpulan yang sama dengan yang saya dapatkan. .  Artinya adalah bahwa upaya untuk menyembunyikan mekanisme yang kompleks tidak mengarah pada kesederhanaan, itu hanya mengarah pada penampilan struktur yang lebih kompleks.  Platform Node.js jauh lebih sederhana. <br><br>  Slogan "Masalah Kompatibilitas" menyembunyikan ide bagus, yang menurutnya kompatibilitas ke belakang adalah fitur paling penting dari platform Java.  Kami menganggap ini serius, menempatkan gambar pada t-shirt seperti yang Anda lihat di bawah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2a/cd5/c40/b2acd5c404b3bc69c4d3af9da1fd6952.jpg"><br>  <i><font color="#999999">Kompatibilitas mundur sangat penting.</font></i> <br><br>  Tentu saja, tingkat perhatian terhadap kompatibilitas ke belakang ini dapat menjadi sumber kecemasan yang konstan, dan dari waktu ke waktu bermanfaat untuk menjauh dari mekanisme lama yang tidak lagi menguntungkan. <br><br><h2>  <font color="#3AC1EF">Java dan Node.js</font> </h2><br>  EE Musim Semi dan Java terlalu rumit.  Platform Node.js dengan latar belakang mereka dianggap sebagai angin segar.  Hal pertama yang Anda perhatikan ketika berkenalan dengan Node.js adalah pendekatan Ryan Dahl untuk pengembangan inti platform.  Pengalamannya mengatakan kepadanya bahwa platform yang menggunakan stream diperlukan untuk menciptakan sistem kelas berat yang kompleks.  Dia mencari sesuatu yang lain, dan menghabiskan beberapa tahun untuk memperbaiki set mekanisme dasar yang terkandung dalam Node.js.  Sebagai hasilnya, ia mendapatkan sistem yang ringan yang ditandai dengan satu utas eksekusi, penggunaan inventif fungsi JavaScript anonim sebagai callback asinkron, dan pustaka runtime yang awalnya menerapkan mekanisme asinkron.  Pesan awal saat membuat sistem seperti itu adalah untuk menyediakan pemrosesan acara berkinerja tinggi dengan pengiriman peristiwa ini dalam fungsi panggilan balik. <br><br>  Selanjutnya, fitur penting Node.js adalah penggunaan JavaScript.  Ada perasaan bahwa mereka yang menulis di JS memiliki kecenderungan untuk menyingkirkan kode templat, yang memungkinkan mereka untuk menggambarkan dengan jelas niat programmer. <br><br>  Sebagai contoh perbedaan antara Java dan JavaScript, pertimbangkan implementasi fungsi pendengar (pengamat).  Di Jawa, untuk bekerja dengan pendengar, Anda perlu membuat contoh spesifik dari antarmuka abstrak.  Ini memerlukan penggunaan konstruksi bahasa besar yang menyembunyikan esensi dari apa yang terjadi.  Bagaimana membedakan niat seorang programmer yang tersembunyi di balik sampul kode boilerplate? <br><br>  Sebaliknya, JavaScript menggunakan fungsi anonim sederhana.  Saat menerapkan pendengar, Anda tidak perlu mencari antarmuka abstrak yang cocok.  Sudah cukup, tanpa perlu menggunakan berbagai teks tambahan, untuk menulis kode yang diperlukan. <br><br>  Jadi, berikut adalah satu ide penting yang dapat diambil dari analisis mekanisme di atas: sebagian besar bahasa pemrograman menyembunyikan niat programmer, yang mengarah pada fakta bahwa kode tersebut sulit dipahami. <br><br>  Keputusan tentang penggunaan fungsi callback yang ditawarkan Node.js terlihat sangat menarik.  Tetapi ini bukan tanpa masalah. <br><br><h2>  <font color="#3AC1EF">Pemecahan Masalah dan Pemecahan Masalah</font> </h2><br>  Dalam JavaScript, sudah ada dua masalah yang terkait dengan pemrograman asinkron.  Yang pertama adalah apa yang disebut Node.js panggilan balik neraka.  Masalah ini terletak pada kenyataan bahwa, selama pengembangan, mudah untuk jatuh ke dalam jebakan yang dibangun dari fungsi-fungsi callback yang sangat bersarang, di mana setiap tingkat bersarang mempersulit program, serta memproses hasil kode dan kesalahan.  Ada masalah lain yang terkait dengan ini, intinya adalah bahwa mekanisme bahasa JavaScript tidak membantu programmer mengekspresikan ide-ide eksekusi kode asynchronous. <br><br>  Beberapa perpustakaan telah muncul untuk menyederhanakan pengembangan asinkron pada JS.  Tapi ini adalah contoh lain dari upaya untuk menyembunyikan mekanisme kompleks yang hanya mengarah pada tampilan struktur yang lebih kompleks. <br><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs lua">const async = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'async'</span></span>); const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); const cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filez, fini)</span></span></span></span> { async.eachSeries(filez, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filenm, next)</span></span></span></span> {   fs.readFile(filenm, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(err);     process.<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(data, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(err);       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>();     });   }); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) fini(err);   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fini(); }); }; cat(process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) console.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>(err.stack); });</code> </pre> <br>  Ini adalah tiruan sederhana dari <code>cat</code> Unix.  Pustaka <code>async</code> dalam menyederhanakan urutan panggilan asinkron.  Namun, penggunaannya membutuhkan sejumlah besar kode boilerplate yang menyembunyikan maksud programmer. <br><br>  Intinya, kode ini berisi loop.  Itu tidak ditulis sebagai siklus reguler, tidak menggunakan konstruksi alami dari deskripsi siklus.  Selanjutnya, hasil eksekusi kode dan kesalahan yang dihasilkan oleh mereka tidak sampai ke tempat mereka seharusnya benar.  Mereka dikunci dalam callback, yang tidak nyaman.  Tapi, sebelum penerapan standar ES2015 / 2016 di Node.js, tidak ada yang lebih baik yang bisa dilakukan. <br><br>  Jika kami menulis ulang kode ini dengan mempertimbangkan fitur-fitur baru, yang, khususnya, tersedia di Node.js 10.x, kami mendapatkan yang berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>).promises; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filenmz</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filenm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> filenmz) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fs.readFile(filenm, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     process.stdout.write(data, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, (err) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) reject(err);       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resolve();     });   }); } } cat(process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>)).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err.stack); });</code> </pre> <br>  Dalam contoh ini, kami menggunakan konstruk <code>async/await</code> .  Mekanisme asinkron yang sama disajikan di sini seperti pada contoh sebelumnya, tetapi struktur yang biasa digunakan dalam mengatur loop digunakan di sini.  Bekerja dengan hasil dan kesalahan terlihat sangat normal.  Kode semacam itu lebih mudah dibaca dan ditulis.  Pendekatan ini memudahkan untuk memahami maksud programmer. <br><br>  Satu-satunya kelemahan adalah bahwa <code>process.stdout.write</code> tidak memiliki antarmuka Promise, akibatnya, mekanisme ini tidak dapat digunakan dalam fungsi async tanpa membungkusnya dengan janji. <br><br>  Sekarang kita dapat menyimpulkan bahwa masalah panggilan balik neraka dalam JavaScript telah dipecahkan dengan cara yang berbeda dengan mencoba menyembunyikan mekanisme yang kompleks.  Sebagai gantinya, perubahan dilakukan pada bahasa, yang memecahkan masalah itu sendiri, dan menyelamatkan kami dari ketidaknyamanan yang disebabkan oleh kebutuhan untuk menggunakan sejumlah besar kode templat dalam solusi sementara.  Selain itu, dengan menggunakan mekanisme async / menunggu, kode menjadi lebih indah. <br><br>  Kami memulai bagian ini dengan diskusi tentang kelemahan Node.js, tetapi solusi yang sangat baik untuk panggilan balik yang hebat menyebabkan pembicaraan tentang kekurangan berubah menjadi pembicaraan tentang kekuatan Node.js dan JavaScript. <br><br><h2>  <font color="#3AC1EF">Ketikan, antarmuka, dan kejelasan kode imajiner yang kuat</font> </h2><br>  Pada hari-hari ketika saya melindungi Java dari segala macam serangan, saya menekankan bahwa pengetikan yang ketat memungkinkan Anda untuk menulis aplikasi besar.  Pada masa itu, pengembangan sistem monolitik sedang digunakan (tidak ada layanan mikro, tidak ada Docker dan sejenisnya).  Karena Java adalah bahasa yang sangat diketik, kompiler Java membantu programmer menghindari banyak masalah dengan mencegahnya dari mengkompilasi kode yang salah. <br><br>  JavaScript, tidak seperti Java, tidak diketik dengan kuat.  Dari sini kita dapat membuat kesimpulan yang jelas bahwa programmer tidak tahu persis objek apa yang harus dia kerjakan.  Bagaimana seorang programmer bisa tahu apa yang harus dilakukan, misalnya, dengan objek tertentu yang diterima dari suatu tempat? <br><br>  Sisi lain dari pengetikan Java yang kuat adalah Anda harus terus-menerus melakukan tindakan boilerplate.  Programmer terus-menerus melakukan casting atau memeriksa bahwa semuanya persis seperti yang diharapkan.  Pengembang menghabiskan waktu menulis kode, melakukannya dengan akurasi luar biasa, menggunakan banyak sekali desain template, dan berharap semua ini akan membantunya menghemat waktu dengan deteksi dini dan koreksi kesalahan. <br><br>  Masalah pemrograman dalam bahasa yang diketik sangat besar sehingga seorang programmer, yang hampir tidak memiliki pilihan, harus menggunakan IDE yang besar dan kompleks.  Editor kode sederhana tidak cukup di sini.  Satu-satunya cara untuk menjaga programmer Java dalam kondisi yang memadai (dengan pengecualian pizza) adalah dengan terus-menerus menunjukkan kepadanya daftar drop-down yang berisi bidang objek yang tersedia atau deskripsi parameter metode.  Ini dan mekanisme pendukung lainnya dari IDE seperti Eclipse, NetBeans, atau IntelliJ membantu dalam pembuatan kelas, memfasilitasi refactoring, dan tugas-tugas lainnya. <br><br>  Dan ... aku tidak akan berbicara tentang Maven.  Ini hanyalah alat mimpi buruk. <br><br>  Dalam JavaScript, tipe variabel tidak ditentukan saat dideklarasikan, tipe casting biasanya tidak digunakan, dan sebagainya.  Akibatnya, kode lebih mudah dibaca, tetapi keadaan ini juga berarti risiko kesalahan pemrograman yang sulit dideteksi. <br><br>  Apakah yang disebutkan di atas berkaitan dengan nilai plus Jawa atau minus tergantung pada sudut pandang. <br><br>  Sepuluh tahun yang lalu, saya percaya bahwa semua kesulitan ini membenarkan diri mereka sendiri dengan memberi programmer lebih percaya diri pada kode yang dia tulis.  Hari ini, saya percaya bahwa pengetikan yang kuat meningkatkan beban kerja programmer dan jauh lebih mudah untuk mengembangkan proyek seperti yang mereka lakukan dalam JavaScript. <br><br><h2>  <font color="#3AC1EF">Perangi kesalahan dengan modul kecil yang mudah diuji</font> </h2><br>  Node.js mendorong programmer untuk memecah proyek-proyeknya menjadi fragmen kecil, menjadi modul yang disebut.  Anda mungkin menemukan fakta ini tidak signifikan, tetapi sebagian menyelesaikan masalah yang baru saja kami sebutkan. <br><br>  Berikut adalah karakteristik utama dari modul: <br><br><ul><li>  Kemandirian  Modul ini menggabungkan kode yang saling berhubungan menjadi satu kesatuan. </li><li>  Batas yang jelas.  Kode di dalam modul dilindungi dari gangguan oleh mekanisme eksternal. </li><li>  Ekspor eksplisit.  Secara default, kode dan data modul tidak diekspor.  Pengembang secara independen memutuskan fungsi dan data mana yang harus tersedia untuk umum. </li><li>  Impor eksplisit.  Ketika mengembangkan sebuah modul, programmer memutuskan sendiri modul mana yang akan ia andalkan. </li><li>  Potensi independensi.  Modul dapat dibuat tersedia untuk umum, dalam arti yang sangat luas, dengan menerbitkannya dalam npm, atau, jika ditujukan untuk kebutuhan internal perusahaan, dengan menerbitkan dalam repositori tertutup.  Ini membuatnya mudah untuk menggunakan modul yang sama di aplikasi yang berbeda. </li><li>  Kode mudah dimengerti.  Fakta bahwa modulnya kecil, menyederhanakan pembacaan dan pemahaman kode mereka, membuka kemungkinan untuk diskusi bebas tentang mereka. </li><li>  Fasilitasi pengujian.  Modul kecil, jika diimplementasikan dengan benar, dapat dengan mudah diuji unit. </li></ul><br>  Semua ini membuat modul Node.js entitas dengan batas yang jelas, kode yang mudah ditulis, dibaca, dan diuji. <br><br>  Namun, khawatir tentang bekerja dengan JavaScript adalah fakta bahwa kurangnya pengetikan yang kuat dapat dengan mudah menyebabkan kode melakukan sesuatu yang salah.  Dalam sebuah modul kecil yang ditujukan untuk memecahkan beberapa masalah sempit dengan batasan yang jelas, "ada sesuatu yang salah" hanya dapat mempengaruhi kode modul itu sendiri.  Ini mengarah pada fakta bahwa masalah yang dapat menyebabkan kurangnya pengetikan yang ketat, terkunci di dalam modul. <br><br>  Solusi lain untuk masalah pengetikan dinamis dalam JavaScript adalah dengan menguji kode secara menyeluruh. <br><br>  Pengembang harus menganggap serius pengujian, yang menghilangkan sebagian manfaat yang berasal dari kesederhanaan proses pengembangan JS.  Sistem pengujian yang dibuat oleh seorang programmer JS harus menemukan kesalahan-kesalahan itu, jika dikembangkan olehnya dalam sesuatu seperti Java, kompiler dapat secara otomatis menemukan.  Apakah Anda menulis tes untuk aplikasi JS Anda? <br><br>  Bagi mereka yang membutuhkan sistem pengetikan statis dalam JavaScript, mungkin bermanfaat untuk melihat pada TypeScript.  Saya tidak menggunakan bahasa ini, tetapi saya telah mendengar banyak hal baik tentang itu.  Ini kompatibel dengan JavaScript dan memperluas bahasa dengan sistem kontrol tipe dan fitur berguna lainnya. <br><br>  Pada akhirnya, kita dapat mengatakan bahwa menggunakan pendekatan modular untuk pengembangan adalah kekuatan dari Node.js dan JavaScript. <br><br><h2>  <font color="#3AC1EF">Manajemen paket</font> </h2><br>  Saya merasa tidak enak hanya dengan memikirkan Maven, jadi saya bahkan tidak bisa menulis dengan normal tentang itu.  Dan, seperti yang saya pahami, Maven, tanpa kompromi, dicintai atau dibenci. <br><br>  Masalahnya di sini adalah bahwa di lingkungan Java tidak ada sistem holistik untuk mengelola paket.  Paket Maven ada, Anda dapat bekerja dengan mereka secara normal, mereka didukung oleh Gradle.  Tetapi cara kerja dengan mereka diatur tidak mirip dengan kenyamanan yang diberikan oleh sistem manajemen paket untuk Node.js kepada pengembang. <br><br>  Di dunia Node.js, ada dua manajer paket hebat yang saling bekerja sama.  Pada awalnya, satu-satunya alat tersebut adalah repositori npm dan alat baris perintah dengan nama yang sama. <br><br>  Berkat npm, kami memiliki skema yang sangat baik untuk menggambarkan dependensi paket.  Ketergantungan dapat ketat (katakanlah, ini mengindikasikan bahwa hanya versi 1.2.3 dari paket tertentu yang diperlukan), atau diberikan dengan beberapa derajat kebebasan - hingga <code>*</code> , yang berarti menggunakan versi terbaru dari paket tertentu. <br><br>  Komunitas Node.js telah menerbitkan ratusan ribu paket di repositori npm.  Pada saat yang sama, menggunakan paket-paket yang tidak ada di npm semudah menggunakan paket-paket dari npm. <br><br>  Sistem npm ternyata sangat sukses sehingga tidak hanya pengembang produk server di Node.js yang menggunakannya, tetapi juga programmer front-end.  Sebelumnya, alat seperti Bower digunakan untuk mengelola paket.  Bower sudah tidak digunakan lagi, dan sekarang Anda dapat menemukan bahwa semua pustaka JS untuk pengembangan frontend ada sebagai paket npm.  Banyak alat pendukung untuk pengembangan klien, seperti Vue.js CLI dan Webpack, ditulis sebagai aplikasi Node.js. <br><br>  Sistem manajemen paket lain untuk Node.js, utas, mengunduh paket dari repositori npm dan menggunakan file konfigurasi yang sama.  Keuntungan utama dari benang melebihi manajer paket npm adalah kecepatannya yang lebih tinggi. <br><br>  Repositori npm, apakah menggunakan manajer paket npm atau manajer paket benang, adalah fondasi yang kuat untuk apa yang membuat pengembangan untuk Node.js begitu mudah dan menyenangkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/382/891/5db382891911a53615838db26c67936c.png"></div><br>  <i><font color="#999999">Suatu hari, setelah saya membantu mengembangkan java.awt.Robot, saya terinspirasi untuk membuat hal ini.</font></i>  <i><font color="#999999">Sementara gambar Duke resmi terdiri dari kurva, RoboDuke dibangun dari garis lurus.</font></i>  <i><font color="#999999">Hanya sambungan siku robot ini yang bulat</font></i> <br><br><h2>  <font color="#3AC1EF">Performa</font> </h2><br>  Java,  JavaScript     .          -,    ,    .  ,   ,  -       . <br><br>   Java,   JavaScript      .    Java   Node.js,        .     JavaScript         .         -. <br><br> JDK Sun/Oracle  HotSpot â€”  ,     -.        ,      ,    ,    ,     ,    . HotSpot â€”   ,     . <br><br>    JavaScript,       ,     JS-,   , ,    -  . ,    JavaScript           .    ,   ,    . , ,     Google Docs,     .    JS    . <br><br> Node.js     ,      V8  Google Chrome. <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ,  Google,     V8,         .     ,  V8   Crankshaft  Turbofan. <br><br>   â€”  ,     ,       R  Python.  ,     ,        .  JavaScript,   ,   ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  JavaScript. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>       JavaScript  , TensorFlow.js. API     API TensorFlow  Python,      .    , ,       ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     IBM,        Node.js,  ,   ,   Docker/Kubernetes.       ,       Node.js    Spring Boot.       -,        .  ,      Node.js  , ,  ,   V8. <br><br>   ,  Node.js      .      . - ,   Node.js     ,     . ,    Â«Node.js Web DevelopmentÂ»,   ,      : <br><br><ul><li>   â€”             . </li><li>          ,   Node.js     . </li><li>       . </li></ul><br>   JavaScript    ,          Node.js.    â€”    Node.js-.      Node.js-   <code>node-gyp</code> ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,     Rust-  Node.js. <br><br> WebAssembly   ,    ,   JavaScript,     . WebAssembly  ,    JavaScript-.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>         WebAssembly   Node.js. <br><br><h2> <font color="#3AC1EF"> -</font> </h2><br>  - (Rich Internet Applications, RIA)        .    ,  ,     (  ) JS-,      . <br><br>   ,     20  . Sun  Netscape    Java-  Netscape Navigator. JavaScript , ,      Java-.     ,      Java-,   â€” Java-.       ,                .      . <br><br>    JavaScript     ,          .       RIA,  ,   -  Java      -. <br><br>    ,   RIA   .  Node.js       , ,      ,      .    JavaScript. <br><br>  Berikut ini beberapa contohnya: <br><br><ul><li>   Google Docs (    ),        ,    . </li><li>  ,  React, Angular  Vue.js,    ,   HTML, CSS  JavaScript. </li><li> Electron â€”   Node.js   Chromium.      -  .          ,  Visual Studio Code, Atom, GitKraken,  Postman. </li><li>    Electron/NW.js   , -, ,  React, Angular,  Vue,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </li></ul><br>  Java,       ,   -  -,   JavaScript.  , , -      Sun Microsystems.    Sun   ,      .      .   Java-    ,       Java   Java Web Start.       Java-  Webstart-. <br><br>          Java, ,  , IDE NetBeans  Eclipse      .      Java  ,         ,   Java. <br><br>    JavaFX. <br><br>  JavaFX, 10  ,    Sun   iPhone. ,        Java,    , ,    .         Flash      iOS.     . JavaFX    ,        ,     .       -  React, Vue.js   . <br><br>    JavaScript  Node   Java. <br><br>    Java,  -    JavaONE.        Java  . ,  ,    ,   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdb/5d1/736/bdb5d1736a9e8f66394d50ef11063389.jpg"><br> <i><font color="#999999"> Java</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/0c6/da4/0640c6da4b0defa291a2b6516f2d2606.png"><br> <i><font color="#999999">  </font></i> <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>          .       Â«P-Â» (Perl, PHP, Python)  Java,      Node.js,   Ruby, Haskell, Go, Rust,   .            . <br><br>     ,  , ,    Java,    Node.js,  ,    ,    Node.js-.  Java   ,    Node.js    . ,  ,  ,    Java,    . <br><br>      . , ,        Node.js  - ,    - .           . ,      XBRL-.        XBRL   Python,  ,   ,   Python. ,  ,           ,        . <br><br>  <b>Pembaca yang budiman!</b>  ,     ,   JavaScript  -  ,   -    Node.js,       . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421741/">https://habr.com/ru/post/id421741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421731/index.html">Berapa biaya untuk membangun perangkat lunak: terdiri dari apa anggaran pengembangan aplikasi</a></li>
<li><a href="../id421733/index.html">Ambillah dan lakukan itu: mengapa kadang-kadang berguna untuk menilai untuk analisis dan hanya mengembangkan</a></li>
<li><a href="../id421735/index.html">"Virus" dalam ekstensi menggunakan FastProxy sebagai contoh</a></li>
<li><a href="../id421737/index.html">Perusahaan Amerika telah memotong karyawannya selama satu tahun sekarang. Mengapa bisa ada masa depan?</a></li>
<li><a href="../id421739/index.html">Bagaimana saya mengganti RxJava dengan coroutine di proyek saya dan mengapa Anda mungkin juga harus melakukan ini</a></li>
<li><a href="../id421745/index.html">Bagaimana Ubisoft Meluncurkan Starlink-nya: Battle for Atlas Hybrid Game Suite</a></li>
<li><a href="../id421747/index.html">Parktronic di Arduino</a></li>
<li><a href="../id421749/index.html">â€œSangat sedikit yang benar-benar menulis backend di Kotlinâ€ - sebuah wawancara dengan Pasha Finkelstein</a></li>
<li><a href="../id421751/index.html">Editor gratis terbaik untuk pengembangan dan dokumentasi: Atom</a></li>
<li><a href="../id421753/index.html">Ulasan video Zoom DJI Mavic 2 dan 2 Pro. Menguji kamera dan fitur baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>