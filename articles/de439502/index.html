<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗳️ 🎂 🛫 Undefiniertes Verhalten und Wahrheit nicht definiert 👴🏻 🛵 👨🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Begriff "unbestimmtes Verhalten" in der Sprache C und C ++ bezeichnet eine Situation, in der wörtlich "was einfach nicht passiert". In der Vergang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Undefiniertes Verhalten und Wahrheit nicht definiert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/439502/">  Der Begriff <b>"unbestimmtes Verhalten"</b> in der Sprache C und C ++ bezeichnet eine Situation, in der wörtlich "was einfach nicht passiert".  In der Vergangenheit wurden Fälle, in denen sich die vorherigen C-Compiler (und die darauf befindlichen Architekturen) inkompatibel verhielten, auf unbestimmtes Verhalten zurückgeführt, und das Komitee für die Entwicklung des Standards entschied in seiner grenzenlosen Weisheit, nichts darüber zu entscheiden (d. H. Keine Präferenz zu geben) eine der konkurrierenden Implementierungen).  Unbestimmtes Verhalten wurde auch als mögliche Situationen bezeichnet, in denen der normalerweise so erschöpfende Standard kein spezifisches Verhalten vorschrieb.  Dieser Begriff hat eine dritte Bedeutung, die in unserer Zeit immer relevanter wird: unbestimmtes Verhalten - dies ist die Möglichkeit zur Optimierung.  Und Entwickler in C und C ++ <i>lieben</i> Optimierungen.  Compiler müssen unbedingt alle Anstrengungen unternehmen, um den Code zu beschleunigen. <br><br>  <i>Dieser Artikel wurde erstmals auf der Cryptography Services-Website veröffentlicht.</i>  <i>Die Übersetzung wird mit Genehmigung des Autors Thomas Pornin veröffentlicht.</i> <br><a name="habracut"></a><br>  Hier ist ein klassisches Beispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Wir werden diesen GCC-Code auf einer 64-Bit-x86-Plattform für Linux kompilieren (ich arbeite an der neuesten Version von Ubuntu 18.04, Version GCC - 7.3.0).  Wir <i>aktivieren die</i> vollständige Optimierung und sehen uns dann die Assembler-Liste an, für die wir die Schlüssel <i>"-W -Wall -O9 -S</i> " verwenden (das Argument " <i>-O9</i> " legt die maximale Stufe der GCC-Optimierung fest, die in der Praxis " <i>-O3</i> " entspricht, obwohl dies in einigen Gabeln der <i>Fall ist</i> GCC definiert und höhere Ebenen).  Wir erhalten folgendes Ergebnis: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Jeder der ersten beiden <i>movupd-</i> Befehle verschiebt zwei <i>Doppelwerte</i> in das 128-Bit-SSE2-Register ( <i>double</i> hat eine Größe von 64 Bit, sodass das SSE2-Register zwei <i>Doppelwerte</i> speichern kann).  Mit anderen Worten, vier Anfangswerte werden zuerst gelesen und erst dann in <i>int umgewandelt</i> (Operation <i>cvttpd2dq</i> ).  Die Operation <i>punpcklqdq</i> verschiebt die vier empfangenen 32-Bit-Ganzzahlen in ein SSE2-Register <i>(% xmm0</i> ), dessen Inhalt dann in den RAM geschrieben wird ( <i>movups</i> ).  Und jetzt die Hauptsache: Unser C-Programm erfordert formal, dass der Zugriff auf den Speicher in der folgenden Reihenfolge erfolgt: <br><br><ul><li>  Lesen Sie den ersten <i>Doppelwert</i> aus <i>src [0]</i> . </li><li>  Schreiben Sie den ersten Wert vom Typ <i>int</i> in <i>dst [0]</i> . </li><li>  Lesen Sie den zweiten <i>Doppelwert</i> aus <i>src [1]</i> . </li><li>  Schreiben Sie den zweiten Wert vom Typ <i>int</i> in <i>dst [1]</i> . </li><li>  Lesen Sie den dritten <i>Doppelwert</i> aus <i>src [2]</i> . </li><li>  Schreiben Sie den dritten Wert vom Typ <i>int</i> in <i>dst [2]</i> . </li><li>  Lesen Sie den vierten <i>Doppelwert</i> aus <i>src [3]</i> . </li><li>  Schreiben Sie den vierten Wert vom Typ <i>int</i> in <i>dst [3]</i> . </li></ul><br>  Alle diese Anforderungen sind jedoch nur im Kontext einer abstrakten Maschine sinnvoll, die der C-Standard definiert.  Das Verfahren auf einer realen Maschine kann variieren.  Dem Compiler steht es frei, Operationen neu anzuordnen oder zu ändern, sofern ihr Ergebnis nicht der Semantik der abstrakten Maschine widerspricht (die sogenannte <i>Als-ob-</i> Regel lautet „als ob“).  In unserem Beispiel ist die Reihenfolge der Aktionen einfach anders: <br><br><ul><li>  Lesen Sie den ersten <i>Doppelwert</i> aus <i>src [0]</i> . </li><li>  Lesen Sie den zweiten <i>Doppelwert</i> aus <i>src [1]</i> . </li><li>  Lesen Sie den dritten <i>Doppelwert</i> aus <i>src [2]</i> . </li><li>  Lesen Sie den vierten <i>Doppelwert</i> aus <i>src [3]</i> . </li><li>  Schreiben Sie den ersten Wert vom Typ <i>int</i> in <i>dst [0]</i> . </li><li>  Schreiben Sie den zweiten Wert vom Typ <i>int</i> in <i>dst [1]</i> . </li><li>  Schreiben Sie den dritten Wert vom Typ <i>int</i> in <i>dst [2]</i> . </li><li>  Schreiben Sie den vierten Wert vom Typ <i>int</i> in <i>dst [3]</i> . </li></ul><br>  Dies ist die C-Sprache: Alle Speicherinhalte sind letztendlich Bytes (d. H. Slots mit Werten vom Typ <i>vorzeichenloses</i> Zeichen, in der Praxis jedoch Gruppen von acht Bits), und beliebige Zeigeroperationen sind zulässig.  Insbesondere können die Zeiger <i>src</i> und <i>dst</i> verwendet werden, um beim Aufruf auf überlappende Teile des Speichers zuzugreifen (diese Situation wird als "Aliasing" bezeichnet).  Daher kann die Lese- und Schreibreihenfolge wichtig sein, wenn Bytes geschrieben und dann erneut gelesen werden.  Damit das tatsächliche Verhalten des Programms der durch den C-Standard definierten Zusammenfassung entspricht, müsste der Compiler zwischen Lese- und Schreiboperationen wechseln und bei jeder Iteration einen vollständigen Zyklus von Speicherzugriffen bereitstellen.  Der resultierende Code wäre größer und würde viel langsamer arbeiten.  Für C-Entwickler wäre dies ein Leid. <br><br>  Hier kommt glücklicherweise <i>unbestimmtes Verhalten</i> zur Rettung.  Standard C besagt, dass auf Werte nicht über Zeiger zugegriffen werden kann, deren Typ nicht den aktuellen Typen dieser Werte entspricht.  Einfach ausgedrückt, wenn der Wert in <i>dst [0] geschrieben wird</i> , wobei <i>dst</i> ein <i>int-</i> Zeiger ist, können die entsprechenden Bytes nicht über <i>src [1]</i> gelesen werden, wobei <i>src</i> ein <i>doppelter</i> Zeiger ist, da wir in diesem Fall versuchen würden, darauf zuzugreifen Wert, der jetzt vom Typ <i>int ist</i> , unter Verwendung eines Zeigers eines inkompatiblen Typs.  In diesem Fall würde ein undefiniertes Verhalten auftreten.  Dies ist in Abschnitt 7.5 Absatz 7 der Norm ISO 9899: 1999 („C99“) angegeben (in der neuen Ausgabe 9899: 2018 oder „C17“ hat sich der Wortlaut nicht geändert).  Diese Anforderung wird als strikte Aliasing-Regel bezeichnet.  Infolgedessen kann der C-Compiler davon ausgehen, dass Speicherzugriffsvorgänge, die aufgrund eines Verstoßes gegen die strikte Aliasing-Regel zu undefiniertem Verhalten führen, nicht auftreten.  Somit kann der Compiler die Lese- und Schreibvorgänge in beliebiger Reihenfolge neu anordnen, da sie nicht auf überlappende Teile des Speichers zugreifen sollten.  Darum geht es bei der Codeoptimierung. <br><br>  Kurz gesagt bedeutet undefiniertes Verhalten Folgendes: Der Compiler kann davon ausgehen, dass es kein undefiniertes Verhalten gibt, und auf der Grundlage dieser Annahme Code generieren.  Im Fall der strengen Aliasing-Regel - vorausgesetzt, Aliasing findet statt - ermöglicht das unbestimmte Verhalten wichtige Optimierungen, die ansonsten schwierig zu implementieren wären.  Im Allgemeinen weist jede Anweisung in den vom Compiler verwendeten Codegenerierungsprozeduren Abhängigkeiten auf, die den Operationsplanungsalgorithmus einschränken: Eine Anweisung kann nicht vor den Anweisungen ausgeführt werden, von denen sie abhängt, oder nach den Anweisungen, die davon abhängen.  In unserem Beispiel beseitigt undefiniertes Verhalten die Abhängigkeiten zwischen Schreiboperationen in <i>dst []</i> und "nachfolgenden" Leseoperationen von <i>src []</i> : Eine solche Abhängigkeit kann nur in Fällen bestehen, in denen beim Zugriff auf den Speicher undefiniertes Verhalten auftritt.  In ähnlicher Weise ermöglicht das Konzept des undefinierten Verhaltens dem Compiler, einfach Code zu löschen, der nicht ausgeführt werden kann, ohne einen Zustand undefinierten Verhaltens einzugeben. <br><br>  All dies ist natürlich gut, aber ein solches Verhalten wird vom Compiler manchmal als tückischer Verrat empfunden.  Sie können oft den Satz hören: "Der Compiler verwendet das Konzept des unbestimmten Verhaltens als Entschuldigung, um meinen Code zu brechen."  Angenommen, jemand schreibt ein Programm, das ganze Zahlen addiert und einen Überlauf befürchtet - denken Sie an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fall von Bitcoin</a> .  Er kann so denken: Um ganze Zahlen darzustellen, verwendet der Prozessor zusätzlichen Code. Wenn also ein Überlauf auftritt, geschieht dies, weil das Ergebnis auf die Größe des Typs abgeschnitten wird, d. H.  32 Bit  Dies bedeutet, dass das Ergebnis des Überlaufs vorhergesagt und mit einem Test überprüft werden kann. <br><br>  Unser bedingter Entwickler wird dies schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Versuchen wir nun, diesen Code mit GCC zu kompilieren: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Ok, es scheint zu funktionieren.  Versuchen Sie jetzt einen anderen Compiler, zum Beispiel Clang (ich habe Version 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  Was? <br><br>  Es stellt sich heraus, dass wir das Gebiet des undefinierten Verhaltens betreten, wenn eine Operation mit vorzeichenbehafteten Ganzzahltypen zu einem Ergebnis führt, das nicht durch den Zieltyp dargestellt werden kann.  Der Compiler kann jedoch davon ausgehen, dass dies nicht der Fall ist.  Insbesondere bei der Optimierung des Ausdrucks <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> kommt der Compiler zu dem Schluss, dass die dritte Prüfung nicht wahr sein kann, da die Werte von <i>x</i> und <i>y</i> streng positiv sind (die Summe zweier Werte kann nicht kleiner sein als einer von ihnen). und Sie können diesen gesamten Vorgang überspringen.  Mit anderen Worten, da Überlaufen ein undefiniertes Verhalten ist, kann es aus Sicht des Compilers nicht passieren, und alle Anweisungen, die von diesem Status abhängen, können gelöscht werden.  Der Mechanismus zum Erkennen von undefiniertem Verhalten ist einfach verschwunden. <br><br>  Der Standard hat niemals die Annahme vorgeschrieben, dass "vorzeichenbehaftete Semantik" (die tatsächlich in Prozessoroperationen verwendet wird) in Berechnungen mit vorzeichenbehafteten Typen verwendet wird;  Dies geschah eher aus Tradition - selbst in jenen Tagen, als Compiler nicht klug genug waren, um den Code zu optimieren und sich auf eine Reihe von Werten zu konzentrieren.  Sie können Clang und GCC zwingen, die Wrapping-Semantik auf signierte Typen anzuwenden, indem <i>Sie das</i> spezielle Flag <i>-fwrapv</i> verwenden (in Microsoft Visual C können Sie <i>-d2UndefIntOverflow- verwenden,</i> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben).  Dieser Ansatz ist jedoch unzuverlässig. Das Flag kann verschwinden, wenn der Code in ein anderes Projekt oder in eine andere Architektur übertragen wird. <br><br>  Nur wenige Menschen wissen, dass Überläufe von Zeichentypen undefiniertes Verhalten beinhalten.  Dies ist in Abschnitt 6.5 Absatz 5 der Normen C99 und C17 angegeben: <br><br>  <i>Wenn beim Auswerten eines Ausdrucks eine Ausnahme auftritt (d. H. Wenn das Ergebnis nicht mathematisch definiert ist oder außerhalb des Bereichs gültiger Werte eines bestimmten Typs liegt), ist das Verhalten undefiniert.</i> <br><br>  Für vorzeichenlose Typen ist jedoch eine modulare Semantik garantiert.  In Abschnitt 6.2.5 Absatz 9 heißt es: <br><br>  <i>Bei Berechnungen mit vorzeichenlosen Operanden tritt niemals ein Überlauf auf, da ein Ergebnis, das nicht durch den resultierenden vorzeichenlosen Ganzzahltyp dargestellt werden kann, modulo abgeschnitten wird und eine Zahl ist, die um eins höher ist als der durch den resultierenden Typ dargestellte Maximalwert.</i> <br><br>  Ein weiteres Beispiel für undefiniertes Verhalten bei Operationen mit vorzeichenbehafteten Typen ist die Divisionsoperation.  Wie jeder weiß, ist das Ergebnis der Division durch Null nicht mathematisch bestimmt, daher beinhaltet diese Operation gemäß dem Standard ein undefiniertes Verhalten.  Wenn der Teiler in der <i>idiv-</i> Operation auf dem x86-Prozessor Null ist, wird eine Prozessorausnahme ausgelöst.  Prozessorausnahmen werden wie Interrupt-Anforderungen vom Betriebssystem behandelt.  Auf Unix-ähnlichen Systemen wie Linux wird die durch die <i>idiv-</i> Operation ausgelöste Prozessorausnahme in ein <i>SIGFPE-</i> Signal übersetzt, das an den Prozess gesendet wird, und endet mit dem Standardhandler (wundern Sie sich nicht, dass "FPE" für "Gleitkomma-Ausnahme" steht (Ausnahme in) Gleitkommaoperationen), während <i>idiv</i> mit ganzen Zahlen arbeitet).  Es gibt jedoch eine andere Situation, die zu undefiniertem Verhalten führt.  Betrachten Sie den folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; }  : $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  Und die Wahrheit ist: Auf diesem Computer (das gleiche x86 für Linux) repräsentiert der <i>int-</i> Typ einen Wertebereich von -2.147.483.648 bis +2.147.483.647. Wenn Sie -2.147.483.648 durch -1 teilen, sollten Sie +2.147.483.648 erhalten Diese Zahl liegt jedoch nicht im Bereich der <i>int-</i> Werte.  Daher ist das Verhalten nicht definiert.  Alles kann passieren.  In diesem Fall wird der Prozess zwangsweise beendet.  Auf einem anderen System, insbesondere bei einem kleinen Prozessor ohne Teilungsoperation, kann das Ergebnis variieren.  In solchen Architekturen wird die Unterteilung programmgesteuert durchgeführt - mit Hilfe der Prozedur, die normalerweise vom Compiler bereitgestellt wird, und jetzt kann sie mit unbestimmtem Verhalten tun, was sie will, denn genau das ist es. <br><br>  Ich <i>stelle</i> fest, dass <i>SIGFPE</i> unter den gleichen Bedingungen und mit Hilfe des Modulo-Operators ( <i>%</i> ) erhalten werden kann.  Und in der Tat: <i>Darunter</i> liegt dieselbe <i>idiv-</i> Operation, die sowohl den Quotienten als auch den Rest berechnet, sodass dieselbe Prozessorausnahme ausgelöst wird.  Interessanterweise besagt der C99-Standard, dass der Ausdruck <i>INT_MIN% -1</i> nicht zu undefiniertem Verhalten führen kann, da das Ergebnis mathematisch definiert ist (Null) und eindeutig in den Wertebereich des <i>Zieltyps</i> fällt.  In Version C17 wurde der Text von Absatz 6 von Abschnitt 6.5.5 geändert, und jetzt wird auch dieser Fall berücksichtigt, wodurch der Standard der tatsächlichen Situation auf gängigen Hardwareplattformen näher kommt. <br><br>  Es gibt viele nicht offensichtliche Situationen, die auch zu undefiniertem Verhalten führen.  Schauen Sie sich diesen Code an: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  Denken Sie, dass ein Programm nach dem C-Standard gedruckt werden sollte, wenn wir die Faktoren 45.000 und 50.000 an die Funktion übergeben? <br><br><ul><li>  18.048 </li><li>  2.250.000.000 </li><li>  Gott schütze die Königin! </li></ul><br>  Die richtige Antwort ... ja, alles oben!  Sie haben wahrscheinlich so argumentiert: Da der <i>vorzeichenlose Short</i> ein vorzeichenloser Typ ist, sollte er die Semantik des Wrapping von Modulo 65 536 unterstützen, da auf dem x86-Prozessor die Größe dieses Typs in der Regel genau 16 Bit beträgt (der Standard erlaubt jedoch auch eine größere Größe, aber In der Praxis ist dies immer noch ein 16-Bit-Typ.  Da das Produkt mathematisch 2.250.000.000 ist, wird es modulo 65.536 abgeschnitten, was eine Antwort von 18.048 ergibt. Wenn wir jedoch so denken, vergessen wir die Erweiterung von Ganzzahltypen.  Nach dem C-Standard (Abschnitt 6.3.1.1, Absatz 2) können die Operanden eines Typs sein, dessen Größe streng kleiner als die Größe von <i>int ist</i> , und die Werte dieses Typs können durch den Typ <i>int</i> ohne Verlust von Bits dargestellt werden (und wir haben nur diesen Fall: auf meinem x86 unter Linux hat eine <i>int-</i> Größe von 32 Bit und kann explizit Werte von 0 bis 65.535 speichern. Dann werden beide Operanden in <i>int umgewandelt</i> und die Operation wird bereits für die konvertierten Werte ausgeführt.  Das heißt, das Produkt wird als Wert vom Typ <i>int</i> berechnet und erst nach Rückkehr von der Funktion auf einen <i>vorzeichenlosen Kurzschluss zurückgesetzt</i> (dh in diesem Moment tritt die Kürzung modulo 65 536 auf).  Das Problem ist, dass das Ergebnis vor der inversen Transformation mathematisch 2,250 Millionen beträgt und dieser Wert den Bereich von <i>int</i> überschreitet, bei dem es sich um einen vorzeichenbehafteten Typ handelt.  Als Ergebnis erhalten wir undefiniertes Verhalten.  Danach kann alles passieren, einschließlich plötzlicher Anfälle von englischem Patriotismus. <br><br>  In der Praxis beträgt das Ergebnis bei normalen Compilern jedoch 18.048, da es immer noch keine Optimierung gibt, die das unbestimmte Verhalten in diesem bestimmten Programm ausnutzen könnte (man könnte sich künstlichere Szenarien vorstellen, in denen es wirklich Probleme verursachen würde). <br><br>  Zum Schluss noch ein Beispiel in C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  Dies ist nicht das typische "böse schreckliche <i>strcpy ()</i> !" Für Sie.  In der Tat wird hier die Funktion <i>strcpy ()</i> nur ausgeführt, wenn die Größe der <i>Quellzeichenfolge</i> einschließlich des Terminals Null klein genug ist.  Darüber hinaus werden die Elemente des Arrays explizit auf Null initialisiert, sodass alle Bytes im Array einen bestimmten Wert haben, unabhängig davon, ob eine große oder eine kleine Zeichenfolge an die Funktion übergeben wird.  Gleichzeitig ist die Schleife am Ende falsch: Sie liest ein Byte mehr als es sollte. <br><br>  Führen Sie den Code aus: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo ++?</span></span></code> </pre> <br>  Sie können naiv Einwände erheben: Nun, es liest ein zusätzliches Byte über die Grenzen des Arrays hinaus;  Dies ist jedoch nicht so beängstigend, da dieses Byte auf dem Stapel noch vorhanden ist und dem Speicher zugeordnet ist. Das einzige Problem hierbei ist das zusätzliche siebzehnte Element mit einem unbekannten Wert.  Der Zyklus druckt immer noch genau 17 Ganzzahlen (im Hexadezimalformat) und endet ohne Beschwerden. <br><br>  Der Compiler hat diesbezüglich jedoch eine eigene Meinung.  Er ist sich bewusst, dass die siebzehnte Lesung unbestimmtes Verhalten hervorruft.  Nach seiner Logik ist jede nachfolgende Anweisung in der Schwebe: Es besteht keine Anforderung, dass nach unbestimmtem Verhalten überhaupt etwas existieren sollte (formal können sogar frühere Anweisungen angegriffen werden, da unbestimmtes Verhalten auch in die entgegengesetzte Richtung funktioniert).  In unserem Fall ignoriert der Compiler einfach die Bedingungsprüfung in der Schleife und dreht sich für immer, oder besser gesagt, bis er außerhalb des für den Stapel zugewiesenen Speichers zu lesen beginnt. <i>Danach</i> funktioniert das <i>SIGSEGV-</i> Signal. <br><br>  Es ist lustig, aber wenn GCC mit weniger aggressiven Einstellungen für Optimierungen startet, wird eine Warnung ausgegeben: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  Bei <i>-O9</i> verschwindet diese Warnung irgendwie.  Möglicherweise ist die Tatsache, dass der Compiler bei hohen Optimierungsstufen die Bereitstellung der Schleife aggressiver erzwingt.  Es ist möglich (aber ungenau), dass dies ein GCC-Fehler ist (im Sinne eines Warnverlusts; daher widersprechen die Aktionen von GCC auf keinen Fall dem Standard, da in dieser Situation keine „Diagnose“ ausgestellt werden muss). <br><br>  Fazit: Wenn Sie Code in C oder C ++ schreiben, seien Sie äußerst vorsichtig und vermeiden Sie Situationen, die zu undefiniertem Verhalten führen, auch wenn es so aussieht, als wäre es in Ordnung. <br><br>  Ganzzahlige Typen ohne Vorzeichen sind ein guter Helfer bei arithmetischen Berechnungen, da ihnen eine modulare Semantik garantiert ist (es können jedoch weiterhin Probleme im Zusammenhang mit der Erweiterung von Ganzzahltypen auftreten).  Eine andere Option - aus irgendeinem Grund unbeliebt - besteht darin, überhaupt nicht in C und C ++ zu schreiben.  Aus mehreren Gründen ist diese Lösung nicht immer geeignet.  Wenn Sie jedoch auswählen können, in welcher Sprache das Programm geschrieben werden soll, d. H.  Wenn Sie gerade ein neues Projekt auf einer Plattform starten, die Go, Rust, Java oder andere Sprachen unterstützt, ist es möglicherweise rentabler, die Verwendung von C als "Standardsprache" abzulehnen.  Die Auswahl der Tools, einschließlich einer Programmiersprache, ist immer ein Kompromiss.  Fallstricke von C, insbesondere unbestimmtes Verhalten bei Vorgängen mit signierten Typen, führen zu zusätzlichen Kosten für die weitere Wartung des Codes, die häufig unterschätzt werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439502/">https://habr.com/ru/post/de439502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439490/index.html">.NET-Referenztypen im Vergleich zu Werttypen. Teil 2</a></li>
<li><a href="../de439492/index.html">10 Tipps für einen guten technischen Vorsprung</a></li>
<li><a href="../de439496/index.html">So erfolgt die Abrechnung dort: Wenn Kunde und Entwickler unterschiedliche Sprachen sprechen</a></li>
<li><a href="../de439498/index.html">Auf welcher Hardware soll ein riesiger Informationsschacht analysiert werden?</a></li>
<li><a href="../de439500/index.html">Warum sind Captchas so kompliziert geworden?</a></li>
<li><a href="../de439504/index.html">Benötigt Ihr Team einen Dateningenieur?</a></li>
<li><a href="../de439506/index.html">9 Alternativen zu einem schlechten Team (Designmuster)</a></li>
<li><a href="../de439508/index.html">Mitap über Open Source-Entwicklung in Moskau</a></li>
<li><a href="../de439510/index.html">Hoch belastetes verteiltes Steuerungssystem eines modernen Kernkraftwerks</a></li>
<li><a href="../de439512/index.html">Das Alter der Dinosaurier oder die gesetzlich geprüfte Rückversicherung?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>