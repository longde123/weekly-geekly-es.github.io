<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó≥Ô∏è üéÇ üõ´ Undefiniertes Verhalten und Wahrheit nicht definiert üë¥üèª üõµ üë®üèº‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Begriff "unbestimmtes Verhalten" in der Sprache C und C ++ bezeichnet eine Situation, in der w√∂rtlich "was einfach nicht passiert". In der Vergang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Undefiniertes Verhalten und Wahrheit nicht definiert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/439502/">  Der Begriff <b>"unbestimmtes Verhalten"</b> in der Sprache C und C ++ bezeichnet eine Situation, in der w√∂rtlich "was einfach nicht passiert".  In der Vergangenheit wurden F√§lle, in denen sich die vorherigen C-Compiler (und die darauf befindlichen Architekturen) inkompatibel verhielten, auf unbestimmtes Verhalten zur√ºckgef√ºhrt, und das Komitee f√ºr die Entwicklung des Standards entschied in seiner grenzenlosen Weisheit, nichts dar√ºber zu entscheiden (d. H. Keine Pr√§ferenz zu geben) eine der konkurrierenden Implementierungen).  Unbestimmtes Verhalten wurde auch als m√∂gliche Situationen bezeichnet, in denen der normalerweise so ersch√∂pfende Standard kein spezifisches Verhalten vorschrieb.  Dieser Begriff hat eine dritte Bedeutung, die in unserer Zeit immer relevanter wird: unbestimmtes Verhalten - dies ist die M√∂glichkeit zur Optimierung.  Und Entwickler in C und C ++ <i>lieben</i> Optimierungen.  Compiler m√ºssen unbedingt alle Anstrengungen unternehmen, um den Code zu beschleunigen. <br><br>  <i>Dieser Artikel wurde erstmals auf der Cryptography Services-Website ver√∂ffentlicht.</i>  <i>Die √úbersetzung wird mit Genehmigung des Autors Thomas Pornin ver√∂ffentlicht.</i> <br><a name="habracut"></a><br>  Hier ist ein klassisches Beispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Wir werden diesen GCC-Code auf einer 64-Bit-x86-Plattform f√ºr Linux kompilieren (ich arbeite an der neuesten Version von Ubuntu 18.04, Version GCC - 7.3.0).  Wir <i>aktivieren die</i> vollst√§ndige Optimierung und sehen uns dann die Assembler-Liste an, f√ºr die wir die Schl√ºssel <i>"-W -Wall -O9 -S</i> " verwenden (das Argument " <i>-O9</i> " legt die maximale Stufe der GCC-Optimierung fest, die in der Praxis " <i>-O3</i> " entspricht, obwohl dies in einigen Gabeln der <i>Fall ist</i> GCC definiert und h√∂here Ebenen).  Wir erhalten folgendes Ergebnis: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Jeder der ersten beiden <i>movupd-</i> Befehle verschiebt zwei <i>Doppelwerte</i> in das 128-Bit-SSE2-Register ( <i>double</i> hat eine Gr√∂√üe von 64 Bit, sodass das SSE2-Register zwei <i>Doppelwerte</i> speichern kann).  Mit anderen Worten, vier Anfangswerte werden zuerst gelesen und erst dann in <i>int umgewandelt</i> (Operation <i>cvttpd2dq</i> ).  Die Operation <i>punpcklqdq</i> verschiebt die vier empfangenen 32-Bit-Ganzzahlen in ein SSE2-Register <i>(% xmm0</i> ), dessen Inhalt dann in den RAM geschrieben wird ( <i>movups</i> ).  Und jetzt die Hauptsache: Unser C-Programm erfordert formal, dass der Zugriff auf den Speicher in der folgenden Reihenfolge erfolgt: <br><br><ul><li>  Lesen Sie den ersten <i>Doppelwert</i> aus <i>src [0]</i> . </li><li>  Schreiben Sie den ersten Wert vom Typ <i>int</i> in <i>dst [0]</i> . </li><li>  Lesen Sie den zweiten <i>Doppelwert</i> aus <i>src [1]</i> . </li><li>  Schreiben Sie den zweiten Wert vom Typ <i>int</i> in <i>dst [1]</i> . </li><li>  Lesen Sie den dritten <i>Doppelwert</i> aus <i>src [2]</i> . </li><li>  Schreiben Sie den dritten Wert vom Typ <i>int</i> in <i>dst [2]</i> . </li><li>  Lesen Sie den vierten <i>Doppelwert</i> aus <i>src [3]</i> . </li><li>  Schreiben Sie den vierten Wert vom Typ <i>int</i> in <i>dst [3]</i> . </li></ul><br>  Alle diese Anforderungen sind jedoch nur im Kontext einer abstrakten Maschine sinnvoll, die der C-Standard definiert.  Das Verfahren auf einer realen Maschine kann variieren.  Dem Compiler steht es frei, Operationen neu anzuordnen oder zu √§ndern, sofern ihr Ergebnis nicht der Semantik der abstrakten Maschine widerspricht (die sogenannte <i>Als-ob-</i> Regel lautet ‚Äûals ob‚Äú).  In unserem Beispiel ist die Reihenfolge der Aktionen einfach anders: <br><br><ul><li>  Lesen Sie den ersten <i>Doppelwert</i> aus <i>src [0]</i> . </li><li>  Lesen Sie den zweiten <i>Doppelwert</i> aus <i>src [1]</i> . </li><li>  Lesen Sie den dritten <i>Doppelwert</i> aus <i>src [2]</i> . </li><li>  Lesen Sie den vierten <i>Doppelwert</i> aus <i>src [3]</i> . </li><li>  Schreiben Sie den ersten Wert vom Typ <i>int</i> in <i>dst [0]</i> . </li><li>  Schreiben Sie den zweiten Wert vom Typ <i>int</i> in <i>dst [1]</i> . </li><li>  Schreiben Sie den dritten Wert vom Typ <i>int</i> in <i>dst [2]</i> . </li><li>  Schreiben Sie den vierten Wert vom Typ <i>int</i> in <i>dst [3]</i> . </li></ul><br>  Dies ist die C-Sprache: Alle Speicherinhalte sind letztendlich Bytes (d. H. Slots mit Werten vom Typ <i>vorzeichenloses</i> Zeichen, in der Praxis jedoch Gruppen von acht Bits), und beliebige Zeigeroperationen sind zul√§ssig.  Insbesondere k√∂nnen die Zeiger <i>src</i> und <i>dst</i> verwendet werden, um beim Aufruf auf √ºberlappende Teile des Speichers zuzugreifen (diese Situation wird als "Aliasing" bezeichnet).  Daher kann die Lese- und Schreibreihenfolge wichtig sein, wenn Bytes geschrieben und dann erneut gelesen werden.  Damit das tats√§chliche Verhalten des Programms der durch den C-Standard definierten Zusammenfassung entspricht, m√ºsste der Compiler zwischen Lese- und Schreiboperationen wechseln und bei jeder Iteration einen vollst√§ndigen Zyklus von Speicherzugriffen bereitstellen.  Der resultierende Code w√§re gr√∂√üer und w√ºrde viel langsamer arbeiten.  F√ºr C-Entwickler w√§re dies ein Leid. <br><br>  Hier kommt gl√ºcklicherweise <i>unbestimmtes Verhalten</i> zur Rettung.  Standard C besagt, dass auf Werte nicht √ºber Zeiger zugegriffen werden kann, deren Typ nicht den aktuellen Typen dieser Werte entspricht.  Einfach ausgedr√ºckt, wenn der Wert in <i>dst [0] geschrieben wird</i> , wobei <i>dst</i> ein <i>int-</i> Zeiger ist, k√∂nnen die entsprechenden Bytes nicht √ºber <i>src [1]</i> gelesen werden, wobei <i>src</i> ein <i>doppelter</i> Zeiger ist, da wir in diesem Fall versuchen w√ºrden, darauf zuzugreifen Wert, der jetzt vom Typ <i>int ist</i> , unter Verwendung eines Zeigers eines inkompatiblen Typs.  In diesem Fall w√ºrde ein undefiniertes Verhalten auftreten.  Dies ist in Abschnitt 7.5 Absatz 7 der Norm ISO 9899: 1999 (‚ÄûC99‚Äú) angegeben (in der neuen Ausgabe 9899: 2018 oder ‚ÄûC17‚Äú hat sich der Wortlaut nicht ge√§ndert).  Diese Anforderung wird als strikte Aliasing-Regel bezeichnet.  Infolgedessen kann der C-Compiler davon ausgehen, dass Speicherzugriffsvorg√§nge, die aufgrund eines Versto√ües gegen die strikte Aliasing-Regel zu undefiniertem Verhalten f√ºhren, nicht auftreten.  Somit kann der Compiler die Lese- und Schreibvorg√§nge in beliebiger Reihenfolge neu anordnen, da sie nicht auf √ºberlappende Teile des Speichers zugreifen sollten.  Darum geht es bei der Codeoptimierung. <br><br>  Kurz gesagt bedeutet undefiniertes Verhalten Folgendes: Der Compiler kann davon ausgehen, dass es kein undefiniertes Verhalten gibt, und auf der Grundlage dieser Annahme Code generieren.  Im Fall der strengen Aliasing-Regel - vorausgesetzt, Aliasing findet statt - erm√∂glicht das unbestimmte Verhalten wichtige Optimierungen, die ansonsten schwierig zu implementieren w√§ren.  Im Allgemeinen weist jede Anweisung in den vom Compiler verwendeten Codegenerierungsprozeduren Abh√§ngigkeiten auf, die den Operationsplanungsalgorithmus einschr√§nken: Eine Anweisung kann nicht vor den Anweisungen ausgef√ºhrt werden, von denen sie abh√§ngt, oder nach den Anweisungen, die davon abh√§ngen.  In unserem Beispiel beseitigt undefiniertes Verhalten die Abh√§ngigkeiten zwischen Schreiboperationen in <i>dst []</i> und "nachfolgenden" Leseoperationen von <i>src []</i> : Eine solche Abh√§ngigkeit kann nur in F√§llen bestehen, in denen beim Zugriff auf den Speicher undefiniertes Verhalten auftritt.  In √§hnlicher Weise erm√∂glicht das Konzept des undefinierten Verhaltens dem Compiler, einfach Code zu l√∂schen, der nicht ausgef√ºhrt werden kann, ohne einen Zustand undefinierten Verhaltens einzugeben. <br><br>  All dies ist nat√ºrlich gut, aber ein solches Verhalten wird vom Compiler manchmal als t√ºckischer Verrat empfunden.  Sie k√∂nnen oft den Satz h√∂ren: "Der Compiler verwendet das Konzept des unbestimmten Verhaltens als Entschuldigung, um meinen Code zu brechen."  Angenommen, jemand schreibt ein Programm, das ganze Zahlen addiert und einen √úberlauf bef√ºrchtet - denken Sie an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fall von Bitcoin</a> .  Er kann so denken: Um ganze Zahlen darzustellen, verwendet der Prozessor zus√§tzlichen Code. Wenn also ein √úberlauf auftritt, geschieht dies, weil das Ergebnis auf die Gr√∂√üe des Typs abgeschnitten wird, d. H.  32 Bit  Dies bedeutet, dass das Ergebnis des √úberlaufs vorhergesagt und mit einem Test √ºberpr√ºft werden kann. <br><br>  Unser bedingter Entwickler wird dies schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Versuchen wir nun, diesen Code mit GCC zu kompilieren: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Ok, es scheint zu funktionieren.  Versuchen Sie jetzt einen anderen Compiler, zum Beispiel Clang (ich habe Version 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  Was? <br><br>  Es stellt sich heraus, dass wir das Gebiet des undefinierten Verhaltens betreten, wenn eine Operation mit vorzeichenbehafteten Ganzzahltypen zu einem Ergebnis f√ºhrt, das nicht durch den Zieltyp dargestellt werden kann.  Der Compiler kann jedoch davon ausgehen, dass dies nicht der Fall ist.  Insbesondere bei der Optimierung des Ausdrucks <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> kommt der Compiler zu dem Schluss, dass die dritte Pr√ºfung nicht wahr sein kann, da die Werte von <i>x</i> und <i>y</i> streng positiv sind (die Summe zweier Werte kann nicht kleiner sein als einer von ihnen). und Sie k√∂nnen diesen gesamten Vorgang √ºberspringen.  Mit anderen Worten, da √úberlaufen ein undefiniertes Verhalten ist, kann es aus Sicht des Compilers nicht passieren, und alle Anweisungen, die von diesem Status abh√§ngen, k√∂nnen gel√∂scht werden.  Der Mechanismus zum Erkennen von undefiniertem Verhalten ist einfach verschwunden. <br><br>  Der Standard hat niemals die Annahme vorgeschrieben, dass "vorzeichenbehaftete Semantik" (die tats√§chlich in Prozessoroperationen verwendet wird) in Berechnungen mit vorzeichenbehafteten Typen verwendet wird;  Dies geschah eher aus Tradition - selbst in jenen Tagen, als Compiler nicht klug genug waren, um den Code zu optimieren und sich auf eine Reihe von Werten zu konzentrieren.  Sie k√∂nnen Clang und GCC zwingen, die Wrapping-Semantik auf signierte Typen anzuwenden, indem <i>Sie das</i> spezielle Flag <i>-fwrapv</i> verwenden (in Microsoft Visual C k√∂nnen Sie <i>-d2UndefIntOverflow- verwenden,</i> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben).  Dieser Ansatz ist jedoch unzuverl√§ssig. Das Flag kann verschwinden, wenn der Code in ein anderes Projekt oder in eine andere Architektur √ºbertragen wird. <br><br>  Nur wenige Menschen wissen, dass √úberl√§ufe von Zeichentypen undefiniertes Verhalten beinhalten.  Dies ist in Abschnitt 6.5 Absatz 5 der Normen C99 und C17 angegeben: <br><br>  <i>Wenn beim Auswerten eines Ausdrucks eine Ausnahme auftritt (d. H. Wenn das Ergebnis nicht mathematisch definiert ist oder au√üerhalb des Bereichs g√ºltiger Werte eines bestimmten Typs liegt), ist das Verhalten undefiniert.</i> <br><br>  F√ºr vorzeichenlose Typen ist jedoch eine modulare Semantik garantiert.  In Abschnitt 6.2.5 Absatz 9 hei√üt es: <br><br>  <i>Bei Berechnungen mit vorzeichenlosen Operanden tritt niemals ein √úberlauf auf, da ein Ergebnis, das nicht durch den resultierenden vorzeichenlosen Ganzzahltyp dargestellt werden kann, modulo abgeschnitten wird und eine Zahl ist, die um eins h√∂her ist als der durch den resultierenden Typ dargestellte Maximalwert.</i> <br><br>  Ein weiteres Beispiel f√ºr undefiniertes Verhalten bei Operationen mit vorzeichenbehafteten Typen ist die Divisionsoperation.  Wie jeder wei√ü, ist das Ergebnis der Division durch Null nicht mathematisch bestimmt, daher beinhaltet diese Operation gem√§√ü dem Standard ein undefiniertes Verhalten.  Wenn der Teiler in der <i>idiv-</i> Operation auf dem x86-Prozessor Null ist, wird eine Prozessorausnahme ausgel√∂st.  Prozessorausnahmen werden wie Interrupt-Anforderungen vom Betriebssystem behandelt.  Auf Unix-√§hnlichen Systemen wie Linux wird die durch die <i>idiv-</i> Operation ausgel√∂ste Prozessorausnahme in ein <i>SIGFPE-</i> Signal √ºbersetzt, das an den Prozess gesendet wird, und endet mit dem Standardhandler (wundern Sie sich nicht, dass "FPE" f√ºr "Gleitkomma-Ausnahme" steht (Ausnahme in) Gleitkommaoperationen), w√§hrend <i>idiv</i> mit ganzen Zahlen arbeitet).  Es gibt jedoch eine andere Situation, die zu undefiniertem Verhalten f√ºhrt.  Betrachten Sie den folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; }  : $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  Und die Wahrheit ist: Auf diesem Computer (das gleiche x86 f√ºr Linux) repr√§sentiert der <i>int-</i> Typ einen Wertebereich von -2.147.483.648 bis +2.147.483.647. Wenn Sie -2.147.483.648 durch -1 teilen, sollten Sie +2.147.483.648 erhalten Diese Zahl liegt jedoch nicht im Bereich der <i>int-</i> Werte.  Daher ist das Verhalten nicht definiert.  Alles kann passieren.  In diesem Fall wird der Prozess zwangsweise beendet.  Auf einem anderen System, insbesondere bei einem kleinen Prozessor ohne Teilungsoperation, kann das Ergebnis variieren.  In solchen Architekturen wird die Unterteilung programmgesteuert durchgef√ºhrt - mit Hilfe der Prozedur, die normalerweise vom Compiler bereitgestellt wird, und jetzt kann sie mit unbestimmtem Verhalten tun, was sie will, denn genau das ist es. <br><br>  Ich <i>stelle</i> fest, dass <i>SIGFPE</i> unter den gleichen Bedingungen und mit Hilfe des Modulo-Operators ( <i>%</i> ) erhalten werden kann.  Und in der Tat: <i>Darunter</i> liegt dieselbe <i>idiv-</i> Operation, die sowohl den Quotienten als auch den Rest berechnet, sodass dieselbe Prozessorausnahme ausgel√∂st wird.  Interessanterweise besagt der C99-Standard, dass der Ausdruck <i>INT_MIN% -1</i> nicht zu undefiniertem Verhalten f√ºhren kann, da das Ergebnis mathematisch definiert ist (Null) und eindeutig in den Wertebereich des <i>Zieltyps</i> f√§llt.  In Version C17 wurde der Text von Absatz 6 von Abschnitt 6.5.5 ge√§ndert, und jetzt wird auch dieser Fall ber√ºcksichtigt, wodurch der Standard der tats√§chlichen Situation auf g√§ngigen Hardwareplattformen n√§her kommt. <br><br>  Es gibt viele nicht offensichtliche Situationen, die auch zu undefiniertem Verhalten f√ºhren.  Schauen Sie sich diesen Code an: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  Denken Sie, dass ein Programm nach dem C-Standard gedruckt werden sollte, wenn wir die Faktoren 45.000 und 50.000 an die Funktion √ºbergeben? <br><br><ul><li>  18.048 </li><li>  2.250.000.000 </li><li>  Gott sch√ºtze die K√∂nigin! </li></ul><br>  Die richtige Antwort ... ja, alles oben!  Sie haben wahrscheinlich so argumentiert: Da der <i>vorzeichenlose Short</i> ein vorzeichenloser Typ ist, sollte er die Semantik des Wrapping von Modulo 65 536 unterst√ºtzen, da auf dem x86-Prozessor die Gr√∂√üe dieses Typs in der Regel genau 16 Bit betr√§gt (der Standard erlaubt jedoch auch eine gr√∂√üere Gr√∂√üe, aber In der Praxis ist dies immer noch ein 16-Bit-Typ.  Da das Produkt mathematisch 2.250.000.000 ist, wird es modulo 65.536 abgeschnitten, was eine Antwort von 18.048 ergibt. Wenn wir jedoch so denken, vergessen wir die Erweiterung von Ganzzahltypen.  Nach dem C-Standard (Abschnitt 6.3.1.1, Absatz 2) k√∂nnen die Operanden eines Typs sein, dessen Gr√∂√üe streng kleiner als die Gr√∂√üe von <i>int ist</i> , und die Werte dieses Typs k√∂nnen durch den Typ <i>int</i> ohne Verlust von Bits dargestellt werden (und wir haben nur diesen Fall: auf meinem x86 unter Linux hat eine <i>int-</i> Gr√∂√üe von 32 Bit und kann explizit Werte von 0 bis 65.535 speichern. Dann werden beide Operanden in <i>int umgewandelt</i> und die Operation wird bereits f√ºr die konvertierten Werte ausgef√ºhrt.  Das hei√üt, das Produkt wird als Wert vom Typ <i>int</i> berechnet und erst nach R√ºckkehr von der Funktion auf einen <i>vorzeichenlosen Kurzschluss zur√ºckgesetzt</i> (dh in diesem Moment tritt die K√ºrzung modulo 65 536 auf).  Das Problem ist, dass das Ergebnis vor der inversen Transformation mathematisch 2,250 Millionen betr√§gt und dieser Wert den Bereich von <i>int</i> √ºberschreitet, bei dem es sich um einen vorzeichenbehafteten Typ handelt.  Als Ergebnis erhalten wir undefiniertes Verhalten.  Danach kann alles passieren, einschlie√ülich pl√∂tzlicher Anf√§lle von englischem Patriotismus. <br><br>  In der Praxis betr√§gt das Ergebnis bei normalen Compilern jedoch 18.048, da es immer noch keine Optimierung gibt, die das unbestimmte Verhalten in diesem bestimmten Programm ausnutzen k√∂nnte (man k√∂nnte sich k√ºnstlichere Szenarien vorstellen, in denen es wirklich Probleme verursachen w√ºrde). <br><br>  Zum Schluss noch ein Beispiel in C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  Dies ist nicht das typische "b√∂se schreckliche <i>strcpy ()</i> !" F√ºr Sie.  In der Tat wird hier die Funktion <i>strcpy ()</i> nur ausgef√ºhrt, wenn die Gr√∂√üe der <i>Quellzeichenfolge</i> einschlie√ülich des Terminals Null klein genug ist.  Dar√ºber hinaus werden die Elemente des Arrays explizit auf Null initialisiert, sodass alle Bytes im Array einen bestimmten Wert haben, unabh√§ngig davon, ob eine gro√üe oder eine kleine Zeichenfolge an die Funktion √ºbergeben wird.  Gleichzeitig ist die Schleife am Ende falsch: Sie liest ein Byte mehr als es sollte. <br><br>  F√ºhren Sie den Code aus: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo ++?</span></span></code> </pre> <br>  Sie k√∂nnen naiv Einw√§nde erheben: Nun, es liest ein zus√§tzliches Byte √ºber die Grenzen des Arrays hinaus;  Dies ist jedoch nicht so be√§ngstigend, da dieses Byte auf dem Stapel noch vorhanden ist und dem Speicher zugeordnet ist. Das einzige Problem hierbei ist das zus√§tzliche siebzehnte Element mit einem unbekannten Wert.  Der Zyklus druckt immer noch genau 17 Ganzzahlen (im Hexadezimalformat) und endet ohne Beschwerden. <br><br>  Der Compiler hat diesbez√ºglich jedoch eine eigene Meinung.  Er ist sich bewusst, dass die siebzehnte Lesung unbestimmtes Verhalten hervorruft.  Nach seiner Logik ist jede nachfolgende Anweisung in der Schwebe: Es besteht keine Anforderung, dass nach unbestimmtem Verhalten √ºberhaupt etwas existieren sollte (formal k√∂nnen sogar fr√ºhere Anweisungen angegriffen werden, da unbestimmtes Verhalten auch in die entgegengesetzte Richtung funktioniert).  In unserem Fall ignoriert der Compiler einfach die Bedingungspr√ºfung in der Schleife und dreht sich f√ºr immer, oder besser gesagt, bis er au√üerhalb des f√ºr den Stapel zugewiesenen Speichers zu lesen beginnt. <i>Danach</i> funktioniert das <i>SIGSEGV-</i> Signal. <br><br>  Es ist lustig, aber wenn GCC mit weniger aggressiven Einstellungen f√ºr Optimierungen startet, wird eine Warnung ausgegeben: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  Bei <i>-O9</i> verschwindet diese Warnung irgendwie.  M√∂glicherweise ist die Tatsache, dass der Compiler bei hohen Optimierungsstufen die Bereitstellung der Schleife aggressiver erzwingt.  Es ist m√∂glich (aber ungenau), dass dies ein GCC-Fehler ist (im Sinne eines Warnverlusts; daher widersprechen die Aktionen von GCC auf keinen Fall dem Standard, da in dieser Situation keine ‚ÄûDiagnose‚Äú ausgestellt werden muss). <br><br>  Fazit: Wenn Sie Code in C oder C ++ schreiben, seien Sie √§u√üerst vorsichtig und vermeiden Sie Situationen, die zu undefiniertem Verhalten f√ºhren, auch wenn es so aussieht, als w√§re es in Ordnung. <br><br>  Ganzzahlige Typen ohne Vorzeichen sind ein guter Helfer bei arithmetischen Berechnungen, da ihnen eine modulare Semantik garantiert ist (es k√∂nnen jedoch weiterhin Probleme im Zusammenhang mit der Erweiterung von Ganzzahltypen auftreten).  Eine andere Option - aus irgendeinem Grund unbeliebt - besteht darin, √ºberhaupt nicht in C und C ++ zu schreiben.  Aus mehreren Gr√ºnden ist diese L√∂sung nicht immer geeignet.  Wenn Sie jedoch ausw√§hlen k√∂nnen, in welcher Sprache das Programm geschrieben werden soll, d. H.  Wenn Sie gerade ein neues Projekt auf einer Plattform starten, die Go, Rust, Java oder andere Sprachen unterst√ºtzt, ist es m√∂glicherweise rentabler, die Verwendung von C als "Standardsprache" abzulehnen.  Die Auswahl der Tools, einschlie√ülich einer Programmiersprache, ist immer ein Kompromiss.  Fallstricke von C, insbesondere unbestimmtes Verhalten bei Vorg√§ngen mit signierten Typen, f√ºhren zu zus√§tzlichen Kosten f√ºr die weitere Wartung des Codes, die h√§ufig untersch√§tzt werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439502/">https://habr.com/ru/post/de439502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439490/index.html">.NET-Referenztypen im Vergleich zu Werttypen. Teil 2</a></li>
<li><a href="../de439492/index.html">10 Tipps f√ºr einen guten technischen Vorsprung</a></li>
<li><a href="../de439496/index.html">So erfolgt die Abrechnung dort: Wenn Kunde und Entwickler unterschiedliche Sprachen sprechen</a></li>
<li><a href="../de439498/index.html">Auf welcher Hardware soll ein riesiger Informationsschacht analysiert werden?</a></li>
<li><a href="../de439500/index.html">Warum sind Captchas so kompliziert geworden?</a></li>
<li><a href="../de439504/index.html">Ben√∂tigt Ihr Team einen Dateningenieur?</a></li>
<li><a href="../de439506/index.html">9 Alternativen zu einem schlechten Team (Designmuster)</a></li>
<li><a href="../de439508/index.html">Mitap √ºber Open Source-Entwicklung in Moskau</a></li>
<li><a href="../de439510/index.html">Hoch belastetes verteiltes Steuerungssystem eines modernen Kernkraftwerks</a></li>
<li><a href="../de439512/index.html">Das Alter der Dinosaurier oder die gesetzlich gepr√ºfte R√ºckversicherung?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>