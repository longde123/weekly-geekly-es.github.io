<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽 🏁 ✳️ Teknik pemrograman umum di Rust: bagaimana kami menerjemahkan Exonum dari Iron ke actix-web 👎 👌🏾 🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ekosistem Rust belum sepenuhnya menetap. Perpustakaan baru sering muncul di dalamnya, yang terasa lebih baik dari pendahulunya, dan kerangka kerja yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teknik pemrograman umum di Rust: bagaimana kami menerjemahkan Exonum dari Iron ke actix-web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitfury/blog/429450/"> Ekosistem Rust belum sepenuhnya menetap.  Perpustakaan baru sering muncul di dalamnya, yang terasa lebih baik dari pendahulunya, dan kerangka kerja yang populer sebelumnya menjadi usang.  Inilah yang terjadi dengan kerangka web Iron yang kami gunakan saat mengembangkan Exonum. <br><br>  Actix-web terpilih sebagai pengganti Iron.  Selanjutnya saya akan memberi tahu bagaimana kami mem-porting kode yang ada ke solusi baru menggunakan teknik pemrograman umum. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/c1/e0/un/c1e0unbkgiazhkhwcm7m5yt5v24.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>Gambar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulleo</a> PD</i></font> <br><br><h2>  Bagaimana kami menggunakan Besi </h2><br>  Di Exonum, kerangka besi digunakan tanpa abstraksi.  Kami memasang penangan pada sumber daya tertentu, menerima parameter kueri dengan mem-parsing URL menggunakan metode tambahan, dan mengembalikan hasilnya hanya sebagai string. <br><br>  Semuanya terlihat seperti ini: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_blocks_response</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blocks = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.required_param(req, <span class="hljs-string"><span class="hljs-string">"count"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latest: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"latest"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> skip_empty_blocks: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"skip_empty_blocks"</span></span>)? .unwrap_or(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blocks(count, latest.map(Height), skip_empty_blocks)?; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ok_response(&amp;::serde_json::to_value(info).unwrap()) }; router.get(<span class="hljs-string"><span class="hljs-string">"/v1/blocks"</span></span>, blocks, <span class="hljs-string"><span class="hljs-string">"blocks"</span></span>); }</code> </pre> <br>  Selain itu, beberapa add-on middleware dalam bentuk header CORS digunakan.  Untuk menggabungkan semua penangan ke dalam satu API, kami menggunakan mount. <br><br><h2>  Mengapa Anda harus meninggalkannya? </h2><br>  Besi adalah pekerja keras yang baik dengan banyak tambahan.  Namun, itu ditulis pada masa-masa yang jauh, ketika proyek seperti futures dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tokio</a> tidak ada. <br><br>  Arsitektur besi menyediakan pemrosesan permintaan yang sinkron, sehingga mudah dipasang pada blade bahu dengan sejumlah besar koneksi yang terbuka secara bersamaan.  Agar Besi menjadi skalabel, ia harus dibuat tidak sinkron.  Untuk melakukan ini, perlu memikirkan kembali dan menulis ulang seluruh kerangka kerja, tetapi pengembang secara bertahap meninggalkan pekerjaan di atasnya. <br><br><h2>  Mengapa kami beralih ke actix-web </h2><br>  Ini adalah kerangka kerja populer yang menempati peringkat tinggi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam tolok ukur TechEmpower</a> .  Pada saat yang sama, ia, tidak seperti Iron, aktif berkembang.  Actix-web memiliki API yang dirancang dengan baik dan implementasi berkualitas tinggi berdasarkan kerangka aktor actix.  Permintaan diproses secara tidak sinkron oleh kumpulan utas, dan jika pemrosesan mengarah pada kepanikan, aktor secara otomatis memulai kembali. <br><br>  Tentu saja, actix-web memiliki kekurangan, misalnya, berisi sejumlah besar kode tidak aman.  Tetapi kemudian itu ditulis ulang di Safe Rust, yang memecahkan masalah ini. <br><br><blockquote>  Beralih ke actix memecahkan masalah stabilitas.  Iron-backend dapat dijatuhkan oleh sejumlah besar koneksi.  Secara umum, API baru adalah solusi yang lebih sederhana, lebih produktif, dan terpadu.  Pengguna dan pengembang akan lebih mudah menggunakan antarmuka perangkat lunak, dan kecepatannya akan meningkat. </blockquote><br><h2>  Apa yang kita inginkan dari kerangka kerja web </h2><br>  Penting bagi kami untuk tidak hanya mengubah Iron menjadi actix-web, tetapi untuk membuat fondasi untuk masa depan - untuk mengerjakan arsitektur API baru untuk abstrak dari kerangka web tertentu.  Ini akan memungkinkan Anda untuk membuat penangan, hampir tanpa memikirkan spesifikasi web dan mentransfernya ke backend apa pun.  Ini dapat dilakukan dengan menulis frontend yang akan beroperasi pada tipe dan tipe dasar. <br><br>  Untuk memahami bagaimana tampilan frontend ini, mari kita tentukan apa itu HTTP API: <br><br><ul><li>  Permintaan dibuat secara eksklusif oleh klien, dan server hanya menjawabnya (tidak bertindak sebagai pemrakarsa). </li><li>  Permintaan dibaca dan dimodifikasi. </li><li>  Sebagai hasil dari kueri, server mengembalikan respons yang berisi data keberhasilan yang diinginkan, dan jika terjadi kesalahan, informasi tentangnya. </li></ul><br>  Jika kami menganalisis semua lapisan abstraksi, ternyata setiap permintaan HTTP hanyalah panggilan fungsi: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span></span>(context: &amp;ServiceContext, query: Query) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response, ServiceError&gt;</code> </pre> <br>  Segala sesuatu yang lain dapat dianggap sebagai ekstensi dari entitas dasar ini.  Jadi, untuk mengabaikan implementasi spesifik kerangka kerja web, kita perlu menulis penangan dengan gaya yang mirip dengan contoh di atas. <br><br><h5>  Sifat titik akhir untuk pemrosesan permintaan HTTP umum </h5><br>  Anda dapat pergi dengan cara paling sederhana dan paling mudah dan mendeklarasikan sifat Endpoint, <br>  menggambarkan penerapan kueri tertentu: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   GET .      //    ,      . //         . trait Endpoint: Sync + Send + 'static { type Request: DeserializeOwned + 'static; type Response: Serialize + 'static; fn handle(&amp;self, context: &amp;Context, request: Self::Request) -&gt; Result&lt;Self::Response, io::Error&gt;; }</span></span></code> </pre><br>  Setelah itu, Anda perlu menerapkan penangan ini dalam kerangka kerja tertentu.  Katakanlah untuk actix-web terlihat seperti ini: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    actix-web.  ,   , //  `Endpoint`   . type FutureResponse = actix_web::FutureResponse&lt;HttpResponse, actix_web::Error&gt;; // «»    actix-web.      //   .     , //     . type RawHandler = dyn Fn(HttpRequest&lt;Context&gt;) -&gt; FutureResponse + 'static + Send + Sync; //   ,     ,     . #[derive(Clone)] struct RequestHandler { ///  . pub name: String, /// HTTP . pub method: actix_web::http::Method, ///  .  ,       . pub inner: Arc&lt;RawHandler&gt;, }</span></span></code> </pre><br>  Anda dapat menggunakan struktur untuk meneruskan parameter permintaan melalui konteks.  Actix-web dapat secara otomatis deserialize parameter menggunakan serde.  Misalnya, a = 15 &amp; b = hello deserialized ke dalam struktur bentuk berikut: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleQuery</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre><br>  Ini konsisten dengan jenis Permintaan terkait dari sifat Endpoint. <br><br>  Sekarang mari kita menulis adaptor yang membungkus implementasi Endpoint spesifik di RequstHandler untuk actix-web.  Harap perhatikan bahwa informasi tentang jenis Permintaan dan Respons hilang dalam proses.  Teknik ini disebut tipe erasure.  Tugasnya adalah mengubah penjadwalan statis menjadi dinamis. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> RequestHandler { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_endpoint</span></span></span></span>&lt;E: Endpoint&gt;(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, endpoint: E) -&gt; RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |request: HttpRequest&lt;Context&gt;| -&gt; FutureResponse { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = request.state(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;E::Request&gt;| query.into_inner()) .and_then(|query| endpoint.handle(context, query).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from)) .and_then(|value| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(HttpResponse::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>().json(value))) .into_future(); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future) }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { name: name.to_owned(), method: actix_web::http::Method::GET, inner: Arc::from(index) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Arc&lt;RawHandler&gt;, } } }</code> </pre><br>  Pada tahap ini, Anda dapat menambahkan penangan untuk permintaan POST dan berhenti, karena kami membuat sifat yang disarikan dari detail implementasi.  Namun, masih belum terlalu ergonomis. <br><br><h5>  Ketik masalah </h5><br>  Saat menulis handler, banyak kode tambahan dihasilkan: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    . struct ElementCountEndpoint { elements: Rc&lt;RefCell&lt;Vec&lt;Something&gt;&gt;&gt;, } //   Endpoint. impl Endpoint for ElementCountEndpoint { type Request = (); type Result = usize; fn handle(&amp;self, context: &amp;Context, _request: ()) -&gt; Result&lt;usize, io::Error&gt; { Ok(self.elements.borrow().len()) } } //    . let endpoint = ElementCountEndpoint::new(elements.clone()); let handler = RequestHandler::from_endpoint("/v1/element_count", endpoint); actix_backend.endpoint(handler);</span></span></code> </pre><br>  Idealnya, saya ingin dapat melewati penutupan normal sebagai seorang pawang, mengurangi jumlah kebisingan sintaks dengan urutan besarnya: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = elements.clone(); actix_backend.endpoint(<span class="hljs-string"><span class="hljs-string">"/v1/elements_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || {   <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(elements.borrow().len()) });</code> </pre><br>  Saya akan berbicara tentang bagaimana melakukan ini nanti. <br><br><h2>  Perendaman mudah dalam pemrograman umum </h2><br>  Kita perlu menyadari kemampuan untuk secara otomatis menghasilkan adaptor yang mengimplementasikan Endpoint dengan tipe terkait yang benar.  Dalam hal ini, hanya penutupan dengan penangan permintaan HTTP yang akan diumpankan ke input. <br><br>  Argumen dan hasil penutupan dapat dari berbagai jenis, jadi di sini Anda harus bekerja dengan metode overloading.  Karat tidak mendukung kelebihan beban secara langsung, tetapi memungkinkan untuk ditiru menggunakan sifat Into dan From. <br><br>  Selain itu, tipe nilai kembali penutupan tidak harus cocok dengan nilai kembali implementasi Endpoint.  Untuk memanipulasi tipe ini, itu harus diekstraksi dari tipe penutupan yang diterima. <br><br><h5>  Ekstraksi jenis dari tipe Fn </h5><br>  Di Rust, setiap penutupan memiliki tipe uniknya sendiri, yang tidak dapat ditulis secara eksplisit dalam program.  Untuk memanipulasi penutupan, ada tipe Fn.  Ini berisi tanda tangan fungsi dengan jenis argumen dan nilai balik, namun mengekstraksinya secara terpisah tidak begitu sederhana. <br><br>  Gagasan utamanya adalah menggunakan struktur bantu dari bentuk berikut: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///       F: Fn(A) -&gt; B. struct SimpleExtractor&lt;A, B, F&gt; {   //   .   inner: F,   _a: PhantomData&lt;A&gt;,   _b: PhantomData&lt;B&gt;, }</span></span></code> </pre><br>  Kami terpaksa menggunakan PhantomData karena Rust mengharuskan semua parameter generalisasi berada dalam definisi struktur.  Namun, tipe penutupan tertentu atau fungsi F tidak digeneralisasi (meskipun mengimplementasikan tipe umum Fn).  Tipe parameter A dan B tidak langsung digunakan di dalamnya. <br><br>  Batasan sistem tipe Rust inilah yang tidak memungkinkan penggunaan strategi yang lebih sederhana - untuk mengimplementasikan sifat Endpoint untuk penutupan secara langsung: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span></span> = A; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span></span> = B; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;Context, request: A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;B, io::Error&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  Kompiler dalam hal ini mengembalikan kesalahan: <br><br><pre> <code class="rust hljs">error[E0207]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span> `A` is not constrained by the <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span></span> predicates --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { | ^ unconstrained <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span></code> </pre><br>  Struktur helper dari SimpleExtractor memungkinkan untuk menggambarkan transformasi Dari.  Ini memungkinkan Anda untuk menyimpan fungsi apa pun dan mengekstrak jenis argumennya: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SimpleExtractor&lt;A, B, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B, A: DeserializeOwned, B: Serialize, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(inner: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { SimpleExtractor { inner, _a: PhantomData, _b: PhantomData, } } }</code> </pre><br>  Kode berikut berhasil dikompilasi: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">//   . fn my_handler(_: &amp;Context, q: Query) -&gt; String { format!("{} has {} apples.", qb, qa) } let fn_extractor = SimpleExtractor::from(my_handler); //  . let c = 15; let my_closure = |_: &amp;Context, q: Query| -&gt; String { format!("{} has {} apples, but Alice has {}", qb, qa, c) }; let closure_extractor = SimpleExtractor::from(my_closure);</span></span></code> </pre><br><h5>  Jenis spesialisasi dan penanda </h5><br>  Sekarang kita memiliki fungsi dengan tipe argumen parameter secara eksplisit, cocok untuk digunakan sebagai ganti sifat Endpoint.  Misalnya, kita dapat dengan mudah mengimplementasikan konversi dari SimpleExtractor ke RequestHandler.  Tapi tetap saja, ini bukan solusi lengkap.  Kita juga perlu membedakan antara GET handler permintaan dan permintaan POST pada tingkat tipe (dan penangan sinkron dari yang asinkron).  Jenis penanda yang disebut akan membantu kita dengan ini. <br><br>  Pertama, kami menulis ulang SimpleExtractor sehingga dapat membedakan antara hasil sinkron dan asinkron.  Pada saat yang sama, kami menerapkan sifat Dari untuk masing-masing kasus.  Perhatikan bahwa sifat-sifat dapat diimplementasikan untuk varian spesifik dari struktur umum. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///   HTTP-. pub struct With&lt;Q, I, R, F&gt; { ///  -. pub handler: F, ///     . _query_type: PhantomData&lt;Q&gt;, ///   . _item_type: PhantomData&lt;I&gt;, ///  ,  . ///  ,       . _result_type: PhantomData&lt;R&gt;, } //   ,   . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, Result&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } } //     . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, FutureResult&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</span></span></code> </pre><br>  Sekarang kita perlu mendeklarasikan struktur di mana untuk menggabungkan penangan permintaan dengan nama dan variasinya: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedWith</span></span></span></span>&lt;Q, I, R, F, K&gt; {   <span class="hljs-comment"><span class="hljs-comment">///  .   pub name: String,   ///    .   pub inner: With&lt;Q, I, R, F&gt;,   ///  .   _kind: PhantomData&lt;K&gt;, }</span></span></code> </pre><br>  Setelah Anda dapat mendeklarasikan beberapa struktur kosong yang akan bertindak sebagai jenis marker.  Marker memungkinkan Anda untuk mengimplementasikan masing-masing penangan kode konversinya sendiri ke RequestHandler yang dijelaskan sebelumnya. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// ,    .  HTTP   GET-. pub struct Immutable; /// ,   .  HTTP   POST, PUT, UPDATE ///    ,        POST. pub struct Mutable;</span></span></code> </pre><br>  Sekarang kita dapat mendefinisikan empat implementasi yang berbeda dari tipe Dari untuk semua kombinasi parameter template R dan K (nilai pengembalian pawang dan jenis permintaan). <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state(); let future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;Q&gt;| query.into_inner()) .and_then(|query| handler(context, query).map_err(From::from)) .and_then(|value| Ok(HttpResponse::Ok().json(value))) .into_future(); Box::new(future) }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state().clone(); let handler = handler.clone(); Query::from_request(&amp;request, &amp;()) .map(move |query: Query&lt;Q&gt;| query.into_inner()) .into_future() .and_then(move |query| handler(&amp;context, query).map_err(From::from)) .map(|value| HttpResponse::Ok().json(value)) .responder() }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } }</span></span></code> </pre><br><h5>  "Fasad" untuk backend </h5><br>  Sekarang untuk semua ini masih menulis "fasad", yang akan mengambil penutupan dan menambahkannya ke backend yang sesuai.  Dalam kasus kami, hanya ada satu backend - actix-web - tetapi di belakang fasad Anda dapat menyembunyikan implementasi tambahan yang Anda suka, misalnya, generator spesifikasi Swagger. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceApiScope</span></span></span></span> { actix_backend: actix::ApiBuilder, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ServiceApiScope { <span class="hljs-comment"><span class="hljs-comment">///    Immutable    . pub fn endpoint&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where //     ,      : Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, //  ,          //  NamedWith  RequestHandler. RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Immutable&gt;&gt;, { self.actix_backend.endpoint(name, endpoint); self } ///    Mutable . pub fn endpoint_mut&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Mutable&gt;&gt;, { self.actix_backend.endpoint_mut(name, endpoint); self }</span></span></code> </pre><br>  Perhatikan bagaimana jenis parameter permintaan, jenis hasilnya, serta sinkronisasi / asinkron dari pawang secara otomatis berasal dari tanda tangannya.  Selain itu, Anda harus secara eksplisit menentukan nama permintaan, serta jenisnya. <br><br><h2>  Kerugian dari pendekatan </h2><br>  Pendekatan ini masih memiliki kekurangan.  Secara khusus, <i>endpoint dan endpoint_mut harus mengetahui spesifikasi penerapan backend spesifik</i> .  Ini tidak memungkinkan kami untuk menambahkan backend on the fly, tetapi fungsi seperti itu jarang diperlukan. <br><br>  Masalah lain adalah bahwa <i>Anda tidak dapat menentukan spesialisasi untuk penangan tanpa argumen tambahan.</i>  Dengan kata lain, jika kita menulis kode berikut, itu tidak akan dikompilasi, karena bertentangan dengan implementasi umum yang ada: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;(), I, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> With&lt;(), I, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;ServiceApiState) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(handler: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</code> </pre> <br>  Akibatnya, permintaan yang tidak memiliki parameter masih harus menerima string JSON nol, yang dideserialisasi ke ().  Masalah ini dapat diselesaikan dengan spesialisasi dalam gaya C ++, tetapi sejauh ini hanya tersedia dalam versi malam dari kompiler dan tidak jelas kapan "stabil". <br><br>  <i>Demikian pula, Anda tidak dapat mengkhususkan jenis nilai pengembalian.</i>  Bahkan jika permintaan tidak menyiratkannya, itu akan selalu mengembalikan JSON dengan nol. <br><br>  <i>Mendekripsi permintaan URL dalam permintaan GET juga membebankan beberapa pembatasan yang tidak jelas pada jenis parameter,</i> tetapi ini sudah fitur implementasi serde-urlencoded. <br><br><h2>  Kesimpulan </h2><br>  Karenanya, kami menerapkan API yang memungkinkan Anda membuat penangan dengan mudah dan mudah, hampir tanpa memikirkan spesifikasi web.  Kemudian mereka dapat ditransfer ke backend apa pun atau bahkan menggunakan beberapa backend pada saat yang sama. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429450/">https://habr.com/ru/post/id429450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429420/index.html">PlayStation Classic menggunakan emulator PCSX ReARMed untuk operasi, tidak ada solusi eksklusif</a></li>
<li><a href="../id429422/index.html">UHCI, atau USB pertama</a></li>
<li><a href="../id429424/index.html">Robotaxi dari Daimler dan Bosch akan muncul di California</a></li>
<li><a href="../id429426/index.html">QGIS dan ekspor ubin</a></li>
<li><a href="../id429448/index.html">Kami menulis pemuat FPGA di LabVIEW. Bagian 2</a></li>
<li><a href="../id429452/index.html">Pentagon mulai mendeklasifikasi malware orang lain</a></li>
<li><a href="../id429456/index.html">Sudah cerita: di mana budaya startup dimulai pada 1930-an</a></li>
<li><a href="../id429458/index.html">Bagaimana saya melakukan animasi Tata Surya untuk anak kelas dua</a></li>
<li><a href="../id429460/index.html">Ringkasan laporan “Apa yang kita ketahui tentang layanan mikro” (HL2018, Avito, Vadim Madison)</a></li>
<li><a href="../id429464/index.html">Bisakah blok 35 ton ini memecahkan masalah energi terbarukan yang sangat besar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>