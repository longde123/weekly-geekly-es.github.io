<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏼 🕐 👵🏼 فهم وسطاء الرسائل. تعلم آليات المراسلة من خلال ActiveMQ و Kafka. الفصل 2. ActiveMQ 🧝🏿 🤠 💘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="استمرار ترجمة كتاب صغير: 
 "فهم وسطاء الرسائل" ، 
 المؤلف: Jakub Korab ، الناشر: O'Reilly Media، Inc. ، تاريخ النشر: يونيو 2017 ، ISBN: 9781492049296....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>فهم وسطاء الرسائل. تعلم آليات المراسلة من خلال ActiveMQ و Kafka. الفصل 2. ActiveMQ</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471268/" style=";text-align:right;direction:rtl">  استمرار ترجمة كتاب صغير: <br>  "فهم وسطاء الرسائل" ، <br>  المؤلف: Jakub Korab ، الناشر: O'Reilly Media، Inc. ، تاريخ النشر: يونيو 2017 ، ISBN: 9781492049296. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اكتملت الترجمة</a></b> <br><br>  الجزء السابق: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فهم وسطاء الرسائل.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تعلم آليات المراسلة من خلال ActiveMQ و Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الفصل 1. مقدمة</a> <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  الفصل 2 </h2><br><h2 style=";text-align:right;direction:rtl">  ActiveMQ </h2><br>  من الأفضل وصف ActiveMQ على أنه نظام مراسلة كلاسيكي.  وقد كتب في عام 2004 لسد الحاجة إلى وسيط رسالة مفتوحة المصدر.  في ذلك الوقت ، إذا أردت استخدام المراسلة في تطبيقاتك ، فكان الخيار الوحيد هو منتجات تجارية باهظة الثمن. <br><br>  تم تطوير ActiveMQ كتطبيق لمواصفات خدمة رسائل Java (JMS).  تم اتخاذ هذا القرار للوفاء بمتطلبات تنفيذ المراسلة المتوافقة مع JMS في مشروع Apache Geronimo ، وهو خادم تطبيق J2EE مفتوح المصدر. <br>  يتكون نظام المراسلة (أو الوسيطة الموجهة للرسائل ، كما يطلق عليه في بعض الأحيان) التي تنفذ مواصفات JMS من المكونات التالية: <br><br>  <b>وسيط</b> <br><br>  قطعة مركزية من الوسيطة التي توزع الرسائل. <br><br>  <b>زبون</b> <br><br>  جزء البرنامج الذي يرسل الرسائل من خلال وسيط.  يتكون ، بدوره ، من القطع الأثرية التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  رمز باستخدام واجهة برمجة تطبيقات JMS. </li><li style=";text-align:right;direction:rtl">  واجهة برمجة تطبيقات JMS هي مجموعة من واجهات التفاعل مع وسيط وفقًا للضمانات المنصوص عليها في مواصفات JMS. </li><li style=";text-align:right;direction:rtl">  مكتبة العميل الخاصة بالنظام الذي يوفر تطبيق API ويتفاعل مع الوسيط. </li></ul><br>  يتواصل العميل والوسيط مع بعضهما البعض من خلال بروتوكول طبقة التطبيق ، المعروف أيضًا باسم <i>بروتوكول التفاعل</i> <a href="">(الشكل 2-1)</a> .  ترك مواصفات JMS تفاصيل هذا البروتوكول إلى تطبيقات محددة. <br><br><img src="https://habrastorage.org/webt/u1/wi/za/u1wiza7rupveiqnyqktuqsa-mvs.png"><br>  <i>الشكل 2-1.</i>  <i>مراجعة JMS</i> <br><br>  يستخدم JMS المصطلح " <i>مزود"</i> لوصف تنفيذ البائع لنظام المراسلة الذي يقوم عليه JMS API ، والذي يتضمن الوسيط ، بالإضافة إلى مكتبات العملاء. <br><br>  كان الاختيار المؤيد لتطبيق JMS له عواقب بعيدة المدى على قرارات التنفيذ التي اتخذها مؤلفو ActiveMQ.  توفر المواصفات نفسها إرشادات واضحة حول مسؤوليات عميل نظام المراسلة والوسيط الذي يتصل به ، مع إعطاء الأفضلية لالتزام الوسيط بتوزيع الرسائل وتسليمها.  المسؤولية الرئيسية للعميل هي التفاعل مع المرسل إليه (قائمة الانتظار أو الموضوع) من الرسائل المرسلة من قبله.  تهدف المواصفات نفسها إلى جعل تفاعل واجهة برمجة التطبيقات (API) مع الوسيط بسيطًا نسبيًا. <br><br>  كان لهذه المنطقة ، كما سنرى لاحقًا ، تأثير كبير على أداء ActiveMQ.  بالإضافة إلى تعقيدات الوسيط ، فإن حزمة التوافق للمواصفات التي توفرها Sun Microsystems لها العديد من الفروق الدقيقة ، مع تأثيرها الخاص على الأداء.  يجب أن تؤخذ جميع هذه الفروق الدقيقة في الاعتبار من أجل اعتبار ActiveMQ متوافقًا مع JMS. <br><br><h3 style=";text-align:right;direction:rtl">  صلة </h3><br>  على الرغم من أن API والسلوك المتوقع تم تحديدهما جيدًا في مواصفات JMS ، إلا أنه تم استبعاد بروتوكول الاتصال الفعلي للعميل من المواصفات عملاً حتى يمكن جعل الوسطاء الحاليين متوافقين مع JMS.  وبالتالي ، كان ActiveMQ حرًا في تعريف بروتوكول التفاعل الخاص به ، OpenWire.  يتم استخدام OpenWire من خلال تطبيق مكتبة عملاء ActiveMQ JMS ، وكذلك نظرائه في .Net و C ++: NMS و CMS ، وهما مشروعان فرعيان لـ ActiveMQ تستضيفهما مؤسسة Apache Software Foundation. <br><br>  بمرور الوقت ، تمت إضافة دعم بروتوكولات التفاعل الأخرى إلى ActiveMQ ، مما زاد من القدرة على التفاعل مع اللغات والبيئات الأخرى: <br><br>  <b>AMQP 1.0</b> <br><br>  لا ينبغي الخلط بين بروتوكول انتظار الرسائل المتقدم (ISO / IEC 19464: 2014) مع سابقه 0.X ، والذي يتم تنفيذه في أنظمة المراسلة الأخرى ، ولا سيما RabbitMQ ، باستخدام 0.9.1.  1.0 AMQP هو بروتوكول ثنائي للأغراض العامة لتبادل الرسائل بين العقدتين.  لا يوجد لديه مفهوم للعملاء أو الوسطاء ويتضمن وظائف مثل التحكم في التدفق والمعاملات وجودة الخدمة المختلفة (ليس أكثر من مرة ، مرة واحدة على الأقل ، ومرة ​​واحدة بالضبط). <br><br>  <b>ستومب</b> <br><br>  بروتوكول مراسلة نص بسيط / متدفق ، وهو بروتوكول سهل التنفيذ يحتوي على العشرات من تطبيقات العميل بلغات مختلفة. <br><br>  <b>XMPP</b> <br><br>  الرسائل الموسعة وبروتوكول التواجد.  (بروتوكول الرسائل والتوسع الموسعة).  كان يُطلق عليه سابقًا اسم Jabber ، وقد تم تطوير هذا البروتوكول المستند إلى XML في الأصل لأنظمة الدردشة ، ولكن تم تمديده إلى أبعد من حالات الاستخدام الأصلية ليشمل رسائل اشتراك النشر. <br><br>  <b>MQTT</b> <br><br>  بروتوكول اشتراك النشر الخفيف (ISO / IEC 20922: 2016) المستخدم لتطبيقات من آلة إلى آلة (M2M) وتطبيقات إنترنت الأشياء (IoT). <br><br>  يدعم ActiveMQ أيضًا فرض البروتوكولات أعلاه على WebSockets ، والذي يوفر تبادل بيانات مزدوج الاتجاه بين التطبيقات في مستعرض ويب والوجهات في الوسيط. <br><br>  نظرًا لهذا ، الآن عندما نتحدث عن ActiveMQ ، لم نعد نشير حصريًا إلى رصة التفاعل استنادًا إلى مكتبات JMS / NMS / CMS وبروتوكول OpenWire.  أصبح الجمع بين اللغات والأنظمة الأساسية والمكتبات الخارجية التي تناسب هذا التطبيق واختياره أكثر شيوعًا.  على سبيل المثال ، يمكن تشغيل تطبيق JavaScript في مستعرض باستخدام مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Eclipse Paho</a> MQTT لإرسال رسائل إلى ActiveMQ عبر مآخذ الويب ، وتتم قراءة هذه الرسائل بواسطة عملية خادم C ++ تستخدم AMQP من خلال مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Apache Qpid Proton</a> .  من هذا المنظور ، أصبح مشهد المراسلة أكثر تنوعًا. <br><br>  بالنظر إلى المستقبل ، ستحصل AMQP ، على وجه الخصوص ، على فرص أكثر بكثير مما هي عليه الآن ، حيث أن المكونات التي لا العملاء ولا الوسطاء أصبحت جزءًا مألوفًا أكثر من مشهد المراسلة.  على سبيل المثال ، يعمل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Apache Qpid Dispatch Router</a> كموجه للرسائل ، يتصل به العملاء مباشرة ، مما يسمح لوجهات مختلفة بمعالجة عناوين مختلفة ، فضلاً عن توفير إمكانية المشاركة (الفصل). <br><br>  عند العمل مع مكتبات الجهات الخارجية والمكونات الخارجية ، يرجى ملاحظة أن لديهم جودة متغيرة وقد لا تكون متوافقة مع الوظائف المتوفرة في ActiveMQ.  كمثال بسيط للغاية - من المستحيل إرسال رسائل إلى قائمة الانتظار من خلال MQTT (دون إعداد التوجيه في الوسيط).  وبالتالي ، ستحتاج إلى قضاء بعض الوقت في العمل مع الخيارات لتحديد مكدس نظام المراسلة الأكثر ملاءمة لمتطلبات التطبيق الخاص بك. <br><br><h3 style=";text-align:right;direction:rtl">  المفاضلة بين الأداء والموثوقية </h3><br>  قبل أن نتعمق في تفاصيل كيفية عمل المراسلة من نقطة إلى نقطة في ActiveMQ ، نحتاج إلى التحدث قليلاً حول ما تواجهه جميع الأنظمة مع معالجة البيانات الثقيلة: مفاضلة بين الأداء والموثوقية. <br><br>  يجب إرشاد أي نظام يقبل البيانات ، سواء كان وسيط رسائل أو قاعدة بيانات ، حول كيفية معالجة هذه البيانات في حالة حدوث فشل.  يمكن أن يتخذ الفشل أشكالًا كثيرة ، ولكن من أجل البساطة سنقوم بتضييقه إلى وضع يفقد فيه النظام الطاقة ويتوقف عن العمل على الفور.  في هذه الحالة ، نحتاج إلى التكهن بما سيحدث للبيانات الموجودة في النظام.  إذا كانت البيانات (في هذه الحالة ، الرسائل) في الذاكرة أو في الجزء المتقلب من الحديد ، على سبيل المثال ، في ذاكرة التخزين المؤقت ، فستفقد هذه البيانات.  ومع ذلك ، إذا تم إرسال البيانات إلى وحدة تخزين غير متقلبة ، على سبيل المثال إلى القرص ، فستكون متاحة مرة أخرى عندما يعود النظام إلى العمل. <br><br>  من وجهة النظر هذه ، يكون من المنطقي أننا إذا كنا لا نريد أن نفقد الرسائل في حالة فشل الوسيط ، نحتاج إلى كتابتها إلى وحدة التخزين الدائمة.  تكلفة هذا الحل بالذات ، للأسف ، مرتفعة للغاية. <br><br>  لاحظ أن الفرق بين كتابة ميغا بايت من البيانات على القرص هو 100-1000 مرة أبطأ من الكتابة إلى الذاكرة.  لذلك ، يجب أن يقرر مطور التطبيق ما إذا كانت موثوقية الرسالة تستحق فقدان الأداء أم لا.  يجب اتخاذ القرارات المشابهة بناءً على سيناريو الاستخدام. <br><br>  تعتمد المفاضلة بين الأداء والموثوقية على مجموعة من الخيارات.  كلما زادت الموثوقية ، انخفض الأداء.  إذا قررت جعل النظام أقل موثوقية ، على سبيل المثال ، تخزين الرسائل في الذاكرة فقط ، فستزيد إنتاجيتك بشكل كبير.  بشكل افتراضي ، يتم تكوين JMS ليكون ActiveMQ خارج الصندوق لضمان الموثوقية.  هناك العديد من الآليات التي تسمح لك بتكوين الوسيط والتفاعل معه إلى موقع في هذا الطيف يناسب بشكل أفضل سيناريوهات محددة لاستخدام نظام المراسلة. <br><br>  يتم تطبيق هذا الحل الوسط على مستوى الوسطاء الفرديين.  ومع ذلك ، عند الانتهاء من إعداد وسيط فردي ، من الممكن توسيع نطاق نظام المراسلة إلى ما بعد هذه النقطة عن طريق فحص تدفقات الرسائل ومشاركة حركة المرور بين العديد من الوسطاء بعناية.  يمكن تحقيق ذلك من خلال توفير مستلمين محددين مع الوسطاء الخاصين بهم أو عن طريق تقسيم تدفق الرسائل الكلي إما على مستوى التطبيق أو باستخدام مكون وسيط.  في وقت لاحق ، سننظر بتفصيل أكبر في كيفية مراعاة طبولوجيا الوسطاء. <br><br><h3 style=";text-align:right;direction:rtl">  حفظ الرسائل </h3><br>  يأتي ActiveMQ مع عدد من استراتيجيات الاحتفاظ بالرسائل القابلة للتوصيل.  أنها تأتي في شكل محولات الثبات (الثبات) ، والتي يمكن اعتبارها محركات تخزين الرسائل.  وتشمل هذه الحلول المستندة إلى القرص مثل KahaDB و LevelDB ، وكذلك القدرة على استخدام قاعدة البيانات من خلال JDBC.  نظرًا لأن الأكثر استخدامًا في السابق ، سنركز مناقشتنا عليها. <br><br>  عندما يتلقى وسيط رسائل دائمة ، يتم كتابتها لأول مرة على القرص في مجلة.  دفتر اليومية هو بنية بيانات على القرص حيث يمكنك فقط إضافة بيانات وتتكون من عدة ملفات.  يتم تسلسل الرسائل الواردة بواسطة الوسيط إلى تمثيل مستقل عن البروتوكول للكائن ، ومن ثم تنظيمه في شكل ثنائي ، والذي يتم كتابته بعد ذلك في نهاية السجل.  يحتوي السجل على سجل بجميع الرسائل الواردة ، بالإضافة إلى معلومات حول تلك الرسائل التي تم تأكيدها كما قرأها العميل. <br><br>  تدعم محولات الأقراص الدائمة ملفات الفهرس التي تتعقب مكان الرسائل المعاد توجيهها التالية في السجل.  عند قراءة جميع الرسائل من ملف السجل ، سيتم حذفها أو أرشفتها بواسطة سير عمل خلفية ActiveMQ.  في حالة تلف هذا السجل أثناء فشل الوسيط ، سيقوم ActiveMQ بإعادة إنشائه استنادًا إلى المعلومات الموجودة في ملفات السجل. <br><br>  تتم كتابة الرسائل من جميع قوائم الانتظار إلى ملفات السجل نفسها ، مما يعني أنه إذا لم تتم قراءة رسالة واحدة ، فلن يمكن مسح الملف بالكامل (عادةً ما يكون الافتراضي هو 32 ميجابايت أو 100 ميجابايت ، وفقًا لمحول الثبات).  هذا يمكن أن يسبب مشاكل مع انخفاض مساحة القرص مع مرور الوقت. <br><blockquote style=";text-align:right;direction:rtl">  لم يتم تصميم وسطاء الرسائل الكلاسيكية للتخزين على المدى الطويل - اقرأ رسائلك! </blockquote>  تعد السجلات آلية فعالة للغاية لتخزين الرسائل واستعادتها لاحقًا ، حيث أن الوصول إلى القرص متسلسل لكلتا العمليتين.  على الأقراص الصلبة التقليدية ، يؤدي هذا إلى تقليل عدد عمليات البحث عن الأقراص بواسطة الأسطوانات ، نظرًا لأن رؤوس القرص تستمر ببساطة في قراءة القطاعات أو كتابتها على الركيزة الدوارة للقرص.  وبالمثل ، في محركات أقراص الحالة الثابتة ، يكون الوصول التسلسلي أسرع بكثير من الوصول العشوائي ، حيث أن الأول يستخدم بشكل أفضل صفحات ذاكرة محرك الأقراص. <br><br><h3 style=";text-align:right;direction:rtl">  عوامل أداء القرص </h3><br>  هناك عدد من العوامل التي تحدد السرعة التي يمكن أن يعمل بها القرص.  لفهم ذلك ، فكر في طريقة الكتابة إلى القرص من خلال نموذج عقلي مبسط للأنبوب ( <a href="">الشكل 2-2</a> ). <br><br><img src="https://habrastorage.org/webt/kv/wx/j_/kvwxj_wqzdn772kf0lb5yttf4i8.png"><br>  <i>الشكل 2-2.</i>  <i>نموذج أنبوب أداء القرص</i> <br><br>  الأنبوب له ثلاثة أبعاد: <br><br>  <b>طول</b> <br><br>  يتوافق مع <i>الكمون</i> المتوقع لإكمال عملية واحدة.  بالنسبة لمعظم محركات الأقراص المحلية ، يعد هذا الأمر جيدًا ، ولكنه قد يصبح عاملاً محددًا في البيئات السحابية حيث يوجد محرك أقراص محلي بالفعل عبر الإنترنت.  على سبيل المثال ، في وقت كتابة هذا التقرير (أبريل 2017) ، تضمن Amazon أن الكتابة إلى وحدة تخزين EBS الخاصة بها ستكون "في أقل من 2 مللي ثانية."  إذا سجلنا بالتتابع ، فهذا يعطي سرعة قصوى تبلغ 500 سجل في الثانية. <br><br>  <b>عرض</b> <br><br>  يحدد <i>القدرة الاستيعابية أو عرض النطاق الترددي لعملية</i> واحدة.  تستخدم ذاكرة التخزين المؤقت لنظام الملفات هذه الخاصية عن طريق دمج العديد من السجلات الصغيرة في مجموعة أصغر من عمليات الكتابة الأكبر التي يتم إجراؤها على القرص. <br><br>  <b>عرض النطاق الترددي مع مرور الوقت</b> <br><br>  يتم تقديم الفكرة في شكل سلسلة من الأحداث التي يمكن أن تكون في الأنبوب في نفس الوقت ، معبراً عنها بمقياس يسمى <i>IOPS (عدد عمليات الإدخال / الإخراج في الثانية)</i> .  يشيع استخدام IOPS من قبل الشركات المصنعة للتخزين وموفري الخدمات السحابية لقياس الأداء.  سيكون للقرص الصلب قيم IOPS مختلفة في سياقات مختلفة: ما إذا كان عبء العمل يتكون أساسًا من قراءة أو كتابة أو مزيج من هذه العناصر ، وما إذا كانت هذه العمليات متسلسلة أم تعسفية أم مختلطة.  قياسات IOPS الأكثر إثارة للاهتمام من وجهة نظر الوسيط هي عمليات قراءة وكتابة متسلسلة ، لأنها تتوافق مع سجلات قراءة وكتابة السجل. <br><br>  يتم تحديد الحد الأقصى للإنتاجية لوسيط الرسائل من خلال <i>تحقيق أول هذه القيود ،</i> ويعتمد تكوين الوسيط إلى حد كبير على الطريقة التي تتفاعل بها مع الأقراص.  هذا ليس فقط عاملاً في كيفية تكوين الوسيط ، على سبيل المثال ، يعتمد أيضًا على كيفية تفاعل المنتجين مع الوسيط.  كما هو الحال مع كل ما يتعلق بالأداء ، من الضروري اختبار الوسيط على عبء عمل تمثيلي (أي ، أقرب ما يمكن من الرسائل الحقيقية) وعلى تكوين التخزين الفعلي الذي سيتم استخدامه في PROM.  يتم ذلك لفهم كيفية تصرف النظام في الواقع. <br><br><h3 style=";text-align:right;direction:rtl">  JMS API </h3><br>  قبل الدخول في تفاصيل كيفية اتصال ActiveMQ مع العملاء ، نحتاج أولاً إلى معرفة واجهة برمجة تطبيقات JMS.  يعرّف API مجموعة من واجهات البرمجة المستخدمة بواسطة رمز العميل: <br><br>  <b>ConnectionFactory</b> <br><br>  هذه هي واجهة المستوى الأعلى المستخدمة لإقامة اتصالات مع الوسيط.  في تطبيق المراسلة النموذجي ، هناك مثيل واحد فقط من هذه الواجهة.  في ActiveMQ ، هذا هو ActiveMQConnectionFactory.  في المستوى الأعلى ، يحدد هذا التصميم موقع وسيط الرسائل ، إلى جانب تفاصيل منخفضة المستوى حول كيفية التفاعل معه.  كما يوحي الاسم ، ConnectionFactory هي الآلية التي يتم من خلالها إنشاء كائنات الاتصال. <br><br>  <b>صلة</b> <br><br>  هذا كائن طويل العمر يشبه اتصال TCP تقريبًا - بعد الإنشاء ، عادة ما يكون موجودًا طوال دورة حياة التطبيق بالكامل حتى يتم إغلاقه.  الاتصال آمن للخيط ويمكنه العمل مع عدة خيوط في وقت واحد.  تسمح لك كائنات الاتصال بإنشاء كائنات الجلسة. <br><br>  <b>جلسة</b> <br><br>  هذا مؤشر دفق عند التفاعل مع وسيط.  كائنات جلسة العمل غير آمنة لمؤشر الترابط ، مما يعني أنه لا يمكن الوصول إليها بواسطة مؤشرات ترابط متعددة في نفس الوقت.  الجلسة هي واصف المعاملات الرئيسي الذي يمكن للمبرمج أن يرسل ويعيد رسائل التراجع إذا كان في وضع المعاملات.  باستخدام هذا الكائن ، يمكنك إنشاء كائنات MessageConsumer و MessageProducer ، وكذلك الحصول على مؤشرات (واصفات) إلى كائنات Topic و Queue. <br><br>  <b>MessageProducer</b> <br><br>  تتيح لك هذه الواجهة إرسال رسالة إلى المستلم. <br><br>  <b>MessageConsumer</b> <br><br>  تسمح هذه الواجهة للمطور باستلام الرسائل.  هناك آليتان لاستعادة الرسائل: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تسجيل MessageListener.  هذه هي واجهة معالج الرسائل التي قمت بتطبيقها ، والتي ستقوم بمعالجة أي رسائل صادرة عن الوسيط باستخدام تيار واحد. </li><li style=";text-align:right;direction:rtl">  استقصاء الرسائل باستخدام طريقة التلقي (). </li></ul><br>  <b>رسالة</b> <br><br>  ربما هذا هو الهيكل الأكثر أهمية لأنه ينقل بياناتك.  تتكون الرسائل في JMS من جانبين: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  بيانات التعريف للرسالة.  تحتوي الرسالة على رؤوس وخصائص.  كل ذلك ، وهذا يمكن اعتباره عناصر من الخريطة.  الرؤوس عبارة عن عناصر معروفة معروفة بواسطة مواصفات JMS ومتاحة مباشرة من خلال واجهة برمجة التطبيقات ، مثل JMSDestination و JMSTimestamp.  الخصائص هي أجزاء عشوائية من معلومات الرسائل التي تم تعيينها لتبسيط معالجة الرسائل أو توجيهها دون الحاجة إلى قراءة حمولة الرسالة نفسها.  يمكنك ، على سبيل المثال ، تعيين الرأس إلى AccountID أو OrderType. </li><li style=";text-align:right;direction:rtl">  نص الرسالة.  يمكن إنشاء عدة أنواع مختلفة من الرسائل من الجلسة بناءً على نوع المحتوى الذي سيتم إرساله في النص ، وأكثرها شيوعًا هي TextMessage للسلاسل و BytesMessage للبيانات الثنائية. </li></ul><br><h3 style=";text-align:right;direction:rtl">  كيف تعمل قوائم الانتظار: قصة ثنائية المخ </h3><br>  نموذج ActiveMQ مفيد ، وإن يكن غير دقيق ، هو نموذج لنصفين من المخ.  جزء واحد مسؤول عن تلقي الرسائل من المنتج ، والآخر يرسل هذه الرسائل إلى المستهلكين.  العلاقات في الواقع أكثر تعقيدًا لأغراض تحسين الأداء ، لكن النموذج يكفي لفهم أساسي. <br><br><h4 style=";text-align:right;direction:rtl">  إرسال الرسائل إلى قائمة الانتظار </h4><br>  لنلق نظرة على التفاعل الذي يحدث عند إرسال رسالة. <a href=""><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يوضح لنا </font><a href=""><font style="vertical-align: inherit;">الشكل 2-3</font></a><font style="vertical-align: inherit;"> نموذجًا مبسطًا للعملية التي يتم من خلالها تلقي الرسائل بواسطة الوسيط. لا يتوافق تمامًا مع السلوك في كل حالة ، ولكنه مناسب تمامًا للحصول على فهم أساسي. </font></font><br><br><img src="https://habrastorage.org/webt/u9/tc/_p/u9tc_p1dznwdwdajfxt19fsoxva.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشكل 2-3. إرسال الرسائل إلى JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في تطبيق العميل ، يتلقى مؤشر الترابط مؤشرًا إلى MessageProducer. يقوم بإنشاء رسالة ذات حمولة رسالة تقديرية ويستدعي MessageProducer.send ("الطلبات" ، الرسالة) ، مع قائمة الانتظار كوجهة أخيرة للرسالة. نظرًا لعدم رغبة المبرمج في فقد الرسالة في حالة تعطل الوسيط ، تم تعيين رأس الرسالة JMSDeliveryMode على PERSISTENT (السلوك الافتراضي).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه المرحلة (1) ، يستدعي الدفق المرسل مكتبة العميل ويقوم بتنظيم الرسالة بتنسيق OpenWire. ثم يتم إرسال الرسالة إلى الوسيط. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الوسيط ، يقوم الدفق المتلقي بإزالة الرسالة من الخط وإلغاء تنظيمها على الكائن الداخلي. بعد ذلك ، يتم إرسال كائن الرسالة إلى مهايئ الثبات ، الذي ينظم الرسالة باستخدام تنسيق Google Protocol Buffers ويكتبها إلى وحدة التخزين (2). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد تسجيل الرسالة في وحدة التخزين ، يجب أن يتلقى مهايئ الثبات تأكيدًا على تسجيل الرسالة فعليًا (3). هذا هو عادةً أبطأ جزء من التفاعل بالكامل ؛ المزيد عن هذا في وقت لاحق.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بمجرد أن يتأكد الوسيط من أنه قد تم حفظ الرسالة ، فسيرسل رد تأكيد (4) إلى العميل. بعد ذلك ، يمكن أن يواصل مؤشر ترابط العميل الذي يسمى في الأصل عملية send () عمله.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذا التأكيد المعلق للرسائل المستمرة هو أساس الضمان المقدم من JMS API - إذا كنت تريد حفظ الرسالة ، فمن المحتمل أن يكون من المهم لك أيضًا ما إذا كان قد تم استلام الرسالة من قبل الوسيط في المقام الأول. هناك عدد من الأسباب التي تجعل هذا الأمر غير ممكن ، على سبيل المثال ، تم الوصول إلى حد الذاكرة أو القرص. بدلاً من الفشل ، يقوم الوسيط إما بتعليق عملية الإرسال ، مما يجبر المنتج على الانتظار حتى تتوفر موارد نظام كافية لمعالجة الرسالة (عملية تسمى Producer Flow Control) ، أو سوف يرسل تأكيدًا سلبيًا إلى المنتج ، مع استثناء. السلوك الدقيق قابل للتخصيص لكل وسيط.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه العملية البسيطة ، يحدث عدد كبير من تفاعلات الإدخال / الإخراج: عمليتان للشبكة بين المنتج والوسيط ، عملية حفظ واحدة وخطوة تأكيد. يمكن أن تكون عملية الحفظ عملية بسيطة للكتابة على القرص أو انتقال آخر لشبكة الاتصال إلى خادم التخزين. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يثير هذا سؤالًا مهمًا حول وسطاء الرسائل: يرتبط عملهم بدفق مكثف للغاية من عمليات الإدخال / الإخراج وهم حساسون جدًا للبنية التحتية المستخدمة ، خاصة الأقراص.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعونا نلقي نظرة فاحصة على خطوة التأكيد (3) في التفاعل أعلاه. </font><font style="vertical-align: inherit;">إذا كان محول الثبات قائمًا على الملفات ، فإن تخزين الرسالة ينطوي على الكتابة إلى نظام الملفات. </font><font style="vertical-align: inherit;">إذا كان الأمر كذلك ، فلماذا أحتاج إلى تأكيد أن عملية الكتابة قد اكتملت؟ </font><font style="vertical-align: inherit;">هل فعل إتمام التسجيل يعني أن التسجيل قد حدث؟</font></font><br>  ليس حقا<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما يحدث عادة ، كلما زادت عمق دراستك لشيء ما ، أصبح الأمر أكثر تعقيدًا. </font><font style="vertical-align: inherit;">في هذه الحالة بالذات ، </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التخزين المؤقت</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو الجاني </font><font style="vertical-align: inherit;">.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مخابئ ، مخابئ في كل مكان </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما تقوم عملية نظام التشغيل ، مثل الوسيط ، بكتابة البيانات إلى القرص ، فإنها تتفاعل مع نظام الملفات. نظام الملفات هو عملية تلخص تفاصيل التفاعل مع وسيط التخزين المستخدم ، وتوفر واجهة برمجة تطبيقات لعمليات الملفات مثل OPEN و CLOSE و READ و WRITE. إحدى هذه الوظائف هي </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تقليل عدد عمليات الكتابة</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عن طريق تخزين البيانات المكتوبة بواسطة نظام التشغيل في كتل يمكن حفظها على القرص في نهج واحد. تتم كتابة عمليات كتابة نظام الملفات التي تبدو وكأنها تتفاعل مع الأقراص بالفعل إلى </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ذاكرة التخزين المؤقت</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هذه </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالمناسبة ، لهذا السبب يشتك جهاز الكمبيوتر الخاص بك عندما تقوم بإخراج محرك أقراص USB بطريقة غير آمنة - قد لا تكون الملفات التي قمت بنسخها مكتوبة بالفعل! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بمجرد أن تتجاوز البيانات ذاكرة التخزين المؤقت المخزن المؤقت ، ينتقل إلى المستوى التالي من التخزين المؤقت ، وهذه المرة على مستوى الجهاز - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ذاكرة التخزين المؤقت للتحكم في القرص</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . إنها مهمة بشكل خاص للأنظمة المستندة إلى RAID وتؤدي نفس الوظيفة مثل التخزين المؤقت على مستوى نظام التشغيل: تقليل عدد التفاعلات المطلوبة لمحركات الأقراص نفسها. تنقسم هذه ذاكرات التخزين المؤقت إلى فئتين: </font><font style="vertical-align: inherit;">يتم نقل عمليات </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الكتابة</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إلى القرص فور استلامها. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Writeback (كتابة خلفية)</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم إجراء التسجيل على الأقراص فقط عندما يصل المخزن المؤقت إلى قيمة عتبة معينة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن بسهولة فقدان البيانات المخزنة في هذه ذاكرات التخزين المؤقت أثناء انقطاع التيار الكهربائي ، لأن الذاكرة التي تستخدمها عادة ما تكون </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">متقلبة (متقلبة)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . تحتوي البطاقات الأكثر تكلفة على حزم بطارية احتياطية (BBUs) تدعم طاقة ذاكرة التخزين المؤقت حتى يتمكن النظام بأكمله من استعادة الطاقة ، وبعد ذلك ستتم كتابة البيانات على القرص. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مستوى ذاكرة التخزين المؤقت الأخير موجود على الأقراص نفسها. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مخابئ القرص</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تقع على محركات الأقراص الصلبة (سواء على محركات الأقراص الصلبة العادية أو على محركات الأقراص ذات الحالة الصلبة) ويمكن أن تكون إما كتابة أو كتابة خلفية. تستخدم معظم محركات الأقراص التجارية ذاكرة التخزين المؤقت للكتابة وهي متقلبة ، مما يعني مرة أخرى أنه قد يتم فقد البيانات في حالة انقطاع التيار الكهربائي.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند العودة إلى وسيط الرسائل ، يلزمك إكمال خطوة التأكيد للتأكد من أن البيانات قد وصلت بالفعل إلى القرص. لسوء الحظ ، فإن التفاعل مع هذه المخازن المؤقتة للأجهزة يعتمد على نظام الملفات ، لذلك كل ما يمكن أن تفعله عملية مثل ActiveMQ هو إرسال إشارة إلى نظام الملفات بأنها تريد مزامنة جميع المخازن المؤقتة للنظام مع الجهاز قيد الاستخدام. للقيام بذلك ، يقوم الوسيط باستدعاء طريقة java.io.FileDescriptor.sync () ، والتي بدورها تبدأ عملية POSIX fsync ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعد سلوك المزامنة هذا أحد متطلبات JMS للتأكد من أن جميع الرسائل المميزة بأنها ثابتة يتم حفظها فعليًا على القرص وبالتالي يتم تنفيذها بعد تلقي كل رسالة أو مجموعة من الرسائل ذات الصلة في معاملة ما. </font><font style="vertical-align: inherit;">لذلك ، تعد السرعة التي يمكن أن ينفذ بها القرص التزامن () أمرًا بالغ الأهمية لأداء الوسيط.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الصراعات الداخلية </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استخدام سجل واحد لجميع قوائم الانتظار يضيف تعقيدًا إضافيًا. في أي وقت ، قد يكون هناك العديد من المنتجين يرسلون الرسائل في وقت واحد. لدى الوسيط العديد من التدفقات التي تتلقى هذه الرسائل من المقابس الواردة. يجب أن يحفظ كل مؤشر ترابط رسالته إلى السجل. لأن العديد من المواضيع لا يمكن الكتابة إلى نفس الملف في نفس الوقت ، لأن تتعارض السجلات مع بعضها البعض ، ثم يجب وضع السجلات في قائمة الانتظار باستخدام آلية الاستبعاد المتبادل. نحن نسمي هذا </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الصراع موضوع</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب تسجيل وتزامن كل رسالة بشكل كامل قبل معالجة الرسالة التالية. يؤثر هذا التقييد على جميع قوائم الانتظار في الوسيط في نفس الوقت. وبالتالي ، فإن سرعة سرعة تلقي الرسالة هي الوقت الذي تستغرقه الكتابة على القرص ، بالإضافة إلى أي وقت انتظار لتنتهي التدفقات الأخرى من التسجيل. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يشتمل ActiveMQ على مخزن مؤقت للكتابة ، حيث تكتب تدفقات الاستلام رسائلها ، في انتظار اكتمال التسجيل السابق. ثم يتم كتابة المخزن المؤقت في إجراء واحد عندما تصبح الرسالة متوفرة. عند الانتهاء ، يتم إخطار المواضيع. وبالتالي ، يزيد الوسيط من استخدام عرض النطاق الترددي للتخزين.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتقليل تأثير تعارض مؤشرات الترابط ، يمكن تعيين مجموعات قوائم الانتظار الخاصة بهم سجلات باستخدام محول mKahaDB. </font><font style="vertical-align: inherit;">يقلل هذا النهج من زمن انتقال الكتابة ، لأنه في أي لحظة من المرجح أن تكتب مؤشرات الترابط على سجلات مختلفة ولن تحتاج إلى التنافس مع بعضها البعض للوصول الحصري إلى ملف سجل واحد.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المعاملات </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ميزة استخدام مجلة واحدة لجميع قوائم الانتظار ، أنه من وجهة نظر مؤلفي الوسيط ، من الأسهل بكثير تنفيذ المعاملات. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعونا نلقي نظرة على مثال حيث يتم إرسال العديد من الرسائل من قبل المنتج إلى عدة قوائم انتظار. استخدام معاملة يعني أن مجموعة الرسائل بالكامل المراد إرسالها يجب اعتبارها عملية ذرية واحدة. في هذا التفاعل ، تكون مكتبة عملاء ActiveMQ قادرة على إجراء بعض التحسينات التي ستزيد بشكل كبير من سرعة الإرسال. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في العملية المبينة في </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشكل 2-4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، يرسل المنتج ثلاث رسائل ، كل ذلك في طوابير مختلفة. </font><font style="vertical-align: inherit;">بدلاً من التفاعل المعتاد مع الوسيط ، عندما يتم تأكيد كل رسالة ، يرسل العميل الرسائل الثلاث جميعها بشكل غير متزامن ، أي دون انتظار الرد. </font><font style="vertical-align: inherit;">يتم تخزين هذه الرسائل في ذاكرة الوسيط. </font><font style="vertical-align: inherit;">بمجرد اكتمال العملية ، يقوم المنتج بإبلاغ جلساته بالحاجة إلى الالتزام ، الأمر الذي يجبر الوسيط بدوره على أداء سجل واحد كبير من خلال عملية تزامن واحدة. </font></font><br><br><img src="https://habrastorage.org/webt/i0/gl/tu/i0gltuz_gqybny3uyjrtpiot5bg.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشكل 2-4. </font><font style="vertical-align: inherit;">إرسال الرسائل في المعاملات</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في هذا النوع من العمليات ، يستخدم ActiveMQ تحسينين لزيادة السرعة:</font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يمكن إزالة وقت الانتظار قبل إرسال المنتج القادم </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الجمع بين العديد من عمليات القرص الصغيرة في واحدة كبيرة - وهذا يتيح لك استخدام عرض النطاق الترددي الكامل للحافلة القرص </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إذا قارنا هذا بالموقف عندما يتم تخزين كل قائمة انتظار في سجلها الخاص ، فسيتعين على الوسيط تقديم شيء مثل تنسيق المعاملات بين جميع السجلات. </font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> طرح الرسائل من قائمة الانتظار </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تبدأ عملية قراءة الرسائل عندما يعرب المستهلك عن استعداده لقبولها إما عن طريق إعداد MessageListener لمعالجة الرسائل فور وصولها ، أو عن طريق استدعاء الأسلوب MessageConsumer.receive () ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشكل 2-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/webt/eh/p7/-2/ehp7-2hesg0xjd1h4ynnqr46gqo.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشكل 2-5. قراءة الرسائل من خلال JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عندما يصبح ActiveMQ على علم بمستهلك ، فإنه (ActiveMQ) يقرأ (الصفحات) صفحة الرسائل حسب الصفحة من التخزين إلى ذاكرة التوزيع (1). ثم يتم إعادة توجيه هذه الرسائل (إرسالها) إلى المحاسب (2) ، غالبًا في عدة أجزاء لتقليل مقدار تفاعل الشبكة. يقوم الوسيط بتتبع الرسائل التي تمت إعادة توجيهها والمستهلك. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا تتم معالجة الرسائل التي يستلمها المستهلك على الفور بواسطة التطبيق ، ولكن يتم وضعها في منطقة الذاكرة المعروفة باسم</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عازلة الجلب المسبق (عازلة الجلب المسبق)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . الغرض من هذا المخزن المؤقت هو تبسيط تدفق الرسائل بحيث يمكن للوسيط إصدار رسائل إلى المشرف عند توفرها للإرسال ، بينما يمكن للمستهلك استلامها بشكل منظم ، واحدة تلو الأخرى. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في مرحلة ما بعد الدخول في مخزن الجلب المسبق ، تتم قراءة الرسائل بواسطة منطق التطبيق (X) ويتم إرسال تأكيد التدقيق إلى الوسيط (3). تم تكوين توقيت الوقت بين معالجة الرسائل والتأكيد باستخدام معلمة جلسة JMS تسمى </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وضع الإقرار</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، والتي سنناقشها لاحقًا.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بمجرد أن يقبل الوسيط تأكيد تسليم الرسالة ، يتم حذفه من الذاكرة ومن مخزن الرسائل (4). مصطلح "الحذف" مضلل إلى حد ما ، لأنه في الواقع يتم كتابة سجل تأكيد للمجلة ويزيد المؤشر في الفهرس. سيتم تنفيذ الحذف الفعلي لملف السجل الذي يحتوي على الرسالة بواسطة أداة تجميع مجمعي البيانات المهملة في مؤشر ترابط الخلفية استنادًا إلى هذه المعلومات.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">السلوك الموصوف أعلاه هو تبسيط لتسهيل الفهم. </font><font style="vertical-align: inherit;">في الواقع ، لا يكتفي ActiveMQ فقط بقراءة الصفحات بصفحة من البيانات ، بل يستخدم بدلاً من ذلك آلية المؤشر بين الأجزاء المستقبلة وإعادة التوجيه للوسيط لتقليل التفاعل مع مستودع الوسيط كلما أمكن ذلك. </font><font style="vertical-align: inherit;">ترقيم الصفحات ، كما هو موضح أعلاه ، هو أحد الأساليب المستخدمة في هذه الآلية. </font><font style="vertical-align: inherit;">يمكن عرض المؤشرات على أنها ذاكرة تخزين مؤقت على مستوى التطبيق يجب أن تظل متزامنة مع مستودع الوسيط. </font><font style="vertical-align: inherit;">يعد بروتوكول التماسك المستخدم جزءًا مهمًا مما يجعل آلية إرسال ActiveMQ أكثر تعقيدًا من آلية Kafka الموضحة في الفصل التالي.</font></font><br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وسائط التأكيد والمعاملة </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يكون لأوضاع التأكيد المختلفة ، التي تحدد الترتيب بين التدقيق اللغوي والتأكيد ، تأثير كبير على المنطق الذي يجب تنفيذه في العميل. وهي كالتالي: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AUTO_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هذا هو الوضع الأكثر استخدامًا ، ربما لأنه يحتوي على كلمة AUTO. يفرض هذا الوضع على مكتبة العميل الإقرار بالرسالة في نفس الوقت الذي تتم فيه قراءة الرسالة بواسطة مكالمة الاستلام (). هذا يعني أنه إذا كان منطق العمل الذي بدأته الرسالة يطرح استثناءً ، فسيتم فقد الرسالة لأنه تم حذفها بالفعل من قبل الوسيط. إذا تمت قراءة الرسالة من خلال المستمع ، فسيتم تأكيد الرسالة فقط بعد أن ينهي المستمع العمل بنجاح. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLIENT_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيتم إرسال تأكيد فقط عندما يقوم رمز العميل باستدعاء أسلوب Message.acknowledge () بشكل صريح. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DUPS_OK_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هنا سيتم </font><b><font style="vertical-align: inherit;">تخزين</font></b><font style="vertical-align: inherit;"> التأكيدات في المستهلك قبل إرسالها في وقت واحد من أجل تقليل مقدار حركة مرور الشبكة. ومع ذلك ، إذا تم إيقاف تشغيل نظام العميل ، فستفقد التأكيدات ، وستتم إعادة إرسال الرسائل ومعالجتها مرة أخرى. لذلك ، يجب أن تأخذ التعليمات البرمجية في الاعتبار احتمال تكرار الرسائل.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تستكمل أوضاع التأكيد بأدوات قراءة المعاملات. </font><font style="vertical-align: inherit;">عند إنشاء جلسة ، يمكن وضع علامة على أنها معاملات. </font><font style="vertical-align: inherit;">هذا يعني أنه يجب على المبرمج استدعاء Session.commit () أو Session.rollback () بشكل صريح. </font><font style="vertical-align: inherit;">على جانب المستهلك ، توسع المعاملات نطاق التفاعلات التي يمكن أن يقوم بها الكود كعملية ذرية واحدة. </font><font style="vertical-align: inherit;">على سبيل المثال ، يمكنك قراءة رسائل متعددة ومعالجتها ككل ، أو طرح رسالة من قائمة انتظار واحدة ، ثم إرسالها إلى أخرى باستخدام كائن الجلسة نفسه.</font></font><br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إيفاد والعديد من المستهلكين </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد ناقشنا حتى الآن سلوك قراءة الرسائل مع مستهلك واحد. دعونا الآن نلقي نظرة على كيفية تطبيق هذا النموذج على العديد من المستهلكين. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما يشترك العديد من المستهلكين في قائمة الانتظار ، فإن السلوك الافتراضي للوسيط هو إرسال رسائل مستديرة إلى أولئك المستهلكين الذين لديهم مكان في المخازن المؤقتة للجلب المسبق. سيتم إرسال الرسائل بالترتيب الذي وصلوا به في قائمة الانتظار - وهذا هو ضمان FIFO الوحيد المقدم (أولاً في ، أولاً ، أولاً في ، أولاً). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما يغلق المستهلك فجأة ، فإن كل الرسائل المرسلة إليه ، ولكن لم يتم تأكيدها بعد ، ستكون مستاءة إلى عميل آخر متاح.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يثير هذا سؤالًا مهمًا: حتى في حالة استخدام معاملات المستهلكين ، لا يوجد ضمان بعدم معالجة الرسالة عدة مرات. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النظر في منطق المعالجة التالية داخل المستهلك:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم طرح الرسالة من قائمة الانتظار. </font><font style="vertical-align: inherit;">تبدأ المعاملة.</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يتم استدعاء خدمة الويب مع محتويات الرسالة. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المعاملة ملتزمة. </font><font style="vertical-align: inherit;">يتم إرسال تأكيد إلى الوسيط.</font></font></li></ol><br>  إذا اكتمل العميل بين الخطوتين 2 و 3 ، فقد أثر التدقيق اللغوي للرسالة بالفعل على نظام آخر عن طريق الاتصال بخدمة الويب.  مكالمات خدمة الويب هي طلبات HTTP ، وبالتالي فهي ليست معاملات. <br><br>  هذا السلوك صحيح بالنسبة لجميع أنظمة قائمة الانتظار - حتى لو كانت المعاملات ، فإنها لا تضمن أنه لن يكون هناك أي آثار جانبية عند معالجة الرسائل فيها.  بعد فحص معالجة الرسائل بالتفصيل ، يمكننا أن نقول بثقة ما يلي: <br><br>  <i>لا يوجد شيء مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تسليم الرسائل مرة واحدة فقط</a> .</i> <br><br>  توفر قوائم الانتظار ضمانًا للتسليم <i>مرة واحدة على الأقل ،</i> ويجب أن تراعي الأجزاء الحساسة من الكود دائمًا إمكانية تلقي الرسائل المتكررة.  سنناقش لاحقًا كيف يمكن لعميل المراسلة استخدام القراءة العاطفية لتتبع الرسائل التي تم عرضها بالفعل وتجنب التكرارات. <br><br><h4 style=";text-align:right;direction:rtl">  ترتيب الرسائل </h4><br>  بالنسبة لمجموعة من الرسائل التي تصل بترتيب [A ، B ، C ، D] ، وبالنسبة للمستهلكين C1 و C2 ، سيكون التوزيع الطبيعي للرسائل على النحو التالي: <br><br> <code>C1: [A, C] <br> C2: [B, D]</code> <br>  نظرًا لأن الوسيط لا يتحكم في تشغيل عمليات القراءة وأن ترتيب المعالجة متوازي ، فهو غير حاسم.  إذا كانت C1 أبطأ من C2 ، فيمكن معالجة المجموعة الأولى من الرسائل كـ [B ، D ، A ، C]. <br><br>  قد يفاجئ هذا السلوك المبتدئين الذين يتوقعون معالجة الرسائل بالترتيب ، وعلى هذا الأساس ، يقومون بتطوير تطبيق المراسلة الخاص بهم.  يعد اشتراط معالجة الرسائل المرسلة من قبل المرسل نفسه بالترتيب بالنسبة لبعضها البعض ، والمعروف أيضًا بالترتيب <i>السببي</i> ، أمر شائع جدًا. <br><br>  خذ حالة الاستخدام التالية المأخوذة من المراهنة عبر الإنترنت كمثال: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تم تكوين حساب المستخدم. </li><li style=";text-align:right;direction:rtl">  يتم إضافة الأموال إلى الحساب. </li><li style=";text-align:right;direction:rtl">  يتم المراهنة على سحب الأموال من الحساب. </li></ol><br>  من المنطقي هنا معالجة الرسائل بالترتيب الذي تم إرسالها به ، بحيث تؤخذ الحالة العامة للحساب في الاعتبار.  يمكن أن تحدث أشياء غريبة إذا حاول النظام إزالة الأموال من حساب ليس لديه أموال.  هناك ، بالطبع ، طرق للتغلب على هذا. <br><br>  يتضمن نموذج <i>العميل الحصري</i> إرسال جميع الرسائل من قائمة الانتظار إلى عميل واحد.  باستخدام هذا النهج ، عند توصيل مثيلات متعددة للتطبيقات أو <code>my.queue?consumer.exclusive=true</code> الانتظار ، يتم توقيعها باستخدام معلمة مستلم خاص: <code>my.queue?consumer.exclusive=true</code> .  عند توصيل مستهلك احتكار ، يتلقى جميع الرسائل.  عندما يكون المستهلك الثاني متصلاً ، لن يتلقى أي رسائل حتى يتم قطع اتصال العميل الأول.  هذا المستهلك الثاني هو في الواقع احتياطي ساخن ، في حين سيتلقى المستهلك الأول الآن رسائل بالضبط بالترتيب الذي تم تسجيله به في المجلة - بترتيب سببي. <br>  أما عيب هذا الأسلوب فهو أنه على الرغم من أن معالجة الرسائل متسقة ، إلا أنها تمثل اختناقًا في الأداء نظرًا لأن جميع الرسائل يجب معالجتها بواسطة جهاز compurator واحد. <br><br>  لفهم حالة الاستخدام هذه بشكل أكثر ذكاءً ، تحتاج إلى إعادة النظر في المشكلة.  هل يجب معالجة جميع الرسائل بالترتيب؟  في حالة معالجة عروض الأسعار الموضحة أعلاه ، من الضروري معالجة الرسائل ذات الصلة بحساب واحد بالتتابع فقط.  يوفر ActiveMQ آلية للتعامل مع هذا الموقف يسمى <i>مجموعات رسائل JMS</i> . <br><br>  مجموعات الرسائل هي نوع من آليات التقسيم التي تسمح للمنتجين بتوزيع الرسائل في مجموعات ستتم معالجتها بالتسلسل وفقًا لمفتاح العمل.  يتم تعيين مفتاح العمل هذا في خاصية رسالة تسمى <code>JMSXGroupID</code> . <br><br>  سيكون المفتاح الطبيعي في حالة معالجة العطاءات هو معرف الحساب. <br>  لتوضيح كيفية عمل الإرسال ، ضع في اعتبارك مجموعة من الرسائل التي تصل بالترتيب التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[(A, Group1), (B, Group1), (C, Group2), (D, Group3), (E, Group2)]</code> </pre> <br>  عندما تتم معالجة رسالة بواسطة آلية الإرسال في ActiveMQ <code>JMSXGroupID</code> لم تكن موجودة من قبل ، يتم تعيين هذا المفتاح للمستهلك على أساس دوري.  من الآن فصاعدًا ، سيتم إرسال جميع الرسائل بهذا المفتاح إلى هذا المحاسب. <br><br>  سيتم تعيين المجموعات هنا بين مستهلكين: C1 و C2 ، على النحو التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">C1: [Group1, Group3] C2: [Group2]</code> </pre> <br>  سيتم إعادة توجيه الرسائل ومعالجتها على النحو التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">C2: [B, D] C2: [(C, Group2), (E, Group2)]</code> </pre> <br>  إذا تعطل المستهلك ، فسيتم إعادة توزيع جميع المجموعات المخصصة له على بقية المستهلكين وسيتم إعادة توجيه أي رسائل غير مؤكدة مرة أخرى.  لذلك ، على الرغم من أنه يمكننا ضمان معالجة جميع الرسائل ذات الصلة بالترتيب ، لا يمكننا الادعاء بأنها ستتم معالجتها بواسطة نفس المستهلك. <br><br><h3 style=";text-align:right;direction:rtl">  عالية التوفر </h3><br>  يوفر ActiveMQ توفرًا عاليًا مع السيد والعبد استنادًا إلى التخزين المشترك.  في هذا المخطط ، يتم تكوين اثنين أو أكثر من الوسطاء (على الرغم من اثنين عادة) على خوادم منفصلة ، ويتم تخزين رسائلهم في متجر رسائل يقع في مكان خارجي.  لا يمكن استخدام مخزن الرسائل في وقت واحد من خلال العديد من مثيلات الوسيط ، وبالتالي فإن وظيفته (المخزن) الثانوي هي بمثابة آلية حظر لتحديد الوسيط الذي سيحصل على وصول حصري ( <a href="">الشكل 2-6</a> ). <br><br><img src="https://habrastorage.org/webt/bn/yn/d5/bnynd5kctkhlomy5nb7-gmckrws.png"><br>  <i>الشكل 2-6.</i>  <i>الوسيط A هو الرائد ؛ الوسيط B في وضع الاستعداد كعبد</i> <br><br>  للاتصال بالمستودع ، يتولى الوسيط الأول (الوسيط A) دور القائد ويفتح منافذه لحركة مرور الرسائل.  عندما يتصل الوسيط الثاني (Broker B) بالمستودع ، يحاول الحصول على قفل ، ولأنه لم ينجح ، يتوقف لفترة قصيرة قبل محاولة الحصول على القفل مرة أخرى.  وهذا ما يسمى الاحتواء مدفوعة. <br><br>  في الوقت نفسه ، يقوم العميل بالتبديل بين عناوين الوسيطين في محاولة للاتصال بالمنفذ الوارد ، المعروف باسم موصل النقل.  بمجرد توفر الوسيط الرئيسي ، يتصل العميل بمنفذه ويمكنه إرسال الرسائل وقراءتها. <br>  عندما يفشل الوسيط A ، الذي يتصرف كقائد ، بسبب فشل العملية ( <a href="">الشكل 2-7</a> ) ، تحدث الأحداث التالية: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  العميل قطع الاتصال ويحاول على الفور إعادة الاتصال ، بالتناوب على عناوين اثنين من الوسطاء. </li><li style=";text-align:right;direction:rtl">  يتم تحرير القفل في الرسالة.  توقيت هذا يعتمد على تنفيذ التخزين. </li><li style=";text-align:right;direction:rtl">  الوسيط B ، الذي كان في وضع الرقيق ، يحاول بشكل دوري الحصول على قفل ، ينجح أخيرًا ويتولى دور السيد ، ويفتح منافذه. </li><li style=";text-align:right;direction:rtl">  يتصل العميل بالوسيط B ويواصل عمله. </li></ol><br><img src="https://habrastorage.org/webt/ks/wi/yd/kswiydyc5bffutft06ck-1sm4zq.png"><br>  <i>الشكل 2-7.</i>  <i>ينتهي الوسيط A بفقد الاتصال بالمستودع.</i>  <i>وسيط B يأخذ زمام المبادرة</i> <br><blockquote style=";text-align:right;direction:rtl">  لا يتم ضمان منطق التناوب بين عدة عناوين وسيط في مكتبة العميل ، كما هو الحال في تطبيقات JMS / NMS / CMS.  إذا كانت المكتبة توفر فقط إعادة الاتصال بعنوان واحد ، فقد تحتاج إلى وضع اثنين من الوسطاء وراء موازن التحميل ، والذي يجب أن يكون متاحًا أيضًا بدرجة كبيرة. </blockquote>  العيب الرئيسي لهذا النهج هو أنه لتبسيط عمل وسيط منطقي واحد ، هناك حاجة إلى عدة خوادم فعلية.  في هذه الحالة ، يكون أحد خادمي الوسيط خاملاً ، في انتظار انقطاع شريكه قبل أن يبدأ العمل. <br><br>  يحتوي هذا النهج أيضًا على التعقيد الإضافي الذي يجب أن يكون الوصول إليه من قبل التخزين الوسيط المستخدم ، سواء كان نظام ملفات شبكة مشترك أو قاعدة بيانات.  هذا يؤدي إلى تكاليف إضافية للمعدات وإدارة إعدادات الوسيط.  في هذا السيناريو ، من المغري إعادة استخدام مستودعات التخزين عالية التوافر الحالية التي تستخدمها أجزاء أخرى من البنية التحتية ، مثل قاعدة البيانات ، ولكن هذا خطأ. <br><br>  من المهم أن تتذكر أن القرص هو المحدد الرئيسي للأداء العام للوسيط.  إذا تم استخدام القرص نفسه في وقت واحد من خلال عملية أخرى غير وسيط الرسائل ، فإن تفاعل هذه العملية مع القرص ربما يؤدي إلى إبطاء التسجيل من الوسيط ، وبالتالي السرعة التي يمكن أن تمر بها الرسائل عبر النظام.  يصعب تشخيص مثل هذا التباطؤ والسبيل الوحيد من حولهم هو فصل العمليتين في أحجام تخزين مختلفة. <br><br>  لضمان التشغيل المستقر للوسيط ، يلزم تخزين مخصص وحصري. <br><br><h3 style=";text-align:right;direction:rtl">  التحجيم الرأسي والأفقي </h3><br>  في مرحلة ما من عمر المشروع ، قد تواجه قيودًا على أداء وسيط الرسائل.  تتعلق هذه القيود عادةً بالموارد ، ولا سيما تفاعلات ActiveMQ مع وحدة التخزين المستخدمة.  تنشأ هذه المشكلات عادةً بسبب تعارض حجم الرسائل أو النطاق الترددي بين المستلمين ، على سبيل المثال ، عندما تطفو قائمة انتظار واحدة على الوسيط خلال فترات الذروة. <br><br>  هناك عدة طرق للحصول على أداء أكثر من البنية التحتية للوسيط: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا تستخدم الثبات إن لم يكن مطلوبًا.  تسمح بعض سيناريوهات الاستخدام بفقدان الرسائل أثناء الأعطال ، خاصة عندما يرسل نظام ما حالة لقطة كاملة أخرى إلى الآخر من خلال قائمة الانتظار ، إما بشكل دوري أو عند الطلب. </li><li style=";text-align:right;direction:rtl">  تشغيل وسيط على محركات أسرع.  في الظروف الحقيقية ، لوحظت اختلافات كبيرة في عرض النطاق الترددي للتسجيل بين الأقراص الصلبة القياسية والبدائل المستندة إلى الذاكرة. </li><li style=";text-align:right;direction:rtl">  الاستفادة القصوى من أحجام القرص.  كما هو موضح في نموذج تفاعل خط أنابيب القرص الموصوف أعلاه ، يمكن تحقيق إنتاجية أعلى باستخدام المعاملات لإرسال مجموعات من الرسائل ، وبذلك يتم دمج عدة عمليات كتابة في واحدة أكبر. </li><li style=";text-align:right;direction:rtl">  استخدام تقسيم حركة المرور.  يمكنك تحقيق إنتاجية أعلى من خلال تقسيم الوجهات بإحدى الطرق التالية: </li></ul><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  عدة أقراص داخل وسيط واحد ، على سبيل المثال ، باستخدام محول الثبات mKahaDB للعديد من الدلائل ، كل منها مثبت على قرص منفصل. </li><li style=";text-align:right;direction:rtl">  يتم تنفيذ العديد من الوسطاء وتقسيم حركة المرور يدويًا بواسطة تطبيق العميل.  لا يوفر ActiveMQ أي وظائف أصلية لهذا الغرض. </li></ol><br>  أحد الأسباب الأكثر شيوعًا لمشاكل أداء الوسيط هو مجرد محاولة لفعل الكثير باستخدام مثيل واحد.  كقاعدة عامة ، يحدث هذا في الحالات التي ينقسم فيها الوسيط بسذاجة بين العديد من التطبيقات دون مراعاة الحمل الحالي على الوسيط أو فهم وحدات التخزين.  بمرور الوقت ، يتم تحميل وسيط واحد أكثر وأكثر حتى يتوقف عن التصرف بشكل مناسب. <br><br>  تنشأ المشكلة غالبًا أثناء مرحلة تصميم النظام ، عندما يستطيع مهندس النظام اقتراح مثل هذا المخطط كما في <a href="">الشكل 2-8</a> . <br><br><img src="https://habrastorage.org/webt/86/2g/9m/862g9malnlxd6k8ryettpya_dwu.png"><br>  <i>الشكل 2-8.</i>  <i>عرض مفاهيمي للبنية التحتية للرسائل</i> <br><br>  الهدف هو أن تتواصل تطبيقات متعددة مع بعضها البعض بشكل غير متزامن من خلال ActiveMQ.  لم يعد الهدف محددًا ، ثم يحدد المخطط أساس تكوين الوسيط الحقيقي.  هذا النهج يسمى خط البيانات العالمي. <br><br>  لا يأخذ في الاعتبار الخطوة الأساسية للتحليل بين التصميم المفاهيمي المذكور أعلاه والتنفيذ الفعلي.  قبل الشروع في إنشاء تكوين محدد ، من الضروري إجراء تحليل ، والذي سيتم استخدامه بعد ذلك لتبرير المشروع الفعلي.  الخطوة الأولى في هذه العملية هي تحديد الأنظمة التي تتفاعل مع بعضها البعض - رسم تخطيطي بسيط إلى حد ما مع المستطيلات والسهام ( <a href="">الشكل 2-9</a> ). <br><br><img src="https://habrastorage.org/webt/v_/wz/cz/v_wzczik2oi-menqrxjenakhs1e.png"><br>  <i>الشكل 2-9.</i>  <i>تدفقات رسالة الرسم بين الأنظمة</i> <br><br>  بعد موافقتها ، يمكنك الذهاب إلى التفاصيل للإجابة على الأسئلة التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  كم عدد قوائم الانتظار والمواضيع التي سيتم استخدامها؟ </li><li style=";text-align:right;direction:rtl">  ما هي وحدات تخزين الرسائل المتوقعة لكل منها؟ </li><li style=";text-align:right;direction:rtl">  ما حجم الرسائل في كل مستلم؟  يمكن أن تسبب الرسائل الكبيرة مشكلات في عملية الترحيل ، مما يؤدي إلى تجاوز حدود الذاكرة ومنع الوسيط. </li><li style=";text-align:right;direction:rtl">  هل ستكون تدفقات الرسالة موحدة طوال اليوم أم ستكون هناك طفرات بسبب وظائف الدُفعات؟  دفعات كبيرة في قائمة انتظار أقل استخدامًا يمكن أن تتداخل مع عمليات كتابة القرص في الوقت المناسب للوجهات عالية الأداء. </li><li style=";text-align:right;direction:rtl">  هل الأنظمة في نفس مركز البيانات أم مختلفة؟  الاتصال عن بعد ينطوي على نوع من وسطاء الشبكة. </li></ul><br>  تتمثل الفكرة في تحديد سيناريوهات منفصلة للمراسلة يمكن دمجها أو تقسيمها بواسطة وسطاء فرديين ( <a href="">الشكل 2-10</a> ). <br>  بعد هذا الانهيار ، يمكن محاكاة سيناريوهات الاستخدام من خلال الجمع مع بعضها البعض باستخدام وحدة الأداء ActiveMQ لتحديد أي مشاكل. <br><br><img src="https://habrastorage.org/webt/nj/im/ry/njimryyhatcjfwhprygsdrrzqwc.png"><br>  <i>الشكل 2-10.</i>  <i>تحديد الوسطاء الفرديين</i> <br><br>  بعد تحديد العدد المناسب من الوسطاء المنطقيين ، يمكنك تحديد كيفية تنفيذها على المستوى الفعلي باستخدام تكوينات يمكن الوصول إليها بشكل كبير وشبكات الوسيط. <br><br><h3 style=";text-align:right;direction:rtl">  النتائج </h3><br>  في هذا الفصل ، درسنا الآلية التي يستقبل بها ActiveMQ الرسائل ويوزعها.  ناقشنا الميزات التي تدعمها هذه البنية ، بما في ذلك موازنة التحميل اللصقة للرسائل والمعاملات ذات الصلة.  في الوقت نفسه ، قدمنا ​​مجموعة من المفاهيم الشائعة لجميع أنظمة المراسلة ، بما في ذلك بروتوكولات الاتصال والمجلات.  لقد درسنا أيضًا بالتفصيل الصعوبات التي تنطوي عليها الكتابة إلى القرص وكيف يمكن للوسطاء استخدام تقنيات مثل كتابة الرزم لتحسين الأداء.  أخيرًا ، قمنا بفحص كيفية جعل ActiveMQ متاحًا بشكل كبير وكيفية توسيعه إلى أبعد من قدرات وسيط فردي. <br><br>  في الفصل التالي ، سننظر في Apache Kafka وكيف يعيد تصميم هندستها إلى تفسير العلاقة بين العملاء والوسطاء لتوفير خط أنابيب للرسائل قوي بشكل لا يصدق مع عرض نطاق ترددي أكبر بكثير من وسيط الرسائل العادي.  سنناقش الوظيفة التي يستخدمها لتحقيق هذا الهدف ، وسننظر باختصار في بنية التطبيقات التي توفر هذه الوظيفة. <br><br>  الجزء التالي: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فهم وسطاء الرسائل.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تعلم آليات المراسلة من خلال ActiveMQ و Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الفصل 3. كافكا</a> <br><br>  <b>اكتملت الترجمة: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">tele.gg/middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar471268/">https://habr.com/ru/post/ar471268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar471258/index.html">نظام تخزين / تحميل البيانات</a></li>
<li><a href="../ar471260/index.html">Kali Linux NetHunter على Android الجزء 2: الهجمات على الشبكات اللاسلكية</a></li>
<li><a href="../ar471262/index.html">Holivar. تاريخ Runet. الجزء 5. المتصيدون: تعلم ، طابعة محمومة ، والنحاس</a></li>
<li><a href="../ar471264/index.html">اختيار بديل لـ Mailchimp: لماذا التبديل وأي منتج للاختيار</a></li>
<li><a href="../ar471266/index.html">المستقبل هنا أو مشفر مباشرة في المتصفح</a></li>
<li><a href="../ar471270/index.html">نقوم تلقائيًا باستلام البيانات الخاصة بسرعة تحميل موقع من Google PageSpeed ​​Insights [template]</a></li>
<li><a href="../ar471272/index.html">فوائد الكتابة القوية في C ++: تجربة عملية</a></li>
<li><a href="../ar471278/index.html">جيل النص باللغة الروسية عن طريق القوالب</a></li>
<li><a href="../ar471282/index.html">البحث عن الالتهاب الرئوي في الأشعة السينية مع Fast.ai</a></li>
<li><a href="../ar471288/index.html">إنشاء وجه شخصية للعبة "OnAir"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>