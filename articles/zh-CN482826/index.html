<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔧 🤞 😋 解析1997年存档中的128字节演示 👩‍👦‍👦 👴🏿 🦃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="满足我的愿望是非常愉快的，尤其是从遥远的过去开始，如此遥远，以至于我已经忘记了曾经想要的。 我对这个场景不了解，当然也从来没有跟随作者或他们的作品，我只是喜欢看发生了什么。 有时我想弄清楚，但是后来我缺乏知识和经验，后来又没有毅力，然后我对此完全失去了兴趣。 但是最近，我当时与我们一起学习，并向我们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>解析1997年存档中的128字节演示</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/">满足我的愿望是非常愉快的，尤其是从遥远的过去开始，如此遥远，以至于我已经忘记了曾经想要的。 我对这个场景不了解，当然也从来没有跟随作者或他们的作品，我只是喜欢看发生了什么。 有时我想弄清楚，但是后来我缺乏知识和经验，后来又没有毅力，然后我对此完全失去了兴趣。 但是最近，我当时与我们一起学习，并向我们提供了BBS和Fidonet的所有新产品（包括演示）的朋友，因为他几乎几乎同时拥有电话，调制解调器和计算机，他带着自己的作品访问了<a href="https://cafeparty.org.ru/2019/" rel="nofollow">CAFePARTY</a> 。这使我打开了第一台计算机的存档，选择一个演示并弄清楚了。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br> 客观地评估自己的长处，我做了一个128字节的介绍，我从视觉上很喜欢。  <code>pentagra.com</code>文件由<b>Mcm</b>签名，为128个字节，最后修改时间为1996年9月24日18:10:14，十六进制转储： <br><br> <code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42 <br> 000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40 <br> 000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03 <br> 000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7 <br> 000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab <br> 000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88 <br> 000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c <br> 000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d <br></code> <a name="habracut"></a><br> 从同一档案中，我退出了： <br><br><ul><li>  <b>Hiew 6.11</b> （可在网站上找到<a href="http://www.hiew.ru/" rel="nofollow">6.50</a> ）-我将其用作反汇编程序 </li><li>  <b>TASM</b>软件包-我用它收集了收到的代码，以确保我不会弄乱任何东西 </li><li>  <b>Flambeaux软件的TECH帮助！</b>  <b>6.0-</b>针对DOS API，BIOS函数，硬件和汇编器的详细而全面的在线参考 </li><li>  <b>Mayko G.V.</b>  <b>IBM PC的汇编程序</b> -几乎是袖珍大小的格式参考，适用于所有基本的Intel 8086命令和程序文本格式设置规则。 没有架构细节，只有基本示例，只有最基本的东西。 这里几乎有您需要的所有东西，但是除了环境之外，您无法使用汇编器进行编写。 </li><li> 因此，第二本书<b>Zubkov S.V.</b>  <b>汇编器。</b>  <b>对于DOS，Windows和Unix-</b>硬件角落和DOS指南 </li></ul><br> 从最低限度的最小实现上，应该可以期待使用技巧和非标准方法，但是除了在初始条件下的一些假设之外，我没有看到任何技术技巧，但是我看到了一种算法技巧。 在这里，您应该对体验说几句话。 可能会有什么困难？ 在实现中或在算法中。 例如，在<code>mov di, 099d1h</code>命令<code>mov di, 099d1h</code> ，您可能会害怕魔术常数。 但是，如果您在使用环境中，很显然这是屏幕坐标X和Y上的访问地址，其中X = 17，Y = 123，320是屏幕的水平分辨率（以像素为单位）。 总之，这使我们获得了17 + 123 * 320，即二维坐标到一维的转换。 <br><br> 现在看一下屏幕上发生的事情，即使不是100％相似，即使不是100％相似，我也可以轻松想象如何实现它，但是我可以。 而20年前，尽管我从尘土飞扬的架子上拿出了所有使用过的工具，但我不必浏览互联网就可以了解它的工作原理。 因此，首先，这是一个上下文，是对正在发生的事情的理解，因此，技巧和操作方法的问题位于第二位。 <br><br> 我们看到的是： <br><br><ol><li> 五行五角星。 根据所有经典，这些不一定是不可分割的直线。 我们只看到一般数字，没有细节 </li><li> 火焰效果包括两个重要部分：正确选择的调色板和一种算法，该算法使用不确定性元素不断更改屏幕上点的颜色，但保持相邻点的连续调色板顺序。 例如，您可以通过平均上一个屏幕的相邻像素的值来计算整个当前屏幕，并在随机位置（或不在随机位置）添加更多的“亮”点，而在值上随机（或完全没有机会）添加更多“亮”点，只需远离线性顺序即可。 一种选择是<a href="https://habr.com/ru/post/435122/">如何在DOOM中完成</a> 。 结果应该是颜色相互渗透的形式，从不断出现的明亮区域到褪色 </li></ol><br> 有待了解如何完成此操作。 进一步的描述不会替代有关计算机体系结构和DOS或汇编器功能的知识，但是拥有此知识将使您能够理解并专注于正在发生的事情的本质。 开始写作后，我意识到事实足够详细，但我不能拒绝它，以免失去故事的意义。 <br><br><h3>  DOS和加载.COM程序 </h3><br>  <code>.com</code>文件中的程序是干净的代码，没有标题，只需将其放在正确的位置即可。 这就是DOS所做的，或者更确切地说是4Bh系统调用。 正在采取许多行动，让我们来谈谈结果： <br><br><ul><li> 所有段寄存器CS，DS，ES，SS均加载有单个值 </li><li>  65536字节为整个程序保留，正好是所有段寄存器指示的一个段。 前256个字节由系统头PSP（程序段前缀）占用。 在CS：0（PSP的第一个字段）处，找到INT 20h命令-结束当前程序并将控制权转移到父进程。 程序本身以CS：100h地址开头，并占用以下128个字节 </li><li> 字0000h被压入堆栈，SP寄存器为FFFEh。 这意味着该段中位于地址SS：FFFEh的最后两个字节被复位。 实际上，这是过程中最接近的返回地址，它将导致我们到达CS：0处的完成命令。 </li><li> 寄存器AL和AH包含一个错误标志，用于在调用程序时从第一个和第二个参数确定驱动器号。 如果没有错误，则它们为0，如果存在则FFh </li></ul><br> 我真诚地认为，在一般情况下，寄存器的状态没有定义。 但是在我看来，在所分析的代码中，对它们的初始状态做出了非常大胆的假设，尤其是关于CX，SI寄存器和DF方向标志。 我在上面产生的源列表中没有找到对此的确认，因此我去浏览了<a href="" rel="nofollow">MS-DOS 2.0</a>源： <br><br><ul><li> 关于DF，我们可以假定它已由<code>cld</code>命令重置，因为后者在将控制权转移到换行之前使用正向，因此DF被重置。 尽管此位置没有明确使用<code>cld</code> ，但是在进行许多其他传输之前，经常会遇到清除方向标志的命令 </li><li>  SI包含100h，因为它用于确定IP命令计数器将加载到寄存器中的偏移量 </li><li>  CX等于FFh，因为它用作初始值80h的计数器，用于传输整个命令行的内容，因此，在传输之后它为0。此后，CL作为临时变量加载FFh，并用于在AL和AH中设置驱动器号的错误标志 </li></ul><br> 没有较新版本的来源，但有<a href="https://sourceforge.net/projects/dosbox/files/dosbox/" rel="nofollow">DOSBox来源</a> ： <br><br><pre> <code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number"><span class="hljs-number">0</span></span>;reg_cx=<span class="hljs-number"><span class="hljs-number">0xff</span></span>; reg_dx=pspseg; reg_si=RealOff(csip); reg_di=RealOff(sssp);</code> </pre><br> 也就是说，它与我在MS-DOS源代码（第二版！）中看到的一致，您可以看到其他寄存器的初始值，这是一个显式的特殊初始化。 对于MS-DOS，除AX，段和堆栈以外的寄存器的值都是将它们用于其他目的的基本条件；这不是教条或标准，因此，在任何地方都没有提及。 但是，另一方面，已经形成的生态系统以及Microsoft在支持与旧版本的兼容性上的全部痛苦（迫使他们拖延所有随机生成的值）变得有点可理解了，因为程序员非常习惯于它们。 <br><br> 最后，对于我们来说，这些知识已足够，我们开始从头文件恢复程序： <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup</code> </pre><br> 我们确定处理器80186的类型，因为我们使用了仅在此模型中出现的<code>outsb</code>命令。 一个代码段和一个程序入口点，再加上<code>tiny</code>内存模型的定义，将使编译器能够正确计算变量和转换的所有偏移量。 构建<code>tlink</code> ，将使用<code>/t</code> <code>tlink</code> ；在输出上将提供一个<code>.com</code>文件。 <br><br><h3> 图形和调色板 </h3><br> 要切换到图形模式，您需要转到BIOS函数，为此将中断10h，AH = 0，在AL中，我们将所需模式的标识符-13h放入： <br><br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h ;b0 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br> 请注意，根据程序加载条件，假设零为零，我们不会触摸AH。 所选模式对应于具有256色调色板的320 x 200像素的图形分辨率。 要在屏幕上显示一个点，您需要写入存储区，该存储区以地址A000h：0（与颜色相对应的字节）开头。 用以下值填充段数据寄存器： <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h ;<span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> a0 pop es ;<span class="hljs-number"><span class="hljs-number">07</span></span> push es ;<span class="hljs-number"><span class="hljs-number">06</span></span> pop ds ;<span class="hljs-number"><span class="hljs-number">1f</span></span></code> </pre><br> 从逻辑上讲，内存被组织为一个二维数组，在其中显示屏幕坐标，0：0对应于左上角。 切换模式后，将以零填充-默认调色板中为黑色。 转换为线性位移的公式为<b>X + Y * L</b> ，其中L是水平分辨率，在我们的情况下为320。在这种形式下，我将在使用常量的地方编写代码，在转换程序文本时它们会自动计算出来。 <br><br> 要更改调色板，我们可以使用输入/输出端口直接访问设备： <br><br><pre> <code class="cpp hljs">lodsb ;ac mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h ;ba c8 <span class="hljs-number"><span class="hljs-number">03</span></span> out dx, al ;ee</code> </pre><br> 第一条命令将位于DS：SI的数据字节加载到AL中。 在DS中，我们已经加载了视频内存的段地址，并且在SI中我们知道它用零填充-在通常情况下，我们不知道至少为0。无论SI指示在哪里，我们几乎都可以进入占用的视频内存分辨率为320 * 200 = 64000字节，几乎是整个段。 因此，我们希望在此命令之后AL = 0。 对SI加上或减去一个单位，取决于DF方向标志的设置。 尽管这对我们来说也不是特别重要，但是无论SI移到哪里，我们仍然保留在填充有零的视频存储区域中。 <br><br> 接下来，使用端口号03C8h加载DX，该输出将确定我们将要覆盖的256种颜色。 在我们的情况下，AL为0。 <br><br> 颜色是在RGB调色板中编码的，为此，您应该连续三次写入端口03C9h（大于3C8h），每个组件一次。 组件的最大亮度为63，最小为0。 <br><br><pre> <code class="cpp hljs">inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">64</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">40</span></span> PALETTE: out dx, al ;ee inc ax ;<span class="hljs-number"><span class="hljs-number">40</span></span> outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e loop PALETTE ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">,    6  </span></span></code> </pre><br> 将DX增加1，使其具有所需的端口号。  CL是我们的周期计数器64，我们假设CH = 0，如先前基于初始加载条件所述。 接下来，我们将第一个组件输出到端口-红色的组件，其亮度将存储在AL中，就是我们将在第一步0中对其进行更改。在此之后，我们将其亮度增加一个，以在下一次迭代中显示。 接下来，我们执行两个写入端口的<code>outsb</code>命令<code>outsb</code>该端口号包含在DS内存区中的字节DX中：SI，请记住，那里有零。  SI每次更改一个。 <br><br> 一旦推断出这三个成分，就会自动将一个单位添加到色号中。 因此，如果颜色是连续的，则不必根据需要输出到3C8h端口来重新定义颜色。  <code>loop</code>命令将CX减一，如果获得非零值，它将转到循环的开始，如果为0，则转到循环后的下一个命令。 <br><br> 总共64次重复。 在每次重复中，我们确定从0到63的颜色的红色分量，其亮度与当前色号一致。 我们重置绿色和蓝色分量，以获得从最小到最大红色亮度的调色板： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="示意图"></div><br><br><h3> 线数 </h3><br> 设置初始颜色和坐标值： <br><br><pre> <code class="cpp hljs">LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh ;b8 <span class="hljs-number"><span class="hljs-number">3f</span></span> <span class="hljs-number"><span class="hljs-number">3f</span></span> mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span></code> </pre><br> 在AL和AH中，我们分别加载最大可能的（最亮的）颜色63（3Fh），AX一次定义了两个点。  BX-最大水平分辨率。 将来，它将用于从当前坐标中添加或减去一行。  DI-坐标64：4，将它们保存在堆栈中。 <br><br>  <b>从左上角到右端画第一行</b> ： <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE1: stosw ;ab add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE1 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br> 配置计数器-这将是行数。 接下来，将AX中的字（两个字节）保存到地址ES：DI。 此操作将在屏幕上以调色板中的最大颜色显示两个点，因为ES已配置为用于视频内存，并且已在DI中设置了特定坐标。 执行此操作后，由于写入了两个字节，因此将2添加到DI。 显然，我们没有设置DF方向标志，而是依靠将其重置的事实，因此我们再次回顾了加载程序的初始条件。 否则，两者将被带走，这将不允许绘制所需的线。 <br><br> 接下来，DI = DI + BX，相当于将Y坐标增加一。 因此，在循环的主体中，在一条直线上绘制了两个点，X坐标增加了2，Y坐标增加了1，此动作重复了120次，结果图像稍低。 <br><br>  <b>第二行是从左上方到顶部</b> ： <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">60</span></span> LINE2: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE2 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br> 我们将初始坐标恢复为64：4，并将计数器设置为96次重复。 我们打印一个点，但是在当前坐标下打印一行。 和以前一样，这是通过从BX添加一个值来实现的，只是不保存新坐标。 结构<code>[bx+di]</code>或<code>[bx][di]</code>被称为带有索引的基址，并且在处理器级别而不是在翻译器上工作。  BX的默认段寄存器是DS。 之后，我们显示第二个点，但是已经在当前坐标中。  DI，因此X增加1，因为仅使用了一个字节传输命令<code>stosb</code> 。 循环主体的最后两个命令是将Y增加2，为此我们再次使用BX。 <br><br> 绘制两条线后，在左上角附近获得以下图像： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="1,2行"></div><br><br> 视频存储器中行偏移地址的左坐标和右坐标。 点64：4将被绘制两次。 <br><br>  <b>第三行是从顶部到右上角</b> ： <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">61</span></span> LINE3: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb loop LINE3 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  DI已经包含所需的坐标值160：196，我们需要从上一行的顶部开始绘制一条线，在保持相同角度的情况下向上移动屏幕。 因此，周期几乎相同。  CX增加1，因为当前的Y坐标比上一行结束的位置多2（低），因此已经为下一次迭代计算了它。 因此，要移到上角，您需要采取额外的步骤。 沿X的移动沿相同方向继续-每次迭代后加一个，沿Y的移动而不是相加，而是减去两个。 点的显示顺序相同，先低后高。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="3号线"></div><br><br>  <b>第四行是从最左边到右上角：</b> <br><br><pre> <code class="cpp hljs">mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf d1 <span class="hljs-number"><span class="hljs-number">99</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE4: stosw ;ab sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb(<span class="hljs-number"><span class="hljs-number">-5</span></span>) loop LINE4</code> </pre><br> 我们再次处于必需的坐标中，但是显然不使用该坐标，以便不更改DF方向标志。 因此，新坐标将放置在DI中并存储在堆栈中。 <br><br> 此外，一切都与第一行相同，只有Y坐标不会增加，但会减小，然后上升。 <br><br>  <b>第五行是水平的：</b> <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">8f</span></span> rep stosw ;f3 ab</code> </pre><br> 这里的一切都很简单，使用了微处理器重传机制，因为水平线对应于每个下一个点地址的简单增加。 在DI中，恢复上一步中存储的与左极角坐标对应的地址。 设置CX中的重复次数，并使用单词传输命令应用重复前缀。 <br><br> 完成此操作后，我们将绘制出一个最亮的五角星。 使用了80个字节，保留了48个字节。 <br><br><h3> 火魔法 </h3><br>  <b>我们为计算设置边界条件：</b> <br><br><pre> <code class="cpp hljs">FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> ;<span class="hljs-number"><span class="hljs-number">81</span></span> fe <span class="hljs-number"><span class="hljs-number">00</span></span> fa jae NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> lodsb ;ac <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al ;<span class="hljs-number"><span class="hljs-number">0</span></span>a c0 jz NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>d</code> </pre><br> 在SI中，将有当前点的坐标进行计算，如果我们超出了屏幕的边界，则我们不会对该点进行任何计算，而是继续计算下一个。 <br><br>  <code>lodsb</code>将DS：SI区域中的一个字节加载到AL中，即当前坐标中点的颜色。 如果它是0，那么我们也什么也不做，继续进行到下一点。 <br><br>  <b>新颜色计算</b> <br><br> 这是更改屏幕上的颜色值的主要算法，这不是火焰，这是它的基础。 我们计算相邻点并实现颜色连续性： <br><br><pre> <code class="cpp hljs">dec ax ;<span class="hljs-number"><span class="hljs-number">48</span></span> mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> fe mov [si], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> ff mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> bf fe</code> </pre><br> 从AX减去实际上从AL减去一个包含从当前坐标获得的非零颜色值的单位。 接下来，我们基于调色板将获得的值写入相对于当前坐标的所有相邻点，即它们的一小部分。 <br><br> 由于在<code>lodsb</code>之后，SI值增加了一个且不再对应于我们在AL中读取其颜色的点，因此必须对其进行调整。 请注意，不再使用<code>stosb</code>字节传输命令；而是使用<code>mov</code>来精确定位将要放置值的地址。 如果我们接受当前坐标为X：Y，对于它们来说为SI-1，则： <br><br><ul><li>  <code>mov [si-2], al</code>在当前颜色左侧的X-1：Y点记录新颜色。 由于上述原因，从SI中减去2，因为已经向其中添加了一个额外的单位 </li><li>  <code>mov [si], al</code>在当前颜色右边的X + 1：Y处记录新颜色。  SI已经有X +1 </li><li>  <code>mov [bx+si-1], al</code>向当前点下方的点X：Y + 1写入新颜色。 再次将BX用作Y + 1 </li><li>  <code>mov [si-1-1*320], al</code>在当前颜色上方的点X：Y-1处写入新颜色。 我们将无法使用BX，因为我们需要删除坐标，处理器架构不允许我们以这种形式执行此操作，因此根据坐标缩减公式使用了一个常数 </li></ul><br> 段寄存器是DS，默认情况下与SI和BX一起使用。 <br><br> 当该点到达屏幕边缘时，不会检查任何情况。 这不会导致失败，因为我们将始终处于视频片段的边界之内。 从进一步的说明中可以看出，相邻点可以落入地址大于64,000的未报告区域中，也可以落入相邻行中，这对我们无害，甚至无济于事。 <br><br>  <b>一样的魔法，计算下一点的坐标</b> <br><br><pre> <code class="cpp hljs">NEXT_PIXEL: add si, dx ;<span class="hljs-number"><span class="hljs-number">03</span></span> f2 inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> jnz FLAME ;<span class="hljs-number"><span class="hljs-number">75</span></span> e3(<span class="hljs-number"><span class="hljs-number">-29</span></span>)</code> </pre><br> 让我们回头看看，我们没有在任何地方专门设置初始SI值，在DX中，我们仍然有用于调色板的输出输入端口号。 我们仅执行三个简单的动作SI = SI + DX，显然这将设置新的坐标，哪个坐标？  DX = DX + 1，并且如果DX不等于0，那么回到获取和计算相邻点的基本算法，即DX是某种计数器吗？ <br><br> 我们知道我们需要遍历所有点并计算其邻居的亮度变化。 如果您连续执行此操作，那么我们可能会得到一个静态渐变，也许不是很均匀，但是在我们的行周围没有变化。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们知道屏幕的大小以及需要绕开多少个点，但是在这里我们几乎忽略了它，而是选择收盘价65536而不是精确的64000。DX实际上是一个计数器，仅为65536。但是为什么其初始值并不重要，为什么我们采用最终值是否大于屏幕上的总点数？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为我们绕过的点不是连续的，也不是全部。每个后续线性坐标比上一个线性坐标大DX的值。也就是说，在SI中，简单算术级数的DX元素的总和：0、1、2、3、4、5、6，...，362,363，...，65535。这已经给我们非线性了，如果您从SI = 0和DX = 0开始，那么在SI中，我们得到：0,1,3,4,6,10,15,21，...，65341,65703，...， 2147450880。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但这还不是全部，因为SI尺寸为16位，我们不能获得大于65535的值，会发生溢出，并且SI中的余数保持为65536模。线性坐标计算公式的格式为SI =（SI + DX）MOD 65536，它完全破坏了连续顺序：0,1,3,4,6,10,15,21，...，65341,167,530,894，... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们回想起SI并没有以任何方式初始化，也就是说，下次我们返回该循环时那么我们将从停止的坐标开始，而不是从0或给定的某个坐标开始。这将给我们的序列增加混乱-延长非重复元素的数量。否则，这些点的遍历将始终是相同的，尽管是非线性的。会有火焰效果，但不是很清楚。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们谈论把戏，那仅此而已。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于第一次溢出，DX总是隐式地从0开始，除非是第一次使用</font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的边界值会增加一些混乱，因为对于SI&gt; = 64000，将不会绘制任何点，并且输出序列会有些混乱。跳过所有零值点会在程序的前几秒钟产生点火效果。这是因为整个循环结束得更快，因为大多数点都没有处理。但最重要的是，由于大多数点的亮度只会增加，因此它们不会被相邻的调光器部分所遮盖-它们根本不存在，并且不会计算零值。在完全黑色的区域消失后，就建立了平衡，某些区域将增加亮度，而某些区域将减少。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们再也无法谈论任何顺序或梯度，每次都以新的顺序分配点，包括重复几次或完全跳过。</font><font style="vertical-align: inherit;">这导致形成彼此混合的不同亮度的区域，并在每次新的迭代中改变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但这还不是全部，如果您不添加新的亮点，那么最终它们将全部还清。</font><font style="vertical-align: inherit;">因此，在DX达到最大值之后，我们再次绘制五条亮线，并再次计算屏幕上的所有点：</font></font><br><br><pre> <code class="cpp hljs">in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h ;e4 <span class="hljs-number"><span class="hljs-number">60</span></span> cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h ;<span class="hljs-number"><span class="hljs-number">3</span></span>c <span class="hljs-number"><span class="hljs-number">01</span></span> jne LINES ;<span class="hljs-number"><span class="hljs-number">75</span></span> a5(<span class="hljs-number"><span class="hljs-number">-91</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但在此之前，我们从端口60h读取，这是键盘，是最后按下的键的扫描代码。</font><font style="vertical-align: inherit;">对于ESC等于1。如果是，则按ESC键，我们向出口移动。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完成时间 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得注意的是，在更新当前屏幕时（这会花费一些时间），您无法退出程序，也就是说，对ESC的反应将会延迟。如果在等待过程中以及按ESC键后，我们仍然保留在程序中，则只能从端口读取最后的扫描代码。还有一件事，我们不为此替换或使用DOS和BIOS系统功能，无论我们从端口读取什么，按下的键都放在循环缓冲区中，并且在介绍完成后很可能由下一个程序从该缓冲区中读取该文件，很可能是文件经理或</font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这将导致其处理，例如，ESC上的Volkov Commander将隐藏其面板。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回文本模式3：</font></font><br><br><pre> <code class="cpp hljs">mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h ;b8 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假定我们在程序启动之前就处于这种模式，但是在一般情况下可能并非如此。</font><font style="vertical-align: inherit;">在这里，我们更新整个AX，因为我们确定AH不包含0。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在您可以退出：</font></font><br><br><pre> <code class="cpp hljs">retn ;c3</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个过程的近出口命令，该过程从堆栈中获取放置在那里的字的值（两个字节）并将其装入IP命令计数器。</font><font style="vertical-align: inherit;">根据初始条件，我们在堆栈中有零，这将导致我们到达CS：0地址，即我们所知道的命令代码所在的位置</font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-关闭。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有7个字节的版权：</font></font><br><br><pre> <code class="cpp hljs">dd <span class="hljs-number"><span class="hljs-number">0</span></span>h ;<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> ;<span class="hljs-number"><span class="hljs-number">4</span></span>d <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>d end</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以说，我还有地方要进行更严格的初始化，但是由于一切都可以在现代DOSBox中运行，因此作者可能所做的一切都正确。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们再经历一次：</font></font><br><br><ol><li>    ,        </li><li>  4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,          </li><li>       SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         — <code>add si, dx</code>  <code>inc dx</code> ,            ,       </li><li>     ESC  ,           </li></ol><br><div class="spoiler"> <b class="spoiler_title">  .</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h pop es push es pop ds lodsb mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h out dx, al inc dx mov cl, <span class="hljs-number"><span class="hljs-number">040</span></span>h PALETTE: out dx, al inc ax outsb outsb loop PALETTE LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE1: stosw add di, bx loop LINE1 pop di mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> LINE2: mov [bx+di], al stosb add di, bx add di, bx loop LINE2 mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> LINE3: mov [bx+di], al stosb sub di, bx sub di, bx loop LINE3 mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE4: stosw sub di, bx loop LINE4 pop di mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> rep stosw FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> jae NEXT_PIXEL lodsb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al jz NEXT_PIXEL dec ax mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al mov [si], al mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al NEXT_PIXEL: add si, dx inc dx jnz FLAME in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h jne LINES mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h retn dd <span class="hljs-number"><span class="hljs-number">0</span></span>h db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> end</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要进行编译，您必须执行：</font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不知道您是否清楚该如何实施以及如何实施，但在我看来似乎是采用了一种美丽而又不寻常的方法来产生火焰效果。</font><font style="vertical-align: inherit;">尽管我没有什么可比的，但也许每个人都可以做到，现在您可以做同样的事情。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482826/">https://habr.com/ru/post/zh-CN482826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482814/index.html">树的一般视图，不仅实现而且</a></li>
<li><a href="../zh-CN482816/index.html">Arthur Khachuyan：市场营销中的人工智能</a></li>
<li><a href="../zh-CN482818/index.html">阅读有关Infostart 2019的1C DSS报告的简要结果</a></li>
<li><a href="../zh-CN482820/index.html">图片上传优化</a></li>
<li><a href="../zh-CN482822/index.html">游戏的美术测试如何进行</a></li>
<li><a href="../zh-CN482832/index.html">物理学家的未来经济学</a></li>
<li><a href="../zh-CN482834/index.html">静态类型不一定需要仪式</a></li>
<li><a href="../zh-CN482838/index.html">ONYX BOOX Note 2评估-具有最大功能的大屏幕阅读器</a></li>
<li><a href="../zh-CN482840/index.html">UTorrent连续2次点击下载</a></li>
<li><a href="../zh-CN482842/index.html">Mash是一种可自行编译的编程语言</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>