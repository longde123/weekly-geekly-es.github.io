<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöº üìÅ ‚õπüèø Ausf√ºhren von Programmen mit nur einer Datei in Java 11 ohne Kompilierung üñãÔ∏è üå§Ô∏è ü§≥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie die Quelldatei HelloUniverse.java eine Klassendefinition und eine statische Hauptmethode enthalten, die eine einzelne Textzeile an das Term...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ausf√ºhren von Programmen mit nur einer Datei in Java 11 ohne Kompilierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/483888/"><img src="https://habrastorage.org/webt/mr/ie/ii/mrieiilbpca6armxtc_yym5nqc0.jpeg"><br><br>  Lassen Sie die Quelldatei HelloUniverse.java eine Klassendefinition und eine statische Hauptmethode enthalten, die eine einzelne Textzeile an das Terminal ausgibt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello InfoQ Universe"</span></span>); } }</code> </pre> <br>  Um diese Klasse auszuf√ºhren, m√ºssen Sie sie normalerweise zuerst mit dem Java-Compiler (javac) kompilieren, der die Datei HelloUniverse.class erstellt: <br><br><pre> <code class="java hljs">mohamed_taman$ javac HelloUniverse.java</code> </pre> <br>  Anschlie√üend m√ºssen Sie die resultierende Datei mit dem Java Virtual Machine-Befehl (Interpreter) ausf√ºhren: <br><br><pre> <code class="java hljs">mohamed_taman$ java HelloUniverse Hello InfoQ Universe</code> </pre> <br>  Dann startet zuerst die Virtualka, die die Klasse l√§dt und den Code ausf√ºhrt. <br><br>  Und wenn Sie schnell einen Code √ºberpr√ºfen m√ºssen?  Oder sind Sie neu in Java ( <i>in diesem Fall ein wichtiger Punkt</i> ) und m√∂chten mit der Sprache experimentieren?  Die beiden beschriebenen Schritte k√∂nnen die Dinge komplizieren. <br><br>  In Java SE 11 k√∂nnen Sie einzelne Quelldateien ohne Zwischenkompilierung direkt ausf√ºhren. <br><a name="habracut"></a><br>  Diese Funktion ist besonders n√ºtzlich f√ºr Anf√§nger, die mit einfachen Programmen arbeiten m√∂chten.  In Kombination mit jshell erhalten Sie eine Reihe gro√üartiger Tools f√ºr die Ausbildung von Anf√§ngern. <br><br>  Profis k√∂nnen mit diesen Tools Neuerungen in der Sprache erlernen oder unbekannte APIs testen.  Unserer Meinung nach ist es besser, viele Aufgaben zu automatisieren, z. B. das Schreiben von Java-Programmen in Form von Skripten mit anschlie√üender Ausf√ºhrung √ºber die OS-Shell.  Dadurch k√∂nnen wir flexibel mit Shell-Skripten arbeiten und alle Funktionen von Java nutzen.  Lassen Sie uns im zweiten Teil des Artikels n√§her darauf eingehen. <br><br>  Mit dieser gro√üartigen Funktion von Java 11 k√∂nnen Sie eine einzelne Quelldatei direkt ausf√ºhren, ohne sie kompilieren zu m√ºssen.  Lass uns diskutieren. <br><br><h3>  Was brauchst du </h3><br>  Zum Ausf√ºhren des im Artikel bereitgestellten Codes ben√∂tigen Sie eine Java-Version von mindestens 11. Zum Zeitpunkt des Schreibens war die aktuelle Version Java SE Development Kit 12.0.1. Die endg√ºltige Version ist <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">hier</a> . Akzeptieren Sie einfach die Lizenzbedingungen und klicken Sie auf den Link f√ºr Ihr Betriebssystem.  Wenn Sie mit den neuesten Funktionen experimentieren m√∂chten, k√∂nnen Sie JDK 13 Early Access <a href="https://jdk.java.net/13/">herunterladen</a> . <br><br>  Bitte beachten Sie, dass jetzt auch Releases verschiedener OpenJDK-Anbieter verf√ºgbar sind, einschlie√ülich <a href="https://adoptopenjdk.net/">AdoptOpenJDK</a> . <br><br>  In diesem Artikel verwenden wir anstelle der Java-IDE einen Nur-Text-Editor, um den Zauber der IDE zu umgehen, und verwenden die Java-Befehlszeile direkt im Terminal. <br><br><h2>  F√ºhren Sie .java mit Java aus </h2><br>  Die <a href="https://openjdk.java.net/jeps/330">JEP 330-</a> Funktion (Ausf√ºhren von Einzeldateiprogrammen mit Quellcode) ist in JDK 11 erschienen. Mit ihr k√∂nnen Sie Quelldateien mit Java-Quellcode direkt ausf√ºhren, ohne einen Interpreter zu verwenden.  Der Quellcode wird im Speicher kompiliert und dann vom Interpreter ausgef√ºhrt, ohne dass eine .class-Datei auf der Festplatte erstellt wird. <br><br>  Diese Funktion ist jedoch auf Code beschr√§nkt, der in einer einzelnen Datei gespeichert ist.  Sie k√∂nnen nicht mehrere Quelldateien gleichzeitig ausf√ºhren. <br><br>  Um diese Einschr√§nkung zu umgehen, m√ºssen alle Klassen in einer einzigen Datei definiert werden.  Ihre Anzahl unterliegt keinen Beschr√§nkungen.  Au√üerdem spielt es keine Rolle, ob sie √∂ffentlich oder privat sind, w√§hrend sie sich in derselben Datei befinden. <br><br>  Die erste in der Datei definierte Klasse wird als die Hauptklasse betrachtet, und die Hauptmethode muss darin platziert werden.  Ordnung ist also wichtig. <br><br><h3>  Erstes Beispiel </h3><br>  Beginnen wir mit dem klassisch einfachsten Beispiel - Hallo Universum! <br><br>  Wir werden das beschriebene Feature anhand verschiedener Beispiele demonstrieren, damit Sie einen Eindruck davon bekommen, wie es in der t√§glichen Programmierung eingesetzt werden kann. <br><br>  Erstellen Sie eine HelloUniverse.java-Datei mit dem Code vom Anfang des Artikels, kompilieren Sie die resultierende Klassendatei und f√ºhren Sie sie aus.  Dann l√∂schen Sie es, jetzt werden Sie verstehen, warum: <br><br><pre> <code class="java hljs">mohamed_taman$ rm HelloUniverse.class</code> </pre> <br>  Wenn Sie jetzt den Java-Interpreter verwenden, f√ºhren Sie die Klassendatei ohne Kompilierung aus: <br><br><pre> <code class="java hljs">mohamed_taman$ java HelloUniverse.java Hello InfoQ Universe</code> </pre> <br>  Sie sehen das gleiche Ergebnis: Die Datei wird ausgef√ºhrt. <br><br>  Dies bedeutet, dass Sie jetzt nur <code>java HelloUniverse.java</code> ausf√ºhren <code>java HelloUniverse.java</code> .  Wir √ºbertragen den Quellcode selbst und nicht die Klassendatei: Das System in sich kompiliert ihn, startet und zeigt eine Meldung in der Konsole an. <br><br>  Das hei√üt, die Kompilierung wird immer noch unter der Haube durchgef√ºhrt.  Und im Falle ihres Fehlers werden wir dar√ºber benachrichtigt.  Sie k√∂nnen die Verzeichnisstruktur √ºberpr√ºfen und sicherstellen, dass die Klassendatei nicht generiert wird und die Kompilierung im Speicher ausgef√ºhrt wird. <br><br>  Nun wollen wir herausfinden, wie alles funktioniert. <br><br><h3>  Wie der Java-Interpreter das HelloUniverse-Programm ausf√ºhrt </h3><br>  In JDK 10 kann der Java-Launcher in drei Modi ausgef√ºhrt werden: <br><br><ol><li>  Ausf√ºhrung der Klassendatei. <br></li><li>  Ausf√ºhrung der Hauptklasse aus einer JAR-Datei. <br></li><li>  Ausf√ºhrung der Hauptklasse des Moduls. <br></li></ol><br>  Und in Java 11 erschien ein vierter Modus: <br><br><ol><li>  Ausf√ºhrung der in der Quelldatei deklarierten Klasse. <br></li></ol><br>  In diesem Modus wird die Quelldatei im Speicher kompiliert und anschlie√üend die erste Klasse aus dieser Datei ausgef√ºhrt. <br><br>  Das System bestimmt Ihre Absicht, die Quelldatei einzugeben, anhand von zwei Kriterien: <br><br><ol><li>  Das erste Element in der Befehlszeile ist weder eine Option noch Teil einer Option. <br></li><li>  Die Zeile kann die Option <code>--source &lt;vrsion&gt;</code> . <br></li></ol><br>  Im ersten Fall wird Java zuerst herausfinden, ob das erste Element des Befehls eine Option oder ein Teil davon ist.  Wenn dies ein Dateiname ist, der auf .java endet, betrachtet das System ihn als den Quellcode, der kompiliert und ausgef√ºhrt werden muss.  Sie k√∂nnen dem Java-Befehl auch Optionen vor dem Namen der Quelldatei hinzuf√ºgen.  <i>Zum Beispiel, wenn Sie den Klassenpfad festlegen m√∂chten, wenn die Quelldatei externe Abh√§ngigkeiten verwendet.</i> <br><br>  Im zweiten Fall wird der Modus zum Arbeiten mit der Quelldatei ausgew√§hlt und das erste Element in der Befehlszeile, das keine Option ist, wird als Quelldatei betrachtet, die kompiliert und ausgef√ºhrt werden muss. <br><br>  Wenn die Datei nicht die Erweiterung .java aufweist, m√ºssen Sie die Option <code>--source</code> , um den <code>--source</code> in den Arbeitsmodus mit der Quelldatei zu erzwingen. <br><br>  Dies ist in F√§llen wichtig, in denen die Quelldatei ein ‚ÄûSkript‚Äú ist, das ausgef√ºhrt werden muss, und der Dateiname nicht den √ºblichen Konventionen f√ºr die Benennung der Quelldateien mit Java-Code entspricht. <br><br>  Mit der Option <code>--source</code> k√∂nnen <code>--source</code> die Version der Quellsprache ermitteln.  Wir werden weiter unten darauf eingehen. <br><br><h3>  Kann ich in der Befehlszeile Argumente √ºbergeben? </h3><br>  Erweitern wir unser Hello Universe-Programm so, dass jedem Benutzer, der das InfoQ Universe besucht, eine pers√∂nliche Begr√º√üung angezeigt wird: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse2</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ System.err.println(<span class="hljs-string"><span class="hljs-string">"Name required"</span></span>); System.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; System.out.printf(<span class="hljs-string"><span class="hljs-string">"Hello, %s to InfoQ Universe!! %n"</span></span>, name); } }</code> </pre> <br>  Speichern Sie den Code in der Datei Greater.java.  Beachten Sie, dass der Dateiname nicht mit dem Namen der √∂ffentlichen Klasse √ºbereinstimmt.  Dies verst√∂√üt gegen die Regeln der Java-Spezifikation. <br><br>  F√ºhren Sie den Code aus: <br><br><pre> <code class="java hljs">mohamed_taman$ java Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello, Mo. Taman to InfoQ universe!!</code> </pre> <br>  Wie Sie sehen, spielt es keine Rolle, dass die Klassen- und Dateinamen nicht √ºbereinstimmen.  Ein aufmerksamer Leser kann auch feststellen, dass wir nach der Verarbeitung des Dateinamens Argumente an den Code √ºbergeben haben.  Dies bedeutet, dass alle Argumente in der Befehlszeile, die auf den Dateinamen folgen, an die Standard-Hauptmethode √ºbergeben werden. <br><br><h3>  Bestimmen Sie die Ebene des Quellcodes mit der Option --source </h3><br>  Es gibt zwei Szenarien f√ºr die Verwendung der Option <code>--source</code> : <br><br><ol><li>  Bestimmen der Ebene des Quellcodes. <br></li><li>  Java-Laufzeit in den Quellmodus versetzen. <br></li></ol><br>  Wenn Sie im ersten Fall die Quellcode-Ebene nicht angegeben haben, wird die aktuelle Version des JDK daf√ºr verwendet.  Im zweiten Fall k√∂nnen Dateien mit anderen Erweiterungen als .java direkt zum Kompilieren und Ausf√ºhren √ºbertragen werden. <br><br>  Schauen wir uns zuerst das zweite Szenario an.  Benennen Sie Greater.java einfach in Greater ohne Erweiterung um und versuchen Sie Folgendes auszuf√ºhren: <br><br><pre> <code class="java hljs">mohamed_taman$ java greater <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Error: Could not find or load main <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">greater</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Caused</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassNotFoundException</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">greater</span></span></span></span></code> </pre> <br>  In Abwesenheit der Erweiterung .java sucht der Befehlsinterpreter nach der kompilierten Klasse anhand des als Argument √ºbergebenen Namens. Dies ist die erste Betriebsart des Java-Launchers.  Um dies zu verhindern, verwenden Sie die Option <code>--source</code> , um den Wechsel in den Quelldateimodus zu erzwingen: <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">11</span></span> greater <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello, Mo. Taman to InfoQ universe!!</code> </pre> <br>  Fahren wir nun mit dem ersten Szenario fort.  Die Greater.java-Klasse ist mit JDK 10 kompatibel, da sie das Schl√ºsselwort <code>var</code> enth√§lt, jedoch nicht mit JDK 9 kompatibel ist. √Ñndern Sie die <code>source</code> in <code>10</code> : <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">10</span></span> Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello Mo. Taman to InfoQ universe!!</code> </pre> <br>  F√ºhren Sie den vorherigen Befehl erneut aus, aber √ºbergeben Sie diesmal <code>--source 9</code> anstelle von <code>10</code> : <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">9</span></span> Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Greater.java:<span class="hljs-number"><span class="hljs-number">8</span></span>: warning: as of release <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'var'</span></span> is a restricted local variable type and cannot be used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> type declarations or as the element type of an array <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ^ Greater.java:<span class="hljs-number"><span class="hljs-number">8</span></span>: error: cannot find symbol <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ^ symbol: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class"> 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">warning</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compilation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">failed</span></span></span></span></code> </pre> <br>  Hinweis: Der Compiler warnt, dass <code>var</code> in JDK 10 ein eingeschr√§nkter Typname geworden ist.  Da wir jedoch eine Sprache der Stufe 10 haben, wird die Kompilierung fortgesetzt.  Es kommt jedoch zu einem Absturz, da die Quelldatei keinen Typ namens <code>var</code> . <br><br>  Alles ist einfach.  Betrachten Sie nun die Verwendung mehrerer Klassen. <br><br><h3>  Funktioniert dieser Ansatz mit mehreren Klassen? </h3><br>  Ja, das tut es. <br><br>  Betrachten Sie ein Beispiel mit zwei Klassen.  Der Code √ºberpr√ºft, ob der angegebene Zeichenfolgenwert ein <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25BC">Palindrom ist</a> . <br><br>  Hier ist der Code, der in der Datei PalindromeChecker.java gespeichert ist: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PalindromeChecker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ err.println(<span class="hljs-string"><span class="hljs-string">"String is required!!"</span></span>); exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } out.printf(<span class="hljs-string"><span class="hljs-string">"The string {%s} is a Palindrome!! %b %n"</span></span>, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], StringUtils .isPalindrome(args[<span class="hljs-number"><span class="hljs-number">0</span></span>])); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPalindrome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String word)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(word)) .reverse() .toString() .equalsIgnoreCase(word); } }</code> </pre> <br>  F√ºhren Sie die Datei aus: <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java RediVidEr The string {RediVidEr} is a Palindrome!! True</code> </pre> <br>  F√ºhren Sie es erneut aus und ersetzen Sie "RaceCar" anstelle von "MadAm": <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java RaceCar The string {RaceCar} is a Palindrome!! True</code> </pre> <br>  Ersetze jetzt "Mohamed" anstelle von "RaceCar": <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java Taman The string {Taman} is a Palindrome!! <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  Wie Sie sehen, k√∂nnen Sie einer Quelldatei beliebig viele √∂ffentliche Klassen hinzuf√ºgen.  Stellen Sie sicher, dass zuerst die Hauptmethode definiert wird.  Der Interpreter verwendet die erste Klasse als Startpunkt f√ºr das Starten des Programms nach dem Kompilieren des Codes im Speicher. <br><br><h3>  Kann ich Module verwenden? </h3><br>  Ja, keine Grenzen.  Der speicherkompilierte Code wird als Teil eines unbenannten Moduls mit der <code>--add-modules=ALL-DEFAULT</code> , mit der auf alle mit dem JDK <code>--add-modules=ALL-DEFAULT</code> . <br><br>  Das hei√üt, der Code kann verschiedene Module verwenden, ohne dass Abh√§ngigkeiten explizit mit module-info.java definiert werden m√ºssen. <br><br>  Schauen wir uns den Code an, der einen HTTP-Aufruf mit der in JDK 11 eingef√ºhrten neuen HTTP-Client-API ausf√ºhrt. Beachten Sie, dass diese APIs in Java SE 9 als experimentelles Feature eingef√ºhrt wurden, aber jetzt den Status einer vollwertigen Funktion des Moduls java.net.http haben . <br><br>  In diesem Beispiel rufen wir eine einfache REST-API mit der GET-Methode auf, um eine Liste der Benutzer abzurufen.  Wir wenden uns an den √∂ffentlichen Dienst <a href="https://reqres.in/api/users%3Fpage%3D2">reqres.in/api/users?page=2</a> .  Wir speichern den Code in einer Datei namens UsersHttpClient.java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.http.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.http.HttpResponse.BodyHandlers; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersHttpClient</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = HttpClient.newBuilder().build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = HttpRequest.newBuilder() .GET() .uri(URI.create(<span class="hljs-string"><span class="hljs-string">"https://reqres.in/api/users?page=2"</span></span>)) .build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = client.send(request, BodyHandlers.ofString()); out.printf(<span class="hljs-string"><span class="hljs-string">"Response code is: %d %n"</span></span>,response.statusCode()); out.printf(<span class="hljs-string"><span class="hljs-string">"The response body is:%n %s %n"</span></span>, response.body()); } }</code> </pre> <br>  F√ºhren Sie das Programm aus und erhalten Sie das Ergebnis: <br><br><pre> <code class="java hljs">mohamed_taman:code$ java UsersHttpClient.java Response code is: <span class="hljs-number"><span class="hljs-number">200</span></span> The response body is: {<span class="hljs-string"><span class="hljs-string">"page"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">"per_page"</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-string"><span class="hljs-string">"total"</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-string"><span class="hljs-string">"total_pages"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"data"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Eve"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Holt"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg"</span></span>},{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Charles"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Morris"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/stephenmoon/128.jpg"</span></span>},{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Tracey"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Ramos"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/bigmancho/128.jpg"</span></span>}]}</code> </pre> <br>  Jetzt k√∂nnen Sie schnell neue Funktionen testen, die von verschiedenen Modulen bereitgestellt werden, ohne ein eigenes Modul erstellen zu m√ºssen. <br><br><h2>  Warum sind Skripte in Java wichtig? </h2><br>  Erinnern wir uns zun√§chst an die folgenden Skripte: <br><br><blockquote>  Ein Skript ist ein Programm, das f√ºr eine bestimmte Laufzeitumgebung geschrieben wurde und das die Ausf√ºhrung von Aufgaben oder Befehlen automatisiert, die eine Person nacheinander ausf√ºhren kann. </blockquote><br>  Aus dieser allgemeinen Definition k√∂nnen wir eine einfache Definition einer Skriptsprache ableiten - es ist eine Programmiersprache, die √ºbergeordnete Konstrukte verwendet, um einen Befehl (oder mehrere Befehle) zu interpretieren und auszuf√ºhren. <br><br>  Die Skriptsprache verwendet eine Reihe von Befehlen, die in einer Datei geschrieben sind.  Oft werden diese Sprachen interpretiert (anstatt kompiliert) und folgen einem prozeduralen Programmierstil (obwohl einige Skriptsprachen auch die Eigenschaften objektorientierter Sprachen haben). <br><br>  Im Allgemeinen sind Skriptsprachen leichter zu lernen und schneller einzugeben als strukturiertere kompilierte Sprachen wie Java, C und C ++.  Serverseitige Skriptsprachen umfassen Perl, PHP und Python sowie <i>clientseitig</i> JavaScript. <br><br>  Java galt lange Zeit als eine gut strukturierte, stark typisierte kompilierte Sprache, die von einer virtuellen Maschine interpretiert wird, um auf jeder Computerarchitektur ausgef√ºhrt zu werden.  Java ist jedoch im Vergleich zu anderen Skriptsprachen nicht so einfach zu erlernen und zu prototypisieren. <br><br>  Dennoch ist Java bereits 24 Jahre alt geworden und wird von rund 10 Millionen Entwicklern auf der ganzen Welt verwendet.  Neuere Versionen haben eine Reihe neuer Funktionen hinzugef√ºgt, um jungen Programmierern das Erlernen dieser Sprache zu erleichtern und die Funktionen der Sprache und der API ohne Kompilierung und IDE zu nutzen.  Beispielsweise f√ºhrte Java SE 9 das JShell-Tool (REPL) ein, das die interaktive Programmierung unterst√ºtzt. <br><br>  Mit der Ver√∂ffentlichung von JDK 11 wurde diese Sprache in die Lage versetzt, Skripte zu unterst√ºtzen, da Sie jetzt Code mit einem einfachen Aufruf des <code>java</code> Befehls ausf√ºhren k√∂nnen! <br><br>  Es gibt zwei M√∂glichkeiten, Skripte in Java 11 zu verwenden: <br><br><ol><li>  Direkter Aufruf des <code>java</code> Befehls. <br></li><li>  Verwenden von * nix-Skripten f√ºr die Befehlszeile, √§hnlich wie bei Bash-Skripten. <br></li></ol><br>  Wir haben bereits √ºber die erste Option nachgedacht, jetzt werden wir uns mit der zweiten befassen.  Das er√∂ffnet uns viele M√∂glichkeiten. <br><br><h3>  Shebang-Dateien: F√ºhren Sie Java als Shell-Skript aus </h3><br>  Daher wurde in Java SE 11 die Unterst√ºtzung f√ºr Skripte angezeigt, einschlie√ülich traditioneller Shebang-Dateien aus der * nix-Welt.  Um sie zu unterst√ºtzen, war keine Sprachspezifikation erforderlich. <br><br>  In der shebang-Datei m√ºssen die ersten beiden Bytes 0x23 und 0x21 sein.  Dies ist die ASCII-Zeichenkodierung #! .. Alle nachfolgenden Bytes in der Datei werden basierend auf dem Standardkodierungssystem auf dieser Plattform gelesen. <br><br>  Damit die Datei mit dem im Betriebssystem integrierten shebang-Mechanismus ausgef√ºhrt werden kann, gibt es nur eine Voraussetzung: Die erste Zeile beginnt mit #! .. Dies bedeutet, dass wir keine spezielle erste Zeile ben√∂tigen, wenn der Java-Launcher explizit verwendet wird um den Code aus der Quelldatei auszuf√ºhren, wie dies bei HelloUniverse.java der Fall ist. <br><br>  F√ºhren Sie das folgende Beispiel in einem Terminal aus, auf dem <i>macOS Mojave 10.14.5 ausgef√ºhrt wird</i> .  Aber zuerst definieren wir wichtige Regeln, die beim Erstellen einer shebang-Datei beachtet werden m√ºssen: <br><br><ul><li>  Mischen Sie Java-Code nicht mit dem Skriptsprachencode Ihres OS-Shell-Skripts. <br></li><li>  Wenn Sie Optionen f√ºr virtuelle Maschinen hinzuf√ºgen m√ºssen, m√ºssen Sie <code>--source</code> erste Option nach dem Namen der ausf√ºhrbaren Datei in der shebang-Datei angeben.  Zu den Optionen der virtuellen Maschine geh√∂ren: <code>--class-path</code> , <code>--module-path</code> , <code>--add-exports</code> , <code>--add-modules</code> , <code>--limit-modules</code> , <code>--patch-module</code> , <code>--upgrade-module-path</code> , sowie jegliche Variationen davon.  In dieser Liste ist auch die neue Option <code>--enable-preview</code> , die in <a href="https://openjdk.java.net/jeps/12">JEP 12 beschrieben wird</a> . <br></li><li>  Sie m√ºssen die Java-Version angeben, die in der Quelldatei verwendet wird. <br></li><li>  Die erste Zeile der Datei sollte mit Shebang-Zeichen (#!) Beginnen.  Zum Beispiel: <br> <code>#!/path/to/java --source &lt;vrsion&gt;</code> </li> <li>  Verwenden Sie f√ºr Java-Quelldateien NICHT den shebang-Mechanismus, um Dateien auszuf√ºhren, die der Standardbenennungskonvention entsprechen (endet in .java). <br></li><li>  Sie m√ºssen die Datei mit dem folgenden Befehl als ausf√ºhrbar markieren: <br>  <code>chmod +x &lt;Filname&gt;.&lt;Extnsion&gt;</code> . <br></li></ul><br>  Erstellen wir eine shebang-Datei (Skriptprogramm), die den Inhalt des Verzeichnisses auflistet, dessen Name als Parameter √ºbergeben wird.  Wenn keine Parameter √ºbergeben werden, wird standardm√§√üig das aktuelle Verzeichnis verwendet. <br><br><pre> <code class="java hljs">#!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryLister</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ vardirName = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ err.println(<span class="hljs-string"><span class="hljs-string">"Will list the current directory"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dirName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } Files .walk(Paths.get(dirName)) .forEach(out::println); } }</code> </pre> <br>  Speichern Sie den Code in einer Datei namens dirlist ohne die Erweiterung und markieren Sie ihn dann als ausf√ºhrbar: <code>mohamed_taman:code$ chmod +x dirlist</code> . <br><br>  F√ºhren Sie die Datei aus: <br><br><pre> <code class="java hljs">mohamed_taman:code$ ./dirlist Will list the current directory . ./PalindromeChecker.java ./greater ./UsersHttpClient.java ./HelloWorld.java ./Greater.java ./dirlist</code> </pre> <br>  F√ºhren Sie es erneut mit dem Befehl aus, der das √ºbergeordnete Verzeichnis √ºbergibt, und √ºberpr√ºfen Sie das Ergebnis. <br><br><pre> <code class="java hljs">mohamed_taman:code$ ./dirlist ../</code> </pre> <br>  Hinweis: Bei der Auswertung des Quellcodes ignoriert der Interpreter die Shebang-Zeile (erste Zeile).  So kann die shebang-Datei mit dem Launcher explizit aufgerufen werden, zum Beispiel mit zus√§tzlichen Optionen: <br><br><pre> <code class="java hljs">$ java -Dtrace=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> --source <span class="hljs-number"><span class="hljs-number">11</span></span> dirlist</code> </pre> <br>  Es ist auch zu beachten: Wenn sich die Skriptdatei im aktuellen Verzeichnis befindet, k√∂nnen Sie sie folgenderma√üen ausf√ºhren: <br><br><pre> <code class="java hljs">$ ./dirlist</code> </pre> <br>  Und wenn sich das Skript in einem Verzeichnis befindet, dessen Pfad im Benutzer PATH angegeben ist, k√∂nnen Sie es folgenderma√üen ausf√ºhren: <br><br><pre> <code class="java hljs">$ dirlist</code> </pre> <br>  Abschlie√üend gebe ich Ihnen einige Tipps, die Sie bei der Verwendung von Skripten ber√ºcksichtigen sollten. <br><br><h2>  Tipps </h2><br><ol><li>  Einige Optionen, die Sie an javac √ºbergeben, werden m√∂glicherweise nicht an <code>java</code> √ºbergeben (oder nicht erkannt), z. B. die Optionen <code>-Werror</code> oder <code>-Werror</code> . <br></li><li>  Befinden sich im Klassenpfad .class- und .java-Dateien, erzwingt der Launcher die Verwendung der Klassendatei. <br><br><pre> <code class="java hljs">mohamed_taman:code$ javac HelloUniverse.java mohamed_taman:code$ java HelloUniverse.java error: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">application</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse</span></span></span></span></code> </pre> <br></li><li>  Beachten Sie die M√∂glichkeit eines Konflikts zwischen Klassen- und Paketnamen.  Schauen Sie sich diese Verzeichnisstruktur an: <br><br><pre> <code class="java hljs">mohamed_taman:code$ tree . ‚îú‚îÄ‚îÄ Greater.java ‚îú‚îÄ‚îÄ HelloUniverse ‚îÇ ‚îú‚îÄ‚îÄ java.class ‚îÇ ‚îî‚îÄ‚îÄ java.java ‚îú‚îÄ‚îÄ HelloUniverse.java ‚îú‚îÄ‚îÄ PalindromeChecker.java ‚îú‚îÄ‚îÄ UsersHttpClient.java ‚îú‚îÄ‚îÄ dirlist ‚îî‚îÄ‚îÄ greater</code> </pre> <br>  Beachten Sie die beiden <code>java.java</code> im HelloUniverse-Paket und die HelloUniverse.java-Datei im selben Verzeichnis.  Wenn du versuchst zu rennen: <br><br><pre> <code class="java hljs">mohamed_taman:code$ java HelloUniverse.java</code> </pre> <br>  dann wird welche datei zuerst ausgef√ºhrt und welche zweite?  Der Launcher verweist nicht mehr auf die Klassendatei im HelloUniverse-Paket.  Stattdessen wird die urspr√ºngliche HelloUniverse.java-Datei geladen und ausgef√ºhrt, d. H. Die Datei wird im aktuellen Verzeichnis gestartet. <br></li></ol><br>  Shebang-Dateien er√∂ffnen eine Vielzahl von M√∂glichkeiten zur Erstellung von Skripten zur Automatisierung aller Arten von Aufgaben mit Java-Tools. <br><br><h2>  Zusammenfassung </h2><br>  Ab Java SE 11 und zum ersten Mal in der Programmiergeschichte k√∂nnen Sie Skripte mit Java-Code direkt ausf√ºhren, ohne sie zu kompilieren.  Auf diese Weise k√∂nnen Sie Java-Skripte schreiben und √ºber die * nix-Befehlszeile ausf√ºhren. <br><br>  Experimentieren Sie mit dieser Funktion und teilen Sie Ihr Wissen mit anderen. <br><br><h2>  N√ºtzliche Quellen </h2><br><ul><li>  <a href="https://openjdk.java.net/jeps/330">JEP 330: Starten von Single-File Source-Code-Programmen</a> <br></li><li>  <a href="https://openjdk.java.net/jeps/12">JEP 12: Vorschau der Sprach- und VM-Funktionen</a> <br></li><li>  <a href="https://docs.oracle.com/en/java/javase/11/">JDK 11-Dokumentation</a> <br></li><li>  <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">Java SE Development Kit 12.0.1</a> <br></li><li>  <a href="https://reqres.in/">Testen Sie Ihr Frontend gegen eine echte API</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483888/">https://habr.com/ru/post/de483888/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483874/index.html">Die Ver√∂ffentlichung des VVVVVV-Codes zeigte, wie unh√∂flich die Spiele sind</a></li>
<li><a href="../de483876/index.html">Rote Unternehmenskultur ist das Hauptproblem des russischen Gesch√§fts (Teil 1)</a></li>
<li><a href="../de483880/index.html">Wie unterscheidet sich die Programmierung heute von der Programmierung vor 20 Jahren?</a></li>
<li><a href="../de483882/index.html">Unit-Tests in der Clean Swift-Architektur</a></li>
<li><a href="../de483886/index.html">Movix Pro-Set-Top-Box: von der Software bis zur letzten Nuss</a></li>
<li><a href="../de483894/index.html">Avito Kafka-Treffen: Konnektoren, Integration, Clouds</a></li>
<li><a href="../de483896/index.html">So starten Sie ein Produkt alleine, wenn Sie Entwickler sind: Tipps von Taylor Otvel, dem Sch√∂pfer von Laravel. Teil 2: Eine Idee finden</a></li>
<li><a href="../de483898/index.html">Dokumente als Code gegen oder in Verbindung mit Confluence? √úbersicht √ºber verschiedene M√∂glichkeiten zum Ver√∂ffentlichen aus einem Repository in Confluence</a></li>
<li><a href="../de483900/index.html">Aufbau eines fehlertoleranten Embedded Linux-Systems auf Basis des Mars ZX3-Moduls von Enclustra</a></li>
<li><a href="../de483906/index.html">Mobiles Terminal in Zugangskontrollsystemen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>