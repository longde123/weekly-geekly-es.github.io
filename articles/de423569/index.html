<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêº üëãüèΩ ‚ô®Ô∏è Wir definieren einfach und genau die Sprache der Nachrichten üçó üßõ üí∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei YouScan verarbeiten wir t√§glich etwa 100 Millionen Nachrichten, auf die viele Regeln und verschiedene intelligente Funktionen angewendet werden. F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir definieren einfach und genau die Sprache der Nachrichten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423569/"><img src="https://habrastorage.org/getpro/habr/post_images/b5d/97b/37e/b5d97b37ec0ea5fce5bf22200c96fdb3.png" align="right" width="320"><br><p>  Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YouScan verarbeiten</a> wir t√§glich etwa 100 Millionen Nachrichten, auf die viele Regeln und verschiedene intelligente Funktionen angewendet werden.  F√ºr ihre korrekte Arbeit ist es notwendig, die Sprache korrekt zu bestimmen, da nicht alle Funktionen in Bezug auf die Sprache agnostisch gemacht werden k√∂nnen.  In diesem Artikel werden wir kurz auf unsere Untersuchung dieses Problems eingehen und eine Qualit√§tsbewertung in einem Datensatz eines sozialen Netzwerks zeigen.  Netzwerke. </p><a name="habracut"></a><br><h4 id="plan-stati">  Artikel√ºbersicht </h4><br><ol><li>  Sprachdefinitionsprobleme </li><li>  Erschwingliche √∂ffentliche L√∂sungen <br><ul><li>  Kompakter Sprachdetektor 2 </li><li>  Fasttext </li></ul></li><li>  Qualit√§tsbewertung </li><li>  Schlussfolgerungen </li></ol><br><h2 id="1-problemy-opredeleniya-yazyka">  1. Probleme der Sprachdefinition </h2><br><p> Die Definition von Sprache ist ein ziemlich altes Problem, und viele versuchen, es im Rahmen der Mehrsprachigkeit ihrer Produkte zu l√∂sen.  √Ñltere Ans√§tze verwenden L√∂sungen, die auf n-Gramm basieren. Wenn die Anzahl der Vorkommen eines bestimmten n-Gramms ber√ºcksichtigt wird und auf dieser Grundlage die "Geschwindigkeit" f√ºr jede Sprache berechnet wird, wird die wahrscheinlichste Sprache gem√§√ü unserem Modell ausgew√§hlt.  Der Hauptnachteil dieser Modelle besteht darin, dass der Kontext absolut nicht ber√ºcksichtigt wird, weshalb die Definition einer Sprache f√ºr √§hnliche Sprachgruppen schwierig ist.  Aufgrund der Einfachheit der Modelle erhalten wir jedoch eine hohe Bestimmungsgeschwindigkeit, die Ressourcen f√ºr hoch belastete Systeme spart.  Eine andere Option, eine modernere, ist eine L√∂sung f√ºr wiederkehrende neuronale Netze.  Diese L√∂sung basiert bereits nicht nur auf n-Gramm, sondern ber√ºcksichtigt auch den Kontext, der die Arbeitsqualit√§t verbessern sollte. </p><br><p>  Die Komplexit√§t der Erstellung Ihrer eigenen L√∂sung beruht auf der Erfassung von Daten f√ºr das Training und den Lernprozess selbst.  Die naheliegendste L√∂sung besteht darin, das Modell auf Wikipedia-Artikeln zu trainieren, da wir die Sprache sicher kennen und es sehr hochwertige verifizierte Texte gibt, die relativ einfach zu kompilieren sind.  Um Ihr Modell zu trainieren, m√ºssen Sie viel Zeit aufwenden, um das Dataset zusammenzustellen, zu verarbeiten und dann die beste Architektur auszuw√§hlen.  H√∂chstwahrscheinlich hat dies bereits jemand vor uns getan.  Im n√§chsten Block betrachten wir bestehende L√∂sungen. </p><br><h2 id="2-dostupnye-publichnye-resheniya">  2. Verf√ºgbare √∂ffentliche L√∂sungen </h2><br><h3 id="compact-language-detector-2">  Kompakter Sprachdetektor 2 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CLD2</a> ist ein auf maschinellem Lernen basierendes probabilistisches Modell (Naive Baessian Classifier), das 83 verschiedene Sprachen f√ºr Text im UTF-8- oder HTML / XML-Format definieren kann.  F√ºr gemischte Sprachen gibt das Modell die drei wichtigsten Sprachen zur√ºck, wobei die Wahrscheinlichkeit als ungef√§hrer Prozentsatz des Textes der Gesamtzahl der Bytes berechnet wird.  Wenn das Modell sich seiner Antwort nicht sicher ist, gibt es das Tag "unc" zur√ºck. </p><br><p>  Die Genauigkeit und Vollst√§ndigkeit dieses Modells ist auf einem ziemlich guten Niveau, aber der Hauptvorteil ist die Geschwindigkeit.  Die Entwickler behaupten, dass wir bei unseren Tests des Python-Wrappers in 1 ms etwa 30 KB in 21 ms erhalten haben (70.000 bis 85.000 Nachrichten pro Sekunde, deren durchschnittliche Gr√∂√üe 0,8 KB und deren Median 0,3 KB betr√§gt). </p><br><p>  Diese L√∂sung ist sehr einfach zu bedienen.  Zuerst m√ºssen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Wrapper</a> installieren oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseren Docker verwenden</a> . </p><br><p> Um eine Prognose zu erstellen, importieren <code>pycld2</code> einfach die <code>pycld2</code> Bibliothek und schreiben Sie eine zus√§tzliche Codezeile: </p><br><div class="spoiler">  <b class="spoiler_title">Definieren einer Sprache mit cld2</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pycld2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cld2 cld2.detect(<span class="hljs-string"><span class="hljs-string">"Bonjour, Habr!"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># (True, # 14, # (('FRENCH', 'fr', 92, 1102.0), # ('Unknown', 'un', 0, 0.0), # ('Unknown', 'un', 0, 0.0)))</span></span></code> </pre> </div></div><br><p>  Die Detektorantwort ist ein Tupel mit drei Elementen: </p><br><ul><li>  Sprache ist definiert oder nicht; </li><li>  Anzahl der Zeichen; </li><li>  Tupel der drei wahrscheinlichsten Sprachen, bei denen der vollst√§ndige Name an erster Stelle steht, <br>  Die zweite ist die Abk√ºrzung gem√§√ü ISO 3166-Codes, die dritte ist der Prozentsatz der Zeichen, die zu dieser Sprache geh√∂ren, und die vierte ist die Anzahl der Bytes. </li></ul><br><h3 id="fasttext">  Fasttext </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FastText</a> ist eine von Facebook geschriebene Bibliothek zum effektiven Lernen und Klassifizieren von Texten.  Im Rahmen dieses Projekts pr√§sentierte Facebook Research Einbettungen f√ºr 157 Sprachen, die aktuelle Ergebnisse f√ºr verschiedene Aufgaben sowie ein Modell zur Bestimmung der Sprache und anderer √úberwachungsaufgaben zeigen. </p><br><p>  F√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Sprachdefinitionsmodell</a> verwendeten sie Daten aus Wikipedia, Tatoeba und SETimes und als Klassifikator ihre Fasttext-L√∂sung. </p><br><p>  Die Entwickler der Facebook-Forschung bieten zwei Modelle an: </p><br><ul><li>  <a href="">lid.176.bin</a> , der etwas schneller und genauer als das zweite Modell ist, aber 128 MB wiegt; </li><li>  <a href="">lid.176.ftz</a> - eine komprimierte Version des Originalmodells. </li></ul><br><p>  Um diese Modelle in Python zu verwenden, m√ºssen Sie zuerst den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Wrapper f√ºr Fasttext</a> installieren.  Die Installation kann schwierig sein. Befolgen Sie daher die Anweisungen auf dem Github oder verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseren Docker</a> .  Es ist auch erforderlich, das Modell √ºber den obigen Link herunterzuladen.  Wir werden die Originalversion in diesem Artikel verwenden. </p><br><p>  Das Klassifizieren einer Sprache mithilfe eines Modells von Facebook ist etwas komplizierter. Dazu ben√∂tigen wir drei Codezeilen: </p><br><div class="spoiler">  <b class="spoiler_title">Definieren einer Sprache mithilfe des FastText-Modells</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyfasttext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FastText model = FastText(<span class="hljs-string"><span class="hljs-string">'../model/lid.176.bin'</span></span>) model.predict_proba([<span class="hljs-string"><span class="hljs-string">"Bonjour, Habr!"</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">#[[('fr', 0.7602248429835308), # ('en', 0.05550386696556002), # ('ca', 0.04721488914800802)]]</span></span></code> </pre> </div></div><br><p>  Das FastText'a-Modell erm√∂glicht die Vorhersage der Wahrscheinlichkeit f√ºr n-Sprachen, wobei standardm√§√üig n = 1 ist. In diesem Beispiel haben wir jedoch das Ergebnis f√ºr die drei besten Sprachen abgeleitet.  F√ºr dieses Modell ist dies bereits die allgemeine Wahrscheinlichkeit einer Sprachvorhersage f√ºr den Text und nicht die Anzahl der Zeichen, die zu einer bestimmten Sprache geh√∂ren, wie dies im cld2-Modell der Fall war.  Die Geschwindigkeit ist auch ziemlich hoch - mehr als 60.000 Nachrichten pro Sekunde. </p><br><h2 id="3-ocenka-kachestva">  3. Qualit√§tsbewertung </h2><br><p>  Wir werden die Qualit√§t der Algorithmen anhand von Daten aus sozialen Netzwerken f√ºr zuf√§llige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitr√§ume</a> bewerten, die aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YouScan-</a> System <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entnommen</a> wurden (ca. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">500.000</a> Referenzen). Daher wird die Stichprobe mehr russische und englische Sprachen enthalten, 43% bzw. 32%, ukrainisch, spanisch und portugiesisch - ungef√§hr Jeweils 2% der √ºbrigen Sprachen weniger als 1%.  F√ºr das richtige Ziel werden wir das Markup √ºber Google √úbersetzer durchf√ºhren, da Google derzeit nicht nur die √úbersetzung, sondern auch die Definition der Sprache der Texte sehr gut verwaltet.  Nat√ºrlich ist das Markup nicht ideal, aber in den meisten F√§llen kann man ihm vertrauen. </p><br><p>  Metriken zur Bewertung der Qualit√§t von Sprachdefinitionen sind Genauigkeit, Vollst√§ndigkeit und f1.  Z√§hlen wir sie und zeigen sie in der Tabelle an: </p><br><div class="spoiler">  <b class="spoiler_title">Vergleich der Qualit√§t zweier Algorithmen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"../data/lang_data.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: text_l, cld2_l, ft_l, g_l = [], [], [], [] s = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f: s += i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">' |end\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s: text, cld2, ft, g = s.strip().rsplit(<span class="hljs-string"><span class="hljs-string">" ||| "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) text_l.append(text) cld2_l.append(cld2) ft_l.append(ft) g_l.append(g.replace(<span class="hljs-string"><span class="hljs-string">" |end"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)) s=<span class="hljs-string"><span class="hljs-string">''</span></span> data = pd.DataFrame({<span class="hljs-string"><span class="hljs-string">"text"</span></span>: text_l, <span class="hljs-string"><span class="hljs-string">"cld2"</span></span>: cld2_l, <span class="hljs-string"><span class="hljs-string">"ft"</span></span>: ft_l, <span class="hljs-string"><span class="hljs-string">"google"</span></span>: g_l}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lang_summary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lang, col)</span></span></span><span class="hljs-function">:</span></span> prec = (data.loc[data[col] == lang, <span class="hljs-string"><span class="hljs-string">"google"</span></span>] == data.loc[data[col] == lang, col]).mean() rec = (data.loc[data[<span class="hljs-string"><span class="hljs-string">"google"</span></span>] == lang, <span class="hljs-string"><span class="hljs-string">"google"</span></span>] == data.loc[data[<span class="hljs-string"><span class="hljs-string">"google"</span></span>] == lang, col]).mean() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> round(prec, <span class="hljs-number"><span class="hljs-number">3</span></span>), round(rec, <span class="hljs-number"><span class="hljs-number">3</span></span>), round(<span class="hljs-number"><span class="hljs-number">2</span></span>*prec*rec / (prec + rec),<span class="hljs-number"><span class="hljs-number">3</span></span>) results = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> approach <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">"cld2"</span></span>, <span class="hljs-string"><span class="hljs-string">"ft"</span></span>]: results[approach] = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data[<span class="hljs-string"><span class="hljs-string">"google"</span></span>].value_counts().index[:<span class="hljs-number"><span class="hljs-number">20</span></span>]: results[approach][l] = lang_summary(l, approach) res = pd.DataFrame.from_dict(results) res[<span class="hljs-string"><span class="hljs-string">"cld2_prec"</span></span>], res[<span class="hljs-string"><span class="hljs-string">"cld2_rec"</span></span>], res[<span class="hljs-string"><span class="hljs-string">"cld2_f1"</span></span>] = res[<span class="hljs-string"><span class="hljs-string">"cld2"</span></span>].apply(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: [x[<span class="hljs-number"><span class="hljs-number">0</span></span>], x[<span class="hljs-number"><span class="hljs-number">1</span></span>], x[<span class="hljs-number"><span class="hljs-number">2</span></span>]]).str res[<span class="hljs-string"><span class="hljs-string">"ft_prec"</span></span>], res[<span class="hljs-string"><span class="hljs-string">"ft_rec"</span></span>], res[<span class="hljs-string"><span class="hljs-string">"ft_f1"</span></span>] = res[<span class="hljs-string"><span class="hljs-string">"ft"</span></span>].apply(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: [x[<span class="hljs-number"><span class="hljs-number">0</span></span>], x[<span class="hljs-number"><span class="hljs-number">1</span></span>], x[<span class="hljs-number"><span class="hljs-number">2</span></span>]]).str res.drop(columns=[<span class="hljs-string"><span class="hljs-string">"cld2"</span></span>, <span class="hljs-string"><span class="hljs-string">"ft"</span></span>], inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) arrays = [[<span class="hljs-string"><span class="hljs-string">'cld2'</span></span>, <span class="hljs-string"><span class="hljs-string">'cld2'</span></span>, <span class="hljs-string"><span class="hljs-string">'cld2'</span></span>, <span class="hljs-string"><span class="hljs-string">'ft'</span></span>, <span class="hljs-string"><span class="hljs-string">'ft'</span></span>, <span class="hljs-string"><span class="hljs-string">'ft'</span></span>], [<span class="hljs-string"><span class="hljs-string">'precision'</span></span>, <span class="hljs-string"><span class="hljs-string">'recall'</span></span>, <span class="hljs-string"><span class="hljs-string">'f1_score'</span></span>, <span class="hljs-string"><span class="hljs-string">'precision'</span></span>, <span class="hljs-string"><span class="hljs-string">'recall'</span></span>, <span class="hljs-string"><span class="hljs-string">'f1_score'</span></span>]] tuples = list(zip(*arrays)) res.columns = pd.MultiIndex.from_tuples(tuples, names=[<span class="hljs-string"><span class="hljs-string">"approach"</span></span>, <span class="hljs-string"><span class="hljs-string">"metrics"</span></span>])</code> </pre> </div></div><br><table><thead><tr><th>  Modell </th><th></th><th>  cld2 </th><th></th><th></th><th>  ft </th><th></th><th></th><th>  ans </th><th></th></tr></thead><tbody><tr><td>  Metriken </td><td>  vor </td><td>  rec </td><td>  f1 </td><td>  vor </td><td>  rec </td><td>  f1 </td><td>  vor </td><td>  rec </td><td>  f1 </td></tr><tr><td>  ar </td><td>  <strong>0,992</strong> </td><td>  0,725 </td><td>  0,838 </td><td>  0,918 </td><td>  0,697 </td><td>  0,793 </td><td>  0,968 </td><td>  <strong>0,788</strong> </td><td>  <strong>0,869</strong> </td></tr><tr><td>  az </td><td>  <strong>0,95</strong> </td><td>  0,752 </td><td>  0,839 </td><td>  0,888 </td><td>  0,547 </td><td>  0,677 </td><td>  0,914 </td><td>  <strong>0,787</strong> </td><td>  <strong>0,845</strong> </td></tr><tr><td>  bg </td><td>  <strong>0,529</strong> </td><td>  0,136 </td><td>  0,217 </td><td>  0,286 </td><td>  0,178 </td><td>  0,219 </td><td>  0,408 </td><td>  <strong>0,214</strong> </td><td>  <strong>0,281</strong> </td></tr><tr><td>  en </td><td>  <strong>0,949</strong> </td><td>  0,844 </td><td>  0,894 </td><td>  0,885 </td><td>  0,869 </td><td>  0,877 </td><td>  0,912 </td><td>  <strong>0,925</strong> </td><td>  <strong>0,918</strong> </td></tr><tr><td>  es </td><td>  <strong>0,987</strong> </td><td>  0,653 </td><td>  0,786 </td><td>  0,709 </td><td>  0,814 </td><td>  0,758 </td><td>  0,828 </td><td>  <strong>0,834</strong> </td><td>  <strong>0,831</strong> </td></tr><tr><td>  fr </td><td>  <strong>0,991</strong> </td><td>  0,713 </td><td>  <strong>0,829</strong> </td><td>  0,53 </td><td>  0,803 </td><td>  0,638 </td><td>  0,713 </td><td>  <strong>0,81</strong> </td><td>  0,758 </td></tr><tr><td>  id </td><td>  <strong>0,763</strong> </td><td>  0,543 </td><td>  <strong>0,634</strong> </td><td>  0,481 </td><td>  0,404 </td><td>  0,439 </td><td>  0,659 </td><td>  <strong>0,603</strong> </td><td>  0,63 </td></tr><tr><td>  es </td><td>  <strong>0,975</strong> </td><td>  0,466 </td><td>  0,631 </td><td>  0,519 </td><td>  0,778 </td><td>  0,622 </td><td>  0,666 </td><td>  <strong>0,752</strong> </td><td>  <strong>0,706</strong> </td></tr><tr><td>  ja </td><td>  <strong>0,994</strong> </td><td>  0,899 </td><td>  <strong>0,944</strong> </td><td>  0,602 </td><td>  0,842 </td><td>  0,702 </td><td>  0,847 </td><td>  <strong>0,905</strong> </td><td>  0,875 </td></tr><tr><td>  ka </td><td>  <strong>0,962</strong> </td><td>  0,995 </td><td>  <strong>0,979</strong> </td><td>  0,959 </td><td>  0,905 </td><td>  0,931 </td><td>  0,958 </td><td>  <strong>0,995</strong> </td><td>  0,976 </td></tr><tr><td>  kk </td><td>  <strong>0,908</strong> </td><td>  0,653 </td><td>  0,759 </td><td>  0,804 </td><td>  0,584 </td><td>  0,677 </td><td>  0,831 </td><td>  <strong>0,713</strong> </td><td>  <strong>0,767</strong> </td></tr><tr><td>  ko </td><td>  <strong>0,984</strong> </td><td>  0,886 </td><td>  0,933 </td><td>  0,94 </td><td>  0,704 </td><td>  0,805 </td><td>  0,966 </td><td>  <strong>0,91</strong> </td><td>  <strong>0,937</strong> </td></tr><tr><td>  ms </td><td>  <strong>0,801</strong> </td><td>  0,578 </td><td>  <strong>0,672</strong> </td><td>  0,369 </td><td>  0,101 </td><td>  0,159 </td><td>  0,73 </td><td>  <strong>0,586</strong> </td><td>  0,65 </td></tr><tr><td>  pt </td><td>  <strong>0,968</strong> </td><td>  0,753 </td><td>  0,847 </td><td>  0,805 </td><td>  0,771 </td><td>  0,788 </td><td>  0,867 </td><td>  <strong>0,864</strong> </td><td>  <strong>0,865</strong> </td></tr><tr><td>  ru </td><td>  <strong>0,987</strong> </td><td>  0,809 </td><td>  0,889 </td><td>  0,936 </td><td>  0,933 </td><td>  0,935 </td><td>  0,953 </td><td>  <strong>0,948</strong> </td><td>  <strong>0,95</strong> </td></tr><tr><td>  sr </td><td>  0,093 </td><td>  0,114 </td><td>  0,103 </td><td>  <strong>0,174</strong> </td><td>  0,103 </td><td>  0,13 </td><td>  0,106 </td><td>  <strong>0,16</strong> </td><td>  <strong>0,128</strong> </td></tr><tr><td>  th </td><td>  <strong>0,989</strong> </td><td>  0,986 </td><td>  <strong>0,987</strong> </td><td>  0,973 </td><td>  0,927 </td><td>  0,95 </td><td>  0,979 </td><td>  <strong>0,986</strong> </td><td>  0,983 </td></tr><tr><td>  tr </td><td>  <strong>0,961</strong> </td><td>  0,639 </td><td>  <strong>0,768</strong> </td><td>  0,607 </td><td>  0,73 </td><td>  0,663 </td><td>  0,769 </td><td>  <strong>0,764</strong> </td><td>  0,767 </td></tr><tr><td>  Gro√übritannien </td><td>  <strong>0,949</strong> </td><td>  0,671 </td><td>  <strong>0,786</strong> </td><td>  0,615 </td><td>  0,733 </td><td>  0,669 </td><td>  0,774 </td><td>  <strong>0,777</strong> </td><td>  0,775 </td></tr><tr><td>  uz </td><td>  0,666 </td><td>  0,512 </td><td>  0,579 </td><td>  <strong>0,77</strong> </td><td>  0,169 </td><td>  0,278 </td><td>  0,655 </td><td>  <strong>0,541</strong> </td><td>  <strong>0,592</strong> </td></tr></tbody></table><br><p>  Die Ergebnisse zeigen deutlich, dass der cld2-Ansatz eine sehr hohe Genauigkeit bei der Bestimmung der Sprache aufweist, nur f√ºr unpopul√§re Sprachen unter 90% f√§llt und in 90% der F√§lle das Ergebnis besser ist als das von Fasttext.  Mit ungef√§hr der gleichen Vollst√§ndigkeit f√ºr die beiden Ans√§tze ist f1 bei cld2 schneller. <br>  Die Besonderheit des cld2-Modells besteht darin, dass es nur f√ºr die Nachrichten eine Prognose liefert, bei denen es sicher genug ist. Dies erkl√§rt die hohe Genauigkeit.  Das Fasttext'a-Modell bietet eine Antwort auf die meisten Nachrichten, daher ist die Genauigkeit erheblich geringer, aber es ist seltsam, dass die Vollst√§ndigkeit nicht wesentlich h√∂her und in halben F√§llen niedriger ist.  Wenn Sie jedoch den Schwellenwert f√ºr das Fasttext-Modell "verdrehen", k√∂nnen Sie die Genauigkeit verbessern. </p><br><h2 id="4-vyvody">  4. Schlussfolgerungen </h2><br><p>  Im Allgemeinen liefern beide Modelle gute Ergebnisse und k√∂nnen verwendet werden, um das Problem der Bestimmung der Sprache in verschiedenen Bereichen zu l√∂sen.  Ihr Hauptvorteil ist die hohe Geschwindigkeit, die es erm√∂glicht, ein sogenanntes "Ensemble" zu erstellen und die notwendige Vorverarbeitung hinzuzuf√ºgen, um die Qualit√§t zu verbessern. </p><br><p>  Den gesamten Code zum Reproduzieren von Experimenten und Testen der oben genannten Ans√§tze finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem Repository</a> . </p><br><p>  Sie k√∂nnen das Testen dieser L√∂sungen auch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem anderen Artikel sehen</a> , in dem Genauigkeit und Geschwindigkeit in 6 westeurop√§ischen Sprachen verglichen werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423569/">https://habr.com/ru/post/de423569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423557/index.html">Baby, Internet und Eltern. Wie vermeide ich Fallen, profitiere und bleibe Freunde?</a></li>
<li><a href="../de423559/index.html">Sichern und Wiederherstellen von Kubernetes-Ressourcen mit Heptio Ark</a></li>
<li><a href="../de423563/index.html">VPS.today - Katalog virtueller Server</a></li>
<li><a href="../de423565/index.html">Gamepad von Sega Mega Drive und Raspberry Pi Part 1 (vorbereitend und mit drei Tasten)</a></li>
<li><a href="../de423567/index.html">Noch einmal √ºber k√ºnstliche Intelligenz</a></li>
<li><a href="../de423571/index.html">Alle m√∂glichen Dinge in MetaPost</a></li>
<li><a href="../de423573/index.html">Synchronizit√§t ist ein Mythos</a></li>
<li><a href="../de423575/index.html">Designstandards in der Mikroelektronik: Wo gibt es wirklich 7 Nanometer in der 7-nm-Technologie?</a></li>
<li><a href="../de423577/index.html">Erstellen eines Logikspiels f√ºr eine Spieleplattform</a></li>
<li><a href="../de423579/index.html">Cloud Services f√ºr WebGL? Nein danke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>