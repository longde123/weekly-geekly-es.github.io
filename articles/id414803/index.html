<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¶ğŸ½ ğŸ‘š ğŸ’ Bagaimana kami melihat pembayaran IoT di hackathon di Hong Kong ğŸš° â›“ï¸ ğŸ‘‡ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="10 Juni adalah hari ketiga aklimatisasi kami di Hong Kong. Dan 26 jam terakhir yang kami habiskan hampir tanpa tidur, mengembangkan proyek prototipe d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami melihat pembayaran IoT di hackathon di Hong Kong</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mixbytes/blog/414803/"><p><img src="https://habrastorage.org/webt/fs/nm/lj/fsnmljsf_fjfqn0eqomgc9yyswi.jpeg"></p><br><p>  10 Juni adalah hari ketiga aklimatisasi kami di Hong Kong.  Dan 26 jam terakhir yang kami habiskan hampir tanpa tidur, mengembangkan proyek prototipe dengan nama kerja SensorPay pada tahap pertama hackathon EOS Global dengan total hadiah uang satu setengah juta dolar.  Momen demonstrasi proyek di depan para hakim semakin dekat. </p><br><p>  Jika Anda ingin mengetahui bagaimana kisah ini berakhir, lihat bagian terakhir segera.  Sementara itu, kami akan mulai berbicara secara sistematis tentang teknologi EOS dan bagaimana kami sampai pada gagasan menautkan pembayaran untuk IoT ke EOS.  Segera setelah itu akan ada deskripsi rinci tentang isian teknis proyek. </p><a name="habracut"></a><br><h1 id="0-predystoriya">  0. Latar Belakang </h1><br><p>  EOS adalah blockchain generasi baru, beberapa bahkan menganggapnya sebagai pembunuh Ethereum.  Jika tiba-tiba Anda tidak tahu apa itu blockchain atau Ethereum, Google akan membantu.  Dan kami, itu terjadi, mulai menggali EOS sekitar setahun yang lalu, termasuk dengan mempelajari produk sebelumnya dari penulisnya BitShares dan Steem. </p><br><p>  Keuntungan EOS dibandingkan dengan Ethereum: throughput transaksi adalah tiga urutan lebih tinggi;  mengembangkan sistem izin untuk kontrak pintar;  kemampuan untuk mengembalikan akses yang hilang dan memperbaiki kesalahan dalam blockchain;  manajemen jaringan onchain.  Kelemahan: kekhawatiran sentralisasi, konsensus DPoS yang berpotensi lebih rentan, kode mentah, dan kurva pembelajaran yang lebih curam untuk pengembang. </p><br><p>  Karena kami telah menyukai teknologi ini sejak lama dan menganggapnya menjanjikan, kami tidak dapat mengabaikan rangkaian hackathon, yang didukung oleh penulis EOS.  Kami hanya ingin berada di sana, mewujudkan ide-ide kami di lingkungan yang menginspirasi ini dan membaginya dengan khalayak luas.  Tentu saja, kesempatan untuk memenangkan uang yang baik juga menjadi motivator tambahan yang menyenangkan. </p><br><p>  Jadi, EOS adalah satu-satunya solusi yang berfungsi untuk blockchain publik yang kami tahu di mana Anda dapat melakukan banyak transaksi.  Di mana itu dibutuhkan?  Tentu saja dalam IoT!  Memang, jika setiap pemanggang menjadi pembayaran mikro, ia akan membayar setiap potong roti ke lemari es (dan ini asik secara default, seperti yang Anda mengerti), akan ada banyak transaksi.  Belum lagi segala macam aplikasi lain dalam bidang kedokteran, industri dan kehidupan sehari-hari. </p><br><p>  Beberapa minggu sebelum hackathon, ide-ide alternatif muncul secara berkala, dan brainstorm kecil diadakan.  Kami membandingkan ide berdasarkan kriteria wasit terkenal: penggunaan kemampuan EOS, kreativitas, dampak publik, dan skalabilitas.  Hasilnya, kami memilih IoT + EOS - solusi yang akan mengambil data dari sensor dan mengirim banyak transaksi pembayaran ke EOS. </p><br><p>  Ngomong-ngomong, kami benar-benar ingin memberi tahu di sini juga tentang bagaimana kami meningkatkan Block Producer kami untuk EOS;  bagaimana mereka berencana untuk membilasnya untuk konstruktor token ERC721 dan dukungan untuk fungsi konstan;  bagaimana mereka mengajukan protokol ACL Merkle Root.  Tetapi semua ini tidak sesuai dengan artikel, jadi kami akan kembali ke proyek utama kami. </p><br><p><img src="https://habrastorage.org/webt/9j/mu/uk/9jmuukvwx1e6cav3h59txeywaw0.jpeg"></p><br><h1 id="1-podgotovka">  1. Persiapan </h1><br><h2 id="11-iot">  1.1.  IoT </h2><br><p>  Mempersiapkan bagian IoT dari proyek ini adalah memilih perangkat keras yang tepat.  Dalam peran pembaca RFID, RC522 yang beroperasi pada bus SPI dipilih: populer dan mudah digunakan. </p><br><p><img src="https://habrastorage.org/webt/tq/xf/qh/tqxfqh4x5vzlaywel57eqszznpu.jpeg"></p><br><p>  Saat mencari penghitung, kami fokus pada keberadaan output pulsa, karena memungkinkan Anda untuk membaca data dengan sangat sederhana: satu pulsa adalah X kWâ‹…h (di mana X bergantung pada model), sebagai hasilnya, kami berhenti di konter Mercury 201.5. </p><br><p><img src="https://habrastorage.org/webt/z-/63/sc/z-63scf4m94nnbw30prkmy_nfxa.jpeg"></p><br><p>  Hal yang paling sulit adalah memutuskan controller, yang harus mengumpulkan data dari sensor, membentuk transaksi, menandatanganinya dengan kunci pribadi Anda dan mengirimkannya ke jaringan.  Karenanya, kami membutuhkan perangkat dengan modul jaringan yang dapat menandatangani transaksi menggunakan ECDSA (dalam kasus ini, pada kurva eliptik secp256k1, karena digunakan dalam EOS untuk penandatanganan). </p><br><p>  Awalnya, pilihan ada pada mikrokontroler ESP8266, ia memiliki modul Wi-Fi dan semua antarmuka yang diperlukan untuk menghubungkan sensor kami.  Pada saat yang sama, sangat ringkas.  Tetapi tidak satupun dari firmware memiliki implementasi asli dari primitif eliptik.  Dimungkinkan untuk menulis implementasi Anda sendiri, tetapi ini bukan tugas untuk hackathon.  Akibatnya, Raspberry Pi 3 B dipilih untuk prototipe, dan perpustakaan eosjs digunakan untuk menghasilkan dan menandatangani transaksi. </p><br><p><img src="https://habrastorage.org/webt/ww/jo/dg/wwjodgbxktjubpruvb-srqz_9dq.jpeg"></p><br><h2 id="12-infrastruktura">  1.2.  Infrastruktur </h2><br><p>  Beberapa hari sebelum hackathon, kami menyiapkan secara lokal dan pada server eos-hackathon.smartz.io sebuah perakitan EOS ( <a href="">sumber</a> ).  Instalasi, perakitan, dan tes ketergantungan berjalan sangat lancar untuk proyek yang masih muda (menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ).  Tidak ada cukup waktu untuk persiapan infrastruktur lainnya, dan saya harus menghadapinya selama hackathon. </p><br><h2 id="13-arhitektura">  1.3.  Arsitektur </h2><br><p>  Menjelang hackathon, kami membahas arsitektur dan menjelaskan detail produk.  Kami akan menerapkan kasus-kasus utama berikut: pembayaran untuk listrik dan pembayaran untuk pembelian yang ditandai dengan tag RFID.  Mereka juga berencana untuk membuat produk mudah diperluas dan menggunakannya di daerah lain. </p><br><p><img src="https://habrastorage.org/webt/yh/rh/tm/yhrhtm0ildam8hgnnjnpkf4_l7w.jpeg"></p><br><p>  Gagasan arsitektur adalah bahwa penyedia layanan (Produser) menciptakan satu kontrak - titik interaksi utama antara pemasok dan konsumen.  Setiap konsumen memiliki saldo sendiri, yang dapat diisi ulang, dana didebit darinya berdasarkan sinyal sensor.  Semua data - pengguna, sensor, statistik - disimpan dalam kontrak pemasok. </p><br><p> Preferensi pengguna dikaitkan dengan konsumen, atau bendera (misalnya, kategori pengguna preferensial) - <code>user_meta</code> .  Beberapa sensor dapat dihubungkan dengan konsumen, untuk masing-masing dari mereka pengaturan kontrak dan penagihan ( <code>billing_meta</code> ) ditunjukkan.  Jadi, Anda bisa mendapatkan kontrak penagihan stateless yang tidak dapat diubah, yang digunakan untuk sejumlah besar konsumen;  data yang diperlukan akan muncul selama doa metode <code>bill(payload, user_meta, billing_meta)</code> .  Juga, kemungkinan logika penagihan yang berbeda, yaitu, kontrak yang berbeda, diletakkan: misalnya, satu menganggap listrik, yang lain - barang.  Setiap sensor memiliki "penunjuk" untuk kontrak penagihannya. </p><br><p>  Diasumsikan bahwa konsumen mempercayai produsen sensor, tetapi tidak harus percaya pada penyedia layanan.  Antarmuka interaksi dengan sensor sangat sederhana: ini adalah panggilan ke metode kontrak pemasok dengan parameter numerik, yang akan ditransfer ke penagihan.  Penyedia layanan memulai konsumen, sensor, kontrak penagihan dan hubungan mereka dalam kontrak mereka, menggunakan kontrol transaksi - setter primitif.  Ketika transaksi diterima dari sensor, data diperiksa, data untuk penagihan dihasilkan, penagihan disebut, pembayaran dicatat dan statistik dicatat. </p><br><p>  Mungkin sebagian besar dari semua yang kita bahas masalah berikut ini yang penting untuk penerapan produk di dunia nyata: </p><br><ul><li>  Uang muka atau pascabayar?  Isi ulang akun Anda dan gunakan (seperti koneksi seluler) - atau gunakan, lalu bayar (seperti AWS)?  Tidak ada jawaban benar atau salah di sini: bisnis yang berbeda lebih suka model yang berbeda.  Untuk mempermudah, kami memutuskan untuk mengambil pembayaran di muka. </li><li>  Haruskah pengguna menyimpan akun terpisah untuk setiap pemasok, atau apakah semua biaya berasal dari satu akun?  Lagi - tidak ada keputusan benar dan salah;  selain itu, jawabannya terkait erat dengan jawaban pertanyaan sebelumnya.  Pembayaran di muka adalah teman baik dengan akun konsumen individu - mereka diambil. </li><li>  Mengisi biaya dalam EOS, tanda penyedia layanan atau koin stabil (terkait dengan mata uang fiat)?  Opsi selain koin stabil, tentu saja, tidak nyaman bagi konsumen karena volatilitas, dan koin stabil dalam kerangka EOS belum ada.  Pada saat itu, bahkan jaringan EOS utama tidak ada di sana!  Untuk kesederhanaan, mereka mengambil tanda kondisional. </li></ul><br><h1 id="2-koding">  2. Pengodean </h1><br><p>  Pertama-tama, mereka menentukan API dan kerangka kontrak pemasok untuk secara bersamaan memulai pengembangan frontend, kode perangkat, penagihan, dan kontrak utama ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ). </p><br><h2 id="21-iot">  2.1.  IoT </h2><br><p>  Yang pertama menerapkan <a href="">kode</a> untuk membaca pulsa dari penghitung.  Untuk bekerja dengan GPIO (pin tujuan umum), pustaka JS onoff digunakan.  Kemudian, dua LED ditambahkan ke sirkuit untuk kejelasan: yang pertama berkedip ketika sinyal diterima dari konter, dan yang kedua ketika jawaban tentang transaksi yang berhasil datang dari node EOS.  Demikian pula, kami mengembangkan skema dan kode untuk membaca tag RFID, dengan satu-satunya perbedaan: membaca terjadi pada bus SPI menggunakan perpustakaan MFRC522-python.  Ternyata, pengaturan SPI untuk Raspberry Pi 3 berbeda dari pengaturan pada model board sebelumnya;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instruksi</a> ini membantu kami untuk mengerti. </p><br><p>  Perangkat ini didukung oleh bank daya, yang berhasil disajikan kepada semua peserta hackathon, dan mereka harus berbagi Internet sendiri dengan iPhone 5, karena Wi-Fi hackathon bekerja secara eksklusif pada 5 GHz, ini tidak bekerja untuk Raspberry Pi. </p><br><h2 id="22-infrastruktura-i-utility">  2.2.  Infrastruktur dan Utilitas </h2><br><p>  Panitia menyarankan untuk mengambil gambar buruh pelabuhan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eos-dev</a> , tetapi kami bingung dengan kurangnya deskripsi dan dokumentasi dari gambar tersebut.  Di server, mereka terus bekerja dengan perakitan yang disiapkan, dan secara lokal, untuk menghindari menginstal EOS secara sistematis, mereka menggunakan eos-dev. </p><br><p>  Segera dibutuhkan kemampuan untuk membangun dan menguji dengan cepat.  Ideal: buat dan jalankan file yang dapat dieksekusi secara lokal.  Namun, tidak mungkin untuk mengabaikan fakta bahwa setelah perakitan, output membutuhkan WebAssembly dan, dalam lingkungan EOS, dengan dorongan yang sesuai, perpustakaan, kontrak sistem.  Opsi kompilasi yang diperlukan dapat dimata-matai di <a href="">eosiocpp.in</a> , namun, kami memutuskan untuk tidak memainkan game ini.  Hasil yang diprediksi, meskipun sedikit lebih lambat, lebih penting daripada solusi cepat dengan penggaruk potensial.  Oleh karena itu, untuk perakitan kami mengambil eoscpp, yang ada di wadah eos-dev. </p><br><p>  Ternyata menjadi lebih sulit dengan peluncuran, saya harus meningkatkan blockchain EOS lokal, dan sekali lagi tidak ada solusi siap pakai.  Hanya perangkat lunak.  Jadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi pertama dari</a> infrastruktur peluncuran muncul.  Idenya adalah untuk menyembunyikan nuansa pemasangan dan konfigurasi dan mendapatkan seperangkat "tombol" yang konsisten sendiri untuk tindakan khusus.  Kurang kontrol, tetapi lebih sedikit kemungkinan kesalahan, ditambah penghematan waktu. </p><br><p>  Komponen utama EOS termasuk nodeos, keosd daemon, utilitas konsol cleos, dan kompiler eoscpp: </p><br><ul><li>  nodeos - EOS node, daemon - peserta jaringan, menyediakan akses ke blockchain dan secara opsional menghasilkan blok baru; </li><li>  keosd - sebuah daemon untuk mengelola dompet lokal yang menyimpan pasangan kunci; </li><li>  cleos menyediakan perintah mulai dari memperoleh informasi tentang transaksi hingga bekerja dengan kunci, itu diimplementasikan berdasarkan panggilan dalam nodeos dan keosd melalui API HTTP; </li><li>  eoscpp mengkompilasi kontrak ke dalam WebAssembly, dan juga memungkinkan Anda untuk mendapatkan Application Binary Interface berdasarkan kode sumber. </li></ul><br><p>  Segera menjadi jelas bahwa perintah cleos terkait dengan panggilan keosd tidak berfungsi.  Karena kesalahan dikeluarkan yang menunjukkan tidak dapat diaksesnya jaringan keosd, kami menghabiskan waktu untuk mendiagnosis masalah jaringan di jaringan buruh pelabuhan.  Namun, strace menunjukkan bahwa itu bukan jaringan: cleos mengakses alamat yang salah, selalu ke localhost (dan dalam hal infrastruktur kami, daemon yang berbeda memiliki alamat jaringan yang berbeda dalam jaringan buruh pelabuhan yang terpisah).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bug</a> didiagnosis dalam cleos: memeriksa ketersediaan keosd, yang dilakukan sebelum perintah apa pun yang terkait dengan dompet, memperhitungkan port yang diteruskan dalam argumen, tetapi tidak memperhitungkan alamat.  Di bawah hackathon, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beralih</a> ke jaringan host di buruh pelabuhan sebagai solusi. </p><br><p>  Langkah selanjutnya adalah utilitas kompilasi kontrak menggunakan kompiler dalam wadah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit</a> ).  Direktori input dan output sudah terpasang.  Dan akhirnya, kemampuan untuk mengunggah kontrak ke blockchain dan mengirim transaksi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit</a> ).  Lagi - utilitas dalam gaya yang konsisten, "tombol" sederhana.  Ini mengakhiri infrastruktur dasar, tetapi kejutan terus berlanjut: kami menemukan masalah fungsi-C untuk bekerja dengan memori (lebih terinci di bawah). </p><br><p>  Sebagai kesimpulan, mereka mulai mengatur akun dalam satu file (setiap kontrak dan peserta membutuhkan akun terpisah) tepat bersama dengan pasangan kunci yang dibuat secara otomatis ketika blockchain dimulai, sehingga satu tim dapat meningkatkan lingkungan pengujian.  Satu salinan dari lingkungan ini digunakan untuk eos-hackathon.smartz.io. </p><br><h2 id="23-smart-kontrakty">  2.3.  Kontrak yang cerdas </h2><br><h3 id="231-kontrakt-postavschika-i-billing-elektrichestva">  2.3.1.  Kontrak pemasok dan tagihan listrik </h3><br><p>  Setelah dimulainya hackathon, kami mulai menyusun struktur kontrak sesuai dengan skema di atas.  Sistem terdiri dari kontrak-kontrak berikut: </p><br><ul><li>  <code>supplier</code> - kontrak <code>supplier</code> ; </li><li>  <code>billing_electricity</code> - kontrak untuk menghitung pembayaran listrik untuk setiap centang meter. </li></ul><br><p>  Dalam kontrak <code>supplier</code> , sebagian besar pekerjaan dilakukan oleh operasi CRUD biasa: menambah pengguna, tarif, penghitung, menambah atau mengurangi saldo pengguna.  Metode yang lebih kompleks bertanggung jawab untuk menerima data dari meteran, memanggil kontrak untuk menghitung pembayaran (penagihan), mendebit akun pribadi pengguna setelah panggilan balik dari kontrak penagihan.  Kontrak penagihan yang diperlukan ditentukan berdasarkan tarif pengguna. </p><br><p>  Setelah panggilan dalam kontrak untuk penagihan, pembayaran dihitung dan metode dipanggil untuk mendebit pembayaran dari akun pribadi pengguna.  Setelah melempar logika utama, kami bahkan berpikir jika kami melakukan kontrak yang terlalu sederhana.  Beberapa saat kemudian, setelah penyebaran kontrak di simpul dan pengujiannya, menjadi jelas bahwa kontrak mungkin sederhana, tetapi ada nuansa.  :) </p><br><p>  Setelah penyebaran, ternyata panggilan kontrak yang diharapkan dari satu sama lain tidak berfungsi.  Tidak cukup hak.  Tidak seperti kontrak pintar di Ethereum, di mana kontrak dipanggil dari kontrak atas nama kontrak panggilan, di EOS, seluruh rantai dimulai dengan pemrakarsa transaksi.  Ketika suatu kontrak dipanggil dari suatu kontrak, akan diperiksa apakah pemrakarsa mengizinkan kontrak untuk melakukan hal ini. </p><br><p>  Mentor segera menyarankan cara bertindak dalam kasus sederhana.  Hak ditambahkan sebagai berikut (melalui panggilan kontrak pintar sistem eosio): </p><br><pre> <code class="hljs swift">./cleos push action eosio updateauth '{<span class="hljs-string"><span class="hljs-string">"account"</span></span>:<span class="hljs-string"><span class="hljs-string">"electricity"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"active"</span></span>,<span class="hljs-string"><span class="hljs-string">"parent"</span></span>:<span class="hljs-string"><span class="hljs-string">"owner"</span></span>,<span class="hljs-string"><span class="hljs-string">"auth"</span></span>:{<span class="hljs-string"><span class="hljs-string">"keys"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"key"</span></span>:<span class="hljs-string"><span class="hljs-string">"EOS7oPdzdvbHcJ4k9iZaDuG4Foh9YsjQffTGniLP28FC8fbpCDgr5"</span></span>,<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"threshold"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"accounts"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:{<span class="hljs-string"><span class="hljs-string">"actor"</span></span>:<span class="hljs-string"><span class="hljs-string">"supplier"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"eosio.code"</span></span>},<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"waits"</span></span>:[]}}' -p electricity</code> </pre> <br><p>  Dalam hal ini, akun <code>electricity</code> memungkinkan kontrak <code>supplier</code> untuk memanggil kontrak lain atas namanya.  Anda dapat membaca lebih lanjut tentang hak di <a href="">WP Teknis EOS</a> .  Di negara kita, kontrak <code>supplier</code> menyebabkan kontrak <code>billing</code> , dan pada gilirannya, lagi-lagi disebut <code>supplier</code> .  Menambahkan dengan analogi hak dalam formulir ini tidak berhasil: </p><br><pre> <code class="hljs swift">./cleos push action eosio updateauth '{<span class="hljs-string"><span class="hljs-string">"account"</span></span>:<span class="hljs-string"><span class="hljs-string">"electricity"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"active"</span></span>,<span class="hljs-string"><span class="hljs-string">"parent"</span></span>:<span class="hljs-string"><span class="hljs-string">"owner"</span></span>,<span class="hljs-string"><span class="hljs-string">"auth"</span></span>:{<span class="hljs-string"><span class="hljs-string">"keys"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"key"</span></span>:<span class="hljs-string"><span class="hljs-string">"EOS7oPdzdvbHcJ4k9iZaDuG4Foh9YsjQffTGniLP28FC8fbpCDgr5"</span></span>,<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"threshold"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"accounts"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:{<span class="hljs-string"><span class="hljs-string">"actor"</span></span>:<span class="hljs-string"><span class="hljs-string">"supplier"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"eosio.code"</span></span>},<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>},{<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:{<span class="hljs-string"><span class="hljs-string">"actor"</span></span>:<span class="hljs-string"><span class="hljs-string">"billelectro"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"eosio.code"</span></span>},<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"waits"</span></span>:[]}}' -p electricity</code> </pre> <br><p>  Terjadi kesalahan: Otoritas tidak valid.  Di sini para mentor tidak dapat lagi membantu kami: mereka berkata bahwa mereka sendiri tidak melakukan ini.  Dan siapa yang melakukannya?  Mungkin hanya Dan Larimer.  Kami tidak dapat dengan cepat menemukan penyebab kesalahan dalam kode EOS dan sudah mulai mempertimbangkan opsi alternatif, tanpa rantai panggilan.  Ini dicegah dengan indah bahwa mekanisme untuk memanggil kontrak lain di EOS juga berbeda dari eter.  Ketika kontrak lain dipanggil, panggilan ini diantrekan dan hanya akan selesai setelah panggilan saat ini selesai.  Tidak akan bekerja untuk memanggil kontrak dan setelah panggilan untuk membaca data yang dicatat oleh kontrak ini. </p><br><p>  Kemudian, setelah semua, mereka menemukan dalam kode EOS alasan kesalahan ketika menetapkan hak untuk dua kontrak.  Ternyata akun dalam daftar hak harus disortir berdasarkan akun: <em>Memastikan semua kunci unik dan diurutkan dan semua izin akun unik dan diurutkan</em> ( <a href="">authority.hpp</a> ).  Setelah mengubah urutan akun, pembaruan hak berhasil - dan sistem kontrak kami mulai beroperasi. </p><br><h3 id="232-problema-c-funkciy-raboty-s-pamyatyu">  2.3.2.  Masalah fungsi-C dengan memori </h3><br><p>  Mengatakan hal itu konyol, tetapi pada akhirnya kami tidak dapat menggunakan fungsi yang sudah jadi untuk menguraikan angka (!) Untuk membaca konfigurasi penagihan.  Mengikuti <code>std::istringstream</code> fungsi <code>std::istringstream</code> ditarik ke atas, yang agak aneh.  Dan ketika menggunakan <code>atof</code> dan sejenisnya, serta <code>sscanf</code> - <code>env.realloc</code> diperketat.  Untuk beberapa alasan, fungsi-fungsi yang disebutkan bekerja dengan memori pustaka C standar tidak ditemukan selama pemuatan kode di nodeos.  Fungsi C ++ bekerja dengan memori berfungsi. </p><br><p>  Tentu saja, ketika menjalankan kontrak WebAssembly, bukan pengalokasi memori standar yang digunakan, tetapi kotak pasirnya sendiri, yang disediakan untuk setiap transaksi dalam kondisi tertentu.  Juga, dukungan untuk fungsi-C yang bekerja dengan memori di atas kotak pasir ini telah diimplementasikan untuk waktu yang lama, implementasinya dalam <a href="">kontrak EOS standar</a> .  Mungkin ada yang tidak beres pada tahap penautan. </p><br><p>  Setelah menghabiskan sekitar satu jam mencari jalan keluar, termasuk dengan bantuan salah satu mentor, kami memutuskan untuk tidak melanjutkan dan membuat solusi: tulis kode kami sendiri yang memecahkan masalah parsing angka.  Mekanisme datastream EOS tidak sesuai dengan kita: diperlukan kemampuan untuk menyimpan paket data dari struktur yang berbeda dalam satu bidang dan membentuknya dengan tangan (konfigurasi yang sangat penagihan). </p><br><h3 id="233-billing-pokupok">  2.3.3.  Tagihan belanja </h3><br><p>  Pada angin kedua, yang dibuka baik oleh insinyur listrik atau saat sarapan pagi, mereka menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tagihan</a> untuk berbelanja di toko.  Skema kerja umum adalah sebagai berikut: </p><br><ol><li>  Pemasok membuat kontrak penagihan dan menetapkannya dalam kontrak umum. </li><li>  Di outlet toko, pemasok membuat kerangka kerja yang dapat membaca RFID, berinteraksi dengan EOS dan memiliki akun sendiri yang ditentukan dalam kontrak penagihan. </li><li>  Setiap produk di toko dilengkapi dengan tag RFID, semua tag terdaftar dalam kontrak penagihan. </li><li>  Pembeli membayar barang dengan memindai RFID-nya, dan barang dihapus dari kontrak penagihan. </li><li>  Di pintu keluar dari toko, bingkai juga membaca pembelian RFID.  Jika barang masih ada di toko, transaksi tidak lulus, dan frame harus membunyikan alarm (ya, sebenarnya, Anda bahkan tidak dapat mengirim transaksi, tetapi cukup membaca tabel). </li></ol><br><p>  Tidak masuk akal untuk memikirkan kode kontrak itu sendiri: ini adalah standar C ++ 14 dengan beberapa konstruksi dan pustaka spesifik EOS.  Lebih baik dikatakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EOSIO Wiki</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Portal Pengembang EOSIO</a> . </p><br><h3 id="234-frontend">  2.3.4.  Frontend </h3><br><p>  Bagian depan dari proyek diimplementasikan menggunakan React.  Alih-alih biasanya banyak Redux memutuskan untuk menggunakan MobX, yang secara signifikan mempercepat pengembangan dan memungkinkan Anda untuk mengelola status global tanpa sakit kepala. </p><br><p>  Fase integrasi front-blockchain tidak berjalan semulus yang diharapkan.  Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eosjs sedang</a> diselesaikan dengan sangat aktif, diikuti oleh dompet EOS untuk browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scatter</a> .  Dalam kelompok ini, ini sering menyebabkan masalah.  Dan bukan fakta bahwa kode yang bekerja kemarin akan berfungsi dengan baik hari ini.  Kami menginjak menyapu ini (dan bukan yang pertama kali).  Satu jam mencoba dan men-debug dalam kondisi mengantuk - masalah terpecahkan. </p><br><p>  Pertimbangkan diagram yang disederhanakan dari interaksi sisi klien dari aplikasi dengan eos.  Untuk melakukan ini, Anda memerlukan perpustakaan eosjs dan ekstensi browser Scatter. </p><br><p>  Kami mengingatkan Anda!  Menyebarkan secara aktif diperbarui setelah eosjs, jangan lupa untuk memperbarui perpustakaan. </p><br><p>  Selanjutnya, sekilas membaca dan menulis.  Ada dua cara untuk berkomunikasi dengan kontrak pintar dalam EOS: mengirim transaksi (itu menyebabkan blockchain akan dimodifikasi, tanpa nilai pengembalian yang disediakan) dan membaca tabel (tindakan hanya baca). </p><br><p>  Pertimbangkan kode pengiriman transaksi: </p><br><pre> <code class="hljs markdown"> sendTransaction(funcName, data) { return this.scatter .suggestNetwork(this.network) .then(() =&gt; this.scatter.getIdentity({ accounts: [<span class="hljs-string"><span class="hljs-string">this.network</span></span>] })) .then((identity) =&gt; { let accountName = this.getAccountName(identity); // wrap eos instance const eos = this.scatter.eos(this.network, Eos, this.configEosInstance); return eos.transaction(accountName, (contract) =&gt; { contract[<span class="hljs-string"><span class="hljs-string">funcName</span></span>](<span class="hljs-link"><span class="hljs-link">data, { authorization: accountName }</span></span>); }); }); }</code> </pre> <br><p>  Input argumen: nama fungsi dan objek, nilainya adalah argumen fungsi ini.  Baris ketiga: kami mengkonfirmasi jaringan tempat kami berinteraksi dengan EOS.  Baris keempat: kita mendapatkan <code>identity</code> , parameternya adalah objek dengan bidang <code>accounts</code> (untuk jaringan ini).  Fungsi <code>getAccountName</code> mengembalikan akun pertama dari daftar akun yang diterima (di objek <code>identity</code> ). </p><br><p>  Dalam contoh ini, Scatter digunakan untuk menandatangani transaksi.  Scatter adalah pembungkus atas instance dari kelas <code>Eos</code> .  Pada baris 9, kita memanggil metode <code>eos</code> , parameternya: </p><br><ol><li>  <code>this.network</code> - objek dengan parameter jaringan. </li><li>  <code>Eos</code> adalah turunan dari eosjs. </li><li>  <code>this.configEosInstance</code> - objek dengan parameter untuk instance Eos (lihat dock eosjs). </li></ol><br><p>  Metode <code>transaction</code> terakhir menerima nama akun dan <code>callback</code> sebagai input, argumen <code>callback</code> adalah kontrak yang terletak di nama akun.  Dalam <code>callback</code> 'e, kita memanggil metode kontrak yang diterima dengan objek, kuncinya adalah argumen dari metode yang disebut. </p><br><p>  Pertimbangkan metode membaca tabel: </p><br><pre> <code class="hljs kotlin"> readTable(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scatter.eos(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.network, Eos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configEosInstance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eos.getTableRows({ json: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, limit: <span class="hljs-number"><span class="hljs-number">1</span></span>, ...<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, }); }</code> </pre> <br><p>  Di sini untuk membaca kita hanya perlu contoh <code>eos</code> . </p><br><p>  Untuk mendesain antarmuka, kami menjatuhkan Materialize, Semantic, dan Ant, membuat gaya sendiri.  Pada jam-jam terakhir hackathon, sebuah ide muncul untuk menghidupkan kembali UI, menambahkan visualisasi proses.  Sorot baris baru tabel selama dua detik berwarna hijau dan dapatkan efek keren harga saham.  Perbaikan secara signifikan meningkatkan daya tarik proyek dan menjadi tahap akhir membangun UI. </p><br><h1 id="3-sborka">  3. Majelis </h1><br><p>  Tiga jam sebelum akhir waktu, kami memiliki Raspberry Pi dengan meteran listrik Merkurius dan pembaca RFID yang terhubung dengannya, serta indikasi cahaya.  Semua listrik meja melewati Merkurius.  Untuk setiap 0,3125 Wh / jam yang dihabiskan, serta untuk setiap "pembelian", Raspberry Pi mengirim transaksi ke blockchain kami, dan penyedia layanan dapat mengelola pengguna, sensor, penagihan, dan melihat statistik konsumsi. </p><br><p><img src="https://habrastorage.org/webt/y6/uq/mz/y6uqmz1upvprppiimceoecejewg.jpeg"></p><br><p>  Selama satu jam lagi, kami dengan tenang melakukan cek dan menambahkan sentuhan akhir.  Dua jam sebelum akhir waktu, kami menerima produk lengkap dengan dua case yang diimplementasikan, sepenuhnya menggambarkan konsep, dan bahkan tidak ada komitmen di menit terakhir! </p><br><h1 id="4-demonstraciya">  4. Demonstrasi </h1><br><p>  Demonstrasi proyek (alias pitches) terdiri dari dua tahap.  Pada tahap pertama, 69 tim yang berpartisipasi dibagi menjadi empat kelompok, masing-masing diberi makan secara terpisah di depan dua juri dan tanpa penonton.  Para juri memberikan nilai (masing-masing empat kriteria dari 5 poin), dan berdasarkan nilai ini, 10 tim teratas dipilih untuk tahap kedua.  Tim-tim ini diberi kesempatan untuk menggelar proyek di panggung besar di depan penonton dan kedelapan hakim. </p><br><p>  Kami berakhir di kelompok pertama, hakim kami adalah CEO dan presiden (saya bertanya-tanya bagaimana posisi ini berbeda) dari Everipedia.  Tiga menit dialokasikan untuk kinerja, mereka dipantau secara ketat oleh timer.  Kami menyelesaikan ketidakkonsistenan kami, tetapi meminta untuk mengesankan pidato 30 detik lebih cepat dari jadwal.  Para hakim menanyakan sesuatu secara dangkal dan agak singkat, dan demonstrasi berakhir. </p><br><p>  Kami, yang naif, terkejut bahwa kami tidak memperhatikan kapasitas kerja produk yang sebenarnya, dan lebih lagi pada kode hakim.  Masalah implementasi teknis tidak menarik bagi mereka bahkan pada tingkat sedikit pun.  Kami juga bisa menunjukkan lampu Raspberry Pi yang berkedip dan gambar di bagian depan. </p><br><p>  Ada perasaan bahwa dengan presentasi proyek kami gagal, karena kami berharap untuk mengesankan dengan solusi aktual, prototipe, dan bukan hanya deskripsi warna-warni dari proyek yang signifikan secara sosial dan ambisius.  Semuanya dimainkan seolah-olah dengan catatan: kami menggambarkan masalah, rasa sakit, solusi kami, menunjukkan cara kerjanya, dan menggambarkan rencana pengembangan proyek.  Mengetahui sebelumnya tentang metode penilaian, kita akan melakukan banyak hal berbeda. </p><br><p>  Para juri dari empat aliran putaran pertama mengurangi skor mereka dan bertukar pandangan 15 menit setelah akhir lemparan.  Setelah pengumuman pemenang dimulai.  Suasana gugup memerintah di aula: lelah setelah maraton 26 jam, orang-orang ingin menang, ada banyak tim yang kuat, dan mereka tahu bahwa mereka dapat mengklaim kemenangan.  Dan kami tahu itu - dan menunggu hasilnya. </p><br><p>  Agar penonton tidak rileks, hasilnya diumumkan dalam tiga bagian.  Empat finalis pertama, kemudian tiga lagi, lalu tiga lainnya.  Antara pengumuman dan di akhir pertunjukan.  Kami tidak masuk ke 10 besar dan tidak mendapat kesempatan untuk memasuki panggung besar.  Dua tim berbahasa Rusia berhasil masuk dalam sepuluh besar, salah satunya akhirnya menjadi yang ketiga.  Selamat untuk para pemenang, mereka pantas mendapatkan hadiah mereka. </p><br><h1 id="5-zaklyuchenie-i-plany">  5. Kesimpulan dan rencana </h1><br><p>    AngelHack    .     ,   .     â€”  ,  ,      . ,     ,       ,      â€”   . </p><br><p>  26         IoT-   EOS.         ,   . </p><br><p>    â€”      UI (  â€”  -- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Smartz</a> ),     .  - ,     blockchain-ready  ,   , â€”    .  :) </p><br><p><img src="https://habrastorage.org/webt/1i/9q/nq/1i9qnqngvpnjizwpepz4n_b4gkc.gif"></p><br><p>   ,    ,         Â«Â», Â«Â»  . .  5           .   ,         100    ,          .            SensorPay   ! </p><br><p>     : </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Yuvasee</a>  (entrepreneur) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">algs</a>  (hardware &amp; backend developer) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">therealal</a>  (architect, backend developer, devops) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">bolbu</a>  (frontend developer) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">quantum</a>  (blockchain &amp; backend developer) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414803/">https://habr.com/ru/post/id414803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414791/index.html">Seminar "Infrastruktur virtual untuk pengembang: peluang, aplikasi dan layanan", 28 Juni, St. Petersburg</a></li>
<li><a href="../id414793/index.html">Bagaimana cara kerja saluran pembayaran dan jaringan kilat di Bitcoin?</a></li>
<li><a href="../id414797/index.html">Bagaimana kami membuat Open Lines di Bitrix24</a></li>
<li><a href="../id414799/index.html">LLTR Bagian 0: Deteksi topologi jaringan otomatis dan sakelar yang tidak dikelola. Misi Tidak Mungkin?</a></li>
<li><a href="../id414801/index.html">Moscow Vue.js Meetup # 2 di Mail.Ru Group</a></li>
<li><a href="../id414805/index.html">Buka webinar "Metode alternatif merekrut"</a></li>
<li><a href="../id414809/index.html">Swift 4.1: mengapa Apple mengganti nama flatMap menjadi compactMap</a></li>
<li><a href="../id414811/index.html">Integrasikan Telegram dan Avaya</a></li>
<li><a href="../id414813/index.html">Membuat Template di Jetbrains IDE</a></li>
<li><a href="../id414817/index.html">Nenek maya, atau bagaimana kita meretas sehari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>