<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐽 🏪 😞 Oke Google: bagaimana cara melewati captcha? 🧑🏻‍🤝‍🧑🏻 ☺️ 😀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Nama saya Ibadov Ilkin, saya mahasiswa Universitas Federal Ural. 

 Dalam artikel ini saya ingin berbicara tentang pengalaman saya dengan solusi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Oke Google: bagaimana cara melewati captcha?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449236/">  Halo  Nama saya Ibadov Ilkin, saya mahasiswa Universitas Federal Ural. <br><br>  Dalam artikel ini saya ingin berbicara tentang pengalaman saya dengan solusi otomatis untuk captcha Google - "reCAPTCHA".  Saya ingin memperingatkan pembaca sebelumnya bahwa pada saat penulisan artikel, prototipe tidak berfungsi seefisien mungkin dari judulnya, namun, hasilnya menunjukkan bahwa pendekatan yang diterapkan mampu menyelesaikan masalah. <br><a name="habracut"></a><br>  Mungkin setiap orang dalam hidup mereka telah menemukan captcha: masukkan teks dari gambar, pecahkan persamaan sederhana atau persamaan rumit, pilih mobil, hidran, penyeberangan pejalan kaki ... Diperlukan sumber daya dari sistem otomatis dan memainkan peran penting dalam keamanan: captcha melindungi terhadap serangan DDoS , pendaftaran dan posting otomatis, penguraian, mencegah pemilihan spam dan kata sandi untuk akun. <br><br><img src="https://habrastorage.org/webt/kw/la/yu/kwlayu1_wxfwcrknvshirpv8dtw.png"><br>  <font color="#999999"><i>Formulir pendaftaran "Habré" bisa dengan captcha seperti itu.</i></font> <br><br>  Dengan perkembangan teknologi pembelajaran mesin, kinerja captcha mungkin berisiko.  Pada artikel ini, saya menjelaskan poin-poin utama dari suatu program yang dapat memecahkan masalah memilih gambar secara manual di Google reCAPTCHA (untungnya, tidak selalu sejauh ini). <br><br>  Untuk melewati captcha, perlu untuk memecahkan masalah seperti: menentukan kelas captcha yang diperlukan, mendeteksi dan mengklasifikasikan objek, mendeteksi sel-sel captcha, mensimulasikan aktivitas manusia dalam menyelesaikan captcha (gerakan kursor, klik). <br><br>  Untuk mencari objek dalam suatu gambar, digunakan jaringan saraf terlatih yang dapat diunduh ke komputer dan mengenali objek dalam gambar atau video.  Tetapi untuk menyelesaikan captcha, hanya mendeteksi objek saja tidak cukup: Anda perlu menentukan posisi sel dan mencari sel mana yang ingin Anda pilih (atau tidak memilih sel sama sekali).  Untuk ini, alat visi komputer digunakan: dalam karya ini, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan OpenCV yang</a> terkenal. <br><br>  Untuk menemukan objek dalam gambar, pertama-tama, gambar itu sendiri diperlukan.  Saya mendapatkan tangkapan layar bagian layar menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyAutoGUI</a> dengan dimensi yang cukup untuk mendeteksi objek.  Di sisa layar, saya menampilkan windows untuk debugging dan memonitor proses program. <br><br><h2>  Deteksi Objek </h2><br>  Deteksi dan klasifikasi objek adalah apa yang dilakukan jaringan saraf.  Perpustakaan yang memungkinkan kita untuk bekerja dengan jaringan saraf disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tensorflow</a> " (dikembangkan oleh Google).  Saat ini, <a href="">ada banyak model terlatih untuk</a> pilihan Anda <a href="">pada data yang berbeda</a> , yang berarti bahwa semuanya dapat mengembalikan hasil deteksi yang berbeda: beberapa model akan lebih baik mendeteksi objek, dan beberapa lebih buruk. <br><br>  Dalam tulisan ini, saya menggunakan model ssd_mobilenet_v1_coco.  Model yang dipilih dilatih pada dataset <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><abbr title="Objek umum dalam konteks">COCO</abbr></a> , yang menyoroti 90 kelas yang berbeda (dari orang dan mobil hingga sikat gigi dan sisir).  Sekarang ada model lain yang dilatih pada data yang sama, tetapi dengan parameter berbeda.  Selain itu, model ini memiliki parameter kinerja dan akurasi yang optimal, yang penting untuk komputer desktop.  Sumber tersebut mengatakan bahwa waktu pemrosesan untuk satu bingkai 300 x 300 piksel adalah 30 milidetik.  Pada "Nvidia GeForce GTX TITAN X". <br><br>  Hasil dari jaringan saraf adalah satu set array: <br><br><ul><li>  dengan daftar kelas objek yang terdeteksi (pengidentifikasi mereka); </li><li>  dengan daftar peringkat objek yang terdeteksi (dalam persen); </li><li>  dengan daftar koordinat objek yang terdeteksi ("kotak"). </li></ul><br>  Indeks elemen-elemen dalam array ini bersesuaian satu sama lain, yaitu: elemen ketiga dalam array kelas objek sesuai dengan elemen ketiga dalam array "kotak" objek yang terdeteksi dan elemen ketiga dalam array peringkat objek. <br><br><img src="https://habrastorage.org/webt/g4/po/kt/g4poktayba4n3mwspffduto6d1k.png"><br>  <font color="#999999"><i>Model yang dipilih memungkinkan Anda mendeteksi objek dari 90 kelas secara real time.</i></font> <br><br><h2>  Deteksi sel </h2><br>  "OpenCV" memberi kita kemampuan untuk beroperasi dengan entitas yang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sirkuit</a> ": Mereka hanya dapat dideteksi oleh fungsi "findContours ()" dari perpustakaan "OpenCV".  Adalah perlu untuk mengirimkan gambar biner ke input dari fungsi seperti itu, yang dapat diperoleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh fungsi transformasi ambang batas</a> : <br><br><pre><code class="python hljs">_retval, binImage = cv2.threshold(image,<span class="hljs-number"><span class="hljs-number">254</span></span>,<span class="hljs-number"><span class="hljs-number">255</span></span>,cv2.THRESH_BINARY) contours = cv2.findContours(binImage, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Setelah menetapkan nilai ekstrim dari parameter fungsi transformasi ambang, kami juga menyingkirkan berbagai jenis kebisingan.  Juga, untuk meminimalkan jumlah elemen kecil dan kebisingan yang tidak perlu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transformasi morfologis</a> dapat diterapkan: fungsi erosi (kompresi) dan penumpukan (ekspansi).  Fungsi-fungsi ini juga merupakan bagian dari OpenCV.  Setelah transformasi, kontur dipilih dengan jumlah simpul empat (setelah sebelumnya melakukan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perkiraan</a> pada kontur). <br><br><img src="https://habrastorage.org/webt/mo/d3/j7/mod3j7vkdav-bchdnbxl2lycz18.png"><br>  <font color="#999999"><i>Di jendela pertama, hasil transformasi ambang batas.</i></font>  <font color="#999999"><i>Yang kedua adalah contoh transformasi morfologis.</i></font>  <font color="#999999"><i>Di jendela ketiga, sel dan tutup captcha sudah dipilih: disorot dalam warna secara terprogram.</i></font> <br><br>  Setelah semua transformasi, kontur yang bukan sel masih termasuk dalam array terakhir dengan sel.  Untuk menyaring suara yang tidak perlu, saya memilih sesuai dengan nilai panjang (perimeter) dan luas kontur. <br><br>  Secara eksperimental terungkap bahwa nilai-nilai sirkuit yang menarik berada di kisaran 360 hingga 900 unit.  Nilai ini dipilih pada layar dengan diagonal 15,6 inci dan resolusi 1366 x 768 piksel.  Selanjutnya, nilai yang ditunjukkan dari kontur dapat dihitung tergantung pada ukuran layar pengguna, tetapi tidak ada tautan seperti itu dalam prototipe yang dibuat. <br><br>  Keuntungan utama dari pendekatan yang dipilih untuk mendeteksi sel adalah bahwa kami tidak peduli seperti apa tampilan grid dan berapa banyak sel yang akan ditampilkan pada halaman captcha: 8, 9 atau 16. <br><br><img src="https://habrastorage.org/webt/oo/er/tt/ooerttikg_xree5wlre88cljjtq.png"><br>  <font color="#999999"><i>Gambar menunjukkan berbagai jaring captcha.</i></font>  <font color="#999999"><i>Harap perhatikan bahwa jarak antar sel berbeda.</i></font>  <font color="#999999"><i>Untuk memisahkan sel dari satu sama lain memungkinkan kompresi morfologis.</i></font> <br><br>  Keuntungan tambahan mendeteksi kontur adalah bahwa OpenCV memungkinkan kita untuk mendeteksi pusatnya (kita perlu mereka menentukan koordinat pergerakan dan klik mouse). <br><br><h2>  Memilih sel untuk dipilih </h2><br>  Memiliki array dengan kontur yang bersih dari sel CAPTCHA tanpa sirkuit noise yang tidak perlu, kita dapat menggilir setiap sel CAPTCHA ("sirkuit" dalam terminologi "OpenCV") dan memeriksa apakah itu berpotongan dengan "kotak" yang terdeteksi dari objek yang diterima dari jaringan saraf. <br><br>  Untuk menetapkan fakta ini, transfer "kotak" yang terdeteksi ke sirkuit yang mirip dengan sel digunakan.  Tetapi pendekatan ini ternyata salah, karena kasus ketika objek berada di dalam sel tidak dianggap persimpangan.  Secara alami, sel-sel tersebut tidak menonjol dalam captcha. <br><br>  Masalahnya dipecahkan dengan menggambar ulang garis besar setiap sel (dengan isian putih) ke lembaran hitam.  Dengan cara yang sama, gambar biner dari sebuah bingkai dengan objek diperoleh.  Timbul pertanyaan - bagaimana sekarang untuk menetapkan fakta dari persimpangan sel dengan bingkai objek yang diarsir?  Dalam setiap iterasi array dengan sel, operasi disjungsi (logis atau) dilakukan pada dua gambar biner.  Sebagai hasilnya, kami mendapatkan gambar biner baru di mana area berpotongan akan disorot.  Artinya, jika ada area seperti itu, maka sel dan bingkai objek bersinggungan.  Secara pemrograman, pemeriksaan semacam itu dapat dilakukan dengan menggunakan metode " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.any ()</a> ": ia akan mengembalikan "True" jika array memiliki setidaknya satu elemen sama dengan satu atau "False" jika tidak ada unit. <br><br><img src="https://habrastorage.org/webt/cg/8u/pb/cg8upb6izzlfukmfunjgjrzwl2y.gif"><br>  <font color="#999999"><i>Fungsi "any ()" untuk gambar "Logical OR" dalam kasus ini akan kembali benar dan dengan demikian menetapkan fakta persimpangan sel dengan area bingkai objek yang terdeteksi.</i></font> <br><br><h2>  Manajemen </h2><br>  Kontrol kursor dalam "Python" tersedia berkat modul "win32api" (namun, ternyata "PyAutoGUI" yang sudah diimpor ke proyek juga tahu bagaimana melakukan ini).  Menekan dan melepaskan tombol kiri mouse, serta menggerakkan kursor ke koordinat yang diinginkan, dilakukan oleh fungsi yang sesuai dari modul win32api.  Tetapi dalam prototipe, mereka dibungkus dengan fungsi yang ditentukan pengguna untuk memberikan pengamatan visual dari pergerakan kursor.  Ini berdampak negatif pada kinerja dan hanya diterapkan untuk demonstrasi. <br><br>  Selama proses pengembangan, muncul ide untuk memilih sel secara acak.  Ada kemungkinan bahwa ini tidak masuk akal secara praktis (untuk alasan yang jelas, Google tidak memberi kami komentar dan deskripsi tentang mekanisme operasi captcha), tetapi memindahkan kursor melalui sel-sel dalam cara yang kacau terlihat lebih menyenangkan. <br><br><img src="https://habrastorage.org/webt/p0/zh/g8/p0zhg8ii2gn0a76yj1h0vp5q5mg.gif"><br>  <font color="#999999"><i>Pada animasi, hasilnya adalah "random.shuffle (boxesForSelect)".</i></font> <br><br><h2>  Pengenalan teks </h2><br>  Untuk menggabungkan semua perkembangan yang tersedia menjadi satu keseluruhan, diperlukan satu tautan lagi: unit pengenalan untuk kelas yang diperlukan dari captcha.  Kami sudah tahu cara mengenali dan membedakan berbagai objek dalam gambar, kami dapat mengeklik sel captcha yang sewenang-wenang, tetapi kami tidak tahu sel mana yang harus diklik.  Salah satu cara untuk mengatasi masalah ini adalah mengenali teks dari heading captcha.  Pertama-tama, saya mencoba menerapkan pengenalan teks menggunakan alat pengenalan karakter optik " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tesseract-OCR</a> ". <br><br>  Dalam versi terbaru, adalah mungkin untuk menginstal paket bahasa langsung di jendela installer (sebelumnya ini dilakukan secara manual).  Setelah menginstal dan mengimpor Tesseract-OCR ke proyek saya, saya mencoba mengenali teks dari header captcha. <br><br>  Hasilnya, sayangnya, tidak membuat saya terkesan sama sekali.  Saya memutuskan bahwa teks di header disorot dalam huruf tebal dan digabung karena suatu alasan, jadi saya mencoba menerapkan berbagai transformasi pada gambar: binarisasi, penyempitan, ekspansi, pengaburan, distorsi, dan operasi pengubahan ukuran.  Sayangnya, ini tidak memberikan hasil yang baik: dalam kasus terbaik, hanya sebagian dari surat kelas ditentukan, dan ketika hasilnya memuaskan, saya menerapkan transformasi yang sama, tetapi untuk penutup lainnya (dengan teks berbeda), dan hasilnya ternyata buruk lagi. <br><br><img src="https://habrastorage.org/webt/mm/5o/zf/mm5ozfhoq5cmrwiitaig_di7ntu.png"><br>  <font color="#999999"><i>Pengakuan topi Tesseract-OCR biasanya menyebabkan hasil yang tidak memuaskan.</i></font> <br><br>  Tidak mungkin untuk mengatakan dengan tegas bahwa "Tesseract-OCR" tidak mengenali teks dengan baik, ini tidak begitu: alat mengatasi dengan gambar lain (bukan topi captcha) jauh lebih baik. <br><br>  Saya memutuskan untuk menggunakan layanan pihak ketiga yang menawarkan API untuk bekerja dengannya secara gratis (diperlukan pendaftaran dan penerimaan kunci ke alamat email).  Layanan ini memiliki batas 500 pengakuan per hari, tetapi untuk seluruh periode pengembangan saya tidak mengalami masalah dengan keterbatasan.  Sebaliknya: saya mengirimkan gambar asli dari header ke layanan (tanpa menerapkan transformasi apa pun) dan hasilnya membuat saya terkesan. <br><br>  Kata-kata dari layanan dikembalikan praktis tanpa kesalahan (biasanya bahkan yang ditulis dalam cetakan kecil).  Selain itu, mereka kembali dalam format yang sangat mudah - dipecah oleh garis dengan karakter pemecah baris.  Dalam semua gambar, saya hanya tertarik pada baris kedua, jadi saya langsung mengaksesnya.  Ini tidak bisa tidak bersukacita, karena format seperti itu membebaskan saya dari kebutuhan untuk mempersiapkan sebuah baris: Saya tidak harus memotong awal atau akhir dari keseluruhan teks, melakukan "trim", penggantian, bekerja dengan ekspresi reguler dan melakukan operasi lain pada baris, yang bertujuan menyoroti satu kata (dan terkadang dua!) - bonus bagus! <br><br><pre> <code class="python hljs">text = serviceResponse[<span class="hljs-string"><span class="hljs-string">'ParsedResults'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'ParsedText'</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   JSON lines = text.splitlines() #   print("Recognized " + lines[1]) #  !</span></span></code> </pre> <br>  Layanan yang mengenali teks hampir tidak pernah membuat kesalahan dengan nama kelas, tetapi saya masih memutuskan untuk meninggalkan sebagian nama kelas untuk kemungkinan kesalahan.  Ini opsional, tetapi saya perhatikan bahwa “Tesseract-OCR” dalam beberapa kasus salah mengenali ujung kata yang dimulai dari tengah.  Selain itu, pendekatan ini menghilangkan kesalahan aplikasi dalam kasus nama kelas panjang atau nama dua kata (dalam hal ini, layanan akan mengembalikan bukan 3, tetapi 4 baris, dan saya tidak dapat menemukan nama lengkap kelas di baris kedua). <br><br><img src="https://habrastorage.org/webt/6o/3v/nq/6o3vnqamplfdhd9byanlv4c55xw.png"><br>  <font color="#999999"><i>Layanan pihak ketiga mengenali nama kelas dengan baik tanpa ada transformasi atas gambar.</i></font> <br><br><h2>  Penggabungan </h2><br>  Mendapatkan teks dari header tidak cukup.  Ini perlu dibandingkan dengan pengidentifikasi kelas model yang tersedia, karena dalam array kelas jaringan saraf mengembalikan persis pengenal kelas, dan bukan namanya, seperti yang terlihat.  Ketika melatih model, sebagai aturan, file dibuat di mana nama kelas dan pengidentifikasi mereka dibandingkan (alias "label peta").  Saya memutuskan untuk melakukannya dengan lebih mudah dan menentukan pengidentifikasi kelas secara manual, karena captcha masih membutuhkan kelas dalam bahasa Rusia (omong-omong, ini dapat diubah): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query: <span class="hljs-comment"><span class="hljs-comment">#       classNum = 3 #   "label map"  elif "" in query: classNum = 10 elif "" in query: classNum = 11 ...</span></span></code> </pre> <br>  Semua yang dijelaskan di atas direproduksi dalam siklus utama program: bingkai objek, sel, persimpangan ditentukan, kursor bergerak dan klik.  Saat header terdeteksi, pengenalan teks dilakukan.  Jika jaringan saraf tidak dapat mendeteksi kelas yang diperlukan, maka pergeseran sewenang-wenang dari gambar dilakukan hingga 5 kali (yaitu, input ke jaringan saraf diubah), dan jika deteksi masih tidak terjadi, maka tombol "Lewati / Konfirmasi" diklik (posisinya dideteksi dengan cara yang sama mendeteksi sel dan tutup). <br><br>  Jika Anda sering memecahkan captcha, Anda bisa mengamati gambar ketika sel yang dipilih menghilang, dan yang baru perlahan-lahan muncul di tempatnya.  Karena prototipe diprogram untuk langsung pergi ke halaman berikutnya setelah memilih semua sel, saya memutuskan untuk membuat jeda 3 detik untuk mengecualikan mengklik tombol "Next" tanpa mendeteksi objek pada sel yang muncul perlahan. <br><br>  Artikel tidak akan lengkap jika tidak mengandung deskripsi hal yang paling penting - tanda centang untuk berhasil melewati captcha.  Saya memutuskan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbandingan templat</a> sederhana dapat melakukan ini.  Perlu dicatat bahwa pencocokan pola jauh dari cara terbaik untuk mendeteksi objek.  Sebagai contoh, saya harus mengatur sensitivitas deteksi ke "0,01" sehingga fungsi berhenti melihat kutu dalam segala hal, tetapi melihatnya ketika benar-benar ada kutu.  Demikian pula, saya bertindak dengan kotak centang kosong yang memenuhi pengguna dan dari mana captcha dimulai (tidak ada masalah dengan sensitivitas). <br><br><h2>  Hasil </h2><br>  Hasil dari semua tindakan yang dijelaskan adalah aplikasi, kinerja yang saya uji pada " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemanggang Roti</a> ": <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wfl1K0bqBWQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Perlu diakui bahwa video tidak direkam pada percobaan pertama, karena saya sering dihadapkan dengan kebutuhan untuk memilih kelas yang tidak ada dalam model (misalnya, penyeberangan pejalan kaki, tangga atau jendela toko). <br><br>  “Google reCAPTCHA” mengembalikan nilai tertentu ke situs, menunjukkan bagaimana “Anda adalah robot”, dan administrator situs, pada gilirannya, dapat menetapkan ambang batas untuk meneruskan nilai ini.  Ada kemungkinan bahwa ambang captcha yang relatif rendah ditetapkan pada Pemanggang.  Ini menjelaskan jalan yang agak mudah dari captcha oleh program, meskipun faktanya salah dua kali, tidak melihat lampu lalu lintas dari halaman pertama dan hidran dari halaman keempat captcha. <br><br>  Selain pemanggang roti, percobaan dilakukan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman demo</a> resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reCAPTCHA</a> .  Akibatnya, diketahui bahwa setelah beberapa deteksi salah (dan non-deteksi), mendapatkan captcha menjadi sangat sulit bahkan untuk seseorang: kelas baru diperlukan (seperti traktor dan pohon palem), sel tanpa objek muncul dalam sampel (warna hampir monoton) dan jumlah halaman meningkat secara dramatis, untuk melewati. <br><br>  Ini terutama terlihat ketika saya memutuskan untuk mencoba mengklik pada sel-sel acak dalam kasus non-deteksi objek (karena mereka tidak ada dalam model).  Karena itu, kami dapat mengatakan dengan pasti bahwa klik acak tidak akan mengarah ke solusi untuk masalah tersebut.  Untuk menghilangkan "penyumbatan" semacam itu oleh pemeriksa, kami menghubungkan kembali koneksi Internet dan membersihkan data peramban, karena menjadi tidak mungkin untuk lulus tes semacam itu - hampir tidak ada habisnya! <br><br><img src="https://habrastorage.org/webt/xk/xe/5u/xkxe5uanfylidi1jgteyb3svyoc.png"><br>  <font color="#999999"><i>Jika Anda meragukan kemanusiaan Anda, hasil seperti itu mungkin terjadi.</i></font> <br><br><h2>  Pengembangan </h2><br>  Jika artikel dan aplikasi tersebut membangkitkan minat pembaca, saya dengan senang hati akan melanjutkan penerapannya, pengujian dan uraian lebih lanjut dalam bentuk yang lebih terperinci. <br><br>  Ini adalah tentang menemukan kelas yang bukan bagian dari jaringan saat ini, ini akan sangat meningkatkan efisiensi aplikasi.  Saat ini, ada kebutuhan mendesak untuk mengenali setidaknya kelas-kelas seperti: perlintasan pejalan kaki, jendela toko, dan cerobong asap - saya akan memberi tahu Anda cara melatih ulang model.  Selama pengembangan, saya membuat daftar pendek dari kelas yang paling umum: <br><br><ul><li>  penyeberangan pejalan kaki; </li><li>  hidran api; </li><li>  jendela toko </li><li>  cerobong asap; </li><li>  mobil; </li><li>  Bus </li><li>  lampu lalu lintas; </li><li>  sepeda </li><li>  sarana transportasi; </li><li>  tangga </li><li>  tanda-tanda. </li></ul><br>  Meningkatkan kualitas deteksi objek dapat dicapai dengan menggunakan beberapa model secara bersamaan: ini dapat menurunkan kinerja, tetapi meningkatkan akurasi. <br><br>  Cara lain untuk meningkatkan kualitas deteksi objek adalah dengan mengubah input gambar ke jaringan saraf: dalam video, Anda dapat melihat bahwa ketika objek tidak terdeteksi, saya melakukan perpindahan gambar acak beberapa kali (dalam 10 piksel secara horizontal dan vertikal), dan seringkali operasi ini memungkinkan Anda melihat objek yang sebelumnya tidak terdeteksi. <br><br>  Peningkatan gambar dari kotak kecil ke kotak besar (hingga 300 x 300 piksel) juga mengarah pada deteksi objek yang tidak terdeteksi. <br><br><img src="https://habrastorage.org/webt/01/sd/eh/01sdehtdkgz_a-5gtsxh1-auhoq.png"><br>  <font color="#999999"><i>Tidak ada benda yang ditemukan di sebelah kiri: kotak asli dengan sisi 100 piksel.</i></font>  <font color="#999999"><i>Di sebelah kanan, bus terdeteksi: kotak yang diperbesar hingga 300 x 300 piksel.</i></font> <br><br>  Transformasi lain yang menarik adalah penghapusan grid putih di atas gambar menggunakan alat OpenCV: ada kemungkinan hidran tidak terdeteksi dalam video karena alasan ini (kelas ini hadir dalam jaringan saraf). <br><br><img src="https://habrastorage.org/webt/m_/7p/zu/m_7pzu93h3jqw3doy3flbtlymee.png"><br>  <font color="#999999"><i>Di sebelah kiri adalah gambar asli, dan di sebelah kanan adalah gambar yang diubah dalam editor grafik: kisi dihapus, sel-sel dipindahkan satu sama lain.</i></font> <br><br><h2>  Ringkasan </h2><br>  Dengan artikel ini, saya ingin memberi tahu Anda bahwa captcha mungkin bukan perlindungan terbaik terhadap bot, dan sangat mungkin bahwa dalam waktu dekat akan ada kebutuhan akan sarana perlindungan baru terhadap sistem otomatis. <br><br>  Prototipe yang dikembangkan, bahkan dalam keadaan belum selesai, menunjukkan bahwa dengan kelas yang diperlukan dalam model jaringan saraf dan menerapkan transformasi pada gambar, dimungkinkan untuk mencapai otomatisasi proses yang tidak boleh otomatis. <br><br>  Juga, saya ingin menarik perhatian Google pada fakta bahwa selain metode untuk menghindari captcha yang dijelaskan dalam artikel ini, ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara lain</a> di mana sampel audio <abbr title="Proses menerjemahkan audio ke teks">ditranskripsikan</abbr> .  Menurut pendapat saya, sekarang perlu untuk mengambil langkah-langkah yang berkaitan dengan peningkatan kualitas produk perangkat lunak dan algoritma terhadap robot. <br><br>  Dari isi dan esensi materi, sepertinya saya tidak suka Google dan, khususnya, reCAPTCHA, tetapi ini jauh dari kasus, dan jika ada implementasi berikutnya, saya akan memberi tahu Anda alasannya. <br><br>  Dikembangkan dan diperagakan untuk meningkatkan pendidikan dan meningkatkan metode yang bertujuan untuk memastikan keamanan informasi. <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449236/">https://habr.com/ru/post/id449236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449218/index.html">10 keterampilan penting setiap insinyur DevOps</a></li>
<li><a href="../id449220/index.html">DrumHero: Bagaimana saya membuat game pertama dalam hidup saya</a></li>
<li><a href="../id449224/index.html">Tentang bias kecerdasan buatan</a></li>
<li><a href="../id449232/index.html">Pemantauan konsumsi energi matahari oleh komputer / server</a></li>
<li><a href="../id449234/index.html">Layanan VPN Wireguard gratis di AWS</a></li>
<li><a href="../id449240/index.html">Kisah layanan Daida muda (seni berlangganan)</a></li>
<li><a href="../id449246/index.html">AX200 - Intel Wi-Fi 6</a></li>
<li><a href="../id449248/index.html">IDE modern. Jelas D, sampai batas tertentu E, dan tentu saja bukan saya</a></li>
<li><a href="../id449252/index.html">Proyek zombie - menggabungkan data pengguna bahkan setelah kematiannya</a></li>
<li><a href="../id449254/index.html">FAQ tentang arsitektur dan pekerjaan VKontakte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>