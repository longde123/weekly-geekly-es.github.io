<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜüèΩ üßëüèø üöñ Schreiben einer Snapchat-Benutzeroberfl√§che auf Swift üëÜüèª üî≤ üìî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog 


 In einem meiner Projekte musste ich eine solche Schnittstelle in Snepchat erstellen. Wenn eine Karte mit Informationen von der Kamera √ºber ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben einer Snapchat-Benutzeroberfl√§che auf Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415795/"><h2 id="prolog">  Prolog </h2><br><p> In einem meiner Projekte musste ich eine solche Schnittstelle in Snepchat erstellen.  Wenn eine Karte mit Informationen von der Kamera √ºber dem Bild verbleibt, ersetzen Sie sie reibungslos durch eine Volltonfarbe und ebenso gut in die entgegengesetzte Richtung.  Ich pers√∂nlich war besonders fasziniert vom √úbergang vom Kamerafenster zur Seitenkarte, und mit gro√üer Freude habe ich Wege aufgezeigt, um dieses Problem zu l√∂sen. </p><br><p>  Links ist ein Beispiel f√ºr Snepchat, rechts ist ein Beispiel f√ºr eine Anwendung, die wir erstellen werden. </p><br><p><img src="https://habrastorage.org/webt/es/cx/sd/escxsdlqbwqu7rfh9l9lcjjcl0a.gif"><img src="https://habrastorage.org/webt/vg/xf/8v/vgxf8vdl1gwnu0vplvu9gikqaho.gif"></p><a name="habracut"></a><br><p> Wahrscheinlich besteht die erste L√∂sung darin, die <code>UIScrollView</code> anzupassen, die Ansichten irgendwie anzuordnen, die Paginierung zu verwenden, aber ehrlich gesagt ist die Schriftrolle so konzipiert, dass sie v√∂llig andere Aufgaben l√∂st. Das Aufnehmen zus√§tzlicher Animationen ist m√ºhsam und verf√ºgt nicht √ºber die erforderliche Flexibilit√§t Einstellungen.  Daher ist es absolut ungerechtfertigt, es zur L√∂sung dieses Problems zu verwenden. </p><br><p>  Der Bildlauf zwischen dem Kamerafenster und der seitlichen Registerkarte t√§uscht - dies ist √ºberhaupt kein Bildlauf, sondern ein interaktiver √úbergang zwischen den Ansichten, die zu verschiedenen Controllern geh√∂ren.  Die Schaltfl√§chen im unteren Teil sind normale Registerkarten, auf die wir zwischen den Controllern klicken. </p><br><p><img src="https://habrastorage.org/webt/s1/xq/o7/s1xqo7xcojshfu3lqvdjiyonluk.jpeg"></p><br><p>  Auf diese Weise verwendet Snatch eine eigene Version eines Navigationscontrollers wie <code>UITabBarController</code> mit benutzerdefinierten interaktiven √úberg√§ngen. </p><br><p>  <code>UIKit</code> enth√§lt zwei Optionen f√ºr Navigationscontroller, mit denen Sie √úberg√§nge anpassen k√∂nnen: <code>UINavigationController</code> und <code>UITabBarController</code> .  Beide haben <code>navigationController(_:interactionControllerFor:)</code> und <code>tabBarController(_:interactionControllerFor:)</code> in ihren Delegaten, mit denen wir unsere eigene interaktive Animation f√ºr den √úbergang verwenden k√∂nnen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tabBarController (_: InteractionControllerFor :)</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Navigationscontroller (_: InteractionControllerFor :)</a> </p><br><p>  Aber ich m√∂chte nicht durch die Implementierung von <code>UITabBarController</code> oder <code>UINavigationController</code> , zumal wir ihre interne Logik nicht steuern k√∂nnen.  Deshalb habe ich beschlossen, meinen √§hnlichen Controller zu schreiben, und jetzt m√∂chte ich erz√§hlen und zeigen, was daraus geworden ist. </p><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p>  Erstellen Sie Ihren eigenen Container-Controller, in dem Sie mithilfe interaktiver Animationen f√ºr √úberg√§nge zwischen <code>UITabBarController</code> Controllern wechseln k√∂nnen. Verwenden Sie dazu den Standardmechanismus in <code>UITabBarController</code> und <code>UINavigationController</code> .  Wir ben√∂tigen diesen Standardmechanismus, um vorgefertigte √úbergangsanimationen vom Typ <code>UIViewControllerAnimatedTransitioning</code> bereits geschrieben wurden. </p><br><h2 id="podgotovka-proekta">  Projektvorbereitung </h2><br><p>  Normalerweise versuche ich, die Module in separate Frameworks zu verschieben. Dazu erstelle ich ein neues Anwendungsprojekt, f√ºge dort ein zus√§tzliches <code>Cocoa Touch Framework</code> Ziel hinzu und verteile dann die Quellen im Projekt f√ºr die entsprechenden Ziele.  Auf diese Weise erhalte ich ein separates Framework mit einer Testanwendung zum Debuggen. </p><br><p>  Erstellen Sie eine <code>Single View App</code> . </p><br><p><img src="https://habrastorage.org/webt/6p/eb/pa/6pebpaksin3ixvmlpse9tj7rnzs.png"></p><br><p>  <code>Product Name</code> wird unser Ziel sein. </p><br><p><img src="https://habrastorage.org/webt/aq/qv/fg/aqqvfgoimy4kv85lqjrb34tbkco.png"></p><br><p>  Klicken Sie auf <code>+</code> , um das Ziel hinzuzuf√ºgen. </p><br><p><img src="https://habrastorage.org/webt/_b/2v/vj/_b2vvjuxpzkbvcmxuo8wxsctza0.png"></p><br><p>  W√§hlen Sie <code>Cocoa Touch Framework</code> . </p><br><p><img src="https://habrastorage.org/webt/kr/mg/yy/krmgyylj_xfil50cdtejstjdpuc.png"></p><br><p>  Wir nennen unser Framework den entsprechenden Namen, Xcode w√§hlt automatisch das Projekt f√ºr unser Ziel aus und bietet an, die Bin√§rdatei direkt in die Anwendung einzubinden.  Wir sind uns einig. </p><br><p><img src="https://habrastorage.org/webt/no/xi/cn/noxicnp_oslkyxhn3qkmcaukpom.png"></p><br><p>  Wir ben√∂tigen nicht das Standard- <code>Main.storyboard</code> und <code>ViewController.swift</code> , wir l√∂schen sie. </p><br><p><img src="https://habrastorage.org/webt/_m/zq/aw/_mzqawkdo2pi9zgulfqlwnhs2vo.png"></p><br><p>  Vergessen Sie auch nicht, den Wert von der <code>Main Interface</code> im Anwendungsziel auf der Registerkarte <code>General</code> zu entfernen. </p><br><p><img src="https://habrastorage.org/webt/kt/sv/3v/ktsv3vjy_1vqgwdnkh288h4ecpc.png"></p><br><p>  Jetzt gehen wir zu <code>AppDelegate.swift</code> und <code>AppDelegate.swift</code> nur die <code>application</code> des folgenden Inhalts: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">]?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Launch our master view controller let master = MasterViewController() window = UIWindow() window?.rootViewController = master window?.makeKeyAndVisible() return true }</span></span></code> </pre> <br><p>  Hier setzen wir unseren Controller an die Hauptstelle, so dass er nach dem Launcher erscheint. </p><br><p>  Erstellen Sie jetzt <code>MasterViewController</code> diesen <code>MasterViewController</code> .  Es bezieht sich auf die Anwendung. Daher ist es wichtig, beim Erstellen der Datei das richtige Ziel auszuw√§hlen. </p><br><p><img src="https://habrastorage.org/webt/7m/0y/r8/7m0yr8cefaenhznoqbjisg7sy1q.png"></p><br><p>  Wir werden <code>MasterViewController</code> von <code>SnapchatNavigationController</code> erben, den wir sp√§ter im Framework implementieren werden.  Vergessen Sie nicht, den <code>import</code> unseres Frameworks anzugeben.  Ich gebe hier nicht den vollst√§ndigen Controller-Code an, die Auslassungen werden durch Ellipsen angezeigt <code>...</code> Ich habe die Anwendung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub platziert</a> , dort k√∂nnen Sie alle Details sehen.  In diesem Controller interessiert uns nur die <code>viewDidLoad()</code> -Methode, die den Hintergrund-Controller mit der Kamera + einem transparenten Controller (Hauptfenster) + dem Controller mit der abgehenden Karte initialisiert. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MakingSnapchatNavigation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MasterViewController</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SnapchatNavigationController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">//   let camera = CameraViewController() setBackground(vc: camera) //     var vcs: [UIViewController] = [] //    var stub = UIViewController() stub.view.backgroundColor = .clear vcs.append(stub) //  ,     stub = UIViewController() stub.view.backgroundColor = .clear //   let scroll = UIScrollView() stub.view.addSubview(scroll) //  ... //  ,      let content = GradientView() //  ... //    scroll.addSubview(content) vcs.append(stub) //     - setViewControllers(vcs: vcs) } }</span></span></code> </pre> <br><p>  Was ist hier los?  Wir erstellen einen Controller mit einer Kamera und setzen ihn mit der <code>setBackground</code> Methode von <code>SnapchatNavigationController</code> in den Hintergrund.  Dieser Controller enth√§lt ein gestrecktes Bild f√ºr die gesamte Ansicht der Kamera.  Dann erstellen wir einen leeren transparenten Controller und f√ºgen ihn dem Array hinzu. Er leitet einfach das Bild von der Kamera durch das Array. Wir k√∂nnen Steuerelemente darauf platzieren, einen weiteren transparenten Controller erstellen, einen Bildlauf hinzuf√ºgen, eine Ansicht mit Inhalten innerhalb des Bildlaufs hinzuf√ºgen und einen zweiten Controller hinzuf√ºgen Array und legen Sie dieses Array mit der speziellen <code>setViewControllers</code> Methode des √ºbergeordneten <code>SnapchatNavigationController</code> . </p><br><p>  Vergessen Sie nicht, eine Anforderung zur Verwendung der Kamera in <code>Info.plist</code> </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSCameraUsageDescription<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>Need camera for background<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  In diesem Zusammenhang betrachten wir die Testanwendung als bereit und fahren mit dem interessantesten Teil fort - der Implementierung des Frameworks. </p><br><h2 id="struktura-roditelskogo-kontrollera">  √úbergeordnete Controller-Struktur </h2><br><p>  Erstellen Sie zun√§chst einen leeren <code>SnapchatNavigationController</code> . Es ist wichtig, das richtige Ziel daf√ºr auszuw√§hlen.  Wenn alles richtig gemacht wurde, sollte die Anwendung erstellt werden.  Dieser Status des Projekts kann als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenz</a> entladen werden. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SnapchatNavigationController: UIViewController { override <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> func viewDidLoad() { super.viewDidLoad() // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> additional setup <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> loading the <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. } // MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> interface /// Sets <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setViewControllers(vcs: [UIViewController]) { } /// Sets background <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setBackground(vc: UIViewController) { } }</code> </pre> <br><p>  F√ºgen Sie nun die internen Komponenten hinzu, aus denen der Controller bestehen wird.  Ich bringe nicht den gesamten Code hierher, sondern konzentriere mich nur auf wichtige Punkte. </p><br><p>  Wir setzen die Variablen, um das Array der untergeordneten Controller zu speichern.  Jetzt stellen wir die erforderliche Menge fest ein - 2 St√ºck.  In Zukunft wird es m√∂glich sein, die Steuerungslogik f√ºr die Verwendung mit einer beliebigen Anzahl von Steuerungen zu erweitern.  Wir haben auch eine Variable festgelegt, um den angezeigten aktuellen Controller zu speichern. </p><br><pre> <code class="hljs pgsql">private let requiredChildrenAmount = <span class="hljs-number"><span class="hljs-number">2</span></span> // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> controllers /// top child <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller private var topViewController: UIViewController? /// <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> children <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers private var children: [UIViewController] = []</code> </pre> <br><p>  Erstellen Sie die Ansichten.  Wir ben√∂tigen eine Ansicht f√ºr den Hintergrund, eine Ansicht mit dem Effekt, den wir beim √Ñndern des Controllers auf den Hintergrund anwenden m√∂chten.  Wir haben auch einen Ansichtscontainer f√ºr den aktuellen untergeordneten Controller und eine Ansichtsanzeige, die dem Benutzer sagt, wie er mit der Navigation arbeiten soll. </p><br><pre> <code class="hljs bash">// MARK: - Views private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView: UIVisualEffectView = { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView = UIVisualEffectView(effect: backgroundBlurEffect) backgroundBlurEffectView.alpha = 0 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> backgroundBlurEffectView }() /// content view <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> children private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> contentViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> swipeIndicatorView = UIView()</code> </pre> <br><p>  Im n√§chsten Block setzen wir zwei Variablen, <code>swipeAnimator</code> ist f√ºr die Animation verantwortlich, <code>swipeInteractor</code> ist f√ºr die Interaktion verantwortlich (die F√§higkeit, den Fortschritt der Animation zu steuern), wir m√ºssen sie w√§hrend des Controller-Starts initialisieren, damit wir das Entpacken erzwingen. </p><br><pre> <code class="hljs erlang">// MARK: - Animation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> transition private <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeAnimator = AnimatedTransitioning() private var swipeInteractor: CustomSwipeInteractor!</code> </pre> <br><p>  Wir setzen auch die Transformation f√ºr den Indikator.  Wir verschieben den Indikator um die Breite des Containers + doppelte Verschiebung von der Kante + die Breite des Indikators selbst, so dass sich der Indikator am gegen√ºberliegenden Ende des Containers befindet.  Die Breite des Containers wird w√§hrend der Anwendung bekannt, sodass die Variable unterwegs berechnet wird. </p><br><pre> <code class="hljs pgsql">// MARK: - Animation transforms private var swipeIndicatorViewTransform: CGAffineTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGAffineTransform(translationX: -contentViewContainer.bounds.size.width + (swipeIndicatorViewXShift * <span class="hljs-number"><span class="hljs-number">2</span></span>) + swipeIndicatorViewWidth, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre> <br><p>  W√§hrend des Ladens des Controllers weisen wir der Animation <code>self</code> zu (wir implementieren das entsprechende Protokoll unten) und initialisieren den Interaktor basierend auf unserer Animation, deren Fortschritt er steuert.  Wir ernennen ihn auch zum Delegierten.  Der Delegat reagiert auf den Beginn der Geste des Benutzers und startet je nach Status des Controllers entweder die Animation oder bricht ab.  Dann f√ºgen wir alle Ansichten zur Hauptansicht hinzu und rufen <code>setupViews()</code> , wodurch die Einschr√§nkungen festgelegt werden. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() swipeAnimator.animation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swipeInteractor = <span class="hljs-type"><span class="hljs-type">CustomSwipeInteractor</span></span>(with: swipeAnimator) swipeInteractor.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view.addSubview(backgroundViewContainer) view.addSubview(backgroundBlurEffectView) view.addSubview(contentViewContainer) view.addSubview(swipeIndicatorView) setupViews() }</code> </pre> <br><p>  Als n√§chstes fahren wir mit der Logik des Installierens und Entfernens von untergeordneten Controllern in einem Container fort.  Hier ist alles so einfach wie in der Apple-Dokumentation.  Wir verwenden die f√ºr diese Art der Operation vorgeschriebenen Methoden. </p><br><p>  <code>addChildViewController(vc)</code> - <code>addChildViewController(vc)</code> dem aktuellen einen <code>addChildViewController(vc)</code> Controller hinzu. </p><br><p>  <code>contentViewContainer.addSubview(vc.view)</code> - <code>contentViewContainer.addSubview(vc.view)</code> Sie die Controller-Ansicht zur Ansichtshierarchie hinzu. </p><br><p>  <code>vc.view.frame = contentViewContainer.bounds</code> - <code>vc.view.frame = contentViewContainer.bounds</code> die Ansicht auf den gesamten Container.  Da wir hier Frames anstelle des automatischen Layouts verwenden, m√ºssen wir ihre Gr√∂√üe jedes Mal √§ndern, wenn sich die Controller-Gr√∂√üe √§ndert. Wir werden diese Logik weglassen und davon ausgehen, dass der Container die Gr√∂√üe der Anwendung nicht √§ndert, w√§hrend die Anwendung ausgef√ºhrt wird. </p><br><p>  <code>vc.didMove(toParentViewController: self)</code> - <code>vc.didMove(toParentViewController: self)</code> das Hinzuf√ºgen eines <code>vc.didMove(toParentViewController: self)</code> Controllers. </p><br><p>  <code>swipeInteractor.wireTo</code> - Wir binden den aktuellen Controller an Benutzergesten.  Sp√§ter werden wir diese Methode analysieren. </p><br><pre> <code class="hljs pgsql">// MARK: - Private methods private func addChild(vc: UIViewController) { addChildViewController(vc) contentViewContainer.addSubview(vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.frame = contentViewContainer.bounds vc.didMove(toParentViewController: self) topViewController = vc let goingRight = children.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: topViewController!) == <span class="hljs-number"><span class="hljs-number">0</span></span> swipeInteractor.wireTo(viewController: topViewController!, edge: goingRight ? .right : .left) } private func removeChild(vc: UIViewController) { vc.willMove(toParentViewController: nil) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.removeFromSuperview() vc.removeFromParentViewController() topViewController = nil }</code> </pre> <br><p>  Es gibt zwei weitere Methoden, deren Code ich hier nicht <code>setViewControllers</code> werde: <code>setViewControllers</code> und <code>setBackground</code> .  In der <code>setViewControllers</code> Methode <code>setViewControllers</code> wir einfach das Array der <code>setViewControllers</code> Controller in der entsprechenden Variablen unseres Controllers fest und rufen <code>addChild</code> auf, um einen davon in der Ansicht anzuzeigen.  In der <code>setBackground</code> Methode machen wir dasselbe wie in <code>addChild</code> , nur f√ºr den Hintergrund-Controller. </p><br><h2 id="logika-animacii-kontrollera-konteynera">  Container Controller Animationslogik </h2><br><p>  Insgesamt ist die Basis unseres √ºbergeordneten Controllers: </p><br><ul><li>  UIView ist in zwei Typen unterteilt <br><ul><li>  Container </li><li>  Gew√∂hnlich </li></ul></li><li>  Liste der untergeordneten UIViewController </li><li>  Ein Animationssteuerungsobjekt vom Typ <code>swipeAnimator</code> <code>AnimatedTransitioning</code> </li><li>  Ein Objekt, das den interaktiven Verlauf einer <code>swipeInteractor</code> Animation vom Typ <code>CustomSwipeInteractor</code> </li><li>  Interaktive Animation delegieren </li><li>  Implementierung des Animationsprotokolls </li></ul><br><p>  Jetzt werden wir die letzten beiden Punkte analysieren und dann mit der Implementierung von <code>AnimatedTransitioning</code> und <code>CustomSwipeInteractor</code> . </p><br><h3 id="delegat-interaktivnogo-hoda-animacii">  Interaktive Animation delegieren </h3><br><p>  Der Delegat besteht nur aus einer <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> Methode, die den Controller √ºber den Beginn der Geste und ihre Richtung informiert.  Als Antwort wartet er auf Informationen dar√ºber, ob die Animation als gestartet betrachtet werden kann. </p><br><p>  Als Delegierter √ºberpr√ºfen wir die aktuelle Reihenfolge der Controller, um zu verstehen, ob wir die Animation in der angegebenen Richtung starten k√∂nnen. Wenn alles in Ordnung ist, starten wir die <code>transition</code> mit den folgenden Parametern: Controller, von dem aus wir uns bewegen, Controller, Bewegungsrichtung, Interaktivit√§tsflag (Im Falle von <code>false</code> wird eine zeitlich festgelegte √úbergangsanimation ausgel√∂st). </p><br><pre> <code class="hljs julia">func panGestureDidStart(rightToLeftSwipe: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> { guard <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = topViewController, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fromIndex = children.index(of: topViewController) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = rightToLeftSwipe ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> //   -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newIndex &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; newIndex &lt; children.count &amp;&amp; newIndex != fromIndex { transition(from: children[fromIndex], to: children[newIndex], goingRight: rightToLeftSwipe, interactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  Lassen Sie uns sofort den K√∂rper der <code>transition</code> untersuchen.  Zun√§chst erstellen wir den Animationskontext f√ºr die <code>CustomControllerContext</code> Animation.  Wir werden diese Klasse auch etwas sp√§ter analysieren, da sie das <code>UIViewControllerContextTransitioning</code> Protokoll implementiert.  Im Fall von <code>UINavigationController</code> und <code>UITabBarController</code> Instanz der Implementierung dieses Protokolls automatisch vom System erstellt und seine Logik ist uns verborgen. Wir m√ºssen unsere eigene erstellen. </p><br><pre> <code class="hljs pgsql">let ctx = CustomControllerContext(fromViewController: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, toViewController: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, containerView: contentViewContainer, goingRight: goingRight) ctx.isAnimated = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ctx.isInteractive = interactive ctx.completionBlock = { (didComplete: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> didComplete { self.removeChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) self.addChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) } };</code> </pre> <br><p>  Dann rufen wir einfach entweder feste oder interaktive Animation auf.  In Zukunft wird es m√∂glich sein, eine feste an die Registerkarten der Navigation zwischen Controllern zu h√§ngen. In diesem Beispiel werden wir dies nicht tun. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interactive { // Animate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> interaction swipeInteractor.startInteractiveTransition(ctx) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Animate <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> interaction swipeAnimator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: ctx) }</code> </pre> <br><h3 id="protokol-animacii">  Animationsprotokoll </h3><br><p>  <code>TransitionAnimation</code> Animationsprotokoll besteht aus 4 Methoden: </p><br><p>  <code>addTo</code> ist eine Methode, mit der die korrekte Struktur von <code>addTo</code> Ansichten im Container erstellt wird, sodass sich die vorherige Ansicht gem√§√ü der Idee der Animation mit der neuen √ºberlappt. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Setup the views hirearchy for animation. func addTo(containerView: UIView, fromView: UIView, toView: UIView, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>prepare</code> ist die Methode, die vor der Animation aufgerufen wird, um die Ansicht vorzubereiten. </p><br><pre> <code class="hljs sql">/// Setup the views position prior to the animation start. func <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span>(fromView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: UIView?, toView <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>: UIView?, fromLeft: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>)</code> </pre> <br><p>  <code>animation</code> - die Animation selbst. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// The animation. func animation(fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>finalize</code> - die erforderlichen Aktionen nach Abschluss der Animation. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Cleanup the views position after the animation ended. func finalize(completed: Bool, fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  Wir werden die verwendete Implementierung nicht ber√ºcksichtigen, da ist dort alles ziemlich transparent, wir werden direkt zu den drei Hauptklassen gehen, dank derer die Animation stattfindet. </p><br><h2 id="class-customcontrollercontext-nsobject-uiviewcontrollercontexttransitioning"> <code>class CustomControllerContext: NSObject, UIViewControllerContextTransitioning</code> </h2> <br><p>  Der Kontext der Animation.  Zur Beschreibung seiner Funktion verweisen wir auf die Hilfe des <code>UIViewControllerContextTransitioning</code> Protokolls: </p><br><blockquote>  Ein Kontextobjekt kapselt Informationen zu den am √úbergang beteiligten Ansichten und Ansichtscontrollern.  Es enth√§lt auch Details zur Ausf√ºhrung des √úbergangs. </blockquote><p>  Das Interessanteste ist das Verbot der Anpassung dieses Protokolls: </p><br><blockquote>  √úbernehmen Sie dieses Protokoll nicht in Ihre eigenen Klassen, und erstellen Sie keine Objekte, die dieses Protokoll √ºbernehmen. </blockquote><p>  Aber wir brauchen es wirklich, um die Standard-Animations-Engine auszuf√ºhren, also passen wir es trotzdem an.  Es hat fast keine Logik, es speichert nur den Status.  Deshalb werde ich es nicht einmal hierher bringen.  Sie k√∂nnen es auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub sehen</a> . </p><br><p>  Es funktioniert hervorragend bei zeitlich festgelegten Animationen.  Bei Verwendung f√ºr interaktive Animationen tritt jedoch ein Problem auf: <code>UIPercentDrivenInteractiveTransition</code> ruft eine undokumentierte Methode f√ºr den Kontext auf.  Die einzig richtige L√∂sung in dieser Situation besteht darin, ein anderes Protokoll anzupassen - <code>UIViewControllerInteractiveTransitioning</code> , um Ihren eigenen Kontext zu verwenden. </p><br><h2 id="class-percentdriveninteractivetransition-nsobject-uiviewcontrollerinteractivetransitioning"> <code>class PercentDrivenInteractiveTransition: NSObject, UIViewControllerInteractiveTransitioning</code> </h2> <br><p>  Hier ist es - das Herzst√ºck des Projekts, das das Vorhandensein interaktiver Animationen in benutzerdefinierten Container-Controllern erm√∂glicht.  Nehmen wir es in Ordnung. </p><br><p>  Die Klasse wird mit einem Parameter vom Typ <code>UIViewControllerAnimatedTransitioning</code> . Dies ist das Standardprotokoll zum Animieren des √úbergangs zwischen Controllern.  Auf diese Weise k√∂nnen wir alle Animationen verwenden, die bereits zusammen mit unserer Klasse geschrieben wurden. </p><br><pre> <code class="hljs objectivec">init(with animator: <span class="hljs-built_in"><span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animator = animator }</code> </pre> <br><p>  Die √∂ffentliche Schnittstelle ist recht einfach, vier Methoden, deren Funktionalit√§t offensichtlich sein sollte. </p><br><p>  Man muss nur den Moment beachten, in dem die Animation startet. Wir nehmen die √ºbergeordnete Ansicht des Containers und setzen die Ebenengeschwindigkeit auf 0, damit wir den Fortschritt der Animation manuell steuern k√∂nnen. </p><br><pre> <code class="hljs pgsql">// MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) { self.transitionContext = transitionContext transitionContext.containerView.superview?.layer.speed = <span class="hljs-number"><span class="hljs-number">0</span></span> animator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: transitionContext) } func updateInteractiveTransition(percentComplete: CGFloat) { setPercentComplete(percentComplete: (CGFloat(fmaxf(fminf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(percentComplete), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)))) } func cancelInteractiveTransition() { transitionContext?.cancelInteractiveTransition() completeTransition() } func finishInteractiveTransition() { transitionContext?.finishInteractiveTransition() completeTransition() }</code> </pre> <br><p>  Wir wenden uns nun dem privaten Logikblock unserer Klasse zu. </p><br><p>  <code>setPercentComplete</code> legt den Zeitversatz des Fortschritts der Animation f√ºr die √úbersichtsebene fest und berechnet den Wert aus dem Fertigstellungsgrad und der Dauer der Animation. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPercentComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentComplete: CGFloat)</span></span></span></span> { setTimeOffset(timeOffset: <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(percentComplete) * duration) transitionContext?.updateInteractiveTransition(percentComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: TimeInterval)</span></span></span></span> { transitionContext?.containerView.superview?.layer.timeOffset = timeOffset }</code> </pre> <br><p>  <code>completeTransition</code> wird aufgerufen, wenn der Benutzer seine Geste gestoppt hat.  Hier erstellen wir eine Instanz der <code>CADisplayLink</code> Klasse, mit der wir die Animation automatisch wundersch√∂n ab dem Punkt vervollst√§ndigen k√∂nnen, an dem der Benutzer ihren Fortschritt nicht mehr kontrolliert.  Wir f√ºgen unseren <code>displayLink</code> zur <code>run loop</code> damit das System unseren Selektor immer dann aufruft, wenn ein neuer Frame auf dem Bildschirm des Ger√§ts angezeigt werden muss. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink = <span class="hljs-type"><span class="hljs-type">CADisplayLink</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(tickAnimation)) displayLink!.add(to: .main, forMode: .commonModes) }</code> </pre> <br><p>  In unserer Auswahl berechnen und stellen wir die vor√ºbergehende Verschiebung des Fortschritts der Animation ein, wie wir es zuvor w√§hrend der Geste des Benutzers getan haben, oder wir beenden die Animation, wenn sie ihren Start- oder Endpunkt erreicht. </p><br><pre> <code class="hljs coffeescript">@objc private func tickAnimation() { var timeOffset = self.timeOffset() let tick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(displayLink?.duration ?? </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * TimeInterval</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completionSpeed)</span></span></span><span class="hljs-function"> timeOffset += </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transitionContext?.transitionWasCancelled ?? </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ? -tick : tick; if </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || timeOffset &gt; duration)</span></span></span><span class="hljs-function"> { transitionFinished</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } else { setTimeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: timeOffset)</span></span></span><span class="hljs-function"> } } private func timeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> TimeInterval { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transitionContext?.containerView.superview?.layer.timeOffset ?? <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p>  Wenn Sie die Animation beendet haben, <code>displayLink</code> wir unseren <code>displayLink</code> , geben die Geschwindigkeit der Ebene zur√ºck. Wenn die Animation nicht abgebrochen wurde, <code>displayLink</code> ihren endg√ºltigen Frame erreicht hat, berechnen wir den Zeitpunkt, ab dem die Animation der Ebene beginnen soll.  Weitere Informationen hierzu finden Sie im Core Animation Programming Guide oder in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Antwort</a> auf den Stackoverflow. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transitionFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink?.invalidate() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layer = transitionContext?.containerView.superview?.layer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } layer.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasNotCanceled = !(transitionContext?.transitionWasCancelled ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasNotCanceled) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pausedTime = layer.timeOffset layer.timeOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeSincePause = layer.convertTime(<span class="hljs-type"><span class="hljs-type">CACurrentMediaTime</span></span>(), from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) - pausedTime layer.beginTime = timeSincePause } animator.animationEnded?(wasNotCanceled) }</code> </pre> <br><h2 id="class-animatedtransitioning-nsobject-uiviewcontrolleranimatedtransitioning"> <code>class AnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning</code> </h2> <br><p>  Die letzte Klasse, die wir noch nicht untersucht haben, ist die Implementierung des <code>UIViewControllerAnimatedTransitioning</code> Protokolls, in dem wir die Ausf√ºhrungsreihenfolge der Animationsprotokollmethoden <code>addTo</code> , <code>prepare</code> , <code>animation</code> , <code>addTo</code> .  Alles hier ist ziemlich prosaisch, es ist erw√§hnenswert, dass nur <code>UIViewPropertyAnimator</code> , um Animationen anstelle der typischeren <code>UIView.animate(withDuration:animations:)</code> .  Dies geschieht, damit der Fortschritt der Animation weiter gesteuert werden kann. Wenn sie abgebrochen wird, bringen Sie sie durch Aufrufen von <code>finishAnimation(at: .start)</code> an ihre urspr√ºngliche Position zur√ºck, wodurch ein unn√∂tiges Blinken des letzten Frames der Animation auf dem Bildschirm vermieden wird. </p><br><h2 id="epilog">  Nachwort </h2><br><p>  Wir haben eine funktionierende Demo einer Benutzeroberfl√§che erstellt, die der von Snapchat √§hnelt.  In meiner Version habe ich die Konstanten so konfiguriert, dass rechts und links von der Karte Felder vorhanden sind. Au√üerdem habe ich die Kamera in der Hintergrundansicht arbeiten lassen, um einen Effekt hinter der Karte zu erzeugen.  Dies dient ausschlie√ülich dazu, die F√§higkeiten dieses Ansatzes zu demonstrieren, wie er sich auf die Leistung des Ger√§ts auswirkt, und ich habe die Batterieladung nicht √ºberpr√ºft. </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Artikel ist mein erster Versuch, im Genre der technischen Literatur zu schreiben. Ich h√§tte einige wichtige Punkte √ºbersehen k√∂nnen, daher beantworte ich gerne Fragen in den Kommentaren. </font><font style="vertical-align: inherit;">Vielen Dank an alle, die meinen Artikel gelesen haben. Ich hoffe, Sie haben hier etwas N√ºtzliches f√ºr sich gefunden.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das fertige Projekt kann von GitHub unter dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heruntergeladen werden </font><font style="vertical-align: inherit;">.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nochmals vielen Dank, alle haben einen sch√∂nen Tag, interessante Aufgaben, produktive Codierung! </font></font></p><br><p><img src="https://habrastorage.org/webt/mh/se/2z/mhse2z7hfck6aicbobu-vwyi9bw.gif"></p><br><h2 id="istochniki-informacii"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informationsquellen </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um dieses Programm zu schreiben, habe ich die folgenden Informationen verwendet: </font></font></p><br><ol><li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artikel √ºber benutzerdefinierte Container View Controller-√úberg√§nge von Joachim Bondo. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Autor des Artikels schlug eine Variante des benutzerdefinierten Kontexts f√ºr Ziel C vor. Ich habe diese Variante verwendet, um meine Klasse in Swift zu schreiben. </font></font></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> </p><br></li><li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interaktiver benutzerdefinierter Container View Controller Transitions-Artikel von Alek √Östr√∂m </font></font></p><br><p>               ,   Objective C,           Swift. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> </p><br></li><li><p> <code>SwipeableTabBarController</code> </p> <br><p> ,            <code>UITabBarController</code> .      . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415795/">https://habr.com/ru/post/de415795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415783/index.html">Sternscheiben enth√ºllen uns die Geheimnisse des Auftretens von Planeten</a></li>
<li><a href="../de415785/index.html">SpaceX sendet einen Roboter mit k√ºnstlicher Intelligenz an die ISS</a></li>
<li><a href="../de415789/index.html">Patentierungsalgorithmen f√ºr Computerprogramme</a></li>
<li><a href="../de415791/index.html">Optimierung intelligenter Vertr√§ge. Wie sich Solidit√§tstypen auf die Transaktionskosten auswirken</a></li>
<li><a href="../de415793/index.html">Vollst√§ndige Anleitung zur Domain-Nachbestellung</a></li>
<li><a href="../de415797/index.html">Regul√§re Ausdr√ºcke + logische Programmierung. Was ist das Ergebnis?</a></li>
<li><a href="../de415801/index.html">Google: Unsere "Telefon" -KI ist nicht gut genug, um gef√§hrlich zu sein</a></li>
<li><a href="../de415805/index.html">Modifikation des Doorhan GSM Barrier Moduls zur Internetsteuerung</a></li>
<li><a href="../de415809/index.html">Verwendung von Soja, Requirejs und Backbone-Js in Plugins f√ºr Atlassian Jira</a></li>
<li><a href="../de415811/index.html">KI, praktischer Kurs. √úbersicht √ºber neuronale Netze zur Bildklassifizierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>