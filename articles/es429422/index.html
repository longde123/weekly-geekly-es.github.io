<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§§ üëéüèæ üî∫ UHCI, o el primer USB üëê üòµ ‚ò∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen d√≠a, querido lector! Me pidieron que escribiera sobre UHCI, bueno, escribo. 

 Puede encontrar este art√≠culo √∫til si, por ejemplo, no tiene sufic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UHCI, o el primer USB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429422/"><img src="https://habrastorage.org/webt/89/wk/ye/89wkyeuwi_jbnzlge2bawtlabum.png"><br><br>  Buen d√≠a, querido lector!  Me pidieron que escribiera sobre UHCI, bueno, escribo. <br><br>  Puede encontrar este art√≠culo √∫til si, por ejemplo, no tiene suficientes habilidades de escritura para los controladores y la lectura de la documentaci√≥n de un hardware.  Un ejemplo simple: desea escribir su sistema operativo para una mini PC, de modo que alguna distribuci√≥n de Windows u otra distribuci√≥n de Linux no descargue hardware, y utilice toda su potencia exclusivamente para sus propios fines. <br><a name="habracut"></a><br><h2>  ¬øQu√© es la UHCI? </h2><br>  Creo que, para no volver a rociar sobre el tema de qu√© y por qu√©, simplemente deje un enlace a mi art√≠culo anterior sobre EHCI.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meter aqu√≠</a> <br>  UHCI: interfaz de controlador de host universal, funciona como un dispositivo PCI, pero, a diferencia de EHCI, utiliza puertos en lugar de MMIO (Memory-Mapped-IO). <br><br><img src="https://habrastorage.org/webt/nk/bl/--/nkbl--cqrxvs21lcitfothfcw4k.png"><br><br><h2>  T√©rminos que se utilizar√°n m√°s adelante </h2><br><ul><li>  Controlador USB (USBD): el controlador USB en s√≠ </li><li>  HC (Host Controller): un controlador de host, o simplemente nuestro UHCI </li><li>  Host Controller Driver (HCD): un controlador que conecta hardware y USBD </li><li>  Dispositivo USB: dispositivo USB en s√≠ </li></ul><br><h2>  Tipos de transferencia de datos </h2><br>  Is√≥crono: transmisi√≥n isos√≠ncrona, que tiene una frecuencia dada de transferencia de datos.  Se puede usar, por ejemplo, para micr√≥fonos USB, etc. <br><br>  Interrupci√≥n: peque√±as transferencias de datos espont√°neas desde un dispositivo.  El tipo de transmisi√≥n de interrupci√≥n admite dispositivos que requieren un intervalo de servicio predecible pero que no necesariamente proporcionan un flujo de datos predecible.  Com√∫nmente utilizado para dispositivos como teclados y dispositivos se√±aladores que pueden no proporcionar datos durante per√≠odos prolongados de tiempo, pero requieren una respuesta r√°pida cuando tienen datos para enviar. <br><br>  Control: tipo de transmisi√≥n de informaci√≥n sobre el estado del dispositivo, el estado y la configuraci√≥n.  El tipo de transferencia de Control se utiliza para proporcionar un canal de control desde el Host a los dispositivos USB.  Las transmisiones de control siempre consisten en una fase de configuraci√≥n y cero o m√°s fases de datos seguidas de una fase de estado.  Es imperativo que la transferencia de control a un punto final dado se procese en modo FIFO.  Si el control se pasa al mismo punto final, el intercalado puede conducir a un comportamiento impredecible. <br><br>  Granel: tipo de transferencia de matrices de datos.  Usado, por ejemplo, en dispositivos MassStorage. <br><br><img src="https://habrastorage.org/webt/j1/d5/4a/j1d54aqfs0iicr_-dfpmkwx8d_e.png"><br><br>  As√≠ es como se ve la distribuci√≥n de tiempo de 1 ms: procesamiento de un cuadro. <br><br><h2>  Distribuci√≥n del tiempo </h2><br>  El controlador host admite la entrega de datos en tiempo real al generar un paquete de inicio de trama (SOF) cada 1 ms.  Se genera un paquete SOF cuando caduca el contador SOF en el controlador host (Figura 3).  El controlador host inicializa el contador SOF durante un tiempo de trama de 1 ms.  Se pueden hacer peque√±os cambios en este valor (y, por lo tanto, en el per√≠odo de tiempo del cuadro) programando el registro de cambios SOF.  Esta caracter√≠stica le permite realizar cambios menores en el per√≠odo de tiempo del cuadro, si es necesario, para mantener la sincronizaci√≥n en tiempo real en todo el sistema USB. <br><br>  El controlador de host incluye el n√∫mero de trama en cada paquete SOF.  Este n√∫mero de trama determina de manera √∫nica el per√≠odo de trama en tiempo real.  La condici√≥n de fin de trama (EOF) ocurre al final del intervalo de tiempo de 1 ms cuando el controlador host inicia el siguiente tiempo de trama, generando otro paquete SOF con el n√∫mero de trama correspondiente.  Durante el per√≠odo de trama, los datos se transmiten como paquetes de informaci√≥n.  El controlador de host impone estrictamente el per√≠odo de tiempo de trama, y ‚Äã‚Äãlos paquetes de datos en la trama actual no pueden ir m√°s all√° del EOF (consulte el Cap√≠tulo 11 en la especificaci√≥n USB).  El controlador host admite la sincronizaci√≥n de la transmisi√≥n de datos entre cuadros en tiempo real, vinculando el n√∫mero de cuadro para realizar una entrada espec√≠fica en la lista de cuadros.  El contador de trama del controlador host genera un n√∫mero de trama (valor de 11 bits) y lo incluye en cada paquete SOF.  El contador se programa a trav√©s de registros y cada per√≠odo de trama se incrementa.  El controlador host utiliza los 10 bits inferiores del n√∫mero de cuadro como √≠ndice en la lista de cuadros con 1024 cuadros, que se almacena en la memoria del sistema.  Por lo tanto, dado que el contador de cuadros controla la selecci√≥n de una entrada de la lista de cuadros, el controlador host procesa cada entrada en la lista en un per√≠odo de cuadro dado.  El controlador de host se expande a la siguiente entrada en la lista de cuadros para cada nuevo cuadro.  Esto asegura que las transmisiones is√≥cronas se realicen en una trama espec√≠fica. <br><br>  Figura 3: <br><br><img src="https://habrastorage.org/webt/d8/pj/iw/d8pjiwyjanx3yse7tmmtnyeooqe.png"><br><br><h2>  Estructura UHCI </h2><br>  Todo es exactamente igual que con EHCI.  Ejemplo de solicitudes a HC: <br><br><img src="https://habrastorage.org/webt/io/1d/sm/io1dsmtielklqhm84nhekufybj4.png"><br><br><h2>  Configurar y acceder a UHCI </h2><br>  Y as√≠, como dije antes, UHCI funciona a trav√©s de puertos, por lo que desde PCI necesitamos encontrar la base de los registros UHCI. <br><br><img src="https://habrastorage.org/webt/gz/ql/3f/gzql3fejuar2ko92q8dnok-ehpi.png"><br><br>  En el desplazamiento 0x20 hay 4 bytes: IO Base.  Con respecto a IO Base, podemos usar los siguientes registros: <br><br><img src="https://habrastorage.org/webt/jk/a5/od/jka5odl_cbgmqxcdsix8e-1tkl0.png"><br><br><h2>  Registros UHCI </h2><br><ul><li>  USBCMD es un registro para controlar HC.  Bits <ul><li>  El bit 6 es un indicador de que el dispositivo est√° configurado e inicializado con √©xito. </li><li>  Bit 1 - Reinicio HC.  Establecer para restablecer HC. </li><li>  Bit 0 - Ejecutar / Parar.  Muestra el estado de HC.  1 - funciona, 0 - no. </li></ul></li><li>  USBSTS - Registro de estado.  Bits <ul><li>  Bit 5 - HC detenido.  Se ha producido un error o el controlador ha completado con √©xito el restablecimiento de HC. </li><li>  Bit 4: error de proceso del controlador host.  El bit se establece en 1 cuando se produce un error cr√≠tico y HC no puede continuar haciendo cola y TD. </li><li>  Bit 3: error del sistema host.  Error de PCI. </li><li>  Bit 1 - Interrupci√≥n de error.  Indica que se ha producido un error y que el HC gener√≥ una interrupci√≥n. </li><li>  Bit 0 - Interrupci√≥n.  Indica que HC gener√≥ una interrupci√≥n. </li></ul></li><li>  USBINTR - Registro de configuraciones de interrupci√≥n.  Bits <ul><li>  Bit 2 - IOC - Interrupci√≥n al completar - genera una interrupci√≥n al final de la transacci√≥n. </li></ul></li><li>  FRNUM - N√∫mero del cuadro actual (T√≥melo y 0x3FF para el valor correcto). </li><li>  FLBASEADD - Direcci√≥n base de la lista de cuadros - direcci√≥n de la lista de cuadros. </li><li>  PORTSC - Estado y control de puertos - registro de estado y control de puertos.  Bits <ul><li>  Bit 9 - Restablecimiento de puerto - 1 - puerto para restablecer. </li><li>  Bit 8: indica que un dispositivo de baja velocidad est√° conectado al puerto </li><li>  Bit 3: indica que el puerto en estado ha cambiado </li><li>  Bit 2: indica si el puerto est√° habilitado </li><li>  Bit 1: indica que el estado del dispositivo est√° conectado al puerto </li><li>  Bit 0: indica que el dispositivo est√° conectado al puerto. </li></ul></li></ul><br><h2>  Estructuras </h2><br><h3>  Puntero de lista de cuadros </h3><br><img src="https://habrastorage.org/webt/oc/y8/a6/ocy8a6is-xd60i9bxmtdjjyqcdy.png"><br><br><h3>  Descriptor de transferencia </h3><br><img src="https://habrastorage.org/webt/jz/sh/bl/jzshblpig4inzxxtzkzxlmvsvq8.png"><br><br><h5>  TD CONTROL Y ESTADO </h5>  .  Bits <br><ul><li>  Bits 28-27 - contador de errores, similar a EHCI. </li><li><ul><li>  Bit 26 - 1 = Dispositivo de baja velocidad, 0 = Dispositivo de velocidad completa. </li><li>  Bit 25-1 = TD isos√≠ncrono </li><li>  Bit 24 - COI </li><li>  Bits 23-16 - Estado: </li><li>  Bit 23: indica que es un TD activo </li><li>  Bit 22 - Atascado </li><li>  Bit 21 - Error de b√∫fer de datos </li><li>  Bit 20: balbuceo detectado </li><li>  Bit 19 - NAK </li></ul></li><li>  Bits 10‚Äì0: el n√∫mero de bytes transmitidos por el controlador de host. </li></ul><br><h5>  Token TD </h5><br><ul><li>  Bits 31:21 - Max Packet Len, similar a EHCI </li><li>  Bit 19: alternancia de datos, similar a EHCI </li><li>  Bits 18:15 - N√∫mero de punto final </li><li>  Bits 18:14 - direcci√≥n del dispositivo </li><li>  Bits 7: 0 - PID.  In = 0x69, Out = 0xE1, Setup = 0x2D </li></ul><br><h3>  Cabeza de la cola </h3><br><img src="https://habrastorage.org/webt/-4/pb/ia/-4pbiakp01iozcmkne4q1tums4i.png"><br><br><h2>  C√≥digo </h2><br>  Inicializar y configurar HC: <br><br><pre><code class="cpp hljs">PciBar bar; PciGetBar(&amp;bar, id, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~bar.flags &amp; PCI_BAR_IO) { <span class="hljs-comment"><span class="hljs-comment">// Only Port I/O supported return; } unsigned int ioAddr = bar.u.port; UhciController *hc = VMAlloc(sizeof(UhciController)); hc-&gt;ioAddr = ioAddr; hc-&gt;frameList = VMAlloc(1024 * sizeof(u32) + 8292); hc-&gt;frameList = ((int)hc-&gt;frameList / 4096) * 4096 + 4096; hc-&gt;qhPool = (UhciQH *)VMAlloc(sizeof(UhciQH) * MAX_QH + 8292); hc-&gt;qhPool = ((int)hc-&gt;qhPool / 4096) * 4096 + 4096; hc-&gt;tdPool = (UhciTD *)VMAlloc(sizeof(UhciTD) * MAX_TD + 8292); hc-&gt;tdPool = ((int)hc-&gt;tdPool / 4096) * 4096 + 4096; memset(hc-&gt;qhPool, 0, sizeof(UhciQH) * MAX_QH); memset(hc-&gt;tdPool, 0, sizeof(UhciTD) * MAX_TD); memset(hc-&gt;frameList, 0, 4 * 1024); // Frame list setup UhciQH *qh = UhciAllocQH(hc); qh-&gt;head = TD_PTR_TERMINATE; qh-&gt;element = TD_PTR_TERMINATE; qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;asyncQH = qh; for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = 2 | (u32)(uintptr_t)qh; IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); IoWrite16(hc-&gt;ioAddr + REG_CMD, IoRead16(hc-&gt;ioAddr + REG_CMD)&amp;(~1)); unsigned short cfg = PciRead16(id, 4); PciWrite16(id, 4, cfg &amp; (~1)); PciWrite16(id, 0x20, (short)-1); unsigned short size = ~(PciRead16(id, 0x20)&amp;(~3)) + 1; PciWrite16(id, 0x20, hc-&gt;ioAddr); PciWrite16(id, 4, cfg | 5); // Disable Legacy Support IoWrite16(hc-&gt;ioAddr + REG_LEGSUP, 0x8f00); // Disable interrupts IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); // Assign frame list IoWrite16(hc-&gt;ioAddr + REG_FRNUM, 0); IoWrite32(hc-&gt;ioAddr + REG_FRBASEADD, (int)hc-&gt;frameList); IoWrite16(hc-&gt;ioAddr + REG_SOFMOD, 0x40); // Clear status IoWrite16(hc-&gt;ioAddr + REG_STS, 0xffff); // Enable controller IoWrite16(hc-&gt;ioAddr + REG_CMD, 0x1); // Probe devices UhciProbe(hc, size);</span></span></code> </pre> <br>  Puntos finales y solicitudes de control: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static void UhciDevControl(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = 0; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { return; } UhciTD *head = td; UhciTD *prev = 0; // Setup packet uint toggle = 0; uint packetType = TD_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_IN : TD_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; while (it &lt; end) { td = UhciAllocTD(hc); if (!td) { return; } toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) { packetSize = maxSize; } UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet td = UhciAllocTD(hc); if (!td) { return; } toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_OUT : TD_PACKET_IN; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, 0, 0); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Wait until queue has been processed UhciInsertQH(hc, qh); UhciWaitForQH(hc, qh); } // ------------------------------------------------------------------------------------------------ static void UhciDevIntr(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } UhciTD *head = td; UhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = TD_PACKET_IN; //Here for compiler, on some last expression hadn't worked if (t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80) packetType = TD_PACKET_IN; else packetType = TD_PACKET_OUT; uint packetSize = t-&gt;len; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Schedule queue UhciInsertQH(hc, qh); if(t-&gt;w) UhciWaitForQH(hc, qh); }</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429422/">https://habr.com/ru/post/es429422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486156/index.html">Da habe ich unterrichtet und dann ein Trainingshandbuch in Python geschrieben</a></li>
<li><a href="../de486158/index.html">Visualisierung der neuronalen maschinellen √úbersetzung (seq2seq-Modelle mit Aufmerksamkeitsmechanismus)</a></li>
<li><a href="../de486164/index.html">Coronavirus 2019-nCoV. FAQ zu Atemschutz und Desinfektion</a></li>
<li><a href="../de486174/index.html">Ich habe keinen Umsatz</a></li>
<li><a href="../es429420/index.html">La PlayStation Classic utiliza el emulador PCSX ReARMed para su funcionamiento, sin soluciones patentadas</a></li>
<li><a href="../es429424/index.html">Robotaxi de Daimler y Bosch aparecer√° en California</a></li>
<li><a href="../es429426/index.html">QGIS y exportaci√≥n de mosaicos</a></li>
<li><a href="../es429448/index.html">Escribimos el cargador FPGA en LabVIEW. Parte 2</a></li>
<li><a href="../es429450/index.html">T√©cnicas de programaci√≥n generalizadas en Rust: c√≥mo traducimos Exonum de Iron a actix-web</a></li>
<li><a href="../es429452/index.html">El Pent√°gono comenz√≥ a desclasificar el malware de otras personas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>