<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¶ üë∞üèø üßòüèª Sistema flex√≠vel para testar e coletar m√©tricas de programas usando o conjunto de testes LLVM como exemplo üë©üèø‚Äçüî¨ üßôüèΩ ‚òùüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 A maioria dos desenvolvedores ouviu claramente alguns desenvolvimentos de c√≥digo aberto bastante significativos, como o sistema LLVM e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema flex√≠vel para testar e coletar m√©tricas de programas usando o conjunto de testes LLVM como exemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428421/"><h2>  1. Introdu√ß√£o </h2><br>  A maioria dos desenvolvedores ouviu claramente alguns desenvolvimentos de c√≥digo aberto bastante significativos, como o sistema LLVM e o compilador clang.  No entanto, o LLVM agora n√£o √© apenas o sistema propriamente dito para a cria√ß√£o de compiladores, mas tamb√©m um grande ecossistema que inclui muitos projetos para solucionar v√°rios problemas que surgem durante qualquer est√°gio da cria√ß√£o do compilador (geralmente cada um desses projetos tem seu pr√≥prio reposit√≥rio separado).  Parte da infraestrutura inclui naturalmente ferramentas de teste e benchmarking, como  ao desenvolver um compilador, sua efic√°cia √© um indicador muito importante.  Um desses projetos individuais de infraestrutura de teste do LLVM √© o conjunto de testes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o oficial</a> ). <br><br><h2>  Conjunto de teste LLVM </h2><br>  √Ä primeira vista, no reposit√≥rio do conjunto de testes, parece que este √© apenas um conjunto de benchmarks em C / C ++, mas isso n√£o √© inteiramente verdade.  Al√©m do c√≥digo fonte dos programas nos quais as medi√ß√µes de desempenho ser√£o realizadas, o conjunto de testes inclui uma infraestrutura flex√≠vel para criar, executar e coletar m√©tricas.  Por padr√£o, ele coleta as seguintes m√©tricas: tempo de compila√ß√£o, tempo de execu√ß√£o, tempo do link, tamanho do c√≥digo (em se√ß√µes). <br><a name="habracut"></a><br>  O conjunto de testes √© naturalmente √∫til para compiladores de teste e de benchmarking, mas tamb√©m pode ser usado para outras tarefas de pesquisa em que √© necess√°ria alguma base de c√≥digo C / C ++.  Aqueles que fizeram tentativas de fazer algo no campo da an√°lise de dados, acho, enfrentaram o problema da falta e fragmenta√ß√£o dos dados de origem.  Um conjunto de testes, embora n√£o seja composto por um grande n√∫mero de aplicativos, mas possui um mecanismo unificado de coleta de dados.  Adicionando seus pr√≥prios aplicativos √† cole√ß√£o, √© muito simples coletar as m√©tricas necess√°rias para sua tarefa espec√≠fica.  Portanto, na minha opini√£o, o conjunto de testes (al√©m das principais tarefas de teste e benchmarking) √© uma boa op√ß√£o para um projeto b√°sico, com base no qual voc√™ pode criar sua pr√≥pria coleta de dados para tarefas nas quais √© necess√°rio analisar alguns recursos do c√≥digo do programa ou algumas caracter√≠sticas dos programas. <br><br><h3>  Estrutura do conjunto de testes LLVM </h3><br><pre><code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite |----CMakeLists.txt //  CMake ,   ,  | //   .. | |---- cmake | |---- .modules //        , | //   API    | |---- litsupport //  Python,      <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite, | //    lit (  LLVM) | |---- tools //   :    | //     (    | // ),    .. | | //     | |---- SingleSource //   ,       | // .        . | |---- MultiSource //   ,      | //  .        | //  . | |---- MicroBenchmarks // ,   google-benchmark.   | //  ,    ,  | //       | |---- External //    ,     <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite,  | // ,     (  ) | // -   </code> </pre> <br>  A estrutura √© simples e direta. <br><br><h3>  Princ√≠pio de funcionamento </h3><br>  Como voc√™ pode ver, o CMake e um formato especial de lit-test s√£o respons√°veis ‚Äã‚Äãpor todo o trabalho de descri√ß√£o da montagem, lan√ßamento e coleta de m√©tricas. <br><br>  Se considerarmos de uma maneira muito abstrata, fica claro que o processo de benchmarking usando esse sistema parece simples e muito previs√≠vel: <br><img src="https://habrastorage.org/webt/5p/ny/s8/5pnys8slvpcfavbmriofq4lymrs.jpeg"><br><br>  Como isso se parece com mais detalhes?  Neste artigo, gostaria de me debru√ßar sobre exatamente qual papel o CMake desempenha em todo o sistema e qual √© o √∫nico arquivo que voc√™ deve escrever se desejar adicionar algo a este sistema. <br><br>  <b>1. Construindo aplicativos de teste.</b> <br><br>  Como um sistema de compila√ß√£o, tornou-se o padr√£o de fato para os programas C / C ++ CMake.  O CMake configura o projeto e gera arquivos make, ninja etc., dependendo das prefer√™ncias do usu√°rio.  para constru√ß√£o direta. <br>  No entanto, no conjunto de testes, o CMake gera n√£o apenas regras sobre como criar aplicativos, mas tamb√©m configura os pr√≥prios testes. <br><br>  Depois de iniciar o CMake, outros arquivos (com a extens√£o .test) ser√£o gravados no diret√≥rio build com uma descri√ß√£o de como o aplicativo deve ser executado e verificado se est√° correto. <br><br>  Exemplo do arquivo .test mais padr√£o <br><br><pre> <code class="cmake hljs">RUN: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football/football VERIFY: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/tools/fpcmp %o football.reference_output</code> </pre><br>  O arquivo com a extens√£o .test pode conter as seguintes se√ß√µes: <br><br><ul><li>  PREPARE - descreve todas as a√ß√µes que devem ser executadas antes do lan√ßamento do aplicativo, muito semelhante ao m√©todo Before existente em diferentes estruturas de teste de unidade; </li><li>  EXECUTAR - descreve como executar o aplicativo; </li><li>  VERIFICAR - descreve como verificar o funcionamento correto do aplicativo; </li><li>  METRIC - descreve as m√©tricas que precisam ser coletadas adicionalmente no padr√£o. </li></ul><br>  Qualquer uma dessas se√ß√µes pode ser omitida. <br><br>  Por√©m, como esse arquivo √© gerado automaticamente, ele est√° no arquivo CMake da refer√™ncia que descreve: como obter os arquivos de objeto, como mont√°-los em um aplicativo e o que fazer com esse aplicativo. <br><br>  Para uma melhor compreens√£o do comportamento padr√£o e como isso √© descrito, considere um exemplo de alguns CMakeLists.txt <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CFLAGS -DBREAK_HANDLER -DUNICODE-pthread) <span class="hljs-comment"><span class="hljs-comment">#      (         ..     CMak,       ) list(APPEND LDFLAGS -lstdc++ -pthread) #      </span></span></code> </pre><br>  Os sinalizadores podem ser configurados dependendo da plataforma, o arquivo DetectArchitecture √© inclu√≠do nos m√≥dulos cmake da su√≠te de testes, que determina a plataforma de destino na qual os benchmarks s√£o executados, para que voc√™ possa simplesmente usar os dados j√° coletados.  Outros dados tamb√©m est√£o dispon√≠veis: sistema operacional, ordem de bytes, etc. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TARGET_OS <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DC_LINUX) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ARCH <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ARM"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"little"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"big"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>()</code> </pre><br>  Em princ√≠pio, esta parte n√£o deve ser novidade para pessoas que viram ou gravaram pelo menos uma vez um simples arquivo CMake.  Naturalmente, voc√™ pode usar as bibliotecas, constru√≠-las por conta pr√≥pria, em geral, usar todos os meios fornecidos pelo CMake para descrever o processo de cria√ß√£o de seu aplicativo. <br><br>  E ent√£o voc√™ precisa garantir a gera√ß√£o do arquivo .test.  Quais ferramentas a interface tets-suite fornece para isso? <br><br>  Existem 2 macros b√°sicas <b>llvm_multisource</b> e <b>llvm_singlesource</b> , suficientes para a maioria dos casos triviais. <br><br><ul><li>  <b>llvm_multisource ser√°</b> usado se o aplicativo consistir em v√°rios arquivos.  Se voc√™ n√£o passar os arquivos de c√≥digo-fonte como par√¢metros ao chamar essa macro no seu CMake, todos os arquivos de c√≥digo-fonte localizados no diret√≥rio atual ser√£o usados ‚Äã‚Äãcomo base para a constru√ß√£o.  De fato, atualmente est√£o ocorrendo altera√ß√µes na interface dessa macro no conjunto de testes, e o m√©todo descrito para transferir arquivos de origem como par√¢metros de macro √© a vers√£o atual localizada na ramifica√ß√£o principal.  Anteriormente, havia outro sistema: os arquivos com c√≥digo fonte tinham que ser gravados na vari√°vel Source (como na vers√£o 7.0), e a macro n√£o aceitava nenhum par√¢metro.  Mas a l√≥gica b√°sica da implementa√ß√£o permaneceu a mesma. </li><li>  <b>O llvm_singlesource</b> considera que cada arquivo .c / .cpp √© uma refer√™ncia separada e, para cada um, coleta um arquivo execut√°vel separado. </li></ul><br>  Por padr√£o, as duas macros descritas acima para iniciar um aplicativo criado geram um comando que simplesmente chama esse aplicativo.  E a verifica√ß√£o √© realizada comparando-se com a sa√≠da esperada, que est√° no arquivo com a extens√£o .reference_output (tamb√©m com os poss√≠veis sufixos .reference_output.little-endian, .reference_output.big-endian). <br><br>  Se isso lhe conv√©m, √© √≥timo, uma linha extra (chamando llvm_multisource ou llvm_singlesource) √© suficiente para voc√™ iniciar o aplicativo e obter as seguintes m√©tricas: tamanho do c√≥digo (em se√ß√µes), tempo de compila√ß√£o, tempo do link, tempo de execu√ß√£o. <br><br>  Mas, √© claro, isso raramente acontece dessa maneira.  Pode ser necess√°rio alterar um ou mais est√°gios.  E isso tamb√©m √© poss√≠vel com a ajuda de a√ß√µes simples.  A √∫nica coisa que voc√™ precisa lembrar √© que, se voc√™ redefinir um determinado est√°gio, precisar√° descrever todos os outros (mesmo que o algoritmo padr√£o do trabalho deles seja satisfeito, o que, √© claro, √© um pouco perturbador). <br><br>  Existem macros na API para descrever a√ß√µes em cada est√°gio. <br><br>  <b>N√£o h√°</b> muito o que escrever sobre a macro <b>llvm_test_prepare</b> para o est√°gio preparat√≥rio; os comandos que voc√™ precisa executar s√£o simplesmente passados ‚Äã‚Äãpara l√° como par√¢metro. <br><br>  O que pode ser necess√°rio na se√ß√£o de lan√ßamento?  O caso mais previs√≠vel √© que o aplicativo aceita alguns argumentos, arquivos de entrada.  Para isso, existe a macro <b>llvm_test_run</b> , que aceita apenas os argumentos de inicializa√ß√£o do aplicativo (sem o nome do arquivo execut√°vel) como par√¢metros. <br><br><pre> <code class="cmake hljs">llvm_test_run(--fixed <span class="hljs-number"><span class="hljs-number">400</span></span> --cpu <span class="hljs-number"><span class="hljs-number">1</span></span> --num <span class="hljs-number"><span class="hljs-number">200000</span></span> --seed <span class="hljs-number"><span class="hljs-number">1158818515</span></span> run.hmm)</code> </pre><br>  Para alterar as a√ß√µes no est√°gio de valida√ß√£o, √© <b>usada a</b> macro <b>llvm_test_verify</b> , que aceita todos os comandos como par√¢metros.  Obviamente, para verificar a corre√ß√£o, √© melhor usar as ferramentas inclu√≠das na pasta de ferramentas.  Eles fornecem boas oportunidades para comparar a sa√≠da gerada com a esperada (existe um processamento separado para comparar n√∫meros reais com algum erro, etc.).  Mas voc√™ pode em algum lugar e basta verificar se o aplicativo foi conclu√≠do com √™xito etc. <br><br><pre> <code class="cmake hljs">llvm_test_verify(<span class="hljs-string"><span class="hljs-string">"cat %o | grep -q 'exit 0'"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># %o -   placeholder   ,   lit.          lit,    ,    .    lit (  ,   LLVM)      (   &lt;a href="https://llvm.org/docs/CommandGuide/lit.html"&gt; &lt;/a&gt;)</span></span></code> </pre><br>  Mas e se houver a necessidade de coletar algumas m√©tricas adicionais?  Existe uma macro <b>llvm_test_metric</b> para <b>isso</b> . <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC &lt; &gt; &lt;,   &gt;)</code> </pre><br>  Por exemplo, para dhrystone, uma m√©trica espec√≠fica pode ser obtida. <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC dhry_score grep 'Dhrystones per Second' %o | awk '{print $<span class="hljs-number"><span class="hljs-number">4</span></span>}')</code> </pre><br>  Obviamente, se voc√™ precisar coletar m√©tricas adicionais para todos os testes, esse m√©todo ser√° um pouco inconveniente.  Voc√™ precisa adicionar a chamada llvm_test_metric √†s macros de n√≠vel superior fornecidas pela interface ou pode usar TEST_SUITE_RUN_UNDER (a vari√°vel CMake) e um script espec√≠fico para coletar m√©tricas.  A vari√°vel TEST_SUITE_RUN_UNDER √© bastante √∫til e pode ser usada, por exemplo, para rodar em simuladores, etc.  De fato, um comando √© gravado nele que aceitar√° o aplicativo com seus argumentos como uma entrada. <br><br>  Como resultado, obtemos alguns CMakeLists.txt do formul√°rio <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#       llvm_test_run(--fixed 400 --cpu 1 --num 200000 --seed 1158818515 run.hmm) llvm_test_verify("cat %o | grep -q 'exit 0'") llvm_test_metric(METRIC score grep 'Score' %o | awk '{print $4}') llvm_multisource() # llvm_multisource(my_application)   </span></span></code> </pre><br>  A integra√ß√£o n√£o requer esfor√ßos adicionais, se o aplicativo j√° estiver criado usando o CMake, em CMakeList.txt no conjunto de teste, voc√™ poder√° incluir o CMake existente para montagem e adicionar algumas chamadas de macro simples. <br><br>  <b>2. Executando testes</b> <br><br>  Como resultado de seu trabalho, o CMake gerou um arquivo de teste especial de acordo com a descri√ß√£o especificada.  Mas como esse arquivo √© executado? <br><br>  lit sempre usa algum arquivo de configura√ß√£o lit.cfg, que existe, portanto, no conjunto de teste.  Nesse arquivo de configura√ß√£o, s√£o indicadas v√°rias configura√ß√µes para a execu√ß√£o de testes, incluindo o formato dos testes execut√°veis.  O conjunto de testes usa seu pr√≥prio formato, localizado na pasta litsupport. <br><br><pre> <code class="python hljs">config.test_format = litsupport.test.TestSuiteTest()</code> </pre> <br>  Esse formato √© descrito como uma classe de teste herdada do teste padr√£o aceso e substituindo o m√©todo principal da interface de execu√ß√£o.  Tamb√©m componentes importantes do litsupport s√£o uma classe com uma descri√ß√£o do plano de execu√ß√£o de teste do TestPlan, que armazena todos os comandos que devem ser executados em diferentes est√°gios e conhece a ordem dos est√°gios.  Para fornecer a flexibilidade necess√°ria, os m√≥dulos tamb√©m foram introduzidos na arquitetura que deve fornecer o m√©todo mutatePlan, dentro do qual eles podem alterar o plano de teste, apenas introduzindo uma descri√ß√£o da cole√ß√£o das m√©tricas necess√°rias, adicionando comandos adicionais para medir o tempo para iniciar o aplicativo, etc.  Devido a essa solu√ß√£o, a arquitetura est√° se expandindo bem. <br><br><img src="https://habrastorage.org/webt/a_/s4/6y/a_s46ygow0ah-bmfzx9jkezdysg.png"><br><br>  Um exemplo da opera√ß√£o de teste do conjunto de testes (com exce√ß√£o dos detalhes na forma de classes TestContext, v√°rias configura√ß√µes acesas e os pr√≥prios testes, etc.) √© apresentado abaixo. <br><br><img src="https://habrastorage.org/webt/5b/k9/1a/5bk91asgtn8ivhsr4pehhczdgrw.png"><br><br>  Aceso faz com que o tipo de teste especificado no arquivo de configura√ß√£o seja executado.  TestSuiteTest analisa o arquivo de teste CMake gerado, recebendo uma descri√ß√£o dos est√°gios principais.  Ent√£o, todos os m√≥dulos encontrados s√£o chamados para alterar o plano de teste atual, o lan√ßamento √© instrumentado.  Em seguida, o plano de teste recebido √© executado: eles s√£o executados na ordem do est√°gio de prepara√ß√£o, lan√ßamento e valida√ß√£o.  Se necess√°rio, a cria√ß√£o de perfil pode ser executada (adicionada por um dos m√≥dulos, se uma vari√°vel foi configurada durante a configura√ß√£o que indica a necessidade de cria√ß√£o de perfil).  A pr√≥xima etapa √© coletar m√©tricas, as fun√ß√µes de coleta adicionadas pelos m√≥dulos padr√£o no campo metric_collectors no TestPlan e, em seguida, as m√©tricas adicionais descritas pelo usu√°rio no CMake. <br><br>  <b>3. Executando o conjunto de testes</b> <br><br>  Existem duas maneiras de executar o conjunto de testes: <br><br><ul><li>  Manual, ou seja,  invoca√ß√£o seq√ºencial de comandos. <pre> <code class="bash hljs">cmake -DCMAKE_CXX_COMPILER:FILEPATH=clang++ -DCMAKE_C_COMPILER:FILEPATH=clang <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-comment"><span class="hljs-comment">#  make #   llvm-lit . -o &lt;output&gt; #  </span></span></code> </pre></li><li>  usando o LNT (outro sistema do ecossistema LLVM que permite executar benchmarks, salvar resultados no banco de dados, analisar os resultados na interface da web).  O LNT, dentro de sua equipe de execu√ß√£o de teste, executa as mesmas etapas do par√°grafo anterior. <br><pre> <code class="bash hljs">lnt runtest <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite --sandbox SANDBOX --cc clang --cxx clang++ --<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite</code> </pre> </li></ul><br>  O resultado para cada teste √© exibido como <br><br><pre> <code class="bash hljs">PASS: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test (m of n) ********** TEST <span class="hljs-string"><span class="hljs-string">'test-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test'</span></span> RESULTS ********** compile_time: 1.1120 exec_time: 0.0014 <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: <span class="hljs-string"><span class="hljs-string">"38254c7947642d1adb9d2f1200dbddf7"</span></span> link_time: 0.0240 size: 59784 size..bss: 99800 ‚Ä¶ size..text: 37778 **********</code> </pre><br>  Os resultados de diferentes lan√ßamentos podem ser comparados sem o LNT (embora essa estrutura forne√ßa grandes oportunidades para analisar informa√ß√µes usando diferentes ferramentas, mas precise de uma revis√£o separada), usando o script inclu√≠do no conjunto de teste <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py results_a.json results_b.json</code> </pre> <br>  Um exemplo de compara√ß√£o do tamanho do c√≥digo de um e o mesmo benchmark de dois lan√ßamentos: com os sinalizadores -O3 e -Os <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py -m size SANDBOX1/build/O3.json SANDBOX/build/Os.json Tests: 1 Metric: size Program O3 Os diff <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite...langs-C/football/football.test 59784 47496 -20.6%</code> </pre><br><h2>  Conclus√£o </h2><br>  A infra-estrutura para descrever e executar benchmarks implementados no conjunto de testes √© f√°cil de usar e oferecer suporte, dimensiona-se bem e, em princ√≠pio, na minha opini√£o, ele usa solu√ß√µes bastante elegantes em sua arquitetura, o que, √© claro, torna o conjunto de testes uma ferramenta muito √∫til para desenvolvedores compiladores, bem como esse sistema, podem ser modificados para uso em algumas tarefas de an√°lise de dados. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428421/">https://habr.com/ru/post/pt428421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428411/index.html">Radar de tecnologia: uma lista de idiomas, ferramentas e plataformas que passaram pelas m√£os de Lamoda</a></li>
<li><a href="../pt428413/index.html">Sistemas de refrigera√ß√£o nos data centers Selectel</a></li>
<li><a href="../pt428415/index.html">Vis√£o geral do controlador de nuvem TP-Link Omada OC200</a></li>
<li><a href="../pt428417/index.html">Aprendizado de m√°quina no MatLab / Oitava: exemplos de algoritmos suportados por f√≥rmulas</a></li>
<li><a href="../pt428419/index.html">Arraste e deslize o dedo no RecyclerView. Parte 2: arraste e solte controladores, grades e anima√ß√µes personalizadas</a></li>
<li><a href="../pt428423/index.html">Como um acordo de US $ 34 bilh√µes entre a IBM e a Red Hat mudar√° o mercado de TI: especialistas e analistas</a></li>
<li><a href="../pt428429/index.html">GOST R 34.10 assinatura eletr√¥nica de documentos PDF no pacote do escrit√≥rio LibreOffice</a></li>
<li><a href="../pt428431/index.html">Mais do que camadas conc√™ntricas</a></li>
<li><a href="../pt428433/index.html">Advogados particulares</a></li>
<li><a href="../pt428435/index.html">O que ler em PHP em russo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>