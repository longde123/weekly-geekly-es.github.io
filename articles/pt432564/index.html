<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüéì üöç üîî Rust 2018 saiu ... mas o que √©? üà∏ üßëüèæ üç∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo foi escrito por Lin Clarke em colabora√ß√£o com a equipe de desenvolvimento Rust (‚Äún√≥s‚Äù no texto). Voc√™ tamb√©m pode ler a postagem no blog o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 2018 saiu ... mas o que √©?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432564/"> Este artigo foi escrito por Lin Clarke em colabora√ß√£o com a equipe de desenvolvimento Rust (‚Äún√≥s‚Äù no texto).  Voc√™ tamb√©m pode ler a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem</a> no blog oficial da Rust. <br><br>  A primeira vers√£o do Rust 2018 foi lan√ßada em 6 de dezembro de 2018. Nesta vers√£o, focamos na produtividade para que os desenvolvedores do Rust passassem a trabalhar da maneira mais eficiente poss√≠vel. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">A linha do tempo mostra a transi√ß√£o do beta para o Rust 2018 e o Rust 2015. Ela √© cercada por √≠cones de ferramentas e quatro √°reas: WebAssembly, incorporado, rede e CLI.</font></i>  <i><font color="gray">O c√≠rculo vermelho - produtividade do desenvolvedor - envolve tudo, exceto o Rust 2015</font></i> <br><br>  Mas, em geral, n√£o √© f√°cil explicar o que √© Rust 2018. <br><br>  Alguns a apresentam como uma nova vers√£o da linguagem ... algo assim, mas n√£o realmente.  Eu digo "n√£o realmente", porque aqui a "nova vers√£o" n√£o significa as novas vers√µes de outros idiomas. <br><a name="habracut"></a><br>  Na maioria dos outros idiomas, todos os novos recursos adicionam uma nova vers√£o.  A vers√£o anterior n√£o √© atualizada. <br><br>  O sistema Rust opera de maneira diferente.  Isto √© devido √† forma como a linguagem se desenvolve.  Quase todos os novos recursos s√£o 100% compat√≠veis com o Rust.  Eles n√£o exigem nenhuma altera√ß√£o.  Isso significa que n√£o h√° raz√£o para limit√°-los ao c√≥digo do Rust 2018. As vers√µes mais recentes do compilador continuar√£o suportando o "modo Rust 2015" por padr√£o. <br><br>  Mas, √†s vezes, o desenvolvimento de uma linguagem requer inova√ß√£o, por exemplo, uma nova sintaxe.  E essa nova sintaxe pode quebrar as bases de c√≥digo existentes. <br><br>  Por exemplo, a fun√ß√£o <code>async/await</code> .  Inicialmente, n√£o havia tais conceitos no Rust.  Por√©m, essas primitivas s√£o realmente √∫teis, pois simplificam a grava√ß√£o de c√≥digo ass√≠ncrono. <br><br>  Para esta fun√ß√£o, as palavras <code>async</code> chave <code>async</code> e <code>await</code> devem ser adicionadas.  Mas voc√™ deve tomar cuidado para n√£o quebrar o c√≥digo antigo, onde <code>async</code> ou <code>await</code> podem ser usados ‚Äã‚Äãcomo nomes de vari√°veis. <br><br>  Assim, adicionamos palavras-chave no Rust 2018. Embora a fun√ß√£o ainda n√£o tenha sido lan√ßada, as palavras-chave agora est√£o reservadas.  Todas as altera√ß√µes incompat√≠veis para os pr√≥ximos tr√™s anos de desenvolvimento (por exemplo, adicionando novas palavras-chave) s√£o feitas por vez no Rust 1.31. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Embora haja altera√ß√µes incompat√≠veis no Rust 2018, isso n√£o significa que seu c√≥digo ser√° quebrado.  Mesmo com vari√°veis <code>async</code> e <code>await</code> , o c√≥digo ser√° compilado.  Por padr√£o, o compilador funciona como antes. <br><br>  Mas se voc√™ quiser usar uma das novas fun√ß√µes, poder√° escolher o novo modo de compila√ß√£o do Rust 2018. O comando <code>cargo fix</code> ir√° informar se voc√™ precisa atualizar o c√≥digo para usar as novas fun√ß√µes e automatizar o processo de fazer altera√ß√µes.  Em seguida, voc√™ pode adicionar <code>edition=2018</code> ao seu Cargo.toml se concordar com o uso de novas fun√ß√µes. <br><br>  Esse especificador de vers√£o no Cargo.toml n√£o se aplica a todo o projeto e n√£o se aplica √†s suas depend√™ncias.  √â limitado a um rack espec√≠fico.  Ou seja, voc√™ pode usar as caixas Rust 2015 e Rust 2018 ao mesmo tempo. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Portanto, mesmo ao usar o Rust 2018, tudo se parece com o Rust 2015. A maioria das altera√ß√µes √© introduzida simultaneamente no Rust 2018 e no Rust 2015. Apenas algumas fun√ß√µes exigem altera√ß√µes incompat√≠veis. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  O Rust 2018 n√£o √© apenas uma mudan√ßa no idioma principal.  Longe n√£o apenas eles. <br><br>  O Rust 2018 √©, antes de tudo, um √≠mpeto para melhorar a produtividade dos desenvolvedores do Rust, em grande parte gra√ßas a ferramentas que est√£o fora da linguagem, al√©m do desenvolvimento de aplicativos espec√≠ficos e do entendimento de como tornar o Rust a linguagem de programa√ß√£o mais eficaz para esses casos. <br><br>  Assim, voc√™ pode representar o Rust 2018 como um especificador no Cargo.toml, que √© usado para incluir v√°rias fun√ß√µes que exigem altera√ß√µes incompat√≠veis ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  Ou voc√™ pode imagin√°-lo em um momento em que o Rust se torna uma das linguagens mais eficientes para muitos aplicativos - quando voc√™ precisa de desempenho, uso eficiente dos recursos ou alta confiabilidade. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  N√≥s preferimos a segunda vers√£o da defini√ß√£o.  Ent√£o, vamos olhar para todas as melhorias feitas fora do idioma e depois mergulhar no pr√≥prio idioma. <br><br><h1>  Ferrugem para aplica√ß√µes espec√≠ficas </h1><br>  Uma linguagem de programa√ß√£o n√£o pode ser eficaz em si mesma, abstratamente.  √â eficaz em uma aplica√ß√£o espec√≠fica.  Portanto, entendemos que n√£o era apenas necess√°rio melhorar o Rust como uma linguagem ou ferramenta.  Tamb√©m √© necess√°rio simplificar o uso do Rust em certas √°reas. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  Em alguns casos, isso significava criar um conjunto de ferramentas completamente novo para um ecossistema completamente novo.  Em outros casos, polir as fun√ß√µes existentes e a boa documenta√ß√£o para facilitar a cria√ß√£o e a execu√ß√£o de um sistema em funcionamento. <br><br>  A equipe de desenvolvimento da Rust formou grupos de trabalho em quatro √°reas: <br><br><ul><li>  Webassembly </li><li>  Aplicativos Incorporados </li><li>  Tarefas de rede </li><li>  Ferramentas de linha de comando </li></ul><br><h2>  Webassembly </h2><br>  O WebAssembly teve que criar um conjunto completamente novo de ferramentas. <br><br>  Somente no ano passado o WebAssembly tornou poss√≠vel compilar idiomas como o Rust para rodar na Internet.  Desde ent√£o, o Rust se tornou rapidamente o melhor idioma para integra√ß√£o com aplicativos da web existentes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  O Rust √© adequado para o desenvolvimento da Web por dois motivos: <br><br><ol><li>  O Ecossistema Cargo Crash funciona da maneira que a maioria dos desenvolvedores de aplicativos da web est√° acostumada.  Combine v√°rios m√≥dulos pequenos para formar um aplicativo maior.  Isso significa que o Rust √© f√°cil de usar exatamente onde voc√™ precisa. </li><li>  A ferrugem √© baixa em recursos e n√£o requer tempo de execu√ß√£o.  Voc√™ n√£o precisa de muito c√≥digo.  Se voc√™ possui um m√≥dulo min√∫sculo que trabalha muito com computa√ß√£o pesada, implemente algumas linhas Rust para agiliz√°-lo. </li></ol><br>  Usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">web-sys e js-sys</a> do c√≥digo Rust, √© f√°cil chamar APIs da web, como <code>fetch</code> ou <code>appendChild</code> .  E o <code>wasm-bindgen</code> facilita o suporte a tipos de dados de n√≠vel superior aos quais o WebAssembly n√£o oferece suporte nativo. <br><br>  Ap√≥s escrever o m√≥dulo Rust WebAssembly, existem ferramentas para conect√°-lo facilmente ao restante do aplicativo da web.  Voc√™ pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wasm-pack</a> para ativar automaticamente essas ferramentas e executar o m√≥dulo no npm, se desejar. <br><br>  Veja o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livro Rust and WebAssembly para obter mais informa√ß√µes</a> . <br><br><h4>  O que vem a seguir? </h4><br>  Ap√≥s o lan√ßamento do Rust 2018, os desenvolvedores planejam discutir com a comunidade quais as dire√ß√µes a seguir. <br><br><h2>  Aplicativos Incorporados </h2><br>  Para o desenvolvimento incorporado, era necess√°rio aumentar a estabilidade da funcionalidade existente. <br><br>  Teoricamente, o Rust sempre foi uma boa linguagem para aplicativos incorporados.  Este √© um kit de ferramentas moderno, que faltava muito para os desenvolvedores e fun√ß√µes de linguagem de alto n√≠vel muito convenientes.  Tudo isso sem carga desnecess√°ria na CPU e na mem√≥ria.  Assim, o Rust √© √≥timo para embutidos. <br><br>  Mas, na pr√°tica, ficou diferente.  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal est√°vel</a> n√£o possu√≠a as fun√ß√µes necess√°rias.  Al√©m disso, para uso em dispositivos incorporados, era necess√°rio alterar a biblioteca padr√£o.  Isso significa que as pessoas precisavam compilar sua pr√≥pria vers√£o do engradado principal do Rust (o engradado usado em todos os aplicativos Rust para fornecer os blocos b√°sicos de constru√ß√£o do Rust - fun√ß√µes integradas e primitivas). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  Como resultado, os desenvolvedores dependiam da vers√£o experimental do Rust.  E, na aus√™ncia de testes autom√°ticos, a montagem experimental geralmente n√£o funcionava em microcontroladores. <br><br>  Para corrigir isso, os desenvolvedores tentaram transferir todas as fun√ß√µes necess√°rias para um canal est√°vel, adicionar testes ao sistema de CI para microcontroladores.  Isso significa que alterar um componente da √°rea de trabalho n√£o interromper√° a vers√£o interna. <br><br>  Com essas mudan√ßas, o desenvolvimento de sistemas embarcados no Rust est√° passando do campo de experimentos avan√ßados para o campo da efici√™ncia normal. <br><br>  Para obter mais informa√ß√µes, consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livro Rust for Embedded Systems</a> . <br><br><h4>  O que vem a seguir? </h4><br>  Este ano, Rust obteve um suporte realmente bom para a popular fam√≠lia ARM Cortex-M.  No entanto, muitas arquiteturas ainda n√£o s√£o bem suportadas.  A ferrugem precisa ser expandida para fornecer suporte semelhante para outras arquiteturas. <br><br><h2>  Tarefas de rede </h2><br>  Para trabalhar na rede, foi necess√°rio incorporar uma abstra√ß√£o importante no idioma: <code>async/await</code> .  Assim, os desenvolvedores podem usar express√µes padr√£o do Rust, mesmo em c√≥digo ass√≠ncrono. <br><br>  Nas tarefas de rede, voc√™ geralmente precisa esperar.  Por exemplo, uma resposta a uma solicita√ß√£o.  Se o c√≥digo for s√≠ncrono, o trabalho ser√° interrompido: o n√∫cleo do processador no qual o c√≥digo √© executado n√£o poder√° fazer nada at√© que uma solicita√ß√£o chegue.  Mas no c√≥digo ass√≠ncrono, essa fun√ß√£o pode ser colocada no modo de espera, enquanto o n√∫cleo da CPU faz o resto. <br><br>  A programa√ß√£o ass√≠ncrona tamb√©m √© poss√≠vel no Rust 2015, e h√° muitas vantagens nisso.  Em aplicativos de alto desempenho, o aplicativo do servidor manipula muito mais conex√µes com cada servidor.  Os aplicativos incorporados em pequenas CPUs de thread √∫nico otimizam o uso de um √∫nico thread. <br><br>  Mas essas vantagens s√£o acompanhadas de uma grande desvantagem: para esse c√≥digo, a verifica√ß√£o do empr√©stimo n√£o funciona e voc√™ precisa usar idiomas de ferrugem n√£o padr√£o (e um pouco confusos).  Esse √© o benef√≠cio de <code>async/await</code> .  Isso fornece ao compilador as informa√ß√µes necess√°rias para testar empr√©stimos de chamadas de fun√ß√£o ass√≠ncronas. <br><br>  Palavras-chave para <code>async/await</code> implementadas na vers√£o 1.31, embora n√£o sejam atualmente suportadas pela implementa√ß√£o.  A maior parte do trabalho est√° conclu√≠da e o recurso deve estar dispon√≠vel na pr√≥xima vers√£o. <br><br><h4>  O que vem a seguir? </h4><br>  Al√©m do desenvolvimento eficaz de baixo n√≠vel, o Rust pode fornecer um desenvolvimento mais eficiente de aplicativos de rede em um n√≠vel superior. <br><br>  Muitos servidores realizam tarefas de rotina: analisam URLs ou trabalham com HTTP.  Se voc√™ transform√°-los em componentes - abstra√ß√µes comuns que s√£o compartilhadas como caixas -, ser√° f√°cil conect√°-los uns aos outros, formando todos os tipos de configura√ß√µes de servidor e estrutura. <br><br>  Uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura</a> experimental de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mar√©s foi</a> criada para desenvolver e testar componentes. <br><br><h2>  Ferramentas de linha de comando </h2><br>  Para ferramentas de linha de comando, era necess√°rio combinar pequenas bibliotecas de baixo n√≠vel em abstra√ß√µes de n√≠vel superior e polir algumas ferramentas existentes. <br><br>  Para alguns scripts, o bash √© ideal.  Por exemplo, simplesmente invocar outras ferramentas de shell e passar dados entre elas. <br><br>  Mas o Rust √© uma √≥tima op√ß√£o para muitas outras ferramentas.  Por exemplo, se voc√™ criar uma ferramenta complexa como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ripgrep</a> ou uma ferramenta CLI sobre a funcionalidade de uma biblioteca existente. <br><br>  O Rust n√£o requer um tempo de execu√ß√£o e √© compilado em um √∫nico bin√°rio est√°tico, o que simplifica a distribui√ß√£o do programa.  E voc√™ obt√©m abstra√ß√µes de alto n√≠vel que n√£o est√£o em outros idiomas, como C e C ++. <br><br>  O que mais pode melhorar a ferrugem?  Claro, abstra√ß√µes de um n√≠vel ainda mais alto. <br><br>  Com abstra√ß√µes de n√≠vel superior, uma CLI pronta √© montada r√°pida e facilmente. <br><br>  Um exemplo dessa abstra√ß√£o √© a biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√¢nico humano</a> .  Na aus√™ncia dessa biblioteca, no caso de uma falha, o c√≥digo da CLI provavelmente retornar√° todo o retorno.  Mas n√£o √© muito interessante para os usu√°rios.  Voc√™ pode adicionar tratamento de erros personalizado, mas √© dif√≠cil. <br><br>  Com a biblioteca de p√¢nico humano, a sa√≠da ir√° automaticamente para o arquivo de despejo de erro.  O usu√°rio ver√° uma mensagem informativa oferecendo a relatar um problema e fazer o download do arquivo de despejo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Come√ßar a desenvolver ferramentas CLI tamb√©m se tornou mais f√°cil.  Por exemplo, a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confy</a> automatiza sua configura√ß√£o.  Ele pede apenas duas coisas: <br><br><ul><li>  Qual √© o nome do aplicativo? </li><li>  Quais par√¢metros de configura√ß√£o voc√™ deseja fornecer (que voc√™ define como uma estrutura que pode ser serializada e desserializada)? </li></ul><br>  O Confy determinar√° tudo o mais por si pr√≥prio. <br><br><h4>  O que vem a seguir? </h4><br>  Abstra√≠mos muitas tarefas para a CLI.  Mas h√° algo mais a abstrair.  Vamos lan√ßar mais bibliotecas de alto n√≠vel. <br><br><h1>  Ferramentas de ferrugem </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  Ao escrever em qualquer idioma, voc√™ trabalha com suas ferramentas: come√ßando com o editor e continuando com outras ferramentas em todos os est√°gios de desenvolvimento e suporte. <br><br>  Isso significa que uma linguagem eficaz depende de ferramentas eficazes. <br><br>  Aqui est√£o algumas novas ferramentas (e melhorias nas j√° existentes) no Rust 2018. <br><br><h2>  Suporte IDE </h2><br>  Obviamente, o desempenho depende da transfer√™ncia r√°pida e suave de c√≥digo da mente do desenvolvedor para a tela do computador.  √â aqui que o suporte ao IDE √© crucial.  Para fazer isso, precisamos de ferramentas que possam "explicar" o IDE para o significado do c√≥digo Rust: por exemplo, sugira op√ß√µes significativas para o preenchimento autom√°tico de strings. <br><br>  No Rust 2018, a comunidade se concentrou nos recursos exigidos pelo IDE.  Com o advento do Rust Language Server e do IntelliJ Rust, muitos IDEs agora oferecem suporte total ao Rust. <br><br><h2>  Compila√ß√£o mais r√°pida </h2><br>  Melhorar o desempenho do compilador significa aceler√°-lo.  Foi o que fizemos. <br><br>  Anteriormente, quando voc√™ compilava o engradado Rust, o compilador recompilava cada arquivo √∫nico no engradado.  A compila√ß√£o incremental agora est√° implementada: ele compila apenas as partes que foram alteradas.  Juntamente com outras otimiza√ß√µes, isso tornou o compilador Rust muito mais r√°pido. <br><br><h2>  rustfmt </h2><br>  A efici√™ncia tamb√©m exige que nunca discutamos sobre regras de formata√ß√£o de c√≥digo nem corrijamos manualmente os estilos de outras pessoas. <br><br>  A ferramenta rustfmt ajuda com isso: reformata automaticamente o c√≥digo de acordo com o estilo padr√£o (pelo qual a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunidade alcan√ßou consenso</a> ).  O Rustfmt garante que todo o c√≥digo Rust corresponda ao mesmo estilo, como o formato clang para C ++ ou Prettier for JavaScript. <br><br><h2>  Clippy </h2><br>  √Äs vezes, √© bom ter um consultor experiente por perto, dando conselhos sobre as melhores pr√°ticas para escrever c√≥digo.  √â isso que Clippy faz: verifica o c√≥digo enquanto o exibe e sugere idiomas padr√£o. <br><br><h2>  ferrugem </h2><br>  Mas se voc√™ tiver uma base de c√≥digo antiga com idiomas desatualizados, verifique e corrija independentemente o c√≥digo pode ser cansativo.  Voc√™ s√≥ quer que algu√©m fa√ßa corre√ß√µes em toda a base de c√≥digo. <br><br>  Nesses casos, o rustfix automatiza o processo.  Aplica simultaneamente regras de ferramentas como Clippy e atualiza o c√≥digo antigo de acordo com os idiomas do Rust 2018. <br><br><h1>  Altera√ß√µes no pr√≥prio Rust </h1><br>  Mudan√ßas no ecossistema aumentaram significativamente a efici√™ncia da programa√ß√£o.  Mas alguns problemas podem ser resolvidos apenas por mudan√ßas no pr√≥prio idioma. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  Como dissemos na introdu√ß√£o, a maioria das altera√ß√µes de idioma √© totalmente compat√≠vel com o c√≥digo Rust existente.  Todas essas mudan√ßas fazem parte do Rust 2018. Mas, como n√£o quebram nada, elas funcionam em qualquer c√≥digo Rust ... mesmo no antigo. <br><br>  Vamos dar uma olhada nos recursos importantes adicionados a todas as vers√µes.  Veja uma pequena lista de recursos do Rust 2018. <br><br><h2>  Novos recursos para todas as vers√µes </h2><br>  Aqui est√° um pequeno exemplo dos novos recursos que s√£o (ou ser√£o) em todas as vers√µes do idioma. <br><br><h4>  Verifica√ß√£o de empr√©stimo mais precisa </h4><br>  Uma grande vantagem do Rust √© a verifica√ß√£o de empr√©stimos.  Ele garante que o c√≥digo seja seguro para a mem√≥ria.  Mas esse tamb√©m √© um recurso bastante complicado para iniciantes no Rust. <br><br>  Parte da dificuldade est√° em aprender novos conceitos.  Mas h√° outra parte ... O teste de empr√©stimos √†s vezes rejeita c√≥digo que parece funcionar do ponto de vista de um programador que entende completamente o conceito de seguran√ßa de mem√≥ria. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">Voc√™ n√£o pode emprestar uma vari√°vel porque ela j√° est√° emprestada</font></i> <br><br>  Isso acontece porque o tempo de vida do empr√©stimo deveria se estender at√© o final de seu campo - por exemplo, at√© o final da fun√ß√£o em que a vari√°vel est√° localizada. <br><br>  Isso significa que, mesmo que a vari√°vel termine de trabalhar com o valor e n√£o tente mais acessar, outras vari√°veis ‚Äã‚Äãainda ter√£o acesso negado a esse valor at√© o final da fun√ß√£o. <br><br>  Para corrigir a situa√ß√£o, tornamos a verifica√ß√£o mais inteligente.  Agora ela v√™ quando a vari√°vel <i>realmente</i> terminou de usar o valor.  Depois disso, ele n√£o bloqueia o uso de dados. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  Embora isso esteja dispon√≠vel apenas no Rust 2018, mas em um futuro pr√≥ximo a fun√ß√£o ser√° adicionada a todas as outras vers√µes.  Em breve iremos escrever mais sobre este t√≥pico. <br><br><h4>  Macros processuais em ferrugem est√°vel </h4><br>  O Rust tinha macros antes do Rust 1.0.  Mas no Rust 2018, melhorias s√©rias foram feitas, por exemplo, macros processuais apareceram.  Eles permitem que voc√™ adicione sua pr√≥pria sintaxe ao Rust. <br><br>  O Rust 2018 oferece dois tipos de macros processuais: <br><br><h4>  Macros de fun√ß√£o </h4><br>  Macros de fun√ß√£o permitem criar objetos que se parecem com chamadas de fun√ß√£o normais, mas s√£o realmente executados em tempo de compila√ß√£o.  Eles pegam um c√≥digo e distribuem outro, que o compilador insere no bin√°rio. <br><br>  Eles existiam antes, mas com limita√ß√µes.  Uma macro s√≥ pode executar a instru√ß√£o de correspond√™ncia.  Ele n√£o teve acesso para visualizar todos os tokens no c√≥digo recebido. <br><br>  Mas com macros procedurais, voc√™ obt√©m a mesma entrada que o analisador: o mesmo fluxo de tokens.  Isso significa que voc√™ pode criar macros muito mais poderosas, como fun√ß√µes. <br><br><h4>  Macros semelhantes a atributos </h4><br>  Se voc√™ estiver familiarizado com decoradores em idiomas como JavaScript, as macros de atributo s√£o muito semelhantes.  Eles permitem que voc√™ anote fragmentos do c√≥digo Rust que devem ser pr√©-processados ‚Äã‚Äãe transformados em outra coisa. <br><br>  A macro <code>derive</code> faz exatamente isso.  Quando voc√™ a coloca sobre uma estrutura, o compilador pega essa estrutura (depois de analisada como uma lista de tokens) e a processa.  Em particular, ele adiciona uma implementa√ß√£o b√°sica de fun√ß√µes da caracter√≠stica. <br><br><h4>  Empr√©stimos mais ergon√¥micos nas compara√ß√µes </h4><br>  H√° uma mudan√ßa simples. <br><br>  Antes, se voc√™ queria emprestar algo e tentava fazer a correspond√™ncia, era necess√°rio adicionar uma sintaxe estranha: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Agora, em vez de <code>&amp;Some(ref s)</code> simplesmente escrevemos <code>Some(s)</code> . <br><br><h1>  Novos recursos do Rust 2018 </h1><br>  A menor parte do Rust 2018 √© de recursos espec√≠ficos para esta vers√£o.  Aqui est√° um pequeno conjunto de mudan√ßas no Rust 2018. <br><br><h3>  Palavras-chave </h3><br>  O Rust 2018 adicionou algumas palavras-chave: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  Esses recursos ainda n√£o foram totalmente implementados, mas as palavras-chave foram adicionadas no Rust 1.31.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portanto, no futuro, n√£o precisaremos introduzir novas palavras-chave (o que se tornaria uma altera√ß√£o incompat√≠vel) quando implementarmos essas fun√ß√µes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistema modular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma grande dor para os novatos no Rust √© o sistema modular. </font><font style="vertical-align: inherit;">E est√° claro o porqu√™. </font><font style="vertical-align: inherit;">Era dif√≠cil entender por que Rust escolhe um m√≥dulo espec√≠fico. </font><font style="vertical-align: inherit;">Para corrigir isso, fizemos algumas altera√ß√µes no mecanismo do caminho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, se voc√™ importou um rack, poder√° us√°-lo no caminho no n√≠vel superior. </font><font style="vertical-align: inherit;">Mas se voc√™ mover qualquer c√≥digo para um subm√≥dulo, ele n√£o funcionar√° mais.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro exemplo √© o prefixo </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usado tanto para a raiz da caixa como para a caixa externa. </font><font style="vertical-align: inherit;">√â dif√≠cil entender o que est√° diante de n√≥s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tornamos isso mais expl√≠cito. </font><font style="vertical-align: inherit;">Agora, se voc√™ quiser consultar a caixa raiz, use o prefixo </font></font><code>crate::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta √© apenas uma das melhorias para maior clareza. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ deseja que o c√≥digo atual use os recursos do Rust 2018, provavelmente, ser√° necess√°rio atualizar o c√≥digo para levar em conta novos caminhos. </font><font style="vertical-align: inherit;">Mas n√£o √© necess√°rio fazer isso manualmente. </font><font style="vertical-align: inherit;">Antes de adicionar o especificador de vers√£o ao Cargo.toml, basta execut√°-lo </font></font><code>cargo fix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>rustfix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fazer as altera√ß√µes necess√°rias.</font></font><br><br><h1>  Informa√ß√µes Adicionais </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as informa√ß√µes sobre a nova vers√£o do idioma est√£o contidas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no Guia Rust 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432564/">https://habr.com/ru/post/pt432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432554/index.html">Douglas Engelbart: Fortalecendo a Sociedade do ‚ÄúQI Coletivo‚Äù</a></li>
<li><a href="../pt432556/index.html">Tecnologia patenteada Tesla para posicionamento de ve√≠culos</a></li>
<li><a href="../pt432558/index.html">Padr√£o arquitetural ‚ÄúVisitor‚Äù nos universos ‚ÄúiOS‚Äù e ‚ÄúSwift‚Äù</a></li>
<li><a href="../pt432560/index.html">Tipografia na web. Palestra Yandex no FrontTalks 2018</a></li>
<li><a href="../pt432562/index.html">Techday Transforme em realidade - 17 de dezembro, Moscou</a></li>
<li><a href="../pt432566/index.html">Dois mundos ou "engenheiros t√™m algo a dizer". Sobre os v√°rios tipos de tarefas complexas e os processos associados a elas</a></li>
<li><a href="../pt432568/index.html">‚ÄúQuando voc√™ √© o editor-chefe da Rusbase‚Äù: um novo podcast sobre como trabalhar com conte√∫do e uma carreira em m√≠dia tecnol√≥gica</a></li>
<li><a href="../pt432572/index.html">Transistor metal-ar estender√° a Lei de Moore - como a tecnologia funciona</a></li>
<li><a href="../pt432574/index.html">Design sofisticado de dispositivos simples</a></li>
<li><a href="../pt432576/index.html">Sob o cap√¥ de um JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>