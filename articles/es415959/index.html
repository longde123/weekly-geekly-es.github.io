<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèº üåÅ ü§¶üèª Como escribimos el c√≥digo de red del tirador PvP m√≥vil: sincronizaci√≥n del jugador en el cliente üçê üöî üèÇüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En uno de los art√≠culos anteriores , revisamos las tecnolog√≠as que se utilizan en nuestro nuevo proyecto: un juego de disparos r√°pido para dispositivo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escribimos el c√≥digo de red del tirador PvP m√≥vil: sincronizaci√≥n del jugador en el cliente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/415959/">  En uno de los art√≠culos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriores</a> , revisamos las tecnolog√≠as que se utilizan en nuestro nuevo proyecto: un juego de disparos r√°pido para dispositivos m√≥viles.  Ahora quiero compartir c√≥mo se organiza la parte del cliente del c√≥digo de red del juego futuro, qu√© dificultades encontramos y c√≥mo resolverlas. <br><br><img src="https://habrastorage.org/webt/va/gz/nl/vagznl64ylol9qhxysj5ti1akpy.jpeg"><br><a name="habracut"></a><br><br>  En general, los enfoques para crear juegos multijugador r√°pidos en los √∫ltimos 20 a√±os no han cambiado mucho.  Se pueden distinguir varios m√©todos en la arquitectura del c√≥digo de red: <br><br><ol><li>  C√°lculo err√≥neo del estado del mundo en el servidor y visualizaci√≥n de los resultados en el cliente sin predicci√≥n para el jugador local y con la posibilidad de perder la entrada (entrada) del jugador.  Este enfoque, por cierto, se utiliza en nuestro otro proyecto en desarrollo; puede leer sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso a paso</a> </li><li>  Sincronizaci√≥n del estado del mundo sin l√≥gica determinista con predicci√≥n para un jugador local. </li><li>  Sincronizaci√≥n de entrada con l√≥gica y predicci√≥n totalmente determinista para un jugador local. </li></ol><br>  La peculiaridad radica en el hecho de que en los tiradores lo m√°s importante es la capacidad de respuesta del control: el jugador presiona un bot√≥n (o mueve el joystick) y quiere ver de inmediato el resultado de su acci√≥n.  En primer lugar, porque el estado del mundo en tales juegos cambia muy r√°pidamente y es necesario responder de inmediato a la situaci√≥n. <br><br>  Como resultado de esto, los enfoques sin el mecanismo de predicci√≥n de las acciones del jugador local (predicci√≥n) no eran adecuados para el proyecto, y nos decidimos por un m√©todo para sincronizar el estado del mundo, sin una l√≥gica determinista. <br><br>  <b>Ventaja del enfoque:</b> menor complejidad en la implementaci√≥n en comparaci√≥n con el m√©todo de sincronizaci√≥n al intercambiar entradas. <br>  <b>Menos:</b> un aumento en el tr√°fico al enviar todo el estado del mundo al cliente.  Tuvimos que aplicar varias t√©cnicas diferentes de optimizaci√≥n del tr√°fico para que el juego funcionara de manera estable en una red m√≥vil. <br><br>  En el coraz√≥n de la arquitectura de juego tenemos ECS, del que ya hemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablado</a> .  Esta arquitectura le permite almacenar convenientemente datos sobre el mundo del juego, serializarlos, copiarlos y transferirlos a trav√©s de la red.  Y tambi√©n para ejecutar el mismo c√≥digo tanto en el cliente como en el servidor. <br><br>  La simulaci√≥n del mundo del juego tiene lugar a una frecuencia fija de 30 tics por segundo.  Esto le permite reducir el retraso en la entrada del reproductor y casi no utiliza la interpolaci√≥n para mostrar visualmente el estado del mundo.  Pero hay un inconveniente importante que debe tenerse en cuenta al desarrollar dicho sistema: para que el sistema de predicci√≥n del jugador local funcione correctamente, el cliente debe simular el mundo con la misma frecuencia que el servidor.  Y pasamos mucho tiempo para optimizar la simulaci√≥n lo suficiente para los dispositivos de destino. <br><br><h2>  Mecanismo de predicci√≥n de acci√≥n del jugador local (predicci√≥n) </h2><br>  El mecanismo de predicci√≥n del cliente se implementa sobre la base de ECS debido a la ejecuci√≥n de los mismos sistemas tanto en el cliente como en el servidor.  Sin embargo, no todos los sistemas se ejecutan en el cliente, sino solo aquellos que son responsables del jugador local y no requieren datos relevantes sobre otros jugadores. <br><br>  Ejemplo de listas de sistemas que se ejecutan en el cliente y el servidor: <br><br><img src="https://habrastorage.org/webt/sm/jl/wc/smjlwcvyu5mv2omhgnggu9zbbnc.png"><br><br>  En este momento, tenemos unos 30 sistemas que se ejecutan en el cliente que proporcionan la predicci√≥n del jugador y unos 80 sistemas que se ejecutan en el servidor.  Pero no predecimos cosas como infligir da√±o, usar habilidades o curar aliados.  Hay dos problemas en esta mec√°nica: <br><br><ol><li>  El cliente no sabe nada acerca de ingresar a otros jugadores y predecir cosas como da√±o o curaci√≥n casi siempre diferir√° de los datos en el servidor. </li><li>  Crear nuevas entidades localmente (disparos, proyectiles, habilidades √∫nicas) generadas por un jugador conlleva el problema de emparejar con entidades creadas en el servidor. </li></ol><br>  Para una mec√°nica as√≠, el retraso se oculta del jugador de otras maneras. <br><br>  <i>Ejemplo: sacamos el efecto de golpear del disparo inmediatamente, y actualizamos la vida del enemigo solo despu√©s de recibir la confirmaci√≥n del golpe del servidor.</i> <br><br><h2>  El esquema general del c√≥digo de red en el proyecto. </h2><br><br><img src="https://habrastorage.org/webt/so/vq/gw/sovqgwxy7gc2rxtsqedxdlkpdew.png"><br>  El cliente y el servidor sincronizan la hora por n√∫meros de marca.  Debido al hecho de que la transmisi√≥n de datos a trav√©s de la red lleva alg√∫n tiempo, el cliente siempre est√° por delante del servidor a la mitad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTT</a> + el tama√±o del b√∫fer de entrada en el servidor.  El diagrama anterior muestra que el cliente env√≠a una entrada para la marca 20 (a).  Al mismo tiempo, la marca 15 (b) se procesa en el servidor.  Para cuando la entrada del cliente llegue al servidor, la marca 20 se procesar√° en el servidor. <br><br>  Todo el proceso consta de los siguientes pasos: el cliente env√≠a la entrada del jugador al servidor (a) ‚Üí esta entrada se procesa en el servidor despu√©s de HRTT + tama√±o del b√∫fer de entrada (b) ‚Üí el servidor env√≠a el estado mundial resultante al cliente (s) ‚Üí el cliente aplica el estado mundial confirmado con hora del servidor RTT + tama√±o del b√∫fer de entrada + tama√±o del b√∫fer de interpolaci√≥n del estado del juego (d). <br><br>  Despu√©s de que el cliente recibe un nuevo estado confirmado del mundo del servidor (d), debe completar el proceso de reconciliaci√≥n.  El hecho es que el cliente realiza una predicci√≥n mundial basada solo en la aportaci√≥n del jugador local.  Las entradas de otros jugadores no son conocidas por √©l.  Y al calcular el estado del mundo en el servidor, el jugador puede estar en un estado diferente, diferente de lo que predijo el cliente.  Esto puede suceder cuando un jugador es aturdido o asesinado. <br><br>  El proceso de aprobaci√≥n consta de dos partes: <br><br><ol><li>  Comparaciones del estado predicho del mundo para la marca N recibida del servidor.  Solo los datos relacionados con el jugador local est√°n involucrados en la comparaci√≥n.  El resto de los datos del mundo siempre se toman del estado del servidor y no participan en la coordinaci√≥n. </li><li>  Durante la comparaci√≥n, pueden ocurrir dos casos: </li></ol><br>  - si el estado previsto del mundo coincide con el confirmado del servidor, entonces el cliente, utilizando los datos pronosticados para el jugador local y los nuevos datos para el resto del mundo, contin√∫a simulando el mundo en modo normal; <br>  - si el estado predicho no coincid√≠a, entonces el cliente usa el estado del servidor completo del mundo y el historial de entrada del cliente y relata el nuevo estado predicho del mundo del jugador. <br><br><div class="spoiler">  <b class="spoiler_title">En c√≥digo, se parece a esto:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">GameState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconcile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentTick, ServerGameStateData serverStateData, GameState currentState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverState = serverStateData.GameState; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverTick = serverState.Time; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> predictedState = _localStateHistory.Get(serverTick); <span class="hljs-comment"><span class="hljs-comment">//if predicted state matches server last state use server predicted state with predicted player if (_gameStateComparer.IsSame(predictedState, serverState, playerID)) { _tempState.Copy(serverState); _gameStateCopier.CopyPlayerEntities(currentState, _tempState, playerID); return _localStateHistory.Put(_tempState); // replace predicted state with correct server state } //if predicted state doesn't match server state, reapply local inputs to server state var last = _localStateHistory.Put(serverState); // replace wrong predicted state with correct server state for (var i = serverTick; i &lt; currentTick; i++) { last = _prediction.Predict(last); // resimulate all wrong states } return last; }</span></span></code> </pre> <br></div></div><br>  La comparaci√≥n de dos estados mundiales se produce solo para aquellos datos que se relacionan con el jugador local y participan en el sistema de predicci√≥n.  Los datos se muestrean por ID de jugador. <br><br><div class="spoiler">  <b class="spoiler_title">M√©todo de comparaci√≥n:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState s1, GameState s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || s1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity1 = s1.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity2 = s2.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Time != s2.Time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Weapon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s1.WorldState.Weapon) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value.Owner.Id != avatarId) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Weapon = s2.WorldState.Weapon[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value != s2Weapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Ammo = s1.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Ammo = s2.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Ammo != s2Ammo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Reload = s1.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Reload = s2.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Reload != s2Reload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.Aiming != entity2.Aiming) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.ChangeWeapon != entity2.ChangeWeapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Los operadores de comparaci√≥n para componentes espec√≠ficos se generan junto con toda la estructura EC, especialmente escrita por un generador de c√≥digo.  Por ejemplo, dar√© el c√≥digo generado del operador de comparaci√≥n de componentes Transformar: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Cabe se√±alar que nuestros valores Float se comparan con un error bastante alto.  Esto se hace para reducir la cantidad de desincronizaci√≥n entre el cliente y el servidor.  Para el jugador, dicho error ser√° invisible, pero esto ahorra significativamente los recursos inform√°ticos del sistema. <br><br>  La complejidad del mecanismo de coordinaci√≥n es que, en caso de una mala sincronizaci√≥n de los estados del cliente y del servidor (predicci√≥n err√≥nea), es necesario simular repetidamente todos los estados del cliente predichos sobre los que no hay confirmaci√≥n del servidor, hasta el tic actual en un cuadro.  Dependiendo del ping del jugador, esto puede ser de 5 a 20 tics de simulaci√≥n.  Tuvimos que optimizar significativamente el c√≥digo de simulaci√≥n para encajar en el marco de tiempo: 30 fps. <br><br>  Para completar el proceso de aprobaci√≥n, se deben almacenar dos tipos de datos en el cliente: <br><br><ol><li>  Una historia de estados de jugador predichos. </li><li>  Y la historia de la entrada. </li></ol><br>  Para estos fines, utilizamos un b√∫fer circular.  El tama√±o del b√∫fer es de 32 ticks.  Que a una frecuencia de 30 HZ da aproximadamente 1 segundo de tiempo real.  El cliente puede continuar trabajando de manera segura en el mecanismo de predicci√≥n, sin recibir nuevos datos del servidor, hasta llenar este b√∫fer.  Si la diferencia entre la hora del cliente y el servidor comienza a ser m√°s de un segundo, el cliente se ve obligado a desconectarse con un intento de reconexi√≥n.  Tenemos tal tama√±o de amortiguaci√≥n debido a los costos del proceso de coordinaci√≥n en caso de una discrepancia entre los estados del mundo.  Pero si la diferencia entre el cliente y el servidor es m√°s de un segundo, es m√°s barato realizar una reconexi√≥n completa al servidor. <br><br><h2>  Reducci√≥n del tiempo de retraso </h2><br>  El diagrama anterior muestra que en el juego hay dos buffers en el esquema de transferencia de datos: <br><br><ul><li>  b√∫fer de entrada en el servidor; </li><li>  un b√∫fer de estados mundiales en el cliente. </li></ul><br>  El prop√≥sito de estos b√∫feres es el mismo: compensar los saltos de red (jitter).  El hecho es que la transmisi√≥n de paquetes a trav√©s de la red es desigual.  Y dado que el motor de red funciona a una frecuencia fija de 30 HZ, los datos se deben suministrar al motor a la misma frecuencia.  No tenemos la oportunidad de "esperar" algunos ms hasta que el pr√≥ximo paquete llegue al destinatario.  Utilizamos buffers para datos de entrada y estados mundiales con el fin de tener un margen de tiempo para la compensaci√≥n de jitter.  Tambi√©n usamos el b√∫fer gamestate para la interpolaci√≥n si se pierde uno de los paquetes. <br><br>  Al comienzo del juego, el cliente inicia la sincronizaci√≥n con el servidor solo despu√©s de recibir varios estados mundiales del servidor y el b√∫fer de estado del juego est√° lleno.  Por lo general, el tama√±o de este b√∫fer es de 3 ticks (100 ms). <br><br>  Al mismo tiempo, cuando el cliente se sincroniza con el servidor, "corre" por delante del tiempo del servidor por el valor del b√∫fer de entrada en el servidor.  Es decir  el cliente mismo controla qu√© tan lejos est√° el servidor.  El tama√±o inicial del b√∫fer de entrada tambi√©n es igual a 3 ticks (100 ms). <br><br>  Inicialmente, implementamos el tama√±o de estos b√∫feres como constantes.  Es decir  independientemente de si el jitter realmente exist√≠a en la red o no, hubo un retraso fijo de 200 ms (tama√±o del b√∫fer de entrada + tama√±o del b√∫fer del estado del juego) para actualizar los datos.  Si agregamos a esto el ping promedio estimado en dispositivos m√≥viles en alg√∫n lugar alrededor de 200 ms, entonces el retraso real entre el uso de la entrada en el cliente y la confirmaci√≥n de la aplicaci√≥n desde el servidor fue de 400 ms. <br><br>  Esto no nos vino bien. <br><br>  El hecho es que algunos sistemas se ejecutan solo en el servidor, como, por ejemplo, calcular el HP del jugador.  Con este retraso, el jugador dispara y solo despu√©s de 400 ms ve c√≥mo mata al oponente.  Si esto sucedi√≥ en movimiento, generalmente el jugador logr√≥ correr detr√°s de la pared o para cubrirse y ya estaba muriendo all√≠.  Las pruebas de juego dentro del equipo mostraron que tal demora rompe por completo toda la jugabilidad. <br><br>  La soluci√≥n a este problema fue la implementaci√≥n de tama√±os din√°micos de buffers de entrada y estados de juego: <br><ul><li>  para un b√∫fer gamestate, el cliente siempre conoce el contenido actual del b√∫fer.  Al momento de calcular el siguiente tick, el cliente verifica cu√°ntos estados ya est√°n en el b√∫fer; </li><li>  para el b√∫fer de entrada: el servidor, adem√°s del estado del juego, comenz√≥ a enviar al cliente el valor del llenado actual del b√∫fer de entrada para un cliente espec√≠fico.  El cliente a su vez analiza estos dos valores. </li></ul><br>  El algoritmo de cambio de tama√±o del b√∫fer gamestate es aproximadamente el siguiente: <br><br><ol><li>  El cliente considera el valor promedio del tama√±o del b√∫fer durante un per√≠odo de tiempo y variaci√≥n. </li><li>  Si la variaci√≥n est√° dentro de los l√≠mites normales (es decir, durante un per√≠odo de tiempo determinado no hubo grandes saltos en el llenado y la lectura del b√∫fer), el cliente verifica el valor del tama√±o promedio del b√∫fer para este per√≠odo de tiempo. </li><li>  Si el llenado promedio del b√∫fer fue mayor que la condici√≥n de l√≠mite superior (es decir, el b√∫fer se llenar√≠a m√°s de lo requerido), el cliente "reduce" el tama√±o del b√∫fer realizando una marca de simulaci√≥n adicional. </li><li>  Si el llenado promedio del b√∫fer fue menor que la condici√≥n de l√≠mite inferior (es decir, el b√∫fer no tuvo tiempo de llenarse antes de que el cliente comenzara a leerlo), en este caso, el cliente "aumenta" el tama√±o del b√∫fer omitiendo una marca de la simulaci√≥n. </li><li>  En el caso de que la varianza fuera superior a lo normal, no podemos confiar en estos datos, porque  las sobretensiones de red durante un per√≠odo de tiempo determinado fueron demasiado grandes.  Luego, el cliente descarta todos los datos actuales y comienza a recopilar estad√≠sticas nuevamente. </li></ol><br><h2>  Compensaci√≥n de retraso del servidor </h2><br>  Debido al hecho de que el cliente recibe actualizaciones mundiales del servidor con un retraso (retraso), el jugador ve el mundo un poco diferente de lo que existe en el servidor.  El jugador se ve a s√≠ mismo en el presente y al resto del mundo, en el pasado.  En el servidor, todo el mundo existe en una sola vez. <br><br><img src="https://habrastorage.org/webt/jo/ca/5d/joca5d_dhigvw1i9gjlpcd-tgqa.png"><br>  Debido a esto, la situaci√≥n es que el jugador dispara localmente a un objetivo que se encuentra en el servidor en otro lugar. <br><br>  Para compensar el retraso, utilizamos el rebobinado de tiempo en el servidor.  El algoritmo de operaci√≥n es aproximadamente el siguiente: <br><br><ol><li>  El cliente con cada entrada adicionalmente env√≠a al servidor el tiempo de tic en el que ve el resto del mundo. </li><li>  El servidor valida este tiempo: es la diferencia entre la hora actual y la hora visible del mundo del cliente en el intervalo de confianza. </li><li>  Si la hora es v√°lida, el servidor deja al jugador en la hora actual y el resto del mundo regresa al estado que vio el jugador y calcula el resultado del disparo. </li><li>  Si un jugador golpea, el da√±o se hace en el tiempo actual del servidor. </li></ol><br>  El tiempo de rebobinado en un servidor funciona de la siguiente manera: la historia del mundo (en ECS) y la historia de la f√≠sica (compatible con el motor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F√≠sica vol√°til</a> ) se almacenan en el norte.  En el momento en que se calcul√≥ el tiro, los datos del jugador se toman del estado actual del mundo y los jugadores restantes del historial. <br><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo para el sistema de validaci√≥n de disparos se ve as√≠:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shotPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Shot) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shot = shotPair.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooter = gs.WorldState[shotPair.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooterTransform = shooter.Transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weaponStats = gs.WorldState.WeaponStats[shot.WeaponId]; <span class="hljs-comment"><span class="hljs-comment">// DeltaTime shouldn't exceed physics history size var shootDeltaTime = (int) (gs.Time - shot.ShotPlayerWorldTime); if (shootDeltaTime &gt; PhysicsWorld.HistoryLength) { continue; } // Get the world at the time of shooting. var oldState = _immutableHistory.Get(shot.ShotPlayerWorldTime); var potentialTarget = oldState.WorldState[shot.Target.Id]; var hitTargetId = _singleShotValidator.ValidateTargetAvailabilityInLine(oldState, potentialTarget, shooter, shootDeltaTime, weaponStats.ShotDistance, shooter.Transform.Angle.GetDirection()); if (hitTargetId != 0) { gs.WorldState.CreateEntity().AddDamage(gs.WorldState[hitTargetId], shooter, weaponStats.ShotDamage); } } }</span></span></code> </pre> <br></div></div><br>  Un inconveniente significativo en el enfoque es que confiamos en el cliente en los datos sobre el momento de la marca que ve.  Potencialmente, un jugador puede obtener una ventaja al aumentar artificialmente el ping.  Porque  cuanto m√°s ping tiene un jugador, m√°s lejos dispara en el pasado. <br><br><h2>  Algunos problemas que encontramos </h2><br>  Durante la implementaci√≥n de este motor de red, encontramos muchos problemas, algunos de los cuales son dignos de un art√≠culo separado, pero aqu√≠ mencionar√© solo algunos de ellos. <br><br><h4>  Simulaci√≥n de todo el mundo en un sistema de predicci√≥n y copia. </h4><br>  Inicialmente, todos los sistemas en nuestro ECS ten√≠an solo un m√©todo: void Execute (GameState gs).  En este m√©todo, los componentes relacionados con todos los jugadores generalmente se procesaron. <br><br><div class="spoiler">  <b class="spoiler_title">Un ejemplo de un sistema de movimiento en la implementaci√≥n inicial:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[movementPair.Key]; transform.Position += movementPair.Value.Velocity * GameState.TickDuration; } } }</code> </pre> <br></div></div><br>  Pero en el sistema de predicci√≥n de jugadores locales, solo necesit√°bamos procesar los componentes relacionados con un jugador espec√≠fico.  Inicialmente, implementamos esto usando copy. <br><br>  El proceso de predicci√≥n fue el siguiente: <br><br><ol><li>  Se cre√≥ una copia del estado del juego. </li><li>  Se proporcion√≥ una copia a la entrada de ECS. </li><li>  Hubo una simulaci√≥n de todo el mundo en ECS. </li><li>  Todos los datos relacionados con el jugador local se copiaron del estado de juego reci√©n recibido. </li></ol><br><div class="spoiler">  <b class="spoiler_title">El m√©todo de predicci√≥n se ve√≠a as√≠:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _tempGameState.Copy(state); _ecsExecutor.Execute(_tempGameState, input); _playerEntitiesCopier.Copy(_tempGameState, newState); }</code> </pre> <br></div></div><br>  Hubo dos problemas en esta implementaci√≥n: <br><br><ol><li>  Porque  utilizamos clases, no estructuras: la copia es una operaci√≥n bastante costosa para nosotros (aproximadamente 0.1-0.15 ms en iPhone 5S). </li><li>  La simulaci√≥n de todo el mundo tambi√©n lleva mucho tiempo (aproximadamente 1.5-2 ms en el iPhone 5S). </li></ol><br>  Si tenemos en cuenta que durante el proceso de coordinaci√≥n es necesario volver a calcular de 5 a 15 estados mundiales en un solo marco, entonces con tal implementaci√≥n todo fue terriblemente lento. <br><br>  La soluci√≥n era bastante simple: aprender a simular el mundo en partes, es decir, simular solo un jugador espec√≠fico.  Reescribimos todos los sistemas para que pueda transferir la identificaci√≥n del jugador y simular solo a √©l. <br><br><div class="spoiler">  <b class="spoiler_title">Un ejemplo de un sistema de movimiento despu√©s de un cambio:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { Move(gs.WorldState.Transform[movementPair.Key], movementPair.Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[playerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Move(gs.WorldState.Transform[playerId], movement); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform, Movement movement</span></span></span><span class="hljs-function">)</span></span> { transform.Position += movement.Velocity * GameState.TickDuration; } }</code> </pre> <br></div></div><br>  Despu√©s de los cambios, pudimos eliminar las copias innecesarias en el sistema de predicci√≥n y reducir la carga en el sistema correspondiente. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _ecsExecutor.Execute(newState, input, playerId); }</code> </pre> <br></div></div><br><h4>  Crear y eliminar entidades en un sistema de predicci√≥n </h4><br>  En nuestro sistema, la coincidencia de entidades en el servidor y el cliente ocurre por un identificador entero (id).  Para todas las entidades, utilizamos una numeraci√≥n de identificadores de extremo a extremo, cada nueva entidad tiene el valor id = oldID + 1. <br><br>  Este enfoque es muy conveniente de implementar, pero tiene un inconveniente importante: el orden de creaci√≥n de nuevas entidades en el cliente y el servidor puede ser diferente y, como resultado, los identificadores de las entidades ser√°n diferentes. <br><br>  Este problema se manifest√≥ cuando implementamos un sistema para predecir los tiros de los jugadores.  Cada disparo con nosotros es una entidad separada con el componente de disparo.  Para cada cliente, la identificaci√≥n de las entidades de disparo en el sistema de predicci√≥n era secuencial.  Pero si en el mismo momento otro jugador dispar√≥, entonces en el servidor la identificaci√≥n de todos los disparos difer√≠a del cliente. <br><br>  Las tomas en el servidor se crearon en un orden diferente: <br><br><img src="https://habrastorage.org/webt/gl/dg/fy/gldgfykw7m30fuwspkra-xytgqe.png"><br><br>  Para los disparos, eludimos esta limitaci√≥n, en funci√≥n de las caracter√≠sticas de juego del juego.  Los disparos son entidades de vida r√°pida que se destruyen en el sistema una fracci√≥n de segundo despu√©s de la creaci√≥n.  En el cliente, resaltamos un rango separado de ID que no se cruzan con las ID del servidor y ya no tienen en cuenta las tomas en el sistema de coordinaci√≥n.  Es decir  Los disparos de los jugadores locales siempre se dibujan en el juego solo de acuerdo con el sistema de predicci√≥n y no tienen en cuenta los datos del servidor. <br><br>  Con este enfoque, el jugador no ve artefactos en la pantalla (eliminaci√≥n, recreaci√≥n, retrocesos de disparos), y las discrepancias con el servidor son menores y no afectan el juego en su conjunto. <br><br>  Este m√©todo permiti√≥ resolver el problema con disparos, pero no todo el problema de crear entidades en el cliente como un todo.  Todav√≠a estamos trabajando en posibles m√©todos para resolver la comparaci√≥n de objetos creados en el cliente y el servidor. <br><br>  Tambi√©n se debe tener en cuenta que este problema solo se refiere a la creaci√≥n de nuevas entidades (con nuevas ID).  La adici√≥n y eliminaci√≥n de componentes en entidades ya creadas se realiza sin problemas: los componentes no tienen identificadores y cada entidad solo puede tener un componente de un tipo espec√≠fico.  Por lo tanto, generalmente creamos entidades en el servidor, y en los sistemas de predicci√≥n solo agregamos / eliminamos componentes. <br><br>  En conclusi√≥n, quiero decir que la tarea de implementar el modo multijugador no es la m√°s f√°cil y r√°pida, pero hay mucha informaci√≥n sobre c√≥mo hacerlo. <br><br><h2>  Que leer </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Multijugador en juegos r√°pidos</a> : traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Multijugador acelerado</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(Parte I): Introducci√≥n</a> (en mi opini√≥n, este es el mejor art√≠culo sobre Habr√© sobre la interacci√≥n de la red en los juegos). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GDC Vault Overwatch Gameplay Architecture y Netcode</a> : una conferencia con GDC 17, sobre ECS y c√≥digo de red en Overwatch (desafortunadamente, el acceso es de pago). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GDC Vault: 8 marcos en 16 ms: Rollback Networking en Mortal Kombat e Injustice 2</a> : c√≥mo se hace esto en los juegos de lucha. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Networking multijugador de origen</a> : c√≥mo funciona el modo multijugador en Counter Strike. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gaffer on Games</a> generalmente trata sobre el c√≥digo de red en los juegos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UDP en motores de juego</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GDC Vault: I Shot you first networking</a> : c√≥mo funciona el modo multijugador en Halo: Reach. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415959/">https://habr.com/ru/post/es415959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415947/index.html">Sistema de compensaci√≥n de errores de instalaci√≥n de fibra √≥ptica durante su procesamiento por radiaci√≥n l√°ser durante la rotaci√≥n</a></li>
<li><a href="../es415949/index.html">Alta miner√≠a: la √∫ltima opci√≥n para proteger la cadena de bloques PoW de un "ataque del 51%"</a></li>
<li><a href="../es415951/index.html">Mitap Sberbank e IBM en HyperLedger Fabric</a></li>
<li><a href="../es415953/index.html">C√≥mo la empresa sangrienta gana el c√≥digo abierto: la batalla por BPMS</a></li>
<li><a href="../es415957/index.html">Necesitamos m√°s mochilas: Bobby XL de XD Design</a></li>
<li><a href="../es415961/index.html">Almacenamiento distribuido ruso. Como funciona</a></li>
<li><a href="../es415963/index.html">Naive Bayes, o c√≥mo las matem√°ticas te permiten filtrar el spam</a></li>
<li><a href="../es415965/index.html">Qu√© leer en julio: 19 nuevos libros para profesionales digitales</a></li>
<li><a href="../es415967/index.html">SolidFire - Almacenamiento para aquellos ** almacenamiento de odio cking</a></li>
<li><a href="../es415969/index.html">HyperX Pulsefire Surge RGB: un asesino nato</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>