<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📺 👨🏿‍🤝‍👨🏻 👖 Dithering: Rauschendes Signal zur Verbesserung 😯 ↩️ 👬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einleitung 
 Im ersten Teil dieser Artikelserie werden wir die theoretische Seite des Dithering, ein bisschen Geschichte und ihre Anwendung auf 1D-Sig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dithering: Rauschendes Signal zur Verbesserung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481386/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/cbf/70e/847cbf70eb435d9e22a55ff7d917f0a2.png" alt="Bild"></div><br><h2>  Einleitung </h2><br>  Im ersten Teil dieser <a href="https://bartwronski.com/2016/10/30/dithering-in-games-mini-series/">Artikelserie werden</a> wir die theoretische Seite des Dithering, ein bisschen Geschichte und ihre Anwendung auf 1D-Signale und Sampling betrachten.  Ich werde versuchen, eine Frequenzanalyse von Diskretisierungsfehlern durchzuführen und darüber zu sprechen, wie Dithering hilft, diese zu korrigieren.  Grundsätzlich handelt es sich hierbei um einen theoretischen Artikel. Wenn Sie also an praktischeren Anwendungen interessiert sind, warten Sie auf die nächsten Teile. <br><br>  Das Mathematica-Notizbuch zur Reproduktion der Ergebnisse finden Sie <a href="">hier</a> und die PDF-Version finden Sie <a href="https://github.com/bartwronski/BlogPostsExtraMaterial/blob/master/DitheringPostSeries/1DQuantization.pdf">hier</a> . <br><br><h2>  Was ist Dithering? </h2><br>  Dithering kann als das absichtliche / absichtliche Einbringen von Rauschen in ein Signal beschrieben werden, um großräumige / niedrigauflösende Fehler zu vermeiden, die sich aus der Abtastung oder Unterabtastung ergeben. <br><br>  Wenn Sie jemals gearbeitet haben mit: <br><br><ul><li>  Audiosignale </li><li>  90er Jahre Palette Bildformate </li></ul><br>  Sie sollten auf Dithering-Optionen gestoßen sein, die dank des Hinzufügens von Rauschen und Artefakten mit niedriger Auflösung die Qualität von Ton und Bild auf magische Weise verbesserten. <br><br>  Allerdings fand ich auf Wikipedia eine ziemlich überraschende Tatsache darüber, wie Dithering zuerst definiert und verwendet wurde: <a name="habracut"></a><br><br><blockquote>  ... Eine der ersten Anwendungen von Dithering trat während des Zweiten Weltkriegs auf.  Bomberflugzeuge verwendeten mechanische Computer, um die Flugbahn von Bomben zu navigieren und zu berechnen.  Es ist merkwürdig, dass diese Computer (mit Hunderten von Zahnrädern und Zahnrädern gefüllte Kästen) beim Fliegen an Bord eines Flugzeugs genauer arbeiteten als am Boden.  Die Ingenieure stellten fest, dass die vom Flugzeug verursachten Vibrationen den Fehler verringern, der durch klebrige bewegliche Teile verursacht wird.  Auf der Erde bewegten sie sich in kurzen ruckartigen Bewegungen, und in der Luft war ihre Bewegung kontinuierlicher.  Kleine Vibrationsmotoren wurden in Computer eingebaut, und ihre Vibration wurde "Dither" genannt, vom mittelenglischen Wort "didderen", was "zittern" bedeutet.  Wenn Sie heute an ein mechanisches Messgerät klopfen, um dessen Genauigkeit zu erhöhen, wenden Sie Dithering an.  Dither wandelt das Digitalisierungssystem in kleinen Mengen im wahrsten Sinne des Wortes erfolgreich in ein analogeres um. <br><br>  - Ken Polmann, <i>Grundsätze für digitales Audio</i> </blockquote><br>  Dies ist eine inspirierende und interessante historische Tatsache, und ich verstehe, warum wir dadurch Abweichungen bei Berechnungen und Resonanzen vermeiden können, indem wir die Rückkopplungszyklen mechanischer Schwingungen zufällig unterbrechen. <br><br>  Aber genug Geschichte, lassen Sie uns zuerst den Dithering-Prozess in 1D-Signalen betrachten, zum Beispiel in Audio. <br><br><h2>  Sampling durch Dithering eines konstanten Signals </h2><br>  Zunächst analysieren wir das langweiligste Signal der Welt - ein konstantes Signal.  Wenn Sie ein wenig über die digitale Verarbeitung von Signalen im Zusammenhang mit Ton wissen, können Sie sagen: Aber Sie haben versprochen, Audio in Betracht zu ziehen, und per Definition gibt es keine konstante Komponente im Ton!  (Außerdem wird in Software und in Tonverarbeitungsgeräten der sogenannte <em>Gleichstromversatz</em> absichtlich beseitigt.) <br><br>  Dies ist wahr, und bald werden wir uns komplexere Funktionen ansehen, aber wir werden wieder von vorne anfangen. <br><br>  Stellen Sie sich vor, wir führen eine 1-Bit-Abtastung eines normalisierten Gleitkommasignals durch.  Dies bedeutet, dass es sich nur um endliche Binärwerte handelt, 0 oder 1. <br><br>  Wenn das Signal <strong>0,3 ist</strong> , ist einfaches Runden ohne Dithering die langweiligste Funktion - nur <strong>Null</strong> ! <br><br>  Der Fehler ist ebenfalls konstant und gleich <strong>0,3</strong> , daher ist der durchschnittliche Fehler gleich <strong>0,3</strong> .  Dies bedeutet, dass wir eine ziemlich große Abweichung in das Signal eingeführt haben und die Information des ursprünglichen Signals vollständig verloren haben. <br><br>  Wir können versuchen, dieses Signal zu dithern und die Ergebnisse zu betrachten. <br><br>  In diesem Fall wendet das Dithering (bei Verwendung der Rundungsfunktion) einfach gewöhnliches zufälliges weißes Rauschen an (ein zufälliger Wert für jedes Element, der ein einheitliches Rauschspektrum erzeugt) und fügt dem Signal vor dem Abtasten ein zufälliges Intervall (-0,5, 0,5) hinzu. <br><br><blockquote>  quantizedDitheredSignal = <br>  Round [constantSignalValue + RandomReal [] - 0.5] &amp; / @ Range [sampleCount]; </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/282/c6f/d1b/282c6fd1b2e594fdedd3f34fbf45b5f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/e33/c85/6d5e33c852c01248b5d860d8c040968a.png"></div><br>  Es ist schwer, hier etwas zu sehen, jetzt besteht das Ergebnis der Diskretisierung nur noch aus zufälligen Einsen und Nullen.  Mit (erwarteten) vielen Nullen.  An sich ist dieses Signal nicht besonders interessant, aber der <strong>Fehlerplan</strong> und der durchschnittliche Fehler sind ziemlich interessant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa3/646/fd6/fa3646fd6d348b1ba95023dd34284d3c.png"></div><br>  Wie wir erwartet haben, variiert der Fehler auch, aber es ist erschreckend, dass der Fehler manchmal größer wurde (absoluter Wert 0,7)!  Das heißt, der maximale Fehler ist leider schlechter geworden, aber das durchschnittliche Rauschen spielt eine Rolle: <br><br><blockquote>  Mean [ditheredSignalError] <br>  0,013 </blockquote><br>  Viel besser als der Anfangsfehler von 0,3.  Bei einer signifikant großen Anzahl von Abtastwerten tendiert dieser Fehler gegen Null (bis zur Grenze).  Der Fehler der konstanten Komponente ist also viel geringer geworden, aber schauen wir uns den Frequenzgraphen aller Fehler an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/940/a58/696/940a586964e656aba927408a8547af19.gif"></div><br>  <i>Roter Graph / Burst = Frequenzspektrum des Fehlers ohne Dithering (konstantes Signal ohne Frequenzen).</i>  <i>Schwarz - mit Dithering unter Verwendung von weißem Rauschen.</i> <br><br>  Alles wird interessanter!  Dies zeigt die erste Schlussfolgerung aus diesem Post- <strong>Dithering, die den Abtastfehler / die Abtastabweichung auf mehrere Frequenzen verteilt</strong> . <br><br>  Im nächsten Abschnitt werden wir herausfinden, wie dies uns helfen wird. <br><br><h2>  Frequenzempfindlichkeit und Tiefpassfilterung </h2><br>  Oben haben wir das Dithering eines abgetasteten konstanten Signals beobachtet: <br><br><ul><li>  Er erhöhte den maximalen Fehler. </li><li>  Fast nullte der durchschnittliche Fehler. </li><li>  Dem Fehlerfrequenzspektrum wurde konstantes weißes Rauschen (mit vollständiger Abdeckung des Spektrums) hinzugefügt, um den Niederfrequenzfehler zu reduzieren. </li></ul><br>  An sich ist es für uns nicht sehr nützlich ... Wir ziehen jedoch keine Diskretisierung einer beliebigen mathematischen Funktion / eines beliebigen mathematischen Signals in Betracht.  Wir betrachten die Signale, die der Mensch wahrnehmen wird.  Offensichtlich ist die menschliche Wahrnehmung begrenzt.  Hier einige Beispiele dafür: <br><br><ul><li>  Unsere Sehschärfe ist begrenzt.  Viele Menschen haben Kurzsichtigkeit und ohne Brille sehen sie verschwommene Bilder von entfernten Objekten. </li><li>  Wir nehmen die durchschnittliche Detailskala viel besser wahr als sehr hohe oder sehr niedrige Frequenzen (kleine Details von sehr weichen Verläufen können unsichtbar sein). </li><li>  Unser Gehör arbeitet in einem bestimmten Frequenzbereich (20 Hz - 20 kHz, verschlechtert sich jedoch mit der Zeit) und wir sind am empfindlichsten für den mittleren Bereich - 2 kHz - 5 kHz. </li></ul><br>  Daher wird jeder Fehler in den Frequenzen, die näher am oberen Bereich der wahrgenommenen Frequenz liegen, viel weniger auffallen. <br><br>  Darüber hinaus werden unsere Mediengeräte immer besser und bieten ein größeres <strong>Oversampling</strong> .  Zum Beispiel haben wir bei Fernsehern und Monitoren die „Retina“ -Technologie und 4K-Displays (auf denen kein Pixel zu sehen ist). Im Bereich Sound verwenden wir Dateiformate mit einer Abtastrate von mindestens 44 kHz, auch für billige Lautsprecher, die oft nicht abgespielt werden können mehr als 5-10 kHz. <br><br>  Dies bedeutet, dass wir das wahrgenommene Erscheinungsbild des Signals durch Ausführen seiner Tiefpassfilterung approximieren können.  In der Grafik habe ich eine Tiefpassfilterung durchgeführt (das Füllen mit Nullen auf der linken Seite ist ein "Anstieg"): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59c/d4f/c3d/59cd4fc3d3c7b4e759e4bbf621e7be7d.png"></div><br>  <i>Rot - Gewünschtes nicht abgetastetes Signal.</i>  <i>Grün - diskretes Signal mit Dithering.</i>  <i>Blau ist das Tiefpassfilter dieses Signals.</i> <br><br>  Das Signal fängt an, der ursprünglichen, nicht abgetasteten Funktion viel näher zu kommen! <br><br>  Leider stellen wir langsam niedrige Frequenzen fest, die im Originalsignal sehr auffällig sind und fehlen.  Im dritten Teil der Serie werden wir versuchen, es mit Hilfe von blauem Rauschen zu beheben.  In der Zwischenzeit könnte das Diagramm mit einer Pseudorauschfunktion aussehen, deren Inhalt eine viel niedrigere Frequenz aufweist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e0/a3e/327/1e0a3e327d9f47d492580a13b2821351.png"></div>  Dies ist möglich, weil unsere Pseudozufallsfolge das folgende Frequenzspektrum aufweist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23f/d3c/012/23fd3c0126aad1b2b45f49d0794169c9.png"></div><br>  Aber schauen wir uns nun einfache, konstante Funktionen an.  Schauen Sie sich die Sinuswelle an (wenn Sie mit dem Fourier-Theorem vertraut sind, wissen Sie, dass es der Baustein eines periodischen Signals ist!). <br><br><h2>  Sinus-Sampling </h2><br>  Wenn wir eine Sinuskurve mit 1-Bit-Abtastung abtasten, erhalten wir ein einfaches Rechtecksignal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/318/339/49c/31833949c37f814a53da13ad96b0f791.png"></div><br>  Das Rechtecksignal ist sehr interessant, da es sowohl die Grundfrequenz als auch die <em>ungeraden Harmonischen enthält</em> . <br><br>  Dies ist eine interessante Eigenschaft, die in analogen subtraktiven Synthesizern aktiv genutzt wird, um den Klang von Hohl- / Kupferinstrumenten zu erzeugen.  Die subtraktive Synthese nimmt einen komplexen, harmonisch reichen Klang auf und filtert ihn, wobei einige Frequenzen eliminiert werden (Filterparameter variieren mit der Zeit), um den Klängen die gewünschte Form zu geben. <br><br>  Frequenzspektrum einer Rechteckwelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41b/8d0/8fc/41b8d08fc872d67182a9dc440b3f3af8.png"></div><br>  Aber in diesem Beitrag interessieren wir uns mehr für Stichprobenfehler!  Lassen Sie uns ein Fehlerdiagramm sowie ein Spektrum von Fehlerhäufigkeiten erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce8/a70/cca/ce8a70cca07da447534f49be2860c23c.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e08/5f8/d73/e085f8d73fcd19d84f42415ee04e808e.png"></div><br>  In diesem Fall ist die Situation viel besser - der durchschnittliche Fehler liegt nahe bei Null!  Leider haben wir immer noch viele unerwünschte tiefe Frequenzen, die sehr nahe an unserer Hauptfrequenz liegen (ungerade Multiplikatoren mit abnehmender Größe).  Dieses Phänomen wird als Aliasing- oder Dithering-Rauschen bezeichnet. Es treten Frequenzen auf, die im Originalsignal nicht vorhanden waren, und sie sind recht groß. <br><br>  Selbst eine Tiefpassfilterung kann das Signal nicht wesentlich verbessern.  Der Fehler hat viele tiefe Frequenzen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/a01/e69/16ca01e69bf451d493785e24b8d37021.png"></div><br>  <i>Diskretisierte Sinus-Tiefpassfilterung</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/e4f/e80/b58e4fe8085de75fff760643b88bcf25.png"></div><br>  <i>Genauigkeit der abgetasteten Sinuswelle</i> <br><br>  Lassen Sie uns einen Blick darauf werfen, wie sich die Situation ändert, wenn Dithering hinzugefügt wird.  Auf den ersten Blick gibt es fast keine Verbesserungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f83/45e/dfe/f8345edfe04e9e4494d37f2e850a2750.png"></div><br>  Wenn wir dies jedoch als Bild betrachten, sieht es allmählich besser aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/59b/155/fa159b155b1ee0dc9e0a86b454e58ac8.png"></div><br>  Beachten Sie, dass Abtastfehler erneut auf verschiedene Frequenzen verteilt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/0cf/385/4e50cf385c391e41e98e9fa1f40e8da6.gif"></div><br>  Es sieht sehr vielversprechend aus!  Besonders wenn man bedenkt, dass wir jetzt versuchen können zu filtern: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/c66/8f6/b91c668f65e26fd9f726152021139716.png"></div><br>  Dies ist eine leicht verzerrte Sinuswelle, die mit Ausnahme der durch das asymmetrische Filter eingeführten Phasenverschiebung dem Original viel näher kommt als die Version ohne Dithering (ich werde dies hier nicht erklären; ich kann nur sagen, dass das Problem durch Anwendung von symmetrischen Filtern behoben werden kann): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56d/7c4/766/56d7c4766562c6959f9e41b18bfef082.png"></div><br>  <i>Rot ist die ursprüngliche Sinuswelle.</i>  <i>Grün - tiefpassgefiltertes Signal ohne Dithering.</i>  <i>Blau - tiefpassgefiltertes Signal mit Dithering.</i> <br><br>  Die Grafiken beider Fehler bestätigen numerisch, dass der Fehler viel kleiner ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/cbf/70e/847cbf70eb435d9e22a55ff7d917f0a2.png"></div><br>  <i>Rot - der Fehler des tiefpassgefilterten Signals ohne Dithering.</i>  <i>Blau - der Fehler des tiefpassgefilterten Signals beim Dithering.</i> <br><br>  Betrachten wir zum Schluss kurz ein Signal mit einer besseren Dithering-Funktion, das nur hohe Frequenzen enthält: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/226/f56/32b/226f5632b0307975e29c4a38ffb18c3c.png"></div><br>  <i>Das obere Bild ist eine Funktion des weißen Rauschens.</i>  <i>Das untere Bild ist eine Funktion, die höhere Frequenzen enthält.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/8a2/737/8048a27372abfba70db4c11bcc33b897.png"></div><br>  <i>Eine Version mit Tiefpassfilterung, Dithering und verbesserter Funktion - fast perfekte Ergebnisse, wenn Sie die vom Filter verursachte Phasenverschiebung nicht berücksichtigen!</i> <br><br>  Zum Schluss ein Vergleich aller drei Fehlerspektren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/fb3/f10/df1fb3f1049a9415c295b6ab40fc6542.gif"></div><br>  <i>Rot - Spektrum des Abtastfehlers ohne Dithering.</i>  <i>Schwarz - Spektrum des Abtastfehlers mit weißem Rauschen.</i>  <i>Blau - Spektrum des Abtastfehlers beim Dithering mit höheren Frequenzen.</i> <br><br><h2>  Zusammenfassung </h2><br>  Dies ist der erste Teil der Serie endet.  Wichtigste Erkenntnisse: <br><br><ul><li>  Durch das Dithering wird der Abtastfehler / die Abtastabweichung auf mehrere Frequenzen verteilt, und dies hängt von der Dithering-Funktion ab.  Sie konzentrieren sich nicht auf tiefe Frequenzen. </li><li>  Die Wahrnehmung eines Signals (Ton, Bild) funktioniert am besten in ganz bestimmten Frequenzbereichen.  Signale werden häufig an den Grenzen des Wahrnehmungsspektrums überabgetastet, wo die Wahrnehmung nicht empfindlich ist.  Mit Standard-Audio-Abtastraten können Sie beispielsweise Signale wiedergeben, die die meisten Erwachsenen überhaupt nicht hören können.  Aufgrund des vorhergehenden Abschnitts ist die Idee, Dithering- und Verschiebungsfehler in diesen Frequenzbereich zu verwenden, sehr attraktiv. </li><li>  Verschiedene Rauschfunktionen erzeugen unterschiedliche Fehlerspektren, die verwendet werden können, wobei bekannt ist, welches Fehlerspektrum am wünschenswertesten ist. </li></ul><br>  Im nächsten Teil werden wir uns verschiedene Dithering-Funktionen ansehen - die, die ich in diesem Artikel verwendet habe (die Serie mit dem goldenen Schnitt) und das blaue Rauschen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481386/">https://habr.com/ru/post/de481386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481372/index.html">Indexierbarer binärer Baum</a></li>
<li><a href="../de481374/index.html">Habr Weekly # 32 / Rambler gab den Rücken frei, Manipulationen bei der Arbeit, wie man ein Haustierprojekt schützt, Gadgets machen leise Selfies</a></li>
<li><a href="../de481376/index.html">Analyse der Lektionen, die der Community von der NGINX-Situation beigebracht wurden</a></li>
<li><a href="../de481378/index.html">So optimieren Sie die Anwendungsentwicklung</a></li>
<li><a href="../de481382/index.html">Windows Native Applications und Acronis Active Restore</a></li>
<li><a href="../de481388/index.html">Wie Kryptowährungsbörsen ihre Blockchains aufbauen, die DeFi trotzen</a></li>
<li><a href="../de481390/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../de481392/index.html">Da habe ich eine zentralisierte Kryptowährung in PHP geschrieben. (Teil 1 - Grundlegende Zusammenfassungen + Schnellstart)</a></li>
<li><a href="../de481394/index.html">Neuerstellung in einem neuen Spiel, was wir für das alte geliebt haben</a></li>
<li><a href="../de481398/index.html">Grundlegende Linux-Befehle für Tester und mehr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>