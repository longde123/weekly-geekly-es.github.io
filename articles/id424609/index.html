<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‹ğŸ» ğŸŒ ğŸ§’ğŸ½ Cara memperpanjang Kubernetes ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ½ ğŸš ğŸ‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang DevOps, atau lebih tepatnya, terutama tentang Ops. Mereka mengatakan bahwa ada sangat sedikit orang yang puas den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara memperpanjang Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424609/">  Hari ini kita akan berbicara tentang DevOps, atau lebih tepatnya, terutama tentang Ops.  Mereka mengatakan bahwa ada sangat sedikit orang yang puas dengan tingkat otomatisasi operasi mereka.  Tapi situasinya sepertinya bisa diperbaiki.  Dalam artikel ini, Nikolai Ryzhikov akan berbicara tentang pengalamannya mengembangkan Kubernetes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/4f7/1a2/b1a4f71a2809a5b098e738ed4e0b5d3f.png"><br><br>  Materi disusun berdasarkan pidato Nikolai di konferensi musim gugur DevOops 2017. Di bawah potongan - video dan teks transkrip laporan. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3BMTNx2xCtQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <i>Saat ini, Nikolai Ryzhikov bekerja di sektor Kesehatan-TI untuk membuat sistem informasi medis.</i>  <i>Anggota komunitas programmer fungsional St. Petersburg FPROG.</i>  <i>Anggota aktif dari komunitas Clojure Online, anggota dari standar pertukaran informasi medis HL7 FHIR.</i>  <i>Telah pemrograman selama 15 tahun.</i> <br><hr><br>  Sisi apa yang kita miliki untuk DevOps?  Selama 10 tahun, formula DevOps kami cukup sederhana: pengembang bertanggung jawab atas operasi, pengembang dikerahkan, pengembang dipelihara.  Dengan pengaturan ini, yang terlihat agak keras, Anda akan menjadi DevOps.  Jika Anda ingin menerapkan DevOps dengan cepat dan menyakitkan - buat pengembang bertanggung jawab atas produksi Anda.  Jika para pria itu cerdas, maka mereka akan mulai keluar dan memahami segalanya. <br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/799/e0d/8f4799e0d6f25b897b6bd72f2ba1081a.png"><br>  Kisah kami: dahulu kala, ketika tidak ada Chef dan otomatisasi, kami sudah menggunakan Capistrano otomatis.  Kemudian mereka mulai membosankan dia, sehingga dia akan membuat mode.  Tapi kemudian Chef muncul.  Kami beralih ke sana dan pergi ke cloud: kami bosan dengan pusat data kami.  Kemudian Ansible muncul, Docker muncul.  Setelah itu, kami pindah ke Terraform dengan atasan Condo docker tulisan tangan di Camel.  Dan sekarang kita pindah ke Kubernetes. <br><img src="https://habrastorage.org/getpro/habr/post_images/366/af1/be8/366af1be8b4c4cf204553b48c8a76e70.png"><br>  Apa hal terburuk tentang operasi?  Sangat sedikit orang yang puas dengan tingkat otomatisasi operasi mereka.  Ini menakutkan, saya tegaskan: kami menghabiskan banyak sumber daya dan upaya untuk mengumpulkan semua tumpukan ini untuk diri kami sendiri, dan hasilnya tidak memuaskan. <br><br>  Ada perasaan bahwa dengan kedatangan Kubernetes, sesuatu dapat berubah.  Saya berkomitmen untuk lean manufacturing dan, dari sudut pandangnya, operasi pada umumnya tidak bermanfaat.  Operasi ideal adalah tidak adanya atau minimum operasi dalam suatu proyek.  Nilai dibuat ketika pengembang membuat produk.  Ketika sudah siap, pengiriman tidak menambah nilai.  Tetapi Anda perlu mengurangi biaya. <br><img src="https://habrastorage.org/getpro/habr/post_images/731/1a4/6e3/7311a46e3eb4d1d73d788f6ee881be3a.png"><br>  Bagi saya, cita-cita itu selalu heroku.  Kami menggunakannya untuk aplikasi sederhana, di mana pengembang untuk menyebarkan layanannya, itu sudah cukup untuk mengatakan git push dan mengkonfigurasi heroku.  Butuh satu menit. <br><img src="https://habrastorage.org/getpro/habr/post_images/a57/4c0/12b/a574c012ba1158086cd3578287d6d2a9.png"><br>  Bagaimana menjadi  Anda dapat membeli NoOps - juga heroku.  Dan saya menyarankan Anda untuk membeli, jika tidak, ada peluang untuk menghabiskan lebih banyak uang untuk pengembangan operasi normal. <br><br>  Ada Deis guys, mereka mencoba melakukan sesuatu seperti heroku di Kubernetes.  Ada cloud foundry, yang juga menyediakan platform untuk bekerja. <br><img src="https://habrastorage.org/getpro/habr/post_images/bbd/7b9/7e0/bbd7b97e07aae6af9a54663d633e3cc2.png"><br>  Tetapi jika Anda peduli dengan sesuatu yang lebih kompleks atau besar, Anda bisa melakukannya sendiri.  Sekarang, bersama dengan Docker dan Kubernetes, ini menjadi tugas yang dapat diselesaikan dalam jumlah waktu yang wajar dan dengan biaya yang masuk akal.  Dulu terlalu keras. <br><img src="https://habrastorage.org/getpro/habr/post_images/299/2d2/90a/2992d290a7167b9fe4a8cf2320528b8e.png"><br><h2>  Sedikit tentang Docker dan Kubernetes </h2><br>  Salah satu masalah operasi adalah pengulangan.  Hal hebat yang dibawa oleh buruh pelabuhan adalah dua fase.  Kami memiliki fase pembangunan. <br><br>  Poin kedua yang menyenangkan di buruh pelabuhan adalah antarmuka universal untuk meluncurkan layanan sewenang-wenang.  Seseorang merakit Docker, memasukkan sesuatu ke dalam, dan mengoperasikannya sudah cukup untuk mengatakan Docker menjalankan dan memulai. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b4/ca2/5ad/0b4ca25ade4ae7d3513539aaa576d3e7.png"><br><br>  Apa itu Kubernet?  Jadi kami membuat Docker dan kami perlu meluncurkan, mengintegrasikan, mengkonfigurasi dan menghubungkannya dengan orang lain di suatu tempat.  Kubernetes memungkinkan Anda untuk melakukan ini.  Dia memperkenalkan serangkaian abstraksi, yang disebut "sumber daya".  Kami akan dengan cepat melewati mereka dan bahkan mencoba untuk membuat. <br><br><h2>  Abstraksi </h2><br>  Abstraksi pertama adalah POD atau satu set wadah.  Dilakukan dengan benar, apa sebenarnya satu <b>set</b> wadah, dan bukan satu.  Set dapat mengaduk-aduk volume yang saling melihat melalui localhost.  Ini memungkinkan Anda untuk menggunakan pola seperti sespan (ini adalah saat kami meluncurkan wadah utama, dan ada wadah tambahan di sekitarnya yang membantunya). <br><br>  Misalnya, pendekatan duta besar.  Ini adalah saat Anda tidak ingin wadah berpikir di mana beberapa layanan berada.  Anda meletakkan wadah di sebelahnya yang tahu di mana layanan ini berada.  Dan mereka menjadi tersedia untuk wadah utama di localhost.  Dengan demikian, lingkungan mulai terlihat seperti Anda bekerja secara lokal. <br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/ab5/bda/0b8ab5bdae5f0d0e7375ff1b08efc6ee.png"><br>  Mari kita meningkatkan POD dan melihat bagaimana itu dijelaskan.  Secara lokal Anda dapat mengembangkan minikube.  Ini memakan banyak CPU, tetapi memungkinkan Anda untuk meningkatkan sekelompok Kubernet kecil di virtualbox dan bekerja dengannya. <br><br>  Mari kita gunakan POD.  Saya mengatakan Kubernet menerapkan dan membanjiri POD.  Saya dapat melihat POD apa yang saya miliki: Saya melihat satu POD digunakan.  Ini berarti bahwa Kubernetes telah meluncurkan kontainer ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/862/d90/970862d90a9afea1066caa69c1af63c8.png"></div><br>  Saya bahkan bisa masuk ke wadah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/603/8f7/1226038f78d2c9593826e7f26d611853.png"></div><br>  Dari perspektif ini, Kubernet dibuat untuk orang-orang.  Memang, apa yang terus-menerus kita lakukan dalam operasi, dalam pengikatan Kubernetes, misalnya, menggunakan utilitas kubectl, dapat dilakukan dengan mudah. <br><br>  Tapi POD itu fana.  Ini dimulai saat Docker dijalankan: jika seseorang menghentikannya, tidak ada yang akan mengangkatnya.  Di atas abstraksi ini, Kubernetes mulai membangun yang berikut - misalnya, sebuah replaset.  Ini adalah pengawas yang memantau POD, memantau jumlah mereka, dan jika POD jatuh, dia mengangkatnya.  Ini adalah konsep penyembuhan diri yang penting di Kubernetes yang memungkinkan Anda tidur nyenyak di malam hari. <br><br>  Replika di atas ada abstraksi penyebaran - juga sumber daya yang memungkinkan Anda melakukan penyebaran nol waktu.  Sebagai contoh, satu replika bekerja.  Ketika kami menyebarkan dan mengubah versi wadah, misalnya milik kami, di dalam penyebaran, replika lain muncul.  Kami menunggu sampai wadah-wadah ini mulai, memeriksa pemeriksaan kesehatannya, dan kemudian kami dengan cepat beralih ke replaset baru.  Juga latihan klasik dan bagus. <br><img src="https://habrastorage.org/getpro/habr/post_images/02e/d07/f33/02ed07f333733af0155ee539be18c669.png"><br>  Mari kita ambil layanan sederhana.  Misalnya, kami memiliki penempatan.  Di dalam, ia menggambarkan pola POD yang akan diambilnya.  Kita dapat menerapkan penyebaran ini, lihat apa yang kita miliki.  Fitur keren dari Kubernetes - semuanya terletak di basis data, dan kita dapat menyaksikan apa yang terjadi di sistem. <br><br>  Di sini kita melihat satu penyebaran.  Jika kita mencoba melihat POD, kita melihat bahwa beberapa POD telah meningkat.  Kita dapat mengambil dan menghapus POD ini.  Apa yang terjadi pada POD?  Satu dihancurkan, dan yang kedua segera naik.  Kontroler replika ini tidak menemukan POD yang diinginkan dan meluncurkan yang lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/7f4/0d4/5247f40d4fb21eb93bda0ce14124245e.png"></div><br>  Lebih lanjut, jika ini semacam layanan web, atau di dalam layanan kami harus berkomunikasi, kami memerlukan penemuan layanan.  Anda harus memberi layanan nama dan titik masuk.  Kubernetes menawarkan layanan yang disebut sumber daya untuk ini.  Ia dapat menangani keseimbangan muatan dan bertanggung jawab atas penemuan layanan. <br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/926/6e5/2fa9266e57c6718a81241ae1ac15da8e.png"><br>  Mari kita lihat layanan sederhana.  Kami menghubungkannya dengan penyebaran dan POD melalui label: tautan dinamis tersebut.  Konsep yang sangat penting di Kubernetes: sistemnya dinamis.  Tidak masalah dalam urutan apa semua ini akan dibuat.  Layanan akan mencoba menemukan POD dengan label tersebut dan memulai keseimbangan bebannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b48/992/f7d/b48992f7dca832fce9b45276936a4914.png"></div><br>  Terapkan layanan, lihat layanan apa yang kami miliki.  Kami masuk ke POD pengujian kami, yang dinaikkan, dan lakukan nslookup.  Kubernetes memberi kami DNS-ku di mana layanan dapat melihat dan menemukan satu sama lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b05/66f/01e/b0566f01e54210ea26c5b6526b0ed0de.png"></div><br>  Layanan lebih merupakan antarmuka.  Ada beberapa implementasi yang berbeda, karena tugas-tugas penyeimbangan beban dan layanan cukup rumit: dalam satu cara kami bekerja dengan database biasa, yang lain dengan yang dimuat, dan beberapa yang sederhana dibuat cukup sederhana.  Ini juga merupakan konsep penting dalam Kubernetes: beberapa hal dapat disebut antarmuka daripada implementasi.  Mereka tidak diperbaiki secara kaku, dan berbeda, misalnya, penyedia cloud memberikan implementasi yang berbeda.  Misalnya, ada volume persisten sumber daya, yang sudah diterapkan di setiap cloud tertentu dengan cara regulernya. <br><br>  Selanjutnya, kami biasanya ingin mengeluarkan layanan web.  Kubernetes memiliki abstraksi masuknya.  Biasanya SSL ditambahkan di sana. <br><img src="https://habrastorage.org/getpro/habr/post_images/fc7/69e/4e7/fc769e4e7a526588c3f3ae32388d9c11.png"><br>  Masuknya paling sederhana terlihat seperti ini.  Di sana kami menulis aturan: untuk url mana, untuk host mana, layanan internal mana untuk mengarahkan permintaan.  Dengan cara yang sama, kita dapat meningkatkan masuknya kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69d/79c/046/69d79c046478f1fde2a073f2fe37067f.png"></div><br>  Setelah itu, setelah mendaftar secara lokal di host, Anda dapat melihat layanan ini dari sini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/752/75c/73d75275c26a468f49cd192e781595db.png"></div><br>  Ini adalah tugas yang biasa: kami mengerahkan layanan web tertentu, bertemu sedikit dengan Kubernetes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a3/1f8/c2f/1a31f8c2f639a4758d95719ee6dca1e0.png"></div><br>  Kami akan membersihkan semuanya, menghapus masuknya dan melihat semua sumber daya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c75/990/40c/c7599040cd85c2c155e8acf057be0246.png"></div><br>  Ada sejumlah sumber daya, seperti configmap dan rahasia.  Ini murni sumber daya informasi yang dapat Anda pasang di wadah dan transfer di sana, misalnya, kata sandi dari postgres.  Anda bisa mengaitkan ini dengan variabel lingkungan yang akan disuntikkan ke wadah saat startup.  Anda dapat memasang sistem file.  Semuanya cukup nyaman: tugas standar, solusi bagus. <br><br>  Ada volume persisten - sebuah antarmuka yang diimplementasikan secara berbeda oleh penyedia cloud yang berbeda.  Ini dibagi menjadi dua bagian: ada klaim volume persisten (permintaan), dan kemudian beberapa EBS dibuat yang menyeret ke wadah.  Anda dapat bekerja dengan layanan stateful. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/5c1/2f7/cd65c12f71d417ffd11e3e62c76b484c.png"><br><br>  Tetapi bagaimana cara kerjanya di dalam?  Konsepnya sendiri sangat sederhana dan transparan.  Kubernetes memiliki dua bagian.  Salah satunya hanyalah sebuah database di mana kita memiliki semua sumber daya ini.  Sumber daya dapat dianggap sebagai tablet: khusus, contoh ini hanya catatan di tablet.  Di atas Kubernetes, server API dikonfigurasi.  Artinya, ketika Anda memiliki kluster Kubernetes, Anda biasanya berkomunikasi dengan server API (lebih tepatnya, klien berkomunikasi dengannya). <br><br>  Dengan demikian, apa yang kami buat (POD, layanan, dll.) Hanya ditulis ke basis data.  Basis data ini diimplementasikan oleh ETCD, mis.  sehingga stabil di level tinggi yang tersedia. <br><br>  Apa yang terjadi selanjutnya?  Selanjutnya di bawah setiap jenis sumber daya ada pengontrol tertentu.  Ini hanyalah layanan yang memonitor jenis sumber dayanya dan melakukan sesuatu di dunia luar.  Misalnya, apakah Docker berjalan.  Jika kita memiliki POD, untuk setiap Node ada layanan kubelet yang memonitor POD yang terhubung ke node ini.  Dan semua yang dia lakukan adalah Docker dijalankan setelah pemeriksaan berkala berikutnya jika POD ini tidak ada. <br><br>  Selanjutnya, yang sangat penting - semuanya terjadi secara real time, sehingga kekuatan kontroler ini lebih tinggi dari minimum.  Seringkali, pengontrol masih mengambil metrik dan melihat apa yang dimulai.  Yaitu  menghapus umpan balik dari dunia nyata dan menulisnya ke database, sehingga Anda atau pengontrol lain dapat melihatnya.  Misalnya, status POD yang sama akan ditulis kembali ke ETCD. <br><br>  Dengan demikian, semuanya diimplementasikan di Kubernetes.  Sangat keren bahwa model informasi dipisahkan dari ruang operasi.  Dalam database melalui antarmuka CRUD biasa kami menyatakan apa yang seharusnya.  Kemudian serangkaian pengontrol mencoba untuk membuat semuanya menjadi benar.  Benar, ini tidak selalu terjadi. <br><br>  Ini adalah model cybernetic.  Kami memiliki preset tertentu, ada beberapa jenis mesin yang mencoba mengarahkan dunia nyata atau mesin ke tempat yang dibutuhkan.  Tidak selalu berubah seperti ini: kita harus memiliki umpan balik.  Terkadang mesin tidak dapat melakukan ini dan harus beralih ke seseorang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59e/0a9/1e8/59e0a91e8974351a5f0f49fd94709c9a.png"><br><br>  Dalam sistem nyata, kami berpikir dalam abstraksi dari tingkat berikutnya: kami memiliki beberapa layanan, basis data, dan kami semua menghubungkannya.  Kami tidak memikirkan POD dan Ingress, dan kami ingin membangun beberapa tingkat abstraksi berikutnya. <br><img src="https://habrastorage.org/getpro/habr/post_images/77f/5cb/697/77f5cb6974c6ac85e0b5e8b13921d672.png"><br>  Sehingga pengembang semudah mungkin: sehingga dia hanya berkata, "Saya ingin memulai layanan ini dan itu," dan segala sesuatu yang terjadi di dalam. <br><br>  Ada yang namanya HELM.  Ini adalah cara yang salah - gaya templating mungkin, di mana kami hanya mencoba untuk menelurkan satu set sumber daya yang dikonfigurasi dan menjatuhkannya ke cluster Kubernetes. <br><br>  Masalahnya, pertama, adalah ini hanya dilakukan pada saat bergulir.  Artinya, dia tidak bisa menerapkan banyak logika.  Kedua, dalam runtime abstraksi ini menghilang.  Ketika saya pergi untuk melihat cluster saya, saya hanya melihat POD dan layanan.  Saya tidak melihat bahwa layanan ini dan itu digunakan, bahwa basis ini dan itu dengan replikasi dinaikkan di sana.  Saya hanya melihat puluhan perapian di sana.  Abstraksi menghilang seperti dalam matriks. <br><img src="https://habrastorage.org/getpro/habr/post_images/696/6e6/9bd/6966e69bd8b289229194911f62a11f84.png"><br><h2>  Model Solusi Internal </h2><br>  Di sisi lain, Kubernetes sendiri sudah menyediakan model ekstensi yang sangat menarik dan sederhana di dalamnya.  Kami dapat mendeklarasikan jenis sumber daya baru, misalnya penyebaran.  Ini adalah sumber daya yang dibangun di atas POD atau replaset.  Kita dapat menulis pengontrol untuk sumber daya ini, menempatkan sumber daya ini dalam database dan menjalankan lingkaran cybernetic kami sehingga semuanya berfungsi.  Ini kedengarannya menarik, dan menurut saya ini adalah cara yang tepat untuk memperluas Kubernetes. <br><img src="https://habrastorage.org/getpro/habr/post_images/39e/491/c51/39e491c511ea25078eda191097d88b24.png"><br>  Saya ingin dapat menulis manifes untuk layanan gaya heroku saya.  Contoh yang sangat sederhana: Saya ingin menggunakan beberapa jenis aplikasi di lingkungan saya yang sebenarnya.  Sudah memiliki perjanjian, SSL, domain yang dibeli.  Saya hanya ingin memberi para pengembang antarmuka sesederhana mungkin.  Manifest memberitahu saya wadah mana yang harus diangkat, sumber daya apa yang masih dibutuhkan wadah ini.  Dia melempar pengumuman ini ke cluster, dan semuanya mulai bekerja. <br><img src="https://habrastorage.org/getpro/habr/post_images/a91/24e/8a8/a9124e8a8309c952cc0a65b32f28d76f.png"><br><br>  Bagaimana ini akan terlihat dalam hal sumber daya kustom dan pengontrol?  Di sini kita akan memiliki aplikasi sumber daya dalam database.  Dan pengontrol aplikasi akan menelurkan tiga sumber.  Artinya, ia akan menuliskan aturan tentang cara rute ke layanan ini, memulai layanan untuk menyeimbangkan beban dan meluncurkan penyebaran dengan beberapa jenis konfigurasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/807/938/d22/807938d229cb312ca761214fa30829ed.png"><br><br>  Sebelum kita membuat sumber daya khusus di Kubernetes, kita perlu mendeklarasikannya.  Untuk ini, ada sumber daya meta yang disebut CustomResourceDefinition. <br><br>  Untuk mendeklarasikan sumber daya baru di Kubernetes, cukup bagi kami untuk mengirim pengumuman seperti itu.  Pertimbangkan ini buat tabel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/253/7d3/09e2537d3520f688c7029a357d9773dd.png"></div><br>  Membuat tabel.  Setelah itu, kita dapat melihat melalui kubectl mendapatkan sumber daya pihak ketiga yang kita miliki.  Segera setelah kami mengumumkannya, kami juga mendapat spanduk.  Kita dapat melakukan, misalnya, kubeclt mendapatkan aplikasi.  Namun sejauh ini tidak ada aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5b/c40/9ad/d5bc409ad70866a12358ccb68ba497f8.png"></div><br>  Mari kita menulis beberapa aplikasi.  Setelah itu, kita dapat membuat instance sumber daya kustom.  Mari kita melihatnya di YAML dan membuatnya dengan memposting ke URL tertentu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/e55/454/044e554549dc4dc00d262ecf49d8d72d.png"></div><br>  Jika kita menjalankan dan melihat kubectl, maka satu aplikasi muncul.  Tetapi sementara tidak ada yang terjadi, itu hanya terletak di database.  Anda dapat, misalnya, mengambil dan meminta semua sumber daya aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/234/74d/70123474de1bf62ece27d49587098368.png"></div><br>  Kita dapat membuat sumber daya kedua dari templat yang sama hanya dengan mengubah namanya.  Ini sumber kedua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/a58/4b0/842a584b09631555234babcbd3c7e57c.png"></div><br>  Selanjutnya, controller kita harus melakukan templating, mirip dengan apa yang dilakukan HELM.  Yaitu, setelah menerima deskripsi aplikasi kami, saya harus menghasilkan penyebaran sumber daya dan layanan sumber daya, serta membuat entri masuk.  Ini adalah bagian yang paling mudah: di sini di clojure adalah erlmacro.  Saya melewati struktur data, itu menarik fungsi penyebaran, lolos ke debug, yang merupakan pipa.  Dan ini adalah fungsi murni: templating sederhana.  Oleh karena itu, dalam bentuk yang paling naif, saya dapat segera membuatnya, mengubahnya menjadi utilitas konsol dan mulai mendistribusikannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b33/bf5/2cb/b33bf52cbd901d2c5e0a0641daed9161.png"></div><br>  Kami melakukan hal yang sama untuk layanan: fungsi layanan menerima deklarasi dan menghasilkan sumber daya Kubernetes untuk kami. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/daf/e7f/c2edafe7f36d7c0db4573054991c436a.png"></div><br>  Kami melakukan hal yang sama untuk baris masuknya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d0/22f/156/5d022f15612aa3dcc19f635b0dd9b403.png"></div><br>  Bagaimana ini semua bekerja?  Akan ada sesuatu di dunia nyata dan akan ada yang kita inginkan.  Apa yang kita inginkan - kita mengambil sumber daya aplikasi dan menghasilkan apa yang seharusnya.  Dan sekarang kita perlu melihat apa itu.  Apa yang kami minta melalui REST API.  Kami bisa mendapatkan semua layanan, semua penyebaran. <br><br>  Bagaimana cara kerja kontroler kustom kami?  Dia akan menerima apa yang kita inginkan dan apa yang ada, ambil dari div ini dan berlaku untuk Kubernetes.  Ini mirip dengan Bereaksi.  Saya datang dengan DOM virtual ketika beberapa fungsi hanya menghasilkan pohon objek JS.  Dan kemudian algoritma tertentu menghitung tambalan dan menerapkannya ke DOM nyata. <br><br>  Kami akan melakukan hal yang sama di sini.  Ini dilakukan dalam 50 baris kode.  Ingin - semuanya ada di Github.  Pada akhirnya, kita harus mendapatkan fungsi tindakan rekonsiliasi. <br><br>  Kami memiliki fungsi tindakan rekonsiliasi yang tidak melakukan apa-apa dan hanya menghitung div ini.  Dia mengambil apa yang ada, ditambah apa yang dibutuhkan.  Dan kemudian memberikan apa yang perlu dilakukan untuk membawa yang pertama ke yang kedua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/460/49b/90d/46049b90d8fa93dfe9279c02828cfa1c.png"></div><br>  Mari kita tarik dia.  Tidak ada yang salah dengan dirinya, dia bisa dihancurkan.  Dia mengatakan bahwa Anda perlu membuat layanan masuknya, buat dua entri di dalamnya, buat penyebaran 1 dan 2, buat layanan 1 dan 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/c0a/c10/c72c0ac10e4924fde59ed749339345aa.png"></div><br>  Dalam hal ini, seharusnya hanya ada satu layanan.  Kami melihat dari ingress bahwa hanya satu entri yang tersisa. <br><br>  Kemudian yang tersisa adalah menulis fungsi yang menerapkan tambalan ini ke kluster Kubernetes.  Untuk melakukan ini, kita cukup meneruskan aksi rekonsiliasi ke fungsi rekonsiliasi, dan semuanya akan berlaku.  Dan sekarang kita melihat bahwa POD telah meningkat, penyebaran telah menjadi dan layanan telah dimulai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/144/1a5/66b1441a56d805344c7e734d3b9b2c80.png"></div><br>  Mari kita tambahkan layanan lain: jalankan fungsi rekonsiliasi tindakan lagi.  Mari kita lihat apa yang terjadi.  Semuanya dimulai, semuanya baik-baik saja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32a/f9f/c1e/32af9fc1e444ed1c135e4bbe828a946f.png"></div><br>  Bagaimana cara menghadapinya?  Kami mengemas semua ini dalam wadah Docker.  Setelah itu, kita menulis fungsi yang secara berkala bangun, membuat rekonsiliasi, dan tertidur.  Kecepatan tidak terlalu penting, ia bisa tidur selama lima detik dan melakukan aksi rekonsiliasi yang tidak begitu sering. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bec/04e/8d1/bec04e8d1791843d80aed4f2b3f2a673.png"></div><br>  Pengontrol khusus kami hanyalah layanan yang akan bangun dan menghitung tambalan secara berkala. <br><br>  Sekarang kami memiliki dua layanan zaddeloino, mari kita hapus salah satu aplikasi.  Mari kita lihat bagaimana gugus kita bereaksi: semuanya baik-baik saja.  Kami menghapus yang kedua: semuanya sudah dihapus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ff/a23/96e/5ffa2396ef22187604393a9ae657edd5.png"></div><br>  Mari kita lihat melalui mata pengembang.  Dia hanya perlu mengatakan Kubernetes mendaftar dan memberi nama layanan baru.  Kami melakukan ini, pengontrol kami mengambil semuanya dan menciptakannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd6/ca6/3d7/bd6ca63d77dfbadee1587b6f44a680bd.png"></div><br>  Lalu kami mengumpulkan semua ini di layanan penerapan, dan kami melemparkan pengontrol khusus ini ke dalam cluster menggunakan alat standar Kubernetes.  Kami membuat abstraksi untuk 200 baris kode. <br><br>  Semuanya terlihat seperti BANTUAN, tetapi sebenarnya lebih kuat.  Pengontrol bekerja dalam sebuah cluster: ia melihat pangkalan, melihat dunia luar dan dapat dibuat cukup pintar. <br><br><h2>  CI sendiri </h2><br>  Perhatikan contoh ekstensi Kubernetes.  Kami memutuskan bahwa CI harus menjadi bagian dari infrastruktur.  Ini bagus, nyaman dari sudut pandang keamanan - repositori pribadi.  Kami mencoba menggunakan jenkins, tetapi ini adalah alat yang sudah ketinggalan zaman.  Saya ingin seorang hacker CI.  Kami tidak membutuhkan antarmuka, kami suka ChatOps: biarkan saja yang mengatakan dalam obrolan apakah build telah jatuh atau belum.  Selain itu, saya ingin men-debug semuanya secara lokal. <br><img src="https://habrastorage.org/getpro/habr/post_images/9a4/ecf/86e/9a4ecf86e022a465ce11072352456728.png"><br>  Kami duduk dan menulis CI kami dalam seminggu.  Sama seperti ekstensi ke Kubernetes.  Jika Anda berpikir tentang CI, maka ini hanyalah alat yang menjalankan beberapa jenis pekerjaan.  Sebagai bagian dari pekerjaan ini, kami membangun sesuatu, menjalankan tes, dan sering menggunakan. <br><br>  Bagaimana cara kerjanya?  Itu dibangun pada konsep pengendali kustom yang sama. -,    Kubernetes  ,     .        web-hook.    . <br><br>   web-hook,    â€”   JSON       build,      Kubernetes.   build    build controller,   manifest,   ,   POD.   POD-    . <br><br>  POD-   agent,      travis  circleci,   YAML  .    .           Telegram. <br><br>  ,      Kubernetes â€”  ,        CI  continuous delivery    while true sleep 10,   POD    .   kubectl exec,       . <br><br>   â€”         ,  .        300  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/334/ec3/72f334ec33db75d3b32e4c464a24dc03.png"><br><br><h2>   postgres </h2><br>     postgres,      .     extensions.      RDS   -. <br><br>         postgres.  .    Â«,   postgres,   Â».   ,      ,  ,     .    ,    cluster controller       .   pginstance-,     istance postgres.   cluster postgres. <br><br>  pginstance controller,  ,     POD  deployment   postgres.   persistent volume.        postgres.    Docker-container,     binary postgres.  :      postgres   .    ,     ,  ,     ,    ..    POD   persistent volume    postgres cluster  master. <br><br>     deployment  master.      persistent volume.  POD ,   ,  ,     deployment  slave. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, pengontrol kluster membuat sumber daya cadangan (setelah dijelaskan dengan cadangan). Dan pengendali cadangan sudah mengambilnya dan melemparkannya ke beberapa S3.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/972/b42/457/972b42457c664d988fd8eeee0aaa603c.png"><br><br><h2>  Apa selanjutnya </h2><br>      .   ,           ,  ,    Â«  postgres,   kafka,   CI    Â».   . <br><br>      ,  ,   , ,        .    operations     information-.        ,   ,      , , resource application.         .        .   .  logical  relation . <br><br>    Kubernetes â€”   REST API       ,     .          ,  ,    : Â«    ,    Â».     sql   .   generic ,     .    . <br><img src="https://habrastorage.org/getpro/habr/post_images/fb4/f1e/930/fb4f1e930029011d081eeb911203d289.png"><br><br><blockquote>    â€”   <b>DevOops 2018</b> !     â€”  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«The DevOps HandbookÂ»</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«Learning Chef: A Guide to Configuration Management and AutomationÂ»</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«How to containerize your Go codeÂ»</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«Liquid Software: How to Achieve Trusted Continuous Updates in the DevOps WorldÂ»</a> â€”      .         -    . <br><br>  :       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ! <br><br>    : <b> 1 </b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  DevOops 2018    . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424609/">https://habr.com/ru/post/id424609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424599/index.html">Anda harus memilih perangkat lunak mana yang Anda butuhkan: ditulis tepat waktu atau berkualitas tinggi</a></li>
<li><a href="../id424601/index.html">Arsitektur informasi di Internet bagian 1</a></li>
<li><a href="../id424603/index.html">Buku â€œMengapa kita salah? Berpikir Perangkap dalam Tindakan. " Kutipan Bagian 1</a></li>
<li><a href="../id424605/index.html">Dana Zuckerberg: Kolaborasi + Teknologi + Open Science</a></li>
<li><a href="../id424607/index.html">Naiknya Helidon</a></li>
<li><a href="../id424611/index.html">Cara membuat karyawan dari freelancer</a></li>
<li><a href="../id424613/index.html">Pengalaman menggunakan redux tanpa reduksi</a></li>
<li><a href="../id424615/index.html">Output fungsi kurva untuk parameter, sinyal, dan tidak terbatas membatasi Wolfram Mathematica saja</a></li>
<li><a href="../id424621/index.html">Superhero non-film. Siapa dan bagaimana melindungi situs konstruksi Lakhta Center dari kebakaran?</a></li>
<li><a href="../id424623/index.html">Mari kita proses suara di Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>