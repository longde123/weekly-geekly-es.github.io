<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>㊙️ 🎑 🍏 Gérer les intercepteurs dans React 👩🏼 💪🏿 👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Avec une fierté et un soulagement incroyables, nous avons remis ce soir un nouveau livre sur React à l'imprimerie. 



 A cette occa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gérer les intercepteurs dans React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428632/">  Bonjour, Habr! <br><br>  Avec une fierté et un soulagement incroyables, nous avons remis ce soir un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouveau livre sur React</a> à l'imprimerie. <br><br><img src="https://habrastorage.org/webt/yy/eu/am/yyeuamoit3imb91e5gligyk4oys.jpeg"><br><br>  A cette occasion, nous vous proposons une traduction légèrement abrégée d'un article de Dan Abramov, décrivant l'utilisation des intercepteurs dans la 16e version de React.  Le livre, que nous attendons déjà avec impatience, est décrit au chapitre 5. <br><a name="habracut"></a><br>  La semaine dernière, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sophie Alpert et moi avons</a> présenté le concept des «intercepteurs» lors de la conférence React Conf, suivie d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion</a> détaillée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur</a> le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sujet</a> par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ryan Florence</a> . <br><br>  Je vous recommande fortement de regarder cette conférence plénière pour vous familiariser avec l'éventail des problèmes que nous essayons de résoudre avec l'aide d'intercepteurs.  Cependant, même l'heure de votre temps que j'apprécie beaucoup, j'ai donc décidé de décrire brièvement dans cet article les principales considérations pour les intercepteurs. <br><blockquote>  Remarque: les intercepteurs React sont encore expérimentaux.  Pas besoin de s'y plonger tout de suite.  Notez également que cette publication expose mes opinions personnelles, qui peuvent ne pas coïncider avec la position des développeurs de React. </blockquote>  <b>Pourquoi faut-il des intercepteurs?</b> <br><br>  Il est connu que l'organisation des composants et un flux descendant de données aident à organiser une grande interface utilisateur sous la forme de petits fragments indépendants et réutilisables.  <b>Cependant, il n'est souvent pas possible de décomposer des composants complexes au-delà d'une certaine limite, car la logique préserve l'état et n'est pas extractible dans une fonction ou un autre composant</b> .  Parfois, ceux qui disent que React ne parvient pas à une «séparation des tâches» s'en plaignent. <br>  De tels cas sont très courants et sont associés, par exemple, à l'animation, au traitement des formulaires, à la connexion à des sources de données externes et à de nombreuses autres opérations que nous pourrions avoir besoin d'effectuer avec nos composants.  En essayant de résoudre ces problèmes avec des composants seuls, nous obtenons généralement: <br><br><ul><li>  <b>Composants géants</b> difficiles à refactoriser et à tester. </li><li> <b>Duplication de la logique</b> entre divers composants et méthodes de cycle de vie. </li><li>  <b>Modèles complexes</b> , en particulier, accessoires de rendu et composants d'ordre supérieur. </li></ul><br>  Nous pensons que les intercepteurs sont les plus prometteurs pour résoudre tous ces problèmes.  <b>Les intercepteurs aident à organiser la logique à l'intérieur du composant sous la forme d'unités isolées réutilisables</b> : <br><br><img src="https://habrastorage.org/webt/4g/xr/jw/4gxrjwrsbsq2o6nqjrcjvq8lifo.jpeg"><br><br><img src="https://habrastorage.org/webt/cs/sx/ac/cssxacn4rnmwuob4lhtqflnnyxw.jpeg"><br><br>  <b>Les intercepteurs sont conformes à la philosophie React (flux de données explicite et composition) et au sein d'un composant, et pas seulement entre les composants</b> .  C'est pourquoi il me semble que les intercepteurs s'intègrent naturellement dans le modèle de composant React. <br><br>  Contrairement aux modèles tels que les propriétés de rendu ou les composants d'ordre supérieur, les renifleurs ne surchargent pas votre arborescence de composants avec des pièces jointes inutilement profondes.  De plus, ils ne présentent pas les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inconvénients</a> inhérents aux impuretés. <br><br>  Même si à première vue les intercepteurs vous déforment (tout comme moi au début!) Je recommande de donner une chance à cette option et de l'expérimenter.  Je pense que vous l'aimerez. <br><br>  <b>Le gonflement de React est-il dû aux intercepteurs?</b> <br><br>  Jusqu'à ce que nous ayons couvert les intercepteurs en détail, vous pouvez craindre que l'ajout d'intercepteurs dans React ne soit qu'une multiplication d'entités.  C'est une critique juste.  Je pense ceci: bien qu'à court terme, vous ressentiez vraiment une charge cognitive supplémentaire (pour les étudier), au final vous vous sentirez mieux. <br><br>  <b>Si les intercepteurs prennent racine dans la communauté React, alors en fait le nombre d'entités à gérer lors de l'écriture d'applications React <i>sera réduit</i></b> .  À l'aide d'intercepteurs, vous pouvez constamment utiliser des fonctions, plutôt que de basculer entre les fonctions, les classes, les composants d'ordre supérieur et le rendu des composants. <br><br>  Quant à l'augmentation de la taille de l'implémentation, l'application React avec le support des intercepteurs n'augmente que d'environ ~ 1,5 Ko (min + gzip).  Bien que cela ne soit pas trop en soi, il est très probable que <b>lorsque vous utilisez des intercepteurs, la taille de votre assembly diminue même</b> , car le code d'intercepteur est généralement mieux minifié qu'un code équivalent utilisant des classes.  L'exemple suivant est légèrement extrême, mais il montre clairement pourquoi tout est ainsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://twitter.com/jamiebuilds/status/1056015484364087297/photo/1%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1056015484364087297%26ref_url%3D">cliquez</a> pour développer le fil entier): <br><br><img src="https://habrastorage.org/webt/_z/zp/7k/_zzp7ky6u-3dcsitdyla1mt-ive.jpeg"><br><br>  <b>Il n'y a aucun changement révolutionnaire à la proposition d'intercepteur</b> .  Votre code fonctionnera correctement même si vous commencez à utiliser des intercepteurs dans de nouveaux composants.  En fait, c'est exactement ce que nous recommandons: ne réécrivez rien au niveau mondial!  Il serait sage d'attendre que l'utilisation d'intercepteurs soit établie dans tout le code critique.  Néanmoins, nous serons reconnaissants si vous pouvez expérimenter avec la version alpha 16.7 et nous laisser des commentaires sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">proposition d'intercepteurs</a> , ainsi que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/login%3Freturn_to%3D">signaler tout bogue</a> . <br><br>  <b>Qu'est-ce que c'est - les intercepteurs?</b> <br><br>  Pour comprendre ce que sont les intercepteurs, vous devez revenir en arrière et réfléchir à la réutilisation du code. <br><br>  Il existe de nombreuses façons de réutiliser la logique dans les applications React aujourd'hui.  Donc, pour calculer quelque chose, vous pouvez écrire des fonctions simples, puis les appeler.  Vous pouvez également écrire des composants (qui peuvent eux-mêmes être des fonctions ou des classes).  Les composants sont plus puissants, mais lorsque vous travaillez avec eux, vous devez afficher une interface utilisateur.  Par conséquent, l'utilisation de composants n'est pas pratique pour transmettre une logique non visuelle.  Nous arrivons donc à des motifs complexes comme les propriétés de rendu et les composants d'ordre supérieur.  <b>React ne faciliterait-il pas la tâche s'il n'y avait qu'une seule façon générale de réutiliser le code, et pas tant?</b> <br><br>  Les fonctions semblent être parfaites pour le code réutilisable.  Passer la logique entre les fonctions est le moins cher.  Cependant, l'état local de React ne peut pas être stocké dans les fonctions.  Vous ne pouvez pas extraire un comportement comme «suivre la taille de la fenêtre et l'état de mise à jour» ou «animer une valeur pendant un certain temps» à partir d'un composant de classe sans restructurer le code ou sans introduire d'abstractions telles que Observables.  Les deux approches ne font que compliquer le code, et React est gentil avec notre simplicité. <br><br>  Les intercepteurs résolvent ce problème.  Grâce aux intercepteurs, vous pouvez utiliser les fonctionnalités React (par exemple, state) à partir d'une fonction - en l'appelant une seule fois.  React fournit plusieurs intercepteurs intégrés qui correspondent aux briques React: état, cycle de vie et contexte. <br><br>  <b>Étant donné que les intercepteurs sont des fonctions JavaScript normales, vous pouvez combiner les intercepteurs intégrés fournis dans React pour créer des «intercepteurs natifs»</b> .  Ainsi, des problèmes complexes peuvent être résolus avec une seule ligne de code, puis le multiplier dans votre application ou le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://twitter.com/seldo/status/1057030727512911874%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1057030727512911874%26ref_url%3D">partager dans la communauté React</a> <br><br>  Attention: à proprement parler, vos propres intercepteurs ne font pas partie des fonctionnalités de React.  La capacité d'écrire vos propres intercepteurs découle naturellement de leur organisation très interne. <br><br>  <b>Montrez-moi le code!</b> <br><br>  Supposons que nous voulons abonner un composant à la largeur de la fenêtre actuelle (par exemple, pour afficher un autre contenu ou une zone de visualisation plus étroite). <br>  Un code similaire peut être écrit aujourd'hui de plusieurs manières.  Par exemple, pour créer une classe, créer plusieurs méthodes de cycle de vie, ou peut-être même recourir à des propriétés de rendu ou appliquer un composant d'ordre supérieur si vous recherchez une réutilisation.  Cependant, je pense que rien ne se compare à cela: <br><br><img src="https://habrastorage.org/webt/it/yg/sm/itygsmtcllercyaret5qvglik7u.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gist.github.com/gaearon/cb5add26336003ed8c0004c4ba820eae</a> <br><br>  <b>Si vous lisez ce code, cela signifie qu'il fait exactement ce qu'il dit</b> .  Nous utilisons la largeur de la fenêtre à l'intérieur de notre composant et React redessine votre composant s'il change.  C'est précisément pour cela que les intercepteurs sont nécessaires - pour rendre les composants vraiment déclaratifs, même s'ils contiennent des états et des effets secondaires. <br><br>  Considérez comment ce propre intercepteur pourrait être implémenté.  Nous pourrions utiliser l'état React local pour y conserver la largeur actuelle de la fenêtre et définir l'état lorsque la fenêtre est redimensionnée à l'aide d'un effet secondaire: <br><br><img src="https://habrastorage.org/webt/9t/wf/rx/9twfrxgngukwpy1geu5m8hvcqjk.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gist.github.com/gaearon/cb5add26336003ed8c0004c4ba820eae</a> <br><br>  Comme illustré ci-dessus, les intercepteurs <code>useState</code> comme <code>useState</code> et <code>useEffect</code> servent de briques.  Nous pouvons les utiliser directement à partir de nos composants, ou assembler nos propres intercepteurs à partir d'eux, par exemple, <code>useWindowWidth</code> .  Utiliser vos propres intercepteurs ne semble pas moins idiomatique que de travailler avec l'API React intégrée. <br><br>  En savoir plus sur les intercepteurs intégrés dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette revue</a> . <br><br>  <b>Les intercepteurs sont encapsulés - chaque fois que l'intercepteur est appelé, il reçoit un état local isolé à l'intérieur du composant en cours d'exécution</b> .  Dans cet exemple particulier, ce n'est pas important (la largeur de la fenêtre est la même pour tous les composants!), Mais c'est justement là que réside la puissance des intercepteurs!  Ils sont destinés à séparer non pas la logique, mais la conservation de l'état.  <b>Nous ne voulons pas interrompre le flux de données en aval!</b> <br><br>  Chaque intercepteur peut contenir certains états locaux et effets secondaires.  Vous pouvez transférer des données entre plusieurs intercepteurs, comme cela se fait habituellement entre les fonctions.  Ils peuvent prendre des arguments et renvoyer des valeurs car ce sont des fonctions JavaScript. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici un exemple de</a> bibliothèque d'animation React où nous expérimentons avec des intercepteurs: <br>  Remarquez comment une animation époustouflante est implémentée dans le code source illustré: nous transmettons des valeurs entre plusieurs intercepteurs natifs au sein de la même fonction de rendu. <br><br><img src="https://habrastorage.org/webt/uc/h_/fs/uch_fszu4xmd8xnegfqvwz-flzc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">codesandbox.io/s/ppxnl191zx</a> <br><br>  (Cet exemple est traité plus en détail dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce guide</a> .) <br><br>  En raison de la possibilité de transférer des données entre les intercepteurs, ils sont très pratiques pour implémenter des animations, s'abonner aux données, gérer des formulaires et travailler avec d'autres abstractions avec état.  <b>Contrairement aux propriétés de rendu ou aux composants d'ordre supérieur, les intercepteurs ne créent pas de «fausse hiérarchie» dans votre arborescence de rendu</b> .  Ils ressemblent plus à une liste bidimensionnelle de "cellules de mémoire" attachées à un composant.  Pas de niveaux supplémentaires. <br><br>  <b>Et les cours?</b> <br><br>  À notre avis, nos propres intercepteurs sont le détail le plus intéressant de toute l'offre.  Mais pour que ses propres intercepteurs soient fonctionnels, React doit fournir au niveau des fonctions la capacité de déclarer l'état et les effets secondaires.  C'est exactement ce qui nous permet de faire des intercepteurs <code>useState</code> comme <code>useState</code> et <code>useEffect</code> .  En savoir plus à ce sujet dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br><br>  Il s'avère que de tels intercepteurs intégrés sont pratiques non seulement lors de la création de vos propres intercepteurs.  Ils sont également suffisants pour déterminer les composants dans leur ensemble, car ils nous fournissent les capacités nécessaires - par exemple, l'état.  C'est pourquoi nous souhaitons que les intercepteurs deviennent le principal moyen de définir les composants React à l'avenir. <br>  Non, nous ne prévoyons pas d'abolir progressivement les cours.  Nous utilisons des dizaines de milliers de composants de classe sur Facebook et nous (tout comme vous) ne voulons absolument pas les réécrire.  Mais, si la communauté React commence à utiliser des intercepteurs, il deviendra inapproprié de conserver les deux façons recommandées d'écrire des composants.  Les intercepteurs couvrent tous les cas pratiques dans lesquels les classes sont utilisées, mais offrent une plus grande flexibilité lors de l'extraction, du test et de la réutilisation du code.  C'est pourquoi nous connectons les intercepteurs à nos idées sur l'avenir de React. <br><br>  <b>Et si les intercepteurs sont magiques?</b> <br><br>  Peut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">-</a> être que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les règles d'interception</a> vous dérouteront. <br><br>  <b>Bien qu'il ne soit pas habituel d'appeler un intercepteur au niveau supérieur, vous ne voudriez probablement pas déterminer vous-même la condition dans la condition, même si vous le pouviez</b> .  Par exemple, un état lié à une condition ne peut pas être déterminé en classe, et pendant quatre ans de communication avec les utilisateurs de React, je n'ai entendu aucune plainte à ce sujet. <br><br>  Une telle conception est essentielle pour introduire vos propres intercepteurs sans introduire de bruit de syntaxe excessif ou créer des pièges.  Nous comprenons que par habitude, c'est difficile, mais nous pensons que ce compromis est acceptable, compte tenu des opportunités qu'il offre.  Si vous n'êtes pas d'accord, je vous suggère de vous expérimenter et d'essayer comment vous aimez cette approche. <br><br>  Nous utilisons des hooks de production depuis un mois maintenant pour voir si les nouvelles règles vont dérouter les programmeurs.  La pratique montre qu'une personne maîtrise les intercepteurs en quelques heures.  J'avoue que ces règles me semblaient à première vue une hérésie, mais ce sentiment s'est rapidement dissipé.  C'est l'impression que j'ai eue lors de ma première rencontre avec React.  (Vous n'aimiez pas React? Et je ne l'ai aimé que pour la deuxième fois.) <br><br>  Attention: au niveau de l'implémentation des intercepteurs, il n'y a pas de magie non plus.  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jamie</a> , elle obtient quelque chose comme ça: <br><br><img src="https://habrastorage.org/webt/cf/xl/zt/cfxlztqheooupmcgmecqjp1kk2g.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gist.github.com/gaearon/62866046e396f4de9b4827eae861ff19</a> <br><br>  Nous maintenons une liste éclatée d'intercepteurs et passons au composant suivant de la liste chaque fois que vous utilisez un intercepteur.  Grâce aux règles des intercepteurs, leur ordre est le même dans n'importe quel moteur de rendu, donc à chaque appel, nous pouvons fournir au composant l'état correct. <br><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans cet article de Rudy Yardley,</a> tout est magnifiquement expliqué sur les photos!) <br><br>  Vous vous êtes peut-être demandé où React stocke l'état des intercepteurs.  Au même endroit que l'état des cours.  React dispose d'une file d'attente de mise à jour interne qui contient la vérité ultime pour chaque état, quelle que soit la façon dont vous définissez vos composants. <br><br>  Les intercepteurs sont indépendants des proxys et des getters, qui sont si courants dans les bibliothèques JavaScript modernes.  Par conséquent, on peut affirmer qu'il y a moins de magie dans les intercepteurs que dans d'autres approches populaires pour résoudre de tels problèmes.  Pas plus que dans <code>array.push</code> et <code>array.pop</code> (dans le cas où l'ordre des appels est également important!) <br><br>  La conception de l'intercepteur n'est pas liée à React.  En fait, quelques jours après la publication de la proposition, diverses personnes nous ont montré des implémentations expérimentales de la même API d'intercepteur pour Vue, des composants Web et même des fonctions JavaScript ordinaires. <br>  Enfin, si vous êtes fanatiquement dévoué à la programmation fonctionnelle et que vous n'êtes pas à l'aise lorsque React commence à s'appuyer sur un état modifiable dans le cadre d'une implémentation.  Mais, cela peut vous rassurer que le traitement des intercepteurs peut être implémenté dans sa forme pure, se limitant aux effets algébriques (s'ils étaient pris en charge en JavaScript).  Naturellement, au niveau intra-système, React s'est toujours appuyé sur un état mutable - et c'est exactement ce que vous souhaitez éviter. <br><br>  Quel que soit le point de vue le plus proche de vous - pragmatique ou dogmatique - j'espère qu'au moins une de ces options vous semble logique.  Plus important encore, à mon avis, les intercepteurs simplifient notre travail et il devient plus pratique pour les utilisateurs de travailler.  C'est ce que les intercepteurs me soudoient comme ça. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428632/">https://habr.com/ru/post/fr428632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428620/index.html">Comment créer Roguelike</a></li>
<li><a href="../fr428624/index.html">Jeffrey Richter, Pavel Yosifovich, Greg Young et tout-tout. Hardcore et architecture à DotNext 2018 Moscou</a></li>
<li><a href="../fr428626/index.html">Comment rendre l'extension en PHP7 plus difficile que "bonjour, monde", et ne pas devenir aux yeux rouges. Partie 1</a></li>
<li><a href="../fr428628/index.html">Travailler avec des arbres de syntaxe JavaScript abstraits</a></li>
<li><a href="../fr428630/index.html">Non, le Bitcoin ne détruira pas notre climat d'ici 2033.</a></li>
<li><a href="../fr428634/index.html">Portage de Quake3</a></li>
<li><a href="../fr428636/index.html">Roskomnadzor va récupérer une amende de Google</a></li>
<li><a href="../fr428638/index.html">Hearts Flame Motor: examen du moniteur cardiaque QardioCore</a></li>
<li><a href="../fr428640/index.html">Avec le combiné dans votre poche: équipement Snom DECT pour réseaux téléphoniques sans fil</a></li>
<li><a href="../fr428644/index.html">Brainfuck de bas niveau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>