<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåù üßìüèæ üë®‚Äç‚úàÔ∏è WAL in PostgreSQL: 3. Checkpoint ü§òüèº üå¥ üë®üèΩ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns bereits mit dem Puffer-Cache- Ger√§t vertraut gemacht, einem der Hauptobjekte im gemeinsam genutzten Speicher, und festgestellt, dass Sie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL in PostgreSQL: 3. Checkpoint</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/460423/">  Wir haben uns bereits mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puffer-Cache-</a> Ger√§t vertraut gemacht, einem der Hauptobjekte im gemeinsam genutzten Speicher, und festgestellt, dass Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Voraufzeichnungsprotokoll f√ºhren</a> m√ºssen, um einen Fehler zu beheben, wenn der Inhalt des RAM verloren geht. <br><br>  Das ungel√∂ste Problem, das wir beim letzten Mal gestoppt haben, ist, dass nicht bekannt ist, zu welchem ‚Äã‚ÄãZeitpunkt Sie die Protokolle w√§hrend der Wiederherstellung wiedergeben k√∂nnen.  Von Anfang an zu funktionieren, wie der K√∂nig von <em>Alice</em> geraten hat, wird nicht funktionieren: Es ist unm√∂glich, alle Journaleintr√§ge vom Serverstart an zu speichern - dies ist m√∂glicherweise eine gro√üe Menge und dieselbe gro√üe Wiederherstellungszeit.  Wir brauchen einen solchen Schritt vorw√§rts, von dem aus wir mit der Wiederherstellung beginnen k√∂nnen (und dementsprechend alle vorherigen Journaleintr√§ge sicher l√∂schen k√∂nnen).  Dies ist der <em>Kontrollpunkt</em> , der heute diskutiert wird. <br><br><h1>  Kontrollpunkt </h1><br>  Welche Eigenschaft sollte ein Kontrollpunkt haben?  Wir m√ºssen sicher sein, dass alle Journaleintr√§ge, beginnend mit dem Pr√ºfpunkt, auf Seiten angewendet werden, die auf die Festplatte geschrieben wurden.  Wenn dies nicht der Fall w√§re, k√∂nnten wir w√§hrend der Wiederherstellung eine zu alte Version der Seite von der Festplatte lesen und einen Journaleintrag darauf anwenden, wodurch die Daten unwiderruflich besch√§digt w√ºrden. <br><a name="habracut"></a><br>  Wie bekomme ich einen Haltepunkt?  Die einfachste M√∂glichkeit besteht darin, das System regelm√§√üig anzuhalten und alle verschmutzten Seiten des Puffers und anderer Caches auf die Festplatte zu leeren.  (Beachten Sie, dass Seiten nur geschrieben, aber nicht aus dem Cache ausgeworfen werden.) Solche Punkte erf√ºllen die Bedingung, aber nat√ºrlich m√∂chte niemand mit einem System arbeiten, das auf unbestimmte, aber sehr wichtige Zeit st√§ndig einfriert. <br><br>  In der Praxis ist daher alles etwas komplizierter: Ein Kontrollpunkt von einem Punkt wird zu einem Segment.  Zuerst <em>starten</em> wir <em>den</em> Haltepunkt.  Danach, ohne die Arbeit zu unterbrechen und wenn m√∂glich, ohne Spitzenlasten zu erzeugen, werfen wir langsam schmutzige Puffer auf die Festplatte. <br><br><img src="https://habrastorage.org/webt/n0/ch/6f/n0ch6fdrfxkylmuqjdar7idfxsw.png"><br><br>  Wenn alle Puffer geschrieben wurden, <em>die zu Beginn des</em> Pr√ºfpunkts verschmutzt waren, wird der Pr√ºfpunkt als <em>vollst√§ndig betrachtet</em> .  Jetzt (aber nicht fr√ºher) k√∂nnen wir den Startpunkt als den Punkt verwenden, von dem aus Sie mit der Wiederherstellung beginnen k√∂nnen.  Und die Journaleintr√§ge bis zu diesem Punkt brauchen wir nicht mehr. <br><br><img src="https://habrastorage.org/webt/q4/th/83/q4th83seql63dkrgfmg7esu3zh8.png"><br><br>  Der Checkpoint wird von einem speziellen Hintergrund-Checkpointer-Prozess behandelt. <br><br>  Die Dauer verschmutzter Puffer wird durch den Wert des Parameters <em>checkpoint_completion_target</em> bestimmt.  Es zeigt an, wie viel Zeit zwischen zwei benachbarten Kontrollpunkten die Aufzeichnung stattfinden wird.  Der Standardwert ist 0,5 (wie in den obigen Abbildungen), dh die Aufzeichnung dauert die H√§lfte der Zeit zwischen den Kontrollpunkten.  Typischerweise wird der Wert f√ºr eine gr√∂√üere Gleichm√§√üigkeit auf 1,0 erh√∂ht. <br><br>  Betrachten wir genauer, was passiert, wenn ein Kontrollpunkt ausgef√ºhrt wird. <br><br>  Der Pr√ºfpunktprozess l√∂scht zuerst die Transaktionsstatuspuffer (XACT) auf die Festplatte.  Da es nur wenige davon gibt (insgesamt 128), werden sie sofort aufgezeichnet. <br><br>  Dann beginnt die Hauptarbeit - das Schreiben schmutziger Seiten aus dem Puffercache.  Wie bereits erw√§hnt, k√∂nnen nicht alle Seiten gleichzeitig zur√ºckgesetzt werden, da die Gr√∂√üe des Puffercaches erheblich sein kann.  Daher werden zun√§chst alle aktuell verschmutzten Seiten im Puffercache in den Headern mit einem speziellen Flag markiert. <br><br><img src="https://habrastorage.org/webt/_4/ym/eq/_4ymeqozl8o23kwq6su9ntvjujk.png"><br><br>  Und dann durchl√§uft der Checkpoint-Prozess nach und nach alle Puffer und l√∂scht die auf der Festplatte markierten.  Denken Sie daran, dass Seiten nicht aus dem Cache ausgeworfen, sondern nur auf die Festplatte geschrieben werden, sodass Sie nicht auf die Anzahl der Aufrufe des Puffers oder dessen Korrektur achten m√ºssen. <br><br>  Beschriftete Puffer k√∂nnen auch von Serverprozessen geschrieben werden - je nachdem, wer zuerst in den Puffer gelangt.  In jedem Fall wird das zuvor gesetzte Flag bei der Aufzeichnung entfernt, sodass (zum Zweck des Pr√ºfpunkts) der Puffer nur einmal geschrieben wird. <br><br>  W√§hrend der Ausf√ºhrung des Pr√ºfpunkts √§ndern sich die Seiten nat√ºrlich weiterhin im Puffercache.  Neue verschmutzte Puffer werden jedoch nicht markiert, und der Checkpoint-Prozess sollte sie nicht schreiben. <br><br><img src="https://habrastorage.org/webt/fg/uo/vm/fguovmm8yzy0jb4jwisgg10nmm8.png"><br><br>  Am Ende seiner Arbeit erstellt der Prozess einen Journaleintrag f√ºr das Ende des Pr√ºfpunkts.  Dieser Datensatz enth√§lt die LSN des Arbeitsbeginns des Kontrollpunkts.  Da der Kontrollpunkt zu Beginn seiner Arbeit nichts in das Protokoll schreibt, kann dieser LSN einen beliebigen Protokolldatensatz enthalten. <br><br>  Dar√ºber hinaus aktualisiert die Datei $ PGDATA / global / pg_control die Angabe des zuletzt √ºbergebenen Pr√ºfpunkts.  Bevor der Pr√ºfpunkt abgeschlossen ist, zeigt pg_control auf den vorherigen Pr√ºfpunkt. <br><br><img src="https://habrastorage.org/webt/w0/cy/gi/w0cygixp3k4k3qscwfa2nlapqna.png"><br><br>  Um die Arbeit des Pr√ºfpunkts zu betrachten, erstellen Sie eine Tabelle. Die Seiten werden in den Puffercache verschoben und sind verschmutzt: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre> <pre> <code class="plaintext hljs"> count ------- 78 (1 row)</code> </pre><br>  Merken Sie sich die aktuelle Position im Protokoll: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A048 (1 row)</code> </pre><br>  Jetzt f√ºhren wir den Pr√ºfpunkt manuell aus und stellen sicher, dass sich keine fehlerhaften Seiten im Cache befinden (wie gesagt, es k√∂nnen neue fehlerhafte Seiten angezeigt werden, aber in unserem Fall gab es keine √Ñnderungen im Prozess der Ausf√ºhrung des Pr√ºfpunkts): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Mal sehen, wie sich der Pr√ºfpunkt im Protokoll widerspiegelte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A0E4 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A048 -e 0/3514A0E4</code> </pre><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/3514A048, prev 0/35149CEC, desc: RUNNING_XACTS nextXid 101105 latestCompletedXid 101104 oldestRunningXid 101105</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A07C, prev 0/3514A048, desc: CHECKPOINT_ONLINE redo 0/3514A048; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 101105; online</code> </pre><br>  Hier sehen wir zwei Eintr√§ge.  Der letzte ist eine Aufzeichnung des Passierens des Kontrollpunkts (CHECKPOINT_ONLINE).  Die LSN des Starts des Pr√ºfpunkts wird nach dem Wort "Wiederherstellen" angezeigt, und diese Position entspricht dem Journaleintrag, der der letzte am Anfang des Pr√ºfpunkts war. <br><br>  Wir finden die gleichen Informationen in der Kontrolldatei: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | egrep 'Latest.*location'</code> </pre><pre> <code class="plaintext hljs">Latest checkpoint location: 0/3514A07C Latest checkpoint's REDO location: 0/3514A048</code> </pre><br><h1>  Wiederherstellung </h1><br>  Jetzt sind wir bereit, den im vorherigen Artikel beschriebenen Wiederherstellungsalgorithmus zu kl√§ren. <br><br>  Wenn der Server beim n√§chsten Start abst√ºrzt, erkennt der Startvorgang dies, indem er sich die Datei pg_control ansieht und einen anderen Status als "Herunterfahren" anzeigt.  In diesem Fall wird eine automatische Wiederherstellung durchgef√ºhrt. <br><br>  Zun√§chst liest der Wiederherstellungsprozess aus derselben pg_control die Position des Starts des Kontrollpunkts.  (Um das Bild zu vervollst√§ndigen, stellen wir fest, dass, wenn die Datei backup_label vorhanden ist, der Datensatz des Kontrollpunkts daraus gelesen wird. Dies ist f√ºr die Wiederherstellung aus Sicherungen erforderlich, dies ist jedoch ein Thema f√ºr einen separaten Zyklus.) <br><br>  Dann liest er das Magazin ausgehend von der gefundenen Position und wendet nacheinander Journaleintr√§ge auf die Seiten an (falls erforderlich, wie wir es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letztes Mal</a> besprochen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> ). <br><br>  Abschlie√üend werden alle nicht journalisierten Tabellen mit Bildern in den Init-Dateien √ºberschrieben. <br><br>  Zu diesem Zeitpunkt wird der Startvorgang beendet und der Checkpointer-Prozess f√ºhrt sofort einen Checkpoint aus, um den wiederhergestellten Status auf der Festplatte zu beheben. <br><br>  Sie k√∂nnen einen Fehler simulieren, indem Sie den Server im Sofortmodus zwangsweise stoppen. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop -m immediate --skip-systemctl-redirect</code> </pre><br>  (Der Schl√ºssel <code>--skip-systemctl-redirect</code> wird hier ben√∂tigt, da PostgreSQL in Ubuntu aus dem Paket installiert wird. Er wird vom Befehl pg_ctlcluster gesteuert, der tats√§chlich systemctl aufruft, und ruft bereits pg_ctl auf. Bei all diesen Wrappern wird der Modusname angegeben geht dabei verloren und mit dem <code>--skip-systemctl-redirect</code> k√∂nnen Sie auf systemctl verzichten und wichtige Informationen speichern.) <br><br>  √úberpr√ºfen Sie den Clusterstatus: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Beim Start erkennt PostgreSQL, dass ein Fehler aufgetreten ist und eine Wiederherstellung erforderlich ist. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:49.441 MSK [8865] LOG: database system was interrupted; last known up at 2019-07-17 15:27:48 MSK 2019-07-17 15:27:49.801 MSK [8865] LOG: database system was not properly shut down; automatic recovery in progress 2019-07-17 15:27:49.804 MSK [8865] LOG: redo starts at 0/3514A048 2019-07-17 15:27:49.804 MSK [8865] LOG: invalid record length at 0/3514A0E4: wanted 24, got 0 2019-07-17 15:27:49.804 MSK [8865] LOG: redo done at 0/3514A07C 2019-07-17 15:27:49.824 MSK [8864] LOG: database system is ready to accept connections 2019-07-17 15:27:50.409 MSK [8872] [unknown]@[unknown] LOG: incomplete startup packet</code> </pre><br>  Die Notwendigkeit einer Wiederherstellung wird im Nachrichtenprotokoll vermerkt: Das <em>Datenbanksystem wurde nicht ordnungsgem√§√ü heruntergefahren.</em>  <em>automatische Wiederherstellung l√§uft</em> .  Anschlie√üend werden die Journaleintr√§ge an der unter ‚ÄûWiederherstellen beginnt um‚Äú markierten Position abgespielt und fortgesetzt, bis die n√§chsten Journaleintr√§ge abgerufen werden k√∂nnen.  Damit ist die Wiederherstellung an der Position "Wiederherstellen um" abgeschlossen, und das DBMS beginnt mit der Arbeit mit Clients (das <em>Datenbanksystem ist bereit, Verbindungen zu akzeptieren</em> ). <br><br>  Und was passiert beim normalen Herunterfahren des Servers?  Um verschmutzte Seiten auf die Festplatte zu √ºbertragen, trennt PostgreSQL alle Clients und f√ºhrt dann den endg√ºltigen Pr√ºfpunkt aus. <br><br>  Merken Sie sich die aktuelle Position im Protokoll: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A14C (1 row)</code> </pre><br>  Stoppen Sie nun vorsichtig den Server: <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br>  √úberpr√ºfen Sie den Clusterstatus: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: shut down</code> </pre><br>  Und im Protokoll finden wir den einzigen Datensatz √ºber den endg√ºltigen Kontrollpunkt (CHECKPOINT_SHUTDOWN): <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A14C</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A14C, prev 0/3514A0E4, desc: CHECKPOINT_SHUTDOWN redo 0/3514A14C; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</code> </pre><pre> <code class="plaintext hljs">pg_waldump: FATAL: error in WAL record at 0/3514A14C: invalid record length at 0/3514A1B4: wanted 24, got 0</code> </pre><br>  (In einer schrecklichen t√∂dlichen Nachricht m√∂chte pg_waldump nur sagen, dass er bis zum Ende des Magazins gelesen hat.) <br><br>  F√ºhren Sie die Instanz erneut aus. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><h1>  Hintergrundaufnahme </h1><br>  Wie wir herausgefunden haben, ist der Pr√ºfpunkt einer der Prozesse, die schmutzige Seiten aus dem Puffercache auf die Festplatte schreiben.  Aber nicht der einzige. <br><br>  Wenn das Backend die Seite aus dem Puffer schieben muss und die Seite verschmutzt ist, muss es sie selbst auf die Festplatte schreiben.  Dies ist eine schlechte Situation, die zu Erwartungen f√ºhrt - es ist viel besser, wenn die Aufnahme asynchron im Hintergrund erfolgt. <br><br>  Daher gibt es zus√§tzlich zum Checkpoint- <em>Prozess</em> auch <em>einen Hintergrundaufzeichnungsprozess</em> (Hintergrundschreiber, Bgwriter oder nur Schreiber).  Dieser Prozess verwendet denselben Puffersuchalgorithmus wie der Preemption-Mechanismus.  Grunds√§tzlich gibt es zwei Unterschiede. <br><br><ol><li>  Es wird kein Zeiger auf das "n√§chste Opfer" verwendet, sondern ein eigener.  Er kann dem Zeiger auf das "Opfer" voraus sein, bleibt aber nie hinter ihm zur√ºck. </li><li>  Beim Durchlaufen von Puffern verringert sich der Trefferz√§hler nicht. </li></ol><br>  Es werden Puffer geschrieben, die gleichzeitig sind: <br><br><ul><li>  ge√§nderte Daten enthalten (verschmutzt), </li><li>  nicht fest (Pinanzahl = 0), </li><li>  habe null Treffer (Nutzungsanzahl = 0). </li></ul><br>  Der Hintergrundaufzeichnungsprozess l√§uft also sozusagen dem Verdr√§ngen voraus und findet die Puffer, die wahrscheinlich bald √ºberf√ºllt sein werden.  Aus diesem Grund sollten Serviceprozesse im Idealfall feststellen, dass die von ihnen ausgew√§hlten Puffer verwendet werden k√∂nnen, ohne das Schreiben anzuhalten. <br><br><h1>  Anpassung </h1><br>  <em>Der Pr√ºfpunktprozess wird</em> normalerweise aus den folgenden Gr√ºnden konfiguriert. <br><br>  Zuerst m√ºssen Sie entscheiden, wie viele Protokolldateien wir uns leisten k√∂nnen (und welche Wiederherstellungszeit f√ºr uns geeignet ist).  Je gr√∂√üer, desto besser, aber aus offensichtlichen Gr√ºnden wird dieser Wert begrenzt sein. <br><br>  Als n√§chstes k√∂nnen wir berechnen, wie lange dieses Volumen unter normaler Last erzeugt wird.  Wir haben bereits dar√ºber nachgedacht, wie dies zu tun ist (wir m√ºssen uns die Positionen im Journal merken und voneinander subtrahieren). <br><br>  Diese Zeit ist unser √ºbliches Intervall zwischen Kontrollpunkten.  Wir schreiben es in den Parameter <em>checkpoint_timeout</em> .  Der Standardwert von 5 Minuten ist offensichtlich zu klein, normalerweise wird die Zeit beispielsweise auf eine halbe Stunde erh√∂ht.  Ich wiederhole: Je seltener Sie sich Meilensteine ‚Äã‚Äãleisten k√∂nnen, desto besser - dies reduziert den Overhead. <br><br>  Es ist jedoch m√∂glich (und sogar wahrscheinlich), dass die Last manchmal h√∂her als normal ist und zu viele Journaleintr√§ge in der im Parameter angegebenen Zeit generiert werden.  In diesem Fall m√∂chte ich den Kontrollpunkt √∂fter ausf√ºhren.  Dazu geben wir im Parameter <em>max_wal_size</em> den Betrag an, der innerhalb desselben Kontrollpunkts g√ºltig ist.  Wenn das tats√§chliche Volumen mehr erreicht wird, initiiert der Server einen au√üerplanm√§√üigen Pr√ºfpunkt. <br><br>  Daher treten die meisten Kontrollpunkte nach einem Zeitplan auf: einmal pro <em>checkpoint_timeout-</em> Zeiteinheit.  Bei erh√∂hter Last wird der Kontrollpunkt jedoch h√§ufiger aufgerufen, wenn das Volumen <em>max_wal_size erreicht ist</em> . <br><br>  Es ist wichtig zu verstehen, dass der Parameter <em>max_wal_size</em> √ºberhaupt nicht die maximale Menge bestimmt, die Protokolldateien auf der Festplatte belegen k√∂nnen. <br><br><ul><li>  Um einen Fehler zu beheben, m√ºssen Sie die Dateien ab dem Zeitpunkt speichern, an dem der letzte Pr√ºfpunkt √ºbergeben wurde, sowie die Dateien, die sich w√§hrend des Betriebs des aktuellen Pr√ºfpunkts angesammelt haben.  Daher kann das Gesamtvolumen grob gesch√§tzt werden als <br>  (1 + <em>checkpoint_completion_target</em> ) √ó <em>max_wal_size</em> . </li><li>  Vor Version 11 hat PostgreSQL auch Dateien f√ºr den zwei Jahre alten Pr√ºfpunkt gespeichert. Bis zu Version 10 in der obigen Formel m√ºssen Sie also 2 anstelle von 1 festlegen. </li><li>  Der Parameter <em>max_wal_size</em> ist nur ein Wunsch, aber keine feste Grenze.  Es kann sich herausstellen, mehr. </li><li>  Der Server ist nicht berechtigt, Protokolldateien zu l√∂schen, die noch nicht √ºber die Replikationssteckpl√§tze √ºbertragen wurden und die w√§hrend der kontinuierlichen Archivierung noch nicht archiviert wurden.  Wenn diese Funktionalit√§t verwendet wird, ist eine st√§ndige √úberwachung erforderlich, da der Serverspeicher leicht √ºberlaufen kann. </li></ul><br>  Um das Bild zu vervollst√§ndigen, k√∂nnen Sie nicht nur die maximale Lautst√§rke, sondern auch die minimale Lautst√§rke <em>einstellen</em> : Parameter <em>min_wal_size</em> .  Die Bedeutung dieser Einstellung ist, dass der Server keine Dateien l√∂scht, w√§hrend sie in das Volume in <em>min_wal_size</em> passen, sondern sie einfach umbenennt und erneut verwendet.  Dies spart Ihnen ein wenig, indem Sie st√§ndig Dateien erstellen und l√∂schen. <br><br>  <em>Die Hintergrundaufzeichnung</em> ist nach der Konfiguration des Pr√ºfpunkts sinnvoll zu konfigurieren.  Zusammen m√ºssen diese Prozesse Zeit haben, um verschmutzte Puffer zu schreiben, bevor sie von Wartungsprozessen ben√∂tigt werden. <br><br>  Der Hintergrundaufzeichnungsprozess l√§uft in Zyklen von h√∂chstens <em>bgwriter_lru_maxpages-</em> Seiten ab und schl√§ft zwischen den Zyklen auf <em>bgwriter_delay ein</em> . <br><br>  Die Anzahl der Seiten, die in einem Arbeitszyklus aufgezeichnet werden, wird durch die durchschnittliche Anzahl der Puffer bestimmt, die von Wartungsprozessen aus dem letzten Lauf angefordert wurden (unter Verwendung eines gleitenden Durchschnitts, um die Ungleichm√§√üigkeiten zwischen den L√§ufen auszugleichen, h√§ngt jedoch nicht von einer langen Historie ab).  Die berechnete Anzahl von Puffern wird mit dem Koeffizienten <em>bgwriter_lru_multiplier multipliziert</em> (in jedem Fall wird <em>bgwriter_lru_maxpages</em> jedoch nicht √ºberschritten). <br><br>  Standardwerte: <em>bgwriter_delay</em> = 200 ms (h√∂chstwahrscheinlich zu viel, es <em>tritt</em> in 1/5 Sekunde viel Wasser aus), <em>bgwriter_lru_maxpages</em> = 100, <em>bgwriter_lru_multiplier</em> = 2.0 (wir versuchen, vorzeitig auf die Nachfrage zu reagieren). <br><br>  Wenn der Prozess √ºberhaupt keine verschmutzten Puffer erkennt (dh im System passiert nichts), wird er in den Ruhezustand versetzt, woraus abgeleitet wird, dass der Serverprozess auf den Puffer zugreift.  Danach wacht der Prozess auf und funktioniert wieder wie gewohnt. <br><br><h1>  √úberwachung </h1><br>  Die Einstellungen f√ºr Kontrollpunkt und Hintergrundaufzeichnung k√∂nnen und sollten angepasst werden, um Feedback von der √úberwachung zu erhalten. <br><br>  Der Parameter <em>checkpoint_warning</em> zeigt eine Warnung an, wenn Pr√ºfpunkte, die durch √úberl√§ufe der Protokolldateigr√∂√üe verursacht werden, zu h√§ufig ausgef√ºhrt werden.  Der Standardwert betr√§gt 30 Sekunden und muss mit dem Wert von <em>checkpoint_timeout</em> in Einklang gebracht werden. <br><br>  Der Parameter <em>log_checkpoints</em> (standardm√§√üig deaktiviert) erm√∂glicht den Empfang von Informationen zu den ausgef√ºhrten Pr√ºfpunkten im Servernachrichtenprotokoll.  Schalten Sie es ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_checkpoints = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  √Ñndern Sie nun etwas in den Daten und f√ºhren Sie den Pr√ºfpunkt aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> n = n + <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>;</code> </pre><br>  Im Nachrichtenprotokoll sehen wir ungef√§hr Folgendes: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 2 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:55.248 MSK [8962] LOG: checkpoint starting: immediate force wait 2019-07-17 15:27:55.274 MSK [8962] LOG: checkpoint complete: wrote 79 buffers (0.5%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.013 s, total=0.025 s; sync files=2, longest=0.011 s, average=0.006 s; distance=1645 kB, estimate=1645 kB</code> </pre><br>  Hier k√∂nnen Sie sehen, wie viele Puffer geschrieben wurden, wie sich die Zusammensetzung der Protokolldateien nach dem Kontrollpunkt ge√§ndert hat, wie lange der Kontrollpunkt gedauert hat und wie weit (in Byte) die benachbarten Kontrollpunkte voneinander entfernt sind. <br><br>  Die wahrscheinlich n√ºtzlichste Information ist jedoch die Statistik der Arbeit von Pr√ºfpunkt- und Hintergrundaufzeichnungsprozessen in der Ansicht pg_stat_bgwriter.  Die Ansicht ist eins f√ºr zwei, da beide Aufgaben einmal von einem Prozess ausgef√ºhrt wurden.  dann wurden ihre Funktionen geteilt, und die Sicht blieb. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_bgwriter \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------+------------------------------ checkpoints_timed | 0 checkpoints_req | 1 checkpoint_write_time | 1 checkpoint_sync_time | 13 buffers_checkpoint | 79 buffers_clean | 0 maxwritten_clean | 0 buffers_backend | 42 buffers_backend_fsync | 0 buffers_alloc | 363 stats_reset | 2019-07-17 15:27:49.826414+03</code> </pre><br>  Hier sehen wir unter anderem die Anzahl der abgeschlossenen Kontrollpunkte: <br><br><ul><li>  checkpoints_timed - gem√§√ü Zeitplan (bei Erreichen von checkpoint_timeout), </li><li>  checkpoints_req - auf Anfrage (auch bei Erreichen von max_wal_size). </li></ul><br>  Der gro√üe Wert von checkpoint_req (im Vergleich zu checkpoints_timed) zeigt an, dass Kontrollpunkte h√§ufiger als erwartet auftreten. <br><br>  Wichtige Informationen zur Anzahl der aufgezeichneten Seiten: <br><br><ul><li>  buffers_checkpoint - Checkpoint-Prozess, </li><li>  buffers_backend - durch Serving von Prozessen, </li><li>  buffers_clean - Hintergrundaufzeichnungsprozess. </li></ul><br>  Auf einem gut abgestimmten System sollte der Wert von buffers_backend wesentlich kleiner sein als die Summe von buffers_checkpoint und buffers_clean. <br><br>  Maxwritten_clean ist auch n√ºtzlich, um die Hintergrundaufzeichnung <em>einzurichten</em> . Diese Zahl gibt an, wie oft der Hintergrundaufzeichnungsprozess aufgrund von √úberschreitungen von <em>bgwriter_lru_maxpages nicht</em> mehr <em>funktioniert</em> . <br><br>  Sie k√∂nnen die akkumulierten Statistiken mit dem folgenden Aufruf zur√ºcksetzen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_stat_reset_shared(<span class="hljs-string"><span class="hljs-string">'bgwriter'</span></span>);</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460423/">https://habr.com/ru/post/de460423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460411/index.html">Mad Converter GIF'ok zu animierten Aufklebern f√ºr Telegramm</a></li>
<li><a href="../de460413/index.html">7 n√ºtzliche Websites und Anwendungen zum Lernen von Englisch</a></li>
<li><a href="../de460415/index.html">Apple Watch 4 (44 mm, 2019) gegen Pebble Steel Classic (2014)</a></li>
<li><a href="../de460419/index.html">Abgasw√§rmer√ºckgewinnung: umweltfreundlich</a></li>
<li><a href="../de460421/index.html">Optischer TP-Link T2600G-28SQ-Switch f√ºr Dienstanbieter: Eine detaillierte √úberpr√ºfung</a></li>
<li><a href="../de460425/index.html">H√∂llenk√§lte, Levitation und Plasma: Vergangenheit, Gegenwart und Zukunft der Supraleitung</a></li>
<li><a href="../de460431/index.html">Erstellen einer automatisierten Testpipeline auf Azure DevOps</a></li>
<li><a href="../de460433/index.html">Risiken und Bedrohungen im Internet der Dinge</a></li>
<li><a href="../de460435/index.html">Kleine Freude # 8: kleine Freuden f√ºr die Arbeit mit der Datenbank</a></li>
<li><a href="../de460437/index.html">Wie wir ein technisches Support-Fahrrad herausbringen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>