<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌝 🧓🏾 👨‍✈️ WAL in PostgreSQL: 3. Checkpoint 🤘🏼 🌴 👨🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns bereits mit dem Puffer-Cache- Gerät vertraut gemacht, einem der Hauptobjekte im gemeinsam genutzten Speicher, und festgestellt, dass Sie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL in PostgreSQL: 3. Checkpoint</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/460423/">  Wir haben uns bereits mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puffer-Cache-</a> Gerät vertraut gemacht, einem der Hauptobjekte im gemeinsam genutzten Speicher, und festgestellt, dass Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Voraufzeichnungsprotokoll führen</a> müssen, um einen Fehler zu beheben, wenn der Inhalt des RAM verloren geht. <br><br>  Das ungelöste Problem, das wir beim letzten Mal gestoppt haben, ist, dass nicht bekannt ist, zu welchem ​​Zeitpunkt Sie die Protokolle während der Wiederherstellung wiedergeben können.  Von Anfang an zu funktionieren, wie der König von <em>Alice</em> geraten hat, wird nicht funktionieren: Es ist unmöglich, alle Journaleinträge vom Serverstart an zu speichern - dies ist möglicherweise eine große Menge und dieselbe große Wiederherstellungszeit.  Wir brauchen einen solchen Schritt vorwärts, von dem aus wir mit der Wiederherstellung beginnen können (und dementsprechend alle vorherigen Journaleinträge sicher löschen können).  Dies ist der <em>Kontrollpunkt</em> , der heute diskutiert wird. <br><br><h1>  Kontrollpunkt </h1><br>  Welche Eigenschaft sollte ein Kontrollpunkt haben?  Wir müssen sicher sein, dass alle Journaleinträge, beginnend mit dem Prüfpunkt, auf Seiten angewendet werden, die auf die Festplatte geschrieben wurden.  Wenn dies nicht der Fall wäre, könnten wir während der Wiederherstellung eine zu alte Version der Seite von der Festplatte lesen und einen Journaleintrag darauf anwenden, wodurch die Daten unwiderruflich beschädigt würden. <br><a name="habracut"></a><br>  Wie bekomme ich einen Haltepunkt?  Die einfachste Möglichkeit besteht darin, das System regelmäßig anzuhalten und alle verschmutzten Seiten des Puffers und anderer Caches auf die Festplatte zu leeren.  (Beachten Sie, dass Seiten nur geschrieben, aber nicht aus dem Cache ausgeworfen werden.) Solche Punkte erfüllen die Bedingung, aber natürlich möchte niemand mit einem System arbeiten, das auf unbestimmte, aber sehr wichtige Zeit ständig einfriert. <br><br>  In der Praxis ist daher alles etwas komplizierter: Ein Kontrollpunkt von einem Punkt wird zu einem Segment.  Zuerst <em>starten</em> wir <em>den</em> Haltepunkt.  Danach, ohne die Arbeit zu unterbrechen und wenn möglich, ohne Spitzenlasten zu erzeugen, werfen wir langsam schmutzige Puffer auf die Festplatte. <br><br><img src="https://habrastorage.org/webt/n0/ch/6f/n0ch6fdrfxkylmuqjdar7idfxsw.png"><br><br>  Wenn alle Puffer geschrieben wurden, <em>die zu Beginn des</em> Prüfpunkts verschmutzt waren, wird der Prüfpunkt als <em>vollständig betrachtet</em> .  Jetzt (aber nicht früher) können wir den Startpunkt als den Punkt verwenden, von dem aus Sie mit der Wiederherstellung beginnen können.  Und die Journaleinträge bis zu diesem Punkt brauchen wir nicht mehr. <br><br><img src="https://habrastorage.org/webt/q4/th/83/q4th83seql63dkrgfmg7esu3zh8.png"><br><br>  Der Checkpoint wird von einem speziellen Hintergrund-Checkpointer-Prozess behandelt. <br><br>  Die Dauer verschmutzter Puffer wird durch den Wert des Parameters <em>checkpoint_completion_target</em> bestimmt.  Es zeigt an, wie viel Zeit zwischen zwei benachbarten Kontrollpunkten die Aufzeichnung stattfinden wird.  Der Standardwert ist 0,5 (wie in den obigen Abbildungen), dh die Aufzeichnung dauert die Hälfte der Zeit zwischen den Kontrollpunkten.  Typischerweise wird der Wert für eine größere Gleichmäßigkeit auf 1,0 erhöht. <br><br>  Betrachten wir genauer, was passiert, wenn ein Kontrollpunkt ausgeführt wird. <br><br>  Der Prüfpunktprozess löscht zuerst die Transaktionsstatuspuffer (XACT) auf die Festplatte.  Da es nur wenige davon gibt (insgesamt 128), werden sie sofort aufgezeichnet. <br><br>  Dann beginnt die Hauptarbeit - das Schreiben schmutziger Seiten aus dem Puffercache.  Wie bereits erwähnt, können nicht alle Seiten gleichzeitig zurückgesetzt werden, da die Größe des Puffercaches erheblich sein kann.  Daher werden zunächst alle aktuell verschmutzten Seiten im Puffercache in den Headern mit einem speziellen Flag markiert. <br><br><img src="https://habrastorage.org/webt/_4/ym/eq/_4ymeqozl8o23kwq6su9ntvjujk.png"><br><br>  Und dann durchläuft der Checkpoint-Prozess nach und nach alle Puffer und löscht die auf der Festplatte markierten.  Denken Sie daran, dass Seiten nicht aus dem Cache ausgeworfen, sondern nur auf die Festplatte geschrieben werden, sodass Sie nicht auf die Anzahl der Aufrufe des Puffers oder dessen Korrektur achten müssen. <br><br>  Beschriftete Puffer können auch von Serverprozessen geschrieben werden - je nachdem, wer zuerst in den Puffer gelangt.  In jedem Fall wird das zuvor gesetzte Flag bei der Aufzeichnung entfernt, sodass (zum Zweck des Prüfpunkts) der Puffer nur einmal geschrieben wird. <br><br>  Während der Ausführung des Prüfpunkts ändern sich die Seiten natürlich weiterhin im Puffercache.  Neue verschmutzte Puffer werden jedoch nicht markiert, und der Checkpoint-Prozess sollte sie nicht schreiben. <br><br><img src="https://habrastorage.org/webt/fg/uo/vm/fguovmm8yzy0jb4jwisgg10nmm8.png"><br><br>  Am Ende seiner Arbeit erstellt der Prozess einen Journaleintrag für das Ende des Prüfpunkts.  Dieser Datensatz enthält die LSN des Arbeitsbeginns des Kontrollpunkts.  Da der Kontrollpunkt zu Beginn seiner Arbeit nichts in das Protokoll schreibt, kann dieser LSN einen beliebigen Protokolldatensatz enthalten. <br><br>  Darüber hinaus aktualisiert die Datei $ PGDATA / global / pg_control die Angabe des zuletzt übergebenen Prüfpunkts.  Bevor der Prüfpunkt abgeschlossen ist, zeigt pg_control auf den vorherigen Prüfpunkt. <br><br><img src="https://habrastorage.org/webt/w0/cy/gi/w0cygixp3k4k3qscwfa2nlapqna.png"><br><br>  Um die Arbeit des Prüfpunkts zu betrachten, erstellen Sie eine Tabelle. Die Seiten werden in den Puffercache verschoben und sind verschmutzt: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre> <pre> <code class="plaintext hljs"> count ------- 78 (1 row)</code> </pre><br>  Merken Sie sich die aktuelle Position im Protokoll: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A048 (1 row)</code> </pre><br>  Jetzt führen wir den Prüfpunkt manuell aus und stellen sicher, dass sich keine fehlerhaften Seiten im Cache befinden (wie gesagt, es können neue fehlerhafte Seiten angezeigt werden, aber in unserem Fall gab es keine Änderungen im Prozess der Ausführung des Prüfpunkts): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Mal sehen, wie sich der Prüfpunkt im Protokoll widerspiegelte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A0E4 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A048 -e 0/3514A0E4</code> </pre><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/3514A048, prev 0/35149CEC, desc: RUNNING_XACTS nextXid 101105 latestCompletedXid 101104 oldestRunningXid 101105</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A07C, prev 0/3514A048, desc: CHECKPOINT_ONLINE redo 0/3514A048; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 101105; online</code> </pre><br>  Hier sehen wir zwei Einträge.  Der letzte ist eine Aufzeichnung des Passierens des Kontrollpunkts (CHECKPOINT_ONLINE).  Die LSN des Starts des Prüfpunkts wird nach dem Wort "Wiederherstellen" angezeigt, und diese Position entspricht dem Journaleintrag, der der letzte am Anfang des Prüfpunkts war. <br><br>  Wir finden die gleichen Informationen in der Kontrolldatei: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | egrep 'Latest.*location'</code> </pre><pre> <code class="plaintext hljs">Latest checkpoint location: 0/3514A07C Latest checkpoint's REDO location: 0/3514A048</code> </pre><br><h1>  Wiederherstellung </h1><br>  Jetzt sind wir bereit, den im vorherigen Artikel beschriebenen Wiederherstellungsalgorithmus zu klären. <br><br>  Wenn der Server beim nächsten Start abstürzt, erkennt der Startvorgang dies, indem er sich die Datei pg_control ansieht und einen anderen Status als "Herunterfahren" anzeigt.  In diesem Fall wird eine automatische Wiederherstellung durchgeführt. <br><br>  Zunächst liest der Wiederherstellungsprozess aus derselben pg_control die Position des Starts des Kontrollpunkts.  (Um das Bild zu vervollständigen, stellen wir fest, dass, wenn die Datei backup_label vorhanden ist, der Datensatz des Kontrollpunkts daraus gelesen wird. Dies ist für die Wiederherstellung aus Sicherungen erforderlich, dies ist jedoch ein Thema für einen separaten Zyklus.) <br><br>  Dann liest er das Magazin ausgehend von der gefundenen Position und wendet nacheinander Journaleinträge auf die Seiten an (falls erforderlich, wie wir es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letztes Mal</a> besprochen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> ). <br><br>  Abschließend werden alle nicht journalisierten Tabellen mit Bildern in den Init-Dateien überschrieben. <br><br>  Zu diesem Zeitpunkt wird der Startvorgang beendet und der Checkpointer-Prozess führt sofort einen Checkpoint aus, um den wiederhergestellten Status auf der Festplatte zu beheben. <br><br>  Sie können einen Fehler simulieren, indem Sie den Server im Sofortmodus zwangsweise stoppen. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop -m immediate --skip-systemctl-redirect</code> </pre><br>  (Der Schlüssel <code>--skip-systemctl-redirect</code> wird hier benötigt, da PostgreSQL in Ubuntu aus dem Paket installiert wird. Er wird vom Befehl pg_ctlcluster gesteuert, der tatsächlich systemctl aufruft, und ruft bereits pg_ctl auf. Bei all diesen Wrappern wird der Modusname angegeben geht dabei verloren und mit dem <code>--skip-systemctl-redirect</code> können Sie auf systemctl verzichten und wichtige Informationen speichern.) <br><br>  Überprüfen Sie den Clusterstatus: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Beim Start erkennt PostgreSQL, dass ein Fehler aufgetreten ist und eine Wiederherstellung erforderlich ist. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:49.441 MSK [8865] LOG: database system was interrupted; last known up at 2019-07-17 15:27:48 MSK 2019-07-17 15:27:49.801 MSK [8865] LOG: database system was not properly shut down; automatic recovery in progress 2019-07-17 15:27:49.804 MSK [8865] LOG: redo starts at 0/3514A048 2019-07-17 15:27:49.804 MSK [8865] LOG: invalid record length at 0/3514A0E4: wanted 24, got 0 2019-07-17 15:27:49.804 MSK [8865] LOG: redo done at 0/3514A07C 2019-07-17 15:27:49.824 MSK [8864] LOG: database system is ready to accept connections 2019-07-17 15:27:50.409 MSK [8872] [unknown]@[unknown] LOG: incomplete startup packet</code> </pre><br>  Die Notwendigkeit einer Wiederherstellung wird im Nachrichtenprotokoll vermerkt: Das <em>Datenbanksystem wurde nicht ordnungsgemäß heruntergefahren.</em>  <em>automatische Wiederherstellung läuft</em> .  Anschließend werden die Journaleinträge an der unter „Wiederherstellen beginnt um“ markierten Position abgespielt und fortgesetzt, bis die nächsten Journaleinträge abgerufen werden können.  Damit ist die Wiederherstellung an der Position "Wiederherstellen um" abgeschlossen, und das DBMS beginnt mit der Arbeit mit Clients (das <em>Datenbanksystem ist bereit, Verbindungen zu akzeptieren</em> ). <br><br>  Und was passiert beim normalen Herunterfahren des Servers?  Um verschmutzte Seiten auf die Festplatte zu übertragen, trennt PostgreSQL alle Clients und führt dann den endgültigen Prüfpunkt aus. <br><br>  Merken Sie sich die aktuelle Position im Protokoll: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A14C (1 row)</code> </pre><br>  Stoppen Sie nun vorsichtig den Server: <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br>  Überprüfen Sie den Clusterstatus: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: shut down</code> </pre><br>  Und im Protokoll finden wir den einzigen Datensatz über den endgültigen Kontrollpunkt (CHECKPOINT_SHUTDOWN): <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A14C</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A14C, prev 0/3514A0E4, desc: CHECKPOINT_SHUTDOWN redo 0/3514A14C; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</code> </pre><pre> <code class="plaintext hljs">pg_waldump: FATAL: error in WAL record at 0/3514A14C: invalid record length at 0/3514A1B4: wanted 24, got 0</code> </pre><br>  (In einer schrecklichen tödlichen Nachricht möchte pg_waldump nur sagen, dass er bis zum Ende des Magazins gelesen hat.) <br><br>  Führen Sie die Instanz erneut aus. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><h1>  Hintergrundaufnahme </h1><br>  Wie wir herausgefunden haben, ist der Prüfpunkt einer der Prozesse, die schmutzige Seiten aus dem Puffercache auf die Festplatte schreiben.  Aber nicht der einzige. <br><br>  Wenn das Backend die Seite aus dem Puffer schieben muss und die Seite verschmutzt ist, muss es sie selbst auf die Festplatte schreiben.  Dies ist eine schlechte Situation, die zu Erwartungen führt - es ist viel besser, wenn die Aufnahme asynchron im Hintergrund erfolgt. <br><br>  Daher gibt es zusätzlich zum Checkpoint- <em>Prozess</em> auch <em>einen Hintergrundaufzeichnungsprozess</em> (Hintergrundschreiber, Bgwriter oder nur Schreiber).  Dieser Prozess verwendet denselben Puffersuchalgorithmus wie der Preemption-Mechanismus.  Grundsätzlich gibt es zwei Unterschiede. <br><br><ol><li>  Es wird kein Zeiger auf das "nächste Opfer" verwendet, sondern ein eigener.  Er kann dem Zeiger auf das "Opfer" voraus sein, bleibt aber nie hinter ihm zurück. </li><li>  Beim Durchlaufen von Puffern verringert sich der Trefferzähler nicht. </li></ol><br>  Es werden Puffer geschrieben, die gleichzeitig sind: <br><br><ul><li>  geänderte Daten enthalten (verschmutzt), </li><li>  nicht fest (Pinanzahl = 0), </li><li>  habe null Treffer (Nutzungsanzahl = 0). </li></ul><br>  Der Hintergrundaufzeichnungsprozess läuft also sozusagen dem Verdrängen voraus und findet die Puffer, die wahrscheinlich bald überfüllt sein werden.  Aus diesem Grund sollten Serviceprozesse im Idealfall feststellen, dass die von ihnen ausgewählten Puffer verwendet werden können, ohne das Schreiben anzuhalten. <br><br><h1>  Anpassung </h1><br>  <em>Der Prüfpunktprozess wird</em> normalerweise aus den folgenden Gründen konfiguriert. <br><br>  Zuerst müssen Sie entscheiden, wie viele Protokolldateien wir uns leisten können (und welche Wiederherstellungszeit für uns geeignet ist).  Je größer, desto besser, aber aus offensichtlichen Gründen wird dieser Wert begrenzt sein. <br><br>  Als nächstes können wir berechnen, wie lange dieses Volumen unter normaler Last erzeugt wird.  Wir haben bereits darüber nachgedacht, wie dies zu tun ist (wir müssen uns die Positionen im Journal merken und voneinander subtrahieren). <br><br>  Diese Zeit ist unser übliches Intervall zwischen Kontrollpunkten.  Wir schreiben es in den Parameter <em>checkpoint_timeout</em> .  Der Standardwert von 5 Minuten ist offensichtlich zu klein, normalerweise wird die Zeit beispielsweise auf eine halbe Stunde erhöht.  Ich wiederhole: Je seltener Sie sich Meilensteine ​​leisten können, desto besser - dies reduziert den Overhead. <br><br>  Es ist jedoch möglich (und sogar wahrscheinlich), dass die Last manchmal höher als normal ist und zu viele Journaleinträge in der im Parameter angegebenen Zeit generiert werden.  In diesem Fall möchte ich den Kontrollpunkt öfter ausführen.  Dazu geben wir im Parameter <em>max_wal_size</em> den Betrag an, der innerhalb desselben Kontrollpunkts gültig ist.  Wenn das tatsächliche Volumen mehr erreicht wird, initiiert der Server einen außerplanmäßigen Prüfpunkt. <br><br>  Daher treten die meisten Kontrollpunkte nach einem Zeitplan auf: einmal pro <em>checkpoint_timeout-</em> Zeiteinheit.  Bei erhöhter Last wird der Kontrollpunkt jedoch häufiger aufgerufen, wenn das Volumen <em>max_wal_size erreicht ist</em> . <br><br>  Es ist wichtig zu verstehen, dass der Parameter <em>max_wal_size</em> überhaupt nicht die maximale Menge bestimmt, die Protokolldateien auf der Festplatte belegen können. <br><br><ul><li>  Um einen Fehler zu beheben, müssen Sie die Dateien ab dem Zeitpunkt speichern, an dem der letzte Prüfpunkt übergeben wurde, sowie die Dateien, die sich während des Betriebs des aktuellen Prüfpunkts angesammelt haben.  Daher kann das Gesamtvolumen grob geschätzt werden als <br>  (1 + <em>checkpoint_completion_target</em> ) × <em>max_wal_size</em> . </li><li>  Vor Version 11 hat PostgreSQL auch Dateien für den zwei Jahre alten Prüfpunkt gespeichert. Bis zu Version 10 in der obigen Formel müssen Sie also 2 anstelle von 1 festlegen. </li><li>  Der Parameter <em>max_wal_size</em> ist nur ein Wunsch, aber keine feste Grenze.  Es kann sich herausstellen, mehr. </li><li>  Der Server ist nicht berechtigt, Protokolldateien zu löschen, die noch nicht über die Replikationssteckplätze übertragen wurden und die während der kontinuierlichen Archivierung noch nicht archiviert wurden.  Wenn diese Funktionalität verwendet wird, ist eine ständige Überwachung erforderlich, da der Serverspeicher leicht überlaufen kann. </li></ul><br>  Um das Bild zu vervollständigen, können Sie nicht nur die maximale Lautstärke, sondern auch die minimale Lautstärke <em>einstellen</em> : Parameter <em>min_wal_size</em> .  Die Bedeutung dieser Einstellung ist, dass der Server keine Dateien löscht, während sie in das Volume in <em>min_wal_size</em> passen, sondern sie einfach umbenennt und erneut verwendet.  Dies spart Ihnen ein wenig, indem Sie ständig Dateien erstellen und löschen. <br><br>  <em>Die Hintergrundaufzeichnung</em> ist nach der Konfiguration des Prüfpunkts sinnvoll zu konfigurieren.  Zusammen müssen diese Prozesse Zeit haben, um verschmutzte Puffer zu schreiben, bevor sie von Wartungsprozessen benötigt werden. <br><br>  Der Hintergrundaufzeichnungsprozess läuft in Zyklen von höchstens <em>bgwriter_lru_maxpages-</em> Seiten ab und schläft zwischen den Zyklen auf <em>bgwriter_delay ein</em> . <br><br>  Die Anzahl der Seiten, die in einem Arbeitszyklus aufgezeichnet werden, wird durch die durchschnittliche Anzahl der Puffer bestimmt, die von Wartungsprozessen aus dem letzten Lauf angefordert wurden (unter Verwendung eines gleitenden Durchschnitts, um die Ungleichmäßigkeiten zwischen den Läufen auszugleichen, hängt jedoch nicht von einer langen Historie ab).  Die berechnete Anzahl von Puffern wird mit dem Koeffizienten <em>bgwriter_lru_multiplier multipliziert</em> (in jedem Fall wird <em>bgwriter_lru_maxpages</em> jedoch nicht überschritten). <br><br>  Standardwerte: <em>bgwriter_delay</em> = 200 ms (höchstwahrscheinlich zu viel, es <em>tritt</em> in 1/5 Sekunde viel Wasser aus), <em>bgwriter_lru_maxpages</em> = 100, <em>bgwriter_lru_multiplier</em> = 2.0 (wir versuchen, vorzeitig auf die Nachfrage zu reagieren). <br><br>  Wenn der Prozess überhaupt keine verschmutzten Puffer erkennt (dh im System passiert nichts), wird er in den Ruhezustand versetzt, woraus abgeleitet wird, dass der Serverprozess auf den Puffer zugreift.  Danach wacht der Prozess auf und funktioniert wieder wie gewohnt. <br><br><h1>  Überwachung </h1><br>  Die Einstellungen für Kontrollpunkt und Hintergrundaufzeichnung können und sollten angepasst werden, um Feedback von der Überwachung zu erhalten. <br><br>  Der Parameter <em>checkpoint_warning</em> zeigt eine Warnung an, wenn Prüfpunkte, die durch Überläufe der Protokolldateigröße verursacht werden, zu häufig ausgeführt werden.  Der Standardwert beträgt 30 Sekunden und muss mit dem Wert von <em>checkpoint_timeout</em> in Einklang gebracht werden. <br><br>  Der Parameter <em>log_checkpoints</em> (standardmäßig deaktiviert) ermöglicht den Empfang von Informationen zu den ausgeführten Prüfpunkten im Servernachrichtenprotokoll.  Schalten Sie es ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_checkpoints = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Ändern Sie nun etwas in den Daten und führen Sie den Prüfpunkt aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> n = n + <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>;</code> </pre><br>  Im Nachrichtenprotokoll sehen wir ungefähr Folgendes: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 2 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:55.248 MSK [8962] LOG: checkpoint starting: immediate force wait 2019-07-17 15:27:55.274 MSK [8962] LOG: checkpoint complete: wrote 79 buffers (0.5%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.013 s, total=0.025 s; sync files=2, longest=0.011 s, average=0.006 s; distance=1645 kB, estimate=1645 kB</code> </pre><br>  Hier können Sie sehen, wie viele Puffer geschrieben wurden, wie sich die Zusammensetzung der Protokolldateien nach dem Kontrollpunkt geändert hat, wie lange der Kontrollpunkt gedauert hat und wie weit (in Byte) die benachbarten Kontrollpunkte voneinander entfernt sind. <br><br>  Die wahrscheinlich nützlichste Information ist jedoch die Statistik der Arbeit von Prüfpunkt- und Hintergrundaufzeichnungsprozessen in der Ansicht pg_stat_bgwriter.  Die Ansicht ist eins für zwei, da beide Aufgaben einmal von einem Prozess ausgeführt wurden.  dann wurden ihre Funktionen geteilt, und die Sicht blieb. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_bgwriter \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------+------------------------------ checkpoints_timed | 0 checkpoints_req | 1 checkpoint_write_time | 1 checkpoint_sync_time | 13 buffers_checkpoint | 79 buffers_clean | 0 maxwritten_clean | 0 buffers_backend | 42 buffers_backend_fsync | 0 buffers_alloc | 363 stats_reset | 2019-07-17 15:27:49.826414+03</code> </pre><br>  Hier sehen wir unter anderem die Anzahl der abgeschlossenen Kontrollpunkte: <br><br><ul><li>  checkpoints_timed - gemäß Zeitplan (bei Erreichen von checkpoint_timeout), </li><li>  checkpoints_req - auf Anfrage (auch bei Erreichen von max_wal_size). </li></ul><br>  Der große Wert von checkpoint_req (im Vergleich zu checkpoints_timed) zeigt an, dass Kontrollpunkte häufiger als erwartet auftreten. <br><br>  Wichtige Informationen zur Anzahl der aufgezeichneten Seiten: <br><br><ul><li>  buffers_checkpoint - Checkpoint-Prozess, </li><li>  buffers_backend - durch Serving von Prozessen, </li><li>  buffers_clean - Hintergrundaufzeichnungsprozess. </li></ul><br>  Auf einem gut abgestimmten System sollte der Wert von buffers_backend wesentlich kleiner sein als die Summe von buffers_checkpoint und buffers_clean. <br><br>  Maxwritten_clean ist auch nützlich, um die Hintergrundaufzeichnung <em>einzurichten</em> . Diese Zahl gibt an, wie oft der Hintergrundaufzeichnungsprozess aufgrund von Überschreitungen von <em>bgwriter_lru_maxpages nicht</em> mehr <em>funktioniert</em> . <br><br>  Sie können die akkumulierten Statistiken mit dem folgenden Aufruf zurücksetzen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_stat_reset_shared(<span class="hljs-string"><span class="hljs-string">'bgwriter'</span></span>);</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460423/">https://habr.com/ru/post/de460423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460411/index.html">Mad Converter GIF'ok zu animierten Aufklebern für Telegramm</a></li>
<li><a href="../de460413/index.html">7 nützliche Websites und Anwendungen zum Lernen von Englisch</a></li>
<li><a href="../de460415/index.html">Apple Watch 4 (44 mm, 2019) gegen Pebble Steel Classic (2014)</a></li>
<li><a href="../de460419/index.html">Abgaswärmerückgewinnung: umweltfreundlich</a></li>
<li><a href="../de460421/index.html">Optischer TP-Link T2600G-28SQ-Switch für Dienstanbieter: Eine detaillierte Überprüfung</a></li>
<li><a href="../de460425/index.html">Höllenkälte, Levitation und Plasma: Vergangenheit, Gegenwart und Zukunft der Supraleitung</a></li>
<li><a href="../de460431/index.html">Erstellen einer automatisierten Testpipeline auf Azure DevOps</a></li>
<li><a href="../de460433/index.html">Risiken und Bedrohungen im Internet der Dinge</a></li>
<li><a href="../de460435/index.html">Kleine Freude # 8: kleine Freuden für die Arbeit mit der Datenbank</a></li>
<li><a href="../de460437/index.html">Wie wir ein technisches Support-Fahrrad herausbringen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>