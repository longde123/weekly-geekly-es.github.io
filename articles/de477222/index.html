<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏻 ⬜️ 👨🏼 Formeln und Lazy Combinators 🎍 🧑🏿‍🤝‍🧑🏿 💃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Formelbibliothek 
 In der Fintech-Branche müssen wir häufig überprüfen, ob einfache arithmetische Bedingungen erfüllt sind, beispielsweise ob der Wech...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Formeln und Lazy Combinators</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477222/"><h3>  Formelbibliothek </h3><br>  In der Fintech-Branche müssen wir häufig überprüfen, ob einfache arithmetische Bedingungen erfüllt sind, beispielsweise ob der Wechselkurs über dem erwarteten Wert liegt oder nicht.  Diese Bedingungen ändern sich sehr oft, und wir mussten eine Art Fahrrad erfinden, um neue Prüfungen hinzuzufügen und bestehende in Echtzeit durchzuführen.  Stellen Sie sich vor, mehrere tausend Kunden erwarten Benachrichtigungen, wenn der Wechselkurs für einige Währungspaare ein Verhältnis von zwei zu eins erreicht.  Es wäre sehr einfach, wenn wir nur die Bedingungen statisch machen könnten: <br><br><pre><code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify?</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> rate &gt; <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify?</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Kunden können solche Prüfungen dynamisch hinzufügen.  Wir brauchen also einen mehr oder weniger zuverlässigen Mechanismus, um die gerade hinzugefügten Bedingungen zu überprüfen. <br><a name="habracut"></a><br>  Ja, <a href="https://hexdocs.pm/elixir/master/Code.html" rel="nofollow"><code>Code.eval_string/3</code></a> funktioniert irgendwie, aber es kompiliert die Bedingung jedes verdammte Mal, bevor es tatsächlich überprüft wird.  Offensichtlich ist dies ohne Grund eine Verschwendung von Ressourcen.  Hinzu kommt, dass wir pro Sekunde rund 10.000 Kurse für verschiedene Währungspaare erhalten und abwickeln. <br><br>  Also haben wir uns vorkompilierte Formeln ausgedacht.  Die winzige <a href="https://hexdocs.pm/formulae/Formulae.html" rel="nofollow"><code>formulae</code></a> erstellt für jede gegebene Bedingung ein Modul und kompiliert die vom Benutzer eingegebene Formel einmal im Code. <br><br>  <b>Die NB-</b> Bibliothek sollte mit Vorsicht verwendet werden, da die Modulnamen in Form von Atomen gespeichert werden und ihre blinde, bedingungslose Erstellung für alles, was der Client überprüfen möchte, zu einem atomaren DoS-Angriff auf die virtuelle Erlang-Maschine mit einer mehr oder weniger langen Ausführungszeit führen kann.  Wir verwenden die maximal zulässige Schrittweite von <code>0.01</code> , was im schlimmsten Fall maximal 200.000 Atome ergibt. <br><br><h3>  Faule Kombinatoren </h3><br>  Der Hauptzweck dieses Artikels ist es jedoch nicht, über vorkompilierte Formeln zu sprechen.  Für einige Grenzfälle der Wechselkursanalyse mussten wir die Permutationen einer ziemlich langen Liste berechnen.  Plötzlich bietet die Elixir-Standardbibliothek keine schlüsselfertige Lösung.  Nun, ich habe mich entschlossen, die kombinatorischen Signaturen von Ruby ( <a href="https://ruby-doc.org/core/Array.html" rel="nofollow"><code>Array#combination</code></a> und Cousins) zu kopieren.  Bei langen Listen war das leider nicht so einfach.  Die Kombinationen blieben im Bereich von dreißig Elementen in der Liste stehen, Permutation - noch früher. <br><br>  Nun, es wird erwartet, dass schon hier;  Also habe ich angefangen, Lazy Implementation mit Stream zu spielen.  Es stellte sich heraus, und es ist nicht so einfach, wie ich dachte.  Ich habe mir so etwas wie den folgenden Code ausgedacht <br><br><pre> <code class="ruby hljs">list = ~w[abcde]a combinations = Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {i1, idx1}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {<span class="hljs-number"><span class="hljs-number">_</span></span>, idx2}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> idx2 &lt;= idx1 -&gt; {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} {i2, idx2}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {<span class="hljs-number"><span class="hljs-number">_</span></span>, idx3}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> idx3 &lt;= idx2 -&gt; {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} {i3, idx3}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {Stream.transform(Stream.with_index(list), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, fn {<span class="hljs-number"><span class="hljs-number">_</span></span>, idx4}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> idx4 &lt;= idx3 -&gt; {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} {i4, _idx4}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> -&gt; {[[i1, i2, i3, i4]], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre><br>  Dies funktioniert jedoch nur für eine bekannte Anzahl von Kombinationen.  Nun, das ist leicht zu überwinden: Für einen solchen Fall haben wir doch Makros, oder? <br><br>  Im obigen Code werden drei verschiedene Muster angezeigt.  Ein erfolgreicher Zweig, aus dem wir die Liste streichen.  Schnelles Auswerfen einer leeren Liste.  Und die Transformation des Flusses mit dem Index.  Es sieht so aus, als könnten wir versuchen, einen AST für das oben Gesagte zu erstellen. <br><br>  Dies ist der seltene Fall, wenn <a href="https://hexdocs.pm/elixir/master/Kernel.SpecialForms.html%3F" rel="nofollow"><code>Kernel.SpecialForms.quote/2</code></a> wird, was wahrscheinlich nur zu Komplikationen führt. <a href="https://hexdocs.pm/elixir/master/Kernel.SpecialForms.html%3F" rel="nofollow"><code>Kernel.SpecialForms.quote/2</code></a> bin ich den Weg des geringsten Widerstands <a href="https://hexdocs.pm/elixir/master/Kernel.SpecialForms.html%3F" rel="nofollow"><code>Kernel.SpecialForms.quote/2</code></a> : Wir werden den guten alten nackten AST formen. <br><br>  Zunächst habe ich <code>quote do:</code> in der Konsole für diesen Code aufgerufen und das Ergebnis auf den Punkt gebracht.  Ja, es gibt Muster.  Nun, lass uns gehen. <br><br>  Sie müssen also zunächst ein gemeinsames Framework erstellen. <br><br><pre> <code class="ruby hljs">defmacrop mapper(from, to, fun), <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> quote(<span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> Enum.map(Range.new(unquote(from), unquote(to)), unquote(fun))) @spec combinations(list <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: list(), count <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: non_neg_integer()) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: {Stream.t(), <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} defmacro combinations(l, n) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Enum.reduce(n..<span class="hljs-number"><span class="hljs-number">1</span></span>, {[mapper(<span class="hljs-number"><span class="hljs-number">1</span></span>, n, &amp;var/<span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>}, fn i, body -&gt; stream_combination_transform_clause(i, l, body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Jetzt müssen wir anfangen, nicht in Code, sondern in AST zu denken, um zu sehen, wie sich Schablonenteile wiederholen.  Das ist lustig! <br><br>  Beginnen wir mit Hilfsmakros, um den Code zu vereinfachen: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:</span><span class="hljs-string"><span class="hljs-symbol"><span class="hljs-string">"i_</span></span><span class="hljs-subst"><span class="hljs-symbol"><span class="hljs-string"><span class="hljs-subst">#{i}</span></span></span></span><span class="hljs-symbol"><span class="hljs-string">"</span></span></span></span>, [], Elixir} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:</span><span class="hljs-string"><span class="hljs-symbol"><span class="hljs-string">"idx_</span></span><span class="hljs-subst"><span class="hljs-symbol"><span class="hljs-string"><span class="hljs-subst">#{i}</span></span></span></span><span class="hljs-symbol"><span class="hljs-string">"</span></span></span></span>, [], Elixir}</code> </pre><br>  AST-Innenteil aus einer Gesamtansicht gerissen: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sink_combination_clause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:-&gt;</span></span>, [], [ [ {<span class="hljs-symbol"><span class="hljs-symbol">:when</span></span>, [], [ {​{<span class="hljs-symbol"><span class="hljs-symbol">:_</span></span>, [], Elixir}, idx(i)}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, {<span class="hljs-symbol"><span class="hljs-symbol">:&lt;=</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">context:</span></span> Elixir, <span class="hljs-symbol"><span class="hljs-symbol">import:</span></span> Kernel], [idx(i), idx(i - <span class="hljs-number"><span class="hljs-number">1</span></span>)]} ]} ], {[], <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} ]} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Alle inneren Teile zusammen: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sink_combination_clauses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, body)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:-&gt;</span></span>, [], [[{var(<span class="hljs-number"><span class="hljs-number">1</span></span>), idx(<span class="hljs-number"><span class="hljs-number">1</span></span>)}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>], body]}] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sink_combination_clauses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, body)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Enum.reverse([ {<span class="hljs-symbol"><span class="hljs-symbol">:-&gt;</span></span>, [], [[{var(i), idx(i)}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>], body]} <span class="hljs-params"><span class="hljs-params">| Enum.map(2..i, &amp;sink_combination_clause/1) ]) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre><br>  Und schließlich die äußere Hülle um alles. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream_combination_transform_clause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, l, body)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> clauses = sink_combination_clauses(i, body) {​{​{<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>., [], [{<span class="hljs-symbol"><span class="hljs-symbol">:__aliases__</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">alias:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:Stream</span></span>]}, <span class="hljs-symbol"><span class="hljs-symbol">:transform</span></span>]}, [], [ {​{<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>., [], [{<span class="hljs-symbol"><span class="hljs-symbol">:__aliases__</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">alias:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:Stream</span></span>]}, <span class="hljs-symbol"><span class="hljs-symbol">:with_index</span></span>]}, [], [l]}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, {<span class="hljs-symbol"><span class="hljs-symbol">:fn</span></span>, [], clauses} ]}, <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Alle Permutationen werden fast identisch durchgeführt, die einzige Änderung ist die Bedingung in internen Aufrufen.  Es war einfach, richtig?  Der gesamte Code kann <a href="" rel="nofollow">im Repository</a> angezeigt werden. <br><br><h3>  App </h3><br>  Gut, wie können wir diese Schönheit nutzen?  So etwas in der Art: <br><br><pre> <code class="ruby hljs">l = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c &lt;- <span class="hljs-string"><span class="hljs-string">?a</span></span>..<span class="hljs-string"><span class="hljs-string">?z</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> &lt;&lt;c<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-comment"><span class="hljs-comment"># letters list with {stream, :ok} &lt;- Formulae.Combinators.Stream.permutations(l, 12), do: stream |&gt; Stream.take_every(26) |&gt; Enum.take(2) #⇒ [["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l"], # ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "w"]]</span></span></code> </pre><br>  Wir können jetzt sogar <a href="https://hexdocs.pm/flow/" rel="nofollow"><code>Flow</code></a> direkt aus diesem Stream einspeisen, um die Berechnungen zu parallelisieren.  Ja, es wird immer noch langsam und traurig sein, aber glücklicherweise erfolgt diese Aufgabe nicht in Echtzeit, sondern für Analysen, die nachts ausgeführt werden können und die alle Kombinationen langsam durchlaufen und die Ergebnisse irgendwo aufschreiben. <br><br>  Wenn Sie Fragen zu AST in Elixier haben - fragen Sie, ich habe einen Hund darauf gegessen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477222/">https://habr.com/ru/post/de477222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477204/index.html">Verwenden Sie KI im Marketing: Lassen Sie uns den Kunden in den Sinn kommen</a></li>
<li><a href="../de477206/index.html">Zeitreihen zur Vorhersage der Nachfrage, Auslastung der CCs, Produktempfehlungen und Aufdeckung von Anomalien</a></li>
<li><a href="../de477208/index.html">Intel lädt zum OpenVINO Hackathon ein, Preispool - 180 000 Rubel</a></li>
<li><a href="../de477210/index.html">Mein Schrei Jaroslawna</a></li>
<li><a href="../de477214/index.html">Anwendungskonfiguration unter Angular. Best Practices</a></li>
<li><a href="../de477224/index.html">„Noise Kills“: Was Sie über Lärmbelästigung wissen müssen</a></li>
<li><a href="../de477226/index.html">Die Wahl zwischen einfach und richtig</a></li>
<li><a href="../de477228/index.html">Vue 3 wird schneller</a></li>
<li><a href="../de477230/index.html">Die Geschichte der Lernsoftware: die ersten PCs, Lernspiele und Software für Studenten</a></li>
<li><a href="../de477234/index.html">Die Maus, die den Drahtbrüdern ein Ende gesetzt hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>