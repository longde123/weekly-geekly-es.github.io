<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèº ü¶Ü üèí Anwendbare regul√§re Ausdr√ºcke als kostenlose alternative Funktion üë®üèΩ‚Äçüç≥ üôèüèº üö¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mache Sie auf eine √úbersetzung eines wunderbaren frischen Artikels von Justin Le aufmerksam. In seinem Blog in Code spricht dieser Autor in einer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anwendbare regul√§re Ausdr√ºcke als kostenlose alternative Funktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448644/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/lx/ku/znlxkuzq-mdn9op_dfy7enlrwsy.png" width="90%"></div><br><p>  <em>Ich mache Sie auf eine √úbersetzung eines wunderbaren frischen Artikels von Justin Le aufmerksam.</em>  <em>In seinem Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Code</a> spricht dieser Autor in einer recht einfachen Sprache √ºber die mathematische Essenz sch√∂ner und eleganter funktionaler L√∂sungen f√ºr praktische Probleme.</em>  <em>In diesem Artikel wird im Detail ein Beispiel daf√ºr untersucht, wie die √úbertragung der mathematischen Struktur, die Daten in einem Themenbereich bilden, auf ein System von Programmtypen sofort zu einer funktionierenden L√∂sung f√ºhren kann, wie Gerald und Sassman ‚Äûautomatisch‚Äú geschrieben haben.</em> </p><br><p> <em>Der im Bild gezeigte Code ist eine vollwertige, in sich geschlossene, erweiterbare Implementierung des Parsers f√ºr regul√§re Ausdr√ºcke, der von Grund auf neu geschrieben wurde.</em>  <em>Erstklassige, echte Magie!</em> </p><a name="habracut"></a><br><p>  Heute implementieren wir anwendungsbezogene regul√§re Ausdr√ºcke und Parser (im Sinne der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regex-Anwendungsbibliothek</a> ) unter Verwendung freier algebraischer Strukturen!  Freie Strukturen sind eines meiner Lieblingswerkzeuge in Haskell, und ich habe fr√ºher √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freie Gruppen</a> , Variationen zum Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freie Monaden</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äûfreien‚Äú Anwendungsfunktor f√ºr Monoide geschrieben</a> . </p><br><p>  Regul√§re Ausdr√ºcke (und Parser f√ºr sie) sind in der Programmierung und in der Informatik allgegenw√§rtig. Ich hoffe, dass ich durch die Demonstration, wie einfach sie mithilfe freier Strukturen zu implementieren sind, dem Leser helfen kann, die Vorz√ºge dieses Ansatzes zu erkennen, ohne bef√ºrchten zu m√ºssen, sich in unn√∂tigen Details zu verlieren. </p><br><p> Der gesamte Code im Artikel ist online als "stapelbare ausf√ºhrbare Datei" <a href="">verf√ºgbar</a> .  Wenn Sie es ausf√ºhren ( <code>./regexp.hs</code> ), beginnt die GHCi-Sitzung mit allen Definitionen, sodass Sie die M√∂glichkeit haben, mit Funktionen und ihren Typen herumzuspielen. </p><br><p>  Dieser Artikel ist f√ºr den "fortgeschrittenen Anf√§nger" oder den "Anf√§ngerspezialisten" in Haskell vollst√§ndig verst√§ndlich.  Es erfordert Kenntnisse der Grundkonzepte einer Sprache: Mustervergleich, algebraische Datentypen und Abstraktionen wie Monoide, Funktoren und Notationen. </p><br><h1 id="regulyarnye-yazyki">  Regul√§re Sprachen </h1><br><p>  Ein regul√§rer Ausdruck ist eine M√∂glichkeit, eine regul√§re Sprache zu definieren.  Formal besteht ein solcher Ausdruck aus drei Grundelementen: </p><br><ol><li>  Eine leere Menge ist ein Element, das nichts zugeordnet wird. </li><li>  Eine leere Zeichenfolge ist ein neutrales Element, das trivial mit einer leeren Zeichenfolge √ºbereinstimmt. </li><li>  Ein Literal ist ein Symbol, das zu sich selbst passt.  Viel von einem Element. </li></ol><br><p>  Und auch aus drei Operationen: </p><br><ol><li>  Verkettung: <code>RS</code> , Folge von Ausdr√ºcken.  Das Produkt von Sets (kartesisch). </li><li>  Alternative: <code>R|S</code> , Wahl zwischen Ausdr√ºcken.  Die Vereinigung von Mengen. </li><li>  Wedge Star: <code>R*</code> , Wiederholung eines Ausdrucks beliebig oft (einschlie√ülich Null). </li></ol><br><p>  Und das ist alles, was regul√§re Ausdr√ºcke ausmacht, nicht mehr und nicht weniger.  Aus diesen Grundkomponenten k√∂nnen Sie alle anderen bekannten Operationen f√ºr regul√§re Ausdr√ºcke erstellen. Beispielsweise kann <code>a+</code> als <code>aa*</code> ausgedr√ºckt werden, und Kategorien wie <code>\w</code> k√∂nnen als Alternative zu geeigneten Zeichen dargestellt werden. </p><br><div class="spoiler">  <b class="spoiler_title">Anmerkung des √úbersetzers</b> <div class="spoiler_text"><p>  Die obige Mindestdefinition einer regul√§ren Sprache ist f√ºr einen Mathematiker ziemlich vollst√§ndig, aber unpraktisch.  Beispielsweise kann die Negations- oder Additionsoperation ("ein beliebiges Zeichen au√üer dem angegebenen") als Teil der Basisdefinition geschrieben werden, aber ihre direkte Anwendung f√ºhrt zu einer exponentiellen Zunahme der verwendeten Ressourcen. </p></div></div><br><h1 id="alternativnyy-funktor">  Alternativer Funktor </h1><br><p>  Wenn Sie sich die Struktur regul√§rer Ausdr√ºcke ansehen, kommt Ihnen das nicht bekannt vor?  Es erinnert mich sehr an die <code>Alternative</code> Typklasse.  Wenn ein Funktor zu dieser Klasse geh√∂rt, bedeutet dies, dass f√ºr diese Klasse Folgendes definiert ist: </p><br><ol><li>  Ein leeres Element, das einem Fehler oder einem Berechnungsfehler entspricht. </li><li>  <code>pure x</code> - ein einzelnes Element (aus der <code>Applicative</code> Klasse). </li><li>  Operation <code>&lt;*&gt;</code> , Organisation von sequentiellen Berechnungen. </li><li>  Operation <code>&lt;|&gt;</code> , Organisation alternativer Berechnungen. </li><li>  Die Funktion <code>many</code> ist die Operation, bei der Berechnungen null oder mehrmals wiederholt werden. </li></ol><br><p>  All dies ist dem Aufbau einer regul√§ren Sprache sehr √§hnlich, oder?  Vielleicht ist der alternative Funktor fast das, was wir brauchen. Das einzige, was fehlt, ist das Primitiv, das dem w√∂rtlichen Charakter entspricht. </p><br><p>  Jeder, der neu in der <code>Alternative</code> Klasse ist, kann eine gute Einf√ºhrung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typeclassopedia finden</a> .  Im Rahmen unseres Artikels stellt diese Klasse jedoch einfach ein ‚ÄûDoppelmonoid‚Äú mit zwei Kombinationsm√∂glichkeiten f√ºr <code>&lt;*&gt;</code> und <code>&lt;|&gt;</code> , die gewisserma√üen mit den Operationen <code>*</code> und <code>+</code> f√ºr Zahlen verglichen werden k√∂nnen.  Um einen alternativen Funktor zu bestimmen, sind im Allgemeinen die obigen f√ºnf Punkte und einige zus√§tzliche Gesetze der Kommutativit√§t und Verteilbarkeit ausreichend. </p><br><div class="spoiler">  <b class="spoiler_title">Anmerkung des √úbersetzers (langweilig)</b> <div class="spoiler_text"><p>  Um genau zu sein, war der Autor ein wenig begeistert von dem ‚ÄûDoppelmonoid‚Äú.  Die <code>Alternative</code> Klasse erweitert den anwendbaren Funktor, der (unter bestimmten Einschr√§nkungen) eine Halbgruppe ist, auf ein Semiring, bei dem die Additionsoperation <code>&lt;|&gt;</code> mit dem neutralen Element <code>empty</code> die Rolle eines kommutativen Monoids spielt.  Anwendungsbetreiber </p><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  kann nicht als Analogon der Multiplikationsoperation in einem Semiring fungieren, da es nicht einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Magma bildet</a> .  Zusammen mit dem Operator <code>&lt;*&gt;</code> werden jedoch die "einseitigen" Operatoren <code>*&gt;</code> und <code>&lt;*</code> im <code>Control.Applicative</code> Paket definiert.  Jeder von ihnen ignoriert das Ergebnis des Operanden, den die "Ecke" nicht anzeigt: </p><br><pre> <code class="haskell hljs">(&lt;*) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fa (*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fb</code> </pre> <br><p>  Wenn die Typen <code>a</code> und <code>b</code> √ºbereinstimmen, erhalten wir mit diesen Operationen eine Halbgruppe (Assoziativit√§t ergibt sich aus den Eigenschaften der Zusammensetzung).  Es kann √ºberpr√ºft werden, dass f√ºr einen alternativen Funktor die Multiplikation sowohl rechts als auch links in Bezug auf die Addition verteilend ist, und au√üerdem ist das neutrale Element f√ºr die Addition (analog zu Null) ein absorbierendes Element f√ºr den Multiplikationsvorgang. </p><br><p>  Semirings bilden auch Zahlen, Mengen, Matrizen von Semirings, algebraische Typen und ... regul√§re Ausdr√ºcke. Wir sprechen also wirklich von derselben algebraischen Struktur. </p></div></div><br><p>  Daher k√∂nnen wir regul√§re Ausdr√ºcke als alternativen Funktor sowie als Grundelement f√ºr einen w√∂rtlichen Charakter betrachten.  Es gibt aber auch eine andere Sichtweise, die uns direkt zu freien Strukturen f√ºhrt.  Anstelle des "alternativen Funktors mit Literalen" k√∂nnen wir das Literal in eine Instanz der <code>Alternative</code> Klasse verwandeln. </p><br><h1 id="svoboda">  Freiheit </h1><br><p>  Lass uns so schreiben.  Typ f√ºr primitives Literal: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre> <br><p>  Da wir mit Funktoren arbeiten (anwendbar, alternativ), wird mit all unseren regul√§ren Ausdr√ºcken ein bestimmtes ‚ÄûErgebnis‚Äú verkn√ºpft.  Dies liegt daran, dass beim Definieren einer Instanz f√ºr die Klassen <code>Functor</code> , <code>Applicative</code> und <code>Alternative</code> ein Parametertyp erforderlich ist. </p><br><p>  Einerseits k√∂nnen Sie diesen Typ ignorieren, andererseits sollten Sie diesen Wert als Ergebnis der √úbereinstimmung mit einem regul√§ren Ausdruck verwenden, wie dies in industriellen Anwendungen der Fall ist, die mit regul√§ren Ausdr√ºcken arbeiten. </p><br><p>  In unserem Fall stellt <code>Prim 'a' 1 :: Prim Int</code> ein Primitiv dar, das dem Zeichen <code>'a'</code> und sofort interpretiert wird, was zu einer Einheit f√ºhrt. </p><br><p>  Nun, jetzt ... geben wir unserem Grundelement die gew√ºnschte mathematische Struktur mit dem kostenlosen alternativen Funktor aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>free</code></a> Bibliothek: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free type RegExp = Alt Prim</code> </pre> <br><p>  Das ist alles!  Dies ist unser vollst√§ndiger Typ f√ºr regul√§re Ausdr√ºcke!  Wenn wir den <code>Alt</code> Typ als Instanz der <code>Functor</code> Klasse <code>Functor</code> , haben wir alle Operationen aus den Klassen <code>Applicative</code> und <code>Alternative</code> , da es in diesem Fall Instanzen von <code>Applicative (Alt f)</code> und <code>Alternative (Alt f)</code> .  Jetzt haben wir: </p><br><ul><li>  Trivial leerer Satz - <code>empty</code> aus der <code>Alternative</code> Klasse </li><li>  Leere Zeichenfolge - <code>pure</code> aus der <code>Applicative</code> </li><li>  W√∂rtlicher Charakter - Basic <code>Prim</code> </li><li>  Verkettung - <code>&lt;*&gt;</code> aus der <code>Applicative</code> Klasse </li><li>  Alternative - <code>&lt;|&gt;</code> aus der Klasse <code>Alternative</code> </li><li>  Kleene Star - <code>many</code> aus der <code>Alternative</code> </li></ul><br><p>  Und das alles haben wir v√∂llig "frei" bekommen, das hei√üt "kostenlos"! </p><br><p>  Im Wesentlichen liefert uns eine freie Struktur automatisch nur eine Abstraktion f√ºr den Basistyp und nichts weiter.  Regul√§re Ausdr√ºcke an sich stellen aber auch nur eine Struktur dar: Grundelemente und eine Reihe von Operationen, weder mehr noch weniger, sodass der kostenlose alternative Funktor uns genau das bietet, was wir brauchen.  Nicht mehr, aber nicht weniger. </p><br><p>  Nach dem Hinzuf√ºgen einiger praktischer Wrapper-Funktionen ... ist die Arbeit am Typ abgeschlossen! </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | charAs:   ,    charAs :: Char -&gt; a -&gt; RegExp a charAs cx = liftAlt (Prim cx) -- liftAlt :: fa -&gt; Alt fa   --   Prim   RegExp -- | char:         char :: Char -&gt; RegExp Char char c = charAs cc -- | string:         string :: String -&gt; RegExp String string = traverse char -- , ?</span></span></code> </pre> <br><h1 id="primery">  Beispiele </h1><br><p>  Nun, lass es uns versuchen.  Konstruieren wir den Ausdruck <code>(a|b)(cd)*e</code> , der im Falle einer erfolgreichen √úbereinstimmung den Einheitentyp <code>()</code> zur√ºckgibt: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp_</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> () testRegExp_ = void $ (char 'a' &lt;|&gt; char 'b') *&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) *&gt; char 'e'</code> </pre> <br><p>  Die Funktion <code>void :: Functor f =&gt; fa -&gt; f ()</code> aus dem <code>Data.Functor</code> Paket verwirft das Ergebnis, wir verwenden es, da wir nur am Erfolg des Vergleichs interessiert sind.  Die Operatoren <code>&lt;|&gt;</code> , <code>*&gt;</code> und <code>many</code> werden von uns jedoch genau so verwendet, wie es bei der Verkettung oder Auswahl einer der Optionen angenommen wird. </p><br><p>  Hier ist ein interessantes, komplizierteres Beispiel. Definieren wir denselben regul√§ren Ausdruck. Jetzt berechnen wir als Ergebnis des Abgleichs die Anzahl der Wiederholungen der Teilstring- <code>cd</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExp = (char 'a' &lt;|&gt; char 'b') *&gt; (length &lt;$&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>)) &lt;* char 'e'</code> </pre> <br><p>  Die Bedienung der Operatoren <code>*&gt;</code> und <code>&lt;*</code> subtil: Die Pfeile geben das Ergebnis an, das gespeichert werden soll.  Und da <code>many (string "cd") :: RegExp [String]</code> eine Liste sich wiederholender Elemente zur√ºckgibt, k√∂nnen wir die L√§nge dieser Liste berechnen, indem wir die Anzahl der Wiederholungen ermitteln. </p><br><p>  Dar√ºber hinaus k√∂nnen <code>-XApplicativeDo</code> mit der Compiler- <code>-XApplicativeDo</code> GHC <code>-XApplicativeDo</code> unseren Ausdruck in do-Notation schreiben, was wahrscheinlich einfacher zu verstehen ist: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExpDo</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExpDo = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> char 'a' &lt;|&gt; char 'b' cds &lt;- many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) char 'e' pure (length cds)</code> </pre> <br><p>  Dies alles √§hnelt in gewisser Weise der Art und Weise, wie wir das Ergebnis des Parsens eines Strings mithilfe eines regul√§ren Ausdrucks ‚Äûerfassen‚Äú und Zugriff darauf erhalten.  Hier ist ein Beispiel in Ruby: </p><br><pre> <code class="ruby hljs">irb&gt; <span class="hljs-regexp"><span class="hljs-regexp">/(a|b)((cd)*)e/</span></span>.match(<span class="hljs-string"><span class="hljs-string">"acdcdcdcde"</span></span>)[<span class="hljs-number"><span class="hljs-number">2</span></span>] =&gt; <span class="hljs-string"><span class="hljs-string">"cdcdcdcd"</span></span></code> </pre> <br><p>  Der einzige Unterschied besteht darin, dass wir eine Nachbearbeitung hinzugef√ºgt haben, um die Anzahl der Wiederholungen zu berechnen. </p><br><p>  Hier ist ein weiteres praktisches regul√§res <code>\d</code> , das einer Zahl von 0 bis 9 entspricht und eine Zahl zur√ºckgibt: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">digit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> digit = asum [ charAs (intToDigit i) i | i &lt;- [<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.9</span></span>] ]</code> </pre> <br><p>  Hier stellt die <code>asum</code> Funktion aus dem <code>Control.Applicative.Alternative</code> Paket eine Auswahl aus den Listenelementen <code>asum [x,y,z] = x &lt;|&gt; y &lt;|&gt; z</code> , und die <code>intToDigit</code> Funktion <code>intToDigit</code> im <code>Data.Char</code> Paket definiert.  Und wieder k√∂nnen wir ziemlich elegante Dinge erstellen, zum Beispiel den Ausdruck <code>\[\d\]</code> , der der Zahl in eckigen Klammern entspricht: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bracketDigit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> bracketDigit = char '[' *&gt; digit &lt;* char ']'</code> </pre> <br><h1 id="parsing">  Parsen </h1><br><p>  Wir haben lediglich den Datentyp f√ºr ein Literal mit Verkettung, Auswahl und Wiederholung beschrieben.  Gro√üartig!  Aber was wir wirklich brauchen, ist eine Zeichenfolge mit einem regul√§ren Ausdruck abzugleichen, oder?  Wie kann uns ein kostenloser alternativer Funktor dabei helfen?  In der Tat wird es viel helfen.  Schauen wir uns zwei M√∂glichkeiten an, um dies zu tun! </p><br><h2 id="razgruzhaem-alternativnyy-funktor">  Entladen Sie den alternativen Funktor </h2><br><p>  <strong>Was ist Freiheit?</strong> </p><br><p>  Die kanonische Art, eine freie Struktur zu verwenden, besteht darin, sie unter Verwendung einer geeigneten Algebra zu einer konkreten Struktur zu falten.  Beispielsweise wandelt die <code>foldMap</code> Transformation ein freies Monoid (Liste) in den Wert einer beliebigen Instanz der <code>Monoid</code> Klasse um: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldMap</span></span> :: <span class="hljs-type"><span class="hljs-type">Monoid</span></span> m =&gt; (a -&gt; m) -&gt; ([a] -&gt; m)</code> </pre> <br><p>  Die Funktion <code>foldMap</code> wandelt die Transformation <code>a -&gt; m</code> in die Transformation <code>[a] -&gt; m</code> (oder <code>FreeMonoid a -&gt; m</code> ) mit einem bestimmten Monoid <code>m</code> .  Die allgemeine Idee ist, dass Sie durch die Verwendung einer freien Struktur ihre spezifische Verwendung "f√ºr sp√§ter" verschieben k√∂nnen, wobei der Zeitpunkt der Erstellung und der Zeitpunkt der Verwendung der Struktur getrennt werden. </p><br><p>  Zum Beispiel k√∂nnen wir ein freies Monoid aus Zahlen konstruieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- |  "" `Int`     `Int`,  `liftAlt`. liftFM :: Int -&gt; [Int] liftFM x = [x] myMon :: [Int] myMon = liftFM 1 &lt;&gt; liftFM 2 &lt;&gt; liftFM 3 &lt;&gt; liftFM 4</span></span></code> </pre> <br><p>  Und jetzt k√∂nnen wir entscheiden, wie wir die Operation <code>&lt;&gt;</code> interpretieren wollen: <br>  Vielleicht dieser Zusatz? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Sum</span></span> myMon <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 + 2 + 3 + 4</span></span></code> </pre> <br><p>  Oder Multiplikation? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Product</span></span> myMon <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 * 2 * 3 * 4</span></span></code> </pre> <br><p>  Oder vielleicht die Berechnung der maximalen Anzahl? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Max</span></span> myMon <span class="hljs-type"><span class="hljs-type">Max</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 `max` 2 `max` 3 `max` 4</span></span></code> </pre> <br><p>  Die Idee ist, die Auswahl eines bestimmten Monoids zu verschieben, indem zuerst eine freie Sammlung der Nummern 1, 2, 3 und 4 erstellt wird. Ein freies Monoid √ºber Zahlen bestimmt die Struktur dar√ºber, die Sie ben√∂tigen, nicht mehr und nicht weniger.  Um <code>foldMap</code> wir an, wie der Basistyp wahrgenommen werden soll, indem der Operator <code>&lt;&gt;</code> an ein bestimmtes Monoid √ºbergeben wird. </p><br><p>  <strong>Interpretation in einem <code>State</code> Functor</strong> </p><br><p>  In der Praxis besteht das Erhalten eines Ergebnisses aus einer freien Struktur darin, einen geeigneten Funktor zu finden (oder zu erstellen), der uns das gew√ºnschte Verhalten liefert.  In unserem Fall haben wir das Gl√ºck, dass es eine bestimmte Implementierung der <code>Alternative</code> Klasse gibt, die genau so funktioniert, wie wir sie ben√∂tigen: <code>StateT String Maybe</code> . </p><br><p>  Das Produkt <code>&lt;*&gt;</code> f√ºr diesen Funktor besteht darin, eine Folge von Zustands√§nderungen zu organisieren.  In unserem Fall betrachten wir unter dem Status den Rest der analysierten Zeichenfolge, sodass die sequentielle Analyse die beste √úbereinstimmung f√ºr die Operation <code>&lt;*&gt;</code> . </p><br><p>  Und seine Summe <code>&lt;|&gt;</code> funktioniert wie Backtracking, eine Suche mit einer R√ºckkehr zur Alternative im Fehlerfall.  Es speichert den Status seit der letzten erfolgreichen Ausf√ºhrung der Analyse und kehrt zu ihm zur√ºck, wenn die Alternative nicht erfolgreich ist.  Dies ist genau das Verhalten, das wir vom Ausdruck <code>R|S</code> erwarten <code>R|S</code> </p><br><p>  Schlie√ülich hei√üt eine nat√ºrliche Transformation f√ºr einen kostenlosen alternativen Funktor <code>runAlt</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. pb -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">Alt</span></span> pa -&gt; fa</code> </pre> <br><p>  Oder f√ºr den Typ RegExp: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. <span class="hljs-type"><span class="hljs-type">Prim</span></span> b -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; fa</code> </pre> <br><p>  Wenn Sie mit <code>RankN</code> Typen (mit <code>forall b.</code> Construction) nicht vertraut sind, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> eine gute Einf√ºhrung.  Der Punkt hier ist, dass Sie eine <code>runAlt</code> Funktion <code>runAlt</code> m√ºssen, die mit <code>Prim b</code> f√ºr absolut jedes <code>b</code> funktioniert und nicht f√ºr einen bestimmten Typ, wie beispielsweise <code>Int</code> und <code>Bool</code> .  Das hei√üt, wie bei <code>foldMap</code> wir nur angeben, was mit dem Basistyp <code>foldMap</code> .  Beantworten Sie in unserem Fall die Frage: "Was ist mit dem Typ <code>Prim</code> zu tun?" </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">processPrim</span></span> :: <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> d:ds &lt;- get guard (c == d) put ds pure x</code> </pre> <br><p>  Dies ist eine Interpretation von <code>Prim</code> als Aktion im Kontext der <code>StateT String Maybe</code> Zeichenfolge. <code>StateT String Maybe</code> ist der Status eine <code>StateT String Maybe</code> Zeichenfolge.  Ich m√∂chte Sie daran erinnern, dass <code>Prim</code> Informationen √ºber das √ºbereinstimmende Zeichen <code>c</code> und seine Interpretation in Form eines Wertes von <code>x</code> .  <code>Prim</code> Verarbeitung besteht aus den folgenden Schritten: </p><br><ul><li>  Mit <code>get</code> Status (noch nicht analysierter Teil der Zeichenfolge) und drucken sofort das erste Zeichen und den Rest aus.  Wenn die Zeile leer ist, wird eine Alternative zur√ºckgegeben.  ( <em>Der <code>StateT</code> Transformator wirkt innerhalb des Vielleicht-Funktors. Wenn es nicht m√∂glich ist, das Muster auf der rechten Seite des Operators <code>&lt;-</code> innerhalb des do-Blocks <code>StateT</code> , enden die Berechnungen mit dem <code>empty</code> Ergebnis, dh <code>Nothing</code> . Ca. Trans.</em> ). </li><li>  Wir verwenden den Schutzausdruck, um das aktuelle Zeichen mit dem angegebenen Zeichen abzugleichen.  Im Fehlerfall wird <code>empty</code> zur√ºckgegeben und wir gehen zur alternativen Option √ºber. </li><li>  Wir √§ndern den Status, indem wir die analysierte Zeichenfolge durch ihren "Schwanz" ersetzen, da zu diesem Zeitpunkt das aktuelle Zeichen bereits als erfolgreich analysiert betrachtet werden kann. </li><li>  Wir geben zur√ºck, was das <code>Prim</code> Primitiv zur√ºckgeben soll. </li></ul><br><p>  Mit dieser Funktion k√∂nnen Sie RegEx bereits einem Zeichenfolgenpr√§fix zuordnen.  Dazu m√ºssen Sie die Berechnungen mit <code>runAlt</code> und <code>runStateT</code> <code>runAlt</code> und die analysierte Zeichenfolge als Argument an die letzte Funktion √ºbergeben: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchPrefix</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchPrefix re = evalStateT (runAlt processPrim re)</code> </pre> <br><p>  Das ist alles!  Mal sehen, wie unsere erste L√∂sung funktioniert: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchPrefix digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchPrefix bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchPrefix (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchPrefix (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><p>  <strong>Warten Sie, was war das?</strong> </p><br><p>  Es scheint, dass alles etwas schneller ging als erwartet.  Vor einer Minute haben wir unser Primitiv geschrieben und dann wieder!  und der funktionierende Parser ist bereit.  Hier in der Tat der gesamte Schl√ºsselcode, ein paar Zeilen in Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.State (<span class="hljs-title"><span class="hljs-title">evalStateT</span></span>, <span class="hljs-title"><span class="hljs-title">put</span></span>, <span class="hljs-title"><span class="hljs-title">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free (<span class="hljs-title"><span class="hljs-title">runAlt</span></span>, <span class="hljs-type"><span class="hljs-type">Alt</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">guard</span></span>) data Prim a = Prim Char a deriving Functor type RegExp = Alt Prim matchPrefix :: RegExp a -&gt; String -&gt; Maybe a matchPrefix re = evalStateT (<span class="hljs-title"><span class="hljs-title">runAlt</span></span> <span class="hljs-title"><span class="hljs-title">processPrim</span></span> <span class="hljs-title"><span class="hljs-title">re</span></span>) where processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> <span class="hljs-title"><span class="hljs-title">cx</span></span>) = do d:ds &lt;- get guard (<span class="hljs-title"><span class="hljs-title">c</span></span> == <span class="hljs-title"><span class="hljs-title">d</span></span>) put ds pure x</code> </pre> <br><p>  Und haben wir einen voll funktionsf√§higen Parser f√ºr regul√§re Ausdr√ºcke?  Was ist passiert? </p><br><p>  Denken Sie daran, dass <code>Alt Prim</code> auf einer hohen Abstraktionsebene bereits <code>pure</code> , <code>empty</code> <code>Prim</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> und <code>many</code> in seiner Struktur enth√§lt (es gibt eine unangenehme Subtilit√§t bei diesem Operator, aber dazu sp√§ter mehr).  Was <code>runAlt</code> tut, ist das Verhalten eines bestimmten alternativen Funktors (in unserem Fall <code>StateT String Maybe</code> ), um das Verhalten der <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> und <code>many</code> Operatoren zu steuern.  <code>StateT</code> verf√ºgt jedoch nicht √ºber einen integrierten Operator, der <code>Prim</code> √§hnelt, und daf√ºr mussten wir <code>StateT</code> schreiben. </p><br><p>  F√ºr den <code>Prim</code> Typ verwendet die Funktion <code>runAlt</code> , und f√ºr <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> und <code>many</code> wird eine geeignete Instanz der <code>Alternative</code> Klasse verwendet.  Somit werden 83% der Arbeit vom <code>StateT</code> Funktor f√ºr uns <code>StateT</code> , und die restlichen 17% werden von <code>StateT</code> erledigt.  In Wahrheit ist das etwas entt√§uschend.  Man k√∂nnte fragen: Warum war es √ºberhaupt notwendig, mit dem <code>Alt</code> Wrapper zu beginnen?  Warum nicht sofort den Typ <code>RegExp = StateT String Maybe</code> und das entsprechende <code>char :: Char -&gt; StateT String Maybe Char</code> ?  Wenn alles im StateT- <code>StateT</code> erledigt ist, warum sollte man sich dann mit <code>Alt</code> - einem kostenlosen alternativen Funktor? </p><br><p>  <code>Alt</code> Hauptvorteil von <code>Alt</code> gegen√ºber <code>StateT</code> ist, dass <code>StateT</code> ... ein ziemlich m√§chtiges Werkzeug ist.  Tats√§chlich ist er jedoch bis zur Absurdit√§t m√§chtig.  Es kann verwendet werden, um eine gro√üe Anzahl der unterschiedlichsten Berechnungen und Strukturen darzustellen, und es ist unangenehm, sich etwas vorzustellen, das kein regul√§rer Ausdruck ist.  Nehmen wir an, etwas Grundlegendes wie <code>put "hello" :: StateT String Maybe ()</code> stimmt mit keinem g√ºltigen regul√§ren Ausdruck √ºberein, ist jedoch vom gleichen Typ wie <code>RegExp ()</code> .  W√§hrend wir also sagen, dass <code>Alt Prim</code> mit einem regul√§ren Ausdruck √ºbereinstimmt, nicht mehr, aber nicht weniger, k√∂nnen wir mit <code>StateT String Maybe</code> nicht dasselbe sagen.  Der <code>Alt Prim</code> Typ ist die perfekte Darstellung eines regul√§ren Ausdrucks.  Alles, was mit seiner Hilfe ausgedr√ºckt werden kann, ist ein regul√§rer Ausdruck, aber alles, was nicht so ein Ausdruck ist, kann nicht mit seiner Hilfe ausgedr√ºckt werden.  Hier gibt es jedoch auch einige unangenehme Feinheiten, die mit Haskells Faulheit verbunden sind, dazu sp√§ter mehr. </p><br><p>  Hier k√∂nnen wir <code>StateT</code> nur als einen Kontext betrachten, der f√ºr einen verwendet wird <br>  Interpretationen regul√§rer Ausdr√ºcke - als Parser.  Sie k√∂nnen sich aber auch andere M√∂glichkeiten vorstellen, <code>RegExp</code> zu verwenden.  Zum Beispiel ben√∂tigen wir m√∂glicherweise eine Textdarstellung, die <code>StateT</code> nicht zul√§sst. </p><br><p>  Wir k√∂nnen nicht sagen, dass <code>StateT String Maybe</code> ein regul√§rer Ausdruck ist, nur dass dieser Funktor einen Parser darstellen kann, der auf regul√§ren Grammatiken basiert.  Aber √ºber <code>Alt Prim</code> wir mit Sicherheit sagen, dass dies ein regul√§rer Ausdruck ist ( <em>wie Mathematiker sagen, sind sie bis zum Isomorphismus gleich, ca. Trans.</em> ). </p><br><h2 id="neposredstvennoe-ispolzovanie-svobodnoy-struktury">  Direkte Nutzung der freien Struktur </h2><br><p>  All dies ist nat√ºrlich sehr gut, aber was ist, wenn wir 83% der Arbeit nicht auf Code f√ºr einen Typ verlagern m√∂chten, der von jemandem f√ºr uns geschrieben wurde?  Ist es m√∂glich, die freie <code>Alt</code> Struktur direkt zum Schreiben eines Parsers zu verwenden?  Diese Frage √§hnelt der folgenden: Wie schreibe <code>foldMap</code> eine Funktion, die Listen verarbeitet (durch Abgleichen der Konstruktoren <code>(:)</code> und <code>[]</code> ), anstatt nur <code>foldMap</code> ?  Wie kann man direkt mit dieser Struktur arbeiten, anstatt die Arbeit an ein bestimmtes Monoid zu delegieren? </p><br><p>  Sch√∂n, dass du gefragt hast!  Werfen wir einen Blick auf die Definition eines kostenlosen alternativen Funktors: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> fa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alternatives</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> fa = forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ap</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br><p>  Dies ist ein ungew√∂hnlicher Typ, der durch gegenseitige Rekursion definiert wird, sodass er sehr verwirrend aussehen kann.  Eine M√∂glichkeit, dies zu verstehen, besteht darin, sich vorzustellen, dass <code>Alt xs</code> eine Kette von Alternativen enth√§lt, die mit dem Operator <code>&lt;|&gt;</code> .       <code>AltF</code> ,     <code>f</code> ,     <code>&lt;*&gt;</code> (   ). </p><br><p>   <code>AltF fa</code>    <code>[fr]</code> ,   <code>r</code>   . <code>Ap</code>   <code>(:)</code> ,  <code>fr</code> ,  <code>Pure</code> ‚Äî   <code>[]</code> .  <code>forall r.</code>       <code>-XExistentialQuantification</code>         . </p><br><p>   , <code>Alt f</code>   ,      .     ,      ( )  <code>&lt;*&gt;</code>  <code>&lt;|&gt;</code> ,  ,   <code>[a]</code>      <code>&lt;&gt;</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>       ,     : </p><br><ul><li>   () ‚Äî ,   <code>&lt;&gt;</code> : <br><pre> <code class="haskell hljs">[a,b,c,d] = [a]&lt;&gt;[b]&lt;&gt;[c]&lt;&gt;[d]</code> </pre> </li><li>   () ‚Äî  ,   <code>+</code> ,   ‚Äî ,   <code>*</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span>*(b+c)+d*(x+y+z)*h</code> </pre> </li><li>    (Alt f) ‚Äî  ,   <code>&lt;|&gt;</code> ,   ‚Äî ,   <code>&lt;*&gt;</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fa</span></span> &lt;*&gt; (fb &lt;|&gt; fc) &lt;|&gt; fd &lt;*&gt; (fx &lt;|&gt; fy &lt;|&gt; fz) &lt;*&gt; fh</code> </pre> </li></ul></div></div><br><p>   ,       <code>RegExp a -&gt; String -&gt; Maybe a</code> ,   ,     .          :         . </p><br><p>  ,   <code>Alt</code> .   ,           ,     . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchAlts</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchAlts (<span class="hljs-type"><span class="hljs-type">Alt</span></span> res) xs = asum [ matchChain re xs | re &lt;- res ]</code> </pre> <br><p>   <code>asum :: [Maybe a] -&gt; Maybe a</code>   ,   <code>Just</code> . ( <em>   ,   <code>Maybe a</code>       <code>Alternative</code> ‚Äî   <code>Nothing</code> ,   <code>&lt;|&gt;</code>    . . .</em> ) </p><br><p>     .       <code>AltF</code> ,   <code>Ap</code>  <code>Pure</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = _ matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) cs = _</code> </pre> <br><p>      "  ":     GHC   "",   ,    ,   . ( <em> Haskell "" (holes)     ,   <code>_</code> ,      . . .</em> )        : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> d:ds | c == d -&gt; matchAlts (($ x) &lt;$&gt; next) ds | otherwise -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) _ = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br><p>   <code>Ap</code> (  <code>(:)</code> ),  ,  -    .         ,       .    <code>Prim r</code> ,   ,           <code>next :: RegExp (r -&gt; a)</code> .    ,       <code>next</code> .   , ""  ,  <code>Nothing</code> . ,     <code>Pure x</code> (   <code>[]</code> ), ,  ,      . </p><br><p> ,        ,    .  ,  ,  " "    <code>Ap</code> , <code>Pure</code> , <code>AltF</code>  ..,            . </p><br><p>          : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchAlts digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchAlts bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchAlts (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchAlts (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>              . ,      () ,            .    ,  ,   . </p></div></div><br><h1 id="chto-zhe-imenno-my-sdelali">     ? </h1><br><p>                <code>foldMap</code>     .    ,   ,         foldMap,     ,     ,    ,   ! ,   ‚Äî    ,           ‚Äî    <code>(:)</code>  <code>[]</code> . </p><br><p>  ,   ,    : ,   ,    ,  <code>(:)</code> ,  <code>[]</code> .  ,     .  ,  <code>[1,2,3] &lt;&gt; [4]</code>      ,   <code>[1] &lt;&gt; [2,3] &lt;&gt; [4]</code> .  ,    ,      . </p><br><p>        .  ,     : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a | forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Seq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Union</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Many</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>       <code>RegExp</code> ,        .      . ,      <code>RegExp</code>       : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | a|(b|c) abc1 :: RegExp Int abc1 = Prim 'a' 1 `Union` (Prim 'b' 2 `Union` Prim 'c' 3) -- | (a|b)|c abc2 :: RegExp Int abc2 = (Prim 'a' 1 `Union` Prim 'b' 2) `Union` Prim 'c' 3</span></span></code> </pre> <br><p>  ,             . </p><br><p>    <code>Alt Prim</code> ,       ,        ,       .  ,       <code>matchAlts</code> ,            .     <code>(a|b)|c</code>  <code>a|(b|c)</code> .     <code>Alt</code>        . ,     ,    . </p><br><p>    ,    ,       <code>(a|b)|c</code>  ,  <code>(a|b)|c</code> , , ,       <code>RegExp</code> .  <code>Alt</code>       ,       . </p><br><p> ,  ,    <code>Alt</code>    , <code>Alt Prim</code>       . , <code>Alt Prim</code>       <code>a|a</code>  <code>a</code> .    ,   <code>Alt f</code>       <code>f</code> .        ,   :      .        , ,  ,     . </p><br><h1 id="nekotorye-dosadnye-tonkosti">    </h1><br><p>     ,     .      ,      ,            .        <code>RegExp</code>  ,            ,    ‚Äî . </p><br><p>    ,          Haskell. ,  -  <code>[a]</code>      . ( <em>       ,       -  ,   "" </em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x22A5;</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.808ex" height="1.937ex" viewBox="0 -728.2 778.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/448644/&amp;usg=ALkJrhgjj9cqUW36zL4oq3ouQBi9IWjpxw#MJMAIN-22A5" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ä•</font></font></mi></math></span></span><script type="math/tex" id="MathJax-Element-1">\bot</script></em>  <em>,      - "" .</em>  <em>ca.</em> <em>.</em>  ) </p><br><p>       : <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,              ( <em>,    ,       ,      . . .</em> ).  ,  Haskell     .   ,    <code>Alt</code>   <code>many</code> .  , <code>a*</code>   <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,             .     -    <code>many (char 'a')</code> ,    . Haskell       <code>Alt</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,      . </p><br><p>  ,    ,   ,      ,           (),         .        ,     <code>many</code>    . </p><br><p> ,   !    ""   <code>Alt</code> ,    <code>Control.Alternative.Free.Final</code> ,     <code>many</code> (,    ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ). </p><br><p>           ,    ,  <code>runAlt</code> . ,        <code>Alternative</code> ,     <code>many</code> (  <code>RE</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regex-applicative</a> )       .      ,  Haskell      , ,   , <code>many</code>       . </p><br><p>    ,   .          (       ),          ( <em>,        , . .</em> ).    <code>matchPrefix</code> ,        ,   ,        .  ,   ,    ,      ,       .      ,   GHC        . </p><br><h1 id="poslednie-shtrihi">   </h1><br><p>         ,       ,   <code>tails</code> (   )  <code>mapMaybe</code> (           ).    ,     ,    <code>listToMaybe</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matches</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [a] matches re = mapMaybe (matchPrefix re) . tails firstMatch :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a firstMatch re = listToMaybe . matches re</code> </pre> <br><p>    ,   ,   <code>matchPrefix</code>   <code>Nothing</code>      ,  <code>listToMaybe</code>      ,   <code>Nothing</code> ( <em>      ,      . . .</em> ). </p><br><p> ,        .    ,       ,     ‚Äî  ,    .       ,         .    ,     ,    ,      . </p><br><p>        <code>Alt Prim</code>         ,    :   ,  ,  ,    . </p><br><p>       ?        .      : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Only</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    | Letter a --     | Digit (Int -&gt; a) --    , | Wildcard (Char -&gt; a) --    , | Satisfy (Char -&gt; Maybe a) --    , --  </span></span></span></span></code> </pre> <br><p>       ,      .      . </p><br><p>      ,   ,   .      <code>runAlt</code>      <code>Alt</code> . </p><br><p>                (). ,    ,        ,    ,    .       <code>|</code>      . ( <em>         ,        . . .</em> ).     ,  -     .  ,   <code>MonadPlus</code>     -   ,        ,     .     ,      . </p><br><p> ,   ,         .  ,   ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448644/">https://habr.com/ru/post/de448644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448634/index.html">Ukrainischunterricht</a></li>
<li><a href="../de448636/index.html">Hackaday Retro Computer Fall</a></li>
<li><a href="../de448638/index.html">Buildroot - Teil 1. Allgemeine Informationen, Aufbau eines Minimalsystems, Einstellung √ºber das Men√º</a></li>
<li><a href="../de448640/index.html">SSD GIGABYTE Aorus RGB M.2: kleine, gleichm√§√üige Fernbedienung f√ºr RGB-LEDs (2 Teile)</a></li>
<li><a href="../de448642/index.html">Obligatorisches Modell f√ºr die Verteilung von Rechten in FreeBSD</a></li>
<li><a href="../de448648/index.html">Wie man alle in die Wissenschaft einbindet und das B√ºro nicht in eine Brutst√§tte des Hasses verwandelt</a></li>
<li><a href="../de448652/index.html">Mozilla WebThings auf Raspberry Pi - Erste Schritte</a></li>
<li><a href="../de448654/index.html">Mozilla WebThings - Gateway-Setup</a></li>
<li><a href="../de448656/index.html">Der gro√üe Bruder beobachtet ... sich selbst oder eine Karte mit der Geschichte der Bewegungen in HomeAssistant</a></li>
<li><a href="../de448658/index.html">Was kann √ºber den OBD-Anschluss im Auto getan werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>