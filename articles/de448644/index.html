<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼 🦆 🏒 Anwendbare reguläre Ausdrücke als kostenlose alternative Funktion 👨🏽‍🍳 🙏🏼 🚴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mache Sie auf eine Übersetzung eines wunderbaren frischen Artikels von Justin Le aufmerksam. In seinem Blog in Code spricht dieser Autor in einer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anwendbare reguläre Ausdrücke als kostenlose alternative Funktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448644/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/lx/ku/znlxkuzq-mdn9op_dfy7enlrwsy.png" width="90%"></div><br><p>  <em>Ich mache Sie auf eine Übersetzung eines wunderbaren frischen Artikels von Justin Le aufmerksam.</em>  <em>In seinem Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Code</a> spricht dieser Autor in einer recht einfachen Sprache über die mathematische Essenz schöner und eleganter funktionaler Lösungen für praktische Probleme.</em>  <em>In diesem Artikel wird im Detail ein Beispiel dafür untersucht, wie die Übertragung der mathematischen Struktur, die Daten in einem Themenbereich bilden, auf ein System von Programmtypen sofort zu einer funktionierenden Lösung führen kann, wie Gerald und Sassman „automatisch“ geschrieben haben.</em> </p><br><p> <em>Der im Bild gezeigte Code ist eine vollwertige, in sich geschlossene, erweiterbare Implementierung des Parsers für reguläre Ausdrücke, der von Grund auf neu geschrieben wurde.</em>  <em>Erstklassige, echte Magie!</em> </p><a name="habracut"></a><br><p>  Heute implementieren wir anwendungsbezogene reguläre Ausdrücke und Parser (im Sinne der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regex-Anwendungsbibliothek</a> ) unter Verwendung freier algebraischer Strukturen!  Freie Strukturen sind eines meiner Lieblingswerkzeuge in Haskell, und ich habe früher über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freie Gruppen</a> , Variationen zum Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freie Monaden</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„freien“ Anwendungsfunktor für Monoide geschrieben</a> . </p><br><p>  Reguläre Ausdrücke (und Parser für sie) sind in der Programmierung und in der Informatik allgegenwärtig. Ich hoffe, dass ich durch die Demonstration, wie einfach sie mithilfe freier Strukturen zu implementieren sind, dem Leser helfen kann, die Vorzüge dieses Ansatzes zu erkennen, ohne befürchten zu müssen, sich in unnötigen Details zu verlieren. </p><br><p> Der gesamte Code im Artikel ist online als "stapelbare ausführbare Datei" <a href="">verfügbar</a> .  Wenn Sie es ausführen ( <code>./regexp.hs</code> ), beginnt die GHCi-Sitzung mit allen Definitionen, sodass Sie die Möglichkeit haben, mit Funktionen und ihren Typen herumzuspielen. </p><br><p>  Dieser Artikel ist für den "fortgeschrittenen Anfänger" oder den "Anfängerspezialisten" in Haskell vollständig verständlich.  Es erfordert Kenntnisse der Grundkonzepte einer Sprache: Mustervergleich, algebraische Datentypen und Abstraktionen wie Monoide, Funktoren und Notationen. </p><br><h1 id="regulyarnye-yazyki">  Reguläre Sprachen </h1><br><p>  Ein regulärer Ausdruck ist eine Möglichkeit, eine reguläre Sprache zu definieren.  Formal besteht ein solcher Ausdruck aus drei Grundelementen: </p><br><ol><li>  Eine leere Menge ist ein Element, das nichts zugeordnet wird. </li><li>  Eine leere Zeichenfolge ist ein neutrales Element, das trivial mit einer leeren Zeichenfolge übereinstimmt. </li><li>  Ein Literal ist ein Symbol, das zu sich selbst passt.  Viel von einem Element. </li></ol><br><p>  Und auch aus drei Operationen: </p><br><ol><li>  Verkettung: <code>RS</code> , Folge von Ausdrücken.  Das Produkt von Sets (kartesisch). </li><li>  Alternative: <code>R|S</code> , Wahl zwischen Ausdrücken.  Die Vereinigung von Mengen. </li><li>  Wedge Star: <code>R*</code> , Wiederholung eines Ausdrucks beliebig oft (einschließlich Null). </li></ol><br><p>  Und das ist alles, was reguläre Ausdrücke ausmacht, nicht mehr und nicht weniger.  Aus diesen Grundkomponenten können Sie alle anderen bekannten Operationen für reguläre Ausdrücke erstellen. Beispielsweise kann <code>a+</code> als <code>aa*</code> ausgedrückt werden, und Kategorien wie <code>\w</code> können als Alternative zu geeigneten Zeichen dargestellt werden. </p><br><div class="spoiler">  <b class="spoiler_title">Anmerkung des Übersetzers</b> <div class="spoiler_text"><p>  Die obige Mindestdefinition einer regulären Sprache ist für einen Mathematiker ziemlich vollständig, aber unpraktisch.  Beispielsweise kann die Negations- oder Additionsoperation ("ein beliebiges Zeichen außer dem angegebenen") als Teil der Basisdefinition geschrieben werden, aber ihre direkte Anwendung führt zu einer exponentiellen Zunahme der verwendeten Ressourcen. </p></div></div><br><h1 id="alternativnyy-funktor">  Alternativer Funktor </h1><br><p>  Wenn Sie sich die Struktur regulärer Ausdrücke ansehen, kommt Ihnen das nicht bekannt vor?  Es erinnert mich sehr an die <code>Alternative</code> Typklasse.  Wenn ein Funktor zu dieser Klasse gehört, bedeutet dies, dass für diese Klasse Folgendes definiert ist: </p><br><ol><li>  Ein leeres Element, das einem Fehler oder einem Berechnungsfehler entspricht. </li><li>  <code>pure x</code> - ein einzelnes Element (aus der <code>Applicative</code> Klasse). </li><li>  Operation <code>&lt;*&gt;</code> , Organisation von sequentiellen Berechnungen. </li><li>  Operation <code>&lt;|&gt;</code> , Organisation alternativer Berechnungen. </li><li>  Die Funktion <code>many</code> ist die Operation, bei der Berechnungen null oder mehrmals wiederholt werden. </li></ol><br><p>  All dies ist dem Aufbau einer regulären Sprache sehr ähnlich, oder?  Vielleicht ist der alternative Funktor fast das, was wir brauchen. Das einzige, was fehlt, ist das Primitiv, das dem wörtlichen Charakter entspricht. </p><br><p>  Jeder, der neu in der <code>Alternative</code> Klasse ist, kann eine gute Einführung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typeclassopedia finden</a> .  Im Rahmen unseres Artikels stellt diese Klasse jedoch einfach ein „Doppelmonoid“ mit zwei Kombinationsmöglichkeiten für <code>&lt;*&gt;</code> und <code>&lt;|&gt;</code> , die gewissermaßen mit den Operationen <code>*</code> und <code>+</code> für Zahlen verglichen werden können.  Um einen alternativen Funktor zu bestimmen, sind im Allgemeinen die obigen fünf Punkte und einige zusätzliche Gesetze der Kommutativität und Verteilbarkeit ausreichend. </p><br><div class="spoiler">  <b class="spoiler_title">Anmerkung des Übersetzers (langweilig)</b> <div class="spoiler_text"><p>  Um genau zu sein, war der Autor ein wenig begeistert von dem „Doppelmonoid“.  Die <code>Alternative</code> Klasse erweitert den anwendbaren Funktor, der (unter bestimmten Einschränkungen) eine Halbgruppe ist, auf ein Semiring, bei dem die Additionsoperation <code>&lt;|&gt;</code> mit dem neutralen Element <code>empty</code> die Rolle eines kommutativen Monoids spielt.  Anwendungsbetreiber </p><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  kann nicht als Analogon der Multiplikationsoperation in einem Semiring fungieren, da es nicht einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Magma bildet</a> .  Zusammen mit dem Operator <code>&lt;*&gt;</code> werden jedoch die "einseitigen" Operatoren <code>*&gt;</code> und <code>&lt;*</code> im <code>Control.Applicative</code> Paket definiert.  Jeder von ihnen ignoriert das Ergebnis des Operanden, den die "Ecke" nicht anzeigt: </p><br><pre> <code class="haskell hljs">(&lt;*) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fa (*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fb</code> </pre> <br><p>  Wenn die Typen <code>a</code> und <code>b</code> übereinstimmen, erhalten wir mit diesen Operationen eine Halbgruppe (Assoziativität ergibt sich aus den Eigenschaften der Zusammensetzung).  Es kann überprüft werden, dass für einen alternativen Funktor die Multiplikation sowohl rechts als auch links in Bezug auf die Addition verteilend ist, und außerdem ist das neutrale Element für die Addition (analog zu Null) ein absorbierendes Element für den Multiplikationsvorgang. </p><br><p>  Semirings bilden auch Zahlen, Mengen, Matrizen von Semirings, algebraische Typen und ... reguläre Ausdrücke. Wir sprechen also wirklich von derselben algebraischen Struktur. </p></div></div><br><p>  Daher können wir reguläre Ausdrücke als alternativen Funktor sowie als Grundelement für einen wörtlichen Charakter betrachten.  Es gibt aber auch eine andere Sichtweise, die uns direkt zu freien Strukturen führt.  Anstelle des "alternativen Funktors mit Literalen" können wir das Literal in eine Instanz der <code>Alternative</code> Klasse verwandeln. </p><br><h1 id="svoboda">  Freiheit </h1><br><p>  Lass uns so schreiben.  Typ für primitives Literal: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre> <br><p>  Da wir mit Funktoren arbeiten (anwendbar, alternativ), wird mit all unseren regulären Ausdrücken ein bestimmtes „Ergebnis“ verknüpft.  Dies liegt daran, dass beim Definieren einer Instanz für die Klassen <code>Functor</code> , <code>Applicative</code> und <code>Alternative</code> ein Parametertyp erforderlich ist. </p><br><p>  Einerseits können Sie diesen Typ ignorieren, andererseits sollten Sie diesen Wert als Ergebnis der Übereinstimmung mit einem regulären Ausdruck verwenden, wie dies in industriellen Anwendungen der Fall ist, die mit regulären Ausdrücken arbeiten. </p><br><p>  In unserem Fall stellt <code>Prim 'a' 1 :: Prim Int</code> ein Primitiv dar, das dem Zeichen <code>'a'</code> und sofort interpretiert wird, was zu einer Einheit führt. </p><br><p>  Nun, jetzt ... geben wir unserem Grundelement die gewünschte mathematische Struktur mit dem kostenlosen alternativen Funktor aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>free</code></a> Bibliothek: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free type RegExp = Alt Prim</code> </pre> <br><p>  Das ist alles!  Dies ist unser vollständiger Typ für reguläre Ausdrücke!  Wenn wir den <code>Alt</code> Typ als Instanz der <code>Functor</code> Klasse <code>Functor</code> , haben wir alle Operationen aus den Klassen <code>Applicative</code> und <code>Alternative</code> , da es in diesem Fall Instanzen von <code>Applicative (Alt f)</code> und <code>Alternative (Alt f)</code> .  Jetzt haben wir: </p><br><ul><li>  Trivial leerer Satz - <code>empty</code> aus der <code>Alternative</code> Klasse </li><li>  Leere Zeichenfolge - <code>pure</code> aus der <code>Applicative</code> </li><li>  Wörtlicher Charakter - Basic <code>Prim</code> </li><li>  Verkettung - <code>&lt;*&gt;</code> aus der <code>Applicative</code> Klasse </li><li>  Alternative - <code>&lt;|&gt;</code> aus der Klasse <code>Alternative</code> </li><li>  Kleene Star - <code>many</code> aus der <code>Alternative</code> </li></ul><br><p>  Und das alles haben wir völlig "frei" bekommen, das heißt "kostenlos"! </p><br><p>  Im Wesentlichen liefert uns eine freie Struktur automatisch nur eine Abstraktion für den Basistyp und nichts weiter.  Reguläre Ausdrücke an sich stellen aber auch nur eine Struktur dar: Grundelemente und eine Reihe von Operationen, weder mehr noch weniger, sodass der kostenlose alternative Funktor uns genau das bietet, was wir brauchen.  Nicht mehr, aber nicht weniger. </p><br><p>  Nach dem Hinzufügen einiger praktischer Wrapper-Funktionen ... ist die Arbeit am Typ abgeschlossen! </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | charAs:   ,    charAs :: Char -&gt; a -&gt; RegExp a charAs cx = liftAlt (Prim cx) -- liftAlt :: fa -&gt; Alt fa   --   Prim   RegExp -- | char:         char :: Char -&gt; RegExp Char char c = charAs cc -- | string:         string :: String -&gt; RegExp String string = traverse char -- , ?</span></span></code> </pre> <br><h1 id="primery">  Beispiele </h1><br><p>  Nun, lass es uns versuchen.  Konstruieren wir den Ausdruck <code>(a|b)(cd)*e</code> , der im Falle einer erfolgreichen Übereinstimmung den Einheitentyp <code>()</code> zurückgibt: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp_</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> () testRegExp_ = void $ (char 'a' &lt;|&gt; char 'b') *&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) *&gt; char 'e'</code> </pre> <br><p>  Die Funktion <code>void :: Functor f =&gt; fa -&gt; f ()</code> aus dem <code>Data.Functor</code> Paket verwirft das Ergebnis, wir verwenden es, da wir nur am Erfolg des Vergleichs interessiert sind.  Die Operatoren <code>&lt;|&gt;</code> , <code>*&gt;</code> und <code>many</code> werden von uns jedoch genau so verwendet, wie es bei der Verkettung oder Auswahl einer der Optionen angenommen wird. </p><br><p>  Hier ist ein interessantes, komplizierteres Beispiel. Definieren wir denselben regulären Ausdruck. Jetzt berechnen wir als Ergebnis des Abgleichs die Anzahl der Wiederholungen der Teilstring- <code>cd</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExp = (char 'a' &lt;|&gt; char 'b') *&gt; (length &lt;$&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>)) &lt;* char 'e'</code> </pre> <br><p>  Die Bedienung der Operatoren <code>*&gt;</code> und <code>&lt;*</code> subtil: Die Pfeile geben das Ergebnis an, das gespeichert werden soll.  Und da <code>many (string "cd") :: RegExp [String]</code> eine Liste sich wiederholender Elemente zurückgibt, können wir die Länge dieser Liste berechnen, indem wir die Anzahl der Wiederholungen ermitteln. </p><br><p>  Darüber hinaus können <code>-XApplicativeDo</code> mit der Compiler- <code>-XApplicativeDo</code> GHC <code>-XApplicativeDo</code> unseren Ausdruck in do-Notation schreiben, was wahrscheinlich einfacher zu verstehen ist: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExpDo</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExpDo = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> char 'a' &lt;|&gt; char 'b' cds &lt;- many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) char 'e' pure (length cds)</code> </pre> <br><p>  Dies alles ähnelt in gewisser Weise der Art und Weise, wie wir das Ergebnis des Parsens eines Strings mithilfe eines regulären Ausdrucks „erfassen“ und Zugriff darauf erhalten.  Hier ist ein Beispiel in Ruby: </p><br><pre> <code class="ruby hljs">irb&gt; <span class="hljs-regexp"><span class="hljs-regexp">/(a|b)((cd)*)e/</span></span>.match(<span class="hljs-string"><span class="hljs-string">"acdcdcdcde"</span></span>)[<span class="hljs-number"><span class="hljs-number">2</span></span>] =&gt; <span class="hljs-string"><span class="hljs-string">"cdcdcdcd"</span></span></code> </pre> <br><p>  Der einzige Unterschied besteht darin, dass wir eine Nachbearbeitung hinzugefügt haben, um die Anzahl der Wiederholungen zu berechnen. </p><br><p>  Hier ist ein weiteres praktisches reguläres <code>\d</code> , das einer Zahl von 0 bis 9 entspricht und eine Zahl zurückgibt: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">digit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> digit = asum [ charAs (intToDigit i) i | i &lt;- [<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.9</span></span>] ]</code> </pre> <br><p>  Hier stellt die <code>asum</code> Funktion aus dem <code>Control.Applicative.Alternative</code> Paket eine Auswahl aus den Listenelementen <code>asum [x,y,z] = x &lt;|&gt; y &lt;|&gt; z</code> , und die <code>intToDigit</code> Funktion <code>intToDigit</code> im <code>Data.Char</code> Paket definiert.  Und wieder können wir ziemlich elegante Dinge erstellen, zum Beispiel den Ausdruck <code>\[\d\]</code> , der der Zahl in eckigen Klammern entspricht: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bracketDigit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> bracketDigit = char '[' *&gt; digit &lt;* char ']'</code> </pre> <br><h1 id="parsing">  Parsen </h1><br><p>  Wir haben lediglich den Datentyp für ein Literal mit Verkettung, Auswahl und Wiederholung beschrieben.  Großartig!  Aber was wir wirklich brauchen, ist eine Zeichenfolge mit einem regulären Ausdruck abzugleichen, oder?  Wie kann uns ein kostenloser alternativer Funktor dabei helfen?  In der Tat wird es viel helfen.  Schauen wir uns zwei Möglichkeiten an, um dies zu tun! </p><br><h2 id="razgruzhaem-alternativnyy-funktor">  Entladen Sie den alternativen Funktor </h2><br><p>  <strong>Was ist Freiheit?</strong> </p><br><p>  Die kanonische Art, eine freie Struktur zu verwenden, besteht darin, sie unter Verwendung einer geeigneten Algebra zu einer konkreten Struktur zu falten.  Beispielsweise wandelt die <code>foldMap</code> Transformation ein freies Monoid (Liste) in den Wert einer beliebigen Instanz der <code>Monoid</code> Klasse um: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldMap</span></span> :: <span class="hljs-type"><span class="hljs-type">Monoid</span></span> m =&gt; (a -&gt; m) -&gt; ([a] -&gt; m)</code> </pre> <br><p>  Die Funktion <code>foldMap</code> wandelt die Transformation <code>a -&gt; m</code> in die Transformation <code>[a] -&gt; m</code> (oder <code>FreeMonoid a -&gt; m</code> ) mit einem bestimmten Monoid <code>m</code> .  Die allgemeine Idee ist, dass Sie durch die Verwendung einer freien Struktur ihre spezifische Verwendung "für später" verschieben können, wobei der Zeitpunkt der Erstellung und der Zeitpunkt der Verwendung der Struktur getrennt werden. </p><br><p>  Zum Beispiel können wir ein freies Monoid aus Zahlen konstruieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- |  "" `Int`     `Int`,  `liftAlt`. liftFM :: Int -&gt; [Int] liftFM x = [x] myMon :: [Int] myMon = liftFM 1 &lt;&gt; liftFM 2 &lt;&gt; liftFM 3 &lt;&gt; liftFM 4</span></span></code> </pre> <br><p>  Und jetzt können wir entscheiden, wie wir die Operation <code>&lt;&gt;</code> interpretieren wollen: <br>  Vielleicht dieser Zusatz? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Sum</span></span> myMon <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 + 2 + 3 + 4</span></span></code> </pre> <br><p>  Oder Multiplikation? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Product</span></span> myMon <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 * 2 * 3 * 4</span></span></code> </pre> <br><p>  Oder vielleicht die Berechnung der maximalen Anzahl? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Max</span></span> myMon <span class="hljs-type"><span class="hljs-type">Max</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 `max` 2 `max` 3 `max` 4</span></span></code> </pre> <br><p>  Die Idee ist, die Auswahl eines bestimmten Monoids zu verschieben, indem zuerst eine freie Sammlung der Nummern 1, 2, 3 und 4 erstellt wird. Ein freies Monoid über Zahlen bestimmt die Struktur darüber, die Sie benötigen, nicht mehr und nicht weniger.  Um <code>foldMap</code> wir an, wie der Basistyp wahrgenommen werden soll, indem der Operator <code>&lt;&gt;</code> an ein bestimmtes Monoid übergeben wird. </p><br><p>  <strong>Interpretation in einem <code>State</code> Functor</strong> </p><br><p>  In der Praxis besteht das Erhalten eines Ergebnisses aus einer freien Struktur darin, einen geeigneten Funktor zu finden (oder zu erstellen), der uns das gewünschte Verhalten liefert.  In unserem Fall haben wir das Glück, dass es eine bestimmte Implementierung der <code>Alternative</code> Klasse gibt, die genau so funktioniert, wie wir sie benötigen: <code>StateT String Maybe</code> . </p><br><p>  Das Produkt <code>&lt;*&gt;</code> für diesen Funktor besteht darin, eine Folge von Zustandsänderungen zu organisieren.  In unserem Fall betrachten wir unter dem Status den Rest der analysierten Zeichenfolge, sodass die sequentielle Analyse die beste Übereinstimmung für die Operation <code>&lt;*&gt;</code> . </p><br><p>  Und seine Summe <code>&lt;|&gt;</code> funktioniert wie Backtracking, eine Suche mit einer Rückkehr zur Alternative im Fehlerfall.  Es speichert den Status seit der letzten erfolgreichen Ausführung der Analyse und kehrt zu ihm zurück, wenn die Alternative nicht erfolgreich ist.  Dies ist genau das Verhalten, das wir vom Ausdruck <code>R|S</code> erwarten <code>R|S</code> </p><br><p>  Schließlich heißt eine natürliche Transformation für einen kostenlosen alternativen Funktor <code>runAlt</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. pb -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">Alt</span></span> pa -&gt; fa</code> </pre> <br><p>  Oder für den Typ RegExp: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. <span class="hljs-type"><span class="hljs-type">Prim</span></span> b -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; fa</code> </pre> <br><p>  Wenn Sie mit <code>RankN</code> Typen (mit <code>forall b.</code> Construction) nicht vertraut sind, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> eine gute Einführung.  Der Punkt hier ist, dass Sie eine <code>runAlt</code> Funktion <code>runAlt</code> müssen, die mit <code>Prim b</code> für absolut jedes <code>b</code> funktioniert und nicht für einen bestimmten Typ, wie beispielsweise <code>Int</code> und <code>Bool</code> .  Das heißt, wie bei <code>foldMap</code> wir nur angeben, was mit dem Basistyp <code>foldMap</code> .  Beantworten Sie in unserem Fall die Frage: "Was ist mit dem Typ <code>Prim</code> zu tun?" </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">processPrim</span></span> :: <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> d:ds &lt;- get guard (c == d) put ds pure x</code> </pre> <br><p>  Dies ist eine Interpretation von <code>Prim</code> als Aktion im Kontext der <code>StateT String Maybe</code> Zeichenfolge. <code>StateT String Maybe</code> ist der Status eine <code>StateT String Maybe</code> Zeichenfolge.  Ich möchte Sie daran erinnern, dass <code>Prim</code> Informationen über das übereinstimmende Zeichen <code>c</code> und seine Interpretation in Form eines Wertes von <code>x</code> .  <code>Prim</code> Verarbeitung besteht aus den folgenden Schritten: </p><br><ul><li>  Mit <code>get</code> Status (noch nicht analysierter Teil der Zeichenfolge) und drucken sofort das erste Zeichen und den Rest aus.  Wenn die Zeile leer ist, wird eine Alternative zurückgegeben.  ( <em>Der <code>StateT</code> Transformator wirkt innerhalb des Vielleicht-Funktors. Wenn es nicht möglich ist, das Muster auf der rechten Seite des Operators <code>&lt;-</code> innerhalb des do-Blocks <code>StateT</code> , enden die Berechnungen mit dem <code>empty</code> Ergebnis, dh <code>Nothing</code> . Ca. Trans.</em> ). </li><li>  Wir verwenden den Schutzausdruck, um das aktuelle Zeichen mit dem angegebenen Zeichen abzugleichen.  Im Fehlerfall wird <code>empty</code> zurückgegeben und wir gehen zur alternativen Option über. </li><li>  Wir ändern den Status, indem wir die analysierte Zeichenfolge durch ihren "Schwanz" ersetzen, da zu diesem Zeitpunkt das aktuelle Zeichen bereits als erfolgreich analysiert betrachtet werden kann. </li><li>  Wir geben zurück, was das <code>Prim</code> Primitiv zurückgeben soll. </li></ul><br><p>  Mit dieser Funktion können Sie RegEx bereits einem Zeichenfolgenpräfix zuordnen.  Dazu müssen Sie die Berechnungen mit <code>runAlt</code> und <code>runStateT</code> <code>runAlt</code> und die analysierte Zeichenfolge als Argument an die letzte Funktion übergeben: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchPrefix</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchPrefix re = evalStateT (runAlt processPrim re)</code> </pre> <br><p>  Das ist alles!  Mal sehen, wie unsere erste Lösung funktioniert: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchPrefix digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchPrefix bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchPrefix (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchPrefix (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><p>  <strong>Warten Sie, was war das?</strong> </p><br><p>  Es scheint, dass alles etwas schneller ging als erwartet.  Vor einer Minute haben wir unser Primitiv geschrieben und dann wieder!  und der funktionierende Parser ist bereit.  Hier in der Tat der gesamte Schlüsselcode, ein paar Zeilen in Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.State (<span class="hljs-title"><span class="hljs-title">evalStateT</span></span>, <span class="hljs-title"><span class="hljs-title">put</span></span>, <span class="hljs-title"><span class="hljs-title">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free (<span class="hljs-title"><span class="hljs-title">runAlt</span></span>, <span class="hljs-type"><span class="hljs-type">Alt</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">guard</span></span>) data Prim a = Prim Char a deriving Functor type RegExp = Alt Prim matchPrefix :: RegExp a -&gt; String -&gt; Maybe a matchPrefix re = evalStateT (<span class="hljs-title"><span class="hljs-title">runAlt</span></span> <span class="hljs-title"><span class="hljs-title">processPrim</span></span> <span class="hljs-title"><span class="hljs-title">re</span></span>) where processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> <span class="hljs-title"><span class="hljs-title">cx</span></span>) = do d:ds &lt;- get guard (<span class="hljs-title"><span class="hljs-title">c</span></span> == <span class="hljs-title"><span class="hljs-title">d</span></span>) put ds pure x</code> </pre> <br><p>  Und haben wir einen voll funktionsfähigen Parser für reguläre Ausdrücke?  Was ist passiert? </p><br><p>  Denken Sie daran, dass <code>Alt Prim</code> auf einer hohen Abstraktionsebene bereits <code>pure</code> , <code>empty</code> <code>Prim</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> und <code>many</code> in seiner Struktur enthält (es gibt eine unangenehme Subtilität bei diesem Operator, aber dazu später mehr).  Was <code>runAlt</code> tut, ist das Verhalten eines bestimmten alternativen Funktors (in unserem Fall <code>StateT String Maybe</code> ), um das Verhalten der <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> und <code>many</code> Operatoren zu steuern.  <code>StateT</code> verfügt jedoch nicht über einen integrierten Operator, der <code>Prim</code> ähnelt, und dafür mussten wir <code>StateT</code> schreiben. </p><br><p>  Für den <code>Prim</code> Typ verwendet die Funktion <code>runAlt</code> , und für <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> und <code>many</code> wird eine geeignete Instanz der <code>Alternative</code> Klasse verwendet.  Somit werden 83% der Arbeit vom <code>StateT</code> Funktor für uns <code>StateT</code> , und die restlichen 17% werden von <code>StateT</code> erledigt.  In Wahrheit ist das etwas enttäuschend.  Man könnte fragen: Warum war es überhaupt notwendig, mit dem <code>Alt</code> Wrapper zu beginnen?  Warum nicht sofort den Typ <code>RegExp = StateT String Maybe</code> und das entsprechende <code>char :: Char -&gt; StateT String Maybe Char</code> ?  Wenn alles im StateT- <code>StateT</code> erledigt ist, warum sollte man sich dann mit <code>Alt</code> - einem kostenlosen alternativen Funktor? </p><br><p>  <code>Alt</code> Hauptvorteil von <code>Alt</code> gegenüber <code>StateT</code> ist, dass <code>StateT</code> ... ein ziemlich mächtiges Werkzeug ist.  Tatsächlich ist er jedoch bis zur Absurdität mächtig.  Es kann verwendet werden, um eine große Anzahl der unterschiedlichsten Berechnungen und Strukturen darzustellen, und es ist unangenehm, sich etwas vorzustellen, das kein regulärer Ausdruck ist.  Nehmen wir an, etwas Grundlegendes wie <code>put "hello" :: StateT String Maybe ()</code> stimmt mit keinem gültigen regulären Ausdruck überein, ist jedoch vom gleichen Typ wie <code>RegExp ()</code> .  Während wir also sagen, dass <code>Alt Prim</code> mit einem regulären Ausdruck übereinstimmt, nicht mehr, aber nicht weniger, können wir mit <code>StateT String Maybe</code> nicht dasselbe sagen.  Der <code>Alt Prim</code> Typ ist die perfekte Darstellung eines regulären Ausdrucks.  Alles, was mit seiner Hilfe ausgedrückt werden kann, ist ein regulärer Ausdruck, aber alles, was nicht so ein Ausdruck ist, kann nicht mit seiner Hilfe ausgedrückt werden.  Hier gibt es jedoch auch einige unangenehme Feinheiten, die mit Haskells Faulheit verbunden sind, dazu später mehr. </p><br><p>  Hier können wir <code>StateT</code> nur als einen Kontext betrachten, der für einen verwendet wird <br>  Interpretationen regulärer Ausdrücke - als Parser.  Sie können sich aber auch andere Möglichkeiten vorstellen, <code>RegExp</code> zu verwenden.  Zum Beispiel benötigen wir möglicherweise eine Textdarstellung, die <code>StateT</code> nicht zulässt. </p><br><p>  Wir können nicht sagen, dass <code>StateT String Maybe</code> ein regulärer Ausdruck ist, nur dass dieser Funktor einen Parser darstellen kann, der auf regulären Grammatiken basiert.  Aber über <code>Alt Prim</code> wir mit Sicherheit sagen, dass dies ein regulärer Ausdruck ist ( <em>wie Mathematiker sagen, sind sie bis zum Isomorphismus gleich, ca. Trans.</em> ). </p><br><h2 id="neposredstvennoe-ispolzovanie-svobodnoy-struktury">  Direkte Nutzung der freien Struktur </h2><br><p>  All dies ist natürlich sehr gut, aber was ist, wenn wir 83% der Arbeit nicht auf Code für einen Typ verlagern möchten, der von jemandem für uns geschrieben wurde?  Ist es möglich, die freie <code>Alt</code> Struktur direkt zum Schreiben eines Parsers zu verwenden?  Diese Frage ähnelt der folgenden: Wie schreibe <code>foldMap</code> eine Funktion, die Listen verarbeitet (durch Abgleichen der Konstruktoren <code>(:)</code> und <code>[]</code> ), anstatt nur <code>foldMap</code> ?  Wie kann man direkt mit dieser Struktur arbeiten, anstatt die Arbeit an ein bestimmtes Monoid zu delegieren? </p><br><p>  Schön, dass du gefragt hast!  Werfen wir einen Blick auf die Definition eines kostenlosen alternativen Funktors: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> fa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alternatives</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> fa = forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ap</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br><p>  Dies ist ein ungewöhnlicher Typ, der durch gegenseitige Rekursion definiert wird, sodass er sehr verwirrend aussehen kann.  Eine Möglichkeit, dies zu verstehen, besteht darin, sich vorzustellen, dass <code>Alt xs</code> eine Kette von Alternativen enthält, die mit dem Operator <code>&lt;|&gt;</code> .       <code>AltF</code> ,     <code>f</code> ,     <code>&lt;*&gt;</code> (   ). </p><br><p>   <code>AltF fa</code>    <code>[fr]</code> ,   <code>r</code>   . <code>Ap</code>   <code>(:)</code> ,  <code>fr</code> ,  <code>Pure</code> —   <code>[]</code> .  <code>forall r.</code>       <code>-XExistentialQuantification</code>         . </p><br><p>   , <code>Alt f</code>   ,      .     ,      ( )  <code>&lt;*&gt;</code>  <code>&lt;|&gt;</code> ,  ,   <code>[a]</code>      <code>&lt;&gt;</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>       ,     : </p><br><ul><li>   () — ,   <code>&lt;&gt;</code> : <br><pre> <code class="haskell hljs">[a,b,c,d] = [a]&lt;&gt;[b]&lt;&gt;[c]&lt;&gt;[d]</code> </pre> </li><li>   () —  ,   <code>+</code> ,   — ,   <code>*</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span>*(b+c)+d*(x+y+z)*h</code> </pre> </li><li>    (Alt f) —  ,   <code>&lt;|&gt;</code> ,   — ,   <code>&lt;*&gt;</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fa</span></span> &lt;*&gt; (fb &lt;|&gt; fc) &lt;|&gt; fd &lt;*&gt; (fx &lt;|&gt; fy &lt;|&gt; fz) &lt;*&gt; fh</code> </pre> </li></ul></div></div><br><p>   ,       <code>RegExp a -&gt; String -&gt; Maybe a</code> ,   ,     .          :         . </p><br><p>  ,   <code>Alt</code> .   ,           ,     . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchAlts</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchAlts (<span class="hljs-type"><span class="hljs-type">Alt</span></span> res) xs = asum [ matchChain re xs | re &lt;- res ]</code> </pre> <br><p>   <code>asum :: [Maybe a] -&gt; Maybe a</code>   ,   <code>Just</code> . ( <em>   ,   <code>Maybe a</code>       <code>Alternative</code> —   <code>Nothing</code> ,   <code>&lt;|&gt;</code>    . . .</em> ) </p><br><p>     .       <code>AltF</code> ,   <code>Ap</code>  <code>Pure</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = _ matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) cs = _</code> </pre> <br><p>      "  ":     GHC   "",   ,    ,   . ( <em> Haskell "" (holes)     ,   <code>_</code> ,      . . .</em> )        : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> d:ds | c == d -&gt; matchAlts (($ x) &lt;$&gt; next) ds | otherwise -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) _ = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br><p>   <code>Ap</code> (  <code>(:)</code> ),  ,  -    .         ,       .    <code>Prim r</code> ,   ,           <code>next :: RegExp (r -&gt; a)</code> .    ,       <code>next</code> .   , ""  ,  <code>Nothing</code> . ,     <code>Pure x</code> (   <code>[]</code> ), ,  ,      . </p><br><p> ,        ,    .  ,  ,  " "    <code>Ap</code> , <code>Pure</code> , <code>AltF</code>  ..,            . </p><br><p>          : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchAlts digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchAlts bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchAlts (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchAlts (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>              . ,      () ,            .    ,  ,   . </p></div></div><br><h1 id="chto-zhe-imenno-my-sdelali">     ? </h1><br><p>                <code>foldMap</code>     .    ,   ,         foldMap,     ,     ,    ,   ! ,   —    ,           —    <code>(:)</code>  <code>[]</code> . </p><br><p>  ,   ,    : ,   ,    ,  <code>(:)</code> ,  <code>[]</code> .  ,     .  ,  <code>[1,2,3] &lt;&gt; [4]</code>      ,   <code>[1] &lt;&gt; [2,3] &lt;&gt; [4]</code> .  ,    ,      . </p><br><p>        .  ,     : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a | forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Seq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Union</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Many</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>       <code>RegExp</code> ,        .      . ,      <code>RegExp</code>       : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | a|(b|c) abc1 :: RegExp Int abc1 = Prim 'a' 1 `Union` (Prim 'b' 2 `Union` Prim 'c' 3) -- | (a|b)|c abc2 :: RegExp Int abc2 = (Prim 'a' 1 `Union` Prim 'b' 2) `Union` Prim 'c' 3</span></span></code> </pre> <br><p>  ,             . </p><br><p>    <code>Alt Prim</code> ,       ,        ,       .  ,       <code>matchAlts</code> ,            .     <code>(a|b)|c</code>  <code>a|(b|c)</code> .     <code>Alt</code>        . ,     ,    . </p><br><p>    ,    ,       <code>(a|b)|c</code>  ,  <code>(a|b)|c</code> , , ,       <code>RegExp</code> .  <code>Alt</code>       ,       . </p><br><p> ,  ,    <code>Alt</code>    , <code>Alt Prim</code>       . , <code>Alt Prim</code>       <code>a|a</code>  <code>a</code> .    ,   <code>Alt f</code>       <code>f</code> .        ,   :      .        , ,  ,     . </p><br><h1 id="nekotorye-dosadnye-tonkosti">    </h1><br><p>     ,     .      ,      ,            .        <code>RegExp</code>  ,            ,    — . </p><br><p>    ,          Haskell. ,  -  <code>[a]</code>      . ( <em>       ,       -  ,   "" </em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x22A5;</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.808ex" height="1.937ex" viewBox="0 -728.2 778.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/448644/&amp;usg=ALkJrhgjj9cqUW36zL4oq3ouQBi9IWjpxw#MJMAIN-22A5" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⊥</font></font></mi></math></span></span><script type="math/tex" id="MathJax-Element-1">\bot</script></em>  <em>,      - "" .</em>  <em>ca.</em> <em>.</em>  ) </p><br><p>       : <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,              ( <em>,    ,       ,      . . .</em> ).  ,  Haskell     .   ,    <code>Alt</code>   <code>many</code> .  , <code>a*</code>   <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,             .     -    <code>many (char 'a')</code> ,    . Haskell       <code>Alt</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,      . </p><br><p>  ,    ,   ,      ,           (),         .        ,     <code>many</code>    . </p><br><p> ,   !    ""   <code>Alt</code> ,    <code>Control.Alternative.Free.Final</code> ,     <code>many</code> (,    ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ). </p><br><p>           ,    ,  <code>runAlt</code> . ,        <code>Alternative</code> ,     <code>many</code> (  <code>RE</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regex-applicative</a> )       .      ,  Haskell      , ,   , <code>many</code>       . </p><br><p>    ,   .          (       ),          ( <em>,        , . .</em> ).    <code>matchPrefix</code> ,        ,   ,        .  ,   ,    ,      ,       .      ,   GHC        . </p><br><h1 id="poslednie-shtrihi">   </h1><br><p>         ,       ,   <code>tails</code> (   )  <code>mapMaybe</code> (           ).    ,     ,    <code>listToMaybe</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matches</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [a] matches re = mapMaybe (matchPrefix re) . tails firstMatch :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a firstMatch re = listToMaybe . matches re</code> </pre> <br><p>    ,   ,   <code>matchPrefix</code>   <code>Nothing</code>      ,  <code>listToMaybe</code>      ,   <code>Nothing</code> ( <em>      ,      . . .</em> ). </p><br><p> ,        .    ,       ,     —  ,    .       ,         .    ,     ,    ,      . </p><br><p>        <code>Alt Prim</code>         ,    :   ,  ,  ,    . </p><br><p>       ?        .      : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Only</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    | Letter a --     | Digit (Int -&gt; a) --    , | Wildcard (Char -&gt; a) --    , | Satisfy (Char -&gt; Maybe a) --    , --  </span></span></span></span></code> </pre> <br><p>       ,      .      . </p><br><p>      ,   ,   .      <code>runAlt</code>      <code>Alt</code> . </p><br><p>                (). ,    ,        ,    ,    .       <code>|</code>      . ( <em>         ,        . . .</em> ).     ,  -     .  ,   <code>MonadPlus</code>     -   ,        ,     .     ,      . </p><br><p> ,   ,         .  ,   ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448644/">https://habr.com/ru/post/de448644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448634/index.html">Ukrainischunterricht</a></li>
<li><a href="../de448636/index.html">Hackaday Retro Computer Fall</a></li>
<li><a href="../de448638/index.html">Buildroot - Teil 1. Allgemeine Informationen, Aufbau eines Minimalsystems, Einstellung über das Menü</a></li>
<li><a href="../de448640/index.html">SSD GIGABYTE Aorus RGB M.2: kleine, gleichmäßige Fernbedienung für RGB-LEDs (2 Teile)</a></li>
<li><a href="../de448642/index.html">Obligatorisches Modell für die Verteilung von Rechten in FreeBSD</a></li>
<li><a href="../de448648/index.html">Wie man alle in die Wissenschaft einbindet und das Büro nicht in eine Brutstätte des Hasses verwandelt</a></li>
<li><a href="../de448652/index.html">Mozilla WebThings auf Raspberry Pi - Erste Schritte</a></li>
<li><a href="../de448654/index.html">Mozilla WebThings - Gateway-Setup</a></li>
<li><a href="../de448656/index.html">Der große Bruder beobachtet ... sich selbst oder eine Karte mit der Geschichte der Bewegungen in HomeAssistant</a></li>
<li><a href="../de448658/index.html">Was kann über den OBD-Anschluss im Auto getan werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>