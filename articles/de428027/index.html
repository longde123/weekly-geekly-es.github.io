<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèûÔ∏è üë®üèø‚Äçüöí üëπ Wie ich versucht habe, einen statischen GLSL-Analysator herzustellen (und was schief gelaufen ist) üïï ‚ôçÔ∏è üëµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einmal bereitete ich mich auf Ludum Dare vor und machte ein einfaches Spiel, in dem ich Pixel-Shader verwendete (andere wurden nicht in die Phaser-Eng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich versucht habe, einen statischen GLSL-Analysator herzustellen (und was schief gelaufen ist)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428027/"><p>  Einmal bereitete ich mich auf Ludum Dare vor und machte ein einfaches Spiel, in dem ich Pixel-Shader verwendete (andere wurden nicht in die Phaser-Engine aufgenommen). </p><br><div class="spoiler">  <b class="spoiler_title">Was sind Shader?</b> <div class="spoiler_text"><p>  Shader sind GLSL C-√§hnliche Programme, die auf einer Grafikkarte ausgef√ºhrt werden.  Es gibt zwei Arten von Shadern. In diesem Artikel geht es um Pixel-Shader (sie sind auch "Fragment" -, Fragment-Shader), die in dieser Form sehr grob dargestellt werden k√∂nnen: </p><br><pre><code class="hljs lisp">color = pixelShader(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, ...other attributes)</code> </pre> <br><p>  Das hei√üt,  F√ºr jedes Pixel des Ausgabebildes wird ein Shader ausgef√ºhrt, der seine Farbe bestimmt oder verfeinert. <br>  Sie k√∂nnen den Einf√ºhrungsartikel zu einem anderen Artikel im Hub lesen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/333002/</a> </p></div></div><br><p>  Nach dem Testen warf ich den Link zu einem Freund und erhielt von ihm einen solchen Screenshot mit der Frage "Ist das normal?" </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ys/ti/qp/ystiqpls-jpsxgixk9blbocn6u8.png"></div><br><p>  Nein, das war nicht normal.  Nachdem ich mir den Shader-Code genau angesehen hatte, stellte ich einen Berechnungsfehler fest: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; M) { realColor = mix(color1,color2, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span> - t / R1, <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); }</code> </pre> <br><p>  Weil  Da die Konstante R1 kleiner als M war, war in einigen F√§llen das Ergebnis im ersten Argument von pow eine Zahl kleiner als Null.  Die Quadratwurzel der negativen Zahl ist zumindest f√ºr den GLSL-Standard eine mysteri√∂se Sache.  Meine Grafikkarte war nicht verwirrt und kam irgendwie aus dieser Position heraus (es scheint, als h√§tte sie von pow 0 zur√ºckgegeben), aber es stellte sich heraus, dass sie f√ºr einen Freund besser lesbar war. </p><br><p>  Und dann dachte ich: Kann ich solche Probleme in Zukunft vermeiden?  Niemand ist vor Fehlern sicher, insbesondere solche, die nicht lokal reproduziert werden.  Sie k√∂nnen keine Komponententests f√ºr GLSL schreiben.  Gleichzeitig sind die Transformationen innerhalb des Shaders recht einfach - Multiplikation, Division, Sinus, Cosinus ... Ist es wirklich unm√∂glich, die Werte jeder Variablen zu verfolgen und sicherzustellen, dass sie unter keinen Umst√§nden die zul√§ssigen Werte √ºberschreiten? </p><br><p>  Deshalb habe ich mich entschlossen, eine statische Analyse f√ºr GLSL durchzuf√ºhren.  Was dabei herauskam - Sie k√∂nnen es unter dem Schnitt lesen. </p><br><p>  Ich warne Sie sofort: Ich konnte kein fertiges Produkt bekommen, nur einen p√§dagogischen Prototyp. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-analiz">  Vorl√§ufige Analyse </h2><br><p>  Nachdem ich einige der vorhandenen Artikel zu diesem Thema studiert hatte (und gleichzeitig herausgefunden hatte, dass das Thema Wertbereichsanalyse hei√üt), war ich froh, dass ich GLSL und keine andere Sprache hatte.  √úberzeugen Sie sich selbst: </p><br><ul><li>  keine "Dynamik" - Verweise auf Funktionen, Schnittstellen, automatisch abgeleitete Typen usw. </li><li>  Keine direkte Speicherbehandlung </li><li>  Keine Module, Verkn√ºpfung, sp√§te Bindung - der gesamte Quellcode des Shaders ist verf√ºgbar <br>  Bereiche sind allgemein f√ºr Eingabewerte bekannt </li><li>  wenige Datentypen, und diese drehen sich um einen Float.  int / bool werden selten verwendet und es ist nicht so wichtig, ihnen zu folgen </li><li>  ifs und Schleifen werden selten verwendet (aufgrund von Leistungsproblemen).  Wenn Schleifen verwendet werden, handelt es sich h√§ufig um einfache Z√§hler, mit denen Sie ein Array durchlaufen oder einen bestimmten Effekt mehrmals wiederholen k√∂nnen.  Niemand wird solch einen Horror in GLSL schreiben (ich hoffe). </li></ul><br><pre> <code class="python hljs">//   - https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/RangeAnalysis.pdf k = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> k &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>: i = <span class="hljs-number"><span class="hljs-number">0</span></span> j = k <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; j: i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> j = j ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span> k = k + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Angesichts der Einschr√§nkungen von GLSL scheint die Aufgabe im Allgemeinen l√∂sbar zu sein.  Der Hauptalgorithmus lautet wie folgt: </p><br><ol><li>  Analysieren Sie den Shader-Code und erstellen Sie eine Folge von Befehlen, die die Werte beliebiger Variablen √§ndern </li><li>  Wenn Sie die Anfangsbereiche f√ºr die Variablen kennen, gehen Sie die Sequenz durch und aktualisieren Sie die Bereiche, wenn sie sich √§ndern </li><li>  Wenn der Bereich eine bestimmte Grenze √ºberschreitet (z. B. kann eine negative Zahl zu pow kommen oder etwas gr√∂√üer als 1 zur "Ausgabefarbe" gl_FragColor in der roten Komponente), m√ºssen Sie eine Warnung anzeigen </li></ol><br><h2 id="ispolzuemye-tehnologii">  Verwendete Technologien </h2><br><p>  Hier hatte ich eine lange und schmerzhafte Wahl.  Einerseits besteht mein Hauptbereich darin, WebGL-Shader zu √ºberpr√ºfen. Warum also nicht Javascript, um w√§hrend der Entwicklung alles im Browser auszuf√ºhren?  Andererseits habe ich schon lange vor, Phaser zu verlassen und eine andere Engine wie Unity oder LibGDX auszuprobieren.  Es wird auch Shader geben, aber Javascript wird weg sein. </p><br><p>  Und andererseits wurde die Aufgabe haupts√§chlich zur Unterhaltung erledigt.  Und die beste Unterhaltung der Welt ist der Zoo.  Deshalb: </p><br><ol><li>  GLSL-Code-Analyse in Javascript.  Es ist nur so, dass ich ziemlich schnell die Bibliothek zum Parsen von GLSL in AST gefunden habe und die Test-Benutzeroberfl√§che vertrauter zu sein scheint als das Web.  AST wird zu einer Folge von Befehlen, die an ... </li><li>  ... der zweite Teil, der in C ++ geschrieben und in WebAssembly kompiliert ist.  Ich habe mich folgenderma√üen entschieden: Wenn ich diesen Analysator pl√∂tzlich an einer anderen Engine befestigen m√∂chte, sollte dies mit einer C ++ - Bibliothek am einfachsten erfolgen. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Ein paar Worte zum Toolkit</b> <div class="spoiler_text"><ul><li>  Ich habe Visual Studio Code als Haupt-IDE verwendet und bin im Allgemeinen damit zufrieden.  Ich brauche ein bisschen Gl√ºck - Hauptsache, Strg + Klick sollte funktionieren und beim Tippen automatisch vervollst√§ndigt werden.  Beide Funktionen funktionieren sowohl in C ++ als auch in JS einwandfrei.  Nun, die F√§higkeit, nicht verschiedene IDEs untereinander zu wechseln, ist ebenfalls gro√üartig. </li><li>  Zum Kompilieren von C ++ verwendet WebAssembly das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cheerp-</a> Tool (es ist kostenpflichtig, aber f√ºr Open-Source-Projekte kostenlos).  Ich hatte keine Probleme mit seiner Verwendung, au√üer dass es den Code ziemlich seltsam optimierte, aber hier bin ich mir nicht sicher, wessen Fehler es ist - der Cheerp selbst oder der von ihm verwendete Clang-Compiler. </li><li>  f√ºr Unit-Tests in C ++ nahm der gute alte gtest </li><li>  Um js im B√ºndel zu bauen, brauchte man ein Mikrobundle.  Er erf√ºllte meine Anforderungen "Ich m√∂chte 1 npm Paket und ein paar Kommandozeilenflags", aber gleichzeitig leider nicht ohne Probleme.  Angenommen, die Uhr st√ºrzt bei einem Fehler ab, w√§hrend eingehendes Javascript mit der Meldung <code>[Object object]</code> analysiert wird, was nicht viel hilft. </li></ul></div></div><br><p>  Alles, jetzt kannst du gehen. </p><br><h2 id="korotko-o-modeli">  Kurz zum Modell </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/hf/8s/chhf8sgclvkleyx_kwasvr74hz8.png"></div><br><p>  Der Analysator speichert eine Liste der im Shader gefundenen Variablen im Speicher und speichert f√ºr jede Variable den aktuell m√∂glichen Wertebereich (z. B. <code>[0,1]</code> oder <code>[1,‚àû)</code> ). </p><br><p>  Der Analysator erh√§lt einen Workflow wie folgt: </p><br><pre> <code class="hljs matlab">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> opCode: <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span> arguments: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,-,-,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,-,-]</code> </pre> <br><p>  Hier rufen wir die sin-Funktion auf, die Variablen mit id = 3 und 4 werden ihr zugef√ºhrt, und das Ergebnis wird in die Variablen 1 und 2 geschrieben. Dieser Aufruf entspricht dem GLSL-ten: </p><br><pre> <code class="hljs lisp">vec2 a = sin(<span class="hljs-name"><span class="hljs-name">b</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Beachten Sie die leeren Argumente (markiert als "-").  In GLSL sind fast alle integrierten Funktionen f√ºr verschiedene S√§tze von Eingabetypen √ºberladen, d. H.  Es gibt <code>sin(float)</code> , <code>sin(vec2)</code> , <code>sin(vec3)</code> , <code>sin(vec4)</code> .  Der <code>sin(vec4)</code> bringe ich alle √ºberladenen Versionen in eine Form - in diesem Fall <code>sin(vec4)</code> . </p><br><p>  Der Analysator gibt eine Liste von √Ñnderungen f√ºr jede Variable aus, wie z </p><br><pre> <code class="hljs vhdl">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> branchId: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>: [-<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Dies bedeutet, dass "die Variable 2 in Zeile 10 in Zweig 1 einen Bereich von -1 bis einschlie√ülich 1 hat" (wir werden etwas sp√§ter √ºber Zweig sprechen).  Jetzt k√∂nnen Sie Wertebereiche im Quellcode wundersch√∂n hervorheben. </p><br><h2 id="horoshee-nachalo">  Guter Start </h2><br><p>  Wenn der AST-Baum bereits zu einer Liste von Befehlen geworden ist, ist es an der Zeit, Standardfunktionen und -methoden zu implementieren.  Es gibt ziemlich viele von ihnen (und sie haben auch eine Reihe von √úberlastungen, wie ich oben geschrieben habe), aber im Allgemeinen haben sie vorhersehbare Bereichstransformationen.  Nehmen wir an, f√ºr ein solches Beispiel ist alles ziemlich offensichtlich: </p><br><pre> <code class="hljs ruby">uniform float angle; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; (-‚àû,‚àû) /<span class="hljs-regexp"><span class="hljs-regexp">/... float y = sin(angle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [-1,1] float ynorm = 1 + y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [0,2] gl_FragColor.r = ynorm /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/aj/0f/vbaj0fdcx0nnk3lc2qti7egg7yq.png"></div><br><p>  Der rote Kanal der Ausgabefarbe liegt im akzeptablen Bereich, es liegen keine Fehler vor. </p><br><p>  Wenn Sie mehr integrierte Funktionen abdecken, reicht eine solche Analyse f√ºr die H√§lfte der Shader aus.  Aber was ist mit der zweiten H√§lfte - mit Bedingungen, Schleifen und Funktionen? </p><br><h2 id="vetvleniya">  Zweige </h2><br><p>  Nehmen Sie zum Beispiel einen solchen Shader. </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uSampler; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec2 uv; <span class="hljs-comment"><span class="hljs-comment">// [0,1] void main() { float a = texture2D(uSampler, uv).a; // -&gt; [0,1] float k; // -&gt; ? if (a &lt; 0.5) { k = a * 2.; } else { k = 1. - a; } gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Die Variable <code>a</code> wird aus der Textur entnommen, und daher liegt der Wert dieser Variablen zwischen 0 und 1. Aber welche Werte kann <code>k</code> annehmen? </p><br><p>  Sie k√∂nnen den einfachen Weg gehen und ‚Äûdie Zweige vereinen‚Äú - berechnen Sie die Reichweite in jedem Fall und geben Sie die Summe aus.  F√ºr den if-Zweig erhalten wir <code>k = [0,2]</code> und f√ºr den else-Zweig <code>k = [0,1]</code> .  Wenn Sie kombinieren, stellt sich heraus, dass <code>[0,2]</code> und Sie einen Fehler machen m√ºssen, weil  Werte gr√∂√üer als 1 fallen in die Ausgabefarbe von <code>gl_FragColor</code> . </p><br><p>  Dies ist jedoch ein eindeutiger Fehlalarm, und f√ºr einen statischen Analysator gibt es nichts Schlimmeres als Fehlalarme - wenn er nicht nach dem ersten Schrei des "Wolfs" ausgeschaltet wird, dann sicher nach dem zehnten. </p><br><p>  Wir m√ºssen also beide Zweige getrennt verarbeiten und in beiden Zweigen den Bereich der Variablen <code>a</code> kl√§ren (obwohl sie formal nicht ge√§ndert wurde).  So k√∂nnte es aussehen: </p><br><p>  Zweig 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0, 0.5) k = a * 2.; //k = [0, 1) gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Zweig 2: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0.5, 1] k = 1. - a; //k = [0, 0.5] gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Wenn der Analysator auf eine bestimmte Bedingung st√∂√üt, die sich je nach Bereich unterschiedlich verh√§lt, werden f√ºr jeden Fall Verzweigungen (Brunchs) erstellt.  In jedem Fall verfeinert er den Bereich der Quellvariablen und bewegt sich weiter unten in der Befehlsliste. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/fp/dy/n7fpdy2xtg92oy5f0qsl7p8thz4.png"></div><br><p>  Es ist klarstellbar, dass die Zweige in diesem Fall nicht mit dem if-else-Konstrukt zusammenh√§ngen.  Verzweigungen werden erstellt, wenn ein Bereich einer Variablen in Unterbereiche unterteilt ist. Die Ursache kann eine optionale bedingte Anweisung sein.  Beispielsweise erstellt die Schrittfunktion auch Zweige.  Der n√§chste GLSL-Shader macht dasselbe wie der vorherige, verwendet jedoch keine Verzweigung (was √ºbrigens in Bezug auf die Leistung besser ist). </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> k = mix(a * <span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>. - a, step(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, a)); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>.) * k;</code> </pre> <br><p>  Die Schrittfunktion sollte 0 zur√ºckgeben, wenn a &lt;0,5 und andernfalls 1.  Daher werden hier auch Zweige angelegt - √§hnlich wie im vorherigen Beispiel. </p><br><h2 id="utochnenie-drugih-peremennyh">  Verfeinerung anderer Variablen </h2><br><p>  Betrachten Sie ein leicht modifiziertes vorheriges Beispiel: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-comment"><span class="hljs-comment">// -&gt; [0,1] float b = a - 0.5; // -&gt; [-0.5, 0.5] if (b &lt; 0.) { k = a * 2.; // k,a -&gt; ? } else { k = 1. - a; }</span></span></code> </pre> <br><p>  Hier ist die Nuance wie folgt: Verzweigung tritt in Bezug auf Variable <code>b</code> , und Berechnungen erfolgen in Bezug auf Variable <code>b</code> .  Das hei√üt, in jedem Zweig gibt es einen korrekten Wert des Bereichs <code>b</code> , der jedoch v√∂llig unn√∂tig ist, und den urspr√ºnglichen Wert des Bereichs <code>a</code> ist v√∂llig falsch. </p><br><p>  Der Analysator sah jedoch, dass der Bereich <code>b</code> durch Berechnen aus <code>a</code> .  Wenn Sie sich an diese Informationen erinnern, kann der Analysator beim Verzweigen alle Quellvariablen durchgehen und ihren Bereich durch Ausf√ºhren der inversen Berechnung verfeinern. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pi/lb/sz/pilbszwvjnellonuoosc_oux7wq.png"></div><br><h2 id="funkcii-i-cikly">  Funktionen und Schleifen </h2><br><p>  GLSL verf√ºgt nicht √ºber virtuelle Methoden, Funktionszeiger oder sogar rekursive Aufrufe, sodass jeder Funktionsaufruf eindeutig ist.  Daher ist es am einfachsten, den Funktionsk√∂rper am Ort des Aufrufs einzuf√ºgen (mit anderen Worten inline).  Dies stimmt vollst√§ndig mit der Reihenfolge der Befehle √ºberein. </p><br><p>  Bei Zyklen ist es komplizierter, weil  Formal unterst√ºtzt GLSL die C-√§hnliche for-Schleife vollst√§ndig.  In den meisten F√§llen werden Schleifen jedoch in der einfachsten Form verwendet: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) {}</code> </pre> <br><p>  Solche Zyklen sind leicht "bereitzustellen", d.h.  F√ºhren Sie den K√∂rper der Schleife 12 Mal nacheinander ein.  Nachdem ich dar√ºber nachgedacht hatte, entschied ich mich bisher, nur eine solche Option zu unterst√ºtzen. </p><br><p>  Der Vorteil dieses Ansatzes besteht darin, dass Befehle in einem Stream an den Analysator ausgegeben werden k√∂nnen, ohne dass Fragmente (wie Funktionsk√∂rper oder Schleifen) zur weiteren Wiederverwendung gespeichert werden m√ºssen. </p><br><h2 id="vsplyvshie-problemy">  Pop-up-Probleme </h2><br><h3 id="problema-1-slozhnost-ili-nevozmozhnost-utochneniya">  Problem Nr. 1: Schwierigkeit oder Unf√§higkeit zu kl√§ren </h3><br><p>  Oben haben wir F√§lle untersucht, in denen wir beim Verfeinern der Werte einer Variablen Schlussfolgerungen √ºber die Werte einer anderen Variablen gezogen haben.  Und dieses Problem wird gel√∂st, wenn Operationen wie Addition / Subtraktion beteiligt sind.  Aber was tun mit Trigonometrie?  Zum Beispiel eine solche Bedingung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) &gt; <span class="hljs-number"><span class="hljs-number">0.</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    a? }</span></span></code> </pre> <br><p>  Wie berechnet man die Reichweite <code>a</code> Innenraums, wenn?  Es stellt sich eine endlose Reihe von Bereichen mit pi-Schritten heraus, mit denen dann sehr unpraktisch gearbeitet werden kann. </p><br><p>  Und es kann eine solche Situation geben: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-comment"><span class="hljs-comment">// [-10,10] float b = getAnotherValue(); //[-20, 30] float k = a + b; if (k &gt; 0) { //a? b? }</span></span></code> </pre> <br><p>  Die Kl√§rung der Bereiche <code>a</code> und <code>b</code> im allgemeinen Fall ist unrealistisch.  Und deshalb sind Fehlalarme m√∂glich. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/z9/ea/7ez9eady082-nfgem7j0c65hslk.png"></div><br><h3 id="problema-2-zavisimye-diapazony">  Problem Nr. 2: Abh√§ngige Bereiche </h3><br><p>  Betrachten Sie dieses Beispiel: </p><br><pre> <code class="hljs pgsql">uniform <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> //-&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-type"><span class="hljs-type">float</span></span> val2 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1.</span></span>; gl_FragColor = vec4(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - val2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/0m/jo/gh0mjodwd1oqeoh32mcdkollcyg.png"></div><br><p>  Zun√§chst ber√ºcksichtigt der Analysator den Bereich der Variablen <code>val2</code> - und es wird erwartet, dass er <code>[0,1] - 1 == [-1, 0]</code> betr√§gt. </p><br><p>  In <code>value - val2</code> des <code>value - val2</code> ber√ºcksichtigt der Analysator jedoch nicht, dass <code>val2</code> aus dem <code>value</code> , und arbeitet mit Bereichen, als ob sie unabh√§ngig voneinander w√§ren.  Ruft <code>[0,1] - [-1,0] = [0,2]</code> und meldet einen Fehler.  Obwohl er in Wirklichkeit eine Konstante 1 haben sollte. </p><br><p>  M√∂gliche L√∂sung: Speichern Sie f√ºr jede Variable nicht nur den Verlauf der Bereiche, sondern auch den gesamten ‚ÄûStammbaum‚Äú - von welchen Variablen abh√§ngig war, von welchen Operationen usw.  Eine andere Sache ist, dass es nicht einfach sein wird, diesen Stammbaum zu ‚Äûentfalten‚Äú. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/47/-_/qb/47-_qbz4nhcsbbfo_8wvtepll94.png"></div><br><h3 id="problema-3-diapazony-zavisimye-neyavno">  Problem Nr. 3: Implizit abh√§ngige Bereiche </h3><br><p>  Hier ist ein Beispiel: </p><br><pre> <code class="hljs lisp">float k = sin(<span class="hljs-name"><span class="hljs-name">a</span></span>) + cos(<span class="hljs-name"><span class="hljs-name">a</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Hier nimmt der Analysator an, dass der Bereich <code>k = [-1,1] + [-1,1] = [-2,2]</code> .  Welches ist falsch, weil  <code>sin(a) + cos(a)</code> f√ºr jedes <code>a</code> liegt im Bereich <code>[-‚àö2, ‚àö2]</code> . </p><br><p>  Das Ergebnis der formalen Berechnung von <code>sin(a)</code> h√§ngt nicht vom Ergebnis der Berechnung von <code>cos(a)</code> .  Sie h√§ngen jedoch vom gleichen Bereich von <code>a</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pf/wz/ne/pfwznek8x2iguen0bhyx0thwjuq.png"></div><br><h2 id="itogi-i-vyvody">  Zusammenfassung und Schlussfolgerungen </h2><br><p>  Wie sich herausstellte, ist es keine leichte Aufgabe, eine Wertebereichsanalyse auch f√ºr eine so einfache und hochspezialisierte Sprache wie GLSL durchzuf√ºhren.  Die Abdeckung von Sprachfunktionen kann noch verbessert werden: Die Unterst√ºtzung von Arrays, Matrizen und allen integrierten Operationen ist eine rein technische Aufgabe, die lediglich zeitaufw√§ndig ist.  Aber wie man Situationen mit Abh√§ngigkeiten zwischen Variablen l√∂st - die Frage ist mir noch unklar.  Ohne diese Probleme zu l√∂sen, sind Fehlalarme unvermeidlich, deren Rauschen letztendlich die Vorteile der statischen Analyse √ºberwiegen kann. </p><br><p>  Angesichts dessen, was mir begegnet ist, wundert es mich nicht besonders, dass einige bekannte Tools f√ºr die Wertebereichsanalyse in anderen Sprachen fehlen - sie weisen eindeutig mehr Probleme auf als die relativ einfache GLSL.  Gleichzeitig k√∂nnen Sie mindestens Komponententests in anderen Sprachen schreiben, aber hier k√∂nnen Sie dies nicht tun. </p><br><p>  Eine alternative L√∂sung k√∂nnte das Kompilieren aus anderen Sprachen in GLSL sein - hier gab es k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel √ºber das Kompilieren aus Kotlin</a> .  Anschlie√üend k√∂nnen Sie Unit-Tests f√ºr den Quellcode schreiben und alle Randbedingungen abdecken.  Oder erstellen Sie einen ‚Äûdynamischen Analysator‚Äú, der dieselben Daten ausf√ºhrt, die √ºber den urspr√ºnglichen Kotlin-Code an den Shader gesendet werden, und vor m√∂glichen Problemen warnt. </p><br><p>  Also h√∂rte ich an diesem Punkt auf.  Die Bibliothek hat leider nicht funktioniert, aber vielleicht ist dieser Prototyp f√ºr jemanden n√ºtzlich. </p><br><p>  Repository auf Github, zur √úberpr√ºfung: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/AlexeyGrishin/glsl-value-range-analysis</a> </li></ul><br><p>  Um zu versuchen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://alexeygrishin.github.io/glsl-value-range-analysis/html/</a> </li></ul><br><h2 id="bonus-osobennosti-sborki-webassembly-s-raznymi-flagami-kompilyatora">  Bonus: Webassembly-Funktionen mit verschiedenen Compiler-Flags </h2><br><p>  Anfangs habe ich den Analysator ohne Verwendung von stdlib durchgef√ºhrt - auf altmodische Weise mit Arrays und Zeigern.  Zu dieser Zeit war ich sehr besorgt √ºber die Gr√∂√üe der Ausgabe-Wasm-Datei, ich wollte, dass sie klein ist.  Aber ab einem bestimmten Zeitpunkt f√ºhlte ich mich unwohl und beschloss daher, alles auf stdlib zu √ºbertragen - intelligente Zeiger, normale Sammlungen, das ist alles. </p><br><p>  Dementsprechend hatte ich die M√∂glichkeit, die Ergebnisse der Zusammenstellung von zwei Versionen der Bibliothek zu vergleichen - mit und ohne stdlib.  Sehen Sie auch, wie guter / schlechter Cheerp (und das von ihm verwendete Klirren) den Code optimiert. </p><br><p>  Daher habe ich beide Versionen mit unterschiedlichen S√§tzen von Optimierungsflags ( <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code> und <code>-Oz</code> ) <code>-Oz</code> und f√ºr einige dieser Versionen die Analysegeschwindigkeit von 3.000 Operationen mit 1.000 Zweigen gemessen.  Ich stimme zu, nicht das gr√∂√üte Beispiel, aber IMHO reicht f√ºr eine vergleichende Analyse. </p><br><p>  Was geschah je nach Gr√∂√üe der WASM-Datei: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qz/u9/sc/qzu9sc7tg2jdz7v5-zfbvceqkv8.png"></div><br><p>  √úberraschenderweise ist die Gr√∂√üenoption mit der "Null" -Optimierung besser als fast alle anderen.  Ich gehe davon aus, dass es in <code>O3</code> eine aggressive Inline von allem auf der Welt gibt, die die Bin√§rdatei aufbl√§st.  Die erwartete Version ohne stdlib ist kompakter, aber nicht so sehr <del>  solche Dem√ºtigung ertragen </del>  um sich der Freude zu berauben, mit praktischen Sammlungen zu arbeiten. </p><br><p>  Nach Ausf√ºhrungsgeschwindigkeit: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w_/dc/hs/w_dchsujm7zdc4rvzjsaiwpzeme.png"></div><br><p>  Jetzt kann ich sehen, dass <code>-O3</code> im Vergleich zu <code>-O0</code> nicht umsonst sein Brot <code>-O0</code> .  Gleichzeitig fehlt der Unterschied zwischen Versionen mit und ohne stdlib praktisch (ich habe 10 Messungen durchgef√ºhrt, ich denke, bei einer gr√∂√üeren Zahl w√ºrde der Unterschied insgesamt verschwinden). </p><br><p>  Es ist erw√§hnenswert, 2 Punkte: </p><br><ul><li>  Das Diagramm zeigt die Durchschnittswerte aus 10 aufeinanderfolgenden Durchl√§ufen der Analyse. In allen Tests dauerte die allererste Analyse jedoch zweimal l√§nger als die √ºbrigen (d. H. 120 ms, und die n√§chsten waren bereits etwa 60 ms).  Es gab wahrscheinlich eine Initialisierung von WebAssembly. </li><li>  Mit der <code>-O3</code> Flagge habe ich einige schrecklich seltsame Fehler entdeckt, die ich f√ºr andere Flaggen nicht gefunden habe.  Zum Beispiel begannen die Min- und Max-Funktionen pl√∂tzlich auf die gleiche Weise zu funktionieren - wie Min. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit. <br>  Lassen Sie die Werte Ihrer Variablen niemals √ºber die Grenzen hinausgehen. <br>  Und los geht's. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428027/">https://habr.com/ru/post/de428027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428011/index.html">Weltraum-Zombielieder</a></li>
<li><a href="../de428019/index.html">Spielen Sie Mortal Kombat mit TensorFlow.js</a></li>
<li><a href="../de428021/index.html">Dichtungen gegen das neuronale Netz. Oder w√§hlen Sie ein neuronales Netzwerk aus und f√ºhren Sie es aus, um Objekte auf dem Raspberry Zero zu erkennen</a></li>
<li><a href="../de428023/index.html">Grundlagen der elektrischen Sicherheit bei der Konstruktion elektronischer Ger√§te</a></li>
<li><a href="../de428025/index.html">Anschlie√üen einer Auslagerungsdatei (SWAP) in MAC OS X bei Verwendung einer externen SSD als System</a></li>
<li><a href="../de428029/index.html">Digitale Veranstaltungen in Moskau vom 29. Oktober bis 4. November</a></li>
<li><a href="../de428031/index.html">3CX-Integration mit 1C: Trade Management - eine Methode zum Kombinieren von Konfigurationen</a></li>
<li><a href="../de428033/index.html">In den USA legalisiertes Hacken von Smart-Ger√§ten und Bordcomputern zum Zwecke der Reparatur und Aktualisierung</a></li>
<li><a href="../de428035/index.html">Red Hat wird von IBM √ºbernommen</a></li>
<li><a href="../de428039/index.html">Die Regierung plant nicht, sich f√ºr die Netzneutralit√§t einzusetzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>