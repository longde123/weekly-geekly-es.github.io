<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏞️ 👨🏿‍🚒 👹 Wie ich versucht habe, einen statischen GLSL-Analysator herzustellen (und was schief gelaufen ist) 🕕 ♍️ 👵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einmal bereitete ich mich auf Ludum Dare vor und machte ein einfaches Spiel, in dem ich Pixel-Shader verwendete (andere wurden nicht in die Phaser-Eng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich versucht habe, einen statischen GLSL-Analysator herzustellen (und was schief gelaufen ist)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428027/"><p>  Einmal bereitete ich mich auf Ludum Dare vor und machte ein einfaches Spiel, in dem ich Pixel-Shader verwendete (andere wurden nicht in die Phaser-Engine aufgenommen). </p><br><div class="spoiler">  <b class="spoiler_title">Was sind Shader?</b> <div class="spoiler_text"><p>  Shader sind GLSL C-ähnliche Programme, die auf einer Grafikkarte ausgeführt werden.  Es gibt zwei Arten von Shadern. In diesem Artikel geht es um Pixel-Shader (sie sind auch "Fragment" -, Fragment-Shader), die in dieser Form sehr grob dargestellt werden können: </p><br><pre><code class="hljs lisp">color = pixelShader(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, ...other attributes)</code> </pre> <br><p>  Das heißt,  Für jedes Pixel des Ausgabebildes wird ein Shader ausgeführt, der seine Farbe bestimmt oder verfeinert. <br>  Sie können den Einführungsartikel zu einem anderen Artikel im Hub lesen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/333002/</a> </p></div></div><br><p>  Nach dem Testen warf ich den Link zu einem Freund und erhielt von ihm einen solchen Screenshot mit der Frage "Ist das normal?" </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ys/ti/qp/ystiqpls-jpsxgixk9blbocn6u8.png"></div><br><p>  Nein, das war nicht normal.  Nachdem ich mir den Shader-Code genau angesehen hatte, stellte ich einen Berechnungsfehler fest: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; M) { realColor = mix(color1,color2, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span> - t / R1, <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); }</code> </pre> <br><p>  Weil  Da die Konstante R1 kleiner als M war, war in einigen Fällen das Ergebnis im ersten Argument von pow eine Zahl kleiner als Null.  Die Quadratwurzel der negativen Zahl ist zumindest für den GLSL-Standard eine mysteriöse Sache.  Meine Grafikkarte war nicht verwirrt und kam irgendwie aus dieser Position heraus (es scheint, als hätte sie von pow 0 zurückgegeben), aber es stellte sich heraus, dass sie für einen Freund besser lesbar war. </p><br><p>  Und dann dachte ich: Kann ich solche Probleme in Zukunft vermeiden?  Niemand ist vor Fehlern sicher, insbesondere solche, die nicht lokal reproduziert werden.  Sie können keine Komponententests für GLSL schreiben.  Gleichzeitig sind die Transformationen innerhalb des Shaders recht einfach - Multiplikation, Division, Sinus, Cosinus ... Ist es wirklich unmöglich, die Werte jeder Variablen zu verfolgen und sicherzustellen, dass sie unter keinen Umständen die zulässigen Werte überschreiten? </p><br><p>  Deshalb habe ich mich entschlossen, eine statische Analyse für GLSL durchzuführen.  Was dabei herauskam - Sie können es unter dem Schnitt lesen. </p><br><p>  Ich warne Sie sofort: Ich konnte kein fertiges Produkt bekommen, nur einen pädagogischen Prototyp. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-analiz">  Vorläufige Analyse </h2><br><p>  Nachdem ich einige der vorhandenen Artikel zu diesem Thema studiert hatte (und gleichzeitig herausgefunden hatte, dass das Thema Wertbereichsanalyse heißt), war ich froh, dass ich GLSL und keine andere Sprache hatte.  Überzeugen Sie sich selbst: </p><br><ul><li>  keine "Dynamik" - Verweise auf Funktionen, Schnittstellen, automatisch abgeleitete Typen usw. </li><li>  Keine direkte Speicherbehandlung </li><li>  Keine Module, Verknüpfung, späte Bindung - der gesamte Quellcode des Shaders ist verfügbar <br>  Bereiche sind allgemein für Eingabewerte bekannt </li><li>  wenige Datentypen, und diese drehen sich um einen Float.  int / bool werden selten verwendet und es ist nicht so wichtig, ihnen zu folgen </li><li>  ifs und Schleifen werden selten verwendet (aufgrund von Leistungsproblemen).  Wenn Schleifen verwendet werden, handelt es sich häufig um einfache Zähler, mit denen Sie ein Array durchlaufen oder einen bestimmten Effekt mehrmals wiederholen können.  Niemand wird solch einen Horror in GLSL schreiben (ich hoffe). </li></ul><br><pre> <code class="python hljs">//   - https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/RangeAnalysis.pdf k = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> k &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>: i = <span class="hljs-number"><span class="hljs-number">0</span></span> j = k <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; j: i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> j = j – <span class="hljs-number"><span class="hljs-number">1</span></span> k = k + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Angesichts der Einschränkungen von GLSL scheint die Aufgabe im Allgemeinen lösbar zu sein.  Der Hauptalgorithmus lautet wie folgt: </p><br><ol><li>  Analysieren Sie den Shader-Code und erstellen Sie eine Folge von Befehlen, die die Werte beliebiger Variablen ändern </li><li>  Wenn Sie die Anfangsbereiche für die Variablen kennen, gehen Sie die Sequenz durch und aktualisieren Sie die Bereiche, wenn sie sich ändern </li><li>  Wenn der Bereich eine bestimmte Grenze überschreitet (z. B. kann eine negative Zahl zu pow kommen oder etwas größer als 1 zur "Ausgabefarbe" gl_FragColor in der roten Komponente), müssen Sie eine Warnung anzeigen </li></ol><br><h2 id="ispolzuemye-tehnologii">  Verwendete Technologien </h2><br><p>  Hier hatte ich eine lange und schmerzhafte Wahl.  Einerseits besteht mein Hauptbereich darin, WebGL-Shader zu überprüfen. Warum also nicht Javascript, um während der Entwicklung alles im Browser auszuführen?  Andererseits habe ich schon lange vor, Phaser zu verlassen und eine andere Engine wie Unity oder LibGDX auszuprobieren.  Es wird auch Shader geben, aber Javascript wird weg sein. </p><br><p>  Und andererseits wurde die Aufgabe hauptsächlich zur Unterhaltung erledigt.  Und die beste Unterhaltung der Welt ist der Zoo.  Deshalb: </p><br><ol><li>  GLSL-Code-Analyse in Javascript.  Es ist nur so, dass ich ziemlich schnell die Bibliothek zum Parsen von GLSL in AST gefunden habe und die Test-Benutzeroberfläche vertrauter zu sein scheint als das Web.  AST wird zu einer Folge von Befehlen, die an ... </li><li>  ... der zweite Teil, der in C ++ geschrieben und in WebAssembly kompiliert ist.  Ich habe mich folgendermaßen entschieden: Wenn ich diesen Analysator plötzlich an einer anderen Engine befestigen möchte, sollte dies mit einer C ++ - Bibliothek am einfachsten erfolgen. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Ein paar Worte zum Toolkit</b> <div class="spoiler_text"><ul><li>  Ich habe Visual Studio Code als Haupt-IDE verwendet und bin im Allgemeinen damit zufrieden.  Ich brauche ein bisschen Glück - Hauptsache, Strg + Klick sollte funktionieren und beim Tippen automatisch vervollständigt werden.  Beide Funktionen funktionieren sowohl in C ++ als auch in JS einwandfrei.  Nun, die Fähigkeit, nicht verschiedene IDEs untereinander zu wechseln, ist ebenfalls großartig. </li><li>  Zum Kompilieren von C ++ verwendet WebAssembly das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cheerp-</a> Tool (es ist kostenpflichtig, aber für Open-Source-Projekte kostenlos).  Ich hatte keine Probleme mit seiner Verwendung, außer dass es den Code ziemlich seltsam optimierte, aber hier bin ich mir nicht sicher, wessen Fehler es ist - der Cheerp selbst oder der von ihm verwendete Clang-Compiler. </li><li>  für Unit-Tests in C ++ nahm der gute alte gtest </li><li>  Um js im Bündel zu bauen, brauchte man ein Mikrobundle.  Er erfüllte meine Anforderungen "Ich möchte 1 npm Paket und ein paar Kommandozeilenflags", aber gleichzeitig leider nicht ohne Probleme.  Angenommen, die Uhr stürzt bei einem Fehler ab, während eingehendes Javascript mit der Meldung <code>[Object object]</code> analysiert wird, was nicht viel hilft. </li></ul></div></div><br><p>  Alles, jetzt kannst du gehen. </p><br><h2 id="korotko-o-modeli">  Kurz zum Modell </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/hf/8s/chhf8sgclvkleyx_kwasvr74hz8.png"></div><br><p>  Der Analysator speichert eine Liste der im Shader gefundenen Variablen im Speicher und speichert für jede Variable den aktuell möglichen Wertebereich (z. B. <code>[0,1]</code> oder <code>[1,∞)</code> ). </p><br><p>  Der Analysator erhält einen Workflow wie folgt: </p><br><pre> <code class="hljs matlab">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> opCode: <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span> arguments: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,-,-,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,-,-]</code> </pre> <br><p>  Hier rufen wir die sin-Funktion auf, die Variablen mit id = 3 und 4 werden ihr zugeführt, und das Ergebnis wird in die Variablen 1 und 2 geschrieben. Dieser Aufruf entspricht dem GLSL-ten: </p><br><pre> <code class="hljs lisp">vec2 a = sin(<span class="hljs-name"><span class="hljs-name">b</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Beachten Sie die leeren Argumente (markiert als "-").  In GLSL sind fast alle integrierten Funktionen für verschiedene Sätze von Eingabetypen überladen, d. H.  Es gibt <code>sin(float)</code> , <code>sin(vec2)</code> , <code>sin(vec3)</code> , <code>sin(vec4)</code> .  Der <code>sin(vec4)</code> bringe ich alle überladenen Versionen in eine Form - in diesem Fall <code>sin(vec4)</code> . </p><br><p>  Der Analysator gibt eine Liste von Änderungen für jede Variable aus, wie z </p><br><pre> <code class="hljs vhdl">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> branchId: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>: [-<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Dies bedeutet, dass "die Variable 2 in Zeile 10 in Zweig 1 einen Bereich von -1 bis einschließlich 1 hat" (wir werden etwas später über Zweig sprechen).  Jetzt können Sie Wertebereiche im Quellcode wunderschön hervorheben. </p><br><h2 id="horoshee-nachalo">  Guter Start </h2><br><p>  Wenn der AST-Baum bereits zu einer Liste von Befehlen geworden ist, ist es an der Zeit, Standardfunktionen und -methoden zu implementieren.  Es gibt ziemlich viele von ihnen (und sie haben auch eine Reihe von Überlastungen, wie ich oben geschrieben habe), aber im Allgemeinen haben sie vorhersehbare Bereichstransformationen.  Nehmen wir an, für ein solches Beispiel ist alles ziemlich offensichtlich: </p><br><pre> <code class="hljs ruby">uniform float angle; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; (-∞,∞) /<span class="hljs-regexp"><span class="hljs-regexp">/... float y = sin(angle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [-1,1] float ynorm = 1 + y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [0,2] gl_FragColor.r = ynorm /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/aj/0f/vbaj0fdcx0nnk3lc2qti7egg7yq.png"></div><br><p>  Der rote Kanal der Ausgabefarbe liegt im akzeptablen Bereich, es liegen keine Fehler vor. </p><br><p>  Wenn Sie mehr integrierte Funktionen abdecken, reicht eine solche Analyse für die Hälfte der Shader aus.  Aber was ist mit der zweiten Hälfte - mit Bedingungen, Schleifen und Funktionen? </p><br><h2 id="vetvleniya">  Zweige </h2><br><p>  Nehmen Sie zum Beispiel einen solchen Shader. </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uSampler; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec2 uv; <span class="hljs-comment"><span class="hljs-comment">// [0,1] void main() { float a = texture2D(uSampler, uv).a; // -&gt; [0,1] float k; // -&gt; ? if (a &lt; 0.5) { k = a * 2.; } else { k = 1. - a; } gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Die Variable <code>a</code> wird aus der Textur entnommen, und daher liegt der Wert dieser Variablen zwischen 0 und 1. Aber welche Werte kann <code>k</code> annehmen? </p><br><p>  Sie können den einfachen Weg gehen und „die Zweige vereinen“ - berechnen Sie die Reichweite in jedem Fall und geben Sie die Summe aus.  Für den if-Zweig erhalten wir <code>k = [0,2]</code> und für den else-Zweig <code>k = [0,1]</code> .  Wenn Sie kombinieren, stellt sich heraus, dass <code>[0,2]</code> und Sie einen Fehler machen müssen, weil  Werte größer als 1 fallen in die Ausgabefarbe von <code>gl_FragColor</code> . </p><br><p>  Dies ist jedoch ein eindeutiger Fehlalarm, und für einen statischen Analysator gibt es nichts Schlimmeres als Fehlalarme - wenn er nicht nach dem ersten Schrei des "Wolfs" ausgeschaltet wird, dann sicher nach dem zehnten. </p><br><p>  Wir müssen also beide Zweige getrennt verarbeiten und in beiden Zweigen den Bereich der Variablen <code>a</code> klären (obwohl sie formal nicht geändert wurde).  So könnte es aussehen: </p><br><p>  Zweig 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0, 0.5) k = a * 2.; //k = [0, 1) gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Zweig 2: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0.5, 1] k = 1. - a; //k = [0, 0.5] gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Wenn der Analysator auf eine bestimmte Bedingung stößt, die sich je nach Bereich unterschiedlich verhält, werden für jeden Fall Verzweigungen (Brunchs) erstellt.  In jedem Fall verfeinert er den Bereich der Quellvariablen und bewegt sich weiter unten in der Befehlsliste. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/fp/dy/n7fpdy2xtg92oy5f0qsl7p8thz4.png"></div><br><p>  Es ist klarstellbar, dass die Zweige in diesem Fall nicht mit dem if-else-Konstrukt zusammenhängen.  Verzweigungen werden erstellt, wenn ein Bereich einer Variablen in Unterbereiche unterteilt ist. Die Ursache kann eine optionale bedingte Anweisung sein.  Beispielsweise erstellt die Schrittfunktion auch Zweige.  Der nächste GLSL-Shader macht dasselbe wie der vorherige, verwendet jedoch keine Verzweigung (was übrigens in Bezug auf die Leistung besser ist). </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> k = mix(a * <span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>. - a, step(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, a)); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>.) * k;</code> </pre> <br><p>  Die Schrittfunktion sollte 0 zurückgeben, wenn a &lt;0,5 und andernfalls 1.  Daher werden hier auch Zweige angelegt - ähnlich wie im vorherigen Beispiel. </p><br><h2 id="utochnenie-drugih-peremennyh">  Verfeinerung anderer Variablen </h2><br><p>  Betrachten Sie ein leicht modifiziertes vorheriges Beispiel: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-comment"><span class="hljs-comment">// -&gt; [0,1] float b = a - 0.5; // -&gt; [-0.5, 0.5] if (b &lt; 0.) { k = a * 2.; // k,a -&gt; ? } else { k = 1. - a; }</span></span></code> </pre> <br><p>  Hier ist die Nuance wie folgt: Verzweigung tritt in Bezug auf Variable <code>b</code> , und Berechnungen erfolgen in Bezug auf Variable <code>b</code> .  Das heißt, in jedem Zweig gibt es einen korrekten Wert des Bereichs <code>b</code> , der jedoch völlig unnötig ist, und den ursprünglichen Wert des Bereichs <code>a</code> ist völlig falsch. </p><br><p>  Der Analysator sah jedoch, dass der Bereich <code>b</code> durch Berechnen aus <code>a</code> .  Wenn Sie sich an diese Informationen erinnern, kann der Analysator beim Verzweigen alle Quellvariablen durchgehen und ihren Bereich durch Ausführen der inversen Berechnung verfeinern. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pi/lb/sz/pilbszwvjnellonuoosc_oux7wq.png"></div><br><h2 id="funkcii-i-cikly">  Funktionen und Schleifen </h2><br><p>  GLSL verfügt nicht über virtuelle Methoden, Funktionszeiger oder sogar rekursive Aufrufe, sodass jeder Funktionsaufruf eindeutig ist.  Daher ist es am einfachsten, den Funktionskörper am Ort des Aufrufs einzufügen (mit anderen Worten inline).  Dies stimmt vollständig mit der Reihenfolge der Befehle überein. </p><br><p>  Bei Zyklen ist es komplizierter, weil  Formal unterstützt GLSL die C-ähnliche for-Schleife vollständig.  In den meisten Fällen werden Schleifen jedoch in der einfachsten Form verwendet: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) {}</code> </pre> <br><p>  Solche Zyklen sind leicht "bereitzustellen", d.h.  Führen Sie den Körper der Schleife 12 Mal nacheinander ein.  Nachdem ich darüber nachgedacht hatte, entschied ich mich bisher, nur eine solche Option zu unterstützen. </p><br><p>  Der Vorteil dieses Ansatzes besteht darin, dass Befehle in einem Stream an den Analysator ausgegeben werden können, ohne dass Fragmente (wie Funktionskörper oder Schleifen) zur weiteren Wiederverwendung gespeichert werden müssen. </p><br><h2 id="vsplyvshie-problemy">  Pop-up-Probleme </h2><br><h3 id="problema-1-slozhnost-ili-nevozmozhnost-utochneniya">  Problem Nr. 1: Schwierigkeit oder Unfähigkeit zu klären </h3><br><p>  Oben haben wir Fälle untersucht, in denen wir beim Verfeinern der Werte einer Variablen Schlussfolgerungen über die Werte einer anderen Variablen gezogen haben.  Und dieses Problem wird gelöst, wenn Operationen wie Addition / Subtraktion beteiligt sind.  Aber was tun mit Trigonometrie?  Zum Beispiel eine solche Bedingung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) &gt; <span class="hljs-number"><span class="hljs-number">0.</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    a? }</span></span></code> </pre> <br><p>  Wie berechnet man die Reichweite <code>a</code> Innenraums, wenn?  Es stellt sich eine endlose Reihe von Bereichen mit pi-Schritten heraus, mit denen dann sehr unpraktisch gearbeitet werden kann. </p><br><p>  Und es kann eine solche Situation geben: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-comment"><span class="hljs-comment">// [-10,10] float b = getAnotherValue(); //[-20, 30] float k = a + b; if (k &gt; 0) { //a? b? }</span></span></code> </pre> <br><p>  Die Klärung der Bereiche <code>a</code> und <code>b</code> im allgemeinen Fall ist unrealistisch.  Und deshalb sind Fehlalarme möglich. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/z9/ea/7ez9eady082-nfgem7j0c65hslk.png"></div><br><h3 id="problema-2-zavisimye-diapazony">  Problem Nr. 2: Abhängige Bereiche </h3><br><p>  Betrachten Sie dieses Beispiel: </p><br><pre> <code class="hljs pgsql">uniform <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> //-&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-type"><span class="hljs-type">float</span></span> val2 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1.</span></span>; gl_FragColor = vec4(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - val2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/0m/jo/gh0mjodwd1oqeoh32mcdkollcyg.png"></div><br><p>  Zunächst berücksichtigt der Analysator den Bereich der Variablen <code>val2</code> - und es wird erwartet, dass er <code>[0,1] - 1 == [-1, 0]</code> beträgt. </p><br><p>  In <code>value - val2</code> des <code>value - val2</code> berücksichtigt der Analysator jedoch nicht, dass <code>val2</code> aus dem <code>value</code> , und arbeitet mit Bereichen, als ob sie unabhängig voneinander wären.  Ruft <code>[0,1] - [-1,0] = [0,2]</code> und meldet einen Fehler.  Obwohl er in Wirklichkeit eine Konstante 1 haben sollte. </p><br><p>  Mögliche Lösung: Speichern Sie für jede Variable nicht nur den Verlauf der Bereiche, sondern auch den gesamten „Stammbaum“ - von welchen Variablen abhängig war, von welchen Operationen usw.  Eine andere Sache ist, dass es nicht einfach sein wird, diesen Stammbaum zu „entfalten“. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/47/-_/qb/47-_qbz4nhcsbbfo_8wvtepll94.png"></div><br><h3 id="problema-3-diapazony-zavisimye-neyavno">  Problem Nr. 3: Implizit abhängige Bereiche </h3><br><p>  Hier ist ein Beispiel: </p><br><pre> <code class="hljs lisp">float k = sin(<span class="hljs-name"><span class="hljs-name">a</span></span>) + cos(<span class="hljs-name"><span class="hljs-name">a</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Hier nimmt der Analysator an, dass der Bereich <code>k = [-1,1] + [-1,1] = [-2,2]</code> .  Welches ist falsch, weil  <code>sin(a) + cos(a)</code> für jedes <code>a</code> liegt im Bereich <code>[-√2, √2]</code> . </p><br><p>  Das Ergebnis der formalen Berechnung von <code>sin(a)</code> hängt nicht vom Ergebnis der Berechnung von <code>cos(a)</code> .  Sie hängen jedoch vom gleichen Bereich von <code>a</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pf/wz/ne/pfwznek8x2iguen0bhyx0thwjuq.png"></div><br><h2 id="itogi-i-vyvody">  Zusammenfassung und Schlussfolgerungen </h2><br><p>  Wie sich herausstellte, ist es keine leichte Aufgabe, eine Wertebereichsanalyse auch für eine so einfache und hochspezialisierte Sprache wie GLSL durchzuführen.  Die Abdeckung von Sprachfunktionen kann noch verbessert werden: Die Unterstützung von Arrays, Matrizen und allen integrierten Operationen ist eine rein technische Aufgabe, die lediglich zeitaufwändig ist.  Aber wie man Situationen mit Abhängigkeiten zwischen Variablen löst - die Frage ist mir noch unklar.  Ohne diese Probleme zu lösen, sind Fehlalarme unvermeidlich, deren Rauschen letztendlich die Vorteile der statischen Analyse überwiegen kann. </p><br><p>  Angesichts dessen, was mir begegnet ist, wundert es mich nicht besonders, dass einige bekannte Tools für die Wertebereichsanalyse in anderen Sprachen fehlen - sie weisen eindeutig mehr Probleme auf als die relativ einfache GLSL.  Gleichzeitig können Sie mindestens Komponententests in anderen Sprachen schreiben, aber hier können Sie dies nicht tun. </p><br><p>  Eine alternative Lösung könnte das Kompilieren aus anderen Sprachen in GLSL sein - hier gab es kürzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel über das Kompilieren aus Kotlin</a> .  Anschließend können Sie Unit-Tests für den Quellcode schreiben und alle Randbedingungen abdecken.  Oder erstellen Sie einen „dynamischen Analysator“, der dieselben Daten ausführt, die über den ursprünglichen Kotlin-Code an den Shader gesendet werden, und vor möglichen Problemen warnt. </p><br><p>  Also hörte ich an diesem Punkt auf.  Die Bibliothek hat leider nicht funktioniert, aber vielleicht ist dieser Prototyp für jemanden nützlich. </p><br><p>  Repository auf Github, zur Überprüfung: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/AlexeyGrishin/glsl-value-range-analysis</a> </li></ul><br><p>  Um zu versuchen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://alexeygrishin.github.io/glsl-value-range-analysis/html/</a> </li></ul><br><h2 id="bonus-osobennosti-sborki-webassembly-s-raznymi-flagami-kompilyatora">  Bonus: Webassembly-Funktionen mit verschiedenen Compiler-Flags </h2><br><p>  Anfangs habe ich den Analysator ohne Verwendung von stdlib durchgeführt - auf altmodische Weise mit Arrays und Zeigern.  Zu dieser Zeit war ich sehr besorgt über die Größe der Ausgabe-Wasm-Datei, ich wollte, dass sie klein ist.  Aber ab einem bestimmten Zeitpunkt fühlte ich mich unwohl und beschloss daher, alles auf stdlib zu übertragen - intelligente Zeiger, normale Sammlungen, das ist alles. </p><br><p>  Dementsprechend hatte ich die Möglichkeit, die Ergebnisse der Zusammenstellung von zwei Versionen der Bibliothek zu vergleichen - mit und ohne stdlib.  Sehen Sie auch, wie guter / schlechter Cheerp (und das von ihm verwendete Klirren) den Code optimiert. </p><br><p>  Daher habe ich beide Versionen mit unterschiedlichen Sätzen von Optimierungsflags ( <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code> und <code>-Oz</code> ) <code>-Oz</code> und für einige dieser Versionen die Analysegeschwindigkeit von 3.000 Operationen mit 1.000 Zweigen gemessen.  Ich stimme zu, nicht das größte Beispiel, aber IMHO reicht für eine vergleichende Analyse. </p><br><p>  Was geschah je nach Größe der WASM-Datei: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qz/u9/sc/qzu9sc7tg2jdz7v5-zfbvceqkv8.png"></div><br><p>  Überraschenderweise ist die Größenoption mit der "Null" -Optimierung besser als fast alle anderen.  Ich gehe davon aus, dass es in <code>O3</code> eine aggressive Inline von allem auf der Welt gibt, die die Binärdatei aufbläst.  Die erwartete Version ohne stdlib ist kompakter, aber nicht so sehr <del>  solche Demütigung ertragen </del>  um sich der Freude zu berauben, mit praktischen Sammlungen zu arbeiten. </p><br><p>  Nach Ausführungsgeschwindigkeit: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w_/dc/hs/w_dchsujm7zdc4rvzjsaiwpzeme.png"></div><br><p>  Jetzt kann ich sehen, dass <code>-O3</code> im Vergleich zu <code>-O0</code> nicht umsonst sein Brot <code>-O0</code> .  Gleichzeitig fehlt der Unterschied zwischen Versionen mit und ohne stdlib praktisch (ich habe 10 Messungen durchgeführt, ich denke, bei einer größeren Zahl würde der Unterschied insgesamt verschwinden). </p><br><p>  Es ist erwähnenswert, 2 Punkte: </p><br><ul><li>  Das Diagramm zeigt die Durchschnittswerte aus 10 aufeinanderfolgenden Durchläufen der Analyse. In allen Tests dauerte die allererste Analyse jedoch zweimal länger als die übrigen (d. H. 120 ms, und die nächsten waren bereits etwa 60 ms).  Es gab wahrscheinlich eine Initialisierung von WebAssembly. </li><li>  Mit der <code>-O3</code> Flagge habe ich einige schrecklich seltsame Fehler entdeckt, die ich für andere Flaggen nicht gefunden habe.  Zum Beispiel begannen die Min- und Max-Funktionen plötzlich auf die gleiche Weise zu funktionieren - wie Min. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Vielen Dank für Ihre Aufmerksamkeit. <br>  Lassen Sie die Werte Ihrer Variablen niemals über die Grenzen hinausgehen. <br>  Und los geht's. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428027/">https://habr.com/ru/post/de428027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428011/index.html">Weltraum-Zombielieder</a></li>
<li><a href="../de428019/index.html">Spielen Sie Mortal Kombat mit TensorFlow.js</a></li>
<li><a href="../de428021/index.html">Dichtungen gegen das neuronale Netz. Oder wählen Sie ein neuronales Netzwerk aus und führen Sie es aus, um Objekte auf dem Raspberry Zero zu erkennen</a></li>
<li><a href="../de428023/index.html">Grundlagen der elektrischen Sicherheit bei der Konstruktion elektronischer Geräte</a></li>
<li><a href="../de428025/index.html">Anschließen einer Auslagerungsdatei (SWAP) in MAC OS X bei Verwendung einer externen SSD als System</a></li>
<li><a href="../de428029/index.html">Digitale Veranstaltungen in Moskau vom 29. Oktober bis 4. November</a></li>
<li><a href="../de428031/index.html">3CX-Integration mit 1C: Trade Management - eine Methode zum Kombinieren von Konfigurationen</a></li>
<li><a href="../de428033/index.html">In den USA legalisiertes Hacken von Smart-Geräten und Bordcomputern zum Zwecke der Reparatur und Aktualisierung</a></li>
<li><a href="../de428035/index.html">Red Hat wird von IBM übernommen</a></li>
<li><a href="../de428039/index.html">Die Regierung plant nicht, sich für die Netzneutralität einzusetzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>