<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥃 ⏺️ 🥃 多模型DBMS-现代信息系统的基础？ 👦 🧞 🚶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现代信息系统非常复杂。 最后但并非最不重要的一点是，它们的复杂性归因于其中处理的数据的复杂性。 数据的复杂性通常在于所使用的各种数据模型。 因此，例如，当数据变“大”时，不便特征之一不仅被视为其体积（“ volume”），还被视为其多样性（“ variety”）。 


 如果您仍然没有发现推理上的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>多模型DBMS-现代信息系统的基础？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462493/"><p> 现代信息系统非常复杂。 最后但并非最不重要的一点是，它们的复杂性归因于其中处理的数据的复杂性。 数据的复杂性通常在于所使用的各种数据模型。 因此，例如，当数据变“大”时，不便特征之一不仅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">被视为</a>其体积（“ volume”），还被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视为</a>其多样性（“ variety”）。 </p><br><p> 如果您仍然没有发现推理上的缺陷，请继续阅读。 </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/94/mx/d8/94mxd8qgj-3patv4bk_mwhbpwaq.jpeg" alt="5合1洗发水"></a> </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">文章内容</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多语言持久性</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多模型</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于关系模型的多模型DBMS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MS SQL Server中的文档模型</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MS SQL Server中的图形模型</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于文档模型的多模型DBMS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MarkLogic的关系模型</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MarkLogic中的图模型</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多模型DBMS“没有主模型”</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Arangodb</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">东方</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Azure CosmosDB</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于图模型的多模型DBMS？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">投票</a> </p></div></div><br><h2 id="polyglot-persistenceanchoranchor"> 多语言持久性 </h2><br><p> 前面的事实导致有时甚至在一个系统的框架内，也有必要使用几个不同的DBMS来存储数据并解决各种处理任务，每个任务都支持自己的数据模型。 在M. Fowler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（</a>许多著名书籍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的作者，也是《</a>敏捷宣言》的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合著者之一）的帮助下</a> ，这种情况被称为<em>多变量存储</em> （“多语言持久性”）。 </p><br><p>  Fowler还拥有以下在电子商务领域中功能齐全且负载较高的应用程序中组织数据存储的示例。 </p><br><p><img src="https://habrastorage.org/webt/01/kr/tj/01krtjyrneny1qg_luwiaycrhwe.png"></p><br><p> 当然，此示例有些夸张，但是例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> ，可以找到一些有利于出于相应目的选择一个或另一个DBMS的注意事项。 </p><br><p> 显然，在这样的动物园里当部长并不容易。 </p><br><ul><li> 执行数据存储的代码量与使用的DBMS数量成正比。 如果与该数字的平方不成比例，则用于同步数据的代码量就不错。 </li><li> 使用的DBMS数量的倍数增加了为每个使用的DBMS提供企业特征（可伸缩性，容错性，高可用性）的成本。 </li><li> 不可能提供整个存储子系统的企业特征-尤其是事务性的。 </li></ul><br><p> 从动物园负责人的角度来看，一切看起来像这样： </p><br><ul><li>  DBMS制造商的许可和技术支持成本成倍增加。 </li><li> 员工肿，交货时间更长。 </li><li> 由于数据不一致而造成的直接财务损失或罚款。 </li></ul><br><p> 系统的总拥有成本（TCO）大大增加。 有什么办法可以摆脱“多元存储”的局面吗？ </p><br><h2 id="multimodelnostanchoranchor"> 多模型 </h2><br><p>  “多元存储”一词于2011年开始使用。 意识到这种方法存在的问题以及寻找解决方案的过程花费了数年时间，到2015年，答案由Gartner分析师口中得出： </p><br><ul><li> 摘自“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NoSQL DBMS市场指南-2015</a> ”： <br><blockquote>  DBMS的未来，它们的体系结构和使用方法是多模型的。 <br></blockquote></li><li> 来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ODBMS 2016魔力象限</a> ： <br><blockquote> 领先的运营DBMS将在单个平台中提供多种模型-关系模型和非关系模型。 <br></blockquote></li></ul><br><p> 似乎这次Gartner的分析师并没有误解这一预测。 如果转到DB-Engines上具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主要</a> DBMS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评级</a>的页面，则可以看到其大多数领导者都将自己定位为多模型DBMS。 在具有任何私人评级的页面上也可以看到相同的内容。 </p><br><p> 下表显示了DBMS-每个私人评级中的领导者，宣布了其多模型。 对于每个DBMS，都会显示最初支持的模型（只有一个），并指出当前支持的模型。 根据创建者的说法，也有一些DBMS将自己定位为“初始多模型”，它们没有任何初始继承的模型。 </p><br><div class="scrollable-table"><table><thead><tr><th> 数据库管理系统 </th><th> 原始模型 </th><th> 附加型号 </th></tr></thead><tbody><tr><td> 甲骨文 </td><td> 关系型 </td><td> 图表，纪录片 </td></tr><tr><td>  MS SQL </td><td> 关系型 </td><td> 图表，纪录片 </td></tr><tr><td>  PostgreSQL的 </td><td> 关系型 </td><td> 图*，记录片 </td></tr><tr><td> 马克逻辑 </td><td> 纪录片 </td><td> 关系图 </td></tr><tr><td>  Mongodb </td><td> 纪录片 </td><td> 关键值，图表* </td></tr><tr><td> 数据税 </td><td> 宽列 </td><td> 纪录片，图表 </td></tr><tr><td> 雷迪斯 </td><td> 关键值 </td><td> 纪录片，图表* </td></tr><tr><td>  Arangodb </td><td>  -- </td><td> 图表，纪录片 </td></tr><tr><td> 东方 </td><td>  -- </td><td> 图表，纪录片 </td></tr><tr><td>  Azure CosmosDB </td><td>  -- </td><td> 图形，文件，关系 </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">表注</b> <div class="spoiler_text"><p> 表中的星号标记需要保留的语句： </p><br><ul><li>  PostgreSQL不支持图形数据模型，但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于它</a>的产品（例如AgensGraph）支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">它</a> 。 </li><li>对于MongoDB而言，更多地谈论查询语言中的图形运算符（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>$lookup</code></a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>$graphLookup</code></a> ）而不是对图形模型的支持，尽管当然，它们的引入需要在物理存储级别<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>$graphLookup</code></a>支持图形模型的方向进行一些优化。 </li><li> 对于Redis，这是指<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RedisGraph</a>扩展。 </li></ul></div></div><br><p> 此外，对于每个类，我们将展示该类如何实现DBMS中几个模型的支持。 我们将考虑最重要的关系，文档和图形模型，并通过特定DBMS的示例显示“缺失”是如何实现的。 </p><br><h2 id="multimodelnye-subd-na-osnove-relyacionnoy-modelianchoranchor"> 基于关系模型的多模型DBMS </h2><br><p> 领先的DBMS当前是关系型的；如果RDBMS未显示向多模型的方向移动，则不能认为Gartner预测是正确的。 他们展示了。 现在，多模型DBMS就像一把瑞士刀一样的想法，做得不好，可以立即发送给Larry Ellison。 </p><br><p> 但是，作者喜欢Microsoft SQL Server中的多模型实现，在该示例中将描述RDBMS对文档和图形模型的支持。 </p><br><h3 id="dokumentnaya-model-v-ms-sql-serveranchoranchor">  MS SQL Server中的文档模型 </h3><br><p> 关于MS SQL Server如何支持文档模型，有关Habré的文章已经有两篇了，我将只限于简短的重述和评论： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在SQL Server 2016中使用JSON</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL Server 2017 JSON</a> </li></ul><br><p> 对于关系型DBMS，在MS SQL Server中支持文档模型的方法非常典型：建议将JSON文档存储在纯文本字段中。 文档模型支持是为了提供特殊的运算符来解析此JSON： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>JSON_VALUE</code></a>检索标量属性值， </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>JSON_QUERY</code></a>以检索子文档。 </li></ul><br><p> 这两个运算符的第二个参数是类似JSONPath语法的表达式。 </p><br><p> 可以抽象地说，与元组不同，以这种方式存储的文档不是关系DBMS中的“一流实体”。 具体来说，MS SQL Server当前在JSON文档的字段上没有索引，这使得很难通过这些字段的值来联接表，甚至很难通过这些值来选择文档。 但是，可以在此字段中创建一个可计算列和一个索引。 </p><br><p> 另外，MS SQL Server提供了使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>FOR JSON PATH</code></a>语句从表的内容方便地构造JSON文档的功能，从某种意义上说，此功能与以前的普通存储相反。 显然，无论RDBMS有多快，这种方法都与文档DBMS的思想相矛盾，事实上，文档DBMS可以存储对流行查询的现成答案，并且只能解决易于开发的问题，而不能解决速度问题。 </p><br><p> 最后，MS SQL Server允许您解决问题，这与文档设计相反：您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>OPENJSON</code></a>将JSON分解为表。 如果文档不是完全平坦，则需要使用<code>CROSS APPLY</code> 。 </p><br><h3 id="grafovaya-model-v-ms-sql-serveranchoranchor">  MS SQL Server中的图形模型 </h3><br><p> 在Microsoft SQL Server中实现的图形（ <abbr>LPG</abbr> ）模型的支持也是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以预见的</a> ：建议使用特殊的表来存储节点和存储图边。 分别使用表达式<code>CREATE TABLE AS NODE</code>和<code>CREATE TABLE AS EDGE</code>创建此类表。 </p><br><p> 第一种类型的表类似于用于存储记录的普通表，唯一的不同是表包含系统字段<code>$node_id</code>数据库中唯一的图形节点标识符。 </p><br><p> 类似地，第二种类型的表具有系统字段<code>$from_id</code>和<code>$to_id</code> ，此类表中的记录清楚地定义了节点之间的关系。 单独的表用于存储每种类型的关系。 </p><br><p><img src="https://habrastorage.org/webt/ts/yx/yf/tsyxyfmueakjzmknlgaqxzkwx-o.png" align="right"> 我们举例说明。 让图形数据具有如图所示的方案。 然后，要在数据库中创建相应的结构，您需要执行以下DDL查询： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Person ( <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> NODE; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Cafe ( <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> NODE; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> likes ( rating <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> EDGE; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> friendOf <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> EDGE; <span class="hljs-comment"><span class="hljs-comment">/*   SQL Server 2019: ALTER TABLE likes ADD CONSTRAINT EC_LIKES CONNECTION (Person TO Cafe); */</span></span></code> </pre> <br><p> 此类表的主要特点是可以在查询中使用具有Cypher式语法的图形模式（但是尚不支持“ <code>*</code> ”等）。 另外，基于性能测量，可以假定在这些表中存储数据的方法与在普通表中存储数据的机制不同，并且可以优化为执行这种图形查询。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> Cafe.name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person, likes, Cafe <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCH</span></span> (Person-(friendOf)-(likes)-&gt;Cafe) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Person.name = <span class="hljs-string"><span class="hljs-string">'John'</span></span>;</code> </pre> <br><p> 此外，在处理此类表时不使用这些图形模式非常困难，因为在普通的SQL查询中，为了解决类似的问题，将需要<code>$node_id</code>更多的努力才能获得系统的“图形”节点标识符（ <code>$node_id</code> ， <code>$from_id</code> ， <code>$to_id</code> ；为此出于同样的原因，这里也不给出数据插入请求，因为它太麻烦了。 <br></p><br><p> 总结一下MS SQL Server中文档和图形模型的实现的描述，我会注意到，这种模型在另一模型之上的实现似乎主要在语言设计方面似乎并不成功。 需要将一种语言扩展为另一种语言，语言不是完全“正交”的，兼容性规则可能很奇怪。 </p><br><h2 id="multimodelnye-subd-na-osnove-dokumentnoy-modelianchoranchor"> 基于文档模型的多模型DBMS </h2><br><p> 在本节中，我将以不是最流行的MongoDB示例为例，说明文档DBMS中多模型的实现（正如所说的，它仅包含有条件的图运算符<code>$lookup</code>和<code>$graphLookup</code> ，它们不适用于分片集合），但是在该示例中，它更为成熟，并且“企业»DBMS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MarkLogic</a> 。 </p><br><p> 因此，让集合包含以下格式的XML文档集（MarkLogic也允许存储JSON文档）： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Person</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">INN</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"631803299804"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>John<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">surname</span></span></span><span class="hljs-tag">&gt;</span></span>Smith<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">surname</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Person</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3 id="relyacionnaya-model-v-marklogicanchoranchor">  MarkLogic的关系模型 </h3><br><p> 可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">显示模板</a>创建文档集合的关系表示（以下示例中的<code>value</code>元素的内容可以是任意XPath）： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://marklogic.com/xdmp/tde"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">context</span></span></span><span class="hljs-tag">&gt;</span></span>/Person<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">context</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rows</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">row</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view-name</span></span></span><span class="hljs-tag">&gt;</span></span>Person<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view-name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">columns</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>SSN<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>@SSN<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span>string<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>name<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>name<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>surname<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>surname<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">columns</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">row</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rows</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 可以将SQL查询寻址到创建的视图（例如，通过ODBC）： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, surname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>=<span class="hljs-string"><span class="hljs-string">"John"</span></span></code> </pre> <br><p> 不幸的是，使用显示模板创建的关系视图是只读的。 在处理请求时，MarkLogic将尝试使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档索引</a> 。 在MarkLogic中，过去只有有限的关系视图完全<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于索引</a>并且可写，但是现在认为它们已被弃用。 </p><br><h3 id="grafovaya-model-v-marklogicanchoranchor">  MarkLogic中的图模型 </h3><br><p> 有了图（ <abbr>RDF</abbr> ）模型支持，事情几乎是一样的。 同样，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">显示模板，</a>您可以从上面的示例创建文档集合的RDF表示形式： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://marklogic.com/xdmp/tde"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">context</span></span></span><span class="hljs-tag">&gt;</span></span>/Person<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">context</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vars</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>PREFIX<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">val</span></span></span><span class="hljs-tag">&gt;</span></span>"http://example.org/example#"<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">val</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vars</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">triples</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">triple</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">subject</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>sem:iri( $PREFIX || @SSN )<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">subject</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">predicate</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>sem:iri( $PREFIX || surname )<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">predicate</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">object</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>xs:string( surname )<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">object</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">triple</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">triple</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">subject</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>sem:iri( $PREFIX || @SSN )<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">subject</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">predicate</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>sem:iri( $PREFIX || name )<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">predicate</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">object</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>xs:string( name )<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">object</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">triple</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">triples</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 可以使用SPARQL查询来解决生成的RDF图： </p><br><pre> <code class="sql hljs">PREFIX : &lt;http://example.org/example<span class="hljs-comment"><span class="hljs-comment">#&gt; SELECT ?name ?surname { :631803299804 :name ?name ; :surname ?surname . }</span></span></code> </pre> <br><p> 与关系式不同，MarkLogic图模型以其他两种方式支持： </p><br><ol><li>  DBMS可以是RDF数据的完整独立存储库（与上面<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提取的摘录</a>相反，其中的三元组称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管</a> ）。 </li><li> 可以将特殊序列化的RDF轻松插入XML或JSON文档中（然后将三元组称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">unmanaged</a> ）。 这可能是<code>idref</code>机制等的替代方法。 </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Optic API</a>很好地说明了MarkLogic中所有内容如何“真正”起作用，尽管它的目的恰恰相反，但它的目的却是相反的-尝试从所使用的数据模型中抽象出来，以确保与不同模型，事务性和公关 </p><br><h2 id="multimodelnye-subd-bez-osnovnoy-modelianchoranchor"> 多模型DBMS“没有主模型” </h2><br><p>  DBMS也可以在市场上买到，将自己定位为最初的多模型，没有任何继承的基本模型。 其中包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ArangoDB</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OrientDB</a> （自2018年起，开发公司属于SAP）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CosmosDB</a> （Microsoft Azure云平台中包含的服务）。 </p><br><p> 实际上，ArangoDB和OrientDB中存在“基本”模型。 在这两种情况下，这些都是专有数据模型，是文档概括。 概括主要是为了促进产生图和关系查询的能力。 </p><br><p> 这些模型是唯一可用于指示的DBMS的模型；它们自己的查询语言旨在与它们一起使用。 当然，这样的模型和DBMS很有希望，但是与标准模型和语言的兼容性不足使得无法在遗留系统中使用这些DBMS-用它们已经使用的DBMS替换它们。 </p><br><p> 关于Habré上的ArangoDB和OrientDB，已经有一篇很棒的文章： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NoSQL数据库中的JOIN</a> 。 </p><br><h3 id="arangodbanchoranchor">  Arangodb </h3><br><p>  ArangoDB声称支持图形数据模型。 </p><br><p>  ArangoDB中的图节点是普通文档，边是特殊类型的文档，这些文档具有常见的系统字段（ <code>_key</code> ， <code>_id</code> ， <code>_rev</code> ）以及系统字段<code>_from</code>和<code>_to</code> 。 传统上，文档DBMS中的文档会合并到集合中。 表示边缘的文档集合在ArangoDB中称为边缘集合。 顺便说一下，边缘集合的文档也是文档，因此ArangoDB中的边缘也可以充当节点。 </p><br><div class="spoiler">  <b class="spoiler_title">源数据</b> <div class="spoiler_text"><p> 假设我们有一组<code>persons</code>其文档如下所示： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"people/alice"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alice"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"people/bob"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_key"</span></span> : <span class="hljs-string"><span class="hljs-string">"bob"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span> } ]</code> </pre> <br><p> 让我们也有<code>cafes</code>的集合： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"cafes/jd"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_key"</span></span> : <span class="hljs-string"><span class="hljs-string">"jd"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">" "</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"cafes/jj"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_key"</span></span> : <span class="hljs-string"><span class="hljs-string">"jj"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"-"</span></span> } ]</code> </pre> <br><p> 然后<code>likes</code>集合可能如下所示： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"likes/1"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_key"</span></span> : <span class="hljs-string"><span class="hljs-string">"1"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_from"</span></span> : <span class="hljs-string"><span class="hljs-string">"persons/alice"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_to"</span></span> : <span class="hljs-string"><span class="hljs-string">"cafes/jd"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"since"</span></span> : <span class="hljs-number"><span class="hljs-number">2010</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"likes/2"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_key"</span></span> : <span class="hljs-string"><span class="hljs-string">"2"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_from"</span></span> : <span class="hljs-string"><span class="hljs-string">"persons/alice"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_to"</span></span> : <span class="hljs-string"><span class="hljs-string">"cafes/jj"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"since"</span></span> : <span class="hljs-number"><span class="hljs-number">2011</span></span> } , { <span class="hljs-attr"><span class="hljs-attr">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"likes/3"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_key"</span></span> : <span class="hljs-string"><span class="hljs-string">"3"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_from"</span></span> : <span class="hljs-string"><span class="hljs-string">"persons/bob"</span></span> , <span class="hljs-attr"><span class="hljs-attr">"_to"</span></span> : <span class="hljs-string"><span class="hljs-string">"cafes/jd"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"since"</span></span> : <span class="hljs-number"><span class="hljs-number">2012</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">查询和结果</b> <div class="spoiler_text"><p>  ArangoDB中使用的AQL中的一种图形样式查询，以人类可读的形式返回有关谁喜欢哪个咖啡馆的信息，如下所示： </p><br><pre> <code class="plaintext hljs">FOR p IN persons FOR c IN OUTBOUND p likes RETURN { person : p.name , likes : c.name }</code> </pre> <br><p> 在一种关系样式中，当我们更有可能“计算”关系而不是存储它们时，可以按以下方式重写此查询（顺便说一句，您可以不用<code>likes</code>集合）： </p><br><pre> <code class="plaintext hljs">FOR p IN persons FOR l IN likes FILTER p._key == l._from FOR c IN cafes FILTER l._to == c._key RETURN { person : p.name , likes : c.name }</code> </pre> <br><p> 两种情况下的结果将相同： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"person"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span> , likes : <span class="hljs-string"><span class="hljs-string">"-"</span></span> } , { <span class="hljs-attr"><span class="hljs-attr">"person"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span> , likes : <span class="hljs-string"><span class="hljs-string">" "</span></span> } , { <span class="hljs-attr"><span class="hljs-attr">"person"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span> , likes : <span class="hljs-string"><span class="hljs-string">" "</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">更多查询和结果</b> <div class="spoiler_text"><p> 如果以上结果的格式似乎对于关系型DBMS比对文档型更为典型，则可以尝试以下查询（或者可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>COLLECT</code></a> ）： </p><br><pre> <code class="plaintext hljs">FOR p IN persons RETURN { person : p.name, likes : ( FOR c IN OUTBOUND p likes RETURN c.name ) }</code> </pre> <br><p> 结果如下： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"person"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span> , likes : [<span class="hljs-string"><span class="hljs-string">"-"</span></span> , <span class="hljs-string"><span class="hljs-string">" "</span></span>] } , { <span class="hljs-attr"><span class="hljs-attr">"person"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span> , likes : [<span class="hljs-string"><span class="hljs-string">" "</span></span>] } ]</code> </pre> </div></div><br><h3 id="orientdbanchoranchor"> 东方 </h3><br><p> 在OrientDB中，在文档模型之上的图形模型的实现基于文档字段具有或多或少的标准标量值之外还具有诸如<code>LINK</code> ， <code>LINKLIST</code> ， <code>LINKSET</code> ， <code>LINKMAP</code>和<code>LINKBAG</code>之类的类型的值的<code>LINKBAG</code> 。 这些类型的值是指向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系统</a>文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标识符的</a>链接或链接集合。 </p><br><p> 系统分配的文档标识符具有“物理意义”，指示记录在数据库中的位置，并且看起来像这样： <code>@rid : #3:16</code> 。 因此，引用属性的值实际上更可能是指针（如在图形模型中），而不是选择条件（如在关系模型中）。 </p><br><p> 与ArangoDB中一样，在OrientDB中，边表示为单独的文档（尽管如果边没有自己的属性，则可以将其设置为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">轻量级，</a>并且单独的文档将不与之对应）。 </p><br><div class="spoiler">  <b class="spoiler_title">源数据</b> <div class="spoiler_text"><p> 在接近OrientDB数据库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转储格式的格式中</a> ，来自上一个示例的ArangoDB的数据看起来像这样： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"@type"</span></span>: <span class="hljs-string"><span class="hljs-string">"document"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"#11:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@class"</span></span>: <span class="hljs-string"><span class="hljs-string">"Person"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"out_likes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"#30:1"</span></span>, <span class="hljs-string"><span class="hljs-string">"#30:2"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"@fieldTypes"</span></span>: <span class="hljs-string"><span class="hljs-string">"out_likes=LINKBAG"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"@type"</span></span>: <span class="hljs-string"><span class="hljs-string">"document"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"#12:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@class"</span></span>: <span class="hljs-string"><span class="hljs-string">"Person"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"out_likes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"#30:3"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"@fieldTypes"</span></span>: <span class="hljs-string"><span class="hljs-string">"out_likes=LINKBAG"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"@type"</span></span>: <span class="hljs-string"><span class="hljs-string">"document"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"#21:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@class"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cafe"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"-"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"in_likes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"#30:2"</span></span>, <span class="hljs-string"><span class="hljs-string">"#30:3"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"@fieldTypes"</span></span>: <span class="hljs-string"><span class="hljs-string">"in_likes=LINKBAG"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"@type"</span></span>: <span class="hljs-string"><span class="hljs-string">"document"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"#22:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@class"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cafe"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"in_likes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"#30:1"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"@fieldTypes"</span></span>: <span class="hljs-string"><span class="hljs-string">"in_likes=LINKBAG"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"@type"</span></span>: <span class="hljs-string"><span class="hljs-string">"document"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"#30:1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@class"</span></span>: <span class="hljs-string"><span class="hljs-string">"likes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"in"</span></span>: <span class="hljs-string"><span class="hljs-string">"#22:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"out"</span></span>: <span class="hljs-string"><span class="hljs-string">"#11:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"since"</span></span>: <span class="hljs-number"><span class="hljs-number">1262286000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@fieldTypes"</span></span>: <span class="hljs-string"><span class="hljs-string">"in=LINK,out=LINK,since=date"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"@type"</span></span>: <span class="hljs-string"><span class="hljs-string">"document"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"#30:2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@class"</span></span>: <span class="hljs-string"><span class="hljs-string">"likes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"in"</span></span>: <span class="hljs-string"><span class="hljs-string">"#21:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"out"</span></span>: <span class="hljs-string"><span class="hljs-string">"#11:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"since"</span></span>: <span class="hljs-number"><span class="hljs-number">1293822000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@fieldTypes"</span></span>: <span class="hljs-string"><span class="hljs-string">"in=LINK,out=LINK,since=date"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"@type"</span></span>: <span class="hljs-string"><span class="hljs-string">"document"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"#30:3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@class"</span></span>: <span class="hljs-string"><span class="hljs-string">"likes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"in"</span></span>: <span class="hljs-string"><span class="hljs-string">"#21:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"out"</span></span>: <span class="hljs-string"><span class="hljs-string">"#12:0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"since"</span></span>: <span class="hljs-number"><span class="hljs-number">1325354400000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@fieldTypes"</span></span>: <span class="hljs-string"><span class="hljs-string">"in=LINK,out=LINK,since=date"</span></span> } ]</code> </pre> <br><p> 如我们所见，顶点还存储有关传入和传出边缘的信息。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a> Document API时，您必须自己遵循参照完整性，而Graph API会注意这一点。 但是，让我们看看在未集成到编程语言和查询语言的“干净”状态下对OrientDB的调用是什么样的。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">查询和结果</b> <div class="spoiler_text"><p> 一个与OrientDB中的ArangoDB示例中的查询目的类似的查询如下所示： </p><br><pre> <code class="plaintext hljs">SELECT name AS person_name, OUT('likes').name AS cafe_name FROM Person UNWIND cafe_name</code> </pre> <br><p> 结果将获得如下： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"person_name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cafe_name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"person_name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cafe_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"-"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"person_name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cafe_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"-"</span></span> } ]</code> </pre> <br><p> 如果结果的格式再次显得过于“相关”，则需要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>UNWIND()</code></a>删除该行： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"person_name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cafe_name"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span> ] }, { <span class="hljs-attr"><span class="hljs-attr">"person_name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cafe_name"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"-"</span></span> ' } ]</code> </pre> <br><p>  OrientDB查询语言可以描述为带有类似Gremlin的插入的SQL。  2.2版引入了类似Cypher的请求表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MATCH</code></a> ： </p><br><pre> <code class="plaintext hljs">MATCH {CLASS: Person, AS: person}-likes-&gt;{CLASS: Cafe, AS: cafe} RETURN person.name AS person_name, LIST(cafe.name) AS cafe_name GROUP BY person_name</code> </pre> <br><p> 结果的格式将与上一个查询中的相同。 与第一个查询一样，请考虑需要删除哪些内容以使其更具“关系性”。 </p></div></div><br><h3 id="azure-cosmosdbanchoranchor">  Azure CosmosDB </h3><br><p> 在较小程度上，上述有关ArangoDB和OrientDB的内容指的是Azure CosmosDB。  CosmosDB提供以下数据访问API：SQL，MongoDB，Gremlin和Cassandra。 </p><br><p>  SQL API和MongoDB API用于访问文档模型中的数据。  Gremlin API和Cassandra API-分别用于访问图形和列中的数据。 所有模型中的数据均以CosmosDB内部模型： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ARS</a> （“ atom-record-sequence”）的格式保存，该模型也与文档之一很接近。 </p><br><p><img src="https://habrastorage.org/webt/8g/qw/ns/8gqwnsgawddcuvu4yi46--0bdk8.png"></p><br><p> 但是，在服务中创建帐户时，用户选择的数据模型和使用的API是固定的。 不可能以另一种模型的格式访问在一个模型中加载的数据，这将由以下示例说明： </p><br><p><img src="https://habrastorage.org/webt/lv/hx/lw/lvhxlwpyyu4aub0riqjp6h2lagq.png"></p><br><p> 因此，如今，Azure CosmosDB中的多模型只是使用支持同一制造商的不同模型的多个数据库的良机，这并不能解决多变量存储的所有问题。 </p><br><h2 id="multimodelnye-subd-na-osnove-grafovoy-modelianchoranchor"> 基于图模型的多模型DBMS？ </h2><br><p> 值得注意的是，市场上没有基于图形模型的多模型DBMS（除了同时支持两个图形模型（RDF和LPG）的多模型支持，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先前的出版物</a> ）。 最大的困难是在文档图形模型之上的实现，而不是关系的实现。 </p><br><p> 即使在图形模型形成时，也考虑过如何在图形模型上实现关系模型的问题。 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">David McGovern</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所说</a> ，例如： </p><br><blockquote> 图方法没有内在的东西可以阻止在图数据库上创建一个层（例如，通过适当的索引），该层可以实现以下关系视图：（1）从常规键值对中恢复元组，以及（2）通过关系类型。 </blockquote><p> 在图的顶部实现文档模型时，请记住以下几点： </p><br><ul><li>  JSON数组的元素被认为是有序的，来自图边缘的顶部-否； </li><li> 文档模型中的数据通常是非规范化的，您仍然不希望存储同一附件文档的多个副本，并且子文档通常没有标识符。 </li><li> 另一方面，文档DBMS的思想是文档是现成的“单元”，不需要每次都重新构建。 需要在图模型中提供快速获得与完成文档相对应的子图的能力。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">一些广告</b> <div class="spoiler_text"><p> 本文的作者与NitrosBase DBMS的开发有关，该数据库的内部模型是图形的，而外部模型（关系和文档）是其表示。 所有模型都是平等的：使用自然的查询语言，几乎任何数据都可用。 而且，以任何表示形式，数据都可能发生变化。 更改将反映在内部模型中，并因此反映在其他表示中。 </p><br><p>  NitrosBase中的模型匹配是什么样子-希望在以下文章之一中进行描述。 </p></div></div><br><h1 id="zaklyuchenieanchoranchor"> 结论 </h1><br><p> 我希望对读者来说，所谓的“多模型化”的总体轮廓或多或少变得清晰。 完全不同的DBMS被称为多模型，并且“对多个模型的支持”看起来可能有所不同。 要了解每种情况下的“多模型”，回答以下问题很有用： </p><br><ol><li> 是支持传统模型还是单个混合模型？ </li><li> 模型是“相等的”还是其中一个受其他模型约束？ </li><li> 模型是否彼此“无动于衷”？ 可以将一种模型中记录的数据以另一种模型读取甚至覆盖吗？ </li></ol><br><p> 我认为已经有可能对多模型DBMS的相关性问题做出肯定的回答，但是有趣的问题是，在不久的将来，哪种类型的DBMS会有更多需求。 似乎支持传统模型（主要是关系模型）的多模型DBMS的需求将越来越大。    ,   ,      , —    . </p><br><h2 id="anchoranchorhr"><hr></h2></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462493/">https://habr.com/ru/post/zh-CN462493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462481/index.html">类型系统常见问题</a></li>
<li><a href="../zh-CN462483/index.html">功能编程：一种古怪的玩具，会降低劳动生产率。 第一部分</a></li>
<li><a href="../zh-CN462485/index.html">功能编程：一种古怪的玩具，会降低劳动生产率。 第二部分</a></li>
<li><a href="../zh-CN462487/index.html">Cython：超过30倍的Python代码加速</a></li>
<li><a href="../zh-CN462489/index.html">上周第374期（2019年7月29日至8月4日）前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN462495/index.html">8月5日至11日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN462501/index.html">为什么我需要自己的证书颁发机构</a></li>
<li><a href="../zh-CN462503/index.html">监视和SRE的“黄金信号”是什么？</a></li>
<li><a href="../zh-CN462505/index.html">不要骗我函数式编程</a></li>
<li><a href="../zh-CN462507/index.html">邮件传递时：与iOS中的推送通知丢失作斗争</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>