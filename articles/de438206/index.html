<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∑ üà≤ üèí 26 Empfehlungen f√ºr die Verwendung des var-Typs in Java üë©‚Äçüî¨ üòå üö®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Java Local Variable Type Inference (LVTI) oder kurz der Var- Typ (der Var- Bezeichner ist kein Schl√ºsselwort, sondern ein reservierter Typname) wu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>26 Empfehlungen f√ºr die Verwendung des var-Typs in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438206/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/mq/zq/0cmqzquxmzrie0s3ryftj5dqvga.png"></div><br><p>  <strong>Die Java Local Variable Type Inference (LVTI)</strong> oder kurz der <strong>Var-</strong> Typ (der <strong>Var-</strong> Bezeichner ist kein Schl√ºsselwort, sondern ein reservierter <strong>Typname)</strong> wurde Java 10 mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 286: Local-Variable Type Inference</a> hinzugef√ºgt.  Da es sich um eine 100% ige Compilerfunktion handelt, hat dies keinen Einfluss auf Bytecode, Laufzeit oder Leistung.  Grunds√§tzlich √ºberpr√ºft der Compiler die rechte Seite des Zuweisungsoperators und ermittelt darauf basierend den spezifischen Typ der Variablen und ersetzt ihn dann durch <strong>var</strong> . </p><br><p> Dar√ºber hinaus ist es n√ºtzlich, um die Ausf√ºhrlichkeit von Boilerplate-Code zu reduzieren und den Programmierprozess selbst zu beschleunigen.  Zum Beispiel ist es sehr praktisch, <strong><code>var evenAndOdd =...</code></strong> anstelle von <strong><code>Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd =...</code></strong> zu schreiben <strong><code>Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd =...</code></strong> </p><br><p>  Das Aussehen von <strong>var</strong> bedeutet nicht, dass es immer und bequem ist, es √ºberall zu verwenden. Manchmal ist es praktischer, mit Standardwerkzeugen zu arbeiten. </p><br><p>  In diesem Artikel werden 26 Situationen betrachtet, mit Beispielen, wann Sie <strong>var verwenden</strong> k√∂nnen und wann es sich nicht lohnt. </p><a name="habracut"></a><br><h2 id="punkt-1-staraytes-davat-osmyslennye-imena-lokalnym-peremennym">  Punkt 1: Versuchen Sie, lokalen Variablen aussagekr√§ftige Namen zu geben </h2><br><p>  Normalerweise konzentrieren wir uns darauf, den Feldern der Klassen die richtigen Namen zu geben, aber wir widmen den Namen lokaler Variablen nicht die gleiche Aufmerksamkeit.  Wenn unsere Methoden perfekt implementiert sind, wenig Code enthalten und gute Namen haben, achten wir sehr oft nicht auf lokale Variablen oder reduzieren ihre Namen sogar vollst√§ndig. </p><br><p>  Wenn wir <strong>var verwenden,</strong> anstatt explizite Typen zu schreiben, erkennt der Compiler diese automatisch und ersetzt <strong>var</strong> .  Andererseits wird es dadurch f√ºr die Menschen schwieriger, den Code zu lesen und zu verstehen, da die Verwendung von <strong>var</strong> seine Lesbarkeit und sein Verst√§ndnis erschweren kann.  In den meisten F√§llen liegt dies daran, dass wir den Typ einer Variablen als prim√§re Information und ihren Namen als sekund√§re betrachten.  Obwohl es genau das Gegenteil sein sollte. </p><br><h3 id="primer-1">  Beispiel 1: </h3><br><p>  Viele werden wahrscheinlich zustimmen, dass im folgenden Beispiel die Namen lokaler Variablen zu kurz sind: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// HAVING public boolean callDocumentationTask() { DocumentationTool dtl = ToolProvider.getSystemDocumentationTool(); DocumentationTask dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Bei Verwendung von Kurznamen zusammen mit <strong>var</strong> wird der Code noch weniger klar: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public boolean callDocumentationTask() { var dtl = ToolProvider.getSystemDocumentationTool(); var dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Bevorzugtere Option: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public boolean callDocumentationTask() { var documentationTool = ToolProvider.getSystemDocumentationTool(); var documentationTask = documentationTool.getTask(...); return documentationTask.call(); }</span></span></code> </pre> <br><h3 id="primer-2">  Beispiel 2: </h3><br><p>  Vermeiden Sie es, Variablen wie folgt zu benennen: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public List&lt;Product&gt; fetchProducts(long userId) { var u = userRepository.findById(userId); var p = u.getCart(); return p; }</span></span></code> </pre> <br><p>  Verwenden Sie aussagekr√§ftigere Namen: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public List&lt;Product&gt; fetchProducts(long userId) { var user = userRepository.findById(userId); var productList = user.getCart(); return productList; }</span></span></code> </pre> <br><h3 id="primer-3">  Beispiel 3: </h3><br><p>  Gehen Sie nicht zu Extremen, um lokalen Variablen verst√§ndlichere Namen zu geben: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteArrayOutputStream = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  Stattdessen k√∂nnen Sie eine k√ºrzere, aber nicht weniger verst√§ndliche Option verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var outputStream = new ByteArrayOutputStream(); // or var outputStreamOfFoo = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  Wussten Sie, dass Java eine innere Klasse namens hat? <br>  <strong>InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonWindowNotFocusedState</strong> </p><br><p>  Das Benennen von Variablen mit diesem Typ kann schwierig sein :) </p><br><h2 id="punkt-2-ispolzuyte-literaly-chtoby-pomoch-var-tochno-opredelit-tip-primitiva-int-long-float-double">  Punkt 2: Verwenden Sie Literale, um var dabei zu helfen, den Typ des Grundelements zu bestimmen (int, long, float, double). </h2><br><p>  Ohne die Verwendung von Literalen f√ºr primitive Typen k√∂nnen wir feststellen, dass erwartete und implizite Typen unterschiedlich sein k√∂nnen.  Dies wird durch die implizite Typkonvertierung verursacht, die von <strong>var-</strong> Variablen verwendet wird. </p><br><p>  Beispielsweise verhalten sich die folgenden zwei Codefragmente wie erwartet.  Hier deklarieren wir explizit die Typen <strong>Boolean</strong> und <strong>Char</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type boolean char a = 'a'; // this is of type char</span></span></code> </pre> <br><p>  Jetzt verwenden wir <strong>var</strong> , anstatt explizit Typen zu deklarieren: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is inferred as boolean var a = 'a'; // this is inferred as char</span></span></code> </pre> <br><p>  So weit so gut.  Machen Sie jetzt dasselbe f√ºr die Typen <strong>int</strong> , <strong>long</strong> , <strong>float</strong> und <strong>double</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> intNumber = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type int long longNumber = 20; // this is of type long float floatNumber = 20; // this is of type float, 20.0 double doubleNumber = 20; // this is of type double, 20.0</span></span></code> </pre> <br><p>  Obwohl das obige Code-Snippet einfach und unkompliziert ist, verwenden wir jetzt <strong>var,</strong> anstatt explizit Typen anzugeben. </p><br><p>  Vermeiden Sie: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var intNumber = 20; // this is inferred as int var longNumber = 20; // this is inferred as int var floatNumber = 20; // this is inferred as int var doubleNumber = 20; // this is inferred as int</span></span></code> </pre> <br><p>  Alle vier Variablen werden als <strong>int</strong> ausgegeben.  Um dieses Verhalten zu beheben, m√ºssen wir Java-Literale verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var intNumber = 20; // this is inferred as int var longNumber = 20L; // this is inferred as long var floatNumber = 20F; // this is inferred as float, 20.0 var doubleNumber = 20D; // this is inferred as double, 20.0</span></span></code> </pre> <br><p>  Aber was passiert, wenn wir eine Dezimalzahl deklarieren? </p><br><p>  Vermeiden Sie dies, wenn Sie eine Variable vom Typ <strong>float</strong> erwarten: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID, IF THIS IS A FLOAT var floatNumber = 20.5; // this is inferred as double</span></span></code> </pre> <br><p>  Verwenden Sie das entsprechende Literal, um √úberraschungen zu vermeiden: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER, IF THIS IS A FLOAT var floatNumber = 20.5F; // this is inferred as float</span></span></code> </pre> <br><h2 id="punkt-3-v-nekotoryh-sluchayah-var-i-neyavnye-privedeniya-tipov-mogut-uprostit-podderzhku-koda">  Punkt 3: In einigen F√§llen k√∂nnen var- und implizite Typkonvertierungen die Codeunterst√ºtzung vereinfachen </h2><br><p>  Nehmen wir zum Beispiel an, dass unser Code zwischen zwei Methoden liegt.  Eine Methode erh√§lt einen Einkaufswagen mit verschiedenen Produkten und berechnet den besten Preis.  Dazu vergleicht er verschiedene Marktpreise und gibt den Gesamtpreis in Form eines <strong>Float-</strong> Typs zur√ºck.  Eine andere Methode zieht diesen Preis einfach von der Karte ab. </p><br><p>  Schauen wir uns zun√§chst eine Methode an, mit der der beste Preis berechnet wird: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> price = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre> <br><p>  Zweitens werfen wir einen Blick auf die Methode, die mit der Karte funktioniert: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Jetzt setzen wir unseren Code als Client zwischen diese beiden externen Servicemethoden.  Unsere Benutzer k√∂nnen die zu kaufenden Waren ausw√§hlen und wir berechnen den besten Preis f√ºr sie und schreiben dann das Geld von der Karte ab: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public void purchaseCart(long customerId) { ... float price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><p>  Nach einiger Zeit beschlie√üt das Unternehmen, dem die API geh√∂rt, die wesentliche Darstellung der Preise zugunsten der Dezimalstelle aufzugeben (anstelle von <strong>float</strong> wird jetzt <strong>int</strong> verwendet).  Daher haben sie den API-Code wie folgt ge√§ndert: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> realprice = ...; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> price = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) realprice; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Tatsache ist, dass unser Code eine explizite Deklaration einer <strong>Float-</strong> Variablen als Preis verwendet.  In der aktuellen Form erhalten wir beim Kompilieren einen Fehler.  Wenn wir jedoch eine solche Situation vorausgesehen und <strong>var</strong> anstelle von <strong>float verwendet h√§tten</strong> , w√ºrde unser Code dank der impliziten Typkonvertierung ohne Probleme weiter funktionieren: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public void purchaseCart(long customerId) { ... var price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><h2 id="punkt-4-kogda-literaly-ne-yavlyayutsya-podhodyaschim-resheniem-to-ispolzuyte-yavnoe-privedenie-tipov-ili-otkazhites-ot-var">  Punkt 4: Wenn Literale keine geeignete L√∂sung sind, verwenden Sie explizites Casting oder verwerfen Sie var </h2><br><p>  Einige primitive Typen in Java haben keine speziellen Literale, z. B. <strong>Byte-</strong> und Kurztypen.  In diesem Fall k√∂nnen wir mithilfe der expliziten Typbezeichnung problemlos Variablen erstellen. </p><br><p>  Verwenden Sie dies anstelle von <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS INSTEAD OF USING VAR byte byteNumber = 45; // this is of type byte short shortNumber = 4533; // this is of type short</span></span></code> </pre> <br><p>  Aber warum bevorzugen Sie in dieser Situation die explizite Typennotation, anstatt nur <strong>var zu verwenden</strong> ?  Nun, schreiben wir diesen Code mit <strong>var</strong> .  Beachten Sie, dass der Compiler in beiden F√§llen davon ausgeht, dass Sie Variablen vom Typ <strong>int</strong> ben√∂tigen. </p><br><p>  Vermeiden Sie diesen Fehler: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteNumber = 45; // this is inferred as int var shortNumber = 4533; // this is inferred as int</span></span></code> </pre> <br><p>  Es gibt hier keine Literale, die uns helfen k√∂nnten, daher sind wir gezwungen, eine explizite Abw√§rtskonvertierung zu verwenden.  Pers√∂nlich werde ich solche Situationen vermeiden, da ich hier keine Vorteile sehe. </p><br><p>  Verwenden Sie diesen Eintrag nur, wenn Sie <strong>var</strong> wirklich verwenden m√∂chten: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS ONLY IF YOU WANT TO USE VAR var byteNumber = (byte) 45; // this is inferred as byte var shortNumber = (short) 4533; // this is inferred as short</span></span></code> </pre> <br><h2 id="punkt-5-izbegayte-ispolzovaniya-var-esli-nazvaniya-peremennyh-ne-soderzhat-dostatochnoy-informacii-o-tipe-dlya-ponimaniya-koda">  Punkt 5: Vermeiden Sie die Verwendung von var, wenn Variablennamen nicht gen√ºgend Typinformationen enthalten, um den Code zu verstehen </h2><br><p>  Der Vorteil der Verwendung von <strong>var</strong> besteht darin, pr√§ziseren Code zu schreiben.  Im Fall der Verwendung von Konstruktoren k√∂nnen wir beispielsweise vermeiden, dass der Klassenname wiederholt werden muss, und daher die Code-Redundanz beseitigen. </p><br><p>  Vermeiden Sie Folgendes: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID MemoryCacheImageInputStream inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  Verwenden Sie stattdessen: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  F√ºr die folgende Konstruktion ist <strong>var</strong> auch eine gute M√∂glichkeit, den Code zu vereinfachen, ohne Informationen zu verlieren. </p><br><p>  Vermeiden Sie: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fm = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Verwenden Sie den folgenden Code: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var compiler = ToolProvider.getSystemJavaCompiler(); var fileManager = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Warum arbeiten wir in den vorgestellten Beispielen besser mit <strong>var</strong> ?  Weil alle notwendigen Informationen in den Namen der Variablen enthalten sind.  Wenn <strong>var jedoch</strong> in Kombination mit einem Variablennamen die Klarheit des Codes verringert, ist es besser, die Verwendung abzulehnen. </p><br><p>  Vermeiden Sie: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public File fetchCartContent() { return new File(...); } // As a human, is hard to infer the "cart" type without // inspecting the fetchCartContent() method var cart = fetchCartContent();</span></span></code> </pre> <br><p>  Verwendung: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public File fetchCartContent() { return new File(...); } File cart = fetchCartContent();</span></span></code> </pre> <br><p>  Betrachten Sie beispielsweise die Verwendung der Klasse <strong><code>java.nio.channels.Selector</code></strong> .  Diese Klasse verf√ºgt √ºber eine statische <strong><code>open()</code></strong> -Methode, die einen neuen Selector zur√ºckgibt und ihn √∂ffnet.  Aber hier k√∂nnen Sie leicht denken, dass die <strong><code>Selector.open()</code></strong> -Methode einen <strong>booleschen</strong> Typ zur√ºckgeben kann, abh√§ngig vom Erfolg beim √ñffnen eines vorhandenen Selektors, oder sogar <strong>void zur√ºckgeben kann</strong> .  Die Verwendung von <strong>var f√ºhrt</strong> hier zu Informationsverlust und Verwirrung im Code. </p><br><h2 id="punkt-6-tip-var-garantiruet-bezopasnost-vo-vremya-kompilyacii">  Punkt 6: var type garantiert die Sicherheit bei der Kompilierung </h2><br><p>  Dies bedeutet, dass wir keine Anwendung kompilieren k√∂nnen, die versucht, falsche Zuweisungen auszuf√ºhren.  Der folgende Code wird beispielsweise nicht kompiliert: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var items = 10; items = "10 items"; // incompatible types: String cannot be converted to int</span></span></code> </pre> <br><p>  Aber dieser kompiliert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-number"><span class="hljs-number">10</span></span>; items = <span class="hljs-number"><span class="hljs-number">20</span></span>;</code> </pre> <br><p>  Und dieser Code wird erfolgreich kompiliert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-string"><span class="hljs-string">"10"</span></span>; items = <span class="hljs-string"><span class="hljs-string">"10 items"</span></span>;</code> </pre> <br><p>  Sobald der Compiler den Wert der Variablen <strong>var</strong> definiert hat, k√∂nnen wir nichts anderes als diesen Typ zuweisen. </p><br><h2 id="punkt-7-var-ne-mozhet-ispolzovatsya-dlya-sozdaniya-ekzemplyara-konkretnogo-tipa-i-naznacheniya-ego-peremennoy-tipa-interfeysa">  Punkt 7: var kann nicht verwendet werden, um einen bestimmten Typ zu instanziieren und ihn einer Schnittstellentypvariablen zuzuweisen </h2><br><p>  In Java verwenden wir den Ansatz "Programmieren mit Schnittstellen".  Zum Beispiel erstellen wir eine Instanz der ArrayList-Klasse und ordnen sie einer Abstraktion (Schnittstelle) zu: </p><br><pre> <code class="java hljs">List&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  Und wir vermeiden Dinge wie das Binden eines Objekts an eine Variable des gleichen Typs: </p><br><pre> <code class="java hljs">ArrayList&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  Dies ist die h√§ufigste und w√ºnschenswerteste Vorgehensweise, da wir die Schnittstellenimplementierung problemlos durch eine andere ersetzen k√∂nnen.  Dazu muss nur eine Schnittstellentypvariable deklariert werden. </p><br><p>  Wir werden diesem Konzept nicht folgen k√∂nnen, wenn wir var-Variablen verwenden, as  F√ºr sie wird immer ein bestimmter Typ angezeigt.  Im folgenden Codeausschnitt bestimmt der Compiler beispielsweise den Typ der Variablen als <strong><code>ArrayList&lt;String&gt;</code></strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  Es gibt mehrere Verteidigungsargumente, die dieses Verhalten erkl√§ren: </p><br><ul><li><p>  <strong>var wird</strong> f√ºr lokale Variablen verwendet, wobei in den meisten F√§llen die Programmierung √ºber Schnittstellen weniger verwendet wird als in F√§llen mit Methodenparametern, die von Werten oder Feldern zur√ºckgegeben werden </p><br></li><li><p>  Der Umfang lokaler Variablen sollte klein sein, daher sollte die L√∂sung von Problemen, die durch den Wechsel zu einer anderen Implementierung verursacht werden, nicht sehr schwierig sein </p><br></li><li><p>  <strong>var</strong> behandelt den Code auf der rechten Seite als Initialisierer, mit dem der tats√§chliche Typ bestimmt wird.  Wenn irgendwann der Initialisierer ge√§ndert wird, kann sich auch der zu definierende Typ √§ndern, was zu Problemen im Code f√ºhrt, der auf dieser Variablen beruht. </p><br></li></ul><br><h2 id="punkt-8-veroyatnost-vyvoda-neozhidaemogo-tipa">  Absatz 8: Die Wahrscheinlichkeit des Abschlusses eines unerwarteten Typs </h2><br><p>  Die Verwendung von var in Kombination mit einem <strong>Diamantoperator</strong> (&lt;&gt;) ohne Informationen zur Identifizierung des Typs kann zu unerwarteten Ergebnissen f√ºhren. </p><br><p>  Vor Java 7 wurde f√ºr Sammlungen eine explizite Typinferenz verwendet: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicitly specifying generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;String&gt;();</span></span></code> </pre> <br><p>  Beginnend mit Java 7 wurde der <strong>Diamantoperator</strong> eingef√ºhrt.  In diesem Fall leitet der Compiler unabh√§ngig den erforderlichen Typ ab: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferring generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;&gt;();</span></span></code> </pre> <br><p>  Welcher Typ wird im folgenden Code ausgegeben? </p><br><p>  Sie sollten solche Konstruktionen vermeiden: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var productList = new ArrayList&lt;&gt;(); // is inferred as ArrayList&lt;Object&gt;</span></span></code> </pre> <br><p>  Der Typ wird als <strong><code>ArrayList&lt;Object&gt;</code></strong> .  Dies liegt daran, dass die zur korrekten Bestimmung des Typs erforderlichen Informationen nicht bereitgestellt werden.  Dies f√ºhrt dazu, dass der n√§chstgelegene Typ ausgew√§hlt wird, der mit dem Kontext des Geschehens kompatibel sein kann.  In diesem Fall <strong><code>Object</code></strong> . </p><br><p>  Daher kann <strong>var</strong> nur verwendet werden, wenn wir die erforderlichen Informationen zur Bestimmung des erwarteten Typs bereitstellen.  Der Typ kann direkt angegeben oder als Argument √ºbergeben werden. </p><br><p>  Geben Sie direkt den Typ an: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var productList = new ArrayList&lt;String&gt;(); // inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  √úbergeben Sie Argumente des erforderlichen Typs: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;String&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(productStack); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><pre> <code class="java hljs">Product p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); Product p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listOfProduct = List.of(p1, p2); <span class="hljs-comment"><span class="hljs-comment">// inferred as List&lt;Product&gt; // DON'T DO THIS var listofProduct = List.of(); // inferred as List&lt;Object&gt; listofProduct.add(p1); listofProduct.add(p2);</span></span></code> </pre> <br><h2 id="punkt-9-prisvoenie-massiva-k-var-peremennoy-ne-trebuet-skobok--">  Punkt 9: Das Zuweisen eines Arrays zu einer var-Variablen erfordert keine Klammern [] </h2><br><p>  Wir alle wissen, wie man Arrays in Java deklariert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// or, less preferred int numbers[] = new int[5];</span></span></code> </pre> <br><p>  Wie w√§re es mit <strong>var</strong> bei der Arbeit mit Arrays?  In diesem Fall m√ºssen keine Klammern auf der linken Seite verwendet werden. </p><br><p>  Vermeiden Sie Folgendes (dies wird nicht einmal kompiliert): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var[] numbers = new int[5]; // or var numbers[] = new int[5];</span></span></code> </pre> <br><p>  Verwendung: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var numbers = new int[5]; // inferred as array of int numbers[0] = 2; // work numbers[0] = 2.2; // doesn't work numbers[0] = "2"; // doesn't work</span></span></code> </pre> <br><p>  Der folgende Code mit <strong>var kann</strong> ebenfalls nicht kompiliert werden.  Dies liegt daran, dass der Compiler den Typ nicht von der rechten Seite bestimmen kann: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type work as expected int[] numbers = {1, 2, 3}; // IT DOESN'T COMPILE var numbers = {1, 2, 3}; var numbers[] = {1, 2, 3}; var[] numbers = {1, 2, 3};</span></span></code> </pre> <br><h2 id="punkt-10-var-nelzya-ispolzovat-pri-obyavlenii-neskolkih-peremennyh-v-odnoy-stroke">  Punkt 10: var kann nicht verwendet werden, wenn mehrere Variablen in derselben Zeile deklariert werden </h2><br><p>  Wenn Sie Variablen desselben Typs gleichzeitig deklarieren m√∂chten, m√ºssen Sie wissen, dass <strong>var daf√ºr</strong> nicht geeignet ist.  Der folgende Code wird nicht kompiliert: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: 'var' is not allowed in a compound declaration var hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  Verwenden Sie stattdessen: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  Oder ist es: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var hello = "hello"; var bye = "bye"; var welcome = "welcome";</span></span></code> </pre> <br><h2 id="punkt-11-lokalnye-peremennye-dolzhny-stremitsya-k-minimizacii-svoey-oblasti-vidimosti-tip-var-usilivaet-eto-utverzhdenie">  Punkt 11: Lokale Variablen sollten sich bem√ºhen, ihren Umfang zu minimieren.  Der var-Typ verst√§rkt diese Aussage. </h2><br><p>  Halten Sie einen kleinen Bereich f√ºr lokale Variablen ein - ich bin sicher, Sie haben diese Anweisung vor <strong>var geh√∂rt</strong> . </p><br><p>  Lesbarkeit und schnelle Fehlerbehebungen sprechen f√ºr diesen Ansatz.  Definieren wir beispielsweise einen Stapel wie folgt: </p><br><p>  Vermeiden Sie dies: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // George, Tyllen, Martin, Kelly stack.forEach(...); ...</span></span></code> </pre> <br><p>  Beachten Sie, dass wir die <strong><code>forEach()</code></strong> -Methode aufrufen, die von <strong><code>java.util.Vector</code></strong> geerbt wird.  Diese Methode durchl√§uft den Stapel wie jeder andere Vektor, und genau das brauchen wir.  Aber jetzt haben wir uns entschieden, <strong><code>ArrayDeque</code></strong> anstelle von <strong><code>Stack</code></strong> .  Wenn wir dies tun, erh√§lt die <strong><code>forEach()</code></strong> -Methode eine Implementierung von ArrayDeque, die den Stapel als Standardstapel (LIFO) durchl√§uft. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new ArrayDeque&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // Kelly, Martin, Tyllen, George stack.forEach(...); ...</span></span></code> </pre> <br><p>  Das wollen wir nicht.  Es ist zu schwierig, den Fehler hier zu verfolgen, da sich der Code, der den <strong><code>forEach()</code></strong> enth√§lt, nicht neben dem Code befindet, in dem die √Ñnderungen vorgenommen wurden.  Um die Geschwindigkeit beim Suchen und Beheben von Fehlern zu erh√∂hen, ist es viel besser, Code mit der <strong><code>stack</code></strong> so nah wie m√∂glich an der Deklaration dieser Variablen zu schreiben. </p><br><p>  Dies geschieht am besten wie folgt: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // George, Tyllen, Martin, Kelly stack.forEach(...); ... // 50 lines of code that doesn't use stack</span></span></code> </pre> <br><p>  Wenn der Entwickler jetzt von <strong><code>Stack</code></strong> zu <strong><code>ArrayQueue</code></strong> , kann er den Fehler schnell erkennen und beheben. </p><br><h2 id="punkt-12-tip-var-uproschaet-ispolzovanie-razlichnyh-tipov-v-ternarnyh-operatorah">  Klausel 12: Der var-Typ vereinfacht die Verwendung verschiedener Typen in tern√§ren Operatoren </h2><br><p>  Wir k√∂nnen verschiedene Arten von Operanden auf der rechten Seite des tern√§ren Operators verwenden. </p><br><p>  Bei der expliziten Angabe von Typen wird der folgende Code nicht kompiliert: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE List code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // or Set code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10);</span></span></code> </pre> <br><p>  Trotzdem k√∂nnen wir das tun: </p><br><pre> <code class="java hljs">Collection code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); Object code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Der folgende Code wird auch nicht kompiliert: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE int code = intOrString ? 12112 : "12112"; String code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  Sie k√∂nnen jedoch allgemeinere Typen verwenden: </p><br><pre> <code class="java hljs">Serializable code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>; Object code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>;</code> </pre> <br><p>  In all diesen F√§llen ist es besser, <strong>var</strong> zu bevorzugen: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // inferred as Collection&lt;Integer&gt; var code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // inferred as Serializable var code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  Aus diesen Beispielen folgt nicht, dass der <strong>var-</strong> Typ zur Laufzeit Objekttypen definiert.  Es ist nicht so! </p><br><p>  Und nat√ºrlich funktioniert der <strong>var-</strong> Typ mit denselben Typen beider Operanden korrekt: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferred as float var code = oneOrTwoDigits ? 1211.2f : 1211.25f;</span></span></code> </pre> <br><h2 id="punkt-13-tip-var-mozhet-byt-ispolzovan-vnutri-ciklov">  Punkt 13: Der Var-Typ kann in Schleifen verwendet werden </h2><br><p>  Wir k√∂nnen die explizite Deklaration von Typen in <strong>for-</strong> Schleifen leicht durch den Typ <strong>var</strong> ersetzen. </p><br><p>  √Ñndern eines expliziten <strong>int-</strong> Typs in <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type for (int i = 0; i &lt; 5; i++) { ... } // using var for (var i = 0; i &lt; 5; i++) { // i is inferred of type int ... }</span></span></code> </pre> <br><p>  √Ñndern des expliziten <strong><code>Order</code></strong> in <strong>var</strong> : </p><br><pre> <code class="java hljs">List&lt;Order&gt; orderList = ...; <span class="hljs-comment"><span class="hljs-comment">// explicit type for (Order order : orderList) { ... } // using var for (var order : orderList) { // order type is inferred as Order ... }</span></span></code> </pre> <br><h2 id="punkt-14-var-otlichno-rabotaet-s-potokami-stream-v-java-8">  Punkt 14: var funktioniert gut mit Streams in Java 8 </h2><br><p>  Es ist sehr einfach, var aus Java 10 mit Streams zu verwenden, die in Java 8 angezeigt wurden. </p><br><p>  Sie k√∂nnen die explizite Deklaration vom Typ <strong>Stream</strong> einfach durch <strong>var</strong> ersetzen: </p><br><h3 id="primer-1-1">  Beispiel 1: </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 4, 5); numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println); // using var var numbers = Stream.of(1, 2, 3, 4, 5); // inferred as Stream&lt;Integer&gt; numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println);</span></span></code> </pre> <br><h3 id="primer-2-1">  Beispiel 2: </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit types Stream&lt;String&gt; paths = Files.lines(Path.of("...")); List&lt;File&gt; files = paths.map(p -&gt; new File(p)).collect(toList()); // using var var paths = Files.lines(Path.of("...")); // inferred as Stream&lt;String&gt; var files = paths.map(p -&gt; new File(p)).collect(toList()); // inferred as List&lt;File&gt;</span></span></code> </pre><br><h2 id="punkt-15-var-mozhno-ispolzovat-pri-obyavlenii-lokalnyh-peremennyh-prednaznachennyh-dlya-razbieniya-bolshih-cepochek-vyrazheniy-na-chasti">  Klausel 15: var kann verwendet werden, wenn lokale Variablen deklariert werden, die gro√üe Ausdrucksketten in Teile zerlegen sollen </h2><br><p>  Ausdr√ºcke mit viel Verschachtelung sehen beeindruckend aus und wirken normalerweise wie intelligente und wichtige Codeteile.  In dem Fall, dass die Lesbarkeit des Codes verbessert werden muss, wird empfohlen, einen gro√üen Ausdruck mithilfe lokaler Variablen aufzubrechen.  Aber manchmal scheint das Schreiben vieler lokaler Variablen ein sehr anstrengender Job zu sein, den ich vermeiden m√∂chte. </p><br><p>  Ein Beispiel f√ºr einen gro√üen Ausdruck: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// AVOID int result = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)) .values() .stream() .max(Comparator.comparing(List::size)) .orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  Teilen Sie den Code besser in seine Bestandteile auf: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); Optional&lt;List&lt;Integer&gt;&gt; evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); int sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  Die zweite Version des Codes sieht lesbarer und einfacher aus, aber die erste Version hat auch ein Existenzrecht.  Es ist absolut normal, dass sich unser Geist an das Verst√§ndnis derart gro√üer Ausdr√ºcke anpasst und sie lokalen Variablen vorzieht.  Die Verwendung des <strong>var-</strong> Typs kann jedoch dazu beitragen, gro√üe Strukturen aufzubrechen, indem der Aufwand f√ºr die Deklaration lokaler Variablen verringert wird: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER var evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); var evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); var sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><h2 id="punkt-16-var-ne-mozhet-byt-ispolzovan-kak-tip-vozvraschaemogo-znacheniya-ili-kak-tip-argumenta-metoda">  Klausel 16: var kann nicht als R√ºckgabetyp oder als Methodenargumenttyp verwendet werden </h2><br><p>  Die beiden unten gezeigten Codefragmente werden nicht kompiliert. </p><br><p>  Verwenden von <strong>var</strong> als R√ºckgabetyp: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public var countItems(Order order, long timestamp) { ... }</span></span></code> </pre> <br><p>  Verwenden von <strong>var</strong> als Art von Methodenargument: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public int countItems(var order, var timestamp) { ... }</span></span></code> </pre> <br><h2 id="punkt-17-lokalnye-peremennye-tipa-var-mogut-byt-peredany-kak-parametry-metoda-ili-mogut-prinimat-vozvraschaemoe-metodom-znachenie">  Klausel 17: Lokale Variablen vom Typ var k√∂nnen als Parameter der Methode √ºbergeben werden oder den von der Methode zur√ºckgegebenen Wert annehmen </h2><br><p>  Die folgenden Codefragmente werden kompiliert und funktionieren ordnungsgem√§√ü: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Order order, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// an Order instance var timestamp = ...; // a long representing a timestamp var itemsNr = countItems(order, timestamp); // inferred as int type ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;A, B&gt; <span class="hljs-function"><span class="hljs-function">B </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A container, B tocontain)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// Order instance var product = ...; // Product instance var resultProduct = contains(order, product); // inferred as Product type</span></span></code> </pre> <br><h2 id="punkt-18-peremennye-var-mogut-byt-ispolzovany-s-anonimnymi-klassami">  18:  var       </h2><br><p>    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; Product product = ...; // a Product instance int weight = weighter.getWeight(product);</span></span></code> </pre> <br><p>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; var product = ...; // a Product instance var weight = weighter.getWeight(product);</span></span></code> </pre> <br><h2 id="punkt-19-peremennye-tipa-var-mogut-ispolzovatsya-v-kachestve-effectively-final-peremennyh">  19:   var     effectively final  </h2><br><p> , : </p><br><blockquote> <em>‚Ä¶   Java SE 8,           ,   final  effectively final.   ,        ,  effectively final</em> . </blockquote><p>  ,   <strong>var</strong>   effectively final.      . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID int ratio = 5; // this is effectively final Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var ratio = 5; // this is effectively final var weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><h2 id="punkt-20-var-peremennye-mogut-byt-final-peremennymi">  20: var-   final- </h2><br><p>   <strong>var</strong>     ( ,     effectively final).     ,  <strong>final</strong> . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID // IT DOESN'T COMPILE public void discount(int price) { final int limit = 2000; final int discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // IT DOESN'T COMPILE public void discount(int price) { final var limit = 2000; final var discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><h2 id="punkt-21-lyambda-vyrazheniyam-i-ssylkam-na-metody-nuzhny-yavnye-tipy">  21:          </h2><br><p>  <strong>var</strong>   ,     .          ,   <strong>var</strong> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // lambda expression needs an explicit target-type var f = x -&gt; x + 1; // method reference needs an explicit target-type var exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Supplier&lt;IllegalArgumentException&gt; exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   Java 11   <strong>var</strong> -    .      Java 11: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 11 (var x, var y) -&gt; x + y // or (@Nonnull var x, @Nonnull var y) -&gt; x + y</span></span></code> </pre> <br><h2 id="punkt-22-inicializirovat-var-nullem-zaprescheno">  22:  var null'  </h2><br><p>   <strong>var</strong> -  . </p><br><p>     (  <strong>null</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message = null; // result in an error of type: variable initializer is 'null'</span></span></code> </pre> <br><p>      ( ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message; // result in: cannot use 'var' on variable without initializer ... message = "hello";</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String message = null; // or String message; ... message = "hello";</span></span></code> </pre> <br><h2 id="punkt-23-tip-var-nelzya-ispolzovat-v-polyah-klassa">  23:  var      </h2><br><p>    <strong>var</strong>   ,      . </p><br><p>      : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public class Product { private var price; // error: 'var' is not allowed here private var name; // error: 'var' is not allowed here ... }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public class Product { private int price; private String name; ... }</span></span></code> </pre> <br><h2 id="punkt-24-var-nelzya-ispolzovat-v-bloke-catch">  24: var     catch </h2><br><p>   ,    try-with-resources </p><br><h3 id="blok-catch">  catch </h3><br><p>    ,    ,   . </p><br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE try { TimeUnit.NANOSECONDS.sleep(5000); } catch (var ex) { ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER try { TimeUnit.NANOSECONDS.sleep(5000); } catch (InterruptedException ex) { ... }</span></span></code> </pre> <br><h3 id="try-with-resources"> Try-with-resources </h3><br><p> , <strong>var</strong>     <strong>try-with-resources</strong> . </p><br><p> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type try (PrintWriter writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><p>     <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var try (var writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><h2 id="punkt-25-tip-var-mozhno-ispolzovat-s-dzhenerikami">  25:  var     </h2><br><p> ,     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ T temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>   ,  <strong>var</strong>    ,       <strong>T</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>     ,      <strong>var</strong> : </p><br><pre> <code class="java hljs">codepublic &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)); numbers.add((T) Double.valueOf(<span class="hljs-number"><span class="hljs-number">3.9</span></span>)); numbers.add(t); numbers.add(<span class="hljs-string"><span class="hljs-string">"5"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><p>     <strong>List&lt;T&gt;</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(); <span class="hljs-comment"><span class="hljs-comment">// DON'T DO THIS, DON'T FORGET THE, T var numbers = new ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(3)); numbers.add((T) Double.valueOf(3.9)); numbers.add(t); numbers.add("5"); // error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><h2 id="punkt-26-budte-vnimatelny-s-tipom-var-pri-ispolzovanii-wildcards--kovariantov-i-kontrvariantov">  26:     var   Wildcards (?),    </h2><br><h3 id="ispolzovanie--wildcards"> ? Wildcards </h3><br><p>    <strong>var</strong>  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;?&gt; clazz = Integer.class; // use var var clazz = Integer.class;</span></span></code> </pre> <br><p>    <strong>Foo&lt;?&gt;</strong>  <strong>var</strong>  ,      ,    <strong>var</strong>    . </p><br><p>     ,   , , ,    .       ,     <strong>ArrayList</strong>  ,     <strong>Collection&lt;?&gt;</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Collection&lt;?&gt; stuff = new ArrayList&lt;&gt;(); stuff.add("hello"); // compile time error stuff.add("world"); // compile time error // use var, this will remove the error, but I don't think that this is // what you had in mind when you wrote the above code var stuff = new ArrayList&lt;&gt;(); strings.add("hello"); // no error strings.add("world"); // no error</span></span></code> </pre> <br><h3 id="ispolzovanie-kovariantov-foo--extends-t-i-kontrvariantov-foo--super-t">   (Foo &lt;? extends T&gt;)   (Foo &lt;? super T&gt;) </h3><br><p>  ,    : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;? extends Number&gt; intNumber = Integer.class; Class&lt;? super FilterReader&gt; fileReader = Reader.class;</span></span></code> </pre> <br><p>            ,    ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: Class&lt;Reader&gt; cannot be converted to Class&lt;? extends Number&gt; Class&lt;? extends Number&gt; intNumber = Reader.class; // error: Class&lt;Integer&gt; cannot be converted to Class&lt;? super FilterReader&gt; Class&lt;? super FilterReader&gt; fileReader = Integer.class;</span></span></code> </pre> <br><p>    <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var var intNumber = Integer.class; var fileReader = Reader.class;</span></span></code> </pre> <br><p>       ,     .        ‚Äì     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// this will compile just fine var intNumber = Reader.class; var fileReader = Integer.class;</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>       ¬´ <strong>var</strong> ¬ª,    Java 10.    ,           .   ,      <strong>var</strong>    ,     . </p><br><p>  <strong>var</strong>      Java! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438206/">https://habr.com/ru/post/de438206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438192/index.html">Dell Inspiron 14 (5482): kosteng√ºnstiges 2-in-1-Ger√§t mit guten Upgrade-Optionen</a></li>
<li><a href="../de438196/index.html">Wenn das Projekt "Theater" ist, verwenden Sie Schauspieler ...</a></li>
<li><a href="../de438198/index.html">Gehen wir tief in die Geschichte ein: Wo wachsen die Beine von Quadrocoptern?</a></li>
<li><a href="../de438202/index.html">JavaScript: √ñffentliche und private Klassenfelder</a></li>
<li><a href="../de438204/index.html">Schnelles Compiler-Ger√§t. Teil 1</a></li>
<li><a href="../de438210/index.html">Zivilisation der Quellen, 2/5</a></li>
<li><a href="../de438212/index.html">Proof of Concept: Die √úberpr√ºfung der ML-Implementierung ist die Kerze wert</a></li>
<li><a href="../de438214/index.html">US-Tech-Startups werden 2019 neuen staatlichen Kontrollen ausgesetzt sein</a></li>
<li><a href="../de438218/index.html">OpenSceneGraph: Ereignisbehandlung</a></li>
<li><a href="../de438224/index.html">Regierungsviertel. Pilot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>