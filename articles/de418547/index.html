<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎾 🙅🏿 👨🏿‍💻 Asynchrone Programmierung mit Beispielen: Rekonstruktion der Methoden java.util.concurrent.CompletableFuture 🚧 🔪 👩🏼‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum ist eine Rekonstruktion erforderlich, wenn der Quellcode für diese Klasse geöffnet ist? 


 Schon allein deshalb, weil sich unter der Haube ein ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Programmierung mit Beispielen: Rekonstruktion der Methoden java.util.concurrent.CompletableFuture</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418547/"><p>  Warum ist eine Rekonstruktion erforderlich, wenn der Quellcode für diese Klasse geöffnet ist? </p><br><p>  Schon allein deshalb, weil sich unter der Haube ein hochoptimierter, schwer lesbarer Code befindet, dessen Studium pädagogisch wenig aussagt. </p><br><p>  Daher werden wir die Semantik von Operationen gemäß ihren Spezifikationen neu erstellen und funktional äquivalenten, verständlichen und lesbaren Code schreiben, obwohl dies hinsichtlich Speicherverbrauch und Prozessorzeit möglicherweise nicht der wirtschaftlichste ist. </p><a name="habracut"></a><br><p>  Beginnen wir mit einer relativ einfachen Methode: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><span class="hljs-function"> Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier. Type Parameters: U - the function's return type Parameters: supplier - a function returning the value to be used to complete the returned CompletableFuture executor - the executor to use </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> asynchronous execution Returns: the new CompletableFuture</span></span></code> </pre> <br><p>  Lesen Sie die Spezifikation sorgfältig durch: </p><br><pre> <code class="java hljs">Returns a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture</code> </pre> <br><p>  Das heißt, ein Objekt vom Typ <code>CompletableFuture</code> oder seine Unterklasse wird erstellt und als Ergebnis zurückgegeben. </p><br><pre> <code class="java hljs">that is asynchronously completed by a task running in the given executor`</code> </pre> <br><p>  Zusätzlich wird eine Aufgabe ausgeführt, die auf <code>Executor</code> 'e ausgeführt wird. <br>  Wie wir wissen, akzeptiert <code>Executor</code> nur <code>Runnable</code> Objekte. <br>  Runnable ist eine Schnittstelle, die möglicherweise vom ersten Objekt implementiert wird. Daher werden zwei Funktionen in einem Objekt kombiniert. </p><br><pre> <code class="java hljs"> completed ... with the value obtained by calling the given Supplier.</code> </pre> <br><p>  Diese <code>Runnable</code> sollte den angegebenen <code>Supplier</code> aufrufen und mit dem empfangenen Wert die erstellte <code>CompletableFuture</code> vervollständigen. </p><br><p>  <code>Supplier</code> ist eine parameterlose Funktion, daher ist die Codierung sehr einfach: </p><br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFutureForSupplyAsync</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFuture</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ Supplier&lt;U&gt; supplier; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletableFutureForSupplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.supplier = supplier; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { U result = supplier.get(); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.complete(result); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.completeExceptionally(e); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><span class="hljs-function"> </span></span>{ CompletableFutureForSupplyAsync&lt;U&gt; task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFutureForSupplyAsync&lt;&gt;(supplier); executor.execute(task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Das folgende Beispiel ist etwas komplizierter: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenApplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? extends U&gt; fn, Executor executor)</span></span></span><span class="hljs-function"> Returns a new CompletionStage that, when </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage completes normally, is executed using the supplied Executor, with </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage's result as the argument to the supplied function. See the CompletionStage documentation </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> rules covering exceptional completion. Specified by: thenApplyAsync in interface CompletionStage&lt;T&gt; Type Parameters: U - the function's return type Parameters: fn - the function to use to compute the value of the returned CompletionStage executor - the executor to use </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> asynchronous execution Returns: the new CompletionStage</span></span></code> </pre><br><p> <code>Returns a new CompletionStage that... is executed using the supplied Executor</code> </p> <br><p>  Hier wird uns direkt angeboten, das erstellte Objekt in Form von <code>Runnable</code> . </p><br><p> <code>... with this stage's result as the argument to the supplied function.</code> </p> <br><p>  Das ist aber schon interessanter.  Die an uns übergebene Funktion hat einen Parameter, und der Wert dieses Parameters ist der Wert, der die aktuelle <code>CompletionStage</code> vervollständigt.  Zum Zeitpunkt des Aufrufs von <code>thenApplyAsync</code> dieser Wert möglicherweise nicht bekannt, sodass wir die Aufgabe nicht sofort auf <code>Executor</code> .  Stattdessen müssen wir mit der aktuellen <code>CompletionStage</code> verhandeln. <br>  so dass es zum Zeitpunkt seiner Fertigstellung seinen Wert auf die Aufgabe überträgt.  Unter den zahlreichen Methoden von <code>CompletionStage</code> gibt es eine, die genau für diesen Zweck geeignet ist, <code>whenComplete</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompletableFuture&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whenComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BiConsumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Throwable&gt; action)</span></span></span><span class="hljs-function"> Returns a new CompletionStage with the same result or exception as </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage, that executes the given action when </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage completes.</span></span></code> </pre> <br><p>  Das heißt, im neu erstellten <code>BiConsumer</code> reicht es aus, die <code>BiConsumer</code> Schnittstelle zu implementieren, um ein Argument zu erhalten: </p><br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFutureForApplyAsync</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFuture</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BiConsumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Throwable</span></span></span><span class="hljs-class">&gt; </span></span>{ Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T,? extends U&gt; fn; Executor executor; T arg; Throwable throwable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletableFutureForApplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? extends U&gt; fn, Executor executor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = fn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.executor = executor; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-comment"><span class="hljs-comment">// implementation of BiConsumer interface public void accept(T argument, Throwable throwable) { if (throwable != null) { this.throwable = throwable; } else { this.arg = argument; } executor.execute(this); } @Override public void run() { if (throwable == null) { try { U result = fn.apply(arg); super.complete(result); } catch (Throwable e) { super.completeExceptionally(e); } } else { super.completeExceptionally(throwable); } } } public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor ) { CompletableFutureForApplyAsync&lt;T,U&gt; task = new CompletableFutureForApplyAsync&lt;&gt;(fn, executor); this.whenComplete(task); return task; } }</span></span></code> </pre> <br><p>  Dieses Beispiel ist sehr wichtig, um die Natur der asynchronen Programmierung zu verstehen. Daher listen wir noch einmal die wichtigsten Schritte auf: </p><br><p>  1) Eine asynchrone Prozedur wird erstellt: </p><br><pre> <code class="java hljs"> CompletableFutureForApplyAsync&lt;T,U&gt; task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFutureForApplyAsync&lt;&gt;(fn, executor);</code> </pre> <br><p>  2) es ist noch nicht zur Ausführung bereit, daher bitten wir den Anbieter des fehlenden Arguments, dieses Argument in Zukunft an uns weiterzuleiten, indem wir die von uns eingereichte Methode aufrufen: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.whenComplete(task);</code> </pre> <br><p>  3) In dieser Methode speichern wir nicht nur das empfangene Argument, sondern führen auch die Task zur Ausführung aus (siehe die Methode <code>accept</code> ()). </p><br><p>  4) Die Ausführung der Aufgabe reduziert sich auf die Erfüllung der uns übertragenen Funktion und das Speichern des Ergebnisses. <br>  Dieses Ergebnis kann genauso wie von anderen Prozeduren mithilfe der <code>whenComplete</code> () -Methode angefordert werden, die auf unser neu erstelltes Objekt angewendet wird, sodass wir eine Kette von asynchronen Prozeduren beliebiger Länge erstellen können.  Diese Kette wird jedoch streng sequentiell ohne Parallelität erfüllt. </p><br><p>  Aber wie kann man ein komplexeres Berechnungsdiagramm mit parallelen Zweigen darstellen? <br>  Verwenden Sie dazu die <code>thenCombineAsync</code> Methode. </p><br><p>  Wenn wir im vorherigen Beispiel die asynchrone Prozedur mit einem Argument gestartet haben, dann in diesem - mit zwei. </p><br><p>  In diesem Fall kann die Berechnung beider Argumente parallel erfolgen. </p><br><pre> <code class="java hljs">ublic &lt;U,V&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;V&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenCombineAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> U,? extends V&gt; fn, Executor executor)</span></span></span><span class="hljs-function"> Description copied from interface: CompletionStage Returns a new CompletionStage that, when </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> and the other given stage complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function.</span></span></code> </pre> <br><p>  Hier ist alles dasselbe wie im vorherigen Beispiel mit <code>thenApplyAsync</code> , aber der Funktionsparameter hat bereits zwei Argumente, und der <code>CompletionStage&lt;? extends U&gt; other</code> -Parameter wird hinzugefügt  <code>CompletionStage&lt;? extends U&gt; other</code> , was der asynchrone Anbieter des zweiten Arguments ist. </p><br><p>  Wie stellen wir sicher, dass das zweite Argument verarbeitet wird? </p><br><p>  Beschreiben Sie zunächst anstelle einer Variablen <code>T arg</code> zwei: <code>T arg1; U arg2;</code> <code>T arg1; U arg2;</code>  , a anstelle einer Methode public <code>void accept(T argument, Throwable throwable)</code> beschreiben zwei - <code>accept1</code> und <code>accept2</code> , <br>  Jedes davon arbeitet mit einem eigenen Argument. </p><br><p>  Gleichzeitig implementiert unser im Aufbau befindliches Objekt die <code>BiConsumer&lt;T,Throwable&gt;</code> nicht mehr und wir können keinen Schlüsselsatz mehr zum Verknüpfen der Knoten des asynchronen Berechnungsgraphen schreiben </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.whenComplete(task);</code> </pre> <br><p>  Glücklicherweise kann ein funktionales Schnittstellenobjekt durch einen Verweis auf eine Methode dargestellt werden, ohne es in einer separaten Klasse abzuschließen: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.whenComplete(task::accept1); other.whenComplete(task::accept2);</code> </pre> <br><p>  Das heißt, das aktuelle Objekt liefert das erste Argument und das <code>other</code> Objekt das zweite. </p><br><p>  Hier sind nur die Codes der Methoden, die geändert werden müssen, damit sie die Aufgabe nicht sofort nach Eingang ihres Arguments starten, sondern auch den Empfang der zweiten überprüfen: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T argument, Throwable throwable)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (throwable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.throwable = throwable; executor.execute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg1 = argument; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg2 != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { executor.execute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } }</code> </pre> <br><p>  Die accept2-Methode wird ähnlich beschrieben. </p><br><p>  Beachten Sie Folgendes: </p><br><ul><li>  Methoden werden synchronisiert (wir arbeiten mit gemeinsamen Daten) </li><li>  Bei einer Fehlerübertragung ist es nicht erforderlich, auf das zweite Argument zu warten. </li><li>  Es ist nicht der beste Weg, zu überprüfen, ob das Argument durch Vergleich mit <strong><code>null</code></strong> eintrifft. Möglicherweise müssen Sie für jedes Argument eine boolesche Variable hinzufügen. </li></ul><br><p>  Auf diese Weise können Sie asynchrone Prozeduren aus einer größeren Anzahl von Argumenten als zwei erstellen, aber der Gedanke kommt sofort auf - können Sie immer noch eine separate Klasse für die Parameter erstellen, um nicht Ihre eigene Methode zum Empfangen jedes Parameters zu schreiben, sondern indem Sie die Parameter dynamisch erstellen? </p><br><pre> <code class="java hljs"> Parameter&lt;Integer&gt; arg1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parameter&lt;&gt;(); Parameter&lt;Float&gt; arg2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parameter&lt;&gt;(); ... future1.whenComplete(arg1); future2.whenComplete(arg2);</code> </pre> <br><p>  Ja, Sie können eine solche Klasse erstellen, aber dazu beim nächsten Mal mehr. </p><br><p>  Eine kurze Zusammenfassung des Vorstehenden: </p><br><ul><li>  Ein asynchrones Programm ist ein Netzwerk miteinander verbundener asynchroner Prozeduren. <br>  Genau wie ein Multithread-Programm ist ein Netzwerk von miteinander verbundenen Ausführungsthreads (Threads). </li></ul><br><p>  Die Mittel für Kommunikationsflüsse und asynchrone Prozeduren unterscheiden sich jedoch grundlegend. </p><br><p>  Streams werden mithilfe von Semaphoren, blockierenden Warteschlangen und anderen ähnlichen Objekten verbunden. <br>  Diese blockieren den Empfänger-Stream, wenn die Informationen noch nicht eingetroffen sind, der Stream jedoch bereits versucht, sie mithilfe der Pull-basierten Operation zu extrahieren. </p><br><p>  Asynchrone Prozeduren - Empfänger geben die Ausführung erst ein, wenn alle benötigten Informationen bereit sind. <br>  Sie warten passiv, bis die Informationsanbieter selbst eine Push-basierte Operation durchlaufen. <br>  Aus diesem Grund verbrauchen sie während des Wartens keinen Speicher auf dem Stapel und belegen daher viel weniger Speicher als Ausführungsthreads. </p><br><ul><li>  Der Aufbau eines Netzwerks asynchroner Prozeduren reduziert sich auf das Erstellen und Verknüpfen von Objekten, genauer gesagt auf das Verknüpfen ihrer Unterobjekte - Parameter: Die Adresse des Eingabeparameters des Empfängers wird an den Ausgabeparameter des Informationsanbieters übertragen. </li></ul><br><p>  Der Satz von <code>CompletableFuture</code> Methoden macht genau das, und im Prinzip können Sie auf diese Methoden verzichten, indem Sie Objekte explizit erstellen, wie in den obigen Beispielen gezeigt. <br>  Dafür ist es jedoch erforderlich, Klassen zu haben, die denen ähneln, die in diesen Beispielen beschrieben wurden. <br>  Aus irgendeinem Grund haben die Ersteller von <code>java.util.concurrent</code> beschlossen, Benutzern keinen Zugriff auf diese Klassen zu gewähren und sie in den Tiefen des <code>CompletableFuture</code> Codes zu verstecken. </p><br><p>  Diejenigen, die eine visuelle Darstellung des erstellten asynchronen Netzwerks wünschen, können diese Klassen rekonstruieren, indem sie die obigen Beispiele fortsetzen.  Der Quellcode für die Beispiele <a href="">ist bei Github erhältlich</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418547/">https://habr.com/ru/post/de418547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418535/index.html">Warum Telegrammpass - kein Ende zu Ende</a></li>
<li><a href="../de418537/index.html">Wenn Sie Müll entsorgen, ist die Hauptsache nicht, ihn anzuschauen. Teil 1?</a></li>
<li><a href="../de418539/index.html">Sicherheitslücke in der Verschlüsselung in verschiedenen Bluetooth-Implementierungen</a></li>
<li><a href="../de418543/index.html">Fünf Teams, die die 3D-gedruckte Habitat Centennial Challenge gewinnen, teilen sich einen Preispool von 100.000 US-Dollar</a></li>
<li><a href="../de418545/index.html">"Künstliches Leben" auf einem Computer schaffen</a></li>
<li><a href="../de418549/index.html">Erstellen eines Bots zur Teilnahme am AI Mini Cup 2018 basierend auf einem wiederkehrenden neuronalen Netzwerk (Teil 3)</a></li>
<li><a href="../de418551/index.html">Wie viel sollte ein Programmierer in Mathe wissen?</a></li>
<li><a href="../de418553/index.html">Kotlin + Reagieren gegen Javasript + Reagieren</a></li>
<li><a href="../de418557/index.html">Berechnung von Wellenprozessen in einer Hydraulikleitung nach der Methode der Eigenschaften</a></li>
<li><a href="../de418559/index.html">NL2API: Erstellen von Schnittstellen in natürlicher Sprache für die Web-API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>