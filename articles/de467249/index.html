<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏿 🌛 👼🏽 Eine Geschichte über V8, React und einen Leistungsabfall. Teil 2 🧔🏾 🛵 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute veröffentlichen wir den zweiten Teil der Übersetzung des Materials, das den internen Mechanismen von V8 und der Untersuchung des Leistungsproble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Geschichte über V8, React und einen Leistungsabfall. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467249/">  Heute veröffentlichen wir den zweiten Teil der Übersetzung des Materials, das den internen Mechanismen von V8 und der Untersuchung des Leistungsproblems von React gewidmet ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/de/g6/0r/deg60r8mwme-o8ihiv3mlbuqhmq.jpeg"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Veralterung und Migration von Objektformen</font> </h2><br>  Was ist, wenn das Feld ursprünglich einen <code>Smi</code> enthielt und sich dann die Situation änderte und ein Wert gespeichert werden musste, für den die <code>Smi</code> Darstellung nicht geeignet ist?  Beispiel: Wie im folgenden Beispiel, wenn zwei Objekte mit derselben Form des Objekts dargestellt werden, in dem <code>x</code> anfänglich als <code>Smi</code> gespeichert ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  `x`       `Smi` bx = 0.2; //  `bx`     `Double` y = ax;</span></span></code> </pre> <br>  Zu Beginn des Beispiels haben wir zwei Objekte, für deren Darstellung wir dieselbe Form des Objekts verwenden, in dem das <code>Smi</code> Format zum Speichern von <code>x</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/02d/43f/7a002d43f6d9e7b6e702173b32256513.png"></div><br>  <i><font color="#999999">Das gleiche Formular wird zur Darstellung von Objekten verwendet</font></i> <br><br>  Wenn sich die <code>bx</code> Eigenschaft ändert und Sie das <code>Double</code> Format verwenden müssen, um sie darzustellen, weist V8 Speicherplatz für die neue Form des Objekts zu, in der <code>x</code> die <code>Double</code> Darstellung zugewiesen ist und die eine leere Form angibt.  V8 erstellt auch eine Entität <code>MutableHeapNumber</code> , in der der Wert 0,2 der <code>x</code> Eigenschaft gespeichert wird.  Anschließend aktualisieren wir das Objekt <code>b</code> so, dass es auf dieses neue Formular verweist, und ändern den Steckplatz im Objekt so, dass es <code>MutableHeapNumber</code> die zuvor erstellte <code>MutableHeapNumber</code> Entität mit Offset 0 <code>MutableHeapNumber</code> . Schließlich markieren wir die alte Form des Objekts als veraltet und trennen sie vom Baum Übergänge.  Dazu erstellen Sie einen neuen Übergang für <code>'x'</code> vom leeren zum gerade erstellten Formular. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/8f0/361/e7c8f03616b29cd8c1bea799c6527546.png"></div><br>  <i><font color="#999999">Folgen der Zuweisung eines neuen Werts zu einer Objekteigenschaft</font></i> <br><br>  Derzeit können wir das alte Formular nicht vollständig löschen, da es noch von Objekt <code>a</code> .  Darüber hinaus ist es sehr teuer, den gesamten Speicher bei der Suche nach allen Objekten zu umgehen, die auf das alte Formular verweisen, und den Status dieser Objekte sofort zu aktualisieren.  Stattdessen verwendet der V8 hier einen "faulen" Ansatz.  Alle Operationen zum Lesen oder Schreiben der Eigenschaften von Objekt <code>a</code> zunächst auf die Verwendung eines neuen Formulars übertragen.  Die Idee hinter dieser Aktion ist es, die veraltete Form des Objekts letztendlich unerreichbar zu machen.  Dies führt dazu, dass der Garbage Collector damit umgeht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/bfa/7a3/656bfa7a3138ace8f68a09553b718af6.png"></div><br>  <i><font color="#999999">Out-of-Form-Speicher gibt den Garbage Collector frei</font></i> <br><br>  In Situationen, in denen das Feld, das die Ansicht ändert, nicht das letzte in der Kette ist, sind die Dinge komplizierter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>,  <span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }; oy = <span class="hljs-number"><span class="hljs-number">0.1</span></span>;</code> </pre> <br>  In diesem Fall muss der V8 die sogenannte Split-Form finden.  Dies ist das letzte Formular in der Kette, das sich vor dem Formular befindet, in dem die entsprechende Eigenschaft angezeigt wird.  Hier ändern wir <code>y</code> , das heißt - wir müssen die letzte Form finden, in der es kein <code>y</code> .  In unserem Beispiel ist dies die Form, in der <code>x</code> erscheint. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/210/2e3/0422102e38310aa94fecc13f38048222.png"></div><br>  <i><font color="#999999">Suchen Sie nach dem letzten Formular, in dem kein Wert geändert wurde</font></i> <br><br>  Ausgehend von dieser Form erstellen wir hier eine neue Übergangskette für <code>y</code> , die alle vorherigen Übergänge reproduziert.  Erst jetzt wird die Eigenschaft <code>'y'</code> als <code>Double</code> .  Jetzt verwenden wir diese neue Übergangskette für <code>y</code> und markieren sie als veralteten alten Teilbaum.  Im letzten Schritt migrieren wir die Instanz des <code>o</code> Objekts in ein neues Formular und verwenden jetzt die Entität <code>MutableHeapNumber</code> , um den <code>y</code> <code>MutableHeapNumber</code> zu speichern.  Bei diesem Ansatz verwendet das neue Objekt keine Fragmente des alten Übergangsbaums, und nachdem alle Verweise auf die alte Form verschwunden sind, verschwindet auch der veraltete Teil des Baums. <br><br><h2>  <font color="#3AC1EF">Erweiterbarkeit und Übergangsintegrität</font> </h2><br>  Mit dem Befehl <code>Object.preventExtensions()</code> können Sie das Hinzufügen neuer Eigenschaften zu einem Objekt vollständig verhindern.  Wenn Sie das Objekt mit diesem Befehl verarbeiten und versuchen, ihm eine neue Eigenschaft hinzuzufügen, wird eine Ausnahme ausgelöst.  (Richtig, wenn der Code nicht im strengen Modus ausgeführt wird, wird keine Ausnahme ausgelöst. Ein Versuch, eine Eigenschaft hinzuzufügen, führt jedoch einfach zu keinen Konsequenzen.)  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible</span></span></code> </pre> <br>  Die <code>Object.seal()</code> -Methode wirkt auf Objekte wie <code>Object.preventExtensions()</code> , markiert jedoch auch alle Eigenschaften als nicht konfigurierbar.  Dies bedeutet, dass sie weder gelöscht noch ihre Eigenschaften hinsichtlich der Möglichkeiten zum Auflisten, Festlegen oder Umschreiben geändert werden können. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x</span></span></code> </pre> <br>  Die <code>Object.freeze()</code> -Methode führt dieselben Aktionen wie <code>Object.seal()</code> , ihre Verwendung führt jedoch zusätzlich dazu, dass die Werte vorhandener Eigenschaften nicht geändert werden können.  Sie sind als Eigenschaften gekennzeichnet, in die keine neuen Werte geschrieben werden können. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x object.x = 3; // TypeError: Cannot assign to read-only property x</span></span></code> </pre> <br>  Betrachten Sie ein bestimmtes Beispiel.  Wir haben zwei Objekte, von denen jedes einen eindeutigen Wert <code>x</code> .  Dann verbieten wir die Erweiterung des zweiten Objekts: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(b);</code> </pre> <br>  Die Verarbeitung dieses Codes beginnt mit Aktionen, die wir bereits kennen.  Es wird nämlich ein Übergang von der leeren Form des Objekts zur neuen Form vorgenommen, die die Eigenschaft <code>'x'</code> (dargestellt als Entität <code>Smi</code> ).  Wenn wir die Erweiterung von Objekt <code>b</code> verbieten, führt dies zu einem besonderen Übergang zu einer neuen Form, die als nicht erweiterbar markiert ist.  Dieser besondere Übergang führt nicht zum Erscheinen einer neuen Immobilie.  Dies ist in der Tat nur ein Marker. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/2f4/94a/9582f494ae02d57ddc0c17db4749f767.png"></div><br>  <i><font color="#999999">Das Ergebnis der Verarbeitung eines Objekts mit der Object.preventExtensions () -Methode</font></i> <br><br>  Bitte beachten Sie, dass wir das vorhandene Formular nicht einfach mit dem Wert <code>x</code> darin ändern können, da es von einem anderen Objekt benötigt wird, nämlich Objekt <code>a</code> , das noch erweiterbar ist. <br><br><h2>  <font color="#3AC1EF">Leistungsproblem reagieren</font> </h2><br>  Lassen Sie uns nun alles sammeln, worüber wir gesprochen haben, und das gewonnene Wissen nutzen, um die Essenz des jüngsten React-Leistungsproblems zu verstehen.  Als das React-Team reale Anwendungen profilierte, stellten sie eine merkwürdige Verschlechterung der V8-Leistung fest, die sich auf den React-Kern auswirkte.  Hier ist eine vereinfachte Reproduktion des Problemteils des Codes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(o); oy = <span class="hljs-number"><span class="hljs-number">0.2</span></span>;</code> </pre> <br>  Wir haben ein Objekt mit zwei Feldern, die als <code>Smi</code> Entitäten dargestellt werden.  Wir verhindern eine weitere Erweiterung des Objekts und führen dann eine Aktion aus, die dazu führt, dass das zweite Feld im <code>Double</code> werden muss. <br><br>  Wir haben bereits herausgefunden, dass das Verbot der Objekterweiterung zu ungefähr der folgenden Situation führt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf7/d6e/3b8/bf7d6e3b8783a06c2923e76aa830f64b.png"></div><br>  <i><font color="#999999">Folgen des Verbots der Objekterweiterung</font></i> <br><br>  Um beide Eigenschaften des Objekts darzustellen, werden <code>Smi</code> Entitäten <code>Smi</code> , und der letzte Übergang ist erforderlich, um die Form des Objekts als nicht erweiterbar zu markieren. <br><br>  Jetzt müssen wir die Darstellung der <code>y</code> Eigenschaft durch <code>Double</code> ändern.  Dies bedeutet, dass wir nach einer Form der Trennung suchen müssen.  In diesem Fall ist dies die Form, in der die <code>x</code> Eigenschaft angezeigt wird.  Aber jetzt ist der V8 verwirrt.  Tatsache ist, dass das Trennformular erweiterbar war und das aktuelle Formular als nicht erweiterbar markiert wurde.  V8 weiß nicht, wie der Übergangsprozess in einer ähnlichen Situation reproduziert werden soll.  Infolgedessen weigert sich der Motor einfach, alles herauszufinden.  Stattdessen wird einfach ein separates Formular erstellt, das nicht mit dem aktuellen Formularbaum verbunden ist und nicht mit anderen Objekten geteilt wird.  Dies ist so etwas wie eine verwaiste Form eines Objekts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abc/581/82d/abc58182dd6e657649af6e934aef04f7.png"></div><br>  <i><font color="#999999">Verwaiste Form</font></i> <br><br>  Es ist leicht zu erraten, dass dies, wenn dies bei vielen Objekten geschieht, sehr schlecht ist.  Tatsache ist, dass dies das gesamte System der V8-Objektformen unbrauchbar macht. <br><br>  Wenn kürzlich ein React-Problem aufgetreten ist, ist Folgendes aufgetreten.  Jedes Objekt der <code>FiberNode</code> Klasse verfügte über Felder, in denen Zeitstempel gespeichert werden sollten, wenn die Profilerstellung aktiviert ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actualStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode();</code> </pre> <br>  Diese Felder (z. B. <code>actualStartTime</code> ) wurden mit 0 oder -1 initialisiert.  Dies führte dazu, dass <code>Smi</code> Entitäten verwendet wurden, um ihre Bedeutungen <code>Smi</code> darzustellen.  Später speicherten sie Echtzeitstempel im Format von Gleitkommazahlen, die von der Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">performance.now () zurückgegeben wurden.</a>  Dies führte dazu, dass diese Werte nicht mehr in Form von <code>Smi</code> .  Um diese Felder darzustellen, waren jetzt <code>Double</code> Entitäten erforderlich.  Darüber hinaus hat React auch die Erweiterung von Instanzen der <code>FiberNode</code> Klasse verhindert. <br><br>  Zunächst könnte unser vereinfachtes Beispiel in der folgenden Form dargestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/972/e7f/7db972e7fc38fe7ffe228a765a401509.png"></div><br>  <i><font color="#999999">Ausgangszustand des Systems</font></i> <br><br>  Es gibt zwei Instanzen der Klasse, die denselben Baum von Übergängen der Form von Objekten verwenden.  Genau genommen ist das System der Formen von Objekten in V8 dafür ausgelegt.  Wenn dann die Echtzeitstempel im Objekt gespeichert sind, kann V8 nicht verstehen, wie es die Form der Trennung finden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b6/443/bc9/6b6443bc9ea1c84dcc88ed9b6e9a0a03.png"></div><br>  <i><font color="#999999">V8 ist verwirrt</font></i> <br><br>  V8 weist <code>node1</code> eine neue verwaiste Form zu.  Das gleiche passiert etwas später mit dem <code>node2</code> Objekt.  Als Ergebnis haben wir jetzt zwei "verwaiste" Formen, von denen jede nur von einem Objekt verwendet wird.  In vielen realen React-Anwendungen beträgt die Anzahl solcher Objekte viel mehr als zwei.  Dies können Zehntausende oder sogar Tausende von Objekten der <code>FiberNode</code> Klasse sein.  Es ist leicht zu verstehen, dass diese Situation die V8-Leistung nicht sehr gut beeinflusst. <br><br>  Glücklicherweise haben wir dieses Problem in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8 v7.4 behoben</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untersuchen die</a> Möglichkeit, die Darstellung von Feldern von Objekten weniger ressourcenintensiv zu gestalten.  Auf diese Weise können wir die verbleibenden Leistungsprobleme lösen, die in solchen Situationen auftreten.  Dank des Fixes verhält sich V8 jetzt in der oben beschriebenen Problemsituation korrekt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/556/574/23e556574e5e5b2a462adc3e983d8f37.png"></div><br>  <i><font color="#999999">Ausgangszustand des Systems</font></i> <br><br>  So sieht es aus.  Zwei Instanzen der <code>FiberNode</code> Klasse verweisen auf ein nicht erweiterbares Formular.  In diesem Fall wird <code>'actualStartTime'</code> als <code>Smi</code> Feld dargestellt.  Wenn die erste Operation zum Zuweisen eines Werts zur Eigenschaft <code>node1.actualStartTime</code> , wird eine neue Übergangskette erstellt und die vorherige Kette als veraltet markiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/34f/c12/81b34fc121c16ff52582f33cd01e1389.png"></div><br>  <i><font color="#999999">Ergebnisse der Zuweisung eines neuen Werts zur Node1.actualStartTime-Eigenschaft</font></i> <br><br>  Bitte beachten Sie, dass der Übergang zur nicht erweiterbaren Form jetzt in der neuen Kette korrekt wiedergegeben wird.  Dies ist, worauf das System <code>node2.actualStartTime</code> nachdem der Wert von <code>node2.actualStartTime</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/834/dbf/25c/834dbf25c0436caa37a871d3b985dc5a.png"></div><br>  <i><font color="#999999">Die Ergebnisse der Zuweisung eines neuen Werts zur Eigenschaft node2.actualStartTime</font></i> <br><br>  Nachdem der neue Wert der Eigenschaft <code>node2.actualStartTime</code> zugewiesen wurde, <code>node2.actualStartTime</code> beide Objekte auf das neue Formular, und der veraltete Teil des Übergangsbaums kann vom Garbage Collector zerstört werden. <br><br>  Bitte beachten Sie, dass Vorgänge zum Markieren der Formen von Objekten als veraltet und deren Migration kompliziert aussehen können.  In der Tat - so wie es ist.  Wir vermuten, dass dies auf echten Websites mehr schadet (in Bezug auf Leistung, Speichernutzung, Komplexität) als nützt.  Insbesondere - nachdem wir im Fall der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeigerkomprimierung</a> diesen Ansatz nicht mehr verwenden können, um <code>Double</code> Felder in Form von in Objekte eingebetteten Werten zu speichern.  Infolgedessen hoffen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> den Mechanismus der Veralterung von V8-Objektformen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollständig aufzugeben</a> und diesen Mechanismus selbst überflüssig zu machen. <br><br>  Es ist zu beachten, dass das React-Team dieses Problem selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gelöst</a> hat und sichergestellt hat, dass die Felder in den Objekten der <code>FiberNodes</code> Klasse ursprünglich durch doppelte Werte dargestellt wurden: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-comment"><span class="hljs-comment">//     `Double`   .    this.actualStartTime = Number.NaN;    //       ,  :    this.actualStartTime = 0;    Object.preventExtensions(this);  } } const node1 = new FiberNode(); const node2 = new FiberNode();</span></span></code> </pre> <br>  Hier kann anstelle von <code>Number.NaN</code> jeder Gleitkommawert verwendet werden, der nicht in den <code>Smi</code> Bereich passt.  Zu diesen Werten gehören 0,000001, <code>Number.MIN_VALUE</code> , -0 und <code>Infinity</code> . <br><br>  Es ist erwähnenswert, dass das in React beschriebene Problem spezifisch für V8 war und dass Entwickler beim Erstellen von Code nicht danach streben müssen, ihn basierend auf einer bestimmten Version einer bestimmten JavaScript-Engine zu optimieren.  Es ist jedoch nützlich, etwas durch Optimieren des Codes beheben zu können, falls die Ursachen einiger Fehler in den Funktionen der Engine liegen. <br><br>  Es sei daran erinnert, dass es in den Eingeweiden von JS-Motoren viele allerlei erstaunliche Dinge gibt.  Der JS-Entwickler kann all diesen Mechanismen nach Möglichkeit helfen, ohne dieselben Variablenwerte unterschiedlichen Typs zuzuweisen.  Beispielsweise sollten Sie numerische Felder nicht mit <code>null</code> initialisieren, da dies alle Vorteile der Beobachtung der Felddarstellung zunichte macht und die Lesbarkeit des Codes verbessert: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ! class Point {  x = null;  y = null; } const p = new Point(); px = 0.1; py = 402;</span></span></code> </pre> <br>  Mit anderen Worten - schreiben Sie lesbaren Code, und die Leistung wird von selbst kommen! <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir die folgenden wichtigen Punkte untersucht: <br><br><ul><li>  JavaScript unterscheidet zwischen "primitiven" und "Objekt" -Werten, und die Art der Ergebnisse kann nicht als vertrauenswürdig eingestuft werden. </li><li>  Sogar Werte mit demselben JavaScript-Typ können im Darm der Engine auf unterschiedliche Weise dargestellt werden. </li><li>  V8 versucht, den besten Weg zu finden, um jede Eigenschaft des in JS-Programmen verwendeten Objekts darzustellen. </li><li>  In bestimmten Situationen führt V8 Operationen zum Markieren der Formulare von Objekten als veraltet durch und führt die Migration von Formularen durch.  Einschließlich - implementiert Übergänge, die mit dem Verbot der Erweiterung von Objekten verbunden sind. </li></ul><br>  Basierend auf dem Vorstehenden können wir einige praktische JavaScript-Programmiertipps bereitstellen, die zur Verbesserung der Codeleistung beitragen können: <br><br><ul><li>  Initialisieren Sie Ihre Objekte immer auf die gleiche Weise.  Dies trägt zur effektiven Arbeit mit Objektformen bei. </li><li>  Wählen Sie verantwortungsbewusst die Anfangswerte für die Felder von Objekten aus.  Dies hilft den JavaScript-Engines bei der Auswahl, wie diese Werte intern dargestellt werden sollen. </li></ul><br>  <b>Liebe Leser!</b>  Haben Sie Ihren Code jemals basierend auf den internen Funktionen bestimmter JavaScript-Engines optimiert? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467249/">https://habr.com/ru/post/de467249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467237/index.html">Erhöhen Sie Ihren DNS-over-HTTPS-Server</a></li>
<li><a href="../de467239/index.html">Der Unterschied zwischen Data Scientist und einem Teenager in einem Sportwagen</a></li>
<li><a href="../de467241/index.html">ROS LKW Wagen. Teil 4. Erstellen einer Robotersimulation mit den Editoren rviz und pavillon</a></li>
<li><a href="../de467245/index.html">Dmitry Matskevich, Dbrain: über Unternehmertum als geistige Behinderung, KI und emotionale Sicherheit</a></li>
<li><a href="../de467247/index.html">Eine Geschichte über V8, React und einen Leistungsabfall. Teil 1</a></li>
<li><a href="../de467251/index.html">Geiseln COBOL und Math. Teil 1</a></li>
<li><a href="../de467253/index.html">Geiseln COBOL und Math. Teil 2</a></li>
<li><a href="../de467255/index.html">Drei häufige Sicherheitsfehler, über die jeder Reaktionsentwickler Bescheid wissen sollte</a></li>
<li><a href="../de467257/index.html">Lagern Sie nicht alle Eier gleichzeitig in einem Korb</a></li>
<li><a href="../de467259/index.html">DPI (SSL Inspection) widerspricht der Bedeutung von Kryptografie, wird jedoch von Unternehmen implementiert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>