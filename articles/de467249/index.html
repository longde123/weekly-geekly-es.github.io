<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèø üåõ üëºüèΩ Eine Geschichte √ºber V8, React und einen Leistungsabfall. Teil 2 üßîüèæ üõµ üë®üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ver√∂ffentlichen wir den zweiten Teil der √úbersetzung des Materials, das den internen Mechanismen von V8 und der Untersuchung des Leistungsproble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Geschichte √ºber V8, React und einen Leistungsabfall. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467249/">  Heute ver√∂ffentlichen wir den zweiten Teil der √úbersetzung des Materials, das den internen Mechanismen von V8 und der Untersuchung des Leistungsproblems von React gewidmet ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/de/g6/0r/deg60r8mwme-o8ihiv3mlbuqhmq.jpeg"></a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Veralterung und Migration von Objektformen</font> </h2><br>  Was ist, wenn das Feld urspr√ºnglich einen <code>Smi</code> enthielt und sich dann die Situation √§nderte und ein Wert gespeichert werden musste, f√ºr den die <code>Smi</code> Darstellung nicht geeignet ist?  Beispiel: Wie im folgenden Beispiel, wenn zwei Objekte mit derselben Form des Objekts dargestellt werden, in dem <code>x</code> anf√§nglich als <code>Smi</code> gespeichert ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  `x`       `Smi` bx = 0.2; //  `bx`     `Double` y = ax;</span></span></code> </pre> <br>  Zu Beginn des Beispiels haben wir zwei Objekte, f√ºr deren Darstellung wir dieselbe Form des Objekts verwenden, in dem das <code>Smi</code> Format zum Speichern von <code>x</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/02d/43f/7a002d43f6d9e7b6e702173b32256513.png"></div><br>  <i><font color="#999999">Das gleiche Formular wird zur Darstellung von Objekten verwendet</font></i> <br><br>  Wenn sich die <code>bx</code> Eigenschaft √§ndert und Sie das <code>Double</code> Format verwenden m√ºssen, um sie darzustellen, weist V8 Speicherplatz f√ºr die neue Form des Objekts zu, in der <code>x</code> die <code>Double</code> Darstellung zugewiesen ist und die eine leere Form angibt.  V8 erstellt auch eine Entit√§t <code>MutableHeapNumber</code> , in der der Wert 0,2 der <code>x</code> Eigenschaft gespeichert wird.  Anschlie√üend aktualisieren wir das Objekt <code>b</code> so, dass es auf dieses neue Formular verweist, und √§ndern den Steckplatz im Objekt so, dass es <code>MutableHeapNumber</code> die zuvor erstellte <code>MutableHeapNumber</code> Entit√§t mit Offset 0 <code>MutableHeapNumber</code> . Schlie√ülich markieren wir die alte Form des Objekts als veraltet und trennen sie vom Baum √úberg√§nge.  Dazu erstellen Sie einen neuen √úbergang f√ºr <code>'x'</code> vom leeren zum gerade erstellten Formular. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/8f0/361/e7c8f03616b29cd8c1bea799c6527546.png"></div><br>  <i><font color="#999999">Folgen der Zuweisung eines neuen Werts zu einer Objekteigenschaft</font></i> <br><br>  Derzeit k√∂nnen wir das alte Formular nicht vollst√§ndig l√∂schen, da es noch von Objekt <code>a</code> .  Dar√ºber hinaus ist es sehr teuer, den gesamten Speicher bei der Suche nach allen Objekten zu umgehen, die auf das alte Formular verweisen, und den Status dieser Objekte sofort zu aktualisieren.  Stattdessen verwendet der V8 hier einen "faulen" Ansatz.  Alle Operationen zum Lesen oder Schreiben der Eigenschaften von Objekt <code>a</code> zun√§chst auf die Verwendung eines neuen Formulars √ºbertragen.  Die Idee hinter dieser Aktion ist es, die veraltete Form des Objekts letztendlich unerreichbar zu machen.  Dies f√ºhrt dazu, dass der Garbage Collector damit umgeht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/bfa/7a3/656bfa7a3138ace8f68a09553b718af6.png"></div><br>  <i><font color="#999999">Out-of-Form-Speicher gibt den Garbage Collector frei</font></i> <br><br>  In Situationen, in denen das Feld, das die Ansicht √§ndert, nicht das letzte in der Kette ist, sind die Dinge komplizierter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>,  <span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }; oy = <span class="hljs-number"><span class="hljs-number">0.1</span></span>;</code> </pre> <br>  In diesem Fall muss der V8 die sogenannte Split-Form finden.  Dies ist das letzte Formular in der Kette, das sich vor dem Formular befindet, in dem die entsprechende Eigenschaft angezeigt wird.  Hier √§ndern wir <code>y</code> , das hei√üt - wir m√ºssen die letzte Form finden, in der es kein <code>y</code> .  In unserem Beispiel ist dies die Form, in der <code>x</code> erscheint. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/210/2e3/0422102e38310aa94fecc13f38048222.png"></div><br>  <i><font color="#999999">Suchen Sie nach dem letzten Formular, in dem kein Wert ge√§ndert wurde</font></i> <br><br>  Ausgehend von dieser Form erstellen wir hier eine neue √úbergangskette f√ºr <code>y</code> , die alle vorherigen √úberg√§nge reproduziert.  Erst jetzt wird die Eigenschaft <code>'y'</code> als <code>Double</code> .  Jetzt verwenden wir diese neue √úbergangskette f√ºr <code>y</code> und markieren sie als veralteten alten Teilbaum.  Im letzten Schritt migrieren wir die Instanz des <code>o</code> Objekts in ein neues Formular und verwenden jetzt die Entit√§t <code>MutableHeapNumber</code> , um den <code>y</code> <code>MutableHeapNumber</code> zu speichern.  Bei diesem Ansatz verwendet das neue Objekt keine Fragmente des alten √úbergangsbaums, und nachdem alle Verweise auf die alte Form verschwunden sind, verschwindet auch der veraltete Teil des Baums. <br><br><h2>  <font color="#3AC1EF">Erweiterbarkeit und √úbergangsintegrit√§t</font> </h2><br>  Mit dem Befehl <code>Object.preventExtensions()</code> k√∂nnen Sie das Hinzuf√ºgen neuer Eigenschaften zu einem Objekt vollst√§ndig verhindern.  Wenn Sie das Objekt mit diesem Befehl verarbeiten und versuchen, ihm eine neue Eigenschaft hinzuzuf√ºgen, wird eine Ausnahme ausgel√∂st.  (Richtig, wenn der Code nicht im strengen Modus ausgef√ºhrt wird, wird keine Ausnahme ausgel√∂st. Ein Versuch, eine Eigenschaft hinzuzuf√ºgen, f√ºhrt jedoch einfach zu keinen Konsequenzen.)  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible</span></span></code> </pre> <br>  Die <code>Object.seal()</code> -Methode wirkt auf Objekte wie <code>Object.preventExtensions()</code> , markiert jedoch auch alle Eigenschaften als nicht konfigurierbar.  Dies bedeutet, dass sie weder gel√∂scht noch ihre Eigenschaften hinsichtlich der M√∂glichkeiten zum Auflisten, Festlegen oder Umschreiben ge√§ndert werden k√∂nnen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x</span></span></code> </pre> <br>  Die <code>Object.freeze()</code> -Methode f√ºhrt dieselben Aktionen wie <code>Object.seal()</code> , ihre Verwendung f√ºhrt jedoch zus√§tzlich dazu, dass die Werte vorhandener Eigenschaften nicht ge√§ndert werden k√∂nnen.  Sie sind als Eigenschaften gekennzeichnet, in die keine neuen Werte geschrieben werden k√∂nnen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x object.x = 3; // TypeError: Cannot assign to read-only property x</span></span></code> </pre> <br>  Betrachten Sie ein bestimmtes Beispiel.  Wir haben zwei Objekte, von denen jedes einen eindeutigen Wert <code>x</code> .  Dann verbieten wir die Erweiterung des zweiten Objekts: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(b);</code> </pre> <br>  Die Verarbeitung dieses Codes beginnt mit Aktionen, die wir bereits kennen.  Es wird n√§mlich ein √úbergang von der leeren Form des Objekts zur neuen Form vorgenommen, die die Eigenschaft <code>'x'</code> (dargestellt als Entit√§t <code>Smi</code> ).  Wenn wir die Erweiterung von Objekt <code>b</code> verbieten, f√ºhrt dies zu einem besonderen √úbergang zu einer neuen Form, die als nicht erweiterbar markiert ist.  Dieser besondere √úbergang f√ºhrt nicht zum Erscheinen einer neuen Immobilie.  Dies ist in der Tat nur ein Marker. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/2f4/94a/9582f494ae02d57ddc0c17db4749f767.png"></div><br>  <i><font color="#999999">Das Ergebnis der Verarbeitung eines Objekts mit der Object.preventExtensions () -Methode</font></i> <br><br>  Bitte beachten Sie, dass wir das vorhandene Formular nicht einfach mit dem Wert <code>x</code> darin √§ndern k√∂nnen, da es von einem anderen Objekt ben√∂tigt wird, n√§mlich Objekt <code>a</code> , das noch erweiterbar ist. <br><br><h2>  <font color="#3AC1EF">Leistungsproblem reagieren</font> </h2><br>  Lassen Sie uns nun alles sammeln, wor√ºber wir gesprochen haben, und das gewonnene Wissen nutzen, um die Essenz des j√ºngsten React-Leistungsproblems zu verstehen.  Als das React-Team reale Anwendungen profilierte, stellten sie eine merkw√ºrdige Verschlechterung der V8-Leistung fest, die sich auf den React-Kern auswirkte.  Hier ist eine vereinfachte Reproduktion des Problemteils des Codes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(o); oy = <span class="hljs-number"><span class="hljs-number">0.2</span></span>;</code> </pre> <br>  Wir haben ein Objekt mit zwei Feldern, die als <code>Smi</code> Entit√§ten dargestellt werden.  Wir verhindern eine weitere Erweiterung des Objekts und f√ºhren dann eine Aktion aus, die dazu f√ºhrt, dass das zweite Feld im <code>Double</code> werden muss. <br><br>  Wir haben bereits herausgefunden, dass das Verbot der Objekterweiterung zu ungef√§hr der folgenden Situation f√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf7/d6e/3b8/bf7d6e3b8783a06c2923e76aa830f64b.png"></div><br>  <i><font color="#999999">Folgen des Verbots der Objekterweiterung</font></i> <br><br>  Um beide Eigenschaften des Objekts darzustellen, werden <code>Smi</code> Entit√§ten <code>Smi</code> , und der letzte √úbergang ist erforderlich, um die Form des Objekts als nicht erweiterbar zu markieren. <br><br>  Jetzt m√ºssen wir die Darstellung der <code>y</code> Eigenschaft durch <code>Double</code> √§ndern.  Dies bedeutet, dass wir nach einer Form der Trennung suchen m√ºssen.  In diesem Fall ist dies die Form, in der die <code>x</code> Eigenschaft angezeigt wird.  Aber jetzt ist der V8 verwirrt.  Tatsache ist, dass das Trennformular erweiterbar war und das aktuelle Formular als nicht erweiterbar markiert wurde.  V8 wei√ü nicht, wie der √úbergangsprozess in einer √§hnlichen Situation reproduziert werden soll.  Infolgedessen weigert sich der Motor einfach, alles herauszufinden.  Stattdessen wird einfach ein separates Formular erstellt, das nicht mit dem aktuellen Formularbaum verbunden ist und nicht mit anderen Objekten geteilt wird.  Dies ist so etwas wie eine verwaiste Form eines Objekts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abc/581/82d/abc58182dd6e657649af6e934aef04f7.png"></div><br>  <i><font color="#999999">Verwaiste Form</font></i> <br><br>  Es ist leicht zu erraten, dass dies, wenn dies bei vielen Objekten geschieht, sehr schlecht ist.  Tatsache ist, dass dies das gesamte System der V8-Objektformen unbrauchbar macht. <br><br>  Wenn k√ºrzlich ein React-Problem aufgetreten ist, ist Folgendes aufgetreten.  Jedes Objekt der <code>FiberNode</code> Klasse verf√ºgte √ºber Felder, in denen Zeitstempel gespeichert werden sollten, wenn die Profilerstellung aktiviert ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actualStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode();</code> </pre> <br>  Diese Felder (z. B. <code>actualStartTime</code> ) wurden mit 0 oder -1 initialisiert.  Dies f√ºhrte dazu, dass <code>Smi</code> Entit√§ten verwendet wurden, um ihre Bedeutungen <code>Smi</code> darzustellen.  Sp√§ter speicherten sie Echtzeitstempel im Format von Gleitkommazahlen, die von der Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">performance.now () zur√ºckgegeben wurden.</a>  Dies f√ºhrte dazu, dass diese Werte nicht mehr in Form von <code>Smi</code> .  Um diese Felder darzustellen, waren jetzt <code>Double</code> Entit√§ten erforderlich.  Dar√ºber hinaus hat React auch die Erweiterung von Instanzen der <code>FiberNode</code> Klasse verhindert. <br><br>  Zun√§chst k√∂nnte unser vereinfachtes Beispiel in der folgenden Form dargestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/972/e7f/7db972e7fc38fe7ffe228a765a401509.png"></div><br>  <i><font color="#999999">Ausgangszustand des Systems</font></i> <br><br>  Es gibt zwei Instanzen der Klasse, die denselben Baum von √úberg√§ngen der Form von Objekten verwenden.  Genau genommen ist das System der Formen von Objekten in V8 daf√ºr ausgelegt.  Wenn dann die Echtzeitstempel im Objekt gespeichert sind, kann V8 nicht verstehen, wie es die Form der Trennung finden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b6/443/bc9/6b6443bc9ea1c84dcc88ed9b6e9a0a03.png"></div><br>  <i><font color="#999999">V8 ist verwirrt</font></i> <br><br>  V8 weist <code>node1</code> eine neue verwaiste Form zu.  Das gleiche passiert etwas sp√§ter mit dem <code>node2</code> Objekt.  Als Ergebnis haben wir jetzt zwei "verwaiste" Formen, von denen jede nur von einem Objekt verwendet wird.  In vielen realen React-Anwendungen betr√§gt die Anzahl solcher Objekte viel mehr als zwei.  Dies k√∂nnen Zehntausende oder sogar Tausende von Objekten der <code>FiberNode</code> Klasse sein.  Es ist leicht zu verstehen, dass diese Situation die V8-Leistung nicht sehr gut beeinflusst. <br><br>  Gl√ºcklicherweise haben wir dieses Problem in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8 v7.4 behoben</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untersuchen die</a> M√∂glichkeit, die Darstellung von Feldern von Objekten weniger ressourcenintensiv zu gestalten.  Auf diese Weise k√∂nnen wir die verbleibenden Leistungsprobleme l√∂sen, die in solchen Situationen auftreten.  Dank des Fixes verh√§lt sich V8 jetzt in der oben beschriebenen Problemsituation korrekt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/556/574/23e556574e5e5b2a462adc3e983d8f37.png"></div><br>  <i><font color="#999999">Ausgangszustand des Systems</font></i> <br><br>  So sieht es aus.  Zwei Instanzen der <code>FiberNode</code> Klasse verweisen auf ein nicht erweiterbares Formular.  In diesem Fall wird <code>'actualStartTime'</code> als <code>Smi</code> Feld dargestellt.  Wenn die erste Operation zum Zuweisen eines Werts zur Eigenschaft <code>node1.actualStartTime</code> , wird eine neue √úbergangskette erstellt und die vorherige Kette als veraltet markiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/34f/c12/81b34fc121c16ff52582f33cd01e1389.png"></div><br>  <i><font color="#999999">Ergebnisse der Zuweisung eines neuen Werts zur Node1.actualStartTime-Eigenschaft</font></i> <br><br>  Bitte beachten Sie, dass der √úbergang zur nicht erweiterbaren Form jetzt in der neuen Kette korrekt wiedergegeben wird.  Dies ist, worauf das System <code>node2.actualStartTime</code> nachdem der Wert von <code>node2.actualStartTime</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/834/dbf/25c/834dbf25c0436caa37a871d3b985dc5a.png"></div><br>  <i><font color="#999999">Die Ergebnisse der Zuweisung eines neuen Werts zur Eigenschaft node2.actualStartTime</font></i> <br><br>  Nachdem der neue Wert der Eigenschaft <code>node2.actualStartTime</code> zugewiesen wurde, <code>node2.actualStartTime</code> beide Objekte auf das neue Formular, und der veraltete Teil des √úbergangsbaums kann vom Garbage Collector zerst√∂rt werden. <br><br>  Bitte beachten Sie, dass Vorg√§nge zum Markieren der Formen von Objekten als veraltet und deren Migration kompliziert aussehen k√∂nnen.  In der Tat - so wie es ist.  Wir vermuten, dass dies auf echten Websites mehr schadet (in Bezug auf Leistung, Speichernutzung, Komplexit√§t) als n√ºtzt.  Insbesondere - nachdem wir im Fall der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeigerkomprimierung</a> diesen Ansatz nicht mehr verwenden k√∂nnen, um <code>Double</code> Felder in Form von in Objekte eingebetteten Werten zu speichern.  Infolgedessen hoffen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> den Mechanismus der Veralterung von V8-Objektformen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollst√§ndig aufzugeben</a> und diesen Mechanismus selbst √ºberfl√ºssig zu machen. <br><br>  Es ist zu beachten, dass das React-Team dieses Problem selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gel√∂st</a> hat und sichergestellt hat, dass die Felder in den Objekten der <code>FiberNodes</code> Klasse urspr√ºnglich durch doppelte Werte dargestellt wurden: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-comment"><span class="hljs-comment">//     `Double`   .    this.actualStartTime = Number.NaN;    //       ,  :    this.actualStartTime = 0;    Object.preventExtensions(this);  } } const node1 = new FiberNode(); const node2 = new FiberNode();</span></span></code> </pre> <br>  Hier kann anstelle von <code>Number.NaN</code> jeder Gleitkommawert verwendet werden, der nicht in den <code>Smi</code> Bereich passt.  Zu diesen Werten geh√∂ren 0,000001, <code>Number.MIN_VALUE</code> , -0 und <code>Infinity</code> . <br><br>  Es ist erw√§hnenswert, dass das in React beschriebene Problem spezifisch f√ºr V8 war und dass Entwickler beim Erstellen von Code nicht danach streben m√ºssen, ihn basierend auf einer bestimmten Version einer bestimmten JavaScript-Engine zu optimieren.  Es ist jedoch n√ºtzlich, etwas durch Optimieren des Codes beheben zu k√∂nnen, falls die Ursachen einiger Fehler in den Funktionen der Engine liegen. <br><br>  Es sei daran erinnert, dass es in den Eingeweiden von JS-Motoren viele allerlei erstaunliche Dinge gibt.  Der JS-Entwickler kann all diesen Mechanismen nach M√∂glichkeit helfen, ohne dieselben Variablenwerte unterschiedlichen Typs zuzuweisen.  Beispielsweise sollten Sie numerische Felder nicht mit <code>null</code> initialisieren, da dies alle Vorteile der Beobachtung der Felddarstellung zunichte macht und die Lesbarkeit des Codes verbessert: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ! class Point {  x = null;  y = null; } const p = new Point(); px = 0.1; py = 402;</span></span></code> </pre> <br>  Mit anderen Worten - schreiben Sie lesbaren Code, und die Leistung wird von selbst kommen! <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir die folgenden wichtigen Punkte untersucht: <br><br><ul><li>  JavaScript unterscheidet zwischen "primitiven" und "Objekt" -Werten, und die Art der Ergebnisse kann nicht als vertrauensw√ºrdig eingestuft werden. </li><li>  Sogar Werte mit demselben JavaScript-Typ k√∂nnen im Darm der Engine auf unterschiedliche Weise dargestellt werden. </li><li>  V8 versucht, den besten Weg zu finden, um jede Eigenschaft des in JS-Programmen verwendeten Objekts darzustellen. </li><li>  In bestimmten Situationen f√ºhrt V8 Operationen zum Markieren der Formulare von Objekten als veraltet durch und f√ºhrt die Migration von Formularen durch.  Einschlie√ülich - implementiert √úberg√§nge, die mit dem Verbot der Erweiterung von Objekten verbunden sind. </li></ul><br>  Basierend auf dem Vorstehenden k√∂nnen wir einige praktische JavaScript-Programmiertipps bereitstellen, die zur Verbesserung der Codeleistung beitragen k√∂nnen: <br><br><ul><li>  Initialisieren Sie Ihre Objekte immer auf die gleiche Weise.  Dies tr√§gt zur effektiven Arbeit mit Objektformen bei. </li><li>  W√§hlen Sie verantwortungsbewusst die Anfangswerte f√ºr die Felder von Objekten aus.  Dies hilft den JavaScript-Engines bei der Auswahl, wie diese Werte intern dargestellt werden sollen. </li></ul><br>  <b>Liebe Leser!</b>  Haben Sie Ihren Code jemals basierend auf den internen Funktionen bestimmter JavaScript-Engines optimiert? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467249/">https://habr.com/ru/post/de467249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467237/index.html">Erh√∂hen Sie Ihren DNS-over-HTTPS-Server</a></li>
<li><a href="../de467239/index.html">Der Unterschied zwischen Data Scientist und einem Teenager in einem Sportwagen</a></li>
<li><a href="../de467241/index.html">ROS LKW Wagen. Teil 4. Erstellen einer Robotersimulation mit den Editoren rviz und pavillon</a></li>
<li><a href="../de467245/index.html">Dmitry Matskevich, Dbrain: √ºber Unternehmertum als geistige Behinderung, KI und emotionale Sicherheit</a></li>
<li><a href="../de467247/index.html">Eine Geschichte √ºber V8, React und einen Leistungsabfall. Teil 1</a></li>
<li><a href="../de467251/index.html">Geiseln COBOL und Math. Teil 1</a></li>
<li><a href="../de467253/index.html">Geiseln COBOL und Math. Teil 2</a></li>
<li><a href="../de467255/index.html">Drei h√§ufige Sicherheitsfehler, √ºber die jeder Reaktionsentwickler Bescheid wissen sollte</a></li>
<li><a href="../de467257/index.html">Lagern Sie nicht alle Eier gleichzeitig in einem Korb</a></li>
<li><a href="../de467259/index.html">DPI (SSL Inspection) widerspricht der Bedeutung von Kryptografie, wird jedoch von Unternehmen implementiert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>