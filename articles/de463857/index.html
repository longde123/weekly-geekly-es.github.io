<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∏Ô∏è üíª ‚õπÔ∏è Julia: benutzerdefinierte Typen üëºüèº üçÄ üêí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir erw√§gen, dem Julia-Programm einen benutzerdefinierten Datentyp hinzuzuf√ºgen und Standardfunktionen zu √ºberladen, um beque...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia: benutzerdefinierte Typen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463857/"><p>  In diesem Artikel werden wir erw√§gen, dem Julia-Programm einen benutzerdefinierten Datentyp hinzuzuf√ºgen und Standardfunktionen zu √ºberladen, um bequem mit dem neuen Typ arbeiten zu k√∂nnen. </p><a name="habracut"></a><br><h2 id="chto-takoe-polzovatelskiy-tip">  Was ist ein benutzerdefinierter Typ? </h2><br><p>  Ein schreckliches Geheimnis - die Grenze zwischen den Datentypen "Benutzer" und "integriert" in Julia fehlt praktisch.  In jedem Julia-Programm k√∂nnen Sie Ihre eigenen Datentypen definieren, und die Arbeit mit ihnen unterscheidet sich kaum von der Arbeit mit den integrierten Daten, weder hinsichtlich des Schreibens von Code noch hinsichtlich der Geschwindigkeit der Ausf√ºhrung dieses Codes (Hallo, Python).  Eingabedatentypen k√∂nnen entweder primitiv oder zusammengesetzt sein.  Letztere werden ebenfalls in abstrakte und konkrete Typen unterteilt. </p><br><p>  Weiter werden wir ein Beispiel f√ºr Verbundbetontypen betrachten, da  Bestimmte Objekte im Speicher sind bestimmte Typen, und abstrakte Objekte werden nur zum Erstellen einer Hierarchie ben√∂tigt. </p><br><p> Zusammengesetzte Typen werden durch die Schl√ºsselw√∂rter <code>struct</code> und <code>mutable struct</code> .  Im ersten Fall wird ein unver√§nderlicher Typ erstellt: </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#    x  y struct Point x y end</span></span></code> </pre> <br><p>  Objekte vom Typ <code>Point</code> unver√§nderlich, d.h.  Der Feldwert in einem einmal erstellten Objekt kann nicht ge√§ndert werden. </p><br><pre> <code class="julia hljs">julia&gt; p = Point(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) Point(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) julia&gt; px <span class="hljs-number"><span class="hljs-number">2</span></span> julia&gt; py <span class="hljs-number"><span class="hljs-number">3</span></span> julia&gt; px = <span class="hljs-number"><span class="hljs-number">4</span></span> ERROR: setfield! <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> of <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Point cannot be changed</code> </pre> <br><p>  Sie k√∂nnen jedoch einen ver√§nderlichen Typ erstellen: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> MutablePoint x y <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; mp = MutablePoint(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) MutablePoint(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) julia&gt; mp.y = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> julia&gt; mp MutablePoint(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Aus Effizienzgr√ºnden k√∂nnen den Strukturfeldern und der Struktur selbst Typanmerkungen hinzugef√ºgt werden.  Zum Beispiel: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ParametricPoint{T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>} x::T y::T <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Dies bedeutet, dass der Typ <code>ParametricPoint</code> durch den Typ <code>T</code> <code>ParametricPoint</code> und dass die Felder <code>x</code> und <code>y</code> nun Werte desselben Typs <code>T</code>  Das Verhalten wird wie folgt sein: </p><br><pre> <code class="julia hljs">julia&gt; ParametricPoint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ParametricPoint{<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>}(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) julia&gt; ParametricPoint{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>}(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ParametricPoint{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>}(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) julia&gt; ParametricPoint{<span class="hljs-built_in"><span class="hljs-built_in">Rational</span></span>}(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ParametricPoint{<span class="hljs-built_in"><span class="hljs-built_in">Rational</span></span>}(<span class="hljs-number"><span class="hljs-number">1</span></span>//<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>//<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment"># :        T julia&gt; ParametricPoint{Int}(1, 3.4) ERROR: InexactError: Int64(3.4) # :    julia&gt; ParametricPoint(1, 1.0) ERROR: MethodError: no method matching Point(::Int64, ::Float64) # :  T      julia&gt; ParametricPoint{Any}(1,1) ERROR: TypeError: in Point, in T, expected T&lt;:Real, got Type{Any}</span></span></code> </pre> <br><p>  Schauen wir uns als n√§chstes ein etwas komplexeres Beispiel eines Containertyps an, um zu sehen, welche Methoden in der Standardbibliothek f√ºr die Arbeit mit solchen Typen enthalten sind. </p><br><h2 id="dvustoronnyaya-ochered">  Zwei-Wege-Warteschlange </h2><br><p>  Wir werden aus Knoten vom Typ <code>DequeNode</code> eine <code>DequeNode</code> Warteschlange <code>DequeNode</code> , die einen Datensatz und Links zu den vorherigen und n√§chsten Elementen der Warteschlange enth√§lt.  Der Typ <code>DequeNode</code> muss ver√§nderbar sein, weil  Links m√ºssen neu geschrieben werden. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> DequeNode{T} data::T prev::DequeNode{T} next::DequeNode{T} <span class="hljs-comment"><span class="hljs-comment">#   -       function DequeNode{T}() where T node = new{T}() node.prev = node.next = node return node end #     function DequeNode{T}(x) where T node = new{T}() node.data = x node.prev = node.next = node return node end end</span></span></code> </pre> <br><p>  In diesem Fall werden interne Konstruktoren ben√∂tigt, da Sie beim Erstellen eines Objekts standardm√§√üig die Werte aller Felder mit Argumenten √ºbergeben m√ºssen.  Da der Typ selbst referenziert ist, kann ein Standardkonstruktor das allererste Objekt dieses Typs nicht erstellen.  Daher erstellen wir spezielle Konstruktoren, die einen Warteschlangenknoten erstellen, der auf sich selbst verweist. </p><br><p>  Die Warteschlange selbst kann als fiktiver "Eingabeknoten" dargestellt werden, der keine Daten enth√§lt.  Der <code>next</code> Link verweist auf das erste Element der Warteschlange und auf das letzte.  Bei einer leeren Warteschlange verweisen beide Links auf den Eingabeknoten.  Eine solche Organisation vereinfacht die Verfahren zum Hinzuf√ºgen und Entfernen von Knoten. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Deque{T} entry::DequeNode{T} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Deque{T}() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T = Deque{T}(DequeNode{T}()) Deque() = Deque{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>}()</code> </pre> <br><p>  F√ºr die Struktur der Warteschlange selbst ist kein interner Konstruktor mehr erforderlich. </p><br><h3 id="dobavlenie-elementov">  Elemente hinzuf√ºgen </h3><br><p>  Die Standardprozeduren f√ºr eine Warteschlange bestehen darin, am Anfang und am Ende ein Element hinzuzuf√ºgen und Elemente am Anfang und am Ende zu extrahieren.  F√ºr diese Prozeduren verf√ºgt die Standardbibliothek bereits √ºber Funktionen, zu denen Sie nur Methoden hinzuf√ºgen m√ºssen, um mit einem anderen Typ zu arbeiten: </p><br><ul><li>  <code>push!(collection, element)</code> - f√ºge der Sammlung ein Element hinzu (f√ºr eine bestellte Sammlung - am Ende) </li><li>  <code>pushfirst!(collection, element)</code> - <code>pushfirst!(collection, element)</code> am Anfang einer geordneten Sammlung ein Element hinzu </li><li>  <code>pop!(collection)</code> - l√∂scht einen Artikel aus der Sammlung (f√ºr eine bestellte Sammlung - vom Ende) </li><li>  <code>popfirst!(collection)</code> - Entfernen Sie den ersten Artikel aus einer bestellten Sammlung </li></ul><br><p>  Alle diese Funktionen befinden sich im Basismodul, und Sie m√ºssen neue Methoden hinzuf√ºgen.  Zus√§tzlich schreiben wir eine Funktion, um zu √ºberpr√ºfen, ob die Sammlung nicht leer ist - <code>Base.isempty(collection)</code> . </p><br><pre> <code class="julia hljs">Base.isempty(deq::Deque) = deq.entry.prev ‚â° deq.entry <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.push!(deq::Deque{T}, elt) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T tail = deq.entry.prev new_item = DequeNode{T}(elt) new_item.prev, new_item.next = tail, deq.entry tail.next = deq.entry.prev = new_item <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deq <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.pushfirst!(deq::Deque{T}, elt) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T head = deq.entry.next new_item = DequeNode{T}(elt) new_item.prev, new_item.next = deq.entry, head head.prev = deq.entry.next = new_item <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deq <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.pop!(deq::Deque) !isempty(deq) || throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"deque must be non-empty"</span></span>)) last = deq.entry.prev last.prev.next = deq.entry deq.entry.prev = last.prev <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last.data <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.popfirst!(deq::Deque) !isempty(deq) || throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"deque must be non-empty"</span></span>)) first = deq.entry.next first.next.prev = deq.entry deq.entry.next = first.next <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.data <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Die Funktion <code>push!()</code> Macht es fast trivial, einen Warteschlangenkonstruktor basierend auf einer beliebigen Sammlung zu schreiben: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Deque(itr) d = Deque{eltype(itr)}() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> elt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itr push!(d, elt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#        Deque(args...) = Deque(args)</span></span></code> </pre> <br><p>  Jetzt kann der neue Typ fast als Warteschlange verwendet werden, wenn wir nur Operationen hinzuf√ºgen und entfernen m√ºssen und keine Funktion wie <code>peek()</code> ben√∂tigen (sehen Sie sich das Element im Kopf oder Ende der Warteschlange an, ohne es zu entfernen).  F√ºr den zerst√∂rungsfreien Zugriff auf Elemente ist es zweckm√§√üig, die Iterationsfunktion √ºber den Container zu definieren. </p><br><h3 id="iterirovanie">  Iteration </h3><br><p>  Julia unterst√ºtzt das Konzept von Iteratoren zum Durchlaufen von Containerelementen.  F√ºr die Iteration m√ºssen Sie eine einzelne Funktion definieren - <code>iterate(container, state)</code> , wobei <code>state</code> den aktuellen Status des Iterators bestimmt.  Insbesondere ist das Konstrukt <code>for x in collection</code> syntaktischer Zucker f√ºr so etwas: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextstate = iterate(collection) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nextstate ‚â¢ <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> (x, state) = nextstate &lt;- &gt; nextstate = iterate(collection, state) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Die Funktion <code>iterate()</code> verwendet einen Container und einen ‚ÄûIteratorstatus‚Äú als Argument und gibt entweder ein Tupel aus dem Containerelement und dem n√§chsten Iteratorstatus zur√ºck oder <code>nothing</code> wenn der Container beendet wurde. <br>  F√ºr eine Warteschlange ist es logisch, den Warteschlangenknoten, den die Iteration erreicht hat, als "Status" zu verwenden: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.iterate(deq::Deque{T}, state::DequeNode{T}=deq.entry) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T nextstate = state.next nextstate ‚â° deq.entry ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : (nextstate.data, nextstate) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Jetzt k√∂nnen die Elemente der Warteschlange mit einer <code>for</code> Schleife sortiert werden: </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Deque(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) println(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  Ein gro√ües Plus ist, dass viele der Funktionen der Standard-Julia-Bibliothek √ºber verallgemeinerte Schnittstellen geschrieben werden, insbesondere √ºber Iteration.  Somit wird automatisch ermittelt, ob ein Element automatisch zu einem Container geh√∂rt: </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ‚àà Deque(<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-literal"><span class="hljs-literal">true</span></span> julia&gt; <span class="hljs-number"><span class="hljs-number">100</span></span> ‚àà Deque(-<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Wir finden auch, dass die <code>first()</code> -Methode, die das erste Element der Sammlung zur√ºckgibt, zu funktionieren begann.  Um das Bild zu vervollst√§ndigen, erg√§nzen wir die <code>last()</code> -Methode, um das letzte Element zu erhalten und in umgekehrter Reihenfolge zu iterieren: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.iterate(r::Base.Iterators.Reverse{Deque{T}}, state::DequeNode{T}=r.itr.entry) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T nextstate = state.prev nextstate ‚â° r.itr.entry ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : (nextstate.data, nextstate) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.last(deq::Deque) isempty(deq) &amp;&amp; throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"deque must be non-empty"</span></span>)) deq.entry.prev.data <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Iterators.reverse(Deque(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>)) println(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Die Warteschlangenschnittstelle als Datenstruktur ist nun vollst√§ndig definiert </p><br><div class="scrollable-table"><table><thead><tr><th>  Bedienung </th><th>  Funktionsname </th></tr></thead><tbody><tr><td>  am Ende einf√ºgen </td><td> <code>push!(deque, element)</code> </td> </tr><tr><td>  Einf√ºgen an den Anfang </td><td> <code>pushfirst!(deque, element)</code> </td> </tr><tr><td>  Entfernung von Anfang an </td><td>  <code>popfirst!(deque)</code> (gibt das gel√∂schte Element zur√ºck) </td></tr><tr><td>  Entfernung vom Ende </td><td>  <code>pop!(deque)</code> (gibt das gel√∂schte Element zur√ºck) </td></tr><tr><td>  Zeigen Sie das erste Element an </td><td> <code>first(deque)</code> </td> </tr><tr><td>  letzten Artikel anzeigen </td><td> <code>last(deque)</code> </td> </tr></tbody></table></div><br><h3 id="raspechatka-struktury">  Druckstruktur </h3><br><p>  Obwohl die Warteschlange vollst√§ndig als Datenstruktur fungiert, stellt sie beim Drucken immer noch ein formloses Durcheinander dar: </p><br><pre> <code class="julia hljs">julia&gt; Deque() Deque{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>}(DequeNode{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>}(<span class="hljs-comment"><span class="hljs-comment">#undef, DequeNode{Any}(#= circular reference @-1 =#), DequeNode{Any}(#= circular reference @-1 =#)))</span></span></code> </pre> <br><p>  F√ºgen Sie eine Methode hinzu, um die Warteschlange in einer menschlicheren Form zu drucken.  Die Ausgabe der Struktur an das Terminal wird von der Funktion <code>Base.show()</code> gesteuert, die wir √ºberladen werden: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.show(io::<span class="hljs-built_in"><span class="hljs-built_in">IO</span></span>, deq::Deque{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T print(io, <span class="hljs-string"><span class="hljs-string">"Deque{"</span></span>, T, <span class="hljs-string"><span class="hljs-string">"}("</span></span>) next = iterate(deq) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next ‚â¢ <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> item, state = next show(io, item) next = iterate(deq, state) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next ‚â¢ <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> item, state = next print(io, <span class="hljs-string"><span class="hljs-string">", "</span></span>) show(io, item) next = iterate(deq, state) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> print(io, <span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#        julia&gt; Deque(1:5) Deque{Int64}(1, 2, 3, 4, 5) #       julia&gt; Deque(Deque(), Deque(), Deque()) Deque{Deque{Any}}(Deque{Any}(), Deque{Any}(), Deque{Any}())</span></span></code> </pre> <br><h3 id="dostup-i-izmenenie-po-indeksu">  Zugriff und √Ñnderung nach Index </h3><br><p>  Grunds√§tzlich kann eine Warteschlange auch als Container mit Zugriff per Index verwendet werden.  Das Abrufen und √Ñndern eines Werts nach Index wird durch die <code>setindex!()</code> <code>getindex()</code> und <code>setindex!()</code> .  Wir implementieren die notwendigen Methoden f√ºr die Warteschlange. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.getindex(deq::Deque, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>) i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) next = iterate(deq) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:i-<span class="hljs-number"><span class="hljs-number">1</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) _, state = next next = iterate(deq, state) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.setindex!(deq::Deque, val, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>) i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) next = iterate(deq) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:i-<span class="hljs-number"><span class="hljs-number">1</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) _, state = next next = iterate(deq, state) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> record = next[<span class="hljs-number"><span class="hljs-number">2</span></span>] record.data = val <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Es ist auch n√ºtzlich, die Funktion zum Einf√ºgen eines Elements an einer beliebigen Stelle <code>insert!()</code> Und ein Element von einer beliebigen Position zu entfernen: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.insert!(deq::Deque{T}, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>, val) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) next = iterate(deq) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:i-<span class="hljs-number"><span class="hljs-number">1</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) _, state = next next = iterate(deq, state) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> push!(deq, val) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> record = next[<span class="hljs-number"><span class="hljs-number">2</span></span>] new_node = DequeNode{T}(val) new_node.prev, new_node.next = record.prev, record record.prev = record.prev.next = new_node deq <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.deleteat!(deq::Deque, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>) i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) next = iterate(deq) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:i-<span class="hljs-number"><span class="hljs-number">1</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) _, state = next next = iterate(deq, state) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next ‚â° <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">BoundsError</span></span>(deq, i)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> record = next[<span class="hljs-number"><span class="hljs-number">2</span></span>] record.prev.next, record.next.prev = record.next, record.prev <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h3 id="prochee">  Andere </h3><br><p>  Wie bereits erw√§hnt, werden eine Reihe von Funktionen der Standardbibliothek mithilfe von Iteratoren geschrieben, sodass sie automatisch mit jedem Typ arbeiten k√∂nnen, f√ºr den die Funktion <code>iterate()</code> definiert ist.  Insbesondere funktionieren Funktionen wie <code>map()</code> , <code>collect()</code> und Reduktionsmethoden wie <code>sum()</code> oder <code>minimum()</code> . <br>  Eine Funktion zum Ermitteln der L√§nge einer Warteschlange kann beispielsweise folgenderma√üen geschrieben werden: </p><br><pre> <code class="julia hljs">Base.length(deq::Deque) = sum(x-&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>, deq) julia&gt; length(Deque(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>)) <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre> <br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Wie Sie sehen, ist es sehr einfach, in Julia einen eigenen Datentyp zu erstellen und damit bequem zu arbeiten.  Aufgrund der Verwendung der verallgemeinerten Programmierung in der Standardbibliothek reicht es normalerweise aus, mehrere Grundfunktionen zu definieren, und einige abh√§ngige Funktionen funktionieren automatisch.  Wenn Sie also <code>push!(container, element)</code> , um ein einzelnes Element hinzuzuf√ºgen, k√∂nnen Sie feststellen, dass <code>push!(container, elements...)</code> eine beliebige Anzahl von Argumenten hinzuf√ºgt.  Nachdem wir einen Iterator definiert haben, erhalten wir im Allgemeinen automatisch alle Funktionen der Standardbibliothek f√ºr die Arbeit mit einem abstrakten Container. </p><br><p>  Viel Spa√ü beim Hacken! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463857/">https://habr.com/ru/post/de463857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463847/index.html">Zu was Faulheit f√ºhrt oder wie man einen psd-Parser schreibt und was daraus werden kann</a></li>
<li><a href="../de463849/index.html">Wochenendlesung: 65 Artikel √ºber Streaming, die Geschichte des alten "musikalischen Eisens" und die Audiotechnologie</a></li>
<li><a href="../de463851/index.html">Wie leben die Statistiken zu Internet und Domain Name Server zu Hause?</a></li>
<li><a href="../de463853/index.html">Wie ich Qiwi ohne Programmierkenntnisse gehackt habe</a></li>
<li><a href="../de463855/index.html">Neuralink als Mittel zur Unterst√ºtzung gel√§hmter Menschen und als Mittel zur Bek√§mpfung der b√∂sen KI</a></li>
<li><a href="../de463859/index.html">Leg dich nicht mit NULL an</a></li>
<li><a href="../de463861/index.html">Warum dieses Jahr zum 404 Festival gehen? Acht Gr√ºnde</a></li>
<li><a href="../de463871/index.html">Was sind die Arten von Scrum-Zeremonien und ihre Best Practices?</a></li>
<li><a href="../de463873/index.html">Gestorbener Nobelpreistr√§ger Carey Mullis - Erfinder der DNA-Polymerasekettenreaktion</a></li>
<li><a href="../de463875/index.html">Intel Ice Lake. 10 nm - zu den Massen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>