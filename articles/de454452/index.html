<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏽 📗 😽 Wir zeigen Inhalte auf dem erkannten Bild nach bestimmten Regeln an 🌵 👨🏼‍🔧 👨🏻‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie eine technische Aufgabe lesen und Fristen für die Implementierung festlegen, unterschätzen Sie manchmal den Zeit- und Arbeitsaufwand für die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir zeigen Inhalte auf dem erkannten Bild nach bestimmten Regeln an</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p>  Wenn Sie eine technische Aufgabe lesen und Fristen für die Implementierung festlegen, unterschätzen Sie manchmal den Zeit- und Arbeitsaufwand für die Lösung eines bestimmten Problems.  Es kommt vor, dass ein Punkt, der durch die Zeit pro Woche geschätzt wird, nach einer Stunde ausgeführt wird und manchmal auch umgekehrt.  Aber in diesem Artikel geht es nicht darum.  Dies ist eine Demonstration der Entwicklung einer Lösung für ein Problem.  Von der Gründung bis zur Umsetzung. </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br>
<h1 id="ispolzuemye-terminy">  Verwendete Begriffe </h1><br><ul><li><p>  Markierung oder Markierung - Ein in die AR-Engine geladenes Bild, das von der Kamera des Geräts (Tablet oder Smartphone) erkannt wird und eindeutig identifiziert werden kann </p><br></li><li><p>  Gefunden - Markierungsstatus, als er im Sichtfeld der Kamera erkannt wurde </p><br></li><li><p>  Lost - Markierungsstatus, als er aus der Kameraansicht verloren ging </p><br></li><li><p>  Es kann angezeigt werden - wenn der Marker gefunden wird, zeigen wir den an den Marker angehängten Inhalt an </p><br></li><li><p>  Kann nicht angezeigt werden - wenn wir den Marker finden, zeigen Sie den Inhalt nicht an - Inhalt, der an den Marker angehängt ist - jedes Objekt (3D-Modell, Sprite, Partikelsystem usw.), das an den Marker angehängt werden kann und dementsprechend angezeigt wird auf dem Bildschirm, wenn eine Markierung gefunden wird </p><br></li><li><p>  Markieren, markieren, gefunden, verloren - die Grundzustände aller Engines, die Erkennungsfunktionen bieten </p><br></li><li><p>  Es kann angezeigt werden und kann nicht angezeigt werden - der Status, der zur Lösung dieses Problems verwendet wird </p><br><p>  <strong>Ein Beispiel:</strong> </p><br><ul><li>  Anwendung herunterladen =&gt; Alle heruntergeladenen Marken sind erkennbar </li><li>  Wir versuchen zu erkennen =&gt; der Zustand des Markers ändert sich in "gefunden" </li><li>  Wenn der Marker angezeigt werden kann =&gt; Geben Sie an, dass der Marker „gefunden“ wurde, und wir zeigen das an den Marker angehängte Modell an </li><li>  Wenn der Marker nicht angezeigt werden kann =&gt; wird der Status des Markers "gefunden", aber das angehängte Modell wird nicht angezeigt </li><li>  Die Marke ist aus dem Sichtfeld der Kamera verschwunden =&gt; Wir ändern den Status in "verloren". </li></ul><br></li></ul><br><h1 id="vvedenie">  Einführung </h1><br><p>  Es gibt eine große Postkarte in der Größe eines A4-Blattes.  Es ist in 4 gleiche Teile unterteilt (Format eines Teils A5). Auf jedem dieser Teile befindet sich: </p><br><ul><li>  Eine volle Eckmarke (1) </li><li>  Eine Hälfte der unteren Seitenmarkierung (5) </li><li>  Eine Hälfte der oberen Seitenmarkierung (8) </li><li>  Quarter Center Mark (9) </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="Bild"></p><br><p> Wenn Sie mit Erkennungs-Engines wie Vuforia gearbeitet haben, wissen Sie wahrscheinlich, dass es keine „Erkennungsqualität“ gibt.  Die Marke wird entweder erkannt oder nicht erkannt.  Wenn die Engine die Marke "sieht", ändert sie den Status in " <code>Find</code> und die <code>OnSuccess()</code> -Methode wird <code>OnSuccess()</code> . Wenn sie "verloren" wird, ändert sich der Status in " <code>Lost</code> und die <code>OnLost()</code> -Methode wird <code>OnLost()</code> .  Dementsprechend ergab sich aus den vorhandenen Bedingungen und Eingabedaten eine Situation, in der es möglich war, mit einem Teil der Karte (einem halben oder einem Viertel) die Marke zu erkennen. </p><br><p>  Die Sache ist, dass entsprechend der technischen Aufgabe eine schrittweise Freischaltung der Charaktere geplant war.  In dieser Situation ist ein schrittweises Entsperren möglich, da jedoch keine Personen versuchen, ein Viertel oder die Hälfte der Marke zu erkennen. </p><br><h1 id="formulirovka-zadachi">  Aufgabenstellung </h1><br><p>  Es ist notwendig, Logik in Form von Programmcode zu implementieren, der das schrittweise Entsperren des an die Markierungen angehängten Inhalts gewährleistet.  Aus der Position der Elemente auf der Karte ist bekannt, dass die Markierungen 1, 2, 3, 4 anfänglich zur Anzeige verfügbar sind. </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="Bild"></p><br><p>  Wenn der Inhalt gelesen und auf 2 Markern angezeigt wurde, z. B. 2 und 3, können Sie den Inhalt auf Marker 6 anzeigen. Wenn Marker 1 noch nicht gelesen wurde, ist der Zugriff auf Marker 5 geschlossen.  Weiter analog.  Wir geben die Erlaubnis, Inhalte nur an Seitenmarkierungen anzuzeigen, wenn wir benachbarte Eckmarkierungen gelesen haben. </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="Bild"></p><br><p>  Wenn Marker von 1 bis 8 verfügbar sind und gefunden werden, öffnen Sie den Inhalt auf Marker 9 zur Anzeige. Jeder Marker hat 2 Zustände - der Inhalt ist verfügbar und nicht für die Anzeige verfügbar, für die das Feld <code>public bool IsActive;</code> des <code>public bool IsActive;</code> verantwortlich ist <code>public bool IsActive;</code> </p><br><p>  Es ist sofort klar, dass dies entweder eine Zustandsmaschine mit einem Übergang zwischen Zuständen oder eine Implementierung des "Zustands" -Musters sein sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Das Ergebnis war nicht das eine, nicht das andere.  Ich kann nicht sagen, dass dies eine Krücke ist, da die Lösung die Anforderungen am Anfang des Artikels vollständig erfüllt.  Aber du kannst mit mir streiten. </p></div></div><br><p>  In diesem Zusammenhang gebe ich Ihnen die Möglichkeit, selbst über mögliche Lösungen und Implementierungen dieser Aufgabe nachzudenken.  Ich brauchte ungefähr 5 Stunden, um das Bild der Entscheidung zu erkennen und in meinem Kopf zu fixieren. </p><br><p>  Aus Gründen der Übersichtlichkeit habe ich ein Video aufgenommen, auf dem das Endergebnis des Algorithmus (wenn Sie es so nennen können) bereits erfasst ist. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu">  Lösungsansätze </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1. Von den Eckmarkierungen zur Mitte </h2><br><p>  Das erste, was mir in den Sinn kam, war die Darstellung der Wechselwirkungen zwischen den Markern von der Ecke bis zur Mitte.  In grafischer Form sieht es so aus: </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="Bild"></p><br><p>  Die Probleme: </p><br><ol><li>  Wie bestimme ich, welches Seitenetikett den Status ändern soll?  Der links oder rechts?  Wir zwingen jeden Marker auch dazu, über die Existenz eines zentralen Markers „Bescheid zu wissen“. </li><li>  Es ist erforderlich, nicht offensichtliche Abhängigkeiten aus der Kategorie hinzuzufügen: Die Seitenmarkierung abonniert das Eckmarkierungsereignis IsChangedEventCallback (). Für die zentrale Markierung müssen ähnliche Aktionen ausgeführt werden. </li><li>  Wenn wir jeden Markertyp als Entität betrachten, leiten wir in der Hierarchie dieser Entitäten den Befehl zum Ändern des Status von unten nach oben weiter.  Dies ist nicht sehr gut, da wir uns eng an die Zahl, in diesem Fall an Winkelmarkierungen, binden und die Skalierbarkeit verlieren. </li></ol><br><p>  Ich konnte die obige Lösung aufgrund der vielen Randfälle und der Komplexität der Wahrnehmung nicht in meinen Kopf setzen und änderte den Ansatz zur Auswahl eines Markers, von dem sich die Abhängigkeiten zu verbreiten beginnen. </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2. Seitenteile kennen sich mit Mittel und Ecke aus </h2><br><p>  Beim Nachdenken über die Lösung von Absatz 3 des vorherigen Ansatzes kam die Idee, den Markertyp zu ändern, ab dem sich die Zustände anderer Marker zu ändern beginnen.  Als Hauptseitenmarkierungen wurden genommen.  In diesem Szenario sieht die Kommunikation (Abhängigkeiten) folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="Bild"></p><br><p>  Ab hier wird sofort klar, dass die Verbindungen von der lateralen zur zentralen überflüssig sind, da der laterale Marker nichts über den zentralen Marker wissen muss, weshalb dieser Ansatz sofort in den endgültigen umgewandelt wurde. </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3. Der zentrale kennt jeden, die seitlichen kennen die Ecke </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="Bild"></p><br><p>  Die endgültige Lösung ist, wenn der Seitenmarker über die Ecken Bescheid weiß, die Ecken „ihr Leben leben“ und der zentrale über den Zustand aller Markierungen Bescheid weiß. </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="Bild"></p><br><p>  Das Arbeiten mit der Postkartenansicht ist nicht sehr bequem.  Die Beziehungen zwischen Entitäten sehen nicht klar genug aus, um dies einfach in Code umzuwandeln.  Ein Versuch, in Form eines Binärbaums zu interpretieren, kann zu Mehrdeutigkeiten führen.  Hier wird jedoch eine der Eigenschaften des Binärbaums verletzt, sodass die Mehrdeutigkeit sofort verschwindet.  Daraus können wir schließen, dass diese Darstellung eindeutig interpretiert und verwendet werden kann, um die Lösung des Problems grafisch darzustellen.  Basierend auf diesen Schlussfolgerungen werden wir die Graphnotation verwenden, nämlich: </p><br><ul><li>  Winkelmarkierung - Winkelknoten (Stufe 3) </li><li>  Seitenmarkierung - Seitenknoten (Stufe 2) </li><li>  Center Marker - Center Node (Stufe 1) </li></ul><br><p>  Vorteile: </p><br><ol><li>  Die Abhängigkeiten zwischen den Markern sind offensichtlich und offensichtlich. </li><li>  Jede der Ebenen kann in Form von 3 Entitäten dargestellt werden, von denen jede aus grundlegenden Teilen besteht, deren Ergänzungen jedoch jeder der Ebenen inhärent sind </li><li>  Zum Erweitern müssen Sie nur einen neuen Knotentyp mit eigenen Merkmalen hinzufügen </li><li>  Diese Lösung ist in einem OO-Stil (objektorientiert) leicht vorstellbar </li></ol><br><h1 id="realizaciya">  Implementierung </h1><br><h2 id="bazovye-suschnosti">  Basisentitäten </h2><br><p>  Erstellen wir eine Schnittstelle, die die Elemente enthält, die jeder Entität inhärent sind (Name, Status): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Als nächstes beschreiben wir die Essenz jedes Knotens: </p><br><ul><li>  <strong>CornerNode</strong> - ein <strong>Winkelknoten</strong> .  Implementieren <code>INode</code> einfach die <code>INode</code> Schnittstelle: </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Warum ist <code>IsActive = true</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  Unter den Bedingungen des Problems steht der Inhalt von Eckmarkierungen zunächst zur Erkennung zur Verfügung. </p></div></div><br><ul><li>  <strong>SideNode</strong> - ein <strong>Seitenknoten</strong> .  Wir implementieren die <code>INode</code> Schnittstelle, fügen jedoch die <code>RightCornerNode</code> <code>LeftCornerNode</code> und <code>RightCornerNode</code> .  Somit behält der Seitenknoten seinen Zustand in sich und weiß nur über die Existenz von Seitenknoten Bescheid. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong> ist der zentrale Knoten.  Wie in den vorherigen implementieren wir <code>INode</code> .  Fügen Sie ein Feld vom Typ <code>List&lt;INode&gt;</code> . </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard">  Opencard-Klasse </h2><br><h3 id="privatnye-metody-i-polya">  Private Methoden und Felder </h3><br><p>  Nachdem wir alle Elemente der Karte erstellt haben (alle Arten von Markierungen), können wir beginnen, die Essenz der Karte selbst zu beschreiben.  Ich bin es nicht gewohnt, eine Klasse mit einem Konstruktor zu beginnen.  Ich beginne immer mit den grundlegenden Methoden, die einer bestimmten Entität inhärent sind.  Beginnen wir mit privaten Feldern und privaten Methoden. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p>  Mit Feldern ist alles ganz einfach.  2 Listen mit Winkel-, Seitenknoten und einem Feld des Zentralknotens. </p><br><p>  Als nächstes müssen Sie ein wenig klären.  Tatsache ist, dass der Marker selbst vom Typ <code>Trackable</code> und keine Ahnung hat (und nicht haben sollte), dass er Teil einer anderen Logik ist.  Daher können wir nur seinen Namen verwenden, um die Anzeige zu steuern.  Wenn der Marker selbst nicht den Knotentyp speichert, zu dem er gehört, müssen wir diese Verantwortung auf unsere <code>OpenCard</code> Klasse übertragen.  Basierend darauf beschreiben wir zunächst 3 private Methoden, die für die Bestimmung des Knotentyps verantwortlich sind. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Die direkte Verwendung dieser Methoden ist jedoch nicht sinnvoll.  Es ist nicht bequem, mit Booleschen Werten zu arbeiten, wenn Sie mit Objekten einer anderen Abstraktionsebene arbeiten.  Daher werden wir eine einfache <code>enum NodeType</code> und eine private Methode <code>GetNodeType()</code> , die die gesamte Logik zur Bestimmung des Knotentyps in sich zusammenfasst. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody">  Öffentliche Methoden </h3><br><ul><li>  <code>IsExist</code> ist eine Methode, die einen booleschen Wert zurückgibt, der angibt, ob unsere Marke zu einer Postkarte gehört.  Dies ist eine Hilfsmethode, die durchgeführt wird, damit wir den Inhalt darauf anzeigen können, wenn der Marker zu keiner Karte gehört. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code> - eine Methode (wie der Name schon sagt), mit der wir den aktuellen Status des Knotens überprüfen und seinen Status ändern. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor">  Konstruktor </h3><br><p>  Wenn alle Karten auf dem Tisch liegen, können wir endlich zum Konstruktor gehen.  Es gibt verschiedene Ansätze zur Initialisierung.  Aber ich habe beschlossen, die <code>OpenCard</code> Klasse so weit wie möglich von unnötigen Gesten zu befreien.  Es sollte uns antworten, ob der Inhalt zur Anzeige verfügbar ist oder nicht.  Daher fragen wir einfach nach Eingabelisten von Knoten von 2 Typen und einem zentralen Knoten. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p>  Da der zentrale Knoten nur die Bedingung überprüfen muss, dass alle anderen <code>true</code> Knoten vorhanden sind, reicht es für uns aus <code>INode</code> abgewinkelten und zentralen Knoten, die in den Konstruktor <code>INode</code> sind, implizit in den Typ <code>INode</code> zu <code>INode</code> . </p><br><h3 id="inicializaciya">  Initialisierung </h3><br><p>  Was ist der bequemste Weg, um Objekte zu erstellen, die nicht an ein GameObject angehängt werden müssen (wie <code>MonoBehaviour</code> Komponenten)?  - Richtig, <code>ScriptableObject</code> .  <code>MenuItem</code> Sie der <code>MenuItem</code> auch das <code>MenuItem</code> Attribut hinzu, um die Erstellung neuer Karten zu vereinfachen. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p>  Der letzte Akkord in unserer Komposition wird eine Passage durch eine Reihe von hinzugefügten (falls vorhanden) <code>ScriptableObject</code> und daraus Postkarten erstellen.  Danach bleibt es für uns in der <code>Update</code> Methode, einfach zu prüfen, ob wir den Inhalt anzeigen können oder nicht. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  Für mich persönlich waren die Schlussfolgerungen wie folgt: </p><br><ol><li>  Wenn Sie versuchen, ein Problem zu lösen, müssen Sie versuchen, seine Elemente in atomare Teile zu zerlegen.  Wenn Sie alle möglichen Optionen für die Interaktion zwischen diesen atomaren Teilen berücksichtigen, müssen Sie mit dem Objekt beginnen, von dem möglicherweise weitere Verbindungen stammen.  Auf andere Weise kann es wie folgt formuliert werden: Bemühen Sie sich, Probleme mit Elementen zu lösen, die möglicherweise weniger zuverlässig sind </li><li>  Wenn möglich, sollten Sie versuchen, die Quelldaten in einer anderen Form darzustellen.  In meinem Fall hat mir die grafische Darstellung sehr geholfen. </li><li>  Jede Entität ist durch die Anzahl der Verbindungen, die möglicherweise von ihr stammen könnten, von der anderen getrennt. </li><li>  Viele angewandte Aufgaben, deren Lösung durch Schreiben eines Algorithmus üblicher ist, können im OO-Stil dargestellt werden </li><li>  Eine Lösung mit Ringabhängigkeiten ist eine schlechte Lösung </li><li>  Wenn es schwierig ist, alle Verbindungen zwischen Objekten in Ihrem Kopf aufrechtzuerhalten, ist dies eine schlechte Entscheidung </li><li>  Wenn Sie die Logik der Interaktion von Objekten nicht berücksichtigen können, ist dies eine schlechte Entscheidung </li><li>  Ihre Krücken sind nicht immer eine schlechte Entscheidung </li></ol><br><p>  Kennen Sie eine andere Lösung?  - Schreiben Sie in die Kommentare. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454452/">https://habr.com/ru/post/de454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454440/index.html">Petty Little Fun # 2: Starlette</a></li>
<li><a href="../de454442/index.html">So wählen Sie ein Proxy-Netzwerk für Ihr Unternehmen aus: 3 praktische Tipps</a></li>
<li><a href="../de454444/index.html">Wir profilieren das Laden von Habr oder wie 189 Anfragen auf der Seite Einfluss nehmen</a></li>
<li><a href="../de454446/index.html">Was ist neu in C # 8?</a></li>
<li><a href="../de454450/index.html">Wie Edison Wireless erfand und nichts verstand</a></li>
<li><a href="../de454456/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 7. FAQ</a></li>
<li><a href="../de454458/index.html">Metamorphe Tests: Warum weiß fast niemand etwas über diese vielversprechende Technik?</a></li>
<li><a href="../de454460/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 300 (27. Mai - 2. Juni)</a></li>
<li><a href="../de454462/index.html">Fotogramm ohne Fotopapier</a></li>
<li><a href="../de454464/index.html">Entwicklung visueller Tests basierend auf Gemini und Storybook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>