<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üìó üòΩ Wir zeigen Inhalte auf dem erkannten Bild nach bestimmten Regeln an üåµ üë®üèº‚Äçüîß üë®üèª‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie eine technische Aufgabe lesen und Fristen f√ºr die Implementierung festlegen, untersch√§tzen Sie manchmal den Zeit- und Arbeitsaufwand f√ºr die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir zeigen Inhalte auf dem erkannten Bild nach bestimmten Regeln an</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p>  Wenn Sie eine technische Aufgabe lesen und Fristen f√ºr die Implementierung festlegen, untersch√§tzen Sie manchmal den Zeit- und Arbeitsaufwand f√ºr die L√∂sung eines bestimmten Problems.  Es kommt vor, dass ein Punkt, der durch die Zeit pro Woche gesch√§tzt wird, nach einer Stunde ausgef√ºhrt wird und manchmal auch umgekehrt.  Aber in diesem Artikel geht es nicht darum.  Dies ist eine Demonstration der Entwicklung einer L√∂sung f√ºr ein Problem.  Von der Gr√ºndung bis zur Umsetzung. </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br>
<h1 id="ispolzuemye-terminy">  Verwendete Begriffe </h1><br><ul><li><p>  Markierung oder Markierung - Ein in die AR-Engine geladenes Bild, das von der Kamera des Ger√§ts (Tablet oder Smartphone) erkannt wird und eindeutig identifiziert werden kann </p><br></li><li><p>  Gefunden - Markierungsstatus, als er im Sichtfeld der Kamera erkannt wurde </p><br></li><li><p>  Lost - Markierungsstatus, als er aus der Kameraansicht verloren ging </p><br></li><li><p>  Es kann angezeigt werden - wenn der Marker gefunden wird, zeigen wir den an den Marker angeh√§ngten Inhalt an </p><br></li><li><p>  Kann nicht angezeigt werden - wenn wir den Marker finden, zeigen Sie den Inhalt nicht an - Inhalt, der an den Marker angeh√§ngt ist - jedes Objekt (3D-Modell, Sprite, Partikelsystem usw.), das an den Marker angeh√§ngt werden kann und dementsprechend angezeigt wird auf dem Bildschirm, wenn eine Markierung gefunden wird </p><br></li><li><p>  Markieren, markieren, gefunden, verloren - die Grundzust√§nde aller Engines, die Erkennungsfunktionen bieten </p><br></li><li><p>  Es kann angezeigt werden und kann nicht angezeigt werden - der Status, der zur L√∂sung dieses Problems verwendet wird </p><br><p>  <strong>Ein Beispiel:</strong> </p><br><ul><li>  Anwendung herunterladen =&gt; Alle heruntergeladenen Marken sind erkennbar </li><li>  Wir versuchen zu erkennen =&gt; der Zustand des Markers √§ndert sich in "gefunden" </li><li>  Wenn der Marker angezeigt werden kann =&gt; Geben Sie an, dass der Marker ‚Äûgefunden‚Äú wurde, und wir zeigen das an den Marker angeh√§ngte Modell an </li><li>  Wenn der Marker nicht angezeigt werden kann =&gt; wird der Status des Markers "gefunden", aber das angeh√§ngte Modell wird nicht angezeigt </li><li>  Die Marke ist aus dem Sichtfeld der Kamera verschwunden =&gt; Wir √§ndern den Status in "verloren". </li></ul><br></li></ul><br><h1 id="vvedenie">  Einf√ºhrung </h1><br><p>  Es gibt eine gro√üe Postkarte in der Gr√∂√üe eines A4-Blattes.  Es ist in 4 gleiche Teile unterteilt (Format eines Teils A5). Auf jedem dieser Teile befindet sich: </p><br><ul><li>  Eine volle Eckmarke (1) </li><li>  Eine H√§lfte der unteren Seitenmarkierung (5) </li><li>  Eine H√§lfte der oberen Seitenmarkierung (8) </li><li>  Quarter Center Mark (9) </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="Bild"></p><br><p> Wenn Sie mit Erkennungs-Engines wie Vuforia gearbeitet haben, wissen Sie wahrscheinlich, dass es keine ‚ÄûErkennungsqualit√§t‚Äú gibt.  Die Marke wird entweder erkannt oder nicht erkannt.  Wenn die Engine die Marke "sieht", √§ndert sie den Status in " <code>Find</code> und die <code>OnSuccess()</code> -Methode wird <code>OnSuccess()</code> . Wenn sie "verloren" wird, √§ndert sich der Status in " <code>Lost</code> und die <code>OnLost()</code> -Methode wird <code>OnLost()</code> .  Dementsprechend ergab sich aus den vorhandenen Bedingungen und Eingabedaten eine Situation, in der es m√∂glich war, mit einem Teil der Karte (einem halben oder einem Viertel) die Marke zu erkennen. </p><br><p>  Die Sache ist, dass entsprechend der technischen Aufgabe eine schrittweise Freischaltung der Charaktere geplant war.  In dieser Situation ist ein schrittweises Entsperren m√∂glich, da jedoch keine Personen versuchen, ein Viertel oder die H√§lfte der Marke zu erkennen. </p><br><h1 id="formulirovka-zadachi">  Aufgabenstellung </h1><br><p>  Es ist notwendig, Logik in Form von Programmcode zu implementieren, der das schrittweise Entsperren des an die Markierungen angeh√§ngten Inhalts gew√§hrleistet.  Aus der Position der Elemente auf der Karte ist bekannt, dass die Markierungen 1, 2, 3, 4 anf√§nglich zur Anzeige verf√ºgbar sind. </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="Bild"></p><br><p>  Wenn der Inhalt gelesen und auf 2 Markern angezeigt wurde, z. B. 2 und 3, k√∂nnen Sie den Inhalt auf Marker 6 anzeigen. Wenn Marker 1 noch nicht gelesen wurde, ist der Zugriff auf Marker 5 geschlossen.  Weiter analog.  Wir geben die Erlaubnis, Inhalte nur an Seitenmarkierungen anzuzeigen, wenn wir benachbarte Eckmarkierungen gelesen haben. </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="Bild"></p><br><p>  Wenn Marker von 1 bis 8 verf√ºgbar sind und gefunden werden, √∂ffnen Sie den Inhalt auf Marker 9 zur Anzeige. Jeder Marker hat 2 Zust√§nde - der Inhalt ist verf√ºgbar und nicht f√ºr die Anzeige verf√ºgbar, f√ºr die das Feld <code>public bool IsActive;</code> des <code>public bool IsActive;</code> verantwortlich ist <code>public bool IsActive;</code> </p><br><p>  Es ist sofort klar, dass dies entweder eine Zustandsmaschine mit einem √úbergang zwischen Zust√§nden oder eine Implementierung des "Zustands" -Musters sein sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Das Ergebnis war nicht das eine, nicht das andere.  Ich kann nicht sagen, dass dies eine Kr√ºcke ist, da die L√∂sung die Anforderungen am Anfang des Artikels vollst√§ndig erf√ºllt.  Aber du kannst mit mir streiten. </p></div></div><br><p>  In diesem Zusammenhang gebe ich Ihnen die M√∂glichkeit, selbst √ºber m√∂gliche L√∂sungen und Implementierungen dieser Aufgabe nachzudenken.  Ich brauchte ungef√§hr 5 Stunden, um das Bild der Entscheidung zu erkennen und in meinem Kopf zu fixieren. </p><br><p>  Aus Gr√ºnden der √úbersichtlichkeit habe ich ein Video aufgenommen, auf dem das Endergebnis des Algorithmus (wenn Sie es so nennen k√∂nnen) bereits erfasst ist. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu">  L√∂sungsans√§tze </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1. Von den Eckmarkierungen zur Mitte </h2><br><p>  Das erste, was mir in den Sinn kam, war die Darstellung der Wechselwirkungen zwischen den Markern von der Ecke bis zur Mitte.  In grafischer Form sieht es so aus: </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="Bild"></p><br><p>  Die Probleme: </p><br><ol><li>  Wie bestimme ich, welches Seitenetikett den Status √§ndern soll?  Der links oder rechts?  Wir zwingen jeden Marker auch dazu, √ºber die Existenz eines zentralen Markers ‚ÄûBescheid zu wissen‚Äú. </li><li>  Es ist erforderlich, nicht offensichtliche Abh√§ngigkeiten aus der Kategorie hinzuzuf√ºgen: Die Seitenmarkierung abonniert das Eckmarkierungsereignis IsChangedEventCallback (). F√ºr die zentrale Markierung m√ºssen √§hnliche Aktionen ausgef√ºhrt werden. </li><li>  Wenn wir jeden Markertyp als Entit√§t betrachten, leiten wir in der Hierarchie dieser Entit√§ten den Befehl zum √Ñndern des Status von unten nach oben weiter.  Dies ist nicht sehr gut, da wir uns eng an die Zahl, in diesem Fall an Winkelmarkierungen, binden und die Skalierbarkeit verlieren. </li></ol><br><p>  Ich konnte die obige L√∂sung aufgrund der vielen Randf√§lle und der Komplexit√§t der Wahrnehmung nicht in meinen Kopf setzen und √§nderte den Ansatz zur Auswahl eines Markers, von dem sich die Abh√§ngigkeiten zu verbreiten beginnen. </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2. Seitenteile kennen sich mit Mittel und Ecke aus </h2><br><p>  Beim Nachdenken √ºber die L√∂sung von Absatz 3 des vorherigen Ansatzes kam die Idee, den Markertyp zu √§ndern, ab dem sich die Zust√§nde anderer Marker zu √§ndern beginnen.  Als Hauptseitenmarkierungen wurden genommen.  In diesem Szenario sieht die Kommunikation (Abh√§ngigkeiten) folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="Bild"></p><br><p>  Ab hier wird sofort klar, dass die Verbindungen von der lateralen zur zentralen √ºberfl√ºssig sind, da der laterale Marker nichts √ºber den zentralen Marker wissen muss, weshalb dieser Ansatz sofort in den endg√ºltigen umgewandelt wurde. </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3. Der zentrale kennt jeden, die seitlichen kennen die Ecke </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="Bild"></p><br><p>  Die endg√ºltige L√∂sung ist, wenn der Seitenmarker √ºber die Ecken Bescheid wei√ü, die Ecken ‚Äûihr Leben leben‚Äú und der zentrale √ºber den Zustand aller Markierungen Bescheid wei√ü. </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="Bild"></p><br><p>  Das Arbeiten mit der Postkartenansicht ist nicht sehr bequem.  Die Beziehungen zwischen Entit√§ten sehen nicht klar genug aus, um dies einfach in Code umzuwandeln.  Ein Versuch, in Form eines Bin√§rbaums zu interpretieren, kann zu Mehrdeutigkeiten f√ºhren.  Hier wird jedoch eine der Eigenschaften des Bin√§rbaums verletzt, sodass die Mehrdeutigkeit sofort verschwindet.  Daraus k√∂nnen wir schlie√üen, dass diese Darstellung eindeutig interpretiert und verwendet werden kann, um die L√∂sung des Problems grafisch darzustellen.  Basierend auf diesen Schlussfolgerungen werden wir die Graphnotation verwenden, n√§mlich: </p><br><ul><li>  Winkelmarkierung - Winkelknoten (Stufe 3) </li><li>  Seitenmarkierung - Seitenknoten (Stufe 2) </li><li>  Center Marker - Center Node (Stufe 1) </li></ul><br><p>  Vorteile: </p><br><ol><li>  Die Abh√§ngigkeiten zwischen den Markern sind offensichtlich und offensichtlich. </li><li>  Jede der Ebenen kann in Form von 3 Entit√§ten dargestellt werden, von denen jede aus grundlegenden Teilen besteht, deren Erg√§nzungen jedoch jeder der Ebenen inh√§rent sind </li><li>  Zum Erweitern m√ºssen Sie nur einen neuen Knotentyp mit eigenen Merkmalen hinzuf√ºgen </li><li>  Diese L√∂sung ist in einem OO-Stil (objektorientiert) leicht vorstellbar </li></ol><br><h1 id="realizaciya">  Implementierung </h1><br><h2 id="bazovye-suschnosti">  Basisentit√§ten </h2><br><p>  Erstellen wir eine Schnittstelle, die die Elemente enth√§lt, die jeder Entit√§t inh√§rent sind (Name, Status): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Als n√§chstes beschreiben wir die Essenz jedes Knotens: </p><br><ul><li>  <strong>CornerNode</strong> - ein <strong>Winkelknoten</strong> .  Implementieren <code>INode</code> einfach die <code>INode</code> Schnittstelle: </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Warum ist <code>IsActive = true</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  Unter den Bedingungen des Problems steht der Inhalt von Eckmarkierungen zun√§chst zur Erkennung zur Verf√ºgung. </p></div></div><br><ul><li>  <strong>SideNode</strong> - ein <strong>Seitenknoten</strong> .  Wir implementieren die <code>INode</code> Schnittstelle, f√ºgen jedoch die <code>RightCornerNode</code> <code>LeftCornerNode</code> und <code>RightCornerNode</code> .  Somit beh√§lt der Seitenknoten seinen Zustand in sich und wei√ü nur √ºber die Existenz von Seitenknoten Bescheid. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong> ist der zentrale Knoten.  Wie in den vorherigen implementieren wir <code>INode</code> .  F√ºgen Sie ein Feld vom Typ <code>List&lt;INode&gt;</code> . </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard">  Opencard-Klasse </h2><br><h3 id="privatnye-metody-i-polya">  Private Methoden und Felder </h3><br><p>  Nachdem wir alle Elemente der Karte erstellt haben (alle Arten von Markierungen), k√∂nnen wir beginnen, die Essenz der Karte selbst zu beschreiben.  Ich bin es nicht gewohnt, eine Klasse mit einem Konstruktor zu beginnen.  Ich beginne immer mit den grundlegenden Methoden, die einer bestimmten Entit√§t inh√§rent sind.  Beginnen wir mit privaten Feldern und privaten Methoden. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p>  Mit Feldern ist alles ganz einfach.  2 Listen mit Winkel-, Seitenknoten und einem Feld des Zentralknotens. </p><br><p>  Als n√§chstes m√ºssen Sie ein wenig kl√§ren.  Tatsache ist, dass der Marker selbst vom Typ <code>Trackable</code> und keine Ahnung hat (und nicht haben sollte), dass er Teil einer anderen Logik ist.  Daher k√∂nnen wir nur seinen Namen verwenden, um die Anzeige zu steuern.  Wenn der Marker selbst nicht den Knotentyp speichert, zu dem er geh√∂rt, m√ºssen wir diese Verantwortung auf unsere <code>OpenCard</code> Klasse √ºbertragen.  Basierend darauf beschreiben wir zun√§chst 3 private Methoden, die f√ºr die Bestimmung des Knotentyps verantwortlich sind. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Die direkte Verwendung dieser Methoden ist jedoch nicht sinnvoll.  Es ist nicht bequem, mit Booleschen Werten zu arbeiten, wenn Sie mit Objekten einer anderen Abstraktionsebene arbeiten.  Daher werden wir eine einfache <code>enum NodeType</code> und eine private Methode <code>GetNodeType()</code> , die die gesamte Logik zur Bestimmung des Knotentyps in sich zusammenfasst. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody">  √ñffentliche Methoden </h3><br><ul><li>  <code>IsExist</code> ist eine Methode, die einen booleschen Wert zur√ºckgibt, der angibt, ob unsere Marke zu einer Postkarte geh√∂rt.  Dies ist eine Hilfsmethode, die durchgef√ºhrt wird, damit wir den Inhalt darauf anzeigen k√∂nnen, wenn der Marker zu keiner Karte geh√∂rt. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code> - eine Methode (wie der Name schon sagt), mit der wir den aktuellen Status des Knotens √ºberpr√ºfen und seinen Status √§ndern. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor">  Konstruktor </h3><br><p>  Wenn alle Karten auf dem Tisch liegen, k√∂nnen wir endlich zum Konstruktor gehen.  Es gibt verschiedene Ans√§tze zur Initialisierung.  Aber ich habe beschlossen, die <code>OpenCard</code> Klasse so weit wie m√∂glich von unn√∂tigen Gesten zu befreien.  Es sollte uns antworten, ob der Inhalt zur Anzeige verf√ºgbar ist oder nicht.  Daher fragen wir einfach nach Eingabelisten von Knoten von 2 Typen und einem zentralen Knoten. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p>  Da der zentrale Knoten nur die Bedingung √ºberpr√ºfen muss, dass alle anderen <code>true</code> Knoten vorhanden sind, reicht es f√ºr uns aus <code>INode</code> abgewinkelten und zentralen Knoten, die in den Konstruktor <code>INode</code> sind, implizit in den Typ <code>INode</code> zu <code>INode</code> . </p><br><h3 id="inicializaciya">  Initialisierung </h3><br><p>  Was ist der bequemste Weg, um Objekte zu erstellen, die nicht an ein GameObject angeh√§ngt werden m√ºssen (wie <code>MonoBehaviour</code> Komponenten)?  - Richtig, <code>ScriptableObject</code> .  <code>MenuItem</code> Sie der <code>MenuItem</code> auch das <code>MenuItem</code> Attribut hinzu, um die Erstellung neuer Karten zu vereinfachen. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p>  Der letzte Akkord in unserer Komposition wird eine Passage durch eine Reihe von hinzugef√ºgten (falls vorhanden) <code>ScriptableObject</code> und daraus Postkarten erstellen.  Danach bleibt es f√ºr uns in der <code>Update</code> Methode, einfach zu pr√ºfen, ob wir den Inhalt anzeigen k√∂nnen oder nicht. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  F√ºr mich pers√∂nlich waren die Schlussfolgerungen wie folgt: </p><br><ol><li>  Wenn Sie versuchen, ein Problem zu l√∂sen, m√ºssen Sie versuchen, seine Elemente in atomare Teile zu zerlegen.  Wenn Sie alle m√∂glichen Optionen f√ºr die Interaktion zwischen diesen atomaren Teilen ber√ºcksichtigen, m√ºssen Sie mit dem Objekt beginnen, von dem m√∂glicherweise weitere Verbindungen stammen.  Auf andere Weise kann es wie folgt formuliert werden: Bem√ºhen Sie sich, Probleme mit Elementen zu l√∂sen, die m√∂glicherweise weniger zuverl√§ssig sind </li><li>  Wenn m√∂glich, sollten Sie versuchen, die Quelldaten in einer anderen Form darzustellen.  In meinem Fall hat mir die grafische Darstellung sehr geholfen. </li><li>  Jede Entit√§t ist durch die Anzahl der Verbindungen, die m√∂glicherweise von ihr stammen k√∂nnten, von der anderen getrennt. </li><li>  Viele angewandte Aufgaben, deren L√∂sung durch Schreiben eines Algorithmus √ºblicher ist, k√∂nnen im OO-Stil dargestellt werden </li><li>  Eine L√∂sung mit Ringabh√§ngigkeiten ist eine schlechte L√∂sung </li><li>  Wenn es schwierig ist, alle Verbindungen zwischen Objekten in Ihrem Kopf aufrechtzuerhalten, ist dies eine schlechte Entscheidung </li><li>  Wenn Sie die Logik der Interaktion von Objekten nicht ber√ºcksichtigen k√∂nnen, ist dies eine schlechte Entscheidung </li><li>  Ihre Kr√ºcken sind nicht immer eine schlechte Entscheidung </li></ol><br><p>  Kennen Sie eine andere L√∂sung?  - Schreiben Sie in die Kommentare. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454452/">https://habr.com/ru/post/de454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454440/index.html">Petty Little Fun # 2: Starlette</a></li>
<li><a href="../de454442/index.html">So w√§hlen Sie ein Proxy-Netzwerk f√ºr Ihr Unternehmen aus: 3 praktische Tipps</a></li>
<li><a href="../de454444/index.html">Wir profilieren das Laden von Habr oder wie 189 Anfragen auf der Seite Einfluss nehmen</a></li>
<li><a href="../de454446/index.html">Was ist neu in C # 8?</a></li>
<li><a href="../de454450/index.html">Wie Edison Wireless erfand und nichts verstand</a></li>
<li><a href="../de454456/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 7. FAQ</a></li>
<li><a href="../de454458/index.html">Metamorphe Tests: Warum wei√ü fast niemand etwas √ºber diese vielversprechende Technik?</a></li>
<li><a href="../de454460/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 300 (27. Mai - 2. Juni)</a></li>
<li><a href="../de454462/index.html">Fotogramm ohne Fotopapier</a></li>
<li><a href="../de454464/index.html">Entwicklung visueller Tests basierend auf Gemini und Storybook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>