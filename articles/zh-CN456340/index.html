<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 💼 ⏲️ 关于自由职业者团队如何编写全栈JavaScript应用程序的故事 🙍🏼 😣 ♓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="该材料的作者（我们今天将其翻译发表于此）说，他所工作的GitHub存储库以及其他一些自由职业者由于各种原因，在3天内获得了约8,200星的评价。 该存储库在HackerNews和GitHub Trending上排名第一，有20,000名Reddit用户投票赞成。 

  

 该存储库反映了本文专门...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于自由职业者团队如何编写全栈JavaScript应用程序的故事</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/456340/"> 该材料的作者（我们今天将其翻译发表于此）说，他所工作的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub存储库</a>以及其他一些自由职业者由于各种原因，在3天内获得了约8,200星的评价。 该存储库在HackerNews和GitHub Trending上排名第一，有20,000名Reddit用户投票赞成。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/o9/9m/iu/o99miuqh4mzbstufrnaebmv5cxg.jpeg"></a> <br><br> 该存储库反映了本文专门讨论的用于开发全栈应用程序的方法。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">背景知识</font> </h2><br> 我打算花相当长的时间写这篇材料。 我相信，当我们的存储库非常受欢迎时，我找不到比这更好的时刻了。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/194/534/9ce194534d51b90329a9698ba8835d09.png"></div><br>  <i><font color="#999999">GitHub趋势第一</font></i> <br><br> 我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自由职业者</a>团队中工作。 我们的项目使用React / React Native，NodeJS和GraphQL。 本材料供那些想了解我们如何开发应用程序的人使用。 此外，这对于将来加入我们团队的人也很有用。 <br><br> 现在，我将讨论我们在开发项目时使用的基本原理。 <br><br><h2>  <font color="#3AC1EF">越简单越好。</font> </h2><br>  “越简单越好”说起来容易做起来难。 大多数开发人员都知道，简单性是软件开发中的重要原则。 但是这个原则并不总是容易遵循的。 如果代码很简单，这将有助于项目支持并简化该项目的团队工作。 此外，遵守该原则有助于处理六个月前编写的代码。 <br><br> 这是我在此原则上遇到的错误： <br><br><ul><li> 满足DRY原则的不合理愿望。 有时复制和粘贴代码是很正常的。 无需抽象每两个彼此有点相似的代码片段。 我自己犯了这个错误。 也许所有人都承诺了。  DRY是一种很好的编程方法，但是选择失败的抽象只会使情况恶化并使代码库复杂化。 如果您想进一步了解这些想法，建议阅读Kent A Dodds的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AHA编程</a> 。 </li><li>拒绝使用可用的工具。 此错误的一个示例是使用<code>reduce</code>而不是<code>map</code>或<code>filter</code> 。 当然，使用<code>reduce</code>可以重现<code>map</code>的行为。 但是，鉴于“代码的简单性”是一个主观的概念，这可能会导致代码的大小增加，并使其他人更难以理解该代码。 有时可能需要使用just <code>reduce</code> 。 而且，如果使用链中组合的<code>map</code>和<code>filter</code>调用并使用<code>reduce</code>来比较数据集的处理速度，则可以发现第二个选项的工作速度更快。 在带有<code>reduce</code>的选项中<code>reduce</code>您必须查看一组值，而不是两个。 在我们面前是关于生产率和简单性的辩论。 在大多数情况下，我更喜欢简单性，并尝试避免过早的代码优化，也就是说，我将选择一个<code>map</code> / <code>filter</code>对而不是<code>reduce</code> 。 而且，如果事实证明<code>map</code>和<code>filter</code>的构造成为系统的瓶颈，它将转换代码来<code>reduce</code> 。 </li></ul><br> 下面将要讨论的许多想法旨在使代码库尽可能简单，并使其保持这种状态。 <br><br><h2>  <font color="#3AC1EF">保持相似的实体彼此靠近</font> </h2><br> 该原则（“共置原则”）适用于应用程序的许多部分。 这是存储客户代码和服务器代码的文件夹的结构，这是项目代码在一个存储库中的存储，这也是确定某个文件中哪个代码的决策。 <br><br><h3>  <font color="#3AC1EF">▍仓库</font> </h3><br> 建议您将客户端和服务器代码保存在同一存储库中。 很简单 不要使不必要的复杂化。 使用这种方法，可以方便地在项目上组织协调的团队工作。 我从事的项目使用各种存储库来存储材料。 这不是灾难，但是单一存储库使生活更加轻松。 <br><br><h3>  <font color="#3AC1EF">▍应用程序客户端部分的项目结构</font> </h3><br> 我们正在编写全栈应用程序。 即，客户端代码和服务器代码。 典型客户端项目的文件夹结构包括用于组件，容器，操作，化简和路由的单独目录。 <br><br> 使用Redux的项目中存在操作和简化程序。 我努力做到没有这个库。 我确信有一些使用相同结构的高质量项目。 我的某些项目为组件和容器提供了单独的文件夹。 组件文件夹可以存储带有诸如<code>BlogPost</code>和<code>Profile</code>实体代码的文件之类的东西。 在容器文件夹中，有一些文件存储着容器代码<code>BlogPostContainer</code>和<code>BlogPostContainer</code> 。 容器从服务器接收数据并将其传递给“愚蠢”的子组件，该子组件的任务是在屏幕上显示此数据。 <br><br> 这是一个工作结构。 它至少是同质的，这非常重要。 这导致这样一个事实，即参与该项目工作的开发人员将迅速了解其中正在发生的事情以及其各个部分所起的作用。 由于我最近一直尝试不使用这种方法，因此它的缺点是它迫使程序员不断地在代码库中移动。 例如， <code>BlogPostContainer</code>和<code>BlogPostContainer</code>没有什么共同点，但是它们的文件彼此相邻，并且与实际使用它们的文件相距甚远。 <br><br> 一段时间以来，我一直在努力将计划共享其内容的文件放置在同一文件夹中。 这种项目结构化方法是基于文件的功能进行分组的。 通过这种方法，例如，如果将父组件及其“愚蠢”子组件放置在同一文件夹中，则可以大大简化您的生活。 <br><br> 通常，我们使用<code>routes</code> / <code>screens</code>文件夹和<code>components</code>文件夹。 组件文件夹通常存储诸如<code>Button</code>或<code>Input</code>项目的代码。 该代码可以在应用程序的任何页面上使用。 路由文件夹中的每个文件夹都是一个单独的应用程序页面。 同时，具有与此路径相关的组件代码和应用程​​序逻辑代码的文件位于同一文件夹中。 并且，在多个页面上使用的组件的代码将落入<code>components</code>文件夹中。 <br><br> 在route文件夹中，您可以创建其他文件夹，在其中将负责形成页面不同部分的代码分组。 在路由由大量代码表示的情况下，这是有意义的。 但是，在这里，我要警告读者，不值得从嵌套程度很高的文件夹中创建结构。 这使项目的移动复杂化。 深度嵌套的文件夹结构是使项目过于复杂的标志之一。 应该注意的是，使用专用工具（例如搜索命令）为程序员提供了方便的工具，以便他们使用项目代码并查找他的需求。 但是项目的文件结构也会影响其可用性。 <br><br> 通过对项目代码进行结构化，您可以不基于路由，而是基于这些文件实现的项目功能对文件进行分组。 就我而言，这种方法在单页项目中完美展示，该项目在其唯一的页面上实现了许多功能。 但应注意，按路线对项目材料进行分组比较容易。 这种方法不需要做出特殊的脑力劳动就可以决定应将哪些实体彼此相邻并进行搜索。 <br><br> 如果我们进一步对代码进行分组，则可以决定将容器和组件的代码合理地放置在同一文件中。 您甚至可以走得更远-将两个组件的代码放在一个文件中。 我想您现在可能已经在想，推荐这样的事情真是亵渎神灵。 但是实际上，一切都远没有那么糟。 实际上，这种方法是完全合理的。 而且，如果您使用React钩子或生成的代码（或两者都使用），则建议您使用这种方法。 <br><br> 实际上，如何将代码分解为文件的问题并不是最重要的。 真正的问题是，为什么您可能需要将组件分为聪明的和愚蠢的。 这种分离有什么好处？ 这个问题有几个答案： <br><br><ol><li> 以这种方式构建的应用程序更易于测试。 </li><li> 开发此类应用程序可以更轻松地使用诸如Storybook之类的工具。 </li><li> 愚蠢的组件可以与许多不同的智能组件一起使用（反之亦然）。 </li><li> 智能组件可以在不同平台上使用（例如，在React和React Native平台上）。 </li></ol><br> 所有这些都是支持将组件分为“智能”和“愚蠢”的真实论点，但是它们并不适用于所有情况。 例如，在创建项目时，我们经常将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apollo Client</a>与钩子一起使用。 为了测试此类项目，您可以创建Apollo响应模拟或挂钩模拟。 故事书也是如此。 如果我们谈论混合和共享“智能”和“愚蠢”组件，那么实际上我在实践中从未遇到过。 关于代码的跨平台使用，有一个项目我打算做类似的事情，但是从来没有做过。 它应该是Lerna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单一存储库</a> 。 如今，您可以选择使用React Native Web来代替这种方法。 <br><br> 结果，我们可以说，将组件分为“智能”和“傻”有一定的意义。 这是一个值得了解的重要概念。 但是通常，您不必为此担心，尤其是考虑到React钩子的最新出现。 <br><br> 在一个实体中结合“智能”和“愚蠢”组件功能的优点是，它可以加快开发速度，并且可以简化代码的结构。 <br><br> 此外，如果出现这种需要，则可以始终将一个组件分为两个单独的组件-“智能”和“愚蠢”。 <br><br><h4> 程式化 </h4><br> 我们将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">情感</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">样式化组件</a>用于样式化应用程序。 总是有将样式分离到单独文件中的诱惑。 我已经看到一些开发人员这样做。 但是，在尝试了两种方法之后，最终我找不到将样式移到单独文件中的理由。 就像我们在这里谈论的许多其他事情一样，开发人员可以通过将它们所关联的样式和组件组合到一个文件中来简化工作。 <br><br><h3>  <font color="#3AC1EF">▍应用程序服务器部分的项目结构</font> </h3><br> 就构造应用程序的服务器端代码而言，上述所有内容都是正确的。 我个人试图避免的典型结构可能看起来像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这样</a> ： <br><br><pre> <code class="plaintext hljs">src │ app.js #     └───api #   Express      └───config #      └───jobs #    agenda.js └───loaders #     └───models #    └───services # - └───subscribers #      └───types #    (d.ts)  Typescript</code> </pre> <br> 我们通常在项目中使用GraphQL。 因此，他们使用存储模型，服务和识别器的文件。 我没有将它们分散在项目的不同位置，而是将它们收集在一个文件夹中。 通常，这些文件将被共享，如果将它们存储在同一文件夹中，则使用它们会更容易。 <br><br><h2>  <font color="#3AC1EF">不要多次覆盖类型定义</font> </h2><br> 我们在项目中使用了许多与数据类型相关的解决方案。 这些是TypeScript，GraphQL，数据库架构，有时是MobX。 结果，可以发现相同实体的类型被描述了3-4次。 应该避免这样的事情。 我们应该努力使用自动生成类型描述的工具。 <br><br> 在服务器上，可以将TypeORM / Typegoose和TypeGraphQL组合使用。 这足以描述所有使用的类型。  TypeORM / Typegoose允许您描述数据库架构和相应的TypeScript类型。  TypeGraphQL将帮助创建GraphQL和TypeScript的类型。 <br><br> 这是确定一个文件中TypeORM（MongoDB）和TypeGraphQL类型的示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field, ObjectType, ID } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'type-graphql'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Entity, ObjectIdColumn, ObjectID, Column, CreateDateColumn, UpdateDateColumn, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span> @ObjectType() @Entity() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Policy</span></span></span><span class="hljs-class"> </span></span>{ @Field(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> ID) @ObjectIdColumn() _id: ObjectID @Field() @CreateDateColumn({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'timestamp'</span></span> }) createdAt: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> @Field({ <span class="hljs-attr"><span class="hljs-attr">nullable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) @UpdateDateColumn({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'timestamp'</span></span>, <span class="hljs-attr"><span class="hljs-attr">nullable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) updatedAt?: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> @Field() @Column() name: string @Field() @Column() version: number }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GraphQL代码生成器</a>还可以生成许多不同的类型。 我们使用此工具在客户端上创建TypeScript类型，以及用于访问服务器的React挂钩。 <br><br> 如果使用MobX来控制应用程序的状态，然后使用几行代码，就可以自动生成TS类型。 如果还使用GraphQL，则应查看新软件包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MST-GQL</a> ，该软件包根据GQL方案生成状态树。 <br><br> 一起使用这些工具将使您免于重写大量代码，并避免了常见错误。 <br><br> 其他解决方案，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Prisma</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hasura</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AWS AppSync</a> ，也可以帮助避免重复的类型声明。 当然，使用此类工具有其优点和缺点。 在我们创建的项目中，并非总是使用此类工具，因为我们需要将代码部署在我们自己的组织服务器上。 <br><br><h2>  <font color="#3AC1EF">尽可能使用自动代码生成的方法</font> </h2><br> 如果不使用上述工具自动生成代码，而是查看创建的代码，那么程序员经常会写同样的东西。 我可以提供的主要建议是，您需要为经常使用的所有内容创建摘要。 如果您经常输入<code>console.log</code>命令，请创建一个片段，如<code>cl</code> ，它将自动变成<code>console.log()</code> 。 如果您不这样做，请我帮助您进行代码调试，这会让我很不高兴。 <br><br> 有很多带有摘要的程序包，但是创建自己的摘要很容易。 例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码片段生成器</a> 。 <br><br> 这是允许我向VS Code添加一些我最喜欢的代码片段的代码： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"Export default"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"scope"</span></span>: <span class="hljs-string"><span class="hljs-string">"javascript,typescript,javascriptreact,typescriptreact"</span></span>,   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"eid"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [     <span class="hljs-string"><span class="hljs-string">"export { default } from './${TM_DIRECTORY/.*[\\/](.*)$$/$1/}'"</span></span>,     <span class="hljs-string"><span class="hljs-string">"$2"</span></span>   ],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import and export default in a single line"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Filename"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"fn"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"${TM_FILENAME_BASE}"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Print filename"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Import emotion styled"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"imes"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"import styled from '@emotion/styled'"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion js as styled"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Import emotion css only"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"imec"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"import { css } from '@emotion/styled'"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion css only"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Import emotion styled and css only"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"imesc"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"import styled, { css } from ''@emotion/styled'"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion js and css"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Styled component"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"sc"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"const ${1} = styled.${2}`"</span></span>, <span class="hljs-string"><span class="hljs-string">"  ${3}"</span></span>, <span class="hljs-string"><span class="hljs-string">"`"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion js and css"</span></span> }, <span class="hljs-string"><span class="hljs-string">"TypeScript React Function Component"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"rfc"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [     <span class="hljs-string"><span class="hljs-string">"import React from 'react'"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>,     <span class="hljs-string"><span class="hljs-string">"interface ${1:ComponentName}Props {"</span></span>,     <span class="hljs-string"><span class="hljs-string">"}"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>,     <span class="hljs-string"><span class="hljs-string">"const ${1:ComponentName}: React.FC&lt;${1:ComponentName}Props&gt; = props =&gt; {"</span></span>,     <span class="hljs-string"><span class="hljs-string">" return ("</span></span>,     <span class="hljs-string"><span class="hljs-string">" &lt;div&gt;"</span></span>,     <span class="hljs-string"><span class="hljs-string">" ${1:ComponentName}"</span></span>,     <span class="hljs-string"><span class="hljs-string">" &lt;/div&gt;"</span></span>,     <span class="hljs-string"><span class="hljs-string">" )"</span></span>,     <span class="hljs-string"><span class="hljs-string">"}"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>,     <span class="hljs-string"><span class="hljs-string">"export default ${1:ComponentName}"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"TypeScript React Function Component"</span></span> } }</code> </pre> <br> 除了代码片段之外，代码生成器还可以帮助节省时间。 您可以自己创建它们。 我喜欢为此使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">plop</a> 。 <br><br>  Angular有自己的内置代码生成器。 使用命令行工具，您可以创建一个由4个文件组成的新组件，其中提供了可以在组件中找到的所有内容。 遗憾的是，React没有这样的标准功能，但是可以使用plop单独创建类似的功能。 如果您创建的每个新组件都应以文件夹的形式显示，其中包含一个包含组件代码的文件，一个测试文件和一个Storybook文件，那么生成器将通过一个命令来帮助创建所有这些组件。 在许多情况下，这极大地延长了开发人员的寿命。 例如，向服务器添加新功能时，只需在命令行上运行一个命令即可。 之后，将自动创建包含所有必要基本结构的实体，服务和识别器的文件。 <br><br> 代码生成器的另一个优点是，它们有助于团队开发的统一性。 如果每个人都使用相同的plop生成器，那么每个人的代码将非常统一。 <br><br><h2>  <font color="#3AC1EF">自动代码格式化</font> </h2><br> 格式化代码是一项简单的任务，但是，不幸的是，它始终无法正确解决。 不要浪费时间手动对齐代码或在其中插入分号。 提交时，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Prettier</a>自动格式化代码。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我向您介绍了我们在多年的工作，反复的尝试中学到的一些知识。 有许多方法可以构造项目的代码库。 但是在他们当中没有人可以被称为唯一正确的人。 <br><br> 我想传达给您的最重要的一点是，程序员应该为组织项目的简单性，同质性和使用易于理解的结构而努力。 这简化了团队开发项目。 <br><br>  <b>亲爱的读者们！</b> 您如何看待本文概述的开发全栈JavaScript应用程序的想法？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456340/">https://habr.com/ru/post/zh-CN456340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456316/index.html">前端每周摘要（2019年6月10日至16日）</a></li>
<li><a href="../zh-CN456318/index.html">初学者指针基础</a></li>
<li><a href="../zh-CN456320/index.html">上周第369期（2019年6月10日至16日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN456334/index.html">当之无愧的长生不老的游戏</a></li>
<li><a href="../zh-CN456336/index.html">开发React应用程序时使用Redux的11个技巧</a></li>
<li><a href="../zh-CN456342/index.html">一种语言统治一切</a></li>
<li><a href="../zh-CN456344/index.html">为什么['1'，'7'，'11']。Map（parseInt）在Javascript中返回[1，NaN，3]？</a></li>
<li><a href="../zh-CN456346/index.html">Web开发学习者的交互式路线图</a></li>
<li><a href="../zh-CN456348/index.html">AERODISK引擎：灾难性的。 第一部分</a></li>
<li><a href="../zh-CN456350/index.html">6月17日至23日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>