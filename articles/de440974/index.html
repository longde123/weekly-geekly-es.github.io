<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìä ü§¶üèª üèâ Kotlin Puzzlers, Vol. 2: eine neue Reihe von R√§tseln üö£üèº üë©üèæ‚ÄçüöÄ üåø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√∂nnen Sie vorhersagen, wie sich ein solcher Kotlin-Code verh√§lt? Wird kompiliert, was ausgegeben wird und warum? 

 Egal wie gut die Programmiersprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin Puzzlers, Vol. 2: eine neue Reihe von R√§tseln</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440974/"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br>  K√∂nnen Sie vorhersagen, wie sich ein solcher Kotlin-Code verh√§lt?  Wird kompiliert, was ausgegeben wird und warum? <br><br>  Egal wie gut die Programmiersprache sein mag, sie kann so werfen, dass sie nur noch am Hinterkopf kratzt.  Kotlin ist keine Ausnahme - es enth√§lt auch R√§tsel, wenn selbst ein sehr kurzer Code unerwartetes Verhalten aufweist. <br><br>  Bereits 2017 haben wir auf Habr√© eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auswahl</a> solcher Puzzler von <b>Anton</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Keks antonkeks ver√∂ffentlicht</a> .  Und sp√§ter trat er mit der zweiten Auswahl bei Mobius auf, und wir √ºbersetzten sie nun auch f√ºr Habr in eine Textansicht, wobei wir die richtigen Antworten unter den Spoilern versteckten. <br><br>  Wir f√ºgen auch die Videoaufzeichnung der Rede bei. Wenn im Text etwas unverst√§ndlich erscheint, k√∂nnen Sie sich auch an sie wenden. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die erste H√§lfte der R√§tsel richtet sich an diejenigen, die mit Kotlin nicht sehr vertraut sind.  Die zweite H√§lfte ist f√ºr Hardcore-Kotlin-Entwickler.  Wir werden alles auf Kotlin 1.3 starten, auch wenn der progressive Modus aktiviert ist.  Puzzler-Quellcodes befinden sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> .  Wer neue Ideen hat, sendet Pull-Anfragen. <br><br><h2>  Pazzler Nummer 1 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(‚Ä≥Hello‚Ä≥) == print(‚Ä≥World‚Ä≥) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br>  Bevor wir eine einfache Hallo-Funktion haben, werden mehrere Druckvorg√§nge ausgef√ºhrt.  Und wir starten diese Funktion selbst.  Eine einfache √úbertaktungsfrage: Was soll es drucken? <br><br>  a) HelloWorld <br>  b) HelloWorldfalse <br>  c) HelloWorldtrue <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Richtige Antwort</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br>  Die erste Option war richtig.  Der Vergleich wird ausgel√∂st, nachdem beide Ausdrucke bereits gestartet wurden. Er kann nicht fr√ºher gestartet werden.  Warum wird ein solcher Code √ºberhaupt kompiliert?  Jede andere Funktion als die R√ºckgabe von Nothing gibt etwas zur√ºck.  Da alles in Kotlin ein Ausdruck ist, ist auch die R√ºckkehr ein Ausdruck.  Der R√ºckgabetyp ist Nothing. Er wird in einen beliebigen Typ umgewandelt, sodass Sie ihn wie folgt vergleichen k√∂nnen.  Und print gibt Unit zur√ºck, sodass Unit beliebig oft mit Nothing verglichen werden kann und alles hervorragend funktioniert. <br></div></div><br><h2>  Pazzler Nummer 2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br>  Hinweis, den Sie nicht erraten: Eine be√§ngstigende Zahl ist wirklich die kleinstm√∂gliche 32-Bit-Ganzzahl mit Vorzeichen. <br><br>  Hier sieht alles einfach aus.  Kotlin hat gro√üartige Erweiterungsfunktionen wie .inc () zum Inkrementieren.  Wir k√∂nnen es auf Int aufrufen und das Ergebnis drucken.  Was wird passieren? <br><br>  a) -2147483647 <br>  b) -2147483649 <br>  c) 2147483647 <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br>  Wie Sie der Fehlermeldung entnehmen k√∂nnen, liegt hier das Problem mit Long vor.  Aber warum lange? <br><br>  Erweiterungsfunktionen haben Priorit√§t, und der Compiler f√ºhrt zuerst inc () und dann den Minusoperator aus.  Wenn inc () entfernt wird, ist es Int und alles wird funktionieren.  Aber inc (), beginnend zuerst, wandelt 2_147_483_648 in Long um, weil diese Zahl ohne Minus nicht mehr g√ºltig ist Int.  Es stellt sich als Long heraus und erst dann wird Minus aufgerufen.  All dies kann nicht mehr an die Funktion printInt () √ºbergeben werden, da ein Int erforderlich ist. <br><br>  Wenn wir den printInt-Aufruf in einen regul√§ren Druck √§ndern, der Long akzeptieren kann, ist die zweite Option korrekt. <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br>  Wir sehen, dass dies tats√§chlich lang ist.  Beachten Sie Folgendes: Nicht alle Puzzleteile k√∂nnen in echtem Code ausgef√ºhrt werden, aber dieser kann. <br></div></div><br><h2>  Pazzler Nummer 3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  In Kotlin 1.3 kamen neue gro√üartige Funktionen.  Neben der endg√ºltigen Version von Corutin haben wir <br>  jetzt endlich vorzeichenlose nummern.  Dies ist insbesondere dann erforderlich, wenn Sie eine Art Netzwerkcode schreiben. <br><br>  Jetzt gibt es f√ºr Literale sogar einen speziellen Buchstaben u, wir k√∂nnen Konstanten definieren, wir k√∂nnen, wie im Beispiel, x dekrementieren und in Int konvertieren.  Ich erinnere Sie daran, dass Int mit uns vertraut ist. <br><br>  Was wird passieren? <br><br>  a) -1 4294967294 <br>  b) 0 4294967294 <br>  c) 0-2 <br>  d) Nicht kompiliert <br><br>  4294967294 ist die maximal erreichbare 32-Bit-Zahl. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br>  Richtige Option b. <br><br>  Hier wie in der vorherigen Version: Zuerst wird toInt () f√ºr x aufgerufen und erst dann dekrementiert.  Das Ergebnis der Dekrementierung ohne Vorzeichen wird angezeigt. Dies ist das Maximum von unsignedInt. <br><br>  Das Interessanteste ist, dass der Code nicht kompiliert wird, wenn Sie so schreiben: <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br>  Und f√ºr mich ist es sehr seltsam, dass die erste Zeile funktioniert und die zweite - nein, das ist unlogisch. <br><br>  Und in der Vorabversion w√§re die richtige Option C, was in JetBrains so gut gemacht ist, dass Fehler vor der Ver√∂ffentlichung der endg√ºltigen Version behoben werden. <br></div></div><br><h2>  Pazzler Nummer 4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br>  Wir sind in echtem Code auf diesen Fall gesto√üen.  Wir von Codeborne haben Coding Dojo gemacht und es gemeinsam im Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Game of Life</a> implementiert.  Wie Sie sehen k√∂nnen, ist es nicht sehr bequem, mit mehrstufigen Arrays auf Kotlin zu arbeiten. <br><br>  In Game of Life besteht ein wichtiger Teil des Algorithmus darin, die Anzahl der Nachbarn f√ºr eine Zelle zu bestimmen.  Alle Kleinen sind Nachbarn, und es h√§ngt davon ab, ob die Zelle weiterlebt oder stirbt.  In diesem Code k√∂nnen Sie diejenigen z√§hlen und davon ausgehen, was passiert. <br><br>  a) 6 <br>  b) 3 <br>  c) 2 <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Mal sehen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br>  Die richtige Antwort ist 3. <br><br>  Tatsache ist, dass das Plus aus der ersten Zeile nach unten verschoben wird und Kotlin dies f√ºr unaryPlus () h√§lt.  Infolgedessen werden nur die ersten drei Zellen summiert.  Wenn wir diesen Code in mehreren Zeilen schreiben m√∂chten, m√ºssen wir das Plus nach oben verschieben. <br><br>  Dies ist ein weiterer der "schlechten R√§tsel".  Denken Sie daran, dass Sie in Kotlin die Anweisung nicht in eine neue Zeile √ºbertragen m√ºssen, da sie sonst m√∂glicherweise als un√§r angesehen wird. <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br>  Ich habe keine Situationen gesehen, in denen unaryPlus in echtem Code au√üer DSL ben√∂tigt wird.  Dies ist ein sehr seltsames Thema. <br><br>  Dies ist der Preis, den wir f√ºr das Fehlen von Semikolons zahlen.  Wenn dies der Fall w√§re, w√§re klar, wann ein Ausdruck endet und ein anderer beginnt.  Und ohne sie muss der Compiler die Entscheidung treffen.  Zeilenvorsch√ºbe f√ºr den Compiler bedeuten sehr oft, dass es sinnvoll ist, die Zeilen separat zu untersuchen. <br><br>  Es gibt jedoch eine sehr coole JavaScript-Sprache, in der Sie auch keine Semikolons schreiben k√∂nnen, und dieser Code funktioniert weiterhin korrekt. <br></div></div><br><h2>  Pazzler Nummer 5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br>  Dieses R√§tsel wird von KotlinConf-Sprecher Thomas Nild vorgestellt. <br><br>  Kotlin hat eine gro√üartige Funktion f√ºr nullf√§hige Typen.  Wir haben nullable x und k√∂nnen es, wenn sich herausstellt, dass es null ist, √ºber den Elvis-Operator in einen normalen Wert konvertieren. <br><br>  Was wird? <br><br>  a) 3 <br>  b) 5 <br>  c) 2 <br>  d) 0 <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br>  Das Problem liegt wiederum in der Reihenfolge oder Priorit√§t der Bediener.  Wenn wir dies neu formatieren, wird das offizielle Format dies tun: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br>  Das Format schl√§gt bereits vor, dass 0 + y zuerst beginnt und erst dann x?:.  Daher bleibt nat√ºrlich 2, da X zwei ist, ist es nicht null. <br></div></div><br><h2>  Pazzler Nummer 6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = ‚Ä≥Simple IPA‚Ä≥ hops { name = ‚Ä≥Cascade‚Ä≥ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br>  Als sie mich hier anriefen, versprachen sie mir Craft Beer.  Ich werde ihn heute Abend suchen, ich habe ihn noch nicht gesehen.  Kotlin hat ein gro√üartiges Thema - Bauherren.  Mit vier Codezeilen schreiben wir unser DSL und erstellen es dann √ºber die Builder. <br><br>  Wir erstellen zuerst IPA, f√ºgen Hopfen namens Cascade hinzu, 100 Gramm in der 15. Minute des Kochens, und drucken dann dieses Rezept.  Was haben wir gemacht <br><br>  a) Rezept (Name = einfache IPA, Hopfen = [Hopfen (Name = Kaskade, atMinute = 15, Gramm = 100)]) <br>  b) IllegalArgumentException <br>  c) Nicht kompiliert <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br>  Wir haben etwas √Ñhnliches wie Craft Beer, aber es ist kein Hopfen darin, es ist verschwunden.  Sie wollten eine IPA, bekamen aber Baltic 7. <br><br>  Hier kam es zu einem Namenskonflikt.  Das Feld in Hops hei√üt eigentlich kind, und in der Zeile name = "Cascade" verwenden wir name, der mit dem Namen des Rezepts zwischengespeichert wird. <br><br>  Wir k√∂nnen unsere eigene BeerLang-Annotation erstellen und als Teil der BeerLang-DSL registrieren.  Jetzt versuchen wir, diesen Code auszuf√ºhren, und er sollte nicht mit uns kompiliert werden. <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br>  Nun wird uns gesagt, dass der Name in diesem Zusammenhang grunds√§tzlich nicht verwendet werden kann.  Daf√ºr wird DSLMarker ben√∂tigt, da der Compiler im Builder uns nicht erlaubt hat, das externe Feld zu verwenden, wenn wir dasselbe darin haben, damit es nicht zu Namenskonflikten kommt.  Der Code ist so festgelegt und wir bekommen unser Rezept. <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2>  Pazzler Nummer 7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Dieser Puzzler ist einer der JetBrains-Mitarbeiter.  Kotlin hat eine When-Funktion.  Es ist f√ºr alle Gelegenheiten geeignet, coolen Code zu schreiben. Es wird h√§ufig zusammen mit versiegelten Klassen f√ºr das API-Design verwendet. <br><br>  In diesem Fall haben wir eine Funktion f (), die einen Booleschen Wert annimmt und abh√§ngig von wahr und falsch etwas druckt. <br><br>  Was wird? <br><br>  a) wahr WAHR;  falsch falsch <br>  b) wahr WAHR;  false TRUE <br>  c) wahr FALSE;  falsch falsch <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Mal sehen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br>  Warum so?  Zuerst berechnen wir den Ausdruck x == true: Im ersten Fall ist er beispielsweise true == true, was true bedeutet.  Und dann gibt es noch einen Vergleich mit dem Muster, das wir wann √ºbergeben haben. <br><br>  Und wenn x auf false gesetzt ist, ergibt die Auswertung von x == true falsch. Die Stichprobe ist jedoch auch falsch - das Beispiel stimmt also mit der Stichprobe √ºberein. <br><br>  Es gibt zwei M√∂glichkeiten, diesen Code zu reparieren. Eine besteht darin, in beiden F√§llen "x ==" zu entfernen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Die zweite M√∂glichkeit besteht darin, (x) nach wann zu entfernen.  Wenn unter irgendwelchen Bedingungen gearbeitet wird und dann nicht mit der Probe √ºbereinstimmt. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2>  Pazzler Nummer 8 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = ‚Ä≥Kotlin‚Ä≥ } print(Kotlin().logo)</code> </pre><br>  Kotlin wurde als "null sichere" Sprache vermarktet.  Stellen Sie sich vor, wir haben eine abstrakte Klasse, sie hat einen Namen sowie eine Eigenschaft, die das Logo dieser Sprache zur√ºckgibt: Der erste Buchstabe des Namens wird f√ºr alle F√§lle gro√ü geschrieben (pl√∂tzlich wurde vergessen, das Anfangskapital zu schreiben). <br><br>  Da die Sprache null sicher ist, werden wir den Namen √§ndern und sollten wahrscheinlich das richtige Logo erhalten, das aus einem Buchstaben besteht.  Was bekommen wir wirklich? <br><br>  a) K. <br>  b) NullPointerException <br>  c) IllegalStateException <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br>  Wir haben eine NullPointerException, die wir nicht erhalten sollten.  Das Problem ist, dass der Konstruktor der Oberklasse zuerst aufgerufen wird, der Code versucht, das Eigenschaftslogo zu initialisieren und den Namen char von Null zu nehmen. An diesem Punkt ist der Name null, sodass eine NullPointerException auftritt. <br><br>  Der beste Weg, dies zu beheben, ist Folgendes: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = ‚Ä≥Kotlin‚Ä≥ }</code> </pre><br>  Wenn wir solchen Code ausf√ºhren, erhalten wir "K".  Jetzt ruft die Basisklasse den Konstruktor der Basisklasse auf, ruft tats√§chlich den Getter-Namen auf und ruft Kotlin ab. <br><br>  Immobilien sind eine gro√üartige Funktion in Kotlin, aber Sie m√ºssen sehr vorsichtig sein, wenn Sie Eigenschaften √ºberschreiben, da es sehr leicht ist, zu vergessen, Fehler zu machen oder das Falsche zu versichern. <br><br></div></div><br><h2>  Pazzler Nummer 9 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(‚Ä≥$i, $j; ‚Ä≥) } } result.forEach { it() }</code> </pre><br>  Es gibt eine ver√§nderbare Liste einiger be√§ngstigender Dinge.  Wenn es Sie an Scala erinnert, dann ist es nicht umsonst, weil es wirklich so aussieht.  Es gibt ein List-Lambd, wir nehmen zwei Z√§hler - I und j, erh√∂hen und machen dann etwas mit ihnen.  Was wird passieren? <br><br>  a) 1 1;  2 2;  3 3 <br>  b) 1 3;  2 3;  3 3 <br>  c) 3 1;  3 2;  3 3 <br>  d) keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Lass uns rennen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br>  Wir bekommen 3 1;  3 2;  3 3. Dies geschieht, weil i eine Variable ist und ihren Wert bis zum Ende der Funktion beibeh√§lt.  Und j wird als Wert √ºbergeben. <br><br>  Wenn anstelle von var i = 0 val i = 0 w√§re, w√ºrde dies nicht funktionieren, aber dann k√∂nnten wir die Variable nicht erh√∂hen. <br><br>  Hier in Kotlin verwenden wir Closure, diese Funktion ist nicht in Java.  Es ist sehr cool, aber es kann uns bei√üen, wenn wir den Wert von i nicht sofort verwenden, sondern ihn an das Lambda √ºbergeben, das sp√§ter beginnt und den letzten Wert dieser Variablen sieht.  Und j wird als Wert √ºbergeben, da die Variablen in der Schleifenbedingung - sie sind dieselben wie val - ihren Wert nicht mehr √§ndern. <br><br>  In JavaScript lautet die Antwort ‚Äû3 3;  3 3;  3 3 ‚Äù, weil dort nichts durch Wert √ºbertragen wird. <br><br></div></div><br><h2>  Pazzler Nummer 10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(‚Ä≥$a, $b‚Ä≥) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br>  Wir haben eine Funktion foo (), nehmen zwei Boolesche Werte, drucken sie aus, alles scheint einfach zu sein.  Und wir haben eine Reihe von Zahlen, es bleibt abzuwarten, welche Zahl gr√∂√üer als die andere ist, und zu entscheiden, welche Option richtig ist. <br><br>  a) wahr, wahr <br>  b) falsch, falsch <br>  c) null, null <br>  d) nicht zusammengestellt <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br>  Nicht kompiliert. <br><br>  Das Problem ist, dass der Compiler der Meinung ist, dass dies den generischen Parametern √§hnlich ist: mit &lt;a, b&gt;.  Obwohl es so aussieht, als sei ‚Äûc‚Äú keine Klasse, ist nicht klar, warum es generische Parameter haben sollte. <br><br>  Wenn der Code so w√§re, w√ºrde es gut funktionieren: <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br>  Es scheint mir, dass dies ein Fehler im Compiler ist.  Aber wenn ich mit einem solchen R√§tsel zu Andrei Breslav gehe, sagt er: "Das liegt daran, dass der Parser so ist, sie wollten nicht, dass er zu langsam ist."  Im Allgemeinen findet er immer eine Erkl√§rung warum. <br><br>  Leider ist das so.  Er sagte, dass sie es nicht reparieren werden, weil der Parser drin ist <br>  Kotlin kennt die Semantik noch nicht.  Das Parsen erfolgt zuerst und gibt es dann an eine andere Compilerkomponente weiter.  Leider wird dies wahrscheinlich so bleiben.  Schreiben Sie also keine zwei solchen spitzen Klammern und keinen Code in die Mitte! <br></div></div><br><h2>  Pazzler Nummer 11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(‚Ä≥Kotlin‚Ä≥, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(‚Ä≥Hello $name, $items‚Ä≥)</code> </pre><br>  Delegieren ist eine gro√üartige Funktion in Kotlin.  Andrei Breslav sagt √ºbrigens, dass dies ein Merkmal ist, das er gerne aus der Sprache entfernen w√ºrde, er mag es nicht mehr.  Jetzt werden wir vielleicht herausfinden, warum!  Und er sagte auch, dass Begleitobjekte h√§sslich sind. <br><br>  Aber Datenklassen sind definitiv sch√∂n.  Wir haben eine Datenklasse Container, die einen Namen und Elemente f√ºr sich nimmt.  Gleichzeitig implementieren wir im Container den Elementtyp, dies ist List, und delegieren alle seine Methoden an Elemente. <br><br>  Dann verwenden wir eine andere coole Funktion - Destructure.  Wir "zerst√∂ren" die Namens- und Elementelemente aus dem Container und zeigen sie auf dem Bildschirm an.  Alles scheint einfach und klar zu sein.  Was wird passieren? <br><br>  a) Hallo Kotlin, [1, 2, 3] <br>  b) Hallo Kotlin, 1 <br>  c) Hallo 1, 2 <br>  d) Hallo Kotlin, 2 <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br>  Die dunkelste Option ist d.  Er stellt sich als wahr heraus.  Wie sich herausstellte, verschwinden Elemente einfach aus der Artikelsammlung und nicht von Anfang oder Ende, sondern nur in der Mitte.  Warum? <br><br>  Das Problem bei der Destrukturierung ist, dass aufgrund der Delegation auch alle Sammlungen in Kotlin vorhanden sind <br>  haben ihre eigene Option der Destrukturierung.  Ich kann val (I, j) = listOf (1, 2) schreiben und diese 1 und 2 in Variablen umwandeln, dh List hat die Funktionen component1 () und implementiert <br>  Komponente2 (). <br><br>  Die Datenklasse hat auch Komponente1 () und Komponente2 ().  Da die zweite Komponente in diesem Fall privat ist, gewinnt diejenige, die bei List √∂ffentlich ist. Das zweite Element wird aus List √ºbernommen, und wir kommen hierher. 2. Die Moral ist sehr einfach: Tu das nicht, tu das nicht. <br></div></div><br><h2>  Pazzler Nummer 12 </h2><br>  Das n√§chste R√§tsel ist sehr be√§ngstigend.  Dies ist eine unterw√ºrfige Person, die irgendwie mit Kotlin verbunden ist, also wei√ü er, was er schreibt. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br>  Wir haben eine Erweiterungsfunktion f√ºr nullable Any, das hei√üt, sie kann √ºberhaupt auf alles angewendet werden.  Dies ist eine sehr n√ºtzliche Funktion.  Wenn es noch nicht in Ihrem Projekt enthalten ist, lohnt es sich, es hinzuzuf√ºgen, da es alles, was Sie wollen, in alles stecken kann.  Dann nehmen wir 42 und werfen es in Nichts. <br><br>  Wenn wir sicher sein wollen, dass wir etwas Wichtiges getan haben, k√∂nnen wir es stattdessen !!!  Schreiben !!!!, der Kotlin-Compiler erm√∂glicht Ihnen Folgendes: Wenn Sie zwei Ausrufezeichen vermissen, schreiben Sie mindestens sechsundzwanzig. <br><br>  Dann machen wir wenn (wahr) und dann verstehe ich selbst nichts ... Lassen Sie uns sofort entscheiden, was passiert. <br><br>  a) 87 <br>  b) Kotlin.Unit <br>  c) ClassCastException <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Beobachten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br>  Es ist sehr schwierig, eine logische Erkl√§rung zu geben.  H√∂chstwahrscheinlich ist die Einheit hier auf die Tatsache zur√ºckzuf√ºhren, dass es dort nichts mehr zu pushen gibt.  Dies ist ung√ºltiger Code, aber er funktioniert, weil wir Nothing verwendet haben.  Wir haben etwas in Nothing hochgeladen, und dies ist ein spezieller Typ, der dem Compiler mitteilt, dass eine Instanz dieses Typs niemals erscheinen sollte.  Der Compiler wei√ü, dass, wenn die M√∂glichkeit des Auftretens von Nothing besteht, was per Definition unm√∂glich ist, Sie dies nicht weiter √ºberpr√ºfen k√∂nnen, dies eine unm√∂gliche Situation ist. <br><br>  H√∂chstwahrscheinlich ist dies ein Fehler im Compiler. Das JetBrains-Team sagte sogar, dass dieser Fehler m√∂glicherweise eines Tages behoben wird. Dies hat keine gro√üe Priorit√§t.  Der Trick ist, dass wir den Compiler hier wegen dieser Besetzung ausgetrickst haben.  Wenn Sie die Zeile 42.asGeneric &lt;Nothing&gt; () entfernen !!!  und h√∂r auf zu schummeln, der Code h√∂rt auf zu kompilieren.  Und wenn wir gehen, wird der Compiler verr√ºckt, denkt, dass dies ein unm√∂glicher Ausdruck ist, und stopft alles, was da drin ist. <br><br>  Ich verstehe das  Vielleicht wird es eines Tages jemand besser erkl√§ren. <br><br></div></div><br><h2>  Pazzler Nummer 13 </h2><br>  Wir haben eine sehr interessante Funktion.  Sie k√∂nnen die Abh√§ngigkeitsinjektion verwenden oder darauf verzichten, Singletones durch das Objekt erstellen und Ihr Programm cool ausf√ºhren.  Warum brauchst du Koin, Dolch oder so?  Das Testen wird jedoch schwierig sein. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br>  Wir haben Klasse A offen f√ºr Vererbung, es nimmt etwas in sich auf, wir erstellen zwei Objekte, Singleton, B und C, beide werden von A geerbt und √ºbergeben sich dort gegenseitig.  Das hei√üt, es wird ein ausgezeichneter Zyklus gebildet.  Dann drucken wir, was B und C bekommen haben. <br><br>  a) null;  null <br>  b) C;  null <br>  c) ExceptionInInitializerError <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br>  Die richtige Option ist C;  null <br><br>  Man w√ºrde denken, wenn das erste Objekt initialisiert wird, ist das zweite noch nicht da.  Aber wenn wir daraus schlie√üen, fehlt C B. Das hei√üt, die umgekehrte Reihenfolge wird erhalten: Aus irgendeinem Grund hat der Compiler beschlossen, zuerst C zu initialisieren, und dann hat er B zusammen mit C initialisiert. Es sieht unlogisch aus, es w√§re logisch, im Gegenteil, null ;;  B. B. <br><br>  Aber der Compiler hat versucht, etwas zu tun, es ist nicht gelungen, er hat dort null gelassen und beschlossen, uns nichts zuzuwerfen.  Es k√∂nnte auch so sein. <br><br>  Wenn √ºberhaupt?  Entfernen Sie im Parametertyp?, dann funktioniert es nicht. <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br>  Wir k√∂nnen dem Compiler gut sagen, dass er es versucht hat, als null aufgel√∂st wurde, aber fehlgeschlagen ist, aber was?  Nein, er wirft uns eine Ausnahme, dass es unm√∂glich ist, einen Zyklus zu machen. <br></div></div><br><h2>  Pazzler ‚Ññ14 </h2><br>  Version 1.3 hat gro√üartige neue Coroutinen in Kotlin ver√∂ffentlicht.  Ich habe lange dar√ºber nachgedacht, wie ich ein R√§tsel √ºber Corutin entwickeln kann, damit jemand es verstehen kann.  Ich denke f√ºr manche Leute ist jeder Code mit Coroutinen ein R√§tsel. <br><br>  In 1.3 wurden einige Funktionsnamen ge√§ndert, die in 1.2 in der experimentellen API enthalten waren.  Beispielsweise wird buildSequence () einfach in sequence () umbenannt.  Das hei√üt, wir k√∂nnen mit der Yield-Funktion, Endlosschleifen, hervorragende Sequenzen erstellen und dann versuchen, etwas aus dieser Sequenz herauszuholen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br>  Sie sagten mit Coroutinen, dass alle coolen Grundelemente, die in anderen Sprachen vorliegen, wie z. B. Yield, als Bibliotheksfunktionen ausgef√ºhrt werden k√∂nnen, da Yield eine Suspend-Funktion ist, die unterbrochen werden kann. <br><br>  Was wird passieren? <br><br>  a) [1, 2, 3] <br>  b) [0, 1, 2] <br>  c) Endlosschleife <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br>  Die richtige Option ist die letzte. <br><br>  Sequenz ist eine faule Erfindung, und wenn wir uns daran festhalten, ist sie auch faul.  Wenn Sie jedoch zu List hinzuf√ºgen, wird [0, 1, 2] wirklich ausgedruckt. <br><br>  Die richtige Antwort bezieht sich √ºberhaupt nicht auf Coroutinen.  Coroutinen funktionieren wirklich, sie sind einfach zu bedienen.  F√ºr die Sequenz- und Ertragsfunktion m√ºssen Sie nicht einmal eine Bibliothek mit Coroutinen verbinden, alles befindet sich bereits in der Standardbibliothek. <br></div></div><br><h2>  Pazzler ‚Ññ15 </h2><br>  Dieses R√§tsel wird auch vom Entwickler von JetBrains unterdr√ºckt.  Es gibt so einen h√∂llischen Code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br>  Als ich ihn w√§hrend der KotlinConf zum ersten Mal sah, konnte ich nicht schlafen, ich versuchte zu verstehen, was es war.  Solch ein kryptischer Code kann in Kotlin geschrieben werden. Wenn also jemand Scalaz f√ºr be√§ngstigend hielt, ist dies auch in Kotlin m√∂glich. <br><br>  Lassen Sie uns raten: <br><br>  a) Kotlin.Unit <br>  b) Kotlin. Nichts <br>  c) Nicht kompiliert <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Lass uns rennen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br>  Wir haben eine Einheit, die aus dem Nichts kam. <br><br>  Warum?  Zuerst weisen wir die Variable Lambda zu: {-&gt;} - Dies ist ein g√ºltiger Code. Sie k√∂nnen ein leeres Lambda schreiben.  Es hat keine Parameter, es gibt nichts zur√ºck.  Dementsprechend gibt es Unit zur√ºck. <br><br>  Wir weisen der Variablen ein Lambda zu, schreiben sofort eine Erweiterung in dieses Lambda und f√ºhren es dann aus.  In der Tat wird es einfach Kotlin.Unit reservieren. <br><br>  Dann k√∂nnen Sie auf diesem Lambda eine Erweiterungsfunktion schreiben: <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}</code> </pre><br>  Es ist auf dem Typ Function &lt;*&gt; deklariert, und was wir oben haben, ist auch daf√ºr geeignet.  Eigentlich ist es Funktion &lt;Einheit&gt;, aber ich habe Unit nicht geschrieben, dass es nicht klar war.  Wissen Sie, wie ein Stern in Kotlin funktioniert?     ,    Java.    ,    . <br><br>     ,    Unit  {},      ,  void-. ,   ,  .  -,      ‚Äî   . <br></div></div><br>    .    ,  Kotlin ‚Äî  .   iOS-     ,    ,   Kotlin   ! <br><blockquote>       Mobius,  :  <b>Mobius</b>  <b>22-23   </b> .   Kotlin    ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ¬´Coroutining Android Apps¬ª        .        ( Android,   iOS),      ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,   <b>1 </b>   . <br><br>  :     ,            ‚Äî  <b>6 </b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440974/">https://habr.com/ru/post/de440974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440958/index.html">Wie ich versucht habe, eine Kartensuche nach Treibern zu reparieren. Teil 2</a></li>
<li><a href="../de440960/index.html">Orange Pi 2G-IOT: Minenfeldkarte</a></li>
<li><a href="../de440962/index.html">Kommunikationsanbieter werden sich verpflichten, Vertr√§ge √ºber den Anschluss von Wohngeb√§uden abzuschlie√üen</a></li>
<li><a href="../de440966/index.html">Anschlie√üen der KELLER-Sensoren an MATLAB</a></li>
<li><a href="../de440972/index.html">Die Innopolis University wird Russlands erste internationale autonome Fahrzeugdesignschule abhalten</a></li>
<li><a href="../de440976/index.html">Ich habe ganz √ñsterreich gescannt und festgestellt ...</a></li>
<li><a href="../de440978/index.html">Drahtloser Wi-Fi-programmierbarer Raumthermostat mit Luftqualit√§tsmonitor und anderen n√ºtzlichen Funktionen</a></li>
<li><a href="../de440980/index.html">Welche Geschenke warten am 23. Februar auf M√§nner? Umfrageergebnisse</a></li>
<li><a href="../de440984/index.html">Wie sich die Senkung der Erwerbsquote auf uns (Karteninhaber) auswirkt - 2</a></li>
<li><a href="../de440986/index.html">Lokomotiven: Was wir √ºber selbstfahrende Eisenbahnwaggons wissen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>