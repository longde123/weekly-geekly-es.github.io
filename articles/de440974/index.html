<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📊 🤦🏻 🏉 Kotlin Puzzlers, Vol. 2: eine neue Reihe von Rätseln 🚣🏼 👩🏾‍🚀 🌿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Können Sie vorhersagen, wie sich ein solcher Kotlin-Code verhält? Wird kompiliert, was ausgegeben wird und warum? 

 Egal wie gut die Programmiersprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin Puzzlers, Vol. 2: eine neue Reihe von Rätseln</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440974/"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br>  Können Sie vorhersagen, wie sich ein solcher Kotlin-Code verhält?  Wird kompiliert, was ausgegeben wird und warum? <br><br>  Egal wie gut die Programmiersprache sein mag, sie kann so werfen, dass sie nur noch am Hinterkopf kratzt.  Kotlin ist keine Ausnahme - es enthält auch Rätsel, wenn selbst ein sehr kurzer Code unerwartetes Verhalten aufweist. <br><br>  Bereits 2017 haben wir auf Habré eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auswahl</a> solcher Puzzler von <b>Anton</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Keks antonkeks veröffentlicht</a> .  Und später trat er mit der zweiten Auswahl bei Mobius auf, und wir übersetzten sie nun auch für Habr in eine Textansicht, wobei wir die richtigen Antworten unter den Spoilern versteckten. <br><br>  Wir fügen auch die Videoaufzeichnung der Rede bei. Wenn im Text etwas unverständlich erscheint, können Sie sich auch an sie wenden. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die erste Hälfte der Rätsel richtet sich an diejenigen, die mit Kotlin nicht sehr vertraut sind.  Die zweite Hälfte ist für Hardcore-Kotlin-Entwickler.  Wir werden alles auf Kotlin 1.3 starten, auch wenn der progressive Modus aktiviert ist.  Puzzler-Quellcodes befinden sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> .  Wer neue Ideen hat, sendet Pull-Anfragen. <br><br><h2>  Pazzler Nummer 1 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(″Hello″) == print(″World″) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br>  Bevor wir eine einfache Hallo-Funktion haben, werden mehrere Druckvorgänge ausgeführt.  Und wir starten diese Funktion selbst.  Eine einfache Übertaktungsfrage: Was soll es drucken? <br><br>  a) HelloWorld <br>  b) HelloWorldfalse <br>  c) HelloWorldtrue <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Richtige Antwort</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br>  Die erste Option war richtig.  Der Vergleich wird ausgelöst, nachdem beide Ausdrucke bereits gestartet wurden. Er kann nicht früher gestartet werden.  Warum wird ein solcher Code überhaupt kompiliert?  Jede andere Funktion als die Rückgabe von Nothing gibt etwas zurück.  Da alles in Kotlin ein Ausdruck ist, ist auch die Rückkehr ein Ausdruck.  Der Rückgabetyp ist Nothing. Er wird in einen beliebigen Typ umgewandelt, sodass Sie ihn wie folgt vergleichen können.  Und print gibt Unit zurück, sodass Unit beliebig oft mit Nothing verglichen werden kann und alles hervorragend funktioniert. <br></div></div><br><h2>  Pazzler Nummer 2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br>  Hinweis, den Sie nicht erraten: Eine beängstigende Zahl ist wirklich die kleinstmögliche 32-Bit-Ganzzahl mit Vorzeichen. <br><br>  Hier sieht alles einfach aus.  Kotlin hat großartige Erweiterungsfunktionen wie .inc () zum Inkrementieren.  Wir können es auf Int aufrufen und das Ergebnis drucken.  Was wird passieren? <br><br>  a) -2147483647 <br>  b) -2147483649 <br>  c) 2147483647 <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br>  Wie Sie der Fehlermeldung entnehmen können, liegt hier das Problem mit Long vor.  Aber warum lange? <br><br>  Erweiterungsfunktionen haben Priorität, und der Compiler führt zuerst inc () und dann den Minusoperator aus.  Wenn inc () entfernt wird, ist es Int und alles wird funktionieren.  Aber inc (), beginnend zuerst, wandelt 2_147_483_648 in Long um, weil diese Zahl ohne Minus nicht mehr gültig ist Int.  Es stellt sich als Long heraus und erst dann wird Minus aufgerufen.  All dies kann nicht mehr an die Funktion printInt () übergeben werden, da ein Int erforderlich ist. <br><br>  Wenn wir den printInt-Aufruf in einen regulären Druck ändern, der Long akzeptieren kann, ist die zweite Option korrekt. <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br>  Wir sehen, dass dies tatsächlich lang ist.  Beachten Sie Folgendes: Nicht alle Puzzleteile können in echtem Code ausgeführt werden, aber dieser kann. <br></div></div><br><h2>  Pazzler Nummer 3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  In Kotlin 1.3 kamen neue großartige Funktionen.  Neben der endgültigen Version von Corutin haben wir <br>  jetzt endlich vorzeichenlose nummern.  Dies ist insbesondere dann erforderlich, wenn Sie eine Art Netzwerkcode schreiben. <br><br>  Jetzt gibt es für Literale sogar einen speziellen Buchstaben u, wir können Konstanten definieren, wir können, wie im Beispiel, x dekrementieren und in Int konvertieren.  Ich erinnere Sie daran, dass Int mit uns vertraut ist. <br><br>  Was wird passieren? <br><br>  a) -1 4294967294 <br>  b) 0 4294967294 <br>  c) 0-2 <br>  d) Nicht kompiliert <br><br>  4294967294 ist die maximal erreichbare 32-Bit-Zahl. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br>  Richtige Option b. <br><br>  Hier wie in der vorherigen Version: Zuerst wird toInt () für x aufgerufen und erst dann dekrementiert.  Das Ergebnis der Dekrementierung ohne Vorzeichen wird angezeigt. Dies ist das Maximum von unsignedInt. <br><br>  Das Interessanteste ist, dass der Code nicht kompiliert wird, wenn Sie so schreiben: <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br>  Und für mich ist es sehr seltsam, dass die erste Zeile funktioniert und die zweite - nein, das ist unlogisch. <br><br>  Und in der Vorabversion wäre die richtige Option C, was in JetBrains so gut gemacht ist, dass Fehler vor der Veröffentlichung der endgültigen Version behoben werden. <br></div></div><br><h2>  Pazzler Nummer 4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br>  Wir sind in echtem Code auf diesen Fall gestoßen.  Wir von Codeborne haben Coding Dojo gemacht und es gemeinsam im Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Game of Life</a> implementiert.  Wie Sie sehen können, ist es nicht sehr bequem, mit mehrstufigen Arrays auf Kotlin zu arbeiten. <br><br>  In Game of Life besteht ein wichtiger Teil des Algorithmus darin, die Anzahl der Nachbarn für eine Zelle zu bestimmen.  Alle Kleinen sind Nachbarn, und es hängt davon ab, ob die Zelle weiterlebt oder stirbt.  In diesem Code können Sie diejenigen zählen und davon ausgehen, was passiert. <br><br>  a) 6 <br>  b) 3 <br>  c) 2 <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Mal sehen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br>  Die richtige Antwort ist 3. <br><br>  Tatsache ist, dass das Plus aus der ersten Zeile nach unten verschoben wird und Kotlin dies für unaryPlus () hält.  Infolgedessen werden nur die ersten drei Zellen summiert.  Wenn wir diesen Code in mehreren Zeilen schreiben möchten, müssen wir das Plus nach oben verschieben. <br><br>  Dies ist ein weiterer der "schlechten Rätsel".  Denken Sie daran, dass Sie in Kotlin die Anweisung nicht in eine neue Zeile übertragen müssen, da sie sonst möglicherweise als unär angesehen wird. <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br>  Ich habe keine Situationen gesehen, in denen unaryPlus in echtem Code außer DSL benötigt wird.  Dies ist ein sehr seltsames Thema. <br><br>  Dies ist der Preis, den wir für das Fehlen von Semikolons zahlen.  Wenn dies der Fall wäre, wäre klar, wann ein Ausdruck endet und ein anderer beginnt.  Und ohne sie muss der Compiler die Entscheidung treffen.  Zeilenvorschübe für den Compiler bedeuten sehr oft, dass es sinnvoll ist, die Zeilen separat zu untersuchen. <br><br>  Es gibt jedoch eine sehr coole JavaScript-Sprache, in der Sie auch keine Semikolons schreiben können, und dieser Code funktioniert weiterhin korrekt. <br></div></div><br><h2>  Pazzler Nummer 5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br>  Dieses Rätsel wird von KotlinConf-Sprecher Thomas Nild vorgestellt. <br><br>  Kotlin hat eine großartige Funktion für nullfähige Typen.  Wir haben nullable x und können es, wenn sich herausstellt, dass es null ist, über den Elvis-Operator in einen normalen Wert konvertieren. <br><br>  Was wird? <br><br>  a) 3 <br>  b) 5 <br>  c) 2 <br>  d) 0 <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br>  Das Problem liegt wiederum in der Reihenfolge oder Priorität der Bediener.  Wenn wir dies neu formatieren, wird das offizielle Format dies tun: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br>  Das Format schlägt bereits vor, dass 0 + y zuerst beginnt und erst dann x?:.  Daher bleibt natürlich 2, da X zwei ist, ist es nicht null. <br></div></div><br><h2>  Pazzler Nummer 6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = ″Simple IPA″ hops { name = ″Cascade″ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br>  Als sie mich hier anriefen, versprachen sie mir Craft Beer.  Ich werde ihn heute Abend suchen, ich habe ihn noch nicht gesehen.  Kotlin hat ein großartiges Thema - Bauherren.  Mit vier Codezeilen schreiben wir unser DSL und erstellen es dann über die Builder. <br><br>  Wir erstellen zuerst IPA, fügen Hopfen namens Cascade hinzu, 100 Gramm in der 15. Minute des Kochens, und drucken dann dieses Rezept.  Was haben wir gemacht <br><br>  a) Rezept (Name = einfache IPA, Hopfen = [Hopfen (Name = Kaskade, atMinute = 15, Gramm = 100)]) <br>  b) IllegalArgumentException <br>  c) Nicht kompiliert <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br>  Wir haben etwas Ähnliches wie Craft Beer, aber es ist kein Hopfen darin, es ist verschwunden.  Sie wollten eine IPA, bekamen aber Baltic 7. <br><br>  Hier kam es zu einem Namenskonflikt.  Das Feld in Hops heißt eigentlich kind, und in der Zeile name = "Cascade" verwenden wir name, der mit dem Namen des Rezepts zwischengespeichert wird. <br><br>  Wir können unsere eigene BeerLang-Annotation erstellen und als Teil der BeerLang-DSL registrieren.  Jetzt versuchen wir, diesen Code auszuführen, und er sollte nicht mit uns kompiliert werden. <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br>  Nun wird uns gesagt, dass der Name in diesem Zusammenhang grundsätzlich nicht verwendet werden kann.  Dafür wird DSLMarker benötigt, da der Compiler im Builder uns nicht erlaubt hat, das externe Feld zu verwenden, wenn wir dasselbe darin haben, damit es nicht zu Namenskonflikten kommt.  Der Code ist so festgelegt und wir bekommen unser Rezept. <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2>  Pazzler Nummer 7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Dieser Puzzler ist einer der JetBrains-Mitarbeiter.  Kotlin hat eine When-Funktion.  Es ist für alle Gelegenheiten geeignet, coolen Code zu schreiben. Es wird häufig zusammen mit versiegelten Klassen für das API-Design verwendet. <br><br>  In diesem Fall haben wir eine Funktion f (), die einen Booleschen Wert annimmt und abhängig von wahr und falsch etwas druckt. <br><br>  Was wird? <br><br>  a) wahr WAHR;  falsch falsch <br>  b) wahr WAHR;  false TRUE <br>  c) wahr FALSE;  falsch falsch <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Mal sehen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br>  Warum so?  Zuerst berechnen wir den Ausdruck x == true: Im ersten Fall ist er beispielsweise true == true, was true bedeutet.  Und dann gibt es noch einen Vergleich mit dem Muster, das wir wann übergeben haben. <br><br>  Und wenn x auf false gesetzt ist, ergibt die Auswertung von x == true falsch. Die Stichprobe ist jedoch auch falsch - das Beispiel stimmt also mit der Stichprobe überein. <br><br>  Es gibt zwei Möglichkeiten, diesen Code zu reparieren. Eine besteht darin, in beiden Fällen "x ==" zu entfernen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Die zweite Möglichkeit besteht darin, (x) nach wann zu entfernen.  Wenn unter irgendwelchen Bedingungen gearbeitet wird und dann nicht mit der Probe übereinstimmt. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2>  Pazzler Nummer 8 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = ″Kotlin″ } print(Kotlin().logo)</code> </pre><br>  Kotlin wurde als "null sichere" Sprache vermarktet.  Stellen Sie sich vor, wir haben eine abstrakte Klasse, sie hat einen Namen sowie eine Eigenschaft, die das Logo dieser Sprache zurückgibt: Der erste Buchstabe des Namens wird für alle Fälle groß geschrieben (plötzlich wurde vergessen, das Anfangskapital zu schreiben). <br><br>  Da die Sprache null sicher ist, werden wir den Namen ändern und sollten wahrscheinlich das richtige Logo erhalten, das aus einem Buchstaben besteht.  Was bekommen wir wirklich? <br><br>  a) K. <br>  b) NullPointerException <br>  c) IllegalStateException <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br>  Wir haben eine NullPointerException, die wir nicht erhalten sollten.  Das Problem ist, dass der Konstruktor der Oberklasse zuerst aufgerufen wird, der Code versucht, das Eigenschaftslogo zu initialisieren und den Namen char von Null zu nehmen. An diesem Punkt ist der Name null, sodass eine NullPointerException auftritt. <br><br>  Der beste Weg, dies zu beheben, ist Folgendes: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = ″Kotlin″ }</code> </pre><br>  Wenn wir solchen Code ausführen, erhalten wir "K".  Jetzt ruft die Basisklasse den Konstruktor der Basisklasse auf, ruft tatsächlich den Getter-Namen auf und ruft Kotlin ab. <br><br>  Immobilien sind eine großartige Funktion in Kotlin, aber Sie müssen sehr vorsichtig sein, wenn Sie Eigenschaften überschreiben, da es sehr leicht ist, zu vergessen, Fehler zu machen oder das Falsche zu versichern. <br><br></div></div><br><h2>  Pazzler Nummer 9 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(″$i, $j; ″) } } result.forEach { it() }</code> </pre><br>  Es gibt eine veränderbare Liste einiger beängstigender Dinge.  Wenn es Sie an Scala erinnert, dann ist es nicht umsonst, weil es wirklich so aussieht.  Es gibt ein List-Lambd, wir nehmen zwei Zähler - I und j, erhöhen und machen dann etwas mit ihnen.  Was wird passieren? <br><br>  a) 1 1;  2 2;  3 3 <br>  b) 1 3;  2 3;  3 3 <br>  c) 3 1;  3 2;  3 3 <br>  d) keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Lass uns rennen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br>  Wir bekommen 3 1;  3 2;  3 3. Dies geschieht, weil i eine Variable ist und ihren Wert bis zum Ende der Funktion beibehält.  Und j wird als Wert übergeben. <br><br>  Wenn anstelle von var i = 0 val i = 0 wäre, würde dies nicht funktionieren, aber dann könnten wir die Variable nicht erhöhen. <br><br>  Hier in Kotlin verwenden wir Closure, diese Funktion ist nicht in Java.  Es ist sehr cool, aber es kann uns beißen, wenn wir den Wert von i nicht sofort verwenden, sondern ihn an das Lambda übergeben, das später beginnt und den letzten Wert dieser Variablen sieht.  Und j wird als Wert übergeben, da die Variablen in der Schleifenbedingung - sie sind dieselben wie val - ihren Wert nicht mehr ändern. <br><br>  In JavaScript lautet die Antwort „3 3;  3 3;  3 3 ”, weil dort nichts durch Wert übertragen wird. <br><br></div></div><br><h2>  Pazzler Nummer 10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(″$a, $b″) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br>  Wir haben eine Funktion foo (), nehmen zwei Boolesche Werte, drucken sie aus, alles scheint einfach zu sein.  Und wir haben eine Reihe von Zahlen, es bleibt abzuwarten, welche Zahl größer als die andere ist, und zu entscheiden, welche Option richtig ist. <br><br>  a) wahr, wahr <br>  b) falsch, falsch <br>  c) null, null <br>  d) nicht zusammengestellt <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br>  Nicht kompiliert. <br><br>  Das Problem ist, dass der Compiler der Meinung ist, dass dies den generischen Parametern ähnlich ist: mit &lt;a, b&gt;.  Obwohl es so aussieht, als sei „c“ keine Klasse, ist nicht klar, warum es generische Parameter haben sollte. <br><br>  Wenn der Code so wäre, würde es gut funktionieren: <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br>  Es scheint mir, dass dies ein Fehler im Compiler ist.  Aber wenn ich mit einem solchen Rätsel zu Andrei Breslav gehe, sagt er: "Das liegt daran, dass der Parser so ist, sie wollten nicht, dass er zu langsam ist."  Im Allgemeinen findet er immer eine Erklärung warum. <br><br>  Leider ist das so.  Er sagte, dass sie es nicht reparieren werden, weil der Parser drin ist <br>  Kotlin kennt die Semantik noch nicht.  Das Parsen erfolgt zuerst und gibt es dann an eine andere Compilerkomponente weiter.  Leider wird dies wahrscheinlich so bleiben.  Schreiben Sie also keine zwei solchen spitzen Klammern und keinen Code in die Mitte! <br></div></div><br><h2>  Pazzler Nummer 11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(″Kotlin″, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(″Hello $name, $items″)</code> </pre><br>  Delegieren ist eine großartige Funktion in Kotlin.  Andrei Breslav sagt übrigens, dass dies ein Merkmal ist, das er gerne aus der Sprache entfernen würde, er mag es nicht mehr.  Jetzt werden wir vielleicht herausfinden, warum!  Und er sagte auch, dass Begleitobjekte hässlich sind. <br><br>  Aber Datenklassen sind definitiv schön.  Wir haben eine Datenklasse Container, die einen Namen und Elemente für sich nimmt.  Gleichzeitig implementieren wir im Container den Elementtyp, dies ist List, und delegieren alle seine Methoden an Elemente. <br><br>  Dann verwenden wir eine andere coole Funktion - Destructure.  Wir "zerstören" die Namens- und Elementelemente aus dem Container und zeigen sie auf dem Bildschirm an.  Alles scheint einfach und klar zu sein.  Was wird passieren? <br><br>  a) Hallo Kotlin, [1, 2, 3] <br>  b) Hallo Kotlin, 1 <br>  c) Hallo 1, 2 <br>  d) Hallo Kotlin, 2 <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br>  Die dunkelste Option ist d.  Er stellt sich als wahr heraus.  Wie sich herausstellte, verschwinden Elemente einfach aus der Artikelsammlung und nicht von Anfang oder Ende, sondern nur in der Mitte.  Warum? <br><br>  Das Problem bei der Destrukturierung ist, dass aufgrund der Delegation auch alle Sammlungen in Kotlin vorhanden sind <br>  haben ihre eigene Option der Destrukturierung.  Ich kann val (I, j) = listOf (1, 2) schreiben und diese 1 und 2 in Variablen umwandeln, dh List hat die Funktionen component1 () und implementiert <br>  Komponente2 (). <br><br>  Die Datenklasse hat auch Komponente1 () und Komponente2 ().  Da die zweite Komponente in diesem Fall privat ist, gewinnt diejenige, die bei List öffentlich ist. Das zweite Element wird aus List übernommen, und wir kommen hierher. 2. Die Moral ist sehr einfach: Tu das nicht, tu das nicht. <br></div></div><br><h2>  Pazzler Nummer 12 </h2><br>  Das nächste Rätsel ist sehr beängstigend.  Dies ist eine unterwürfige Person, die irgendwie mit Kotlin verbunden ist, also weiß er, was er schreibt. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br>  Wir haben eine Erweiterungsfunktion für nullable Any, das heißt, sie kann überhaupt auf alles angewendet werden.  Dies ist eine sehr nützliche Funktion.  Wenn es noch nicht in Ihrem Projekt enthalten ist, lohnt es sich, es hinzuzufügen, da es alles, was Sie wollen, in alles stecken kann.  Dann nehmen wir 42 und werfen es in Nichts. <br><br>  Wenn wir sicher sein wollen, dass wir etwas Wichtiges getan haben, können wir es stattdessen !!!  Schreiben !!!!, der Kotlin-Compiler ermöglicht Ihnen Folgendes: Wenn Sie zwei Ausrufezeichen vermissen, schreiben Sie mindestens sechsundzwanzig. <br><br>  Dann machen wir wenn (wahr) und dann verstehe ich selbst nichts ... Lassen Sie uns sofort entscheiden, was passiert. <br><br>  a) 87 <br>  b) Kotlin.Unit <br>  c) ClassCastException <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Beobachten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br>  Es ist sehr schwierig, eine logische Erklärung zu geben.  Höchstwahrscheinlich ist die Einheit hier auf die Tatsache zurückzuführen, dass es dort nichts mehr zu pushen gibt.  Dies ist ungültiger Code, aber er funktioniert, weil wir Nothing verwendet haben.  Wir haben etwas in Nothing hochgeladen, und dies ist ein spezieller Typ, der dem Compiler mitteilt, dass eine Instanz dieses Typs niemals erscheinen sollte.  Der Compiler weiß, dass, wenn die Möglichkeit des Auftretens von Nothing besteht, was per Definition unmöglich ist, Sie dies nicht weiter überprüfen können, dies eine unmögliche Situation ist. <br><br>  Höchstwahrscheinlich ist dies ein Fehler im Compiler. Das JetBrains-Team sagte sogar, dass dieser Fehler möglicherweise eines Tages behoben wird. Dies hat keine große Priorität.  Der Trick ist, dass wir den Compiler hier wegen dieser Besetzung ausgetrickst haben.  Wenn Sie die Zeile 42.asGeneric &lt;Nothing&gt; () entfernen !!!  und hör auf zu schummeln, der Code hört auf zu kompilieren.  Und wenn wir gehen, wird der Compiler verrückt, denkt, dass dies ein unmöglicher Ausdruck ist, und stopft alles, was da drin ist. <br><br>  Ich verstehe das  Vielleicht wird es eines Tages jemand besser erklären. <br><br></div></div><br><h2>  Pazzler Nummer 13 </h2><br>  Wir haben eine sehr interessante Funktion.  Sie können die Abhängigkeitsinjektion verwenden oder darauf verzichten, Singletones durch das Objekt erstellen und Ihr Programm cool ausführen.  Warum brauchst du Koin, Dolch oder so?  Das Testen wird jedoch schwierig sein. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br>  Wir haben Klasse A offen für Vererbung, es nimmt etwas in sich auf, wir erstellen zwei Objekte, Singleton, B und C, beide werden von A geerbt und übergeben sich dort gegenseitig.  Das heißt, es wird ein ausgezeichneter Zyklus gebildet.  Dann drucken wir, was B und C bekommen haben. <br><br>  a) null;  null <br>  b) C;  null <br>  c) ExceptionInInitializerError <br>  d) Nicht kompiliert <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br>  Die richtige Option ist C;  null <br><br>  Man würde denken, wenn das erste Objekt initialisiert wird, ist das zweite noch nicht da.  Aber wenn wir daraus schließen, fehlt C B. Das heißt, die umgekehrte Reihenfolge wird erhalten: Aus irgendeinem Grund hat der Compiler beschlossen, zuerst C zu initialisieren, und dann hat er B zusammen mit C initialisiert. Es sieht unlogisch aus, es wäre logisch, im Gegenteil, null ;;  B. B. <br><br>  Aber der Compiler hat versucht, etwas zu tun, es ist nicht gelungen, er hat dort null gelassen und beschlossen, uns nichts zuzuwerfen.  Es könnte auch so sein. <br><br>  Wenn überhaupt?  Entfernen Sie im Parametertyp?, dann funktioniert es nicht. <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br>  Wir können dem Compiler gut sagen, dass er es versucht hat, als null aufgelöst wurde, aber fehlgeschlagen ist, aber was?  Nein, er wirft uns eine Ausnahme, dass es unmöglich ist, einen Zyklus zu machen. <br></div></div><br><h2>  Pazzler №14 </h2><br>  Version 1.3 hat großartige neue Coroutinen in Kotlin veröffentlicht.  Ich habe lange darüber nachgedacht, wie ich ein Rätsel über Corutin entwickeln kann, damit jemand es verstehen kann.  Ich denke für manche Leute ist jeder Code mit Coroutinen ein Rätsel. <br><br>  In 1.3 wurden einige Funktionsnamen geändert, die in 1.2 in der experimentellen API enthalten waren.  Beispielsweise wird buildSequence () einfach in sequence () umbenannt.  Das heißt, wir können mit der Yield-Funktion, Endlosschleifen, hervorragende Sequenzen erstellen und dann versuchen, etwas aus dieser Sequenz herauszuholen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br>  Sie sagten mit Coroutinen, dass alle coolen Grundelemente, die in anderen Sprachen vorliegen, wie z. B. Yield, als Bibliotheksfunktionen ausgeführt werden können, da Yield eine Suspend-Funktion ist, die unterbrochen werden kann. <br><br>  Was wird passieren? <br><br>  a) [1, 2, 3] <br>  b) [0, 1, 2] <br>  c) Endlosschleife <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br>  Die richtige Option ist die letzte. <br><br>  Sequenz ist eine faule Erfindung, und wenn wir uns daran festhalten, ist sie auch faul.  Wenn Sie jedoch zu List hinzufügen, wird [0, 1, 2] wirklich ausgedruckt. <br><br>  Die richtige Antwort bezieht sich überhaupt nicht auf Coroutinen.  Coroutinen funktionieren wirklich, sie sind einfach zu bedienen.  Für die Sequenz- und Ertragsfunktion müssen Sie nicht einmal eine Bibliothek mit Coroutinen verbinden, alles befindet sich bereits in der Standardbibliothek. <br></div></div><br><h2>  Pazzler №15 </h2><br>  Dieses Rätsel wird auch vom Entwickler von JetBrains unterdrückt.  Es gibt so einen höllischen Code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br>  Als ich ihn während der KotlinConf zum ersten Mal sah, konnte ich nicht schlafen, ich versuchte zu verstehen, was es war.  Solch ein kryptischer Code kann in Kotlin geschrieben werden. Wenn also jemand Scalaz für beängstigend hielt, ist dies auch in Kotlin möglich. <br><br>  Lassen Sie uns raten: <br><br>  a) Kotlin.Unit <br>  b) Kotlin. Nichts <br>  c) Nicht kompiliert <br>  d) Keine der oben genannten <br><br><div class="spoiler">  <b class="spoiler_title">Lass uns rennen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br>  Wir haben eine Einheit, die aus dem Nichts kam. <br><br>  Warum?  Zuerst weisen wir die Variable Lambda zu: {-&gt;} - Dies ist ein gültiger Code. Sie können ein leeres Lambda schreiben.  Es hat keine Parameter, es gibt nichts zurück.  Dementsprechend gibt es Unit zurück. <br><br>  Wir weisen der Variablen ein Lambda zu, schreiben sofort eine Erweiterung in dieses Lambda und führen es dann aus.  In der Tat wird es einfach Kotlin.Unit reservieren. <br><br>  Dann können Sie auf diesem Lambda eine Erweiterungsfunktion schreiben: <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}</code> </pre><br>  Es ist auf dem Typ Function &lt;*&gt; deklariert, und was wir oben haben, ist auch dafür geeignet.  Eigentlich ist es Funktion &lt;Einheit&gt;, aber ich habe Unit nicht geschrieben, dass es nicht klar war.  Wissen Sie, wie ein Stern in Kotlin funktioniert?     ,    Java.    ,    . <br><br>     ,    Unit  {},      ,  void-. ,   ,  .  -,      —   . <br></div></div><br>    .    ,  Kotlin —  .   iOS-     ,    ,   Kotlin   ! <br><blockquote>       Mobius,  :  <b>Mobius</b>  <b>22-23   </b> .   Kotlin    — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> «Coroutining Android Apps»        .        ( Android,   iOS),      —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,   <b>1 </b>   . <br><br>  :     ,            —  <b>6 </b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440974/">https://habr.com/ru/post/de440974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440958/index.html">Wie ich versucht habe, eine Kartensuche nach Treibern zu reparieren. Teil 2</a></li>
<li><a href="../de440960/index.html">Orange Pi 2G-IOT: Minenfeldkarte</a></li>
<li><a href="../de440962/index.html">Kommunikationsanbieter werden sich verpflichten, Verträge über den Anschluss von Wohngebäuden abzuschließen</a></li>
<li><a href="../de440966/index.html">Anschließen der KELLER-Sensoren an MATLAB</a></li>
<li><a href="../de440972/index.html">Die Innopolis University wird Russlands erste internationale autonome Fahrzeugdesignschule abhalten</a></li>
<li><a href="../de440976/index.html">Ich habe ganz Österreich gescannt und festgestellt ...</a></li>
<li><a href="../de440978/index.html">Drahtloser Wi-Fi-programmierbarer Raumthermostat mit Luftqualitätsmonitor und anderen nützlichen Funktionen</a></li>
<li><a href="../de440980/index.html">Welche Geschenke warten am 23. Februar auf Männer? Umfrageergebnisse</a></li>
<li><a href="../de440984/index.html">Wie sich die Senkung der Erwerbsquote auf uns (Karteninhaber) auswirkt - 2</a></li>
<li><a href="../de440986/index.html">Lokomotiven: Was wir über selbstfahrende Eisenbahnwaggons wissen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>