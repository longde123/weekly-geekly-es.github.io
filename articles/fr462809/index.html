<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏼 🍂 🧑🏼 WinForms: erreurs, Holmes 👩🏽‍🚀 🧓🏾 🍠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous aimons rechercher les erreurs dans les projets Microsoft. Pourquoi? C'est simple: leurs projets sont généralement faciles à vérifier (vous pouvez...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WinForms: erreurs, Holmes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/462809/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/aeb/a84/71baeba847a8865aef0cc8148effbb8c.png" alt="Image 5"></div><br>  Nous aimons rechercher les erreurs dans les projets Microsoft.  Pourquoi?  C'est simple: leurs projets sont généralement faciles à vérifier (vous pouvez travailler dans un environnement Visual Studio pour lequel PVS-Studio a un plugin pratique) et ils contiennent peu d'erreurs.  C'est pourquoi l'algorithme de travail habituel est le suivant: rechercher et télécharger un projet open source depuis MS;  vérifiez-le;  choisissez des erreurs intéressantes;  assurez-vous qu'il y en a peu;  écrire un article sans oublier de féliciter les développeurs.  Super!  Gagnant-gagnant-gagnant: cela a pris un peu de temps, les patrons sont heureux de voir de nouveaux documents sur le blog, et le karma va bien.  Mais cette fois "quelque chose s'est mal passé".  Voyons ce que nous avons trouvé dans le code source de Windows Forms et si nous devons dire du bien de Microsoft cette fois. <br><a name="habracut"></a><br>  <b>Présentation</b> <br><br>  Début décembre 2018, Microsoft a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">annoncé</a> la sortie de l'aperçu 1 de .NET Core 3. Un peu plus tôt (vers la mi-octobre), GitHub a commencé à divulguer activement les sources de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows Forms</a> - la plate-forme d'interface utilisateur .NET Core pour créer des applications de bureau Windows .  Vous pouvez voir les statistiques de validation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Maintenant, n'importe qui peut télécharger le code source de WinForms pour examen. <br><br>  J'ai également téléchargé les sources pour y rechercher des erreurs avec PVS-Studio.  Le contrôle n'a pas posé de problème.  Nous avions besoin de: Visual Studio 2019, .NET Core 3.0 SDK Preview, PVS-Studio.  Et nous avons ici le journal des avertissements de l'analyseur. <br><br>  Après avoir reçu le rapport PVS-Studio, je le trie généralement par numéros de diagnostic dans l'ordre croissant (la fenêtre avec le journal des messages PVS-Studio dans l'environnement Visual Studio propose différentes options de tri et de filtrage de la liste).  Il vous permet de travailler avec des groupes d'erreurs similaires, ce qui simplifie considérablement l'analyse du code source.  Je marque des erreurs intéressantes dans la liste avec une "étoile" et seulement ensuite, après avoir analysé tout le journal, j'écris des fragments de code et les décris.  Puisqu'il y a généralement peu d'erreurs, je les "remue" en essayant de placer les plus intéressantes au début et à la fin de l'article.  Mais cette fois, il s'est avéré qu'il y avait beaucoup d'erreurs (eh, l'intrigue n'a pas été sauvée depuis longtemps) et je vais les citer dans l'ordre des nombres de diagnostics. <br><br>  Qu'avons-nous trouvé?  833 avertissements élevés et moyens (249 et 584, respectivement) ont été émis pour 540 000 lignes de code (sans compter les vides) dans des fichiers de 1670 cs.  Et oui, traditionnellement, je ne vérifiais pas les tests et je ne prenais pas en compte les avertissements Low (il y en avait 215).  Selon mes observations précédentes, les avertissements sont trop nombreux pour le projet MS.  Mais tous les avertissements ne sont pas des erreurs. <br><br>  Pour ce projet, le nombre de fausses alarmes était d'environ 30%.  Dans environ 20% des cas, je ne pouvais tout simplement pas conclure exactement s'il s'agissait d'une erreur ou non car je ne connaissais pas assez bien le code.  Et au moins 20% des erreurs que j'ai manquées peuvent être considérées comme "facteur humain": hâte, fatigue, etc.  Soit dit en passant, l'effet inverse est également possible: certains déclencheurs de même type, dont le nombre pourrait atteindre 70-80, j'ai regardé "à côté d'un", ce qui pourrait parfois augmenter le nombre d'erreurs que je pensais réelles. <br><br>  Quoi qu'il en soit, 30% des avertissements indiquent de vraies erreurs, ce qui est un pourcentage assez élevé si l'on tient compte du fait que l'analyseur n'était pas préconfiguré. <br><br>  Donc, le nombre d'erreurs que j'ai réussi à trouver était d'environ 240, ce qui est dans la plage des statistiques données.  Encore une fois, à mon avis, ce n'est pas le résultat le plus remarquable pour un projet MS (même s'il ne fera que 0,44 erreur pour 1000 lignes de code) et il y a probablement plus d'erreurs réelles dans le code WinForms également.  Je suggère de considérer les raisons à la fin de l'article et voyons maintenant les erreurs les plus intéressantes. <br><br>  <b>Des erreurs</b> <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3003</a> L'utilisation du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle</a> 'if (A) {...} else if (A) {...}' a été détectée.  Il y a une probabilité de présence d'erreur logique.  Vérifiez les lignes: 213, 224. ButtonStandardAdapter.cs 213 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> up, CheckState state)</span></span></span><span class="hljs-function"> </span></span>{ up = up &amp;&amp; state == CheckState.Unchecked; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } .... }</code> </pre> <br>  <i>Si</i> et <i>sinon si les</i> blocs vérifient la même condition.  Cela ressemble à du copier-coller.  Est-ce une erreur?  Si vous regardez la déclaration de la méthode <i>IsHighContrastHighlighted</i> , vous pouvez en douter: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsHighContrastHighlighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SystemInformation.HighContrast &amp;&amp; Application.RenderWithVisualStyles &amp;&amp; (Control.Focused || Control.MouseIsOver || (Control.IsDefault &amp;&amp; Control.Enabled)); }</code> </pre> <br>  La méthode peut probablement renvoyer différentes valeurs pour les appels séquentiels.  Et ce qui se passe dans la méthode de l'appelant, bien sûr, semble étrange, mais a le droit d'exister.  Cependant, je conseillerais aux auteurs de jeter un œil à ce fragment de code.  Juste au cas où.  C'est également un bon exemple de la difficulté de tirer des conclusions lors de l'analyse de code inconnu. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3004</a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> 'then' est équivalente à l'instruction 'else'.  RichTextBox.cs 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SelectionCharOffset { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selCharOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... NativeMethods.CHARFORMATA cf = GetCharFormat(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if the effects member contains valid info if ((cf.dwMask &amp; RichTextBoxConstants.CFM_OFFSET) != 0) { selCharOffset = cf.yOffset; // &lt;= } else { // The selection contains characters of different offsets, // so we just return the offset of the first character. selCharOffset = cf.yOffset; // &lt;= } .... } .... }</span></span></code> </pre> <br>  Et il y a certainement une erreur de copier-coller ici.  Quelle que soit la condition, la variable <i>selCharOffset</i> obtiendra toujours la même valeur. <br><br>  Il existe deux autres erreurs de ce type dans le code WinForms: <ul><li>  V3004 L'instruction 'then' est équivalente à l'instruction 'else'.  SplitContainer.cs 1700 </li><li>  V3004 L'instruction 'then' est équivalente à l'instruction 'else'.  ToolstripProfessionalRenderer.cs 371 </li></ul><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3008</a> La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 681, 680. ProfessionalColorTable.cs 681 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSystemColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Dictionary&lt;KnownColors, Color&gt; rgbTable)</span></span></span><span class="hljs-function"> </span></span>{ .... rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonFace; rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonShadow; .... }</code> </pre> <br>  La méthode remplit le dictionnaire <i>rgbTable</i> .  L'analyseur a pointé un fragment de code où différentes valeurs sont écrites deux fois sur la même clé dans l'ordre.  Les choses iraient bien, mais il y a encore 16 de ces fragments dans cette méthode.  Cela ne ressemble plus à une erreur unique en son genre.  Mais pourquoi ils font cela reste un mystère pour moi.  Je n'ai trouvé aucun signe de code généré automatiquement.  Cela ressemble à ceci dans l'éditeur: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/f68/827/006f688275da3701f28abe7918835ce9.png" alt="Image 3"></div><br>  Je vais vous donner les dix premiers avertissements de la liste: <br><br><ol><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 785, 784. ProfessionalColorTable.cs 785 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 787, 786. ProfessionalColorTable.cs 787 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 789, 788. ProfessionalColorTable.cs 789 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 791, 790. ProfessionalColorTable.cs 791 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 797, 796. ProfessionalColorTable.cs 797 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 799, 798. ProfessionalColorTable.cs 799 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 807, 806. ProfessionalColorTable.cs 807 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 815, 814. ProfessionalColorTable.cs 815 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 817, 816. ProfessionalColorTable.cs 817 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 823, 822. ProfessionalColorTable.cs 823 </li></ol><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3011</a> Deux conditions opposées ont été rencontrées.  La deuxième condition est toujours fausse.  Vérifiez les lignes: 5242, 5240. DataGrid.cs 5242 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHierarchyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkHierarchy &amp;&amp; listManager != null &amp;&amp; myGridTable != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myGridTable == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { // there was nothing to check return; } for (int j = 0; j &lt; myGridTable.GridColumnStyles.Count; j++) { DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j]; } checkHierarchy = false; } }</span></span></code> </pre> <br>  L'opérateur de <i>retour</i> ne sera jamais exécuté.  Très probablement, la condition <i>myGridTable! = Null</i> dans le bloc <i>if</i> externe a été ajoutée ultérieurement lors du refactoring.  Et maintenant, la vérification de <i>myGridTable == null</i> n'a aucun sens.  Pour améliorer la qualité du code, vous devez supprimer cette vérification. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019 Il est</a> possible qu'une variable incorrecte soit comparée à null après la conversion de type à l'aide du mot clé 'as'.  Vérifiez les variables «gauche», «cscLeft».  TypeCodeDomSerializer.cs 611 <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019 Il est</a> possible qu'une variable incorrecte soit comparée à null après la conversion de type à l'aide du mot clé 'as'.  Vérifiez les variables «droite», «cscRight».  TypeCodeDomSerializer.cs 615 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object left, object right)</span></span></span><span class="hljs-function"> </span></span>{ OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection; OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == left) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cscLeft.Order - cscRight.Order; <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br>  L'analyseur a généré deux avertissements pour la méthode <i>Compare</i> à la fois.  Quel est le problème?  C'est que les valeurs <i>cscLeft</i> et <i>cscRight</i> ne sont pas vérifiées pour <i>null</i> du tout.  Ils peuvent obtenir cette valeur après une <i>conversion</i> infructueuse vers le type <i>OrderedCodeStatementCollection</i> .  Ensuite, une exception sera levée dans la dernière expression de <i>retour</i> .  Cette situation est possible lorsque tous les contrôles de <i>gauche</i> et de <i>droite</i> passent et n'aboutissent pas à une sortie préalable de la méthode. <br><br>  Pour corriger le code, vous devez utiliser <i>cscLeft / cscRight</i> au lieu de <i>gauche / droite</i> partout. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3020</a> Une «pause» inconditionnelle dans une boucle.  SelectionService.cs 421 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISelectionService.SetSelectedComponents( ICollection components, SelectionTypes selectionType) { .... <span class="hljs-comment"><span class="hljs-comment">// Handle the click case object requestedPrimary = null; int primaryIndex; if (fPrimary &amp;&amp; 1 == components.Count) { foreach (object o in components) { requestedPrimary = o; if (o == null) { throw new ArgumentNullException(nameof(components)); } break; } } .... }</span></span></code> </pre> <br>  Ce fragment fait plutôt référence à "l'odeur de code".  Il n'y a pas d'erreur ici.  Mais des questions se posent quant à l'organisation de la boucle <i>foreach</i> .  Il est clair pourquoi il est nécessaire ici: en raison de la nécessité d'extraire des éléments de la collection, passés en tant que <i>ICollection</i> .  Mais pourquoi la boucle, initialement conçue pour une seule itération (la condition préalable est la présence d'un seul élément dans les <i>composants de</i> la collection), nécessitait-elle un support supplémentaire tel que la <i>rupture</i> ?  Probablement, la réponse peut être considérée comme suit: "Historiquement, cela s'est produit."  Le code a l'air moche. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3022 L'</a> expression 'ocxState! = Null' est toujours vraie.  AxHost.cs 2186 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State OcxState { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ocxState = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ocxState != null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { axState[manualUpdate] = ocxState._GetManualUpdate(); licenseKey = ocxState._GetLicenseKey(); } else { axState[manualUpdate] = false; licenseKey = null; } .... } }</span></span></code> </pre> <br>  En raison d'une erreur logique, un "code mort" s'est produit dans ce fragment.  Les expressions du bloc <i>else</i> ne seront jamais exécutées. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3027</a> La variable 'e' a été utilisée dans l'expression logique avant d'être vérifiée par rapport à null dans la même expression logique.  ImageEditor.cs 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... ImageEditor e = ....; Type myClass = GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myClass.Equals(e.GetType()) &amp;&amp; e != null &amp;&amp; myClass.IsInstanceOfType(e)) { .... } .... }</code> </pre> <br>  La variable <i>e</i> de la condition est d'abord utilisée puis vérifiée par rapport à <i>null</i> .  Bonjour, <i>NullReferenceException</i> . <br><br>  Encore une de ces erreurs: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3027</a> La variable 'dropDownItem' a été utilisée dans l'expression logique avant d'être vérifiée par rapport à null dans la même expression logique.  ToolStripMenuItemDesigner.cs 1351 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterInSituEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ToolStripItem toolItem)</span></span></span><span class="hljs-function"> </span></span>{ .... ToolStripDropDownItem dropDownItem = toolItem as ToolStripDropDownItem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dropDownItem.Owner is ToolStripDropDownMenu) &amp;&amp; dropDownItem != null &amp;&amp; dropDownItem.Bounds.Width &lt; commitedEditorNode.Bounds.Width) { .... } .... }</code> </pre> <br>  La situation est similaire à la précédente mais avec la variable <i>dropDownItem</i> .  Je pense que de telles erreurs apparaissent à la suite d'une refonte insouciante.  Probablement, une partie de la condition <i>! (DropDownItem.Owner est ToolStripDropDownMenu) a</i> été ajoutée au code plus tard. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôle</a> récurrent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3030</a> .  La condition 'columnCount&gt; 0' a déjà été vérifiée à la ligne 3900. ListView.cs 3903 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal ColumnHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ColumnHeader ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refreshSubItems)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Add the column to our internal array int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length); if (columnCount &gt; 0) { ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1]; if (columnCount &gt; 0) { System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount); } .... } .... }</span></span></code> </pre> <br>  Une erreur qui peut sembler inoffensive.  En effet, une vérification inutile est effectuée qui n'affecte pas la logique opérationnelle.  Et parfois, cela se fait même lorsque vous devez vérifier à nouveau l'état d'un composant visuel, par exemple, obtenir le nombre d'entrées dans la liste.  Mais dans ce cas, la variable <i>locale</i> <i>columnCount</i> est vérifiée deux fois.  C'est très suspect.  Soit ils voulaient vérifier une autre variable, soit ils ont utilisé une mauvaise condition dans l'une des vérifications. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3061 Le</a> paramètre 'lprcClipRect' est toujours réécrit dans le corps de la méthode avant d'être utilisé.  WebBrowserSiteBase.cs 281 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext( out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) { ppDoc = null; ppFrame = Host.GetParentContainer(); lprcPosRect.left = Host.Bounds.X; lprcPosRect.top = Host.Bounds.Y; .... lprcClipRect = WebBrowserHelper.GetClipRect(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (lpFrameInfo != null) { lpFrameInfo.cb = Marshal.SizeOf&lt;NativeMethods.tagOIFI&gt;(); lpFrameInfo.fMDIApp = false; .... } return NativeMethods.S_OK; }</span></span></code> </pre> <br>  Une erreur non évidente.  Oui, le paramètre <i>lprcClipRect</i> est réellement initialisé avec une nouvelle valeur sans l'utiliser en aucune façon.  Mais à quoi cela mène-t-il finalement?  Je pense que quelque part dans le code appelant, la référence passée par ce paramètre restera inchangée, bien qu'elle ne soit pas censée l'être.  Vraiment, appréciez le traitement d'autres variables dans cette méthode.  Même son nom (préfixe "Get") indique qu'une certaine initialisation sera effectuée à l'intérieur de la méthode via les paramètres passés.  Et il en est ainsi.  Les deux premiers paramètres ( <i>ppFrame</i> et <i>ppDoc</i> ) sont passés avec le modificateur <i>out</i> et ils obtiennent de nouvelles valeurs.  Les références <i>lprcPosRect</i> et <i>lpFrameInfo</i> sont utilisées pour accéder et initialiser les champs de classe.  Seul <i>lprcClipRect</i> se démarque.  Le modificateur <i>out</i> ou <i>ref</i> est probablement requis pour ce paramètre. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3066</a> Ordre incorrect possible des arguments passés à la méthode 'AdjustCellBorderStyle': 'isFirstDisplayedRow' et 'isFirstDisplayedColumn'.  DataGridViewComboBoxCell.cs 1934 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataGridViewCellMouseEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... dgvabsEffective = AdjustCellBorderStyle( DataGridView.AdvancedCellBorderStyle, dgvabsPlaceholder, singleVerticalBorderAdded, singleHorizontalBorderAdded, isFirstDisplayedRow, <span class="hljs-comment"><span class="hljs-comment">// &lt;= isFirstDisplayedColumn); // &lt;= .... }</span></span></code> </pre> <br>  L'analyseur soupçonnait que les deux derniers arguments étaient mélangés.  Jetons un coup d'œil à la déclaration de la méthode <i>AdjustCellBorderStyle</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> DataGridViewAdvancedBorderStyle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustCellBorderStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataGridViewAdvancedBorderStyledataGridViewAdvancedBorderStyleInput, DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleVerticalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleHorizontalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedColumn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedRow)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br>  On dirait une erreur.  Oui, certains arguments sont souvent passés dans l'ordre inverse, par exemple pour échanger certaines variables.  Mais je ne pense pas que ce soit le cas.  Rien dans les méthodes de l'appelant ou de l'appelé n'indique ce modèle d'utilisation.  Tout d'abord, les variables de type <i>booléen</i> sont mélangées.  Deuxièmement, les noms des méthodes sont également réguliers: pas de "Swap" ou "Reverse".  D'ailleurs, ce n'est pas si difficile de se tromper comme ça.  Les gens perçoivent souvent différemment l'ordre de la paire "ligne / colonne".  Pour moi, par exemple, c'est la "ligne / colonne" qui est familière.  Mais pour l'auteur de la méthode appelée <i>AdjustCellBorderStyle</i> , évidemment, l'ordre le plus courant est "colonne / ligne". <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3070</a> La variable non initialisée 'LANG_USER_DEFAULT' est utilisée lors de l'initialisation de la variable 'LOCALE_USER_DEFAULT'.  NativeMethods.cs 890 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); .... }</code> </pre> <br>  Rare erreur.  L'ordre d'initialisation des champs de classe est mélangé.  Pour calculer la valeur du champ <i>LOCALE_USER_DEFAULT,</i> le champ <i>LANG_USER_DEFAULT</i> est utilisé, qui n'est pas encore initialisé et a une valeur de 0. En passant, la variable <i>LANG_USER_DEFAULT</i> n'est utilisée nulle part ailleurs dans le code.  J'ai fait un effort supplémentaire et j'ai écrit un petit programme de console qui simule la situation.  J'ai remplacé certaines constantes utilisées dans le code WinForms par leurs valeurs réelles: <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELANGID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> primary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sub)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((ushort)(sub)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | (ushort)(primary)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAKELCID(lgid, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sort)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &amp; lgid) | (((<span class="hljs-number"><span class="hljs-number">0x000f</span></span>) &amp; sort) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.Console.WriteLine(NativeMethods.LOCALE_USER_DEFAULT); } }</code> </pre> <br>  Par conséquent, la console affichera: 0. <i>Échangeons</i> maintenant les déclarations des champs <i>LOCALE_USER_DEFAULT</i> et <i>LANG_USER_DEFAULT</i> .  Le résultat de l'exécution du programme est le suivant: 1024. Je pense qu'il n'y a rien de plus à commenter ici. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 Déréférence</a> nulle possible.  Envisagez d'inspecter les «ces».  CodeDomSerializerBase.cs 562 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IDesignerSerializationManager manager, CodeStatement statement)</span></span></span><span class="hljs-function"> </span></span>{ .... CodeExpressionStatement ces = statement as CodeExpressionStatement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ces != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... DeserializeExpression(manager, null, ces.Expression); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } .... }</span></span></code> </pre> <br>  Le code qui devrait "planter" assez régulièrement, car vous pouvez entrer dans la branche <i>else</i> juste au moment où la référence <i>ces</i> est égale à <i>null</i> . <br><br>  Un autre exemple similaire: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 Déréférence</a> nulle possible.  Pensez à inspecter 'comboBox'.  ComboBox.cs 6610 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateOwnerDrawRegions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComboBox comboBox, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Rectangle topOwnerDrawArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, comboBox.Width, innerBorder.Top); .... }</code> </pre> <br>  Le code paradoxal.  Apparemment, la <i>vérification if (comboBox! = Null) a</i> été confondue avec <i>if (comboBox == null)</i> .  Et donc, nous aurons une autre <i>NullReferenceException.</i> <br><br>  Nous avons considéré deux erreurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> assez évidentes où vous pouvez tracer visuellement une utilisation potentielle de référence nulle dans une méthode.  Mais le diagnostic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> est beaucoup plus efficace et peut trouver de telles erreurs pour les chaînes d'appels de méthode.  Il n'y a pas si longtemps, nous avons considérablement amélioré le flux de données et les mécanismes d'analyse interprocédurale.  Vous pouvez lire à ce sujet dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de référence Nullable en C # 8.0 et analyse statique</a> ".  Mais voici ce genre d'erreur détectée dans WinForms: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 Déréférence</a> nulle possible à l'intérieur de la méthode sur 'reader.NameTable'.  Pensez à inspecter le 1er argument: contentReader.  ResXResourceReader.cs 267 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureResData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... XmlTextReader contentReader = null; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileContents != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileName != null || stream != null) { .... contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } SetupNameTable(contentReader); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } finally { .... } .... }</span></span></code> </pre> <br>  Regardez ce qui arrive à la variable <i>contentReader</i> dans le corps de la méthode.  Après l'initialisation avec null, il sera à nouveau initialisé dans l'un des contrôles.  Mais la série de vérifications ne se termine pas avec le bloc <i>else</i> .  Cela signifie que dans certains cas rares (ou en raison d'une refactorisation à l'avenir), la référence <b>peut</b> toujours rester nulle.  Ensuite, il sera transmis à la méthode <i>SetupNameTable</i> où il est utilisé sans aucune vérification: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupNameTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlReader reader)</span></span></span><span class="hljs-function"> </span></span>{ reader.NameTable.Add(ResXResourceWriter.TypeStr); reader.NameTable.Add(ResXResourceWriter.NameStr); .... }</code> </pre> <br>  Il s'agit d'un code potentiellement dangereux. <br><br>  Et encore une erreur où l'analyseur a dû passer par la chaîne d'appel pour détecter le problème: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 Déréférence</a> nulle possible.  Pensez à inspecter la «disposition».  DockAndAnchorLayout.cs 156 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Rectangle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IArrangedElement element, Rectangle displayRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureOnly)</span></span></span><span class="hljs-function"> </span></span>{ .... AnchorInfo layout = GetAnchorInfo(element); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = layout.Left + displayRect.X; .... }</code> </pre> <br>  L'analyseur prétend qu'il est possible d'obtenir une référence nulle à partir de la méthode <i>GetAnchorInfo</i> , ce qui provoquera une exception lors du calcul de la valeur <i>gauche</i> .  Passons en revue toute la chaîne d'appels et vérifions si c'est vrai: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnchorInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IArrangedElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (AnchorInfo)element.Properties.GetObject(s_layoutInfoProperty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>=&gt; GetObject(key, out _); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> found)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> keyIndex = SplitKey(key, out <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LocateObjectEntry(keyIndex, out <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index)) { found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">// We have found the relevant entry. See if // the bitmask indicates the value is used. if (((1 &lt;&lt; element) &amp; s_objEntries[index].Mask) == 0) { found = false; return null; } found = true; switch (element) { case 0: return s_objEntries[index].Value1; .... default: Debug.Fail("Invalid element obtained from LocateObjectEntry"); return null; } }</span></span></code> </pre> <br>  En effet, dans certains cas, la méthode <i>GetObject</i> qui termine la chaîne d'appel retournera <i>null</i> , qui sera transmise à la méthode appelante sans aucune vérification supplémentaire.  Probablement, il est nécessaire de couvrir une telle situation dans la méthode <i>GetAnchorDestination</i> . <br><br>  Il y a beaucoup d'erreurs de ce type dans le code WinForms, <b>plus de 70</b> .  Ils se ressemblent tous et je ne les décrirai pas dans l'article. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3091</a> Analyse empirique.  Il est possible qu'une faute de frappe soit présente à l'intérieur du littéral de chaîne: "ShowCheckMargin".  Le mot «ShowCheckMargin» est suspect.  PropertyNames.cs 136 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNames</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowImageMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowCheckMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; .... }</code> </pre> <br>  Un bon exemple d'une erreur qui n'est pas si facile à trouver.  Lors de l'initialisation des champs de classe, la même valeur est utilisée, bien que l'auteur du code n'en ait évidemment pas l'intention (le copier-coller est à blâmer).  L'analyseur a tiré cette conclusion en comparant les noms des variables et les valeurs des chaînes attribuées.  Je n'ai donné que des lignes avec des erreurs mais vous devriez vérifier à quoi cela ressemble dans l'éditeur de code: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/196/4de/3131964de8f3f5161678c44086ed2e40.png" alt="Image 2"></div><br>  La détection de ces erreurs est ce qui démontre toute la puissance et la durée d'attention sans fin des outils d'analyse statique. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3095</a> L'objet 'currentForm' a été utilisé avant d'être vérifié par rapport à null.  Vérifiez les lignes: 3386, 3404. Application.cs 3386 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMessageLoopInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reason, ApplicationContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... hwndOwner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef( null, UnsafeNativeMethods.GetWindowLong( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(currentForm, currentForm.Handle), <span class="hljs-comment"><span class="hljs-comment">// &lt;= NativeMethods.GWL_HWNDPARENT)); .... if (currentForm != null &amp;&amp; ....) .... }</span></span></code> </pre> <br>  C'est classique.  La variable <i>currentForm</i> est utilisée sans aucun contrôle.  Mais ensuite, il est vérifié pour <i>null</i> dans le code.  Dans ce cas, je peux vous conseiller d'être plus attentif lorsque vous travaillez avec des types de référence et d'utiliser également des analyseurs statiques :). <br><br>  Encore une de ces erreurs: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3095</a> L'objet 'backgroundBrush' a été utilisé avant d'être vérifié par rapport à null.  Vérifiez les lignes: 2331, 2334. DataGrid.cs 2331 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value.Equals(backgroundBrush.Color)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (backgroundBrush != null &amp;&amp; BackgroundBrush != DefaultBackgroundBrush) .... } } }</span></span></code> </pre> <br>  Dans le code WinForms, j'ai rencontré <b>plus de 60</b> erreurs de ce type.  À mon avis, tous sont plutôt critiques et nécessitent l'attention des développeurs.  Mais il n'est plus aussi intéressant d'en parler dans l'article, je me limiterai donc aux deux mentionnés ci-dessus. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> L'objet '_propInfo' a été utilisé et a été vérifié par rapport à null dans différentes branches d'exécution.  Vérifiez les lignes: 996, 982. Binding.cs 996 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPropValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object value)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propInfo != null) .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _propInfo.SetValue(_control, value); } .... }</code> </pre> <br>  Par souci d'exhaustivité - également une sorte de classique, erreur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> .  La situation inverse.  Au début, le développeur utilise une référence potentiellement <i>nulle en</i> toute sécurité, après l'avoir vérifiée par rapport à null, mais arrête de le faire plus loin dans le code. <br><br>  Et encore une de ces erreurs: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> L'objet 'propriétaire' a été utilisé après avoir été vérifié par rapport à null.  Vérifiez les lignes: 64, 60. FlatButtonAppearance.cs 64 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BorderSize { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != null &amp;&amp; owner.ParentInternal != null) { LayoutTransaction.DoLayoutIf(....); } owner.Invalidate(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } }</span></span></code> </pre> <br>  Adorable  Mais c'est le point de vue d'un chercheur extérieur.  Après tout, l'analyseur a trouvé <b>plus de 50 de</b> ces modèles dans le code WinForms en plus de ces deux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> .  Les développeurs ont beaucoup à travailler. <br><br>  Et enfin, il y a une erreur intéressante, à mon avis. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3137</a> La variable 'hCurrentFont' est affectée mais n'est pas utilisée à la fin de la fonction.  DeviceContext2.cs 241 <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { WindowsFont selectedFont; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { DeviceContexts.RemoveDeviceContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedFont != null &amp;&amp; selectedFont.Hfont != IntPtr.Zero) { IntPtr hCurrentFont = IntUnsafeNativeMethods.GetCurrentObject( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, hDC), IntNativeMethods.OBJ_FONT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCurrentFont == selectedFont.Hfont) { <span class="hljs-comment"><span class="hljs-comment">// select initial font back in IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(null, hInitialFont)); hCurrentFont = hInitialFont; // &lt;= } selectedFont.Dispose(disposing); selectedFont = null; } } .... }</span></span></code> </pre> <br>  Voyons ce qui a alerté l'analyseur et pourquoi cela peut indiquer un problème qu'une variable se voit attribuer une valeur, mais jamais utilisée dans le code. <br><br>  Le fichier <i>DeviceContext2.cs</i> contient une classe partielle.  La méthode <i>DisposeFont</i> est utilisée pour libérer des ressources après avoir travaillé avec des graphiques: le contexte de l'appareil et les polices.  Pour une meilleure compréhension, j'ai donné toute la méthode <i>DisposeFont</i> .  Faites attention à la variable locale <i>hCurrentFont</i> .  Le problème est que la déclaration de cette variable dans la méthode masque le champ de classe du même nom.  J'ai trouvé deux méthodes de la classe <i>DeviceContext</i> où le <b>champ</b> avec le nom <i>hCurrentFont</i> est utilisé: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowsFont font)</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = font.Hfont; .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = hInitialFont; }</code> </pre> <br>  Regardez la méthode <i>ResetFont</i> .  La dernière ligne <i>indique</i> exactement ce que fait la méthode <i>DisposeFont</i> dans le sous-bloc (c'est ce que l'analyseur pointe).  Ce champ <i>hCurrentFont</i> du même nom est déclaré dans une autre partie de la classe partielle dans le fichier <i>DeviceContext.cs</i> : <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { .... IntPtr hInitialFont; .... IntPtr hCurrentFont; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Ainsi, une erreur évidente a été commise.  Une autre question est dans son importance.  Maintenant, à la suite du travail de la méthode <i>DisposeFont</i> dans la section marquée avec le commentaire "sélectionner la police initiale dans", le champ <i>hCurrentFont</i> ne sera pas initialisé.  Je pense que seuls les auteurs du code peuvent donner un verdict exact. <br><br>  <b>Conclusions</b> <br><br>  Donc, cette fois, je vais devoir critiquer un peu la SEP.  Dans WinForms, de nombreuses erreurs nécessitent une attention particulière de la part des développeurs.  C'est peut-être la faute d'une hâte avec laquelle MS travaille sur .NET Core 3 et ses composants, y compris WinForms.  À mon avis, le code WinForms est toujours "brut", mais j'espère que la situation changera pour le mieux bientôt. <br><br>  La deuxième raison du grand nombre d'erreurs peut être que notre analyseur est simplement devenu meilleur pour les rechercher :). <br><br>  Soit dit en passant, un article de mon collègue Sergey Vasiliev sera bientôt publié dans lequel il recherche et trouve beaucoup de problèmes dans le code des bibliothèques .NET Core.  J'espère que son travail contribuera également à améliorer les caractéristiques de la plateforme .NET, car nous essayons toujours d'informer les développeurs sur les résultats de l'analyse de leurs projets. <br><br>  Et pour ceux qui souhaitent améliorer leurs produits par eux-mêmes ou rechercher des erreurs dans les projets d'autres personnes, je vous suggère de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télécharger et d'essayer PVS-Studio</a> . <br><br>  Du code propre à tout le monde! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462809/">https://habr.com/ru/post/fr462809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462797/index.html">Et encore une fois sur les nuages, pas seulement les pros</a></li>
<li><a href="../fr462801/index.html">15 outils indispensables pour les chefs de produit en 2019</a></li>
<li><a href="../fr462803/index.html">Migration d'un système ERP à un autre</a></li>
<li><a href="../fr462805/index.html">Analyse: comment l'argent est-il réellement protégé lors de la négociation en bourse</a></li>
<li><a href="../fr462807/index.html">WinForms: erreurs, Holmes</a></li>
<li><a href="../fr462811/index.html">Pourquoi avons-nous besoin de génériques dans Go?</a></li>
<li><a href="../fr462813/index.html">Ekaterinbourg, 14 août - Mitap du groupe d'utilisateurs d'Atlassian</a></li>
<li><a href="../fr462819/index.html">Carences dans l'enseignement des langues dans la CEI: une vision polyglotte</a></li>
<li><a href="../fr462821/index.html">Comment évaluer les ordinateurs qui n'existent pas encore</a></li>
<li><a href="../fr462825/index.html">Rapports vidéo du Summer Droid Meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>