<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèø üóûÔ∏è ‚åõÔ∏è Una serpiente en el buz√≥n y qu√© hace F # üåè üë∞üèª üç≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øDe qu√© se trata todo esto? 


 Se trata de la serpiente. Todos recuerdan lo que es una serpiente: una serpiente se mueve en un campo rectangular. Enc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una serpiente en el buz√≥n y qu√© hace F #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424861/"><h4 id="o-chem-eto-vse">  ¬øDe qu√© se trata todo esto? </h4><br><p>  Se trata de la serpiente.  Todos recuerdan lo que es una serpiente: una serpiente se mueve en un campo rectangular.  Encuentra comida - crece en longitud, se encuentra a s√≠ mismo o al borde del campo - muere.  Y el usuario solo puede enviar comandos: izquierda, derecha, arriba, abajo. <br>  Decid√≠ agregar algo de acci√≥n aqu√≠ y hacer que la serpiente huyera del pacman.  ¬°Y todo esto sobre los actores! </p><br><p> Por lo tanto, hoy usar√© el ejemplo de una serpiente para hablar sobre c√≥mo construir un modelo de actor usando <code>MailboxProcessor</code> de la biblioteca est√°ndar, qu√© puntos buscar y qu√© dificultades puede esperar. </p><br><p>  El c√≥digo escrito aqu√≠ no es perfecto, puede violar algunos principios y puede estar mejor escrito.  Pero si eres un principiante y quieres lidiar con los buzones, espero que este art√≠culo te ayude. <br>  Si sabes todo sobre los buzones sin m√≠, es posible que est√©s aburrido aqu√≠. </p><br><h4 id="pochemu-aktory">  ¬øPor qu√© actores? </h4><br><p>  Por el bien de la pr√°ctica.  Le√≠ sobre el modelo de actores, vi el video, me gust√≥ todo, pero no lo prob√© yo mismo.  Ahora lo prob√©. <br>  A pesar de que, de hecho, eleg√≠ la tecnolog√≠a por el bien de la tecnolog√≠a, el concepto recay√≥ con √©xito en esta tarea. </p><br><h4 id="pochemu-mailboxprocessor-a-ne-naprimer-akkanet">  ¬øPor qu√© MailboxProcessor, y no, por ejemplo, Akka.net? </h4><br><p>  Para mi tarea, el <code>MailboxProcessor</code> es de la estaci√≥n orbital por gorriones, <code>MailboxProcessor</code> mucho m√°s simple y es parte de la biblioteca est√°ndar, por lo que no necesita conectar ning√∫n paquete. </p><a name="habracut"></a><br><h4 id="o-meylboks-processorah-i-soputsvuyuschem-boylerpleyte">  Acerca de los procesadores de buzones y repeticiones relacionadas </h4><br><p>  El punto es simple.  El buz√≥n interior tiene un bucle de mensajes y alg√∫n estado.  Su bucle de mensajes actualizar√° este estado de acuerdo con el nuevo mensaje que llegue. </p><br><pre> <code class="hljs kotlin">let actor = MailboxProcessor.Start(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> inbox -&gt; // ,    //   . inbox --    MailboxProcessor let rec messageLoop oldState = async { //   let! msg = inbox.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">//    let newState = updateState oldState msg //      return! messageLoop newState } //       .    --     messageLoop (0,0) )</span></span></code> </pre> <br><p>  Tenga en cuenta que <code>messageLoop</code> recursivo y, al final, debe volver a llamarse; de ‚Äã‚Äãlo contrario, solo se procesar√° un mensaje, despu√©s del cual este actor morir√°.  <code>messageLoop</code> tambi√©n <code>messageLoop</code> as√≠ncrono, y cada iteraci√≥n posterior se realiza cuando se recibe un nuevo mensaje: <code>let! msg = inbox.Receive()</code>  <code>let! msg = inbox.Receive()</code> . <br>  Por lo tanto, toda la carga l√≥gica va a la funci√≥n <code>updateState</code> , lo que significa que para crear el buz√≥n del procesador, podemos hacer una funci√≥n de constructor que acepte una funci√≥n de actualizaci√≥n de estado y un estado cero: </p><br><pre> <code class="hljs haskell">//   applyMessage       //      (fun inbox -&gt; ...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buildActor applyMessage zeroState = <span class="hljs-type"><span class="hljs-type">MailboxProcessor</span></span>.<span class="hljs-type"><span class="hljs-type">Start</span></span>(fun inbox -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> loop state = async{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! msg = inbox.<span class="hljs-type"><span class="hljs-type">Receive</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newState = applyMessage state msg return! loop newState } loop zeroState )</code> </pre><br><p>  Genial!  ¬°Ahora no necesitamos monitorear constantemente para no olvidar el <code>return! loop newState</code>  <code>return! loop newState</code> .  Como saben, un actor almacena un estado, pero ahora no est√° completamente claro c√≥mo obtener este estado desde el exterior.  El buz√≥n del procesador tiene un m√©todo <code>PostAndReply</code> , que toma la funci√≥n <code>AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg</code> como entrada.  Al principio me llev√≥ a un estupor: no est√° completamente claro de d√≥nde obtener esta funci√≥n.  Pero en realidad, todo result√≥ ser m√°s simple: todos los mensajes deben estar envueltos en un contenedor DU, ya que ahora tenemos 2 operaciones en nuestro actor: enviar el mensaje en s√≠ y preguntar por el estado actual.  As√≠ es como se ve: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Mail&lt;_,_&gt;   ,  Post &amp; Get --  . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ F#       , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   compare &amp; equals . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         --   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   [&lt;Struct&gt;] .       type Mail&lt;'msg, 'state&gt; = | Post of 'msg | Get of AsyncReplyChannel&lt;'state&gt;</span></span></code> </pre> <br><p>  Nuestra funci√≥n de constructor ahora se ve as√≠: </p><br><pre> <code class="hljs erlang-repl">let buildActor applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec loop state = async{ let! msg = inbox.Receive() //    ,     // .    -- ,     //     . //     --      //    .      ! match msg with | Post msg -&gt; let newState = applyMessage state msg return! loop newState | Get channel -&gt; channel.Reply state return! loop state } loop zeroState )</code> </pre><br><p>  Ahora, para trabajar con el buz√≥n, necesitamos envolver todos nuestros mensajes en este <code>Mail.Post</code> .  Para no escribir esto cada vez, es mejor envolverlo en una peque√±a aplicaci√≥n: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> Mailbox = let buildAgent applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state = async{ let! msg = inbox.Receive() match msg with | Post msg -&gt; let newState = applyMessage state msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> newState | Get channel -&gt; channel.Reply state <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state } <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> zeroState ) let post (agent: MailboxProcessor&lt;_&gt;) msg = Post msg |&gt; agent.Post let getState (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndReply Get let getStateAsync (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndAsyncReply Get <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Single Case Discriminated Union. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> MailboxProcessor   API.      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  -  ,  ,      <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   .       ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        . type MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt; = MailAgent <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> address:string * mailbox:MailboxProcessor&lt;Mail&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt;&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     API with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.post <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> msg member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetState() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getState <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateAsync() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getStateAsync <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Address = let (MailAgent (address, _)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> address member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = let (MailAgent (_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (this:&gt;IDisposable).Dispose() interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose()</code> </pre> <br><p>  Te dir√© qu√© <code>address:string</code> poco m√°s tarde, pero por ahora nuestra plantilla est√° lista. </p><br><h4 id="sobstvenno-zmeyka">  En realidad la serpiente </h4><br><p>  En la serpiente hay una serpiente, un usuario con sus comandos, un campo y una transici√≥n regular al siguiente cuadro. <br>  Aqu√≠ est√° todo esto junto y necesita ser manchado por nuestros actores. <br>  Mi dise√±o inicial fue el siguiente: </p><br><ul><li>  Actor con temporizador.  Acepta mensajes de inicio / detenci√≥n / pausa.  Cada n milisegundos, env√≠a un mensaje <code>Flush</code> al actor del <code>Flush</code> .  Almacena <code>System.Timers.Timer</code> como un estado </li><li>  Equipos de actores.  Recibe mensajes del usuario <code>Move Up/Down/Left/Right</code> , <code>AddPerk Speed/Attack</code> (s√≠, mi serpiente puede arrastrarse r√°pidamente y atacar a los villanos) y <code>Flush</code> desde el temporizador.  Almacena una lista de comandos como un estado, y con una descarga, esta lista se restablece. </li><li>  El actor es una serpiente.  Almacena el estado de la serpiente: ventajas, longitud, direcci√≥n, curvas y coordenadas. <br>  Acepta una lista de mensajes del actor de los comandos, un mensaje <code>Tick</code> (para mover la serpiente 1 hacia adelante) y un mensaje <code>GrowUp</code> del actor del campo cuando encuentra comida. </li><li>  Actor del campo.  Almacena un mapa de celdas, toma el estado de una serpiente en un mensaje y dibuja coordenadas en una imagen existente.  Tambi√©n env√≠a <code>GrowUp</code> actor serpiente y el comando <code>Stop</code> al temporizador si el juego ha terminado. </li></ul><br><p>  Como puede ver, incluso con un n√∫mero tan peque√±o de entidades, el mapa de mensajes ya no es trivial.  Y ya en esta etapa surgieron dificultades: el hecho es que, por defecto, F # no permite dependencias c√≠clicas.  En la l√≠nea de c√≥digo actual, solo puede usar el c√≥digo escrito anteriormente, y lo mismo se aplica a los archivos del proyecto.  Esto no es un error, sino una caracter√≠stica, y me encanta porque ayuda a mantener limpio el c√≥digo, pero ¬øqu√© hacer cuando el dise√±o necesita enlaces c√≠clicos?  Por supuesto, puede usar el <code>rec namespace</code> , y luego dentro de un archivo puede hacer referencia a todo lo que est√° en este archivo, que us√©. <br>  Se espera que el c√≥digo se estropee, pero parec√≠a la √∫nica opci√≥n.  Y funcion√≥. </p><br><h4 id="problema-vneshnego-mira">  El problema del mundo exterior. </h4><br><p>  Todo funcion√≥ siempre y cuando todo el sistema de actores estuviera aislado del mundo exterior, y solo debat√≠a y mostraba l√≠neas en la consola.  Cuando lleg√≥ el momento de implementar la dependencia en forma de la funci√≥n <code>updateUI</code> , que se supon√≠a que se redibujar√≠a para cada tick, no pude resolver este problema en la implementaci√≥n actual.  Ni feo ni hermoso, de ninguna manera.  Y luego record√© akku: despu√©s de todo, all√≠ puedes generar actores en el camino, y tengo a todos mis actores descritos en la etapa de compilaci√≥n. <br>  La soluci√≥n es obvia: ¬°usa akku!  No, por supuesto, Akka todav√≠a es excesivo, pero decid√≠ lamer ciertos puntos a partir de ah√≠, a saber, crear un sistema de actores en el que pueda agregar din√°micamente nuevos actores y consultar actores existentes en la direcci√≥n. <br>  Dado que los actores ahora se agregan y eliminan en tiempo de ejecuci√≥n, pero se obtienen por la direcci√≥n en lugar de un enlace directo, debemos proporcionar un escenario en el que la direcci√≥n no se vea en ninguna parte y el actor no est√© all√≠.  Siguiendo el ejemplo del mismo acca, agregu√© un cuadro para letras muertas, y lo dise√±√© a trav√©s de mis DU favoritas: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Agent&lt;_,_&gt; --  ,   ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,      . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,    --    Box (mailagent), <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   ,   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       Deadbox.      MailAgent,  . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>           . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    --    . type Agent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; = | Box <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; | DeadBox <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string * MailAgent&lt;string * obj, Map&lt;string,obj list&gt;&gt; with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box box -&gt; box.Post msg | DeadBox (address, deadbox) -&gt; (address, box msg) |&gt; deadbox.Post interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box agent -&gt; agent.Dispose() | DeadBox (_,agent) -&gt; agent.Dispose()</code> </pre> <br><p>  Y el sistema en s√≠ se ve as√≠: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    .     --    . type MailboxNetwork() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .   ! [&lt;DefaultValue&gt;] val mutable agentRegister: ConcurrentDictionary&lt;string, obj&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister &lt;- ConcurrentDictionary&lt;string, obj&gt;() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Map --     let deadLettersFn deadLetters (address:string, msg:obj) = printfn <span class="hljs-string"><span class="hljs-string">"Deadletter: %s-%A"</span></span> address msg match Map.tryFind address deadLetters with <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   | None -&gt; Map.add address [msg] deadLetters <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   --   | Some letters -&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --      Map.remove address deadLetters |&gt; Map.add address (msg::letters) let deadLettersAgent() = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"deadLetters"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Map.empty |&gt; Mailbox.buildAgent deadLettersFn)</span></span></span><span class="hljs-function"> |&gt; MailAgent member this.DeadLetters = deadLettersAgent</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> // -     ,      member this.Box&lt;'message,'state&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address)</span></span></span><span class="hljs-function"> = match this.agentRegister.TryGetValue address with | </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, agent)</span></span></span><span class="hljs-function"> when </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(agent :? MailAgent&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'message,'</span></span></span></span><span class="hljs-function"><span class="hljs-params">state&gt;)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   let agent = agent :?&gt; MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message, '</span></span>state&gt; Box agent | _ -&gt; DeadBox (address, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DeadLetters) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --    member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox address = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryRemove(address) |&gt; ignore member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RespawnBox (agent: MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'a,'</span></span>b&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox agent.Address <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryAdd (agent.Address, agent) |&gt; ignore interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.Values <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> match agent with | :? IDisposable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> agent -&gt; agent.Dispose() | _ -&gt; ()</code> </pre> <br><p>  Aqu√≠ es donde la misma <code>address:string</code> , sobre la que escrib√≠ anteriormente, fue √∫til.  Y de nuevo funcion√≥, la dependencia externa ahora era f√°cil de llegar a donde necesitabas.  Las funciones de construcci√≥n de los actores ahora aceptaron el sistema de actores como argumentos y obtuvieron las direcciones necesarias a partir de ah√≠: </p><br><pre> <code class="hljs haskell"> //    - (  )   - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) //    message loop           <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> []</code> </pre><br><h4 id="medlenno">  Despacio </h4><br><p>  Por razones obvias, durante la depuraci√≥n, configur√© el juego a una velocidad baja: el retraso entre ticks fue de m√°s de 500 milisegundos.  Si reduce el retraso a 200, entonces los mensajes comenzaron a llegar tarde, y los equipos del usuario trabajaron con un retraso, lo que arruin√≥ todo el juego.  Una mosca adicional en la pomada fue el hecho de que el temporizador recibi√≥ el comando de detenci√≥n en caso de p√©rdida varias veces.  Para el usuario, esto no apareci√≥ de ninguna manera, pero sin embargo, hubo alg√∫n tipo de error. <br>  La verdad desagradable fue que los actores son, por supuesto, convenientemente geniales, pero las llamadas a m√©todos directos son mucho m√°s r√°pidas.  Por lo tanto, a pesar del hecho de que almacenar la serpiente en un actor separado era conveniente desde el punto de vista de organizar el c√≥digo, tuve que abandonar esta idea en nombre de la velocidad, porque durante 1 reloj del juego el mensaje era demasiado intenso: </p><br><ol><li>  El usuario env√≠a un n√∫mero arbitrario de comandos directamente al actor del comando. </li><li>  El temporizador env√≠a una marca al actor del equipo y, en una implementaci√≥n temprana, tambi√©n al actor de la serpiente para que mueva la serpiente a la celda siguiente. </li><li>  El actor de comando env√≠a una lista de comandos para la serpiente cuando el mensaje correspondiente proviene del temporizador. </li><li>  El actor serpiente, habiendo actualizado su estado de acuerdo con los 2 mensajes superiores, env√≠a el estado al actor de campo. </li><li>  El actor de campo vuelve a dibujar todo.  Si la serpiente encontr√≥ comida, entonces env√≠a un mensaje de <code>GrowUp</code> al actor de la serpiente, luego de lo cual env√≠a el nuevo estado al actor de campo. </li></ol><br><p>  Y para todo esto hay 1 ciclo de reloj, que no es suficiente, teniendo en cuenta la sincronizaci√≥n en las entra√±as del <code>MailboxProcessor</code> .  Adem√°s, en la implementaci√≥n actual, el temporizador env√≠a el siguiente mensaje cada n milisegundos, independientemente de cualquier cosa, por lo que si no entramos en la medida 1 vez, los mensajes comienzan a acumularse y la situaci√≥n empeora.  Ser√≠a mucho mejor "estirar" esta medida en particular, procesar todo lo que se ha acumulado y seguir adelante. </p><br><h4 id="finalnaya-versiya">  Versi√≥n final </h4><br><p>  Obviamente, el esquema del mensaje debe simplificarse, mientras que es muy deseable dejar el c√≥digo lo m√°s simple y accesible posible; en t√©rminos relativos, no quiero meter todo en 1 actor divino, y entonces no tiene mucho sentido en los actores. <br>  Por lo tanto, al mirar mi lista de actores, me di cuenta de que es mejor sacrificar primero a un actor serpiente.  Se necesita un temporizador, tambi√©n se necesita un b√∫fer de comandos de usuario para acumularlos en tiempo real, pero solo se vierte una vez por latido, y no hay necesidad objetiva de mantener a la serpiente en un actor separado, esto se hizo solo por conveniencia.  Adem√°s, al mantenerlo con el actor de campo, ser√° posible procesar el script <code>GrowUp</code> sin demora.  <code>Tick</code> mensaje de marca para la serpiente tampoco tiene mucho sentido, porque cuando recibimos un mensaje del actor del equipo, ya significa que ha sucedido un nuevo ritmo.  Adem√°s de esto, el estiramiento del ritmo en caso de retraso, tenemos los siguientes cambios: </p><br><ol><li>  <code>GrowUp</code> mensajes de <code>Tick</code> &amp; <code>GrowUp</code> . </li><li>  Mantenemos al actor serpiente en el actor de campo: ahora almacenar√° la "tapla" de estos estados. </li><li>  <code>System.Timers.Timer</code> del actor del temporizador.  En cambio, el esquema de trabajo ser√° el siguiente: despu√©s de recibir el comando <code>Start</code> , env√≠a <code>Flush</code> actor del comando.  Env√≠a una lista de comandos al campo + actor de serpiente, el √∫ltimo actor procesa todo esto y env√≠a un mensaje <code>Next</code> al temporizador, solicit√°ndole un nuevo tic.  El temporizador, despu√©s de recibir <code>Next</code> espera <code>Thread.Sleep(delay)</code> y comienza todo el c√≠rculo nuevamente.  Todo es simple </li></ol><br><p>  Para resumir. </p><br><ul><li>  En la implementaci√≥n anterior, 500 ms era el retraso m√≠nimo permitido.  En el retraso actual, puede eliminarlo por completo: el actor de campo requerir√° un nuevo ritmo cuando est√© listo.  Recopilar mensajes sin formato de medidas anteriores ya no es posible. </li><li>  El mapa de mensajer√≠a se simplifica enormemente: en lugar de un gr√°fico complejo, tenemos el bucle m√°s simple. </li><li>  Esta simplificaci√≥n resolvi√≥ el error cuando el temporizador se <code>Stop</code> varias veces en caso de p√©rdida. </li><li>  La lista de mensajes se ha reducido.  ¬°Menos c√≥digo, menos maldad! </li></ul><br><p>  Se ve as√≠: </p><br><pre> <code class="hljs haskell"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] commandAddress = <span class="hljs-string"><span class="hljs-string">"command"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] timerAddress = <span class="hljs-string"><span class="hljs-string">"timer"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] gameAddress = <span class="hljs-string"><span class="hljs-string">"game"</span></span> // -     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CommandMessage</span></span>, <span class="hljs-type"><span class="hljs-type">Command</span></span> list&gt;(commandAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TimerCommand</span></span>, <span class="hljs-type"><span class="hljs-type">TimerState</span></span>&gt;(timerAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) updateUi gameState cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent = timerAgent mailboxNetwork //    match gameState.gameFrame with //     | <span class="hljs-type"><span class="hljs-type">Frame</span></span> field -&gt; //       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Next</span></span> //    updateUi gameState //     gameState // ! | <span class="hljs-type"><span class="hljs-type">End</span></span> (<span class="hljs-type"><span class="hljs-type">Win</span></span> _) -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd //        | _ -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Stop</span></span> //     gameState // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands //       | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> //     [] // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) (state: <span class="hljs-type"><span class="hljs-type">TimerState</span></span>) cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent = commandAgent mailboxNetwork match cmd with | <span class="hljs-type"><span class="hljs-type">Start</span></span> -&gt; commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; {state with active = true} | <span class="hljs-type"><span class="hljs-type">Next</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //    ,     <span class="hljs-type"><span class="hljs-type">Threading</span></span>.<span class="hljs-type"><span class="hljs-type">Thread</span></span>.<span class="hljs-type"><span class="hljs-type">Sleep</span></span>(state.delay) commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; state | <span class="hljs-type"><span class="hljs-type">Stop</span></span> -&gt; printfn <span class="hljs-string"><span class="hljs-string">"Stop received"</span></span>; { state with active = false } | <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //     <span class="hljs-comment"><span class="hljs-comment">--   commandAgent.Post Flush { state with active = not state.active } | SetDelay delay -&gt; Threading.Thread.Sleep(delay) if state.active then commandAgent.Post Flush {state with delay = delay}</span></span></code> </pre> <br><h4 id="ssylki">  Referencias </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a los buzones</a> </li><li>  <a href="">Fuentes de buzones para los m√°s curiosos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digos fuente para el modelo de actor</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424861/">https://habr.com/ru/post/es424861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424851/index.html">¬øQu√© hay de malo en contratar a TI?</a></li>
<li><a href="../es424853/index.html">La historia de un controlador de vista que quer√≠a lucir bien</a></li>
<li><a href="../es424855/index.html">Aprendizaje autom√°tico: Scramble with a Room Elephant</a></li>
<li><a href="../es424857/index.html">Soporte de SNI cifrado implementado en CloudFlare</a></li>
<li><a href="../es424859/index.html">El juego Arduino m√°s simple con una pantalla 1602 - Parte # 1</a></li>
<li><a href="../es424865/index.html">Part√≠culas de dise√±o elemental descubiertas</a></li>
<li><a href="../es424867/index.html">Desarrollo de hex√°podos desde cero (parte 1) - dise√±o</a></li>
<li><a href="../es424869/index.html">C√≥mo la nueva caracter√≠stica de iOS 12 me record√≥ que es hora de sanar</a></li>
<li><a href="../es424871/index.html">Elon Musk y Tesla resuelven un litigio con la Comisi√≥n de Bolsa y Valores de EE. UU.</a></li>
<li><a href="../es424873/index.html">Errores de HttpClient en .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>