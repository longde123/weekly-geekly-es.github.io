<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏼 🔧 📹 Récupérer des données avec ORM est facile! Ou pas? 🍮 📶 👴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 


 Presque n'importe quel système d'information interagit d'une manière ou d'une autre avec des magasins de données externes. Dans la pl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Récupérer des données avec ORM est facile! Ou pas?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/451986/"><p><img src="https://habrastorage.org/webt/uv/4h/wb/uv4hwblmcfkf-f6018hxpbkf1s8.jpeg"></p><br><h2 id="vvedenie">  Présentation </h2><br><p>  Presque n'importe quel système d'information interagit d'une manière ou d'une autre avec des magasins de données externes.  Dans la plupart des cas, il s'agit d'une base de données relationnelle et, souvent, une sorte de cadre ORM est utilisé pour travailler avec des données.  ORM élimine la plupart des opérations de routine, offrant à la place un petit ensemble d'abstractions supplémentaires pour travailler avec des données. </p><br><p>  Martin Fowler a publié un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> intéressant, l'une des principales réflexions: «Les ORM nous aident à résoudre un grand nombre de problèmes dans les applications d'entreprise ... Cet outil ne peut pas être qualifié de joli, mais les problèmes qu'il traite ne sont pas non plus agréables.  Je pense que l'ORM mérite plus de respect et de compréhension. » </p><br><p>  Nous utilisons ORM de manière très intensive dans le cadre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CUBA</a> , nous connaissons donc de première main les problèmes et les limites de cette technologie, car CUBA est utilisé dans divers projets à travers le monde.  De nombreux sujets peuvent être abordés en relation avec l'ORM, mais nous nous concentrerons sur l'un d'entre eux: le choix entre les méthodes «paresseuses» (paresseuses) et «gourmandes» (avides) d'échantillonnage de données.  Nous parlerons de différentes approches pour résoudre ce problème avec des illustrations de l'API JPA et de Spring, et décrirons également comment (et pourquoi exactement) ORM est utilisé dans CUBA et quel travail nous faisons pour améliorer le travail avec les données dans notre cadre. </p><a name="habracut"></a><br><h2 id="vyborka-dannyh-lenivaya-ili-net">  Échantillonnage des données: paresseux ou non? </h2><br><p> Si votre modèle de données n'a qu'une seule entité, vous ne remarquerez probablement aucun problème lorsque vous travaillez avec ORM.  Regardons un petit exemple.  Supposons que nous ayons une entité <code>User ()</code> qui possède deux attributs: <code>ID</code> et <code>Name ()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Pour obtenir une instance de cette entité à partir de la base de données, il suffit d'appeler une méthode de l'objet <code>EntityManager</code> : </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, id);</code> </pre> <br><p>  Les choses deviennent un peu plus intéressantes lorsqu'une relation un-à-plusieurs apparaît: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Si nous devons extraire une instance d'utilisateur de la base de données, la question se pose: «Sélectionnons-nous également des adresses?».  Et la «bonne» réponse ici est: «Cela dépend de ...» Dans certains cas, nous aurons besoin d'adresses, dans d'autres - pas.  En règle générale, ORM propose deux façons de récupérer des enregistrements dépendants: paresseux et gourmand.  Par défaut, la plupart des ORM utilisent la méthode paresseuse.  Mais, si nous écrivons ce code: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>); em.close(); System.out.println(user.getAddresses().get(<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p>  ... puis nous obtenons l'exception <code>“LazyInitException”</code> , ce qui <code>“LazyInitException”</code> terriblement les nouveaux arrivants qui viennent de commencer à travailler avec ORM.  Et voici le moment où vous devez commencer une histoire sur ce que sont les instances «attachées» et «détachées» d'une entité, quelles sont les sessions et les transactions. <br>  Oui, cela signifie que l'entité doit être «attachée» à la session afin que vous puissiez sélectionner les données dépendantes.  Eh bien, ne fermons pas les transactions tout de suite, et la vie deviendra immédiatement plus facile.  Et ici, un autre problème se pose: les transactions s'allongent, ce qui augmente le risque de blocage.  Raccourcir les transactions?  C'est possible, mais si vous créez beaucoup, beaucoup de petites transactions, nous obtenons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Conte de Komar Komarovich - un long nez et une Misha poilue - une courte queue»</a> sur la façon dont la horde de minuscules moustiques ours a gagné - cela se produira avec la base de données.  Si le nombre de petites transactions augmente considérablement, des problèmes de performances se poseront. <br>  Comme cela a été dit, lors de la récupération des données sur un utilisateur, les adresses peuvent être requises ou non.Par conséquent, selon la logique métier, vous devez sélectionner la collection ou non.  Il est nécessaire d'ajouter de nouvelles conditions au code ... Hmmm ... Quelque chose se complique. </p><br><p>  Et si vous essayez un autre type d'échantillon? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.EAGER) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Eh bien ... vous ne pouvez pas dire que cela aidera beaucoup.  Oui, nous allons nous débarrasser du <code>LazyInit</code> détesté et il n'est pas nécessaire de vérifier si l'entité est attachée à la session ou non.  Mais maintenant, nous pouvons avoir des problèmes de performances, car nous n'avons pas toujours besoin d'adresses, mais nous sélectionnons toujours ces objets dans la mémoire du serveur. <br>  Avez-vous d'autres idées? </p><br><h2 id="spring-jdbc">  Spring jdbc </h2><br><p>  Certains développeurs sont tellement fatigués d'ORM qu'ils passent à des cadres alternatifs.  Par exemple, sur Spring JDBC, qui offre la possibilité de convertir des données relationnelles en données d'objet en mode "semi-automatique".  Le développeur écrit des requêtes pour chaque cas où un ensemble particulier d'attributs est nécessaire (ou le même code est réutilisé pour les cas où les mêmes structures de données sont nécessaires). </p><br><p>  Cela nous donne une grande flexibilité.  Par exemple, vous pouvez sélectionner un seul attribut sans créer l'objet entité correspondant: </p><br><pre> <code class="java hljs">String name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, String.class);</code> </pre> <br><p>  Ou sélectionnez un objet sous la forme habituelle: </p><br><pre> <code class="java hljs">User user = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select id, name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowMapper&lt;User&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ResultSet rs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); user.setName(rs.getString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)); user.setId(rs.getInt(<span class="hljs-string"><span class="hljs-string">"id"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; } });</code> </pre> <br><p>  Vous pouvez également sélectionner une liste d'adresses pour l'utilisateur, il vous suffit d'écrire un peu plus de code et de composer correctement la requête SQL pour éviter le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème des requêtes n + 1</a> . </p><br><p>  Soooo, encore compliqué.  Oui, nous contrôlons toutes les requêtes et la façon dont les données sont mappées sur des objets, mais nous devons écrire plus de code, apprendre le SQL et savoir comment les requêtes sont exécutées dans la base de données.  Personnellement, je pense que la connaissance de SQL est une compétence requise pour un programmeur d'applications, mais tout le monde ne pense pas de cette façon, et je ne vais pas m'engager dans des polémiques.  Après tout, la connaissance des instructions d'assemblage x86 de nos jours est également facultative.  Réfléchissons mieux à la façon de faciliter la vie des programmeurs. </p><br><h2 id="jpa-entitygraph">  JPA EntityGraph </h2><br><p>  Et prenons un peu de recul et pensons, de quoi avons-nous besoin?  Il semble que nous devons simplement indiquer exactement les attributs dont nous avons besoin dans chaque cas.  Eh bien, faisons-le!  JPA 2.1 a introduit une nouvelle API - EntityGraph (graphique d'entité).  L'idée est très simple: nous utilisons des annotations pour décrire ce que nous choisirons dans la base de données.  Voici un exemple: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-only-entity-graph"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>, attributeNodes = {<span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"addresses"</span></span>)}) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.LAZY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Deux graphiques sont décrits pour cette entité: <code>user-only-entity-graph</code> graphique d'entité <code>user-only-entity-graph</code> ne sélectionne pas l'attribut <code>Addresses</code> (marqué comme paresseux), tandis que le deuxième graphique indique à ORM de sélectionner cet attribut.  Si nous marquons les <code>Addresses</code> comme désireuses, le graphique sera ignoré et les adresses seront sélectionnées de toute façon. </p><br><p>  Ainsi, dans JPA 2.1, vous pouvez échantillonner des données comme ceci: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); EntityGraph graph = em.getEntityGraph(<span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>); Map&lt;String, Object&gt; properties = Map.of(<span class="hljs-string"><span class="hljs-string">"javax.persistence.fetchgraph"</span></span>, graph); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>, properties); em.close();</code> </pre> <br><p>  Cette approche simplifie considérablement le travail, pas besoin de penser séparément aux attributs paresseux et à la longueur des transactions.  Un avantage supplémentaire est que le graphique est appliqué au niveau de la requête SQL, donc les données «supplémentaires» ne sont pas sélectionnées dans l'application Java.  Mais il y a un petit problème: vous ne pouvez pas dire quels attributs ont été sélectionnés et lesquels ne l'ont pas été.  Il existe une API pour vérifier, cela se fait en utilisant la classe <code>PersistenceUtil</code> : </p><br><pre> <code class="java hljs">PersistenceUtil pu = entityManagerFactory.getPersistenceUnitUtil(); System.out.println(<span class="hljs-string"><span class="hljs-string">"User.addresses loaded: "</span></span> + pu.isLoaded(user, <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>));</code> </pre> <br><p>  Mais c'est assez ennuyeux et tout le monde n'est pas prêt à faire de telles vérifications.  Y a-t-il autre chose que vous pouvez simplifier et ne pas afficher les attributs qui n'ont pas été sélectionnés? </p><br><h2 id="proekcii-spring">  Projections de printemps </h2><br><p>  Le Spring Framework a une grande chose appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projections</a> (et ce n'est pas la même chose que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projections dans Hibernate</a> ).  Si vous devez sélectionner uniquement certains attributs d'une entité, une interface avec les attributs nécessaires est créée et Spring sélectionne les «instances» de cette interface dans la base de données.  À titre d'exemple, considérons l'interface suivante: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamesOnly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Vous pouvez maintenant définir un référentiel Spring JPA pour récupérer les entités utilisateur comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Collection&lt;NamesOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastname)</span></span></span></span>; }</code> </pre> <br><p>  Dans ce cas, après avoir appelé la méthode findByName, dans la liste résultante, nous obtenons des entités qui n'ont accès qu'aux attributs définis dans l'interface!  Selon le même principe, on peut choisir des entités dépendantes, c'est-à-dire  sélectionnez immédiatement la relation «maître-détail».  De plus, Spring génère du SQL «correct» dans la plupart des cas, c'est-à-dire  seuls les attributs décrits dans la projection sont sélectionnés dans la base de données, ce qui est très similaire au fonctionnement des graphiques d'entité. <br>  Il s'agit d'une API très puissante. Lorsque vous définissez des interfaces, vous pouvez utiliser des expressions SpEL, utiliser des classes avec une sorte de logique intégrée au lieu d'interfaces, et bien plus encore, tout est décrit en détail dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br>  Le seul problème avec les projections est qu'à l'intérieur, elles sont implémentées en tant que paires clé-valeur, c'est-à-dire  sont en lecture seule.  Cela signifie que même si nous définissons une méthode de définition pour la projection, nous ne pourrons pas enregistrer les modifications via les référentiels CRUD ou via EntityManager.  Les projections sont donc des DTO qui peuvent être reconvertis en Entité et enregistrés uniquement si vous écrivez votre propre code pour cela. </p><br><h2 id="kak-vybirayutsya-dannye-v-cuba">  Comment sélectionner des données dans CUBA </h2><br><p>  Dès le début du développement du framework CUBA, nous avons essayé d'optimiser la partie du code qui fonctionne avec la base de données.  Chez CUBA, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EclipseLink</a> comme base pour l'API d'accès aux données.  Ce qui est bien avec EclipseLink, c'est qu'il a pris en charge le chargement partiel d'entité dès le début, et c'était un facteur décisif dans le choix entre lui et Hibernate.  Dans EclipseLink, vous pouvez spécifier des attributs à charger bien avant l'apparition de la norme JPA 2.1.  CUBA a sa propre façon de décrire un graphe d'entité, appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vues CUBA</a> .  Représentations CUBA est une API plutôt développée, vous pouvez hériter de certaines représentations d'autres, les combiner, en appliquant à la fois aux entités maître et détail.  Une autre motivation pour créer des vues CUBA est que nous voulions utiliser des transactions courtes afin de pouvoir travailler avec des entités détachées dans l'interface utilisateur Web. <br>  Dans CUBA, les vues sont décrites dans un fichier XML, comme dans l'exemple ci-dessous: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.sample.User"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">extends</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"_minimal"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user-minimal-view"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"addresses"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">view</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"address-street-only-view"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Cette vue sélectionne l'entité <code>User</code> et son <code>name</code> attribut local, et sélectionne également des adresses en leur appliquant la vue <code>address-street-only-view</code> .  Tout cela se produit (attention!) Au niveau de la requête SQL.  Lorsque la vue est créée, vous pouvez l'utiliser dans la sélection de données à l'aide de la classe DataManager: </p><br><pre> <code class="java hljs">List&lt;User&gt; users = dataManager.load(User.class).view(<span class="hljs-string"><span class="hljs-string">"user-edit-view"</span></span>).list();</code> </pre> <br><p>  Cette approche fonctionne bien, tout en consommant du trafic réseau de manière économique, car les attributs inutilisés ne sont tout simplement pas transférés de la base de données vers l'application, mais, comme dans le cas de JPA, il y a un problème: on ne peut pas dire quels attributs de l'entité ont été chargés.  Et dans CUBA, il y a une exception <code>“IllegalStateException: Cannot get unfetched attribute [...] from detached object”</code> , qui, comme <code>LazyInit</code> , doit avoir été rencontré par tous ceux qui écrivent en utilisant notre framework.  Comme dans le JPA, il existe des moyens de vérifier quels attributs ont été chargés et lesquels ne le sont pas, mais, encore une fois, écrire de tels contrôles est une tâche fastidieuse et laborieuse qui dérange beaucoup les développeurs.  Il faut inventer autre chose pour ne pas alourdir les gens avec un travail que, en théorie, les machines peuvent faire. </p><br><h2 id="koncept---cuba-view-interfaces">  Concept - CUBA View Interfaces </h2><br><p>  Mais que faire si vous essayez de combiner des graphiques d'entités et des projections?  Nous avons décidé de l'essayer et développé des interfaces pour les interfaces de vue d'entité qui suivent l'approche de projection Spring.  Ces interfaces sont traduites en vues CUBA au démarrage de l'application et peuvent être utilisées dans le DataManager.  L'idée est simple: nous décrivons une interface (ou un ensemble d'interfaces), qui est un graphe d'entité. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserMinimalView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;AddressStreetOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAddresses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressStreetOnly</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String street)</span></span></span></span>; } }</code> </pre> <br><p>  Il est à noter que pour certains cas spécifiques, vous pouvez réaliser des interfaces locales, comme dans le cas d' <code>AddressStreetOnly</code> partir de l'exemple ci-dessus, afin de ne pas «polluer» l'API publique de votre application. </p><br><p>  Dans le processus de démarrage d'une application CUBA (dont la plupart est l'initialisation du contexte Spring), nous créons par programmation des vues CUBA et les plaçons dans le référentiel du bean interne en contexte. <br>  Vous devez maintenant modifier légèrement l'implémentation de la classe DataManager afin qu'elle accepte les vues d'interface, et vous pouvez sélectionner des entités de cette manière: </p><br><pre> <code class="java hljs">List&lt;UserMinimalView&gt; users = dataManager.load(UserMinimalView.class).list();</code> </pre> <br><p>  Sous le capot, un objet proxy est généré qui implémente l'interface et encapsule l'instance d'entité sélectionnée dans la base de données (de la même manière que dans Hibernate).  Et, lorsque le développeur appelle la valeur d'attribut, le proxy délègue l'appel de méthode à l'instance «réelle» de l'entité. </p><br><p>  En développant ce concept, nous essayons de tuer deux oiseaux avec une pierre: </p><br><ul><li>  Les données qui ne sont pas décrites dans l'interface ne sont pas chargées dans l'application, ce qui permet d'économiser les ressources du serveur. </li><li>  Le développeur ne peut utiliser que les attributs accessibles via l'interface (et, par conséquent, sélectionnés dans la base de données), éliminant ainsi les exceptions <code>UnfetchedAttribute</code> dont nous avons parlé plus haut. </li></ul><br><p>  Contrairement aux projections Spring, nous encapsulons les entités dans des objets proxy, de plus, chaque interface hérite de l'interface CUBA standard - <code>Entity</code> .  Cela signifie que les attributs Entity View peuvent être modifiés, puis enregistrez ces modifications dans la base de données à l'aide de l'API CUBA standard pour travailler avec les données. <br>  Et, soit dit en passant, le «troisième lièvre» - vous pouvez rendre les attributs en lecture seule si vous définissez une interface avec des méthodes getter uniquement.  Ainsi, nous avons déjà défini les règles de modification au niveau de l'API d'entité. <br>  De plus, vous pouvez effectuer certaines opérations locales pour les entités détachées à l'aide des attributs disponibles, par exemple, la conversion de chaîne de nom, comme dans l'exemple ci-dessous: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MetaProperty</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNameLowercase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getName().toLowerCase(); }</code> </pre> <br><p>  Notez que les attributs calculés peuvent être retirés du modèle de classe d'entité et transférés vers des interfaces applicables à une logique métier particulière. </p><br><p>  Une autre caractéristique intéressante est l'héritage d'interface.  Vous pouvez créer plusieurs vues avec différents ensembles d'attributs, puis les combiner.  Par exemple, vous pouvez créer une interface pour une entité Utilisateur avec les attributs nom et e-mail, et une autre avec les attributs nom et adresses.  Maintenant, si vous devez sélectionner le nom, l'adresse e-mail et les adresses, vous n'avez pas besoin de copier ces attributs dans la troisième interface, il vous suffit d'hériter des deux premières vues.  Et oui, les instances de la troisième interface peuvent être transmises à des méthodes qui acceptent des paramètres avec le type d'interface parent, les règles de POO sont les mêmes pour tout le monde. </p><br><p>  Une conversion entre les vues a également été implémentée - chaque interface a une méthode reload (), dans laquelle vous pouvez passer la classe de vue comme paramètre: </p><br><pre> <code class="java hljs">UserFullView userFull = userMinimal.reload(UserFullView.class);</code> </pre> <br><p>  UserFullView peut contenir des attributs supplémentaires, de sorte que l'entité sera rechargée à partir de la base de données, si nécessaire.  Et ce processus est retardé.  L'accès à la base de données se fera uniquement lors du premier accès aux attributs de l'entité.  Cela ralentira un peu le premier appel, mais cette approche a été choisie intentionnellement - si l'instance d'entité est utilisée dans le module «Web», qui contient l'interface utilisateur et ses propres contrôleurs REST, ce module peut être déployé sur un serveur distinct.  Et cela signifie que la surcharge forcée de l'entité créera un trafic réseau supplémentaire - accès au module principal puis à la base de données.  Ainsi, en reportant la surcharge jusqu'au moment où cela est nécessaire, nous économisons du trafic et réduisons le nombre de requêtes de base de données. </p><br><p>  Le concept est conçu comme un module pour CUBA, un exemple d'utilisation peut être téléchargé depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Il semble que dans un avenir proche, nous continuerons à utiliser massivement ORM dans les applications d'entreprise simplement parce que nous avons besoin de quelque chose qui transformera les données relationnelles en objets.  Bien sûr, des solutions spécifiques seront développées pour des applications complexes, uniques et à très haute charge, mais il semble que les frameworks ORM vivront aussi longtemps que les bases de données relationnelles. <br>  Dans CUBA, nous essayons de simplifier au maximum le travail avec ORM, et dans les futures versions, nous introduirons de nouvelles fonctionnalités pour travailler avec les données.  Il sera difficile de dire si ce seront des interfaces de présentation ou autre chose, mais je suis sûr d'une chose: nous continuerons à simplifier le travail avec les données dans les futures versions du framework. </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451986/">https://habr.com/ru/post/fr451986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451970/index.html">Thrangrycat: une vulnérabilité critique dans le micrologiciel des périphériques Cisco permet aux pirates informatiques d'y installer des portes dérobées</a></li>
<li><a href="../fr451972/index.html">QuadCast - Sons réels</a></li>
<li><a href="../fr451974/index.html">Histoire d'AMD: 50 ans de développement rapide</a></li>
<li><a href="../fr451976/index.html">Combien coûte un Runet «souverain»?</a></li>
<li><a href="../fr451982/index.html">Plus vite vous oubliez la POO, mieux c'est pour vous et vos programmes.</a></li>
<li><a href="../fr451990/index.html">FAQ sur les transferts et les vols de correspondance: quelle est la différence qu'un passager peut et ne peut pas faire</a></li>
<li><a href="../fr451996/index.html">Mon expérience des erreurs</a></li>
<li><a href="../fr451998/index.html">Problèmes de l'agriculture de précision et comment vivre avec eux</a></li>
<li><a href="../fr452000/index.html">Comment à Leroy Merlin vous pouvez acheter des marchandises de l'entrepôt d'un fournisseur qui ne fait pas partie de l'assortiment du magasin</a></li>
<li><a href="../fr452004/index.html">Trouvé l'emplacement de la chute de l'appareil "Bereshit" sur la lune</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>