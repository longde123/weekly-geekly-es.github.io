<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔬 🎥 🎟️ Infraestrutura System.Transactions no mundo .NET 🈵 🙎🏿 🏂🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você já viu uma construção como using (var scope = new TransactionScope(TransactionScopeOption.Required)) em C #? Isso significa que o código em execu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infraestrutura System.Transactions no mundo .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/433136/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/df/aq/ctdfaqnuvdjaw6tobyxja78mk-s.png"></div><br>  Você já viu uma construção como <code>using (var scope = new TransactionScope(TransactionScopeOption.Required))</code> em C #?  Isso significa que o código em execução no bloco <code>using</code> está na transação e, após sair desse bloco, as alterações serão confirmadas ou revertidas.  Parece compreensível até você começar a cavar mais fundo.  E quanto mais fundo você cavar, mais e mais estranho se torna.  De qualquer forma, quando me familiarizei com a classe <code>TransactionScope</code> e, em geral, com as transações .NET, surgiram várias perguntas. <br><br>  O que é a classe <code>TransactionScope</code> ?  Assim que usamos a construção <code>using (var scope = new TransactionScope())</code> , tudo em nosso programa se torna imediatamente transacional?  O que são "Resource Manager" e "Transaction Manager"?  Posso escrever meu próprio gerenciador de recursos e como ele se "conecta" à instância criada do <code>TransactionScope</code> ?  O que é uma transação distribuída e é verdade que uma transação distribuída no SQL Server ou Oracle Database é igual a uma transação .NET distribuída? <br><br>  Nesta publicação, tentei coletar material que ajuda a encontrar respostas para essas perguntas e a entender as transações no mundo .NET. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conteúdo</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdução</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que são transações e quais problemas eles resolvem?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quais transações são consideradas aqui</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seção TL; DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transações baseadas em System.Transactions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que é isso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerentes de recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de gerenciadores de recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando o TransactionScope</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplicabilidade de transação de software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um exemplo de um gerenciador de recursos inconstante</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seção TL; DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transações Distribuídas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que é isso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Protocolos transacionais</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fixação bifásica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Folha de dicas do System.Transations</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limitações e alternativas de transação distribuída por software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Então está no .NET Core?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transações Distribuídas e WCF</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seção TL; DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclusão Berço</a> </div></div><br><a name="Introduction"></a><h2>  1. Introdução </h2><br><a name="Transactions"></a><h4>  O que são transações e quais problemas eles resolvem? </h4><br>  As transações em questão aqui são operações que transferem o sistema de um estado aceitável para outro e são garantidas para não deixar o sistema em um estado inaceitável, mesmo que surjam situações imprevistas.  Que tipo de condições aceitáveis ​​são essas, no caso geral, depende do contexto.  Aqui consideraremos uma situação aceitável na qual os dados que processamos são integrais.  Entende-se que as alterações que compõem a transação são confirmadas juntas ou não confirmadas.  Além disso, as alterações em uma transação podem ser isoladas das alterações feitas no sistema por outra transação.  Os requisitos básicos para transações são indicados pelo acrônimo ACID.  Para o primeiro contato com eles, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo na Wikipedia é</a> adequado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4r/p7/2b/4rp72bf2l_qdxmlhawxsjslkj-i.png" width="250"></div><br>  Um exemplo clássico de uma transação é a transferência de dinheiro entre duas contas.  Nessa situação, retirar dinheiro da conta número 1 sem creditar na conta número 2 é inaceitável, da mesma maneira que depositar na conta número 2 sem retirar a conta número 1. Em outras palavras, queremos que ambas as operações sejam tanto retirada quanto creditando - realizado imediatamente.  Se um deles falhar, a segunda operação não deve ser executada.  Você pode chamar esse princípio de "tudo ou nada".  Além disso, é desejável que as operações sejam executadas de forma síncrona, mesmo no caso de falhas sistêmicas, como falta de energia, ou seja, que o sistema seja visto em um estado aceitável assim que estiver disponível após a restauração. <br><br>  Em termos matemáticos, podemos dizer que, com relação ao sistema, existe um invariante que gostaríamos de preservar.  Por exemplo, o valor em ambas as contas: é necessário que após a transação (transferência de dinheiro) o valor permaneça o mesmo de antes.  A propósito, no exemplo clássico de transferência de dinheiro, a contabilidade também aparece - uma área de assunto em que o conceito de transação surgiu naturalmente. <br><br>  Ilustramos o exemplo de transferência de dinheiro entre duas contas.  A primeira imagem mostra a situação em que a transferência de 50 rublos da conta 1 para a conta 2 foi concluída com êxito.  A cor verde indica que o sistema está em um estado aceitável (os dados estão completos). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sn/az/ra/snazracqgy0u8fdxtrtksb8jc7g.png"></div><br>  Agora imagine que a transferência é realizada fora da transação e após a retirada do dinheiro da conta nº 1, ocorreu uma falha, devido à qual o dinheiro retirado não foi creditado na conta nº 2. O sistema estará em um estado inaceitável (cor vermelha). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8h/ph/yj8hphqu7cszpcdvnboh97h3xfe.png"></div><br>  Se ocorreu um erro entre as operações de retirada e obtenção de créditos, mas a transferência foi realizada como parte de uma transação, a operação de retirada será cancelada.  Como resultado, o sistema permanecerá em seu estado aceitável original. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/6b/wi/3d6bwim5vko1yam5mhiv1ekl9ve.png"></div><br>  Vou dar exemplos de situações da experiência de nossa empresa nas quais as transações são úteis: contabilizar mercadorias (contabilizar o número de mercadorias de vários tipos que estão em determinadas lojas e a caminho), contabilizar recursos de armazenamento (contabilizar o volume de uma sala ocupada por mercadorias de um determinado tipo, volume de um livre para a colocação de mercadorias, a quantidade de mercadorias que os funcionários e os sistemas de armazenamento automatizados podem mover por dia). <br><br>  Os problemas que surgem quando a integridade dos dados é violada são óbvios.  As informações fornecidas pelo sistema não se tornam apenas falsas - elas perdem contato com a realidade e se transformam em bobagens. <br><br><a name="KindsOfTransactions"></a><h4>  Quais transações são consideradas aqui </h4><br>  Os benefícios fornecidos pelas transações são conhecidos.  Portanto, para manter a integridade dos dados, precisamos de um banco de dados relacional, porque é aí que as transações são feitas?  Na verdade não.  Foi dito acima que o conceito de transação depende do contexto, e agora consideraremos brevemente de que transações podemos falar ao discutir sistemas de informação. <br><br>  Para começar, separamos os conceitos de transações de domínio do assunto (transações comerciais) e transações do sistema.  O segundo pode ser implementado em locais diferentes e de maneiras diferentes. <br><br>  Vamos do nível mais alto - a área de assunto.  A pessoa interessada pode declarar que existem alguns estados aceitáveis ​​e não deseja ver o sistema de informação fora desses estados.  Não apresentaremos exemplos extras: a transferência de dinheiro entre contas é adequada aqui.  Esclarecemos apenas que uma transferência não é necessariamente uma transferência de dinheiro entre as contas de liquidação de dois clientes bancários.  Não menos importante é a tarefa da contabilidade, quando as contas devem refletir as fontes e o objetivo dos fundos da organização, e a transferência deve refletir a mudança na distribuição de fundos por essas fontes e o objetivo.  Este foi um exemplo de uma <b>transação de domínio do assunto</b> . <br><br>  Agora vamos ver os exemplos mais comuns e interessantes da implementação de transações do sistema.  Nas transações do sistema, vários meios técnicos fornecem os requisitos da área de assunto.  Uma solução clássica comprovada desse tipo é uma <strong>transação de DBMS relacional</strong> (primeiro exemplo).  Os sistemas modernos de gerenciamento de banco de dados (relacionais <a href="">e não muito</a> ) fornecem um mecanismo de transação que permite salvar (confirmar) todas as alterações feitas no período especificado de trabalho ou descartá-las (retroceder).  Ao usar esse mecanismo, operações de retirada de dinheiro de uma conta e crédito para outra conta que compõem a transação da área de assunto, os meios do DBMS serão combinados em uma transação do sistema e serão executados juntos ou não serão executados. <br><br>  Usar um DBMS, é claro, não é necessário.  Grosso modo, você geralmente pode implementar o mecanismo de transação DBMS na sua linguagem de programação favorita e aproveitar o análogo instável e com erros das ferramentas existentes.  Mas sua “bicicleta” pode ser otimizada para situações específicas na área de assunto. <br><br>  Existem opções mais interessantes.  As linguagens de programação industrial modernas (C # e Java em primeiro lugar) oferecem ferramentas projetadas especificamente para organizar transações envolvendo subsistemas completamente diferentes, e não apenas o DBMS.  Nesta publicação, chamaremos esses softwares de transações.  No caso de C #, essas são <b>transações do espaço para nome System.Transactions</b> (o segundo exemplo) e são descritas abaixo. <br><br>  Antes de passar para as transações <code>System.Transactions</code> , não se pode deixar de mencionar mais um fenômeno interessante.  <code>System.Transactions</code> ferramentas <code>System.Transactions</code> permitem que o programador implemente independentemente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memória de transação programática</a> .  Nesse caso, as operações do programa que afetam o estado do sistema (no caso das linguagens de programação imperativas clássicas, é uma operação de atribuição) são incluídas por padrão nas transações que podem ser confirmadas e revertidas da mesma maneira que as transações do DBMS.  Com essa abordagem, a necessidade de usar mecanismos de sincronização (em C # - <code>lock</code> , em Java - <code>synchronized</code> ) é significativamente reduzida.  Um desenvolvimento adicional dessa idéia é a <strong>memória transacional de software, suportada no nível da plataforma</strong> (terceiro exemplo).  Espera-se que esse milagre seja encontrado em uma linguagem cuja elegância supere sua aplicabilidade industrial - Clojure.  E para linguagens trabalhador-camponesas, existem bibliotecas de plug-in que fornecem a funcionalidade da memória transacional programática. <br><br>  As transações do sistema podem incluir vários sistemas de informação, caso em que são distribuídos.  Distribuídos podem ser transações e software DBMS;  tudo depende de qual funcionalidade uma ferramenta de transação específica suporta.  Transações distribuídas mais detalhadas são discutidas na seção correspondente.  Vou dar uma imagem para facilitar a compreensão dos tópicos discutidos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/yd/4s/diyd4spwelqhd61eoetfacuncjm.png"></div><br><a name="TLDR1"></a><h4>  Seção TL; DR </h4><br>  Existem processos que consistem em várias operações indivisíveis (atômicas) aplicadas ao sistema, no caso geral, não necessariamente informativas.  Cada operação indivisível pode deixar o sistema em um estado inaceitável quando a integridade dos dados é comprometida.  Por exemplo, se uma transferência de dinheiro entre duas contas for representada por duas operações indivisíveis de retirada da conta nº 1 e crédito na conta nº 2, apenas uma dessas operações violará a integridade dos dados.  O dinheiro desaparece no meio do nada ou aparece no meio do nada.  Uma transação combina operações indivisíveis para que sejam executadas todas juntas (é claro, sequencialmente, se necessário) ou não sejam executadas.  Podemos falar sobre transações de domínio e transações em sistemas técnicos que normalmente implementam transações de domínio. <br><br><a name="SystemTransactions"></a><h2>  Transações baseadas em System.Transactions </h2><br><a name="WhatIsIt1"></a><h4>  O que é isso </h4><br>  No mundo .NET, existe uma estrutura de software projetada pelos criadores de uma plataforma de gerenciamento de transações.  Da perspectiva de um programador transacional, essa estrutura consiste nos <code>System.Transactions</code> <code>TransactionScope</code> , <code>TransactionScopeOption</code> , <code>TransactionScopeAsyncFlowOption</code> e <code>TransactionOptions</code> <code>System.Transactions</code> espaço para nome <code>System.Transactions</code> .  Se falarmos sobre o .NET Standard, tudo isso estará disponível a partir da <a href="">versão 2.0</a> . <br><br>  As transações do namespace <code>System.Transactions</code> são baseadas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padrão X / Open XA do The Open Group</a> .  Esta norma introduz muitos dos termos discutidos abaixo e, o mais importante, descreve transações distribuídas, que também são cobertas nesta publicação em uma seção especial.  A implementação de transações de software em outras plataformas, por exemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, Java, é</a> baseada no mesmo padrão. <br><br>  Um caso de uso de transação típico para um programador C # é o seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { <span class="hljs-comment"><span class="hljs-comment">// -  ,    . scope.Complete(); }</span></span></code> </pre> <br>  Dentro do bloco <code>using</code> , está o código que executa o trabalho, cujos resultados devem ser confirmados ou cancelados todos juntos.  Exemplos clássicos desse trabalho estão lendo e gravando no banco de dados ou enviando e recebendo mensagens da fila.  Quando o controle sair do bloco <code>using</code> , a transação será confirmada.  Se você remover a chamada <code>Complete</code> , a transação será revertida.  Bem simples. <br><br>  Acontece que, durante uma reversão de transação, todas as operações realizadas dentro de um bloco <code>using</code> serão canceladas?  E se eu atribuí uma variável a um valor diferente, essa variável restaurará o valor antigo?  Quando vi pela primeira vez um design semelhante, pensei que sim.  De fato, é claro, nem todas as alterações serão revertidas, mas apenas muito <i>especiais</i> .  Se todas as alterações fossem revertidas, essa seria a memória transacional do software descrita acima.  Agora vamos ver quais são essas alterações especiais que podem participar de transações do programa com base em <code>System.Transactions</code> . <br><br><a name="ResourceManagers"></a><h4>  Gerentes de recursos </h4><br>  Para que algo <code>System.Transactions</code> suporte a transações baseadas no <code>System.Transactions</code> , é necessário que ele possua informações de que uma transação está em andamento no momento e que esteja registrada em algum registro dos participantes da transação.  Você pode obter informações sobre se o trabalho transacional está em andamento verificando a propriedade estática <code>Current</code> da classe <code>System.Transactions.Transaction</code> .  Digitar o bloco <code>using</code> do tipo indicado acima apenas define essa propriedade, se ainda não tiver sido definida anteriormente.  E para se registrar como participante de uma transação, você pode usar métodos do tipo <code>Transaction.Enlist <i>Smth</i></code> .  Além disso, você precisa implementar a interface exigida por esses métodos.  Gerenciador de recursos - este é apenas um "algo" que suporta a interação com transações do <code>System.Transactions</code> (uma definição mais específica é fornecida abaixo). <br><br>  O que são gerenciadores de recursos?  Se trabalhamos em C # com um DBMS, por exemplo, SQL Server ou Oracle Database, geralmente usamos os drivers apropriados, e eles são os recursos de gerenciamento.  No código, eles são representados pelos tipos <code>System.Data.SqlClient.SqlConnection</code> e <code>Oracle.ManagedDataAccess.Client.OracleConnection</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eles também dizem</a> que o MSMQ oferece suporte a transações baseadas em <code>System.Transactions</code> .  Guiado pelo conhecimento e exemplos retirados da Internet, você pode criar seu próprio gerenciador de recursos.  O exemplo mais simples é dado na próxima seção. <br><br>  Além dos gerenciadores de recursos, também devemos ter um Gerenciador de Transações, que monitorará a transação e dará ordens aos gerentes de recursos em tempo hábil.  Dependendo de quais gerenciadores de recursos estão envolvidos na transação (quais características eles têm e onde estão localizados), diferentes gerenciadores de transações são conectados ao trabalho.  Nesse caso, a seleção da versão apropriada é automática e não requer a intervenção de um programador. <br><br>  Mais especificamente, o gerenciador de recursos é uma instância de uma classe que implementa a interface especial <code>System.Transactions.IEnlistmentNotification</code> .  A instância da classe, conforme direcionado pelo cliente, é registrada como participante da transação usando a propriedade estática <code>System.Transactions.Transaction.Current</code> .  Posteriormente, o gerenciador de transações chama métodos da interface especificada, conforme necessário. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/ea/vp/tweavpimeod539do_fkzpr6yzrw.png"></div><br>  É claro que, no tempo de execução, o conjunto de gerenciadores de recursos envolvidos na transação pode mudar.  Por exemplo, depois de inserir o bloco <code>using</code> , podemos primeiro fazer algo no SQL Server e depois no Oracle Database.  Dependendo desse conjunto de gerenciadores de recursos, o gerenciador de transações usado é determinado.  Para ser mais preciso, o protocolo de transação usado é determinado pelo conjunto de gerenciadores de recursos, e o gerenciador de transações que o suporta é determinado com base no protocolo.  Veremos os protocolos transacionais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais tarde,</a> quando falarmos sobre transações distribuídas.  O mecanismo para selecionar automaticamente o gerenciador de transações apropriado no tempo de execução ao alterar os gerenciadores de recursos envolvidos na transação é chamado Promoção de Transação. <br><br><a name="KindsOfResourceManagers"></a><h4>  Tipos de gerenciadores de recursos </h4><br>  Os gerentes de recursos podem ser divididos em dois grandes grupos: duráveis ​​e variáveis. <br><br>  Durable Resource Manager - um gerenciador de recursos que suporta uma transação, mesmo que o sistema de informações não esteja disponível (por exemplo, quando o computador reiniciar).  Volatile Resource Manager - Um gerenciador de recursos que não suporta uma transação se o sistema de informações não estiver disponível.  Um gerenciador de recursos inconsistente suporta apenas transações na memória. <br><br>  Os gerenciadores de recursos clássicos de longo prazo são o DBMS (ou o driver DBMS da plataforma de software).  Não importa o que aconteça - pelo menos um mau funcionamento do sistema operacional, pelo menos uma falta de energia - o DBMS garantirá a integridade dos dados após retornar à condição de trabalho.  Por isso, é claro, você deve pagar alguns inconvenientes, mas neste artigo não os consideraremos.  Um exemplo de um gerenciador de recursos não persistente é a memória transacional do software mencionada acima. <br><br><a name="TransactionScope"></a><h4>  Usando o TransactionScope </h4><br>  Ao criar um objeto do tipo <code>TransactionScope</code> você pode especificar alguns parâmetros. <br><br>  Primeiramente, há uma configuração que informa ao tempo de execução o que ele precisa: <br><br><ol><li>  Use uma transação que já existe no momento; </li><li>  Certifique-se de criar um novo; </li><li>  por outro lado, execute o código dentro de um bloco <code>using</code> fora de uma transação. </li></ol><br>  A enumeração <code>System.Transactions.TransactionScopeOption</code> é responsável por tudo isso. <br><br>  Em segundo lugar, você pode definir o nível de isolamento da transação.  Este é um parâmetro que permite encontrar um compromisso entre a independência da mudança e a velocidade.  O nível mais independente - serializável - garante que não haja situações em que as alterações feitas em uma transação que ainda não foram confirmadas possam ser vistas em outra transação.  Cada próximo nível adiciona uma situação específica, quando a execução simultânea de transações pode afetar uma à outra.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por padrão, uma transação é aberta no nível serializável, o que pode ser desagradável (consulte, por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este comentário</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definir o nível de isolamento da transação durante a criação </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é um aconselhamento para os gerenciadores de recursos. Eles podem até não suportar todos os níveis listados </font></font><code>System.Transactions.IsolationLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Além disso, deve-se ter em mente que, ao usar o pool de conexões para trabalhar com o banco de dados, a conexão para a qual o nível de isolamento da transação foi alterado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manterá esse nível</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao retornar ao pool </font><font style="vertical-align: inherit;">. Agora, quando o programador receber essa conexão do pool e confiar nos valores padrão, ele observará um comportamento inesperado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cenários típicos de trabalho c</font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e armadilhas significativas (ou seja, transações aninhadas) são bem cobertas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste artigo no "Habr"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="Applicability"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aplicabilidade de transação de software </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve-se dizer que em quase qualquer sistema de informações em operação comercial, são iniciados processos que podem levar o sistema a um estado inaceitável. </font><font style="vertical-align: inherit;">Portanto, pode ser necessário controlar esses processos, descobrir se o estado atual do sistema é aceitável e, se não, restaurá-lo. </font><font style="vertical-align: inherit;">Transações de software - uma ferramenta pronta para manter o sistema em um estado aceitável. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em cada caso, seria construtivo considerar o custo:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integrar processos à infraestrutura de transações de software (esses processos também precisam estar cientes </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de muitas outras coisas);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manutenção dessa infraestrutura (por exemplo, o custo do aluguel de equipamentos com o Windows a bordo); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> treinamento de funcionários (já que o tópico de transações do .NET não é comum). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não devemos esquecer que o processo de transação pode ser solicitado a relatar seu progresso ao "mundo externo", por exemplo, para manter um diário de ações fora da transação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, a rejeição de transações de software exigirá a criação ou implementação de outros meios de manutenção da integridade dos dados, que também terão seu valor. </font><font style="vertical-align: inherit;">No final, pode haver casos em que as violações à integridade dos dados são tão raras que é mais fácil restaurar um estado aceitável do sistema por intervenções cirúrgicas do que manter um mecanismo de recuperação automática.</font></font><br><br><a name="Example"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um exemplo de um gerenciador de recursos inconstante </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos ver um exemplo de um gerenciador de recursos simples que não oferece suporte à recuperação de uma falha do sistema. Teremos um bloco de memória transacional de software que armazena algum valor que pode ser lido e gravado. Na ausência de uma transação, esse bloco se comporta como uma variável regular e, na presença de uma transação, armazena o valor inicial, que pode ser restaurado após a reversão da transação. O código para esse gerenciador de recursos é apresentado abaixo:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Stm</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Transactions</span></span>.<span class="hljs-title"><span class="hljs-title">IEnlistmentNotification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _current; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _original; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _enlisted; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _current; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Enlist()) { _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_enlisted) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentTx = System.Transactions.Transaction.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTx == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; currentTx.EnlistVolatile(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, System.Transactions.EnlistmentOptions.None); _enlisted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IEnlistmentNotification public void Commit(System.Transactions.Enlistment enlistment) { _original = _current; _enlisted = false; } public void InDoubt(System.Transactions.Enlistment enlistment) { _enlisted = false; } public void Prepare(System.Transactions.PreparingEnlistment preparingEnlistment) { preparingEnlistment.Prepared(); } public void Rollback(System.Transactions.Enlistment enlistment) { _current = _original; _enlisted = false; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> IEnlistmentNotification }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode-se observar que o único requisito formal é a implementação da interface </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dos interessantes, métodos </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(que não fazem parte </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O método </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas verifica se o código fornecido funciona dentro da estrutura da transação e, nesse caso, registra uma instância de sua classe como um gerenciador de recursos não constante. O método </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é chamado pelo gerenciador de transações antes de confirmar as alterações. Nosso gerente de recursos sinaliza sua prontidão para confirmar chamando um método </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, um código que mostra um exemplo de uso do nosso gerenciador de recursos:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stm&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { stm.Value = <span class="hljs-number"><span class="hljs-number">2</span></span>; scope.Complete(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ler a propriedade </font><font style="vertical-align: inherit;">imediatamente após sair do bloco </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o valor esperado será esperado lá </font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">E se você remover a chamada </font></font><code>scope.Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a transação será revertida e a propriedade </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terá o valor </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definido antes do início da transação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma sequência simplificada de chamadas ao trabalhar com transações é </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mostrada no diagrama abaixo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/09/je/1d/09je1dkghhmmwts6rvaufuntpna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode-se observar que, neste exemplo, nem todas as possibilidades oferecidas pela infraestrutura são consideradas </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos considerá-los mais completamente depois de nos familiarizarmos com protocolos transacionais e transações distribuídas na próxima seção.</font></font><br><br><a name="TLDR2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seção TL; DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um programador pode usar uma classe </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para executar algum código em uma transação existente ou nova. Uma transação é confirmada se e somente se o </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método for chamado </font><font style="vertical-align: inherit;">em uma instância existente da classe </font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mesmo que o método tenha sido chamado antes</font></font><code>Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Um programador pode indicar se deseja iniciar uma nova transação, tirar proveito de uma transação existente ou, inversamente, executar código fora de uma transação existente. Somente gerenciadores de recursos estão envolvidos na transação - componentes de software que implementam determinadas funcionalidades. Os gerenciadores de recursos podem ser de longo prazo (recuperação de uma falha do sistema) e intermitentes (sem recuperação). Um DBMS é um exemplo de um gerenciador de recursos de longa duração. O gerenciador de recursos é coordenado por um gerenciador de transações - um componente de software que é selecionado automaticamente pelo tempo de execução sem a participação de um programador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O gerenciador de recursos inconsistente é uma classe que implementa a interface </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no método</font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">confirmando sua disponibilidade para confirmar alterações ou, inversamente, sinalizando uma reversão de alterações. </font><font style="vertical-align: inherit;">Quando o chamador está fazendo algo para gerir os recursos, ele verifica se a transação está agora aberto, e, se aberto, é registrado pelo método </font></font><code>System.Transactions.Transaction.EnlistVolatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="DistributedTransactions"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transações Distribuídas </font></font></h2><br><a name="WhatIsIt2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que é isso </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma transação distribuída envolve vários subsistemas de informações (na verdade, nem tudo é tão simples, mais sobre isso abaixo). </font><font style="vertical-align: inherit;">Entende-se que as alterações em todos os sistemas envolvidos em uma transação distribuída devem ser confirmadas ou revertidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vários meios de implementação de transações foram apresentados acima: DBMS, infraestrutura </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e memória transacional programática incorporada à plataforma. </font><font style="vertical-align: inherit;">As transações distribuídas também podem ser fornecidas com essas ferramentas. </font><font style="vertical-align: inherit;">Por exemplo, no banco de dados Oracle, alterar (e realmente ler) dados em vários bancos de dados em uma única transação automaticamente os transforma em distribuídos. </font><font style="vertical-align: inherit;">A seguir, falaremos sobre transações distribuídas por software, que podem incluir gerenciadores de recursos heterogêneos.</font></font><br><br><a name="TransactionProtocols"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protocolos transacionais </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um protocolo transacional é um conjunto de princípios pelos quais os aplicativos envolvidos em uma transação interagem. No mundo .NET, os seguintes protocolos são mais comumente encontrados. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leve.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Não é usado mais que um gerenciador de recursos durável. Todas as interações transacionais ocorrem no mesmo domínio de aplicativo ou o gerenciador de recursos suporta promoção e confirmação de fase única (implementos </font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OleTx.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> É permitida a interoperabilidade entre vários domínios de aplicativos e vários computadores. Você pode usar muitos gerenciadores de recursos duráveis. Todos os computadores participantes devem estar executando o Windows. Use chamadas de procedimento remoto (RPCs). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WS-AT.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É permitida a interoperabilidade entre vários domínios de aplicativos e vários computadores. Você pode usar muitos gerenciadores de recursos duráveis. Os computadores participantes podem estar executando vários sistemas operacionais, não apenas o Windows. O protocolo de transmissão de hipertexto (HTTP) é usado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observou-se acima que o atual protocolo de transação afeta a escolha do gerenciador de transações, e as características dos recursos de controle envolvidos na transação influenciam a escolha do protocolo. Agora listamos os conhecidos gerenciadores de transações. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerenciador de transações leves (LTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Introduzido no .NET Framework 2.0 e posterior. Gerencia transações usando o protocolo Lightweight. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerenciador de Transações do Kernel (KTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Introduzido no Windows Vista e Windows Server 2008. Gerencia transações usando o protocolo Lightweight. Ele pode chamar um Sistema de arquivos transacionais (TxF) e um Registro transacional (TxR) no Windows Vista e Windows 2008. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenador de transações distribuídas (MSDTC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gerencia transações usando os protocolos OleTx e WS-AT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também deve-se ter em mente que alguns gerenciadores de recursos não oferecem suporte a todos os protocolos listados. Por exemplo, o MSMQ e o SQL Server 2000 não oferecem suporte ao Lightweight, portanto, as transações envolvendo o MSMQ ou o SQL Server 2000 serão gerenciadas pelo MSDTC, mesmo que sejam os únicos participantes. Tecnicamente, essa limitação decorre do fato de que os gerenciadores de recursos especificados, implementando, é claro, a interface</font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não implemente a interface </font></font><code>System.Transactions.IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele contém, entre outras coisas, um método </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que o tempo de execução chama, se necessário, para alternar para um gerenciador de transações mais íngreme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ambiguidade do conceito de transação distribuída deve agora se tornar aparente. </font><font style="vertical-align: inherit;">Por exemplo, você pode definir uma transação distribuída como uma transação da qual ela participa:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelo menos dois de qualquer gerenciador de recursos; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerentes de recursos arbitrariamente variáveis ​​e pelo menos dois de longa duração; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelo menos dois de quaisquer gerenciadores de recursos necessariamente localizados em computadores diferentes. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, é melhor sempre esclarecer quais transações específicas estão envolvidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, neste contexto, o MSDTC é discutido principalmente. </font><font style="vertical-align: inherit;">É um componente de software do Windows que gerencia transações distribuídas. </font><font style="vertical-align: inherit;">Há uma interface gráfica para configurar e monitorar transações, que pode ser encontrada no utilitário "Serviços de componentes", seguindo o caminho "Computadores - Meu computador - Coordenador de transações distribuídas - DTC local".</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vo/35/gc/vo35gcdta3c9qx5w5cnsuxkbzz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para configuração, selecione o item “Propriedades” no menu de contexto do nó “Local DTC” e, para monitorar transações distribuídas, selecione o item “Estatísticas de transação” no painel central. </font></font><br><br><a name="TwoPhaseCommit"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fixação bifásica </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se vários gerenciadores de recursos participarem da transação, os resultados de seu trabalho poderão ser diferentes: por exemplo, um deles foi concluído com êxito e ele está pronto para confirmar as alterações, e o outro tem um erro e reverterá as alterações. No entanto, a essência de uma transação distribuída está no fato de que as alterações em todos os recursos de controle envolvidos na transação são confirmadas todas juntas ou revertidas. Portanto, nesses casos, geralmente é usado um protocolo de fixação em duas fases. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, a essência deste protocolo é a seguinte. Durante a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeira fase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os gerenciadores de recursos envolvidos na transação preparam informações suficientes para se recuperar da falha (se for um gerenciador de recursos de longo prazo) e para a conclusão bem-sucedida como resultado de uma confirmação. Do ponto de vista técnico, o gerenciador de recursos sinaliza que ele concluiu a primeira fase chamando o método </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no método </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ou gestão dos recursos pode notificar alterações de reversão chamando </font></font><code>ForceRollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando todos os gerenciadores de recursos envolvidos na transação "votaram", ou seja, eles notificaram o gerente de transações se desejam confirmar ou reverter as alterações, a </font><b><font style="vertical-align: inherit;">segunda fase</font></b><font style="vertical-align: inherit;"> começa</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No momento, os gerentes de recursos são instruídos a confirmar suas alterações (se todos os participantes votaram na correção) ou a recusar alterações (se pelo menos um participante votou na reversão). Tecnicamente, isso é expresso na invocação dos métodos </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementada pelos gerenciadores de recursos e na qual eles invocam o método </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O gerenciador de recursos também pode chamar o método </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durante a primeira fase. Nesse caso, entende-se que ele não fará alterações (por exemplo, trabalha apenas para leitura) e não participará da segunda fase. Leia mais sobre o commit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> duas fases </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">na Microsoft</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a conexão entre o gerenciador de transações e pelo menos um dos gerenciadores de recursos for perdida, a transação ficará congelada ("em dúvida", em dúvida). </font><font style="vertical-align: inherit;">O gerenciador de transações, chamando métodos </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, notifica os gerenciadores de recursos disponíveis deste evento que podem responder adequadamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda existe uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixação trifásica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e suas modificações com suas vantagens e desvantagens. </font><font style="vertical-align: inherit;">O protocolo de consolidação trifásico é menos comum, talvez porque exija ainda mais custos de comunicação entre os subsistemas em interação.</font></font><br><br><a name="Interfaces"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folha de dicas nas interfaces System.Transactions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo está difícil. Para resolver um pouco as coisas, descreverei brevemente as principais interfaces de namespace </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessárias para criar um gerenciador de recursos. Aqui está um diagrama de classes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/rj/sx/bsrjsxptqz6w3g7l6zxawrzeyco.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEnlistmentNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O gerenciador de recursos implementa essa interface. O gerenciador de transações chama os métodos implementados na seguinte ordem. Durante a primeira fase, ele chama o método </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(a menos que as estrelas se unissem para chamá-lo </font></font><code>ISinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como descrito no próximo parágrafo). Sob esse método, o gerenciador de recursos salva as informações necessárias para se recuperar de uma falha, se prepara para a confirmação final de alterações do seu lado e vota para confirmar ou reverter as alterações. Se chega uma segunda fase, dependendo da disponibilidade de recursos e controle dos resultados da votação da transação controle é um dos três métodos: </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O gerenciador de recursos implementa essa interface se ele deseja fornecer ao gerente de transações a oportunidade de otimizar a execução, reduzindo a segunda fase de confirmação. Se o gerenciador de transações vir apenas um gerenciador de recursos, na primeira fase de confirmação, ele tentará chamar o método do gerenciador de recursos </font></font><code>SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(em vez disso </font></font><code>IEnlistmentNotification.Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e, assim, excluir a votação e a transição para a segunda fase. Essa abordagem tem vantagens e desvantagens, sobre as quais a Microsoft escreveu mais claramente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ITransactionPromoter.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O gerenciador de recursos implementa essa interface (não apenas diretamente, mas através da interface</font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), se ele quiser fornecer ao gerente de transações a capacidade de aderir ao protocolo Lightweight, mesmo quando estiver chamando remotamente, até que surjam outras condições que exijam complicação do protocolo. Quando você precisar complicar o protocolo, o método será chamado </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPromotableSinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O gerenciador de recursos implementa essa interface para, em primeiro lugar, implementar a interface </font></font><code>ITransactionPromoter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em segundo lugar, para que o gerenciador de transações possa usar confirmação de fase única, métodos de chamada </font></font><code>IPromotableSinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>IPromotableSinglePhaseNotification.Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O gerenciador de transações chama um método </font></font><code>IPromotableSinglePhaseNotification.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para marcar o registro bem-sucedido do gerenciador de recursos de maneira simplificada. Mais ou menos, isso pode ser entendido em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um documento da Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos olhar um pouco mais</font></font><code>System.Transactions.Enlistment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e seus herdeiros. Esse tipo de instância é fornecido pelo gerenciador de transações quando ele chama os métodos de interface implementados pelo gerenciador de recursos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/bd/xc/qibdxcddktegq5h2xnpuaelygj0.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alistamento. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O gerenciador de recursos pode chamar um único método desse tipo - </font></font><code>Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, - para sinalizar a conclusão bem-sucedida de sua parte do trabalho. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PreparingEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando uma instância desse tipo durante a primeira fase de confirmação, o gerenciador de recursos pode sinalizar sua intenção de confirmar ou reverter as alterações. </font><font style="vertical-align: inherit;">Um gerenciador de recursos de longa duração também pode obter as informações necessárias para se recuperar de uma falha do sistema. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SinglePhaseEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando uma instância desse tipo, o gerenciador de recursos pode transmitir informações ao gerente de transações sobre os resultados de seu trabalho usando um esquema simplificado (confirmação de fase única).</font></font><br><br><a name="LimitationsAndAlternatives"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limitações e alternativas de transação distribuída por software </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um breve estudo das opiniões encontradas na Internet mostra que, em muitas áreas, as transações distribuídas estão fora de moda. Dê uma olhada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste comentário malicioso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por exemplo </font><font style="vertical-align: inherit;">. O principal objeto de crítica, que é brevemente mencionado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , é a natureza síncrona (bloqueadora) das transações distribuídas. Se o usuário enviou uma solicitação durante o processamento em que uma transação distribuída foi organizada, ele receberá uma resposta somente depois que (com êxito ou com erro) todos os subsistemas incluídos na transação terminarem de funcionar. Ao mesmo tempo, há uma opinião apoiada por pesquisas de que o protocolo de confirmação de duas fases mostra um desempenho ruim, especialmente com um aumento no número de subsistemas envolvidos na transação, como é mencionado, por exemplo, em</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta publicação em "Habré"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o criador do sistema preferir retornar a resposta ao usuário o mais rápido possível, adiando a coordenação dos dados para mais tarde, então alguma outra solução será mais adequada para ele. No contexto do teorema de Brewer (teorema da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), podemos dizer que as transações distribuídas são adequadas para casos em que a consistência dos dados é mais importante que a disponibilidade.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem outras restrições práticas no uso de transações distribuídas por software. Por exemplo, foi estabelecido experimentalmente que transações distribuídas usando o protocolo OleTx não deveriam cruzar domínios de rede. De qualquer forma, longas tentativas de fazê-los funcionar não tiveram êxito. Além disso, foi revelado que a interação entre várias instâncias do Oracle Database (transações de banco de dados distribuídas) impõe sérias restrições à aplicabilidade das transações distribuídas por software (novamente, falha ao iniciar).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quais são as alternativas para transações distribuídas? Primeiro, devo dizer que será muito difícil prescindir de transações técnicas (normais, não distribuídas). É provável que existam processos no sistema que possam interromper temporariamente a integridade dos dados e será necessário, de alguma forma, supervisionar esses processos. Da mesma forma, em termos de área de assunto, pode surgir um conceito que inclua um processo implementado por um conjunto de processos em diferentes sistemas técnicos, que deve começar e terminar no campo de dados integrais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passando para alternativas às transações distribuídas, podemos observar soluções baseadas em serviços de mensagens, como RabbitMQ e Apache Kafka. Em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desta publicação em "Habré"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> visto quatro destas soluções:</font></font><br><br><ol><li>   ,        ,    ; </li><li>    ,           (Transaction Log Tailing); </li><li>       ,       ; </li><li>             (Event Sourcing). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra alternativa é o modelo Saga. Envolve uma cascata de subsistemas com suas transações locais. Após a conclusão do trabalho, cada sistema chama o seguinte (independentemente ou com a ajuda de um coordenador). Para cada transação, há uma transação de cancelamento correspondente e, em vez de transferir o controle, o subsistema pode iniciar o cancelamento das alterações feitas anteriormente pelos subsistemas anteriores. Em "Habré", existem alguns bons artigos sobre o modelo "Saga". Por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta publicação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fornece informações gerais sobre a manutenção dos princípios do ACID em microsserviços, e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detalha um exemplo de implementação do modelo Saga com um coordenador.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em nossa empresa, alguns produtos usam com êxito transações distribuídas por software por meio do WCF, mas existem outras opções. Certa vez, quando tentamos fazer dos amigos um novo sistema com transações distribuídas, tivemos muitos problemas, incluindo uma colisão com as limitações descritas acima e problemas paralelos com a atualização da infraestrutura de software. Portanto, em condições de escassez de recursos para execução em outra decisão de capital, aplicamos as seguintes táticas. A parte chamada captura as alterações em qualquer caso, mas observa que elas estão em um estado de rascunho, portanto essas alterações ainda não afetam a operação do sistema chamado. Em seguida, o chamador, ao concluir seu trabalho por meio de uma transação distribuída, o DBMS ativa as alterações feitas pelo sistema chamado. Desta maneiraem vez de transações distribuídas por software, usamos transações DBMS distribuídas, que nesse caso se mostraram muito mais confiáveis.</font></font><br><br><a name="NetCore"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Então está no .NET Core? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No .NET Core (e até no .NET Standard), existem todos os tipos necessários para organizar transações e criar seu próprio gerenciador de recursos. </font><font style="vertical-align: inherit;">Infelizmente, no .NET Core, as transações baseadas </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">têm uma limitação séria: elas funcionam apenas com o protocolo Lightweight. </font><font style="vertical-align: inherit;">Por exemplo, se dois gerenciadores de recursos duráveis ​​forem usados ​​no código, em tempo de execução, o ambiente emitirá uma exceção assim que o segundo gerenciador for chamado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O fato é que eles tentam tornar o .NET Core independente do sistema operacional; portanto, o link para gerenciadores de transações como KTM e MSDTC é excluído, ou seja, eles são necessários para oferecer suporte a transações com as propriedades especificadas. </font><font style="vertical-align: inherit;">É possível que a conexão dos gerenciadores de transações seja implementada na forma de plug-ins, mas até agora isso foi escrito com um forcado, para que você ainda não possa contar com o uso industrial de transações distribuídas no .NET Core. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por experiência, você pode verificar as diferenças nas transações distribuídas no .NET Framework e no .NET Core escrevendo o mesmo código, compilando e executando-o em plataformas diferentes.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo desse código que chama o SQL Server e o Oracle Database sequencialmente.</font></font></b> <div class="spoiler_text"><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { MsSqlServer(); Oracle(); scope.Complete(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Oracle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oracle.ManagedDataAccess.Client.OracleConnection(<span class="hljs-string"><span class="hljs-string">"User Id=some_user;Password=some_password;Data Source=some_db"</span></span>)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MsSqlServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnectionStringBuilder { DataSource = <span class="hljs-string"><span class="hljs-string">"some_computer\\some_db"</span></span>, UserID = <span class="hljs-string"><span class="hljs-string">"some_user"</span></span>, Password = <span class="hljs-string"><span class="hljs-string">"some_password"</span></span>, InitialCatalog = <span class="hljs-string"><span class="hljs-string">"some_scheme"</span></span>, Enlist = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnection(builder.ConnectionString)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projetos prontos para compilação </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estão no GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A execução do exemplo para o .NET Core falha. </font><font style="vertical-align: inherit;">O local e o tipo da exceção lançada dependem da ordem da chamada DBMS, mas, em qualquer caso, essa exceção indica uma operação de transação inválida. </font><font style="vertical-align: inherit;">A execução do exemplo para o .NET Framework será bem-sucedida se o MSDTC estiver em execução no momento; </font><font style="vertical-align: inherit;">no entanto, na interface gráfica do MSDTC, é possível observar o registro de uma transação distribuída.</font></font><br><br><a name="WCF"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transações Distribuídas e WCF </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Windows Communication Foundation (WCF) é a estrutura .NET para organizar e chamar serviços de rede. Comparado às abordagens mais modernas da Web REST e ASP.NET, ela tem suas próprias vantagens e desvantagens. O WCF é muito amigo das transações do .NET e, no mundo do .NET Framework, é conveniente usá-lo para organizar transações distribuídas entre o cliente e o serviço. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No .NET Core, essa tecnologia funciona apenas no lado do cliente, ou seja, você não pode criar um serviço, mas pode se referir apenas a um existente. Isso, no entanto, não é muito importante, porque, como mencionado acima, com transações distribuídas no .NET Core, as coisas não estão indo bem. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o WCF funciona</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para leitores que não estão familiarizados com o WCF, aqui estão as informações mais curtas sobre o que essa tecnologia é na prática. Contexto - dois sistemas de informação chamados cliente e serviço. O cliente em tempo de execução acessa outro sistema de informações que suporta o serviço de interesse do cliente e requer que alguma operação seja executada. Em seguida, o gerenciamento é retornado ao cliente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar um serviço no WCF, você geralmente precisa escrever uma interface que descreva o contrato para o serviço que está sendo criado e uma classe que implemente essa interface. A classe e a interface são marcadas com atributos especiais do WCF que os distinguem do restante dos tipos e especificam alguns detalhes do comportamento durante a descoberta e chamada do serviço. Esses tipos são agrupados em algo que funciona como um servidor (por exemplo, em uma DLL na qual o IIS está configurado) e são complementados por um arquivo de configuração (existem opções), onde são indicados detalhes da implementação do serviço. Após o início, o serviço pode ser acessado, por exemplo, no endereço de rede; no navegador da Internet, você pode ver os contratos que o serviço solicitado implementa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um programador que deseja acessar um serviço WCF existente usa um utilitário de console ou uma interface gráfica incorporada ao ambiente de desenvolvimento para formar tipos em C # (ou em outro idioma suportado) que correspondem aos contratos de serviço no endereço do serviço. O arquivo com os tipos obtidos é incluído no projeto do aplicativo cliente e, depois disso, o programador usa os mesmos termos contidos na interface de serviço, aproveitando os benefícios do progresso (digitação estática). Além disso, o arquivo de configuração do cliente especifica as características técnicas do serviço chamado (ele também pode ser configurado no código, sem o arquivo de configuração).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O WCF suporta vários tipos de transporte, criptografia e outros parâmetros técnicos mais sutis. </font><font style="vertical-align: inherit;">A maioria deles está unida pelo conceito de "encadernação" (encadernação). </font><font style="vertical-align: inherit;">Existem três parâmetros importantes para o serviço WCF:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o endereço em que está disponível; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vinculativo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contrato (interfaces). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos esses parâmetros são definidos nos arquivos de configuração de serviço e cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em nossa empresa, o WCF (com e sem transações distribuídas) é amplamente utilizado em produtos implementados, no entanto, dadas as tendências da moda, seu uso em novos produtos ainda está em questão. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como iniciar transações distribuídas no WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para iniciar transações baseadas no WCF </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o programador precisa definir vários atributos no código, verifique se as ligações usadas suportam transações distribuídas, </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que </font><font style="vertical-align: inherit;">elas sejam gravadas no cliente e no serviço </font><font style="vertical-align: inherit;">e se um gerenciador de transações adequado esteja sendo executado em todos os computadores envolvidos (provavelmente , será MSDTC).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligações de transação distribuída: NetTcpBinding, NetNamedPipeBinding, WSHttpBinding, WSDualHttpBinding e WSFederationHttpBinding. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O método (operação) da interface de serviço deve ser marcado com um atributo </font></font><code>System.ServiceModel.TransactionFlowAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, com determinados parâmetros de atributo e ao definir o parâmetro de </font></font><code>TransactionScopeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">a </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transação será distribuída entre o cliente e o serviço. </font><font style="vertical-align: inherit;">Além disso, por padrão, o serviço é considerado votado para confirmar a transação, a menos que uma exceção seja lançada no tempo de execução. </font><font style="vertical-align: inherit;">Para alterar esse comportamento, você deve definir o valor do parâmetro do </font></font><code>TransactionAutoComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo </font><font style="vertical-align: inherit;">correspondente </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O código para um serviço WCF simples que suporta transações distribuídas.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.ServiceModel.ServiceContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationContract] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyService</span></span> : <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationBehavior(TransactionScopeRequired = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(input)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.Length; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, ele difere do código de serviço regular apenas no uso do atributo </font></font><code>System.ServiceModel.TransactionFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e na configuração especial do atributo </font></font><code>System.ServiceModel.OperationBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de configuração para este serviço.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">&lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.MyService"</span></span> behaviorConfiguration=<span class="hljs-string"><span class="hljs-string">"serviceBehavior"</span></span>&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">""</span></span> binding=<span class="hljs-string"><span class="hljs-string">"wsHttpBinding"</span></span> bindingConfiguration=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.IMyService"</span></span>/&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">"mex"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"IMetadataExchange"</span></span> binding=<span class="hljs-string"><span class="hljs-string">"mexHttpBinding"</span></span>/&gt; &lt;/service&gt; &lt;/services&gt; &lt;bindings&gt; &lt;wsHttpBinding&gt; &lt;binding name=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> maxReceivedMessageSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxBufferPoolSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> transactionFlow=<span class="hljs-string"><span class="hljs-string">"true"</span></span> closeTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> openTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> receiveTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> sendTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span>&gt; &lt;security mode=<span class="hljs-string"><span class="hljs-string">"None"</span></span>/&gt; &lt;readerQuotas maxArrayLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxStringContentLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span>/&gt; &lt;/binding&gt; &lt;/wsHttpBinding&gt; &lt;/bindings&gt; &lt;/system.serviceModel&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que a ligação é do tipo WSHttpBinding e o atributo é usado </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></div></div><br><a name="TLDR3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seção TL; DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As transações distribuídas incluem vários gerenciadores de recursos e todas as alterações devem ser confirmadas ou revertidas. Alguns DBMSs modernos implementam transações distribuídas que fornecem um mecanismo conveniente para conectar vários bancos de dados. As transações distribuídas por software (não implementadas no DBMS) podem incluir diferentes combinações de gerenciadores de recursos em computadores diferentes executando sistemas operacionais diferentes, mas possuem limitações que devem ser levadas em consideração antes de confiar nelas. Uma alternativa moderna às transações distribuídas são as soluções de mensagens. No .NET Core, transações distribuídas ainda não são suportadas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O WCF é uma das ferramentas padrão e comprovadas para criar e acessar serviços no mundo .NET, suportando vários tipos de transporte e criptografia. </font><font style="vertical-align: inherit;">O WCF é muito amigo de transações distribuídas com base em </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A configuração de transações distribuídas para o WCF consiste em marcar o código com vários atributos e adicionar algumas palavras nos arquivos de configuração de serviço e cliente. </font><font style="vertical-align: inherit;">Nem todas as ligações do WCF suportam transações distribuídas. </font><font style="vertical-align: inherit;">Além disso, é claro que as transações no WCF têm as mesmas limitações que sem o uso do WCF. </font><font style="vertical-align: inherit;">Até agora, a plataforma .NET Core permite acessar serviços no WCF, em vez de criá-los.</font></font><br><br><a name="Conclusion"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusão Berço </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta postagem é uma visão geral dos conceitos básicos das transações de software .NET. Algumas conclusões sobre tendências nas transações de software podem ser encontradas nas seções sobre aplicabilidade e limitações dos assuntos discutidos e, em conclusão, são coletadas as principais teses da publicação. Suponho que eles possam ser usados ​​como uma cábula ao considerar as transações de software como uma das opções para implementar um sistema técnico ou atualizar informações relevantes na memória. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transações (área de assunto, DBMS, software)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Às vezes, os requisitos de domínio são formulados na forma de transações - operações que, começando no campo de dados integrais, após a conclusão (inclusive sem êxito) também devem entrar no campo de dados integrais (possivelmente já diferentes). Esses requisitos geralmente são implementados como transações do sistema. Um exemplo clássico de uma transação é a transferência de dinheiro entre duas contas, consistindo em duas operações indivisíveis - retirar dinheiro de uma conta e creditar para outra. Além das transações conhecidas implementadas pelo DBMS, também existem transações de software, por exemplo, no mundo .NET. Os gerenciadores de recursos são componentes de software que estão cientes da existência de tais transações e têm a capacidade de serem incluídos nelas, ou seja, confirmar ou reverter as alterações feitas.Os gerentes de recursos recebem instruções sobre como confirmar e reverter alterações do gerenciador de transações, que é a base da infraestrutura</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerentes de recursos duráveis ​​e intermitentes.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os gerentes de recursos de longo prazo oferecem suporte à recuperação de dados após uma falha do sistema. Os drivers DBMS para .NET geralmente oferecem essa funcionalidade. Os gerenciadores de recursos intermitentes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oferecem suporte à recuperação de desastres. A memória transacional programática - uma maneira de gerenciar objetos na RAM - pode ser vista como um exemplo de um gerenciador de recursos inconstante. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transações e gerenciadores de recursos .NET.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O programador .NET usa transações de software e cria seus próprios gerenciadores de recursos usando tipos do espaço para nome</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Essa infraestrutura permite o uso de transações de vários aninhamentos e isolamentos (com limitações conhecidas). O uso de transações não é complicado e consiste em agrupar o código em um bloco </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com certas características. No entanto, os gerenciadores de recursos incluídos dessa maneira na transação devem manter a funcionalidade necessária para sua parte. Usar gerenciadores de recursos heterogêneos em uma transação ou usar um gerenciador de maneiras diferentes pode transformar automaticamente uma transação em distribuída. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transações distribuídas (DBMS, software).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma transação distribuída abrange vários subsistemas, cujas mudanças devem ser sincronizadas, ou seja, elas são confirmadas todas juntas ou revertidas. As transações distribuídas são implementadas em alguns DBMSs modernos. As transações distribuídas por software (não são as implementadas pelo DBMS) impõem restrições adicionais aos processos e plataformas em interação. As transações distribuídas gradualmente saem de moda, dando lugar a soluções baseadas em serviços de mensagens. Para transformar uma transação comum em uma distribuída, o programador não precisa fazer nada: quando um gerenciador de recursos com certas características é incluído na transação no tempo de execução, o gerenciador de transações faz automaticamente o que for necessário. As transações regulares de software estão disponíveis no .NET Core e .NET Standard, e as transações distribuídas não estão disponíveis.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transações distribuídas através do WCF. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O WCF é uma das ferramentas .NET padrão para criar e chamar serviços, que também suporta protocolos padronizados. </font><font style="vertical-align: inherit;">Em outras palavras, os serviços WCF configurados de uma maneira específica podem ser acessados ​​a partir de qualquer aplicativo, não apenas .NET ou Windows. </font><font style="vertical-align: inherit;">Para criar uma transação distribuída sobre o WCF, é necessário marcar os tipos que compõem o serviço com atributos adicionais e fazer alterações mínimas nos arquivos de configuração do serviço e do cliente. </font><font style="vertical-align: inherit;">Você não pode criar serviços WCF no .NET Core e .NET Standard, mas pode criar clientes WCF. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo para verificar System.Transactions no GitHub</font></font></a> <br><br><div class="spoiler">  <b class="spoiler_title">Referências</b> <div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conceitos básicos </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ACID</a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ( «») <br><br><h4>     </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   X/Open XA</a> ( The Open Group) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Transaction API</a> ( «») <br> <a href="">     Cache</a> (  InterSystems) <br><br><h4>   .NET </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   .NET</a> (   Tech Blog Collection) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     TransactionScope</a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  ,     </a> ( Microsoft) <br> <a href="">   .NET Standard 2.0</a> ( .NET Standard  GitHub) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       </a> ( YarFullStack) <br><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    «»     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     «»  </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> («») <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editorial</font></font></b> <div class="spoiler_text"><ul><li> 20.12.2018 . </li><li> 21.12.2018  .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">OlegAxenow</a> . </li><li> 23.12.2018      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">qw1</a> . </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433136/">https://habr.com/ru/post/pt433136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433122/index.html">React-Hot-Loader v4.6</a></li>
<li><a href="../pt433126/index.html">Zabbix Review: Como organizar uma revisão de código para monitorar a configuração</a></li>
<li><a href="../pt433128/index.html">O que os profissionais de TI jogam e não jogam (Boletim 2018)</a></li>
<li><a href="../pt433130/index.html">Que a força esteja conosco: nossa própria imunidade contra o câncer</a></li>
<li><a href="../pt433132/index.html">"Calendário do testador" para dezembro. Tente uma abordagem diferente</a></li>
<li><a href="../pt433138/index.html">Cinco princípios de design de produto no Booking</a></li>
<li><a href="../pt433140/index.html">Módulo de cliente do Google Pay pronto</a></li>
<li><a href="../pt433142/index.html">Clássicos atemporais ou uma visão geral de novos vetores de ataque através do Microsoft Office</a></li>
<li><a href="../pt433144/index.html">Lançamento do .NET Core 2.2. Novidades (1 de 3)</a></li>
<li><a href="../pt433146/index.html">[competição] Os 25 principais consoles de jogos (abane os velhos tempos)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>