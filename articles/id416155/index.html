<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèûÔ∏è üöµüèª üê∑ WebSockets di Angular: buat Layanan Angular untuk bekerja dengan soket web üë¥üèª ü§£ ü§∑üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini saya akan mencoba untuk membahas secara rinci ruang lingkup teknologi yang sempit dalam kerangka kerja Angular dan asistennya yang s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebSockets di Angular: buat Layanan Angular untuk bekerja dengan soket web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416155/"><img src="https://habrastorage.org/webt/dz/-h/c_/dz-hc_la-a4emvhkqbd4ihr5zfe.jpeg" alt="gambar"><br>  Dalam artikel ini saya akan mencoba untuk membahas secara rinci ruang lingkup teknologi yang sempit dalam kerangka kerja Angular dan asistennya yang sudah terpisahkan - RxJs, sementara kami tidak akan sengaja menyentuh implementasi server, seperti  Ini adalah topik lengkap untuk artikel terpisah. <br><br>  Teks ini akan berguna bagi mereka yang sudah terbiasa dengan Angular, tetapi ingin memperdalam pengetahuan mereka langsung pada topik tersebut. <br><a name="habracut"></a><br>  Pertama, beberapa informasi dasar. <br><br><h2>  Apa itu WebSocket dan mengapa Anda membutuhkannya </h2><br><blockquote>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> , WebSocket adalah "protokol komunikasi dupleks (dapat mengirim dan menerima pada saat yang sama) melalui koneksi TCP, yang dirancang untuk pengiriman pesan langsung antara browser dan server web. <br>  WebSocket dirancang untuk diimplementasikan di browser web dan server web, tetapi dapat digunakan untuk aplikasi klien atau server apa pun.  Protokol WebSocket adalah protokol independen yang didasarkan pada protokol TCP.  Ini memungkinkan interaksi yang lebih dekat antara browser dan situs web, memfasilitasi distribusi konten interaktif dan pembuatan aplikasi real-time. " <br></blockquote><br>  Dengan kata lain, WebSocket memungkinkan server untuk menerima permintaan dari klien dan mengirim permintaan ke klien pada waktu yang diinginkan, dengan demikian, browser (klien) dan server menerima hak yang sama dan kemampuan untuk bertukar pesan ketika terhubung.  Permintaan AJAX biasa membutuhkan transfer header HTTP lengkap, yang berarti peningkatan lalu lintas di kedua arah, sedangkan overhead soket web setelah membuat koneksi hanya dua byte.  Soket web mengurangi jumlah informasi yang dikirimkan dalam header HTTP sebanyak ratusan dan ribuan kali dan secara signifikan mengurangi waktu tunggu.  Koneksi soket web mendukung lintas domain seperti CORS. <br><br>  Di sisi server, ada paket untuk mendukung soket web, pada klien itu adalah HTML5 WebSocket API, yang memiliki antarmuka tiga metode: <br><br>  <b><i>WebSocket</i></b> - antarmuka utama untuk menghubungkan ke server WebSocket, dan kemudian mengirim dan menerima data melalui koneksi; <br>  <b><i>CloseEvent</i></b> - acara yang dikirim oleh objek WebSocket ketika koneksi ditutup; <br>  <b><i>MessageEvent</i></b> - Suatu acara yang dikirim oleh WebSocket ketika pesan diterima dari server. <br><br>  Ini adalah tampilannya di tingkat implementasi JavaSript: <br><br><pre><code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com/socketserver", "protocolOne"); ws.onopen = () =&gt; { ws.onmessage = (event) =&gt; { console.log(event); } ws.send("Here's some text that the server is urgently awaiting!"); };</code> </pre> <br>  <b><i>onmessage</i></b> - mendengarkan pesan dari server <br>  <b><i>kirim</i></b> - kirim pesan Anda ke server <br><br>  Artinya, dalam bentuk dasarnya, semuanya sangat sederhana, tetapi jika Anda memiliki keinginan untuk mempelajari topik ini, Anda dapat beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN Web Documents</a> dan pada saat yang sama mempelajari perpustakaan yang mengimplementasikan lapisan mereka sendiri di atas API ini. <br><br><h2>  Mengapa tidak takut menggunakan WebSocket </h2><br>  Poin pertama yang dapat menakuti adalah <b>dukungan browser</b> .  Saat ini tidak ada masalah seperti itu - WebSocket didukung hampir sepenuhnya baik di web maupun di segmen seluler. <br><br><img src="https://habrastorage.org/webt/6q/kt/br/6qktbrrlnloyi0ec862v8qzclts.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/bn/pk/k5/bnpkk58xzozo2c9plnkgszfjnk4.png" alt="gambar"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://caniuse.com/#feat=websockets</a> <br><br>  Poin kedua adalah <b>kemudahan implementasi</b> .  Ya, pada awalnya ini mengecewakan. <br><br>  API sangat sederhana sehingga pada pandangan pertama mungkin sulit untuk memahami bagaimana bekerja dengan sejumlah metode yang sederhana, karena semuanya, kecuali satu, melaporkan kesalahan atau koneksi, dan hanya satu di antaranya - <b><i>onmessage</i></b> - membawa untuk soket web apa yang digunakan, mis.  untuk menerima data dari server. <br><br>  Pada saat yang sama, masalahnya adalah bahwa server biasanya mengirimkan data yang berbeda, oleh karena itu, kita memerlukan beberapa pesan yang berbeda?  Atau apakah Anda perlu membuat koneksi Anda sendiri untuk setiap model data? <br><br>  Jadi, tugasnya: Anda harus menerima model pengguna dan model berita terbaru dari server, dan mungkin bahkan sesuatu yang lain. <br><br>  Saya telah menemukan implementasi yang "elegan": <br><br><pre> <code class="plaintext hljs">const wsUser = new WebSocket("ws://www.example.com/user"); wsUser.onmessage = (event) =&gt; { // ... }; const wsNews = new WebSocket("ws://www.example.com/news"); wsNews.onmessage = (event) =&gt; { // ... }; const wsTime = new WebSocket("ws://www.example.com/time"); wsTime.onmessage = (event) =&gt; { // ... }; const wsDinner = new WebSocket("ws://www.example.com/dinner"); wsDinner.onmessage = (event) =&gt; { // ... }; const wsCurrency = new WebSocket("ws://www.example.com/currency"); wsCurrency.onmessage = (event) =&gt; { // ... }; const wsOnline = new WebSocket("ws://www.example.com/online"); wsOnline.onmessage = (event) =&gt; { // ... }; const wsLogin = new WebSocket("ws://www.example.com/login"); wsLogin.onmessage = (event) =&gt; { // ... }; const wsLogout = new WebSocket("ws://www.example.com/logout"); wsLogout.onmessage = (event) =&gt; { // ... };</code> </pre> <br>  Sekilas, semuanya logis.  Tapi sekarang bayangkan bagaimana jadinya jika ada puluhan atau ratusan dari mereka.  Di salah satu proyek yang kebetulan saya kerjakan, ada sekitar tiga ratus peristiwa. <br><br><img src="https://habrastorage.org/webt/d3/rg/dl/d3rgdlp8eggnms2ot2ely5zktz8.jpeg" alt="gambar"><br><br>  Kami memecahkan masalah. <br><br>  Semua perpustakaan pihak ketiga untuk bekerja dengan soket web memungkinkan Anda untuk berlangganan pesan dari tipe addEventListener.  Ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">ws.on("user", (userData) =&gt; { / .. })</code> </pre> <br>  Seperti yang kita ketahui, kita dapat beroperasi dengan satu metode tunggal - <b><i>onmessage</i></b> , yang menerima semua data sebagai bagian dari koneksinya, sehingga kode ini terlihat agak tidak biasa.  Ini diimplementasikan sebagai berikut: <b><i>onmessage</i></b> mengembalikan <b><i>MessageEvent</i></b> yang berisi bidang <b><i>data</i></b> .  Ini adalah <b><i>data yang</i></b> berisi informasi yang dikirimkan server kepada kami.  Objek ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">{ "event": "user", "data": { "name": "John Doe", ... } }</code> </pre> <br>  di mana <b><i>peristiwa</i></b> adalah kunci yang memungkinkan untuk menentukan informasi apa yang dikirim server.  Selanjutnya, di sisi front-end, bus dibuat yang menyaring informasi berdasarkan peristiwa dan mengirimkannya ke alamat yang diinginkan: <br><br><pre> <code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com"); ws.onmessage = (event) =&gt; { const data = JSON.parse(event.data); if (data.event === 'user') { // ... } if (data.event === 'news') { // ... } };</code> </pre> <br><br>  Ini memungkinkan untuk menerima data yang berbeda dalam koneksi yang sama dan berlangganan melalui sintaksis yang mirip dengan yang biasa untuk acara JS. <br><br><h2>  WebSockets di Angular </h2><br>  Akhirnya, kami sampai pada hal yang paling penting - menggunakan WebSockets langsung di Angular. <br><br>  Terlepas dari kesederhanaan bekerja dengan WebSocket API asli, dalam artikel ini kita akan menggunakan RxJs, yang tentu saja, karena kita berbicara tentang Angular. <br><br>  API WebSocket asli dapat digunakan dalam aplikasi di Angular, membuat antarmuka yang mudah digunakan atas dasar, RxJs Observable, berlangganan pesan yang diperlukan, dll., Tetapi RxJs telah melakukan pekerjaan utama untuk Anda: WebSocketSubject adalah pembungkus reaktif atas WebSocket standar API  Itu tidak membuat bus peristiwa atau menghubungkan kembali pemrosesan.  Ini adalah Subjek biasa, yang dengannya Anda dapat bekerja dengan soket web gaya reaktif. <br><br><h2>  RxJs WebSocketSubject </h2><br>  Jadi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSocketSubject</a> mengharapkan <a href="">WebSocketSubjectConfig</a> dan tujuan opsional, di mana Anda dapat mengirimkan tautan ke Subjek yang Anda amati, menciptakan Observable di mana Anda dapat mendengarkan dan mengirim pesan untuk soket web. <br><br>  Sederhananya, Anda meneruskan url koneksi sebagai argumen WebSocketSubject dan berlangganan semua aktivitas soket web dengan cara yang biasa untuk RxJs.  Dan jika Anda perlu mengirim pesan ke server, maka gunakan metode webSocketSubject.next (data) yang biasa sama. <br><br><h2>  Kami membuat layanan untuk bekerja dengan WebSocket Angular </h2><br>  Jelaskan secara singkat apa yang kami harapkan dari layanan: <br><br><ul><li>  Antarmuka terpadu dan ringkas; </li><li>  Kemungkinan konfigurasi pada tingkat koneksi dependensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DI</a> ; </li><li>  Kemungkinan penggunaan kembali; </li><li>  Mengetik; </li><li>  Kemampuan berlangganan untuk menerima informasi dengan kunci; </li><li>  Kemampuan untuk mengakhiri langganan; </li><li>  Mengirim pesan ke server; </li><li>  Hubungkan kembali. </li></ul><br>  Poin terakhir patut diperhatikan.  Sambungan ulang, atau organisasi menghubungkan kembali ke server, adalah faktor terpenting ketika bekerja dengan soket web, sebagai  jeda jaringan, server lumpuh, atau kesalahan lain yang menyebabkan terputusnya koneksi dapat menyebabkan aplikasi mogok. <br><br>  Penting untuk dicatat bahwa upaya rekoneksi <b>tidak boleh terlalu sering</b> dan tidak boleh dilanjutkan tanpa batas, seperti  perilaku ini dapat menangguhkan klien. <br><br>  Mari kita mulai. <br><br>  Pertama-tama, kami akan membuat antarmuka konfigurasi layanan dan modul yang akan memberikan kemampuan untuk mengonfigurasi saat tersambung. <br><br>  Jika memungkinkan, saya akan mempersingkat kode, versi lengkap yang dapat Anda lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di komunitas Angular berbahasa Rusia di GitHub</a> . <br><br><pre> <code class="plaintext hljs">export interface WebSocketConfig { url: string; reconnectInterval?: number; reconnectAttempts?: number; } export class WebsocketModule { public static config(wsConfig: WebSocketConfig): ModuleWithProviders { return { ngModule: WebsocketModule, providers: [{ provide: config, useValue: wsConfig }] }; } }</code> </pre> <br>  Selanjutnya, kita perlu menggambarkan antarmuka pesan soket web: <br><br><pre> <code class="plaintext hljs">export interface IWsMessage&lt;T&gt; { event: string; data: T; }</code> </pre> <br>  di mana <b><i>acara</i></b> adalah kuncinya, dan <b><i>data yang</i></b> diperoleh oleh kunci adalah model yang diketik. <br><br>  Antarmuka publik layanan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">export interface IWebsocketService { on&lt;T&gt;(event: string): Observable&lt;T&gt;; send(event: string, data: any): void; status: Observable&lt;boolean&gt;; }</code> </pre> <br>  Layanan memiliki bidang: <br><br><pre> <code class="plaintext hljs">//   WebSocketSubject private config: WebSocketSubjectConfig&lt;IWsMessage&lt;any&gt;&gt;; private websocketSub: SubscriptionLike; private statusSub: SubscriptionLike; // Observable    interval private reconnection$: Observable&lt;number&gt;; private websocket$: WebSocketSubject&lt;IWsMessage&lt;any&gt;&gt;; // ,      private connection$: Observer&lt;boolean&gt;; //  Observable       private wsMessages$: Subject&lt;IWsMessage&lt;any&gt;&gt;; //       private reconnectInterval: number; //    private reconnectAttempts: number; //      private isConnected: boolean; //   public status: Observable&lt;boolean&gt;;</code> </pre> <br>  Di konstruktor dari kelas layanan, kami mendapatkan objek WebSocketConfig ditentukan ketika modul terhubung: <br><br><pre> <code class="plaintext hljs">constructor(@Inject(config) private wsConfig: WebSocketConfig) { this.wsMessages$ = new Subject&lt;IWsMessage&lt;any&gt;&gt;(); //  ,  ,     this.reconnectInterval = wsConfig.reconnectInterval || 5000; this.reconnectAttempts = wsConfig.reconnectAttempts || 10; //      connection$   websocket$ this.config = { url: wsConfig.url, closeObserver: { next: (event: CloseEvent) =&gt; { this.websocket$ = null; this.connection$.next(false); } }, //     connection$ openObserver: { next: (event: Event) =&gt; { console.log('WebSocket connected!'); this.connection$.next(true); } } }; // connection status this.status = new Observable&lt;boolean&gt;((observer) =&gt; { this.connection$ = observer; }).pipe(share(), distinctUntilChanged()); //      this.statusSub = this.status .subscribe((isConnected) =&gt; { this.isConnected = isConnected; if (!this.reconnection$ &amp;&amp; typeof(isConnected) === 'boolean' &amp;&amp; !isConnected) { this.reconnect(); } }); // ,  -    this.websocketSub = this.wsMessages$.subscribe( null, (error: ErrorEvent) =&gt; console.error('WebSocket error!', error) ); //  this.connect(); }</code> </pre> <br>  Metode koneksi itu sendiri sederhana: <br><br><pre> <code class="plaintext hljs">private connect(): void { this.websocket$ = new WebSocketSubject(this.config); //  //   ,    , //  ,  // ,    this.websocket$.subscribe( (message) =&gt; this.wsMessages$.next(message), (error: Event) =&gt; { if (!this.websocket$) { // run reconnect if errors this.reconnect(); } }); }</code> </pre> <br>  Sambung kembali sedikit lebih rumit: <br><br><pre> <code class="plaintext hljs">private reconnect(): void { //  interval    reconnectInterval this.reconnection$ = interval(this.reconnectInterval) .pipe(takeWhile((v, index) =&gt; index &lt; this.reconnectAttempts &amp;&amp; !this.websocket$)); //     ,        this.reconnection$.subscribe( () =&gt; this.connect(), null, () =&gt; { // Subject complete if reconnect attemts ending this.reconnection$ = null; if (!this.websocket$) { this.wsMessages$.complete(); this.connection$.complete(); } }); }</code> </pre> <br>  Metode <b><i>on</i></b> , juga sangat sederhana, tidak ada yang bisa dikomentari. <br><br><pre> <code class="plaintext hljs">public on&lt;T&gt;(event: string): Observable&lt;T&gt; { if (event) { return this.wsMessages$.pipe( filter((message: IWsMessage&lt;T&gt;) =&gt; message.event === event), map((message: IWsMessage&lt;T&gt;) =&gt; message.data) ); } }</code> </pre> <br>  Metode <b><i>kirim</i></b> bahkan lebih sederhana: <br><br><pre> <code class="plaintext hljs">public send(event: string, data: any = {}): void { if (event &amp;&amp; this.isConnected) { //   any ,   ""   string //      :) this.websocket$.next(&lt;any&gt;JSON.stringify({ event, data })); } else { console.error('Send error!'); } }</code> </pre> <br>  Itu seluruh layanan.  Seperti yang Anda lihat, sebagian besar kode jatuh pada organisasi koneksi ulang. <br><br>  Sekarang mari kita lihat bagaimana menggunakannya.  Hubungkan modul WebsocketModule: <br><br><pre> <code class="plaintext hljs">imports: [ WebsocketModule.config({ url: environment.ws //      'ws://www.example.com' }) ]</code> </pre> <br>  Dalam konstruktor komponen, kami menyuntikkan layanan dan berlangganan pesan dari ' <b><i>pesan</i></b> ', mengirim teks kembali ke server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private wsService: WebsocketService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.on&lt;IMessage[]&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'messages'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages: IMessage[]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.send(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Text!'</span></span>); }); }</code> </pre> <br>  Nama peristiwa lebih mudah untuk dimasukkan ke dalam konstanta atau enumerasi.  Kami membuat suatu tempat file websocket.events.ts dan menuliskannya di dalamnya: <br><br><pre> <code class="plaintext hljs">export const WS = { ON: { MESSAGES: 'messages' }, SEND: { TEXT: 'text' } };</code> </pre> <br>  Menulis ulang langganan menggunakan objek WS yang dibuat: <br><br><pre> <code class="plaintext hljs">this.wsService.on&lt;IMessage[]&gt;(WS.ON.MESSAGES) .subscribe((messages: IMessage[]) =&gt; { console.log(messages); this.wsService.send(WS.SEND.TEXT, 'Test Text!'); });</code> </pre> <br><img src="https://habrastorage.org/webt/zn/jz/k7/znjzk75iy2uudtgep2wr4u8djmk.jpeg" alt="gambar"><br><br><h2>  Kesimpulannya </h2><br>  Faktanya, itu saja.  Ini adalah minimum yang perlu diketahui oleh pengembang Angular tentang WebSockets.  Saya harap saya telah membahas topik ini dengan cukup jelas.  Versi lengkap dari layanan ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  Untuk semua pertanyaan, Anda dapat menghubungi di komentar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kepada saya</a> di Telegram atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran Angular</a> di tempat yang sama. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416155/">https://habr.com/ru/post/id416155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416143/index.html">Buku "Otopsi akan ditampilkan!" Analisis malware praktis ¬ª</a></li>
<li><a href="../id416147/index.html">Organisasi navigasi di iOS-aplikasi menggunakan Root Controller</a></li>
<li><a href="../id416149/index.html">Pertanyaan dan Jawaban Energi Terbarukan, Bagian 1</a></li>
<li><a href="../id416151/index.html">Balon tanpa dimensi. Sihir Analisis Dimensi Utilitarian</a></li>
<li><a href="../id416153/index.html">Akankah pesawat terbang menjadi lebih andal? Pabrikan pesawat terbang memperkenalkan robot ke perusahaan</a></li>
<li><a href="../id416157/index.html">Di lengan Python (khusus wanita)</a></li>
<li><a href="../id416159/index.html">Bagaimana kami ditugaskan membandingkan landak dengan ular</a></li>
<li><a href="../id416161/index.html">10 alasan [tidak] menggunakan k8s</a></li>
<li><a href="../id416163/index.html">Pelajari OpenGL. Pelajaran 5.6 - Pemetaan Parallax</a></li>
<li><a href="../id416167/index.html">Peter Norwig: Belajar Pemrograman dalam ... 10 Tahun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>