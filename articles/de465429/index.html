<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÑ üöæ üê≤ Dennoch ist C eine einfache Sprache üï¥üèø ‚§µÔ∏è üèáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten zehn Jahren seit dem Aufkommen der C-Sprache wurden viele interessante Programmiersprachen erstellt. Einige von ihnen werden immer noch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dennoch ist C eine einfache Sprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/465429/"><p><img src="https://habrastorage.org/webt/0w/1l/ey/0w1leycdhljvvpoqezgzueoho8a.jpeg"></p><br><p>  In den letzten zehn Jahren seit dem Aufkommen der C-Sprache wurden viele interessante Programmiersprachen erstellt.  Einige von ihnen werden immer noch verwendet, andere haben die n√§chste Generation von Sprachen beeinflusst, die Popularit√§t der dritten hat leise nachgelassen.  Inzwischen archaisch, kontrovers, primitiv, in den schlimmsten Traditionen seiner Generation von C-Sprachen (und seinen Erben) lebendiger als alle Lebewesen. </p><br><p>  Kritik C ist ein klassisches Briefgenre f√ºr unsere Branche.  Es klingt lauter, dann leiser, aber in letzter Zeit war es buchst√§blich atemberaubend.  Ein Beispiel ist eine √úbersetzung von David Ciswells Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûC ist keine niedrige Sprache‚Äú,</a> der vor einiger Zeit in unserem Blog ver√∂ffentlicht wurde.  Man kann verschiedene Dinge √ºber C sagen, es gibt wirklich viele unangenehme Fehler in der Gestaltung der Sprache, aber C auf der "niedrigen Ebene" abzulehnen ist zu viel! </p><br><p>  Um eine solche Ungerechtigkeit nicht zu tolerieren, nahm ich Mut und versuchte zu entscheiden, was eine Programmiersprache auf niedriger Ebene ist und welche Praktiken sie von ihr wollten. Danach ging ich die Argumente der Kritiker C durch. So stellte sich dieser Artikel heraus. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kritik Argumente C.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Low-Level-Programmiersprache</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es geht nicht nur um PDP-11</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung von Compilern und Low-Level-Sprache</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard als absolutes Gut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alternative Architekturen - Spezialcomputer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C wird leben</a> </li></ul><br><h1 id="argumenty-kritikov-c">  Kritik Argumente C. </h1><br><p>  Hier sind einige der Argumente von Cs Kritikern, einschlie√ülich der in einem Artikel von David Chiznell aufgef√ºhrten: </p><br><ol><li>  Die abstrakte C-Sprachmaschine ist der veralteten PDP-11-Architektur zu √§hnlich, die l√§ngst nicht mehr dem Design beliebter moderner Prozessoren entspricht. </li><li> Die Nicht√ºbereinstimmung zwischen einer abstrakten Maschine und dem Ger√§t realer Maschinen erschwert die Entwicklung der Optimierung von Sprachcompilern. </li><li>  Die Unvollst√§ndigkeit und Komplexit√§t des Sprachstandards f√ºhrt zu Diskrepanzen bei Standardimplementierungen. </li><li>  Die Dominanz von C-√§hnlichen Sprachen erlaubt es nicht, alternative Prozessorarchitekturen zu untersuchen. </li></ol><br><p>  Lassen Sie uns zun√§chst die Anforderungen f√ºr eine einfache Sprache ermitteln und anschlie√üend zu den angegebenen Argumenten zur√ºckkehren. </p><br><h1 id="yazyk-programmirovaniya-nizkogo-urovnya">  Low-Level-Programmiersprache </h1><br><p>  Es gibt keine allgemein akzeptierte Definition einer niedrigen Sprache.  Bevor jedoch kontroverse Fragen er√∂rtert werden, ist es w√ºnschenswert, zumindest einige anf√§ngliche Anforderungen f√ºr das Streitgegenstand zu haben. </p><br><p>  Niemand wird argumentieren, dass die Assemblersprache auf der niedrigsten Ebene ist.  Auf jeder Plattform ist es jedoch einzigartig, sodass Code in einer solchen Sprache nicht portierbar sein kann.  Selbst auf einer abw√§rtskompatiblen Plattform m√ºssen Sie m√∂glicherweise einige neue Anweisungen verwenden. </p><br><p>  Ab hier folgt die erste Anforderung f√ºr eine <em>einfache</em> Sprache: Sie sollte <em>gemeinsame Funktionen f√ºr g√§ngige Plattformen</em> beibehalten.  Einfach ausgedr√ºckt muss der Compiler portabel sein.  Die Portabilit√§t des Compilers vereinfacht die Entwicklung von Sprachcompilern f√ºr neue Plattformen, und die Vielzahl der von Compilern unterst√ºtzten Plattformen macht es f√ºr Entwickler √ºberfl√ºssig, Anwendungsprogramme f√ºr jeden neuen Computer neu zu schreiben. </p><br><p>  Die erste Anforderung widerspricht den W√ºnschen der Entwickler spezieller Programme: Programmiersprachen, Treiber, Betriebssysteme und Hochleistungsdatenbanken.  Die Programmierer, die diese Programme schreiben, m√∂chten in der Lage sein, manuell zu optimieren, direkt mit dem Speicher zu arbeiten und so weiter.  Kurz gesagt, eine einfache Sprache <em>sollte es erm√∂glichen, mit den Details der Implementierung der Plattform zu arbeiten</em> . </p><br><p>  Ein Gleichgewicht zwischen diesen beiden Anforderungen zu finden - plattform√ºbergreifende Aspekte zu identifizieren und auf so viele Details wie m√∂glich zuzugreifen - ist ein grundlegender Grund f√ºr die Schwierigkeit, eine einfache Sprache zu entwickeln. </p><br><p>  Beachten Sie, dass Abstraktionen auf hoher Ebene f√ºr eine solche Sprache nicht so wichtig sind - es ist wichtiger, dass sie als Vertrag zwischen der Plattform, dem Compiler und dem Entwickler dient.  Und wenn es einen Vertrag gibt, ist eine Sprache erforderlich, <em>die vom jeweiligen Implementierungsstandard unabh√§ngig ist</em> . </p><br><p>  Unsere erste Anforderung - Funktionen, die Zielplattformen gemeinsam haben - wird in einer abstrakten Sprachmaschine ausgedr√ºckt. Daher beginnen wir die Diskussion mit C. </p><br><h1 id="delo-ne-tolko-v-pdp-11">  Es geht nicht nur um PDP-11 </h1><br><p>  Die Plattform, auf der die C-Sprache erschien, ist PDP-11.  Es basiert auf der traditionellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Neumann-Architektur</a> , bei der die Programme nacheinander vom Zentralprozessor ausgef√ºhrt werden und der Speicher ein Flachband ist, auf dem sowohl die Daten als auch die Programme gespeichert sind.  Eine solche Architektur l√§sst sich leicht in Hardware implementieren, und im Laufe der Zeit wurde sie von allen Allzweckcomputern verwendet. </p><br><p>  Moderne Verbesserungen der von Neumann-Architektur zielen darauf ab, den Hauptengpass zu beseitigen - Verz√∂gerungen beim Datenaustausch zwischen Prozessor und Speicher (englischer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Neuman-Engpass</a> ).  Der Unterschied in der Speicher- und CPU-Leistung f√ºhrte zum Auftreten von Caching-Subsystemen von Prozessoren (einstufig und sp√§ter mehrstufig). </p><br><p>  Aber selbst Caches reichen heutzutage nicht mehr aus.  Moderne Prozessoren sind superskalar geworden.  Verz√∂gerungen, wenn Befehle Daten aus dem Speicher empfangen, werden teilweise durch die au√üergew√∂hnliche Ausf√ºhrung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallelit√§t auf Befehlsebene</a> ) der Befehle in Verbindung mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verzweigungspr√§diktor kompensiert</a> . </p><br><p>  Die sequentielle abstrakte Maschine C (und viele andere Sprachen) imitiert die Arbeit nicht so sehr spezifisch von PDP-11, sondern von Computern, die nach dem Prinzip der von Neumann-Architektur angeordnet sind.  Es enth√§lt Architekturen, die auf Prozessoren mit einem einzigen Kern basieren: Desktop und Server x86, Mobile ARM, die aus der Szene von Sun / Oracle SPARC und IBM POWER stammen. </p><br><p>  Im Laufe der Zeit wurden mehrere Prozessorkerne in einen Prozessor integriert, wodurch es notwendig wurde, die Koh√§renz der Caches jedes Kerns aufrechtzuerhalten und interne Interaktionsprotokolle zu erfordern.  Die Von-Neumann-Architektur wurde daher auf mehrere Kerne skaliert. </p><br><p>  Die urspr√ºngliche Version der abstrakten Maschine C war sequentiell und spiegelte nicht das Vorhandensein von Programmausf√ºhrungsthreads wider, die √ºber den Speicher interagieren.  Das Erscheinen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speichermodells</a> im Standard erweiterte die F√§higkeiten der abstrakten Maschine auf Parallelit√§t. </p><br><p>  Die Behauptung, dass die abstrakte C-Maschine seit langem nicht mehr mit der Struktur moderner Prozessoren vereinbar ist, betrifft nicht so sehr eine bestimmte Sprache, sondern Computer, die die von Neumann-Architektur verwenden, auch in paralleler Ausf√ºhrung. </p><br><p>  Als Praktiker m√∂chte ich jedoch Folgendes erw√§hnen: Wir k√∂nnen davon ausgehen, dass der Fonneimann-Ansatz veraltet ist, wir k√∂nnen davon ausgehen, dass er relevant ist, aber dies hebt nicht die Tatsache auf, dass die heutigen popul√§ren Allzweckarchitekturen Ableitungen der traditionellen Ans√§tze verwenden. </p><br><p>  Die standardisierte und tragbare Verk√∂rperung der von Neumann-Architektur - die abstrakte C-Maschine - ist bequem auf allen wichtigen Plattformen implementiert und erfreut sich daher zu Recht ihrer Beliebtheit als tragbarer Assembler. </p><br><h1 id="optimiziruyuschie-kompilyatory-i-yazyk-nizkogo-urovnya">  Optimierung von Compilern und Low-Level-Sprache </h1><br><p>  Unsere zweite Voraussetzung f√ºr eine Low-Level-Sprache ist der Zugriff auf die Low-Level-Implementierungsdetails jeder der g√§ngigen Plattformen.  Im Fall von C ist dies eine direkte Arbeit mit Speicher und Objekten darin als Array von Bytes, die F√§higkeit, direkt mit Byteadressen zu arbeiten, und eine erweiterte Zeigerarithmetik. </p><br><p>  C-Kritiker weisen darauf hin, dass der Sprachstandard zu viele Garantien gibt, beispielsweise hinsichtlich der Position einzelner Felder in Strukturen und Assoziationen.  Zusammen mit Zeigern und primitiven Mechanismen von Schleifen erschwert dies die Arbeit des Optimierers. </p><br><p>  In der Tat w√ºrde ein deklarativerer Ansatz es dem Compiler erm√∂glichen, die Probleme der Datenausrichtung im Speicher oder der optimalen Reihenfolge der Felder in Strukturen unabh√§ngig zu l√∂sen.  und √ºbergeordnete Zyklen bieten die Freiheit, die Sie beim Vektorisieren ben√∂tigen. </p><br><p>  Die Position der C-Entwickler ist in diesem Fall wie folgt: Eine Sprache auf niedriger Ebene sollte es erm√∂glichen, auf einer Ebene zu arbeiten, die niedrig genug ist, damit der Programmierer Optimierungsprobleme unabh√§ngig l√∂sen kann.  Innerhalb von C ist es m√∂glich, als Compiler zu arbeiten, beispielsweise SIMD-Anweisungen auszuw√§hlen und die Daten korrekt im Speicher abzulegen. </p><br><p>  Mit anderen Worten, unser Erfordernis des Zugriffs auf Implementierungsdetails jeder Plattform steht im Widerspruch zu den W√ºnschen der Entwickler, Compiler gerade aufgrund des Vorhandenseins von Tools auf niedriger Ebene zu optimieren. </p><br><p>  Interessanterweise behauptet Chiznell in einem Artikel mit dem Titel ‚ÄûC ist keine Sprache auf niedriger Ebene‚Äú paradoxerweise, dass C <em>zu</em> niedrig ist, was auf das Fehlen von Werkzeugen auf hoher Ebene hinweist.  Praktiker ben√∂tigen jedoch genau Tools auf niedriger Ebene, da die Sprache sonst nicht zur Entwicklung von Betriebssystemen und anderen Programmen auf niedriger Ebene verwendet werden kann, dh die zweite unserer Anforderungen nicht erf√ºllt. </p><br><p>  Um von der Beschreibung der Optimierungsprobleme, n√§mlich C, abzulenken, m√∂chte ich darauf hinweisen, dass derzeit nicht weniger Aufwand in die Optimierung von Compilern von Hochsprachen (das gleiche C # und Java) investiert wird als in GCC oder Clang.  Funktionale Sprachen haben auch gen√ºgend effektive Compiler: MLTon, OCaml und andere.  Aber die Entwickler desselben OCaml k√∂nnen sich bestenfalls einer Leistung r√ºhmen, die der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">halben Geschwindigkeit von C-Code entspricht</a> ... </p><br><h1 id="standart-kak-bezuslovnoe-blago">  Standard als absolutes Gut </h1><br><p>  In seinem Artikel zitiert Chiznell die Ergebnisse einer 2015 durchgef√ºhrten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umfrage</a> : Viele Programmierer haben Fehler bei der L√∂sung von Problemen beim Verst√§ndnis der C-Standards gemacht. </p><br><p>  Ich nehme an, einer der Leser hat sich mit dem C-Standard befasst. Ich habe eine Papierversion von C99, 900 Seiten Werbung. Dies ist keine lakonische Schemaspezifikation mit einem Volumen von weniger als 100 Seiten und keinem geleckten Standard-ML von 300. Arbeitsvergn√ºgen Niemand bekommt den C-Standard: weder Compiler-Entwickler noch Dokumententwickler noch Programmierer. </p><br><p>  Wir m√ºssen jedoch verstehen, dass der C-Standard nachtr√§glich entwickelt wurde, nachdem viele "fast kaum Orte" -kompatible Dialekte aufgetaucht waren.  ANSI C-Autoren haben gro√üartige Arbeit geleistet, indem sie vorhandene Implementierungen zusammengefasst und mit unz√§hligen ‚ÄûKr√ºcken‚Äú von Unorthogonalit√§t im Sprachdesign abgedeckt haben. </p><br><p>  Es mag seltsam erscheinen, dass sich jemand verpflichtet hat, ein solches Dokument zu implementieren.  Aber C wurde von vielen Compilern implementiert.  Ich werde die Geschichten anderer √ºber den Zoo der UNIX-Welt der sp√§ten 80er Jahre nicht nacherz√§hlen, zumal ich es damals selbst nicht sehr sicher und nur bis f√ºnf Uhr betrachtete.  Aber nat√ºrlich brauchte jeder in der Branche wirklich einen Standard. </p><br><p>  Das Tolle ist, dass es existiert und von mindestens drei gro√üen Compilern und vielen kleineren Compilern implementiert wird, die zusammen Hunderte von Plattformen unterst√ºtzen.  Keine der Konkurrenzsprachen C, die die Krone des K√∂nigs der niederen Sprachen beanspruchen, kann sich einer solchen Vielfalt und Vielseitigkeit r√ºhmen. </p><br><p>  Eigentlich ist der aktuelle C-Standard nicht so schlecht.  Ein mehr oder weniger erfahrener Programmierer ist in der Lage, in angemessener Zeit einen nicht optimierenden C-Compiler zu entwickeln, was durch die Existenz vieler Semi-Amateur-Implementierungen (dieselbe TCC, LCC und 8cc) best√§tigt wird. </p><br><p>  Ein allgemein anerkannter Standard bedeutet, dass C die letzte unserer Anforderungen f√ºr eine einfache Sprache erf√ºllt: Diese Sprache basiert auf einer Spezifikation, nicht auf einer bestimmten Implementierung. </p><br><h1 id="alternativnye-arhitektury---udel-specialnyh-vychisleniy">  Alternative Architekturen - Spezialcomputer </h1><br><p>  Lifewell f√ºhrt jedoch ein anderes Argument an und kehrt zum Ger√§t moderner Allzweckprozessoren zur√ºck, die von Neumann-Architekturoptionen implementieren.  Er behauptet, es sei sinnvoll, die Prinzipien des Zentralprozessors zu √§ndern.  Diese Kritik bezieht sich wiederum nicht auf C, sondern auf das grundlegendste Modell der imperativen Programmierung. </p><br><p>  In der Tat gibt es viele Alternativen zum traditionellen Ansatz mit sequentieller Ausf√ºhrung von Programmen: SIMD-Modelle im GPU-Stil, Modelle im Stil einer abstrakten Erlang-Maschine und andere.  Jeder dieser Ans√§tze ist jedoch nur begrenzt anwendbar, wenn er in einem Zentralprozessor verwendet wird. </p><br><p>  GPUs beispielsweise multiplizieren Matrizen in Spielen und beim maschinellen Lernen bemerkenswert, sind jedoch f√ºr die Raytracing-Funktion schwierig zu verwenden.  Mit anderen Worten, dieses Modell ist f√ºr spezialisierte Beschleuniger geeignet, funktioniert jedoch nicht f√ºr Allzweckprozessoren. </p><br><p>  Erlang funktioniert gut in einem Cluster, aber eine effiziente schnelle Sortierung oder schnelle Hash-Tabelle ist schwierig.  Das Modell unabh√§ngiger Akteure wird besser auf einer h√∂heren Ebene in einem gro√üen Cluster verwendet, in dem jeder Knoten immer noch dieselbe Hochleistungsmaschine mit einem herk√∂mmlichen Prozessor ist. </p><br><p>  Inzwischen haben moderne x86-kompatible Prozessoren lange Zeit eine Reihe von Vektorbefehlen enthalten, die in Zweck und Funktionsprinzipien der GPU √§hnlich sind, aber die allgemeine Prozessorschaltung im von Neumann-Stil als Ganzes beibehalten.  Ich habe keinen Zweifel daran, dass in allgemeinen Prozessoren ziemlich allgemeine Computerans√§tze enthalten sein werden. </p><br><p>  Es gibt eine so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ma√ügebliche</a> Meinung: Die Zukunft liegt in speziellen programmierbaren Beschleunigern.  Unter solch au√üergew√∂hnlichen Eisenst√ºcken ist es wirklich sinnvoll, Sprachen mit besonderer Semantik zu entwickeln.  Ein Allzweckcomputer war und ist jedoch dem PDP-11 √§hnlich, f√ºr den C-√§hnliche Imperativsprachen so gut geeignet sind. </p><br><h1 id="s-budet-zhit">  C wird leben </h1><br><p>  In Chiznells Artikel gibt es einen grunds√§tzlichen Widerspruch.  Er schreibt, dass Prozessoren die abstrakte C-Maschine (und den l√§ngst vergessenen PDP-11) nachahmen, um die Geschwindigkeit von C-Programmen sicherzustellen, woraufhin sie auf die Einschr√§nkungen einer solchen Maschine hinweisen.  Aber ich verstehe nicht, warum dies bedeutet, dass "C keine einfache Sprache ist". </p><br><p>  Im Allgemeinen geht es hier nicht um die M√§ngel von C als Sprache, sondern um Kritik an g√§ngigen Architekturen im Neumann-Stil und dem daraus folgenden Programmiermodell.  Bisher scheint die Branche jedoch nicht bereit zu sein, die bekannte Architektur aufzugeben (zumindest nicht bei Allzweckprozessoren). </p><br><p>  Trotz der Verf√ºgbarkeit vieler spezialisierter Prozessoren wie GPUs und TPUs regiert die von Neumann-Architektur derzeit den Ball und die Branche ben√∂tigt eine Sprache, die es ihr erm√∂glicht, im Rahmen der beliebtesten Architektur auf der niedrigstm√∂glichen Ebene zu arbeiten.  Eine ziemlich einfache, auf Dutzende von Plattformen portierte und standardisierte Programmiersprache ist C (und seine unmittelbare Familie). </p><br><p>  Trotzdem hat C genug M√§ngel: eine archaische Funktionsbibliothek, einen komplizierten und inkonsistenten Standard und grobe Designfehler.  Aber anscheinend haben die Sch√∂pfer der Sprache immer noch etwas richtig gemacht. </p><br><p>  Auf die eine oder andere Weise brauchen wir immer noch eine einfache Sprache, die speziell f√ºr beliebte Fonneimann-Computer entwickelt wurde.  Und lassen Sie C veraltet sein, aber anscheinend muss jeder Nachfolger immer noch auf denselben Prinzipien aufbauen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465429/">https://habr.com/ru/post/de465429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465417/index.html">Kubernetes Storage Volume Plugins: Flexvolume zu CSI</a></li>
<li><a href="../de465419/index.html">Morgen an der ITMO University: Bildungsprozess, Wettbewerbe und Bildung im Ausland - eine Auswahl anstehender Veranstaltungen</a></li>
<li><a href="../de465423/index.html">Smart Manufacturing and Industry 4.0: Drei technologische Haupttrends</a></li>
<li><a href="../de465425/index.html">Vepp - das neue Server- und Website-Kontrollfeld von ISPsystem</a></li>
<li><a href="../de465427/index.html">Analyse des Apache Dubbo RPC Frameworks mit dem PVS-Studio Static Code Analyzer</a></li>
<li><a href="../de465431/index.html">Analyse des RPC-Quellcodes des Apache Dubbo-Frameworks mit dem statischen Analysator PVS-Studio</a></li>
<li><a href="../de465433/index.html">Arbeitsroboter - gl√ºcklicher Mann</a></li>
<li><a href="../de465435/index.html">Welche Distribution ist f√ºr Ihr eingebettetes System besser geeignet?</a></li>
<li><a href="../de465437/index.html">Warum ich mich geweigert habe, in AWS zu arbeiten</a></li>
<li><a href="../de465441/index.html">LuaVela: Lua 5.1-Implementierung basierend auf LuaJIT 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>