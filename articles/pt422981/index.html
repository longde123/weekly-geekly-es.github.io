<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◽️ 🙌🏾 🤦🏿 Implementação mais simples do sistema de componentes de entidade 👩🏼‍🎓 🤣 🧑🏻‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! 

 O quarto fluxo “C ++ Developer” começa aqui, um dos cursos mais ativos em nosso país, a julgar pelas reuniões reais, onde não apenas o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementação mais simples do sistema de componentes de entidade</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/422981/">  Olá pessoal! <br><br>  O quarto fluxo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“C ++ Developer”</a> começa aqui, um dos cursos mais ativos em nosso país, a julgar pelas reuniões reais, onde não apenas os “cruzados” vêm conversar com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dima Shebordaev</a> :) Em geral, o curso já cresceu para uma das maiores do país, permanece inalterado o fato de a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dima</a> ministrar aulas abertas e selecionarmos materiais interessantes antes do início do curso. <br><br>  Vamos lá! <br><br><h3>  Entrada </h3><br>  O Sistema de Componentes de Entidades (ECS, "sistema de componentes de entidades") está agora no auge da popularidade como uma alternativa arquitetônica que enfatiza o princípio da Composição sobre a herança.  Neste artigo, não abordarei os detalhes do conceito, pois já existem recursos suficientes sobre esse tópico.  Existem várias maneiras de implementar o ECS e, mas, na maioria das vezes, escolho formas bastante complexas que podem confundir iniciantes e levar muito tempo. <br><br>  Neste post, descreverei uma maneira muito simples de implementar o ECS, cuja versão funcional requer quase nenhum código, mas segue completamente o conceito. <br><br><img src="https://habrastorage.org/webt/6s/g8/jk/6sg8jksoaekqfccdwlnma-rbz0w.png"><a name="habracut"></a><br><br><h3>  ECS </h3><br>  Falando em ECS, as pessoas geralmente significam coisas diferentes.  Quando falo sobre ECS, quero dizer um sistema que permite definir entidades que possuem zero ou mais componentes de dados puros.  Esses componentes são processados ​​seletivamente por sistemas lógicos puros.  Por exemplo, a posição, velocidade, hitbox e integridade de um componente estão vinculados à entidade E.  Eles simplesmente armazenam dados em si mesmos.  Por exemplo, um componente de integridade pode armazenar dois números inteiros: um para a integridade atual e outro para o máximo.  Um sistema pode ser um sistema de regeneração de integridade que localiza todas as instâncias de um componente de integridade e as aumenta em 1 a cada 120 quadros. <br><br><h3>  Implementação típica de C ++ </h3><br>  Existem muitas bibliotecas que oferecem implementações de ECS.  Geralmente, eles incluem um ou mais itens da lista: <br><br><ul><li> Herança do componente / sistema base da classe <code>GravitySystem : public ecs::System</code> ; </li><li>  Uso ativo de modelos; </li><li>  Tanto isso quanto outro em algum aspecto do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRTP</a> ; </li><li>  A classe <code>EntityManager</code> , que controla a criação / armazenamento de entidades de maneira implícita. </li></ul><br>  Alguns exemplos rápidos do Google: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entidade dos alectosmasx</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ECS do redxdev</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">corgi do google</a> (então eu descobri que o google tem uma implementação ECS). </li></ul><br>  Todos esses métodos têm direito à vida, mas existem algumas desvantagens neles.  A maneira como eles processam os dados de maneira opaca significa que será difícil entender o que está acontecendo lá dentro e se a desaceleração do desempenho ocorreu.  Isso também significa que você deve estudar toda a camada de abstração e garantir que ela se encaixe bem no código existente.  Não se esqueça dos bugs ocultos, que provavelmente estão muito ocultos na quantidade de código que você precisa depurar. <br><br>  Uma abordagem baseada em modelo pode afetar bastante o tempo de compilação e com que frequência você precisará reconstruir a compilação.  Embora os conceitos baseados em herança possam prejudicar o desempenho. <br><br>  A principal razão pela qual considero excessivas essas abordagens é que o problema que elas resolvem é muito simples.  No final, esses são apenas componentes de dados adicionais associados à entidade e seu processamento seletivo.  Abaixo, mostrarei uma maneira muito simples de como isso pode ser implementado. <br><br><h3>  Minha abordagem simples </h3><br>  <i>Essence</i> <br><br>  Em algumas abordagens, a classe Entity é definida; em outras, elas trabalham com entidades como ID / identificador.  Em uma abordagem de componente, uma entidade nada mais é do que os componentes associados a ela e, para isso, uma classe não é necessária.  Uma entidade existirá explicitamente com base em seus componentes relacionados.  Para fazer isso, defina: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EntityID = <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    , int64_t -  </span></span></code> </pre> <br>  <i>Componentes da entidade</i> <br><br>  Componentes são diferentes tipos de dados associados a entidades existentes.  Podemos dizer que para cada entidade e, e terá zero e mais tipos de componentes acessíveis.  Em essência, essa é uma relação de valor-chave explodida e, felizmente, existem ferramentas de biblioteca padrão na forma de cartões para isso. <br><br>  Então, eu defino os componentes da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Velocity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Health</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ComponentMap = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;EntityID, Type&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Positions = ComponentMap&lt;Position&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Velocities = ComponentMap&lt;Velocity&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Healths = ComponentMap&lt;Health&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Components</span></span></span><span class="hljs-class"> {</span></span> Positions positions; Velocities velocities; Healths healths; };</code> </pre> <br>  Isso é suficiente para indicar entidades através de componentes, conforme o esperado do ECS.  Por exemplo, para criar uma entidade com uma posição e integridade, mas sem velocidade, você precisa: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//given a Components instance c EntityID newID = /*obtain new entity ID*/; c.positions[newID] = Position{0.0f, 0.0f}; c.healths[newID] = Health{100, 100};</span></span></code> </pre><br>  Para destruir uma entidade com um determinado ID, simplesmente as <code>.erase()</code> de cada cartão. <br><br>  <i>Sistemas</i> <br><br>  O último componente que precisamos é de sistemas.  Essa é a lógica que trabalha com os componentes para obter um comportamento específico.  Como gosto de simplificar as coisas, uso funções normais.  O sistema de regeneração de saúde mencionado acima pode ser simplesmente a próxima função. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateHealthRegeneration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentFrame, Healths&amp; healths)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(currentFrame % <span class="hljs-number"><span class="hljs-number">120</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [id, health] : healths) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(health.current &lt; health.max) ++health.current; } } }</code> </pre><br>  Podemos colocar a chamada para essa função em um local apropriado no loop principal e transferi-la para o armazenamento do componente de integridade.  Como o repositório de integridade contém apenas registros para entidades que têm integridade, ele pode processá-los isoladamente.  Isso também significa que a função pega apenas os dados necessários e não toca no irrelevante. <br><br>  Mas e se o sistema funcionar com mais de um componente?  Diga um sistema físico que mude de posição com base na velocidade.  Para fazer isso, precisamos cruzar todas as chaves de todos os tipos de componentes envolvidos e iterar sobre seus valores.  Nesse ponto, a biblioteca padrão não é mais suficiente, mas escrever auxiliares não é tão difícil.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePhysics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Positions&amp; positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Velocities&amp; velocities)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,   N   //   ID,    . std::unordered_set&lt;EntityID&gt; targets = mapIntersection(positions, velocities); // target'     ,   //  ,       . for(EntityID id : targets) { Position&amp; pos = positions.at(id); const Velocity&amp; vel = velocities.at(id); pos.x += vel.x; pos.y += vel.y; } }</span></span></code> </pre> <br>  Ou você pode escrever um auxiliar mais compacto que permita acesso mais eficiente via iteração, em vez de pesquisar. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePhysics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Positions&amp; positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Velocities&amp; velocities)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,    //  .        //    . intersectionInvoke&lt;Position, Velocity&gt;(positions, velocities, [] (EntityID id, Position&amp; pos, const Velocity&amp; vel) { pos.x += vel.x; pos.y += vel.y; } ); }</span></span></code> </pre> <br>  Assim, nos familiarizamos com a funcionalidade básica de um ECS regular. <br><br><h3>  Os benefícios </h3><br>  Essa abordagem é muito eficaz, pois é criada do zero, sem restringir a abstração.  Você não precisa integrar bibliotecas externas ou adaptar a base de código às idéias predefinidas de quais entidades / componentes / sistemas devem ser. <br>  E como essa abordagem é completamente transparente, você pode criar utilitários e auxiliares.  Essa implementação cresce com as necessidades do seu projeto.  Provavelmente, para protótipos simples ou jogos para jogos jam'ov, você terá o suficiente da funcionalidade descrita acima. <br><br>  Portanto, se você é novo em todo esse campo da ECS, uma abordagem tão direta ajudará a entender as idéias principais. <br><br><h3>  Limitações </h3><br>  Mas, como em qualquer outro método, existem algumas limitações.  Na minha experiência, é precisamente essa implementação usando <code>unordered_map</code> em qualquer jogo não trivial que levará a problemas de desempenho. <br><br>  Iterar interseções de chave em várias instâncias de <code>unordered_map</code> com várias entidades não é escalável porque você está realmente pesquisando <code>N*M</code> , em que N é o número de componentes sobrepostos, M é o número de entidades correspondentes e <code>unordered_map</code> não <code>unordered_map</code> muito bom em cache.  Esse problema pode ser corrigido usando um armazenamento de valores-chave mais adequado para iteração, em vez de <code>unordered_map</code> . <br><br>  Outra limitação é a caldeira.  Dependendo do que você faz, identificar novos componentes pode se tornar tedioso.  Pode ser necessário adicionar um anúncio não apenas na estrutura de componentes, mas também na função de geração, serialização, utilitário de depuração etc.  Eu me deparei com isso sozinho e resolvi o problema gerando código - defini componentes em arquivos json externos e, em seguida, gerei componentes C ++ e funções auxiliares no estágio de construção.  Tenho certeza de que você pode encontrar outros métodos baseados em modelos para corrigir quaisquer problemas que você encontrar. <br><br>  O FIM <br><br>  Se você tiver perguntas e comentários, pode deixá-los aqui ou ir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma aula aberta</a> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dima</a> , ouvi-lo e perguntar por aí. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt422981/">https://habr.com/ru/post/pt422981/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt422969/index.html">Anomalia de Frango, Outset</a></li>
<li><a href="../pt422971/index.html">Sistema especialista em Rails</a></li>
<li><a href="../pt422973/index.html">Anatomia de um incidente ou como trabalhar para reduzir o tempo de inatividade</a></li>
<li><a href="../pt422977/index.html">Mikhail Bessmeltsev e seu colega desenvolveram novos algoritmos para vetorização de gráficos</a></li>
<li><a href="../pt422979/index.html">Análogo americano do GDPR: o que você precisa saber sobre o CCPA</a></li>
<li><a href="../pt422985/index.html">Início rápido de um projeto web (BE - Java Spring, FE - React Redux, interação - Rest, WebSocket)</a></li>
<li><a href="../pt422987/index.html">E, novamente, o 256º dia do ano</a></li>
<li><a href="../pt422989/index.html">Um banco de dados não é apenas um armazém de dados</a></li>
<li><a href="../pt422993/index.html">Gravando TVs OLED em testes reais</a></li>
<li><a href="../pt422995/index.html">Meta de controle de qualidade em Redmadrobot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>