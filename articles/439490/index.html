<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèæ üßúüèº üçÇ Tipos de referencia .NET vs Tipos de valor. Parte 2 üïµüèΩ üßëüèæ‚Äçü§ù‚Äçüßëüèª üë≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El tipo base del objeto y la implementaci√≥n de interfaces. Boxeo 


 Parece que pasamos por el infierno y el apogeo y podemos concretar cualquier entr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de referencia .NET vs Tipos de valor. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439490/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="the-object-base-type-and-implementation-of-interfaces-boxing">  El tipo base del objeto y la implementaci√≥n de interfaces.  Boxeo </h2><br><p>  Parece que pasamos por el infierno y el apogeo y podemos concretar cualquier entrevista, incluso la del equipo .NET CLR.  Sin embargo, no nos apresuremos a microsoft.com y busquemos vacantes.  Ahora, debemos comprender c√≥mo los tipos de valores heredan un objeto si no contienen una referencia a SyncBlockIndex, ni un puntero a una tabla de m√©todos virtuales.  Esto explicar√° completamente nuestro sistema de tipos y todas las piezas de un rompecabezas encontrar√°n su lugar.  Sin embargo, necesitaremos m√°s de una oraci√≥n. </p><br><p>  Ahora, recordemos nuevamente c√≥mo se asignan los tipos de valor en la memoria.  Obtienen el lugar en la memoria justo donde est√°n.  Los tipos de referencia obtienen asignaci√≥n en el mont√≥n de objetos peque√±os y grandes.  Siempre dan una referencia al lugar en el mont√≥n donde est√° el objeto.  Cada tipo de valor tiene m√©todos como ToString, Equals y GetHashCode.  Son virtuales y reemplazables, pero no permiten heredar un tipo de valor anulando m√©todos.  Si los tipos de valor usaran m√©todos reemplazables, necesitar√≠an una tabla de m√©todos virtuales para enrutar las llamadas.  Esto llevar√≠a a los problemas de pasar estructuras al mundo no administrado: campos adicionales ir√≠an all√≠.  Como resultado, hay descripciones de m√©todos de tipo de valor en alguna parte, pero no puede acceder a ellos directamente a trav√©s de una tabla de m√©todos virtuales. </p><br><p>  Esto puede traer la idea de que la falta de herencia es artificial </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Esto puede traer la idea de que la falta de herencia es artificial: </p><br><ul><li>  hay herencia de un objeto, pero no directo; </li><li> hay ToString, Equals y GetHashCode dentro de un tipo base.  En los tipos de valor, estos m√©todos tienen su propio comportamiento.  Esto significa que los m√©todos se anulan en relaci√≥n con un <code>object</code> ; </li><li>  Adem√°s, si lanza un tipo a un <code>object</code> , tiene todo el derecho de llamar a ToString, Equals y GetHashCode; </li><li>  Al llamar a un m√©todo de instancia para un tipo de valor, el m√©todo obtiene otra estructura que es una copia de un original.  Eso significa que llamar a un m√©todo de instancia es como llamar a un m√©todo est√°tico: <code>Method(ref structInstance, newInternalFieldValue)</code> .  De hecho, esta llamada pasa <code>this</code> , sin embargo, con una excepci√≥n.  Un JIT debe compilar el cuerpo de un m√©todo, por lo que ser√≠a innecesario compensar los campos de estructura, saltando sobre el puntero a una tabla de m√©todos virtuales, que no existe en la estructura.  <em>Existe para los tipos de valor en otro lugar</em> . </li></ul><br><p>  Los tipos son diferentes en el comportamiento, pero esta diferencia no es tan grande en el nivel de implementaci√≥n en el CLR.  Hablaremos de eso un poco m√°s tarde. </p><br><p>  Escribamos la siguiente l√≠nea en nuestro programa: </p><br><pre> <code class="plaintext hljs">var obj = (object)10;</code> </pre> <br><p>  Nos permitir√° tratar con el n√∫mero 10 usando una clase base.  Esto se llama boxeo.  Eso significa que tenemos un VMT para llamar a m√©todos virtuales como ToString (), Equals y GetHashCode.  En realidad, el boxeo crea una copia de un tipo de valor, pero no un puntero a un original.  Esto se debe a que podemos almacenar el valor original en todas partes: en la pila o como un campo de una clase.  Si lo convertimos en un tipo de objeto, podemos almacenar una referencia a este valor todo el tiempo que queramos.  Cuando ocurre el boxeo: </p><br><ul><li>  CLR asigna espacio en el mont√≥n para una estructura + SyncBlockIndex + VMT de un tipo de valor (para llamar a ToString, GetHashCode, Equals); </li><li>  copia una instancia de un tipo de valor all√≠. </li></ul><br><p>  Ahora, tenemos una variante de referencia de un tipo de valor.  Una estructura tiene <strong>absolutamente el mismo conjunto de campos del sistema que un tipo de referencia</strong> , <br>  convirti√©ndose en un tipo de referencia completo despu√©s del boxeo.  La estructura se convirti√≥ en una clase.  Llam√©moslo un salto mortal .NET.  Este es un nombre justo. </p><br><p>  Solo observe lo que sucede si usa una estructura que implementa una interfaz que usa la misma interfaz. </p><br><pre> <code class="plaintext hljs">struct Foo : IBoo { int x; void Boo() { x = 666; } } IBoo boo = new Foo(); boo.Boo();</code> </pre> <br><p>  Cuando creamos la instancia de Foo, su valor va de hecho a la pila.  Luego colocamos esta variable en una variable de tipo de interfaz y la estructura en una variable de tipo de referencia.  Luego, hay boxeo y tenemos el tipo de objeto como salida.  Pero es una variable de tipo de interfaz.  Eso significa que necesitamos conversi√≥n de tipo.  Entonces, la llamada ocurre de esta manera: </p><br><pre> <code class="plaintext hljs">IBoo boo = (IBoo)(box_to_object)new Foo(); boo.Boo();</code> </pre> <br><p>  Escribir dicho c√≥digo no es efectivo.  Tendr√° que cambiar una copia en lugar de un original: </p><br><pre> <code class="plaintext hljs">void Main() { var foo = new Foo(); foo.a = 1; Console.WriteLite(foo.a); // -&gt; 1 IBoo boo = foo; boo.Boo(); // looks like changing foo.a to 10 Console.WriteLite(foo.a); // -&gt; 1 } struct Foo: IBoo { public int a; public void Boo() { a = 10; } } interface IBoo { void Boo(); }</code> </pre> <br><p>  La primera vez que miramos el c√≥digo, no tenemos que saber a qu√© nos enfrentamos en el c√≥digo que <em>no sea el nuestro</em> y ver una interfaz de conversi√≥n a IBoo.  Esto nos hace pensar que Foo es una clase y no una estructura.  Entonces no hay divisi√≥n visual en las estructuras y clases, lo que nos hace pensar que <br>  los resultados de la modificaci√≥n de la interfaz deben entrar en foo, lo que no sucede porque boo es una copia de foo.  Eso es enga√±oso.  En mi opini√≥n, este c√≥digo deber√≠a recibir comentarios, para que otros desarrolladores puedan lidiar con √©l. </p><br><p>  La segunda cosa se relaciona con los pensamientos previos de que podemos lanzar un tipo de un objeto a IBoo.  Esta es otra prueba de que un tipo de valor en caja es una variante de referencia de un tipo de valor.  O bien, todos los tipos en un sistema de tipos son tipos de referencia.  Simplemente podemos trabajar con estructuras como con tipos de valor, pasando su valor por completo.  Desreferenciar un puntero a un objeto como dir√≠a en el mundo de C ++. </p><br><p>  Puede objetar que si fuera cierto, se ver√≠a as√≠: </p><br><pre> <code class="plaintext hljs">var referenceToInteger = (IInt32)10;</code> </pre> <br><p>  Obtendr√≠amos no solo un objeto, sino una referencia escrita para un tipo de valor encuadrado.  Destruir√≠a toda la idea de los tipos de valor (es decir, la integridad de su valor) permitiendo una gran optimizaci√≥n, basada en sus propiedades.  ¬°Eliminemos esta idea! </p><br><pre> <code class="plaintext hljs">public sealed class Boxed&lt;T&gt; { public T Value; [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) { return Value.Equals(obj); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() { return Value.ToString(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() { return Value.GetHashCode(); } }</code> </pre> <br><p>  Tenemos un an√°logo completo del boxeo.  Sin embargo, podemos cambiar su contenido llamando a m√©todos de instancia.  Estos cambios afectar√°n a todas las partes con referencia a esta estructura de datos. </p><br><pre> <code class="plaintext hljs">var typedBoxing = new Boxed&lt;int&gt; { Value = 10 }; var pureBoxing = (object)10;</code> </pre> <br><p>  La primera variante no es muy atractiva.  En lugar de lanzar un tipo, creamos tonter√≠as.  La segunda l√≠nea es mucho mejor, pero las dos l√≠neas son casi id√©nticas.  La √∫nica diferencia es que no hay limpieza de memoria con ceros durante el boxeo habitual despu√©s de asignar memoria en el mont√≥n.  La estructura necesaria lleva la memoria de inmediato, mientras que la primera variante necesita limpieza.  Esto hace que funcione m√°s tiempo que el boxeo habitual en un 10%. </p><br><p>  En cambio, podemos llamar a algunos m√©todos para nuestro valor en caja. </p><br><pre> <code class="plaintext hljs">struct Foo { public int x; public void ChangeTo(int newx) { x = newx; } } var boxed = new Boxed&lt;Foo&gt; { Value = new Foo { x = 5 } }; boxed.Value.ChangeTo(10); var unboxed = boxed.Value;</code> </pre> <br><p>  Tenemos un nuevo instrumento.  Pensemos qu√© podemos hacer con √©l. </p><br><ul><li>  Nuestro tipo <code>Boxed&lt;T&gt;</code> hace lo mismo que el tipo habitual: asigna memoria en el mont√≥n, pasa un valor all√≠ y permite obtenerlo, haciendo una especie de unbox; </li><li>  Si pierde una referencia a una estructura en caja, el GC la recopilar√°; </li><li>  Sin embargo, ahora podemos trabajar con un tipo en caja, es decir, llamando a sus m√©todos; </li><li>  Adem√°s, podemos reemplazar una instancia de un tipo de valor en SOH / LOH por otra.  No pod√≠amos hacerlo antes, ya que tendr√≠amos que hacer unboxing, cambiar la estructura a otra y volver a boxear, dando una nueva referencia a los clientes. </li></ul><br><p>  El principal problema del boxeo es crear tr√°fico en la memoria.  El tr√°fico de un n√∫mero desconocido de objetos, cuya parte puede sobrevivir hasta la generaci√≥n uno, donde tenemos problemas con la recolecci√≥n de basura.  Habr√° mucha basura y podr√≠amos haberla evitado.  Pero cuando tenemos el tr√°fico de objetos de corta duraci√≥n, la primera soluci√≥n es la agrupaci√≥n.  Este es un final ideal de .NET somersault. </p><br><pre> <code class="plaintext hljs">var pool = new Pool&lt;Boxed&lt;Foo&gt;&gt;(maxCount:1000); var boxed = pool.Box(10); boxed.Value=70; // use boxed value here pool.Free(boxed);</code> </pre> <br><p>  Ahora el boxeo puede funcionar utilizando un grupo, lo que elimina el tr√°fico de memoria durante el boxeo.  Incluso podemos hacer que los objetos vuelvan a la vida en el m√©todo de finalizaci√≥n y volver a colocarse en el grupo.  Esto puede ser √∫til cuando una estructura en caja va a un c√≥digo asincr√≥nico que no sea el suyo y no puede entender cu√°ndo se volvi√≥ innecesario.  En este caso, volver√° a la agrupaci√≥n durante el GC. </p><br><p>  Vamos a concluir: </p><br><ul><li>  Si el boxeo es accidental y no deber√≠a suceder, no lo haga.  Puede conducir a problemas con el rendimiento. </li><li>  Si el boxeo es necesario para la arquitectura de un sistema, puede haber variantes.  Si el tr√°fico de estructuras en caja es peque√±o y casi invisible, puede usar el boxeo.  Si el tr√°fico es visible, es posible que desee agrupar el boxeo, utilizando una de las soluciones indicadas anteriormente.  Gasta algunos recursos, pero hace que GC funcione sin sobrecarga; </li></ul><br><p>  Finalmente, veamos un c√≥digo totalmente poco pr√°ctico: </p><br><pre> <code class="plaintext hljs">static unsafe void Main() { // here we create boxed int object boxed = 10; // here we get the address of a pointer to a VMT var address = (void**)EntityPtr.ToPointerWithOffset(boxed); unsafe { // here we get a Virtual Methods Table address var structVmt = typeof(SimpleIntHolder).TypeHandle.Value.ToPointer(); // change the VMT address of the integer passed to Heap into a VMT SimpleIntHolder, turning Int into a structure *address = structVmt; } var structure = (IGetterByInterface)boxed; Console.WriteLine(structure.GetByInterface()); } interface IGetterByInterface { int GetByInterface(); } struct SimpleIntHolder : IGetterByInterface { public int value; int IGetterByInterface.GetByInterface() { return value; } }</code> </pre> <br><p>  El c√≥digo usa una funci√≥n peque√±a, que puede obtener un puntero de una referencia a un objeto.  La biblioteca est√° disponible en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">direcci√≥n de github</a> .  Este ejemplo muestra que el boxeo habitual convierte int en un tipo de referencia escrito.  Vamos <br>  mira los pasos en el proceso: </p><br><ol><li>  Hacer boxeo para un n√∫mero entero. </li><li>  Obtener la direcci√≥n de un objeto obtenido (la direcci√≥n de Int32 VMT) </li><li>  Obtenga el VMT de un SimpleIntHolder </li><li>  Reemplace la VMT de un entero en caja por la VMT de una estructura. </li><li>  Convertir unboxing en un tipo de estructura </li><li>  Mostrar el valor del campo en la pantalla, obteniendo el Int32, que era <br>  en caja </li></ol><br><p>  Lo hago a trav√©s de la interfaz a prop√≥sito, ya que quiero mostrar que funcionar√° <br>  de esa manera </p><br><h3 id="nullablet">  Anulable \ &lt;T&gt; </h3><br><p>  Vale la pena mencionar sobre el comportamiento del boxeo con tipos de valores anulables.  Esta caracter√≠stica de los tipos de valores anulables es muy atractiva ya que el boxeo de un tipo de valor que es una especie de nulo devuelve nulo. </p><br><pre> <code class="plaintext hljs">int? x = 5; int? y = null; var boxedX = (object)x; // -&gt; 5 var boxedY = (object)y; // -&gt; null</code> </pre> <br><p>  Esto nos lleva a una conclusi√≥n peculiar: como nulo no tiene un tipo, el <br>  La √∫nica forma de obtener un tipo, diferente del cuadro, es la siguiente: </p><br><pre> <code class="plaintext hljs">int? x = null; var pseudoBoxed = (object)x; double? y = (double?)pseudoBoxed;</code> </pre> <br><p>  El c√≥digo funciona solo porque puedes convertir un tipo a lo que quieras <br>  con nulo </p><br><h2 id="going-deeper-in-boxing">  Profundizando en el boxeo </h2><br><p>  Como √∫ltimo comentario, me gustar√≠a contarles sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo System.Enum</a> .  L√≥gicamente, este deber√≠a ser un tipo de valor, ya que es una enumeraci√≥n habitual: alias de n√∫meros a nombres en un lenguaje de programaci√≥n.  Sin embargo, System.Enum es un tipo de referencia.  Todos los tipos de datos de enumeraci√≥n, definidos en su campo, as√≠ como en .NET Framework, se heredan de System.Enum.  Es un tipo de datos de clase.  Adem√°s, es una clase abstracta, heredada de <code>System.ValueType</code> . </p><br><pre> <code class="plaintext hljs"> [Serializable] [System.Runtime.InteropServices.ComVisible(true)] public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible { // ... }</code> </pre> <br><p>  ¬øSignifica que todas las enumeraciones se asignan en el SOH y cuando las usamos, sobrecargamos el mont√≥n y el GC?  En realidad no, ya que solo los usamos.  Luego, suponemos que hay un grupo de enumeraciones en alg√∫n lugar y solo obtenemos sus instancias.  No otra vez  Puede usar enumeraciones en estructuras durante el c√°lculo de referencias.  Las enumeraciones son n√∫meros habituales. </p><br><p>  La verdad es que CLR piratea la estructura de tipo de datos al formarla si hay una enumeraci√≥n que <a href="">convierte una clase en un tipo de valor</a> : </p><br><pre> <code class="plaintext hljs">// Check to see if the class is a valuetype; but we don't want to mark System.Enum // as a ValueType. To accomplish this, the check takes advantage of the fact // that System.ValueType and System.Enum are loaded one immediately after the // other in that order, and so if the parent MethodTable is System.ValueType and // the System.Enum MethodTable is unset, then we must be building System.Enum and // so we don't mark it as a ValueType. if(HasParent() &amp;&amp; ((g_pEnumClass != NULL &amp;&amp; GetParentMethodTable() == g_pValueTypeClass) || GetParentMethodTable() == g_pEnumClass)) { bmtProp-&gt;fIsValueClass = true; HRESULT hr = GetMDImport()-&gt;GetCustomAttributeByName(bmtInternal-&gt;pType-&gt;GetTypeDefToken(), g_CompilerServicesUnsafeValueTypeAttribute, NULL, NULL); IfFailThrow(hr); if (hr == S_OK) { SetUnsafeValueClass(); } }</code> </pre> <br><p>  ¬øPor qu√© hacer esto?  En particular, debido a la idea de herencia: hacer una enumeraci√≥n personalizada, por ejemplo, debe especificar los nombres de los posibles valores.  Sin embargo, es imposible heredar los tipos de valor.  Por lo tanto, los desarrolladores lo dise√±aron para ser un tipo de referencia que puede convertirlo en un tipo de valor cuando se compila. </p><br><h2 id="what-if-you-want-to-see-boxing-personally">  ¬øQu√© pasa si quieres ver el boxeo personalmente? </h2><br><p>  Afortunadamente, no tiene que usar un desensamblador y entrar en la jungla de c√≥digos.  Tenemos los textos de todo el n√∫cleo de la plataforma .NET y muchos de ellos son id√©nticos en t√©rminos de .NET Framework CLR y CoreCLR.  Puede hacer clic en los enlaces a continuaci√≥n y ver la implementaci√≥n del boxeo de inmediato: </p><br><ul><li>  Hay un grupo separado de optimizaciones, cada una de las cuales utiliza un <br>  tipo espec√≠fico de procesador: <br><ul><li>  <em><a href="">JIT_BoxFastMP_InlineGetThread</a></em> <br>  (AMD64 - multiprocesador o servidor GC, almacenamiento local de subprocesos impl√≠cito) </li><li>  <em><a href="">JIT_BoxFastMP</a></em> <br>  (AMD64 - multiprocesador o servidor GC) </li><li>  <em><a href="">JIT_BoxFastUP</a></em> <br>  (AMD64 - procesador √∫nico o estaci√≥n de trabajo GC) </li><li>  <em><a href="">JIT_TrialAlloc :: GenBox (..)</a></em> <br>  (x86) conectado a trav√©s de JitHelpers </li></ul></li><li>  En casos generales, un JIT incorpora una llamada de una funci√≥n auxiliar <br>  <a href="">Compilador :: impImportAndPushBox (..)</a> </li><li>  La versi√≥n gen√©rica utiliza menos optimizado <br>  <a href="">MethodTable :: Box (..)</a> <br><ul><li>  Finalmente, se llama a [CopyValueClassUnchecked (..)] <br>  ( <a href="">https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581</a> ). <br>  Su c√≥digo muestra por qu√© es mejor elegir estructuras con un tama√±o de hasta 8 bytes incluido. </li></ul></li></ul><br><p>  Aqu√≠, el √∫nico m√©todo se utiliza para unboxing: <br>  <em><a href="">JIT_Unbox (..)</a></em> , que es un contenedor alrededor de <em><a href="">JIT_Unbox_Helper (..)</a></em> . </p><br><p>  Adem√°s, es interesante que ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right</a> ), unboxing no significa copiar datos al mont√≥n.  El boxeo significa pasar un puntero al mont√≥n mientras se prueba la compatibilidad de los tipos.  El c√≥digo de operaci√≥n de IL que sigue al desempaquetado definir√° las acciones con esta direcci√≥n.  Los datos pueden copiarse en una variable local o en la pila para llamar a un m√©todo.  De lo contrario, tendr√≠amos una doble copia;  primero cuando se copia desde el mont√≥n a alg√∫n lugar, y luego se copia al lugar de destino. </p><br><h2 id="questions">  Preguntas </h2><br><h3 id="why-net-clr-cant-do-pooling-for-boxing-itself">  ¬øPor qu√© .NET CLR no puede agrupar para el boxeo? </h3><br><p>  Si hablamos con cualquier desarrollador de Java, sabremos dos cosas: </p><br><ul><li>  Todos los tipos de valores en Java est√°n encuadrados, lo que significa que no son esencialmente tipos de valores.  Los enteros tambi√©n est√°n en caja. </li><li>  Por razones de optimizaci√≥n, todos los enteros desde -128 hasta 127 se toman del conjunto de objetos. </li></ul><br><p>  Entonces, ¬øpor qu√© esto no sucede en .NET CLR durante el boxeo?  Es simple  Debido a que podemos cambiar el contenido de un tipo de valor encuadrado, podemos hacer lo siguiente: </p><br><pre> <code class="plaintext hljs">object x = 1; x.GetType().GetField("m_value", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(x, 138); Console.WriteLine(x); // -&gt; 138</code> </pre> <br><p>  O as√≠ (C ++ / CLI): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object^ obj)</span></span></span><span class="hljs-function"> </span></span>{ Int32^ i = (Int32^)obj; *i = <span class="hljs-number"><span class="hljs-number">138</span></span>; }</code> </pre> <br><p>  Si tratamos con la agrupaci√≥n, entonces cambiar√≠amos todos los de la aplicaci√≥n a 138, lo que no es bueno. </p><br><p>  El siguiente es la esencia de los tipos de valor en .NET.  Tratan con valor, lo que significa que trabajan m√°s r√°pido.  El boxeo es raro y la adici√≥n de n√∫meros en caja pertenece al mundo de la fantas√≠a y la mala arquitectura.  Esto no es √∫til en absoluto. </p><br><h3 id="why-it-is-not-possible-to-do-boxing-on-stack-instead-of-the-heap-when-you-call-a-method-that-takes-an-object-type-which-is-a-value-type-in-fact">  ¬øPor qu√© no es posible hacer boxeo en la pila en lugar del mont√≥n, cuando se llama a un m√©todo que toma un tipo de objeto, que de hecho es un tipo de valor? </h3><br><p>  Si el cuadro de tipo de valor se realiza en la pila y la referencia ir√° al mont√≥n, la referencia dentro del m√©todo puede ir a otro lugar, por ejemplo, un m√©todo puede poner la referencia en el campo de una clase.  El m√©todo se detendr√° y el m√©todo que hizo el boxeo tambi√©n se detendr√°.  Como resultado, la referencia apuntar√° a un espacio muerto en la pila. </p><br><h3 id="why-it-is-not-possible-to-use-value-type-as-a-field">  ¬øPor qu√© no es posible usar el Tipo de valor como campo? </h3><br><p>  A veces queremos usar una estructura como un campo de otra estructura que usa la primera.  O m√°s simple: use la estructura como un campo de estructura.  No me preguntes por qu√© esto puede ser √∫til.  No puede.  Si usa una estructura como su campo o mediante la dependencia con otra estructura, crea una recursi√≥n, lo que significa una estructura de tama√±o infinito.  Sin embargo, .NET Framework tiene algunos lugares donde puede hacerlo.  Un ejemplo es <code>System.Char</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que se contiene a s√≠ mismo</a> : </p><br><pre> <code class="plaintext hljs">public struct Char : IComparable, IConvertible { // Member Variables internal char m_value; //... }</code> </pre> <br><p>  Todos los tipos primitivos CLR est√°n dise√±ados de esta manera.  Nosotros, simples mortales, no podemos implementar este comportamiento.  Adem√°s, no necesitamos esto: se hace para dar a los tipos primitivos un esp√≠ritu de OOP en CLR. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este traductor traducido del ruso como del idioma del autor por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos a crear una versi√≥n traducida de este texto a cualquier otro idioma, incluido el chino o el alem√°n, utilizando las versiones de texto en ruso e ingl√©s como fuente. <br><br>  Adem√°s, si quiere decir "gracias", la mejor manera de elegir es d√°ndonos una estrella en github o bifurcando repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439490/">https://habr.com/ru/post/439490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439480/index.html">Ceder, o ¬øPor qu√© su CRM (y CRM) se ralentiza?</a></li>
<li><a href="../439482/index.html">devleads - (des) motivaci√≥n financiera</a></li>
<li><a href="../439484/index.html">Obtener datos de enumeraci√≥n en una perspectiva de Automapper</a></li>
<li><a href="../439486/index.html">Tipos de referencia .NET vs Tipos de valor. Parte 1</a></li>
<li><a href="../439488/index.html">QA Meetup Grabaci√≥n de video</a></li>
<li><a href="../439492/index.html">10 consejos para ser un buen l√≠der tecnol√≥gico</a></li>
<li><a href="../439496/index.html">C√≥mo se realiza la facturaci√≥n all√≠: cuando el cliente y el desarrollador hablan diferentes idiomas</a></li>
<li><a href="../439498/index.html">¬øEn qu√© hardware analizar un enorme eje de informaci√≥n?</a></li>
<li><a href="../439500/index.html">¬øPor qu√© los captchas se han vuelto tan complicados?</a></li>
<li><a href="../439502/index.html">Comportamiento indefinido y verdad no definida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>