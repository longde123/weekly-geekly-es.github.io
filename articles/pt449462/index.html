<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚ÄçüöÄ üìÖ üëó Usando mecanismos de token criptogr√°fico PKCS # 11 em linguagens de script üëÜüèΩ üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üëáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em seus coment√°rios ao artigo ‚ÄúUm utilit√°rio de plataforma cruzada no idioma ingl√™s para exibir certificados x509 qualificados para a R√∫ssia‚Äù, o usu√°r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando mecanismos de token criptogr√°fico PKCS # 11 em linguagens de script</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449462/"><img src="https://habrastorage.org/webt/zf/pt/t6/zfptt6z2xd1tfn_xoovblv2gpuk.png" align="left">  Em seus coment√°rios ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> ‚ÄúUm utilit√°rio de plataforma cruzada no idioma ingl√™s para exibir certificados x509 qualificados para a R√∫ssia‚Äù, o usu√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Pas</a> observou corretamente os tokens PKCS # 11 que eles pr√≥prios ‚Äúpodem contar‚Äù.  Sim, os tokens s√£o realmente computadores criptogr√°ficos.  E √© natural querer usar esses computadores em linguagens de script, seja Python, Perl ou Ruby.  De alguma forma, j√° consideramos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uso de tokens PKCS # 11</a> com suporte para criptografia russa em Python para assinar e criptografar documentos, para criar uma solicita√ß√£o de certificado: <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/fad/2c8/cc8/fad2c8cc898827d22442885cc9513afd.png" alt="imagem"><br><br>  Aqui continuamos a discuss√£o sobre a linguagem Tcl.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> anterior, quando analisamos a exibi√ß√£o e a valida√ß√£o de certificados armazenados nos tokens / cart√µes inteligentes PKCS # 11, usamos o pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TclPKCS11 vers√£o 0.9.9</a> para acess√°-los (certificados).  Como j√° foi observado, infelizmente, o pacote foi desenvolvido para criptografia RSA e levando em considera√ß√£o o padr√£o PKCS # 11 v.2.20.  Hoje, o padr√£o PKCS # 11 v.2.40 j√° est√° sendo usado e √© o comit√™ de criptografia t√©cnica TK-26 que √© guiado por ele, emitindo recomenda√ß√µes para fabricantes nacionais de tokens / cart√µes inteligentes que suportam criptografia russa.  E com tudo isso dito, um novo pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TclPKCS11 vers√£o 1.0.1 apareceu</a> .  Faremos uma reserva imediatamente para que todas as interfaces criptogr√°ficas para RSA na nova vers√£o do pacote TclPKCS11 v.10.1 sejam salvas.  A biblioteca de pacotes est√° escrita na linguagem C. <br><br>  Ent√£o, o que h√° de novo no pacote?  Primeiro de tudo, foi adicionado um comando que permite obter uma lista de mecanismos criptogr√°ficos suportados pelo token conectado: <br><br><pre><code class="plaintext hljs">::pki::pkcs11::listmechs &lt;handl&gt; &lt;slotid&gt;</code> </pre> <br>  Como obter uma lista de slots com tokens conectados √© mostrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (procedure - proc :: slots_with_token): <br><br><pre> <code class="plaintext hljs">proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] }</code> </pre> <br>  Pegue um script simples: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path . package require pki::pkcs11 #      RuToken set lib "/usr/local/lib64/librtpkcs11ecp_2.0.so" &lt;source lang="bash"&gt;set handle [pki::pkcs11::loadmodule $lib] #    #       set labslot [::slots_with_token $handle] if {[llength $labslot] == 0} { puts "     " exit } set slotid 0 set lmech [pki::pkcs11::listmechs $handle $slotid] set i 0 foreach mm $lmech { #   if {[string first "GOSTR3410" $mm] != -1} { puts -nonewline "[lindex $mm 0] " if {$i == 2} {puts "";set i 0} else { incr i} } } puts "\n" exit</code> </pre> <br>  Este script permite obter uma lista dos mecanismos de criptografia GOSTR3410 suportados nos tokens da fam√≠lia RuToken.  Para come√ßar, vamos considerar, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Pas</a> escreveu no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> , "Rutoken Light amado por todos os tipos de EDOs": <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken Lite 0 {ruToken Lite } $</code> </pre> <br>  E, naturalmente, acontece que ele n√£o ap√≥ia nenhum mezanismo do GOST, que deveria ser provado.  Tomamos outro token Rutoken EDS: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken ECP } 0 {ruToken ECP } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 $</code> </pre> <br>  Sim, esse token suporta criptografia russa, mas apenas a assinatura do GOST R 34.10-2001, que est√° quase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fora de uso</a> .  Mas se voc√™ usar o token Rutoken EDS-2.0, tudo ficar√° bem, ele suporta o GOST R 34.10-2012 com chaves de 256 e 512 bits: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = RuTokenECP20 0 {RuTokenECP20 } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_512_KEY_PAIR_GEN CKM_GOSTR3410_512 CKM_GOSTR3410_12_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 CKM_GOSTR3410_WITH_GOSTR3411_12_256 CKM_GOS TR3410_WITH_GOSTR3411_12_512 $</code> </pre><br><img src="https://habrastorage.org/webt/1y/za/nm/1yzanmwujk76deyqsdqgw8kge3u.png" align="left">  Se falamos sobre o suporte √† criptografia russa, incluindo algoritmos de criptografia de gafanhoto e magma, com um ou outro token, ele √© totalmente suportado por tokens de software e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nuvem</a> , e isso √© natural: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = LS11SW2016_LIN_64 0 {LS11SW2016_LIN_64 }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Lista de mecanismos</b> <div class="spoiler_text">  CKM_GOSTR3410_KEY_PAIR_GEN <br>  CKM_GOSTR3410_512_KEY_PAIR_GEN <br>  CKM_GOSTR3410 <br>  CKM_GOSTR3410_512 <br>  CKM_GOSTR3410_WITH_GOSTR3411 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_256 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_512 <br>  CKM_GOSTR3410_DERIVE <br>  CKM_GOSTR3410_12_DERIVE <br>  CKM_GOSR3410_2012_VKO_256 <br>  CKM_GOSR3410_2012_VKO_512 <br>  CKM_KDF_4357 <br>  CKM_KDF_GOSTR3411_2012_256 <br>  CKM_KDF_TREE_GOSTR3411_2012_256 <br>  CKM_GOSTR3410_KEY_WRAP <br>  CKM_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_LISSI_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_GOST_GENERIC_SECRET_KEY_GEN <br>  CKM_GOST_CIPHER_KEY_GEN <br>  CKM_GOST_CIPHER_ECB <br>  CKM_GOST_CIPHER_CBC <br>  CKM_GOST_CIPHER_CTR <br>  CKM_GOST_CIPHER_OFB <br>  CKM_GOST_CIPHER_CFB <br>  CKM_GOST_CIPHER_OMAC <br>  CKM_GOST_CIPHER_KEY_WRAP <br>  CKM_GOST_CIPHER_ACPKM_CTR <br>  CKM_GOST_CIPHER_ACPKM_OMAC <br>  CKM_GOST28147_KEY_GEN <br>  CKM_GOST28147 <br>  CKM_GOST28147_KEY_WRAP <br>  CKM_GOST28147_PKCS8_KEY_WRAP <br>  CKM_GOST_CIPHER_PKCS8_KEY_WRAP <br>  CKM_GOST28147_ECB <br>  CKM_GOST28147_CNT <br>  CKM_GOST28147_MAC <br>  CKM_KUZNYECHIK_KEY_GEN <br>  CKM_KUZNYECHIK_ECB <br>  CKM_KUZNYECHIK_CBC <br>  CKM_KUZNYECHIK_CTR <br>  CKM_KUZNYECHIK_OFB <br>  CKM_KUZNYECHIK_CFB <br>  CKM_KUZNYECHIK_OMAC <br>  CKM_KUZNYECHIK_KEY_WRAP <br>  CKM_KUZNYECHIK_ACPKM_CTR <br>  CKM_KUZNYECHIK_ACPKM_OMAC <br>  CKM_MAGMA_KEY_GEN <br>  CKM_MAGMA_ECB <br>  CKM_MAGMA_CBC <br>  CKM_MAGMA_CTR <br>  CKM_MAGMA_OFB <br>  CKM_MAGMA_CFB <br>  CKM_MAGMA_OMAC <br>  CKM_MAGMA_KEY_WRAP <br>  CKM_MAGMA_ACPKM_CTR <br>  CKM_MAGMA_ACPKM_OMAC <br>  CKM_GOSTR3411 <br>  CKM_GOSTR3411_12_256 <br>  CKM_GOSTR3411_12_512 <br>  CKM_GOSTR3411_HMAC <br>  CKM_GOSTR3411_12_256_HMAC <br>  CKM_GOSTR3411_12_512_HMAC <br>  CKM_PKCS5_PBKD2 <br>  CKM_PBA_GOSTR3411_WITH_GOSTR3411_HMAC <br>  CKM_TLS_GOST_KEY_AND_MAC_DERIVE <br>  CKM_TLS_GOST_PRE_MASTER_KEY_GEN <br>  CKM_TLS_GOST_MASTER_KEY_DERIVE <br>  CKM_TLS_GOST_PRF <br>  CKM_TLS_GOST_PRF_2012_256 <br>  CKM_TLS_GOST_PRF_2012_512 <br>  CKM_TLS12_MASTER_KEY_DERIVE <br>  CKM_TLS12_KEY_AND_MAC_DERIVE <br>  CKM_TLS_MAC <br>  CKM_TLS_KDF <br>  CKM_TLS_TREE_GOSTR3411_2012_256 <br>  CKM_EXTRACT_KEY_FROM_KEY <br>  CKM_SHA_1 <br>  CKM_MD5 <br></div></div><br><pre> <code class="plaintext hljs">$</code> </pre> <br>  Passamos para o pr√≥ximo novo recurso adicionado ao pacote: <br><br><pre> <code class="plaintext hljs">set listcertsder [pki::pkcs11::listcertsder $handle $slotid]</code> </pre> <br>  Esta fun√ß√£o retorna uma lista de certificados armazenados por nenhum token.  A quest√£o surge naturalmente, mas como ela difere da fun√ß√£o existente pki :: pkcs11 :: listcerts? <br><br>  Primeiro de tudo, a nova fun√ß√£o n√£o usa o pacote :: pki.  Um dos elementos retornados √© o elemento cert_der, que cont√©m o certificado completo.  Isso √© conveniente, por exemplo, ao exportar um certificado ou ao receber sua impress√£o digital.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Antes, eu</a> precisava coletar o certificado completo do certificado tbs e de sua assinatura.  Uma lista completa dos itens retornados para cada certificado √© claramente vis√≠vel ao imprimir o conte√∫do de um certificado: <br><br><pre> <code class="plaintext hljs">. . . array set derc [[pki::pkcs11::listcertsder $handle $slotid] 0] parray derc derc(cert_der) = 3082064a ‚Ä¶ derc(pkcs11_handle) = pkcsmod0 derc(pkcs11_id) = 5882d64386211cf3a8367d2f87659f9330e5605d derc(pkcs11_label) = Thenderbird-60   derc(pkcs11_slotid) = 0 derc(type) = pkcs11 . . .</code> </pre> <br>  O elemento pkcs11_id armazena o atributo CKA_ID no valor do hash SHA-1 da chave p√∫blica.  O elemento cert_der √© o CKA_VALUE do certificado, pkcs11_label √© CKA_LABEL. <br><br>  O elemento pkcs11_id (CKA_ID na terminologia do padr√£o PKCS # 11) √©, junto com a biblioteca pkcs11_handle, e o identificador de slot com o token pkcs11_slotid um elemento-chave <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para acessar</a> chaves e certificados armazenados em tokens. <br><br>  Portanto, se queremos alterar o r√≥tulo (pkcs11_label) do certificado ou chaves, executamos um comando do formul√°rio: <br><br><pre> <code class="plaintext hljs">pki::pkcs11::rname &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  Para remover um certificado ou chaves de um token, um comando do formul√°rio √© executado: <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  A lista de elementos-chave pode ser formada da seguinte maneira: <br><br><pre> <code class="plaintext hljs">set listparam {} lappend listparam pkcs11_handle lappend listparam $handle lappend listparam pkcs11_slotid lappend listparam $pkcs11_slotid lappend listparam pkcs11_id lappend listparam $pkcs11_id</code> </pre> <br>  etc. <br>  A chamada de fun√ß√£o neste caso √© semelhante a esta (excluiremos o certificado e as chaves associadas a ele): <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete all $listparam</code> </pre> <br>  O leitor provavelmente j√° adivinhou que esta lista pode ser organizada como um dicion√°rio de dict <br><br><pre> <code class="plaintext hljs">set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid) dict set listparam pkcs11_id $pkcs11_id</code> </pre> <br>  Existem outras maneiras, por exemplo, atrav√©s de uma matriz. <br><br>  Mais uma vez, observamos que os elementos pkcs11_handle e pkcs11_slotid devem sempre estar presentes na lista de elementos-chave, que identificam exclusivamente o token conectado.  O restante da composi√ß√£o √© determinado por uma fun√ß√£o espec√≠fica. <br><br>  A seguinte fun√ß√£o √© usada para instalar o certificado no token: <br><br><pre> <code class="plaintext hljs">set pkcs11_id_cert [::pki::pkcs11::importcert &lt;cert_der_hex&gt; &lt;  &gt;</code> </pre> <br>  A fun√ß√£o retorna o valor CKA_ID em hexadecimal.  A lista de par√¢metros-chave determina o token no qual o certificado estar√° localizado: <br><br><pre> <code class="plaintext hljs">{pkcs11_handle &lt;handle&gt; pkcs11_slotid &lt;slotid&gt;}</code> </pre><br>  Em seguida, √© o nosso c√°lculo de hash.  Hoje, na criptografia russa, s√£o usados ‚Äã‚Äãtr√™s tipos de fun√ß√µes de hash: <br>  - GOST R 34.11-94 <br>  - GOST R 34 .11-2012 com um valor de hash de 256 bits (stribog256) <br>  - GOST R 34 .11-2012 com um valor de hash de 512 bits (stribog512) <br>  Para determinar qual hash suporta o token, temos a fun√ß√£o pki :: pkcs11 :: listmechs. <br><br>  A fun√ß√£o de c√°lculo de hash tem o seguinte formato: <br><br><pre> <code class="plaintext hljs">set &lt;&gt; [pki::pkcs11::digest &lt;gostr3411|stribog256|stribog512|sha1&gt; &lt;  &gt; &lt;  &gt;]</code> </pre> <br>  Observe que o resultado do c√°lculo √© apresentado em hexadecimal: <br><pre> <code class="plaintext hljs">. . . set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid set res_hex [pki::pkcs11::digest stribog256 0123456789 $listparam] puts $res_hex 086f2776f33aae96b9a616416b9d1fe9a049951d766709dbe00888852c9cc021</code> </pre><br>  Para verifica√ß√£o, vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usar o openssl com suporte para criptografia russa</a> : <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>|/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lirssl_csp_64/bin/lirssl_s tatic dgst -md_gost12_256 (stdin)= 086f2776f33aae96b9a616416b9d1fe9a0499 51d766709dbe00888852c9 cc021 $</code> </pre> <br>  Como voc√™ pode ver, o resultado √© id√™ntico. <br><br>  Para verificar uma assinatura eletr√¥nica, seja um certificado ou uma lista de certificados revogados ou um documento assinado em um formato, agora precisamos apenas da fun√ß√£o de verifica√ß√£o de assinatura: <br><br><pre> <code class="plaintext hljs">set result [pki::pkcs11::verify &lt; &gt; &lt; &gt; &lt;  &gt;]]</code> </pre> <br>  Se a assinatura passou na verifica√ß√£o, 1 √© retornado; caso contr√°rio, 0. Para verificar a assinatura eletr√¥nica, a pr√≥pria assinatura do documento, o hash do documento, determinado pelo tipo de assinatura e a chave p√∫blica com a qual a assinatura foi criada, com todos os par√¢metros (valor, tipo e par√¢metros), s√£o necess√°rios. .  Todas as informa√ß√µes sobre a chave na forma da estrutura publickeyinfo asn1 devem ser inclu√≠das na lista de elementos-chave: <br><blockquote>  lpkar (pkcs11_handle) = pkcsmod0 <br>  lpkar (pkcs11_slotid) = 0 <br>  lpkar (pubkeyinfo) = 301f06082a85030701010101301306072a85030202240 <br>  006082a8503070101020203430004407d9306687af5a8e63af4b09443ed2e03794be <br>  10eba6627bf5fb3da1bb474a3507d2ce2cd24b63c727a02521897d1dd6edbdc7084d <br>  8886a39289c3f81bdf2e179 </blockquote>  A estrutura de chave p√∫blica ASN1 √© retirada do certificado de signat√°rio: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert_pubkeyinfo {cert_hex} { array set ret [list] set wholething [binary format H* $cert_hex] ::asn::asnGetSequence wholething cert ::asn::asnPeekByte cert peek_tag if {$peek_tag != 0x02} { # Version number is optional, if missing assumed to be value of 0 ::asn::asnGetContext cert - asn_version ::asn::asnGetInteger asn_version ret(version) } ::asn::asnGetBigInteger cert ret(serial_number) ::asn::asnGetSequence cert data_signature_algo_seq ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo) ::asn::asnGetSequence cert issuer ::asn::asnGetSequence cert validity ::asn::asnGetUTCTime validity ret(notBefore) ::asn::asnGetUTCTime validity ret(notAfter) ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo binary scan $pubkeyinfo H* ret(pubkeyinfo) return $ret(pubkeyinfo) }</code> </pre> <br>  O texto do script para verificar a assinatura eletr√¥nica dos certificados de um arquivo est√° localizado <div class="spoiler">  <b class="spoiler_title">aqui</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#! /usr/bin/env tclsh package require pki lappend auto_path . package require pki::pkcs11 #     PKCS#11 #set pkcs11_module "/usr/local/lib/libcackey.so" #set pkcs11_module "/usr/local/lib64/librtpkcs11ecp_2.0.so" set pkcs11_module "/usr/local/lib64/libls11sw2016.so" puts "Connect the Token and press Enter" gets stdin yes set handle [pki::pkcs11::loadmodule $pkcs11_module] set slots [pki::pkcs11::listslots $handle] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid #    break } } # PEM  DER proc ::cert_to_der {data} { if {[string first "-----BEGIN CERTIFICATE-----" $data] != -1} { set data [string map {"\r\n" "\n"} $data] } array set parsed_cert [::pki::_parse_pem $data "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"] if {[string range $parsed_cert(data) 0 0 ] == "0" } { #   DER- "0" == 0x30 set asnblock $parsed_cert(data) } else { set asnblock "" } return $asnblock } proc usage {use error} { puts "Copyright(C) Orlov Vladimir (http://soft.lissi.ru) 2019" if {$use == 1} { puts $error puts "Usage:\nverify_cert_with_pkcs11 &lt;file with certificate&gt; \[&lt;file with CA certificate&gt;\]\n" } } set countcert [llength $argv] if { $countcert &lt; 1 || $countcert &gt; 2 } { usage 1 "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { usage 1 "File $file not exist" exit } #  cert_user puts "Loading user certificate: $file" set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file with certificate user: $file" exit } set cert_user [cert_to_der $cert_user] if {$cert_user == ""} { puts "User certificate bad" exit } catch {array set cert_parse [::pki::x509::parse_cert $cert_user]} if {![info exists cert_parse]} { puts "User certificate bad" exit } #parray cert_parse if {$countcert == 1} { if {$cert_parse(issuer) != $cert_parse(subject)} { puts "Bad usage: not self signed certificate" } else { set cert_CA $cert_user } } else { set fileca [lindex $argv 1] if {![file exists $fileca]} { usage 1 "File $fileca not exist" exit } #  cert_CA puts "Loading CA certificate: $fileca" set fd [open $fileca] chan configure $fd -translation binary set cert_CA [read $fd] close $fd if {$cert_CA == "" } { usage 1 "Bad file with certificate CA=$fileca" exit } set cert_CA [cert_to_der $cert_CA] if {$cert_CA == ""} { puts "CA certificate bad" exit } } foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid } } #    #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA] catch {array set cert_parse_CA [::pki::x509::parse_cert $cert_CA]} #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA_256] #array set cert_parse_CA [::pki::x509::parse_cert $CA_12_512] if {![info exists cert_parse_CA]} { puts "CA certificate bad" exit } ############################### set aa [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] set tbs_cert [binary format H* $cert_parse(cert)] #puts "SIGN_ALGO1=$cert_parse(signature_algo)" catch {set signature_algo_number [::pki::_oid_name_to_number $cert_parse(signature_algo)]} if {![info exists signature_algo_number]} { set signature_algo_number $cert_parse(signature_algo) } #puts "SIGN_ALGO=$signature_algo_number" switch -- $signature_algo_number { "1.2.643.2.2.3" - "1 2 643 2 2 3" { # "GOST R 34.10-2001 with GOST R 34.11-94" set digest_algo "gostr3411" } "1.2.643.7.1.1.3.2" - "1 2 643 7 1 1 3 2" { # "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" set digest_algo "stribog256" } "1.2.643.7.1.1.3.3" - "1 2 643 7 1 1 3 3" { # "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" set digest_algo "stribog512" } default { puts "  :$signature_algo_number" exit } } #   tbs-!!!! set digest_hex [pki::pkcs11::digest $digest_algo $tbs_cert $aa] puts "digest_hex=$digest_hex" puts [string length $digest_hex] # asn-   #    binary scan $cert_CA H* cert_CA_hex array set infopk [pki::pkcs11::pubkeyinfo $cert_CA_hex [list pkcs11_handle $handle pkcs11_slotid $token_slotid]] parray infopk set lpk [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] # pybkeyinfo     lappend lpk "pubkeyinfo" #lappend lpk $pubinfo lappend lpk $infopk(pubkeyinfo) array set lpkar $lpk parray lpkar puts "Enter PIN user for you token \"$token_slotlabel\":" #set password "01234567" gets stdin password if { [pki::pkcs11::login $handle $token_slotid $password] == 0 } { puts "Bad password" exit } if {[catch {set verify [pki::pkcs11::verify $digest_hex $cert_parse(signature) $lpk]} res] } { puts $res exit } if {$verify != 1} { puts "BAD SIGNATURE=$verify" } else { puts "SIGNATURE OK=$verify" } puts "!" exit</code> </pre> <br></div></div><br>  Salve o script em um arquivo e tente execut√°-lo: <br><br><pre> <code class="bash hljs">$./verify_cert_with_pkcs11.tcl Copyright(C) Orlov Vladimir (http://museum.lissi-crypto.ru/) Usage: verify_cert_with_pkcs11 &lt;file with certificate&gt; &lt;file with CA certificate&gt; $</code> </pre> <br>  Algu√©m pode se perguntar, e os certificados no token?  Primeiro, resolvemos o problema do uso de m√°quinas criptogr√°ficas PKCS # 11.  N√≥s os usamos.  E para exibir um certificado com um token, existe uma fun√ß√£o do pacote pki :: pkcs11 :: listcertsder, que permite selecionar o certificado desejado e verific√°-lo.  Isso pode ser considerado como li√ß√£o de casa. <br><br>  A apar√™ncia da nova vers√£o do pacote TclPKCS11v.1.0.1 permitiu refinar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">utilit√°rio de exibi√ß√£o de</a> certificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> adicionando as fun√ß√µes de importar um certificado para um token, excluindo certificados e chaves associadas de um token, alterando os r√≥tulos de certificados e chaves, etc .: <br><br><img src="https://habrastorage.org/webt/tn/7x/e8/tn7xe89tddtvfw0r6vmtqe2oeaa.png"><br><br>  O recurso mais importante adicionado √© a verifica√ß√£o de assinatura digital do certificado: <br><br><img src="https://habrastorage.org/webt/v8/sf/sr/v8sfsrp3tyghuwkyvseltrdtrsy.png"><br><br>  O leitor atento observou corretamente que nada foi dito sobre a gera√ß√£o do par de chaves.  Esse recurso tamb√©m foi adicionado ao pacote TclPKCS11: <br><br><pre> <code class="plaintext hljs">array set genkey [pki::pkcs11::keypair &lt; &gt; &lt;&gt; &lt;  &gt;]</code> </pre> <br>  Como as fun√ß√µes do pacote TclPKCS11 s√£o usadas, √© claro, podem ser encontradas no c√≥digo-fonte do utilit√°rio. <br><br>  A fun√ß√£o de gerar um par de chaves ser√° discutida em detalhes no pr√≥ximo artigo, quando o utilit√°rio criar√° uma solicita√ß√£o para um certificado qualificado com a gera√ß√£o de um par de chaves no token PKCS # 11, o mecanismo para obter um certificado em um centro de certifica√ß√£o ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CA</a> ) e import√°-lo para um token: <br><br><img src="https://habrastorage.org/webt/zn/c4/zu/znc4zukmmtywwnpo4ycwze4zseo.png"><br><br>  No mesmo artigo, a fun√ß√£o de assinar um documento ser√° considerada.  Este ser√° o √∫ltimo artigo desta s√©rie.  Em seguida, uma s√©rie de artigos est√° planejada para oferecer suporte √† criptografia russa na linguagem de script Ruby, que agora est√° na moda.  At√© breve! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt449462/">https://habr.com/ru/post/pt449462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt449450/index.html">Svelte 3: Repensando a reatividade</a></li>
<li><a href="../pt449452/index.html">Os desenvolvedores da Web escrevem c√≥digo n√£o seguro por padr√£o</a></li>
<li><a href="../pt449454/index.html">Como a Microsoft Kaizala permite que as ferrovias indianas re√∫nam 3 milh√µes de funcion√°rios de servi√ßos de sa√∫de</a></li>
<li><a href="../pt449458/index.html">A atualiza√ß√£o do Windows 10 "May 2019 Update" n√£o ser√° instalada quando ... unidades USB e cart√µes de mem√≥ria estiverem conectados ao PC</a></li>
<li><a href="../pt449460/index.html">Museum DataArt. O manipulador do mouse de informa√ß√µes gr√°ficas</a></li>
<li><a href="../pt449464/index.html">O widget vk.com sem demanda define um contador de mail.ru no site</a></li>
<li><a href="../pt449466/index.html">Pausas nos jogos HTML5</a></li>
<li><a href="../pt449468/index.html">Como o "truque √©tico" do fabricante do software de jogos de azar se transformou em um pesadelo completo</a></li>
<li><a href="../pt449472/index.html">Dias sombrios do cataclismo adiante, an√°lise est√°tica e bagels</a></li>
<li><a href="../pt449476/index.html">Um novo tipo de armazenamento SSD reduzir√° o consumo de energia no data center - como funciona</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>