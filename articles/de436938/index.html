<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚖️ ↪️ 🙍🏽 Guix ist das fortschrittlichste Betriebssystem. 🚀 👩‍🚀 🧙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Betriebssysteme sind ein umfangreiches Thema. Hier dominiert seit Jahrzehnten ein Ansatz: Unix. In der Tat halten sich die meisten modernen Systeme, e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guix ist das fortschrittlichste Betriebssystem.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436938/"> Betriebssysteme sind ein umfangreiches Thema.  Hier dominiert seit Jahrzehnten ein Ansatz: Unix.  In der Tat halten sich die meisten modernen Systeme, einschließlich der meisten GNU / Linux-Distributionen * BSD und macOS, an die Unix-Architektur.  (Es gibt kein Windows, aber zu diesem Thema gibt es fast nichts Interessantes). <br><br>  Im Jahr 2000 hielt Rob Pike einen Vortrag darüber, warum die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erforschung von Systemsoftware nicht relevant ist</a> .  Aufgrund von Pessimismus oder Missachtung der Community scheint er die Beschwerden, die viele Unix-Benutzer im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unix-Haters-Handbuch</a> (1994) gesammelt haben, völlig ignoriert zu haben.  Das Buch ist absichtlich sarkastisch, weist jedoch auf einige kritische Probleme mit Unix-Systemen hin - und sie wurden noch nicht gelöst. <br><br>  Im Jahr 2006 veröffentlichte Elko Dositra seine Dissertation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Ein voll funktionsfähiges Software-Bereitstellungsmodell“, in</a> der der funktionale Nix-Paketmanager beschrieben wird.  2008 veröffentlichte der Autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NixOS: eine voll funktionsfähige Linux-Distribution</a> .  Während NixOS viel freie Software für Unix-Systeme wiederverwendet, ist es so weit von Unix-Design und -Philosophie entfernt, dass es kaum als „Unix-System“ bezeichnet werden kann. <br><a name="habracut"></a><br>  Nix ist ein großer Fortschritt in der Systemtechnik.  Dieses Betriebssystem löste nicht nur viele Unix-Probleme (einschließlich Kritik aus der oben genannten Sammlung), sondern ebnete auch den Weg für viele andere Funktionen und Studien, die in unserer Zeit eine sehr wichtige Rolle spielen können, in der Zuverlässigkeit und Sicherheit zum Hauptthema vieler wissenschaftlicher, öffentlicher und politischer Organisationen geworden sind Debatte. <br><br>  Pike hat sich geirrt.  Und dies beweist einen weiteren allgemeineren Punkt: Es ist wahrscheinlich klüger, keine Forschung für irrelevant zu erklären, wenn Sie die Unmöglichkeit einer weiteren Entwicklung nicht beweisen können.  Und der erwähnte Bericht kann kaum als mathematischer Beweis angesehen werden.  Er bekräftigte nur die Idee, dass Unix „gut genug“ ist und dass Sie sich mit seinen Funktionen und Problemen auseinandersetzen sollten. <br><br>  Glücklicherweise erwies sich dieser unnötige Pessimismus als kurzsichtig und hielt nicht lange an: Nur ein paar Jahre später bewies das Nix-System, dass es falsch war. <br><br><h1>  Guix Aussehen </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Guix</a> ist der Paketmanager unter Nix und GuixSD ist das Betriebssystem, das NixOS entspricht und ein „voll programmierbares Betriebssystem“ sein soll.  In der Tat ist fast alles hier im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Guile-Schema</a> geschrieben und konfiguriert: von der Guix-Paketverwaltung bis zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Shepherd-</a> Initialisierungssystem. <br><br>  Guix unterscheidet sich erheblich von Unix-Betriebssystemen.  Sie können die Dokumentation anzeigen und den Änderungsgrad bewerten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizieller Leitfaden</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsliste</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Guix Package Guide</a> ist eine technische Einführung (Kopie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). </li></ul><br><h1>  Guix Vorteile </h1><br>  Die Vorteile von Guix sind so revolutionär, dass der Rest des Betriebssystems im Vergleich dazu wie Legacy-Systeme aussieht. <br><br>  Meine persönlichen Lieblingsmerkmale: <br><br><ul><li>  Systemunverwundbarkeit: Guix führt einen Verlauf aller Änderungen sowohl auf System- als auch auf Benutzerebene.  Wenn das Update etwas kaputt macht, können Sie jederzeit einen Rollback durchführen.  Dies macht das System praktisch <i>unverwundbar</i> . <br></li><li>  Integrität: Da die Konfiguration deklarativ ist, hat der Benutzer oder Systemadministrator die vollständige Kontrolle.  Bei anderen Unix-Varianten ist es viel schwieriger zu sagen, wann sich eine zufällige Konfigurationsdatei ändert. <br></li><li>  Voll programmierbares Betriebssystem: Programmieren Sie Systemkonfigurationen und verwenden Sie ein Versionskontrollsystem.  Viele Systemdienste können im Guile-Schema konfiguriert werden: von udev-Regeln bis zu Xorg, PAM usw. Dank Guile kann die Konfiguration von der Hardware oder sogar vom Hostnamen abhängig gemacht werden! <br></li><li>  Direkter Ersatz für andere (nicht so gute) Paketmanager: Warum sollten Sie Emacs-, Python- oder TeXlive-Pakete separat verwalten, wenn es für jeden eine einzige Schnittstelle gibt (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unten</a> )?  Es ist einfacher, Deklarationen für Benutzerprofile zu schreiben und zu verwalten. <br></li><li>  Guile-Paketdefinitionen: Es ist viel effizienter, Paketdefinitionen in großen Mengen zu entwickeln.  Es ersetzt vorteilhaft Konzepte wie Portage USE-Flags (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unten</a> ). <br></li><li>  Verschiedene Arten der Ausgabe von Paketen: Ein Guix-Paket kann mehrere Arten der Ausgabe haben, mit denen die verschiedenen Komponenten (Bibliotheken, zusätzliche Tools, Dokumentation usw.) getrennt werden.  Auf anderen Betriebssystemen (normalerweise Debian) ist es schwieriger zu erraten, welche Pakete zusammenpassen. <br></li><li> Nicht multiplizierende Eingaben: In der Guix-Terminologie sind „Eingaben“ Paketabhängigkeiten.  Das Benutzerprofil und die Umgebung enthalten nur Pakete, die vom Benutzer explizit installiert wurden, und nicht unbedingt deren Abhängigkeiten.  Siehe beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inxi</a> , ein Tool zum Melden von Systeminformationen: Wenn ich nur an Berichten über das inxi-System / die inxi-Ausrüstung interessiert bin, müssen <code>PATH</code> nicht zwei bis drei Dutzend zusätzliche Befehlszeilentools hinzugefügt werden.  Mit Guix können Sie im Benutzerprofil nur das anzeigen, was er wirklich benötigt. <br></li><li>  Guix-Umgebungen: Wenn Sie eine Guix-Umgebung <code>guix environment SOME-PACKAGES</code> Guix richtet eine temporäre Umgebung ein, in der alle Anforderungen für <code>SOME-PACKAGES</code> .  Dies kann verwendet werden, um die Build-Umgebung für das Projekt sowie für andere Zwecke einfach zu konfigurieren (siehe unten).  Eine großartige Qualität: Mit ihnen können Sie Programme ausführen, ohne sie im Benutzerprofil zu installieren. <br></li><li>  Teilaktualisierungen: 100% unterstützt.  Dies ist wahrscheinlich die Hauptursache für Ausfälle in Floating-Releases wie Arch Linux und Gentoo: Da dort nur mehrere Versionen gleichzeitig unterstützt werden (normalerweise nur eine), muss das gesamte System als Ganzes aktualisiert werden.  Dies bedeutet mehr Verkehr mit jedem Update.  Mit Guix wird jedes Paket einzeln aktualisiert. <br></li><li>  Kontinuierliche Integration oder warum Guix ohne Paketbetreuer funktionieren kann: Dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reproduzierbarer Assemblys</a> und Unterstützung für Teilaktualisierungen funktioniert das Paket unter Guix „immer“ und einige Abhängigkeiten werden beim nächsten Update nicht unterbrochen (genauer gesagt, wenn die Abhängigkeit das Paket zerstört). dann ist dies trivial behoben, um die richtige Version der Bibliothek zu verwenden).  So kann die Arbeit mit Paketen auf „Montagefarmen“ übertragen werden (eine auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hydra</a> aus dem Nix-Projekt, die andere auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cuirass</a> ).  Vergleichen Sie dies mit den meisten anderen GNU / Linux-Communities, bei denen Dutzende von Betreuern Tausende von Paketen aktualisieren müssen.  Dieser Ansatz lässt sich nicht skalieren: Letztendlich stagnieren diese Verteilungen bei einigen tausend Paketen.  In Guix kann die Anzahl der Pakete leise wachsen, ohne dass ein Zusammenbruch befürchtet wird.  Gleichzeitig können Mitwirkende effizienter eingesetzt werden. <br><br>  In Guix ist das Erstellen aus der Quelle genauso einfach.  Tatsächlich ist dies für den Endbenutzer nicht so wichtig: Guix kann problemlos von den Quellen zur Assembly zurückkehren, wenn das fertige Paket nicht verfügbar ist. <br></li><li>  <code>guix import</code> und <code>guix refresh</code> : Automatisch und rekursiv <code>guix refresh</code> erstellen oder aktualisieren.  Hunderte von Definitionen werden gleichzeitig verarbeitet.  Solche Funktionen unterstreichen die Vorteile einer echten Programmiersprache im Betriebssystem.  Was auf den meisten Betriebssystemen eine schwierige Aufgabe ist, ist in Guix relativ einfach zu implementieren. <br></li><li>  Guix-Kanäle: eine meiner Lieblingsfunktionen!  Für Arch Linux oder Gentoo müssen Sie ein lokales Repository erstellen.  Da sie keine Teilaktualisierungen unterstützen, muss der Benutzer von Zeit zu Zeit einige Wartungsarbeiten durchführen (d. H. Sicherstellen, dass Abhängigkeitsaktualisierungen keine Pakete beschädigen).  Guix-Kanäle ersetzen gewinnbringend AUR-Overlays von Arch Linux und Gentoo, sodass jeder seine Paketdefinitionen beispielsweise über Git-Repositorys verteilen kann.  Dies garantiert wiederum vollständige Transparenz (Rückschläge, Verlauf usw.). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emacs-Guix</a> : Soweit ich weiß, ist Guix die einzige Distribution, die über die leistungsstärkste Emacs-Benutzeroberfläche verfügt! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Guix-Packs</a> : eine echte Alternative zu Containern wie Docker.  Die meisten Containersysteme leiden unter kritischen Problemen: Sie können nicht wiedergegeben werden und sind in Wirklichkeit undurchsichtige Binärdateien, was für Benutzer, denen Vertrauen, Sicherheit und Datenschutz wichtig sind, grundsätzlich nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">akzeptabel ist</a> .  Im Gegenteil, Guix-Packs sind absolut klar, reproduzierbar und transparent. <br></li><li>  <code>guix system vm</code> und <code>guix system disk-image</code> : Guix macht es trivial, das gesamte aktuelle System als Live-USB, innerhalb der VM oder auf einem Remote-Computer abzuspielen. </li></ul><br><h1>  Guix im Vergleich zu Wettbewerbern </h1><br><h3>  Debian, Arch Linux und die meisten anderen GNU / Linux-Distributionen </h3><br>  GNU / Linux-Distributionen bieten normalerweise nicht die oben genannten Vorteile von Guix.  Die kritischsten Mängel: <br><br><ul><li>  Mangelnde Unterstützung für mehrere Versionen von Paketen oder "Abhängigkeitshölle".  Angenommen, das neueste mpv erfordert ein neues ffmpeg, aber das Aktualisieren von ffmpeg bricht die meisten anderen Programme.  Wir befinden uns in einem Dilemma: Entweder brechen Sie einige Pakete oder speichern Sie alte Versionen.  Schlimmer noch, es gibt möglicherweise überhaupt kein geeignetes Paket oder es gibt keine Betriebssystemunterstützung.  Dieses Problem tritt bei den meisten Distributionen auf, die die Erfüllung ihrer Hauptaufgabe nicht garantieren können: ein Paket für <i>jedes</i> Programm. <br></li><li>  Kritische Abhängigkeit von Betreuern.  Nicht funktionierende Paketverwaltung bedeutet, dass alle Pakete ständig auf Kompatibilität getestet werden müssen.  Dies ist eine Menge harte Arbeit für diejenigen, denen diese Aufgabe anvertraut wurde.  In der Praxis bedeutet dies, dass die Qualität des Paketmanagements stark von den Menschen abhängt.  Eine Verteilung ohne eine ausreichende Anzahl von Betreuern wird unweigerlich leiden und möglicherweise sterben.  Dieser Arbeitsaufwand ist normalerweise nicht skaliert und führt mit zunehmender Anzahl von Paketen zu einer Zunahme der Komplexität (sowohl in der Codebasis als auch in der Verwaltung). </li></ul><br><a name="2"></a><h3>  Gentoo, * BSD </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gentoo</a> und andere Distributionen mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Portage-</a> Paketmanager haben eine berühmte Funktion: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">USE-Flags</a> zum Aktivieren von Funktionen im gesamten System (z. B. Stummschalten, Aktivieren der GUI-Unterstützung usw.). <br><br>  USE-Flags machen es trivial, Funktionen des Autors des Pakets zu aktivieren oder zu deaktivieren (und der Vorteil ist, dass sie getestet werden).  Auf der anderen Seite können Sie mit Portage keine Funktionen konfigurieren, die nicht im Voraus geplant wurden.  Wenn ein Paket beispielsweise einen zusätzlichen Sound hat, der Autor jedoch das entsprechende Flag nicht gesetzt hat, kann der Benutzer nichts dagegen tun (außer eine neue Paketdefinition zu erstellen). <br><br>  Im Vergleich dazu können Sie mit Guix alles vollständig anpassen, allerdings mit etwas mehr Schema-Code.  Im Pseudocode sieht es ungefähr so ​​aus: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loop-over</span></span> (<span class="hljs-name"><span class="hljs-name">TARGET-PACKAGES</span></span>) (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">inherit</span></span> TARGET) (<span class="hljs-name"><span class="hljs-name">changes-here</span></span>... including patches, build options, etc.))</code> </pre> <br>  Ein solcher Code-Batch legt die Definitionen für <code>TARGET-PACKAGES</code> mit Ihren Änderungen fest.  Keine der Änderungen muss an der Paketdefinition vorgenommen werden.  Der Benutzer behält jederzeit die volle Kontrolle über die Änderungen, die an Paketen vorgenommen werden können. <br><br>  Ich habe Gentoo geliebt, aber nach dem Wechsel zu Guix wurden die Einschränkungen von Portage offensichtlich. <br><br><ul><li>  Das USE-Flag-System erlaubt keine Anpassung ungeplanter beliebiger Funktionen. <br></li><li>  Die Verwendung von Flags fügt eine ganze Klasse von Komplexität hinzu (siehe die ziemlich komplizierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomsemantik</a> ), um die Beziehung von Funktionen zwischen Paketen zu beschreiben und zu verwalten.  Guix beseitigt diese Komplexität mithilfe des Guile-Schemas zum Programmieren von Beziehungen vollständig. </li></ul><br>  Darüber hinaus leidet Portage unter demselben Problem, da mehrere Versionen nicht ordnungsgemäß unterstützt werden, und Flags erhöhen das Ausmaß des Problems erheblich (eine häufige Beschwerde über Portage): Wenn inkompatible USE-Flags für einige Abhängigkeiten gelten, muss der Benutzer manuell nach einer Lösung suchen.  Manchmal bedeutet dies, dass die erforderliche Funktion nicht anwendbar ist (zumindest ohne wesentliche Arbeit an Paketdefinitionen). <br><br>  In der Praxis bietet Guix vorkompilierte Pakete an - eine enorme Zeitersparnis im Vergleich zu Gentoo (obwohl Portage die Verteilung von Binärpaketen unterstützt). <br><br>  * BSD-Systeme (z. B. FreeBSD) leiden unter ähnlichen Problemen bei <code>make config</code> . <br><br><h3>  Nix </h3><br>  Nix war ein historischer Durchbruch in der Betriebssystemforschung, und Guix hat fast alle seine Ideen von dort übernommen.  Heute ist Nix immer noch eines der besten aktiven Betriebssysteme.  Guix hätte wahrscheinlich nicht existiert, wenn es nicht einen Fehler gegeben hätte. <br><br>  Meiner Meinung nach löst Guix das Hauptproblem von Nix: Anstelle seiner eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">domänenspezifischen Sprache</a> (DSL) wird hier eine vollwertige Lisp-basierte Guile Scheme-Programmiersprache verwendet. <br><br>  "Implementieren Ihrer eigenen Programmiersprache" ist ein weit verbreitetes Missverständnis in der Softwareentwicklung.  Dies traf viele Projekte, bei denen die Konfigurations- oder Programmiersprache unter folgenden Nachteilen litt: <br><br><ul><li>  begrenzte Ausdruckskraft und Fähigkeiten; <br></li><li>  Eine andere Sprache zum Lernen (aber nicht sehr nützlich und universell), die vom Benutzer einige Anstrengungen erfordert und somit eine Eintrittsbarriere schafft; <br></li><li>  weniger lesbarer Code (zumindest zuerst); <br></li><li>  oft schlechte Leistung. </li></ul><br>  Es gibt so viele Projekte in einheimischen oder zu begrenzten Sprachen: <br><br><ul><li>  XML, HTML (noch besser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">S-XML</a> ) </li><li>  Make, Autoconf, Automake, Cmake usw. </li><li>  Bash, Zsh, Fish (noch besser: Eshell oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scsh</a> ) </li><li>  JSON, TOML, YAML </li><li>  Portage zu Nix <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ebuild</a> und vielen anderen Syntaxregeln für Betriebssystempaketdefinitionen </li><li>  Firefox bei Verwendung von XUL (Mozilla hat es inzwischen aufgegeben) und den meisten anderen einheimischen Sprachen für Erweiterungen </li><li>  SQL </li><li>  Octave, R, PARI / GP, die meisten wissenschaftlichen Programme (z. B. Common Lisp, Racket und andere Programme) </li><li>  Reguläre Ausdrücke ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rx in Emacs</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG in Racket</a> usw.) </li><li>  sed, AWK usw. </li><li>  Die meisten Init-Konfigurationen, einschließlich systemd (noch besser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Shepherd</a> ) </li><li>  cron (noch besser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mcron</a> ) </li><li>  conky (nicht vollständig programmierbar, obwohl dies das am meisten erwartete Merkmal eines ähnlichen Programms sein sollte) </li><li>  TeX, LaTeX (und alle Derivate), Asymptote (noch besser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scribble</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skribilo</a> - noch in der Entwicklung; ab Januar 2019 wird TeX / LaTeX noch als Zwischenschritt bei der Erstellung des PDF verwendet) </li><li>  Die meisten Programme mit Konfigurationen, die keine universelle Programmiersprache verwenden. </li></ul><br>  Das Rad neu zu erfinden ist normalerweise keine gute Idee.  Wenn es um so wichtige Tools wie Programmiersprachen geht, hat dies sehr dramatische Konsequenzen.  Unnötige zusätzliche Anstrengungen sind erforderlich, Fehler treten auf.  Die Community zerstreut sich.  Konsolidiertere Communities sind effizienter und nutzen ihre Zeit besser, wenn sie vorhandene, gut entwickelte Programmiersprachen verbessern. <br><br><h1>  Nicht nur für den Desktop </h1><br>  Guix unterstützt mehrere Architekturen (i686, x86_64, ARMv7 und AArch64 ab Januar 2019) und plant, weitere Kerne außerhalb des Linux-Ökosystems zu unterstützen (sagen wir * BSD, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Hurd</a> oder vielleicht Ihr eigenes System!). <br><br>  Dies macht Guix zu einem großartigen Tool für die Bereitstellung (reproduzierbarer) Server und anderer spezialisierter Systeme.  Ich denke, dass Guix in eingebetteten Systemen sehr gut mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenWRT</a> konkurrieren kann (obwohl die Portierung auf eingebettete Systeme einige Arbeit erfordert). <br><br><h1>  Selbstreproduzierendes Live-USB </h1><br>  Oben habe ich das <code>guix system disk-image</code> : So können Sie beispielsweise das aktuelle System auf einem USB-Flash-Laufwerk neu erstellen. <br><br>  Somit ist ein Klon des aktuellen Systems einfach überall zu verbinden und die genaue aktuelle Umgebung (abzüglich der Hardware) zu replizieren.  Dort können Sie Benutzerdaten einfügen: PGP-Schlüssel, E-Mail.  Alles ist sofort nach dem Download verfügbar. <br><br>  Offensichtlich funktioniert das Klonen weiter von dem Computer entfernt, auf dem der Klon installiert ist: Anstelle des „nackten“ Guix wird ein vollwertiges Betriebssystem bereitgestellt, das betriebsbereit ist. <br><br><a name="1"></a><h1>  Andere Paketmanager ersetzen </h1><br><h3>  Emacs, Python, Ruby ... und die Kraft der <code>guix environment</code> </h3><br>  Guix kann jeden Paketmanager ersetzen, einschließlich Paketmanager von Programmiersprachen.  Es hat mehrere Vorteile: <br><br><ul><li>  Allgegenwärtige Reproduzierbarkeit. <br></li><li>  Allgegenwärtige Rollbacks. <br></li><li>  Sie müssen keinen anderen Paketmanager lernen. </li></ul><br>  An dieser Stelle sollten Sie die <code>guix environment</code> erwähnen.  Dieser Befehl richtet eine temporäre Umgebung mit nur einem bestimmten Satz von Paketen wie <code>virtualenv</code> .  Das Killer-Feature ist, dass es für alle Sprachen und ihre Kombinationen universell ist. <br><br><h3>  Texlive </h3><br>  (Haftungsausschluss: Ab Januar 2019 wird das TeXlive-Build-System für Guix neu gestaltet.) <br><br>  TeXlive erhielt eine besondere Erwähnung, weil es besonders schrecklich ist :), was erneut die rettende Rolle von Guix bestätigt! <br><br>  Die meisten Unix-basierten Betriebssysteme vertreiben TeXlive normalerweise als Teil einer Paketsuite.  Zum Beispiel hat Arch Linux ein Dutzend davon.  Wenn Sie einige TeX-Pakete aus verschiedenen Sets benötigen, bleibt Arch Linux keine andere Wahl, als Tausende (möglicherweise unnötige) Pakete zu installieren, und TeXlive nimmt <i>viel</i> Platz ein: Hunderte von Megabyte. <br><br>  Alternativ können Sie TeXlive manuell installieren, aber seien wir <code>tlmgr</code> : <code>tlmgr</code> ist nur ein schlechter Paketmanager und erfordert mühsame zusätzliche Arbeit. <br><br>  Mit Guix werden TeXlive-Pakete wie alles andere separat installiert. Auf diese Weise können Sie Ihre eigenen TeXlive-Pakete verwalten oder sogar Spezifikationen für die virtuelle Umgebung zum Kompilieren bestimmter Dokumente erstellen. <br><br><h1>  Der Kern </h1><br>  Viele Betriebssysteme bieten nur begrenzte Unterstützung für benutzerdefinierte Kernel.  Wenn Benutzer vom Standardkernel abweichen möchten, muss der nicht standardmäßige Kernel manuell verwaltet werden. <br><br>  Es ist bekannt, dass Gentoo den Benutzerkern als empfohlenen (obligatorischen?) Installationsschritt "benötigt".  Dies ist jedoch kaum eine Voraussetzung, und die Benutzer selbst müssen die Kernelkonfiguration unterstützen. <br><br>  In Guix ist der Kernel wie jedes andere ein vollständig anpassbares reguläres Paket.  Sie können alles konfigurieren und die Kernel-Konfigurationsdatei an die Paketdefinition übergeben. <br><br>  Im Folgenden finden Sie beispielsweise Definitionen eines nicht freien Linux-Kernels mit dem <code>iwlwifi</code> Treiber (Warnung: Ich empfehle dringend, keine proprietären Treiber zu verwenden, da diese eine ernsthafte Bedrohung für Ihre Privatsphäre und Freiheit darstellen): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-module</span></span> (<span class="hljs-name"><span class="hljs-name">ambrevar</span></span> linux-custom) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> gexp) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> packages) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> download) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> git-download) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> build-system trivial) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> ((<span class="hljs-name"><span class="hljs-name">guix</span></span> licenses) #<span class="hljs-symbol"><span class="hljs-symbol">:prefix</span></span> license:) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">gnu</span></span> packages linux) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">srfi</span></span> srfi-1)) (<span class="hljs-name"><span class="hljs-name">define-public</span></span> linux-nonfree (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">inherit</span></span> linux-libre) (<span class="hljs-name"><span class="hljs-name">name</span></span> <span class="hljs-string"><span class="hljs-string">"linux-nonfree"</span></span>) (<span class="hljs-name"><span class="hljs-name">version</span></span> (<span class="hljs-name"><span class="hljs-name">package-version</span></span> linux-libre)) (<span class="hljs-name"><span class="hljs-name">source</span></span> (<span class="hljs-name"><span class="hljs-name">origin</span></span> (<span class="hljs-name"><span class="hljs-name">method</span></span> url-fetch) (<span class="hljs-name"><span class="hljs-name">uri</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"https://www.kernel.org/pub/linux/kernel/v4.x/"</span></span> <span class="hljs-string"><span class="hljs-string">"linux-"</span></span> version <span class="hljs-string"><span class="hljs-string">".tar.xz"</span></span>)) (<span class="hljs-name"><span class="hljs-name">sha256</span></span> (<span class="hljs-name"><span class="hljs-name">base32</span></span> <span class="hljs-string"><span class="hljs-string">"1lm2s9yhzyqra1f16jrjwd66m3jl43n5k7av2r9hns8hdr1smmw4"</span></span>)))) (<span class="hljs-name"><span class="hljs-name">native-inputs</span></span> `((<span class="hljs-string"><span class="hljs-string">"kconfig"</span></span> ,(local-file <span class="hljs-string"><span class="hljs-string">"./linux-custom.conf"</span></span>)) ,@(alist-delete <span class="hljs-string"><span class="hljs-string">"kconfig"</span></span> (package-native-inputs linux-libre)))))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-version</span></span>) <span class="hljs-string"><span class="hljs-string">"9d40a17beaf271e6ad47a5e714a296100eef4692"</span></span>) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-source</span></span> version) (<span class="hljs-name"><span class="hljs-name">origin</span></span> (<span class="hljs-name"><span class="hljs-name">method</span></span> git-fetch) (<span class="hljs-name"><span class="hljs-name">uri</span></span> (<span class="hljs-name"><span class="hljs-name">git-reference</span></span> (<span class="hljs-name"><span class="hljs-name">url</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"https://git.kernel.org/pub/scm/linux/kernel"</span></span> <span class="hljs-string"><span class="hljs-string">"/git/firmware/linux-firmware.git"</span></span>)) (<span class="hljs-name"><span class="hljs-name">commit</span></span> version))) (<span class="hljs-name"><span class="hljs-name">file-name</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"linux-firmware-"</span></span> version <span class="hljs-string"><span class="hljs-string">"-checkout"</span></span>)) (<span class="hljs-name"><span class="hljs-name">sha256</span></span> (<span class="hljs-name"><span class="hljs-name">base32</span></span> <span class="hljs-string"><span class="hljs-string">"099kll2n1zvps5qawnbm6c75khgn81j8ns0widiw0lnwm8s9q6ch"</span></span>)))) (<span class="hljs-name"><span class="hljs-name">define-public</span></span> linux-firmware-iwlwifi (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> <span class="hljs-string"><span class="hljs-string">"linux-firmware-iwlwifi"</span></span>) (<span class="hljs-name"><span class="hljs-name">version</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-version</span></span>)) (<span class="hljs-name"><span class="hljs-name">source</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-source</span></span> version)) (<span class="hljs-name"><span class="hljs-name">build-system</span></span> trivial-build-system) (<span class="hljs-name"><span class="hljs-name">arguments</span></span> `(#<span class="hljs-symbol"><span class="hljs-symbol">:modules</span></span> ((guix build utils)) #<span class="hljs-symbol"><span class="hljs-symbol">:builder</span></span> (begin (use-modules (guix build utils)) (let ((source (assoc-ref %build-inputs <span class="hljs-string"><span class="hljs-string">"source"</span></span>)) (fw-dir (string-append %output <span class="hljs-string"><span class="hljs-string">"/lib/firmware/"</span></span>))) (mkdir-p fw-dir) (for-each (lambda (file) (copy-file file (string-append fw-dir (basename file)))) (find-files source <span class="hljs-string"><span class="hljs-string">"iwlwifi-.*\\.ucode$|LICENSE\\.iwlwifi_firmware$"</span></span>)) #t)))) (<span class="hljs-name"><span class="hljs-name">home-page</span></span> <span class="hljs-string"><span class="hljs-string">"https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi"</span></span>) (<span class="hljs-name"><span class="hljs-name">synopsis</span></span> <span class="hljs-string"><span class="hljs-string">"Non-free firmware for Intel wifi chips"</span></span>) (<span class="hljs-name"><span class="hljs-name">description</span></span> <span class="hljs-string"><span class="hljs-string">"Non-free iwlwifi firmware"</span></span>) (<span class="hljs-name"><span class="hljs-name">license</span></span> (<span class="hljs-name"><span class="hljs-name">license</span></span><span class="hljs-symbol"><span class="hljs-symbol">:non-copyleft</span></span> <span class="hljs-string"><span class="hljs-string">"https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/LICENCE.iwlwifi_firmware?id=HEAD"</span></span>))))</code> </pre> <br>  Der benutzerdefinierte Kernel und die Firmware können bedingt in die aktuelle Systemkonfiguration aufgenommen werden (einige <code>config.scm</code> Dateien): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> *lspci* (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">port</span></span> (<span class="hljs-name"><span class="hljs-name">open-pipe*</span></span> OPEN_READ <span class="hljs-string"><span class="hljs-string">"lspci"</span></span>)) (<span class="hljs-name"><span class="hljs-name">str</span></span> (<span class="hljs-name"><span class="hljs-name">get-string-all</span></span> port))) (<span class="hljs-name"><span class="hljs-name">close-pipe</span></span> port) str)) (<span class="hljs-name"><span class="hljs-name">operating-system</span></span> (<span class="hljs-name"><span class="hljs-name">host-name</span></span> <span class="hljs-string"><span class="hljs-string">"..."</span></span>) <span class="hljs-comment"><span class="hljs-comment">;;... (kernel (cond ((string-match "Network controller: Intel Corporation Wireless 8888" *lspci*) linux-nonfree) (#t linux-libre))) (firmware (append (list linux-firmware-iwlwifi) %base-firmware))</span></span></code> </pre> <br>  Führen Sie dann die folgenden Schritte aus, um eine neue Systemkonfiguration zu installieren: <br><br><pre> <code class="bash hljs">sudo -E guix system reconfigure config.scm</code> </pre> <br>  Ohne einen neuen Kernel zu installieren, können Sie direkt ein Image erstellen, das zum Booten von einem USB-Laufwerk bereit ist. <br><br><h1>  Die Spiele </h1><br>  Da Guix-Pakete fortschrittliche Technologien verwenden (z. B. die neuesten Versionen von Mesa) und eine vollständige Kernel-Optimierung ermöglichen, ist dies eine ideale Plattform für Spiele und insbesondere zum <i>Verpacken von</i> Spielen! <br><br>  Leider ist die Spielebranche weit von einer Philosophie der freien Software entfernt, und nur sehr wenige Spiele werden im Rahmen des offiziellen Guix-Projekts verpackt. <br><br>  Obwohl Guix freie Software bevorzugt und keine Eigentumsrechte in seinem Repository akzeptiert, machen viele erweiterte Funktionen Guix ironischerweise zum idealen Paketmanager für proprietäre Software. <br><br>  Einige der Vorteile: <br><br><ul><li>  <code>guix environment</code> können Sie jede Anwendung in einem isolierten Container ausführen, der den Zugriff auf das Netzwerk einschränkt, das Dateisystem verbirgt (es besteht kein Risiko, dass das proprietäre Programm einige Ihrer Dateien stiehlt, z. B. Bitcoin Wallet- oder PGP-Schlüssel) und sogar Informationen auf Systemebene, z als Benutzername.  Dies ist erforderlich, um ein unzuverlässiges Closed-Source-Programm auszuführen. <br></li><li>  Funktionale Paketverwaltung: Closed-Source-Programme bestehen normalerweise nicht den Test der Zeit und brechen ab, wenn eine Bibliotheksabhängigkeit ihre API ändert.  Da Guix Pakete über jede Version einer Abhängigkeit definiert (ohne Konflikte mit dem aktuellen System), können Sie mit Guix Pakete für Spiele mit geschlossenem Quellcode erstellen, die für immer funktionieren. <br></li><li>  Reproduzierbare Umgebung: Closed-Source-Programme sind im Allgemeinen schlecht portiert und können sich auf Systemen mit leicht unterschiedlichen Abhängigkeiten unterschiedlich verhalten.  Die Reproduzierbarkeitseigenschaft von Guix impliziert, dass das Guix-Paket immer funktioniert, wenn es einmal funktioniert (mit Ausnahme eines Hardwareausfalls oder einer Änderung der Hardwarekonfiguration). </li></ul><br>  Aus diesen Gründen ist Guix ein ideales Tool zum Verpacken und Verteilen von Closed-Source-Spielen. <br><br>  Dies ist jedoch ein großes separates Thema, das besser für einen anderen Artikel übrig bleibt. <br><br><h1>  Tipps und Tricks </h1><br><h3>  Emacs-Guix </h3><br>  Einer der erstaunlichen Vorteile von Guix ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emacs-Guix-Oberfläche</a> , mit der Sie Pakete installieren und entfernen, selektiv aktualisieren, suchen, zur Paketdefinition übergehen, Generationen verwalten, die „Unterschiede“ zwischen ihnen drucken und vieles mehr. <br><br>  Es verfügt über Entwicklungsmodi für Assemblierung und Programmierung sowie eine spezielle interaktive Umgebung namens Scheme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">REPL</a> .  Dies ist eine einzigartige Benutzeroberfläche für das Betriebssystem. <br><br>  Es gibt auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm System Packages-</a> Oberfläche, die sich teilweise mit Emacs-Guix überschneidet, aber für schnelle Paketsuchen und schnelle Operationen für mich angenehmer erscheint. <br><br><h3>  Datenspeicherung </h3><br>  Da Guix mehrere Generationen von Systemkonfigurationen speichert (einschließlich des gesamten Paketverlaufs), benötigt es mehr Speicherplatz als andere Betriebssysteme. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach meiner Erfahrung musste die 25-GB-Partition im Jahr 2018 etwa einmal im Monat gereinigt werden (unter Berücksichtigung der großen Anforderungen an die Anzahl der Pakete), und die 50-GB-Partition kann ein ganzes Jahr lang unbeaufsichtigt bleiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist praktisch, den Befehl zum Bereinigen des Speichers zu verwenden </font></font><code>guix gc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber es können "zu viele Pakete" entfernt werden, dh Pakete, die beim nächsten Update sofort benötigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emacs-Guix verfügt über einen Befehl </font></font><code>mx guix-store-dead-item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem tote Pakete nach Größe sortiert und einzeln gelöscht werden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Abhängigkeiten analysieren müssen, schauen Sie sich </font></font><code>guix gc --references</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und an </font></font><code>guix gc --requisites</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies kann mit der Ausgabe kombiniert werden </font></font><code>guix build ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die verschiedenen Elemente des Abhängigkeitsgraphen anzuzeigen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Öffnen Sie beispielsweise die vom folgenden Befehl zurückgegebene Datei, um den Code für eines der Build-Skripte anzuzeigen: </font></font><br><br><pre> <code class="bash hljs">$ guix gc --references $(guix build -d coreutils) | grep builder /gnu/store/v02xky6f5rvjywd7ficzi5pyibbmk6cq-coreutils-8.29-guile-builder</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manifestierte Generation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist oft nützlich, ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manifest</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aller in einem Profil installierten Pakete </font><font style="vertical-align: inherit;">zu generieren </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann mit dem folgenden Guile-Skript erfolgen:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">use-modules</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> profiles) (<span class="hljs-name"><span class="hljs-name">ice-9</span></span> match) (<span class="hljs-name"><span class="hljs-name">ice-9</span></span> pretty-print)) (<span class="hljs-name"><span class="hljs-name">match</span></span> (<span class="hljs-name"><span class="hljs-name">command-line</span></span>) ((<span class="hljs-name"><span class="hljs-name">_</span></span> where) (<span class="hljs-name"><span class="hljs-name">pretty-print</span></span> `(specifications-&gt;manifest ',(map manifest-entry-name (manifest-entries (profile-manifest where)))))) (<span class="hljs-name"><span class="hljs-name">_</span></span> (<span class="hljs-name"><span class="hljs-name">error</span></span> <span class="hljs-string"><span class="hljs-string">"Please provide the path to a Guix profile."</span></span>)))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führen Sie es beispielsweise in Ihrem Profil aus </font></font><code>~/.guix-profile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="bash hljs">$ guile -s manifest-to-manifest.scm ~/.guix-profile</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punktedateien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfolgen den Verlauf der installierten Pakete. </font><font style="vertical-align: inherit;">Da ich auch die Version von Guix behalte, kann ich jederzeit in der Vergangenheit zum genauen Status meines Systems zurückkehren.</font></font><br><br><h1>  Referenzen </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einige Webschnittstellen: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guix-Paketliste</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlermeldung Tracker</font></font></a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wünsche</a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dokumente: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU Guix "Staging" -Code (</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> warum Lisp eine wichtige Rolle bei der Entwicklung spielte)</font></font><br></li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peters Notizen</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inoffizielle Pakete: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chrom-Paketkanal</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pakete von Oleg Pykhalov</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436938/">https://habr.com/ru/post/de436938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436924/index.html">Ein paar Worte zur Organisation von Roboterwettbewerben</a></li>
<li><a href="../de436926/index.html">Helden der Zwei-Faktor-Authentifizierung oder wie man "in den Schuhen anderer läuft"</a></li>
<li><a href="../de436928/index.html">WebRTC - noch einfacher (EasyRTC)</a></li>
<li><a href="../de436934/index.html">Naive Mathematik: der Mendocino-Motor und Earnshaws Theorem</a></li>
<li><a href="../de436936/index.html">Japanisches Atomlager in Primorje oder die Entsorgungsstelle der Atom-U-Boote der Pazifikflotte</a></li>
<li><a href="../de436940/index.html">Zwei-Faktor-Authentifizierungshelden, Teil zwei</a></li>
<li><a href="../de436942/index.html">10 sehenswerte Softwaretesttrends im Jahr 2019</a></li>
<li><a href="../de436944/index.html">Der nächste Schritt in der Flughafensicherheit</a></li>
<li><a href="../de436946/index.html">Röntgenerkennung: Präzision = 0,84, Rückruf = 0,96. Brauchen wir mehr Ärzte?</a></li>
<li><a href="../de436948/index.html">Die Zukunft der Rechenzentrumsinfrastrukturen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>