<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§˜ğŸ» ğŸ´ ğŸ”‘ Mapper sendiri atau sedikit tentang ExpressionTrees ğŸ¦‚ ğŸ¦ ğŸ‘©ğŸ¿â€ğŸ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang cara menulis AutoMapper Anda. Ya, saya benar-benar ingin memberi tahu Anda tentang ini, tetapi saya tidak bisa. F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapper sendiri atau sedikit tentang ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463961/"><img src="https://habrastorage.org/webt/ry/x_/sj/ryx_sj0phsfsrlfz1tcxy2_8izs.jpeg" alt="gambar"><br><br>  Hari ini kita akan berbicara tentang cara menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AutoMapper</a> Anda.  Ya, saya benar-benar ingin memberi tahu Anda tentang ini, tetapi saya tidak bisa.  Faktanya adalah bahwa solusi seperti itu sangat besar, memiliki sejarah coba-coba, dan juga sudah jauh untuk aplikasi.  Saya hanya bisa memberikan pemahaman tentang bagaimana ini bekerja, memberikan titik awal bagi mereka yang ingin memahami mekanisme kerja para "pemetaan".  Anda bahkan dapat mengatakan bahwa kami akan menulis sepeda kami. <br><a name="habracut"></a><br><h3>  Penafian </h3><br>  Saya ingatkan sekali lagi: kami akan menulis mapper primitif.  Jika Anda tiba-tiba memutuskan untuk memodifikasinya dan menggunakannya di prod - jangan lakukan ini.  Ambil solusi yang sudah jadi yang tahu tumpukan masalah di area subjek ini dan <i>sudah tahu bagaimana</i> menyelesaikannya.  Ada beberapa alasan yang kurang lebih signifikan untuk menulis dan menggunakan mapper sepeda Anda: <br><br><ul><li>  Perlu beberapa penyesuaian khusus. </li><li> Anda memerlukan kinerja maksimum dalam kondisi Anda dan Anda siap untuk mengisi kerucut. </li><li>  Anda ingin memahami cara kerja mapper. </li><li>  Anda suka bersepeda. </li></ul><br><h3>  Apa yang disebut kata "mapper"? </h3><br>  Ini adalah subsistem yang bertanggung jawab untuk mengambil objek dan mengonversi (menyalin nilainya) ke yang lain.  Tugas khas adalah mengubah DTO menjadi objek lapisan bisnis.  Mapper yang paling primitif â€œdijalankanâ€ melalui properti dari sumber data dan membandingkannya dengan properti dari tipe data yang akan di-output.  Setelah pencocokan, nilai diekstraksi dari sumber dan ditulis ke objek, yang akan menjadi hasil konversi.  Di suatu tempat di sepanjang jalan, kemungkinan besar, masih akan diperlukan untuk menciptakan "hasil" ini. <br><br>  Bagi konsumen, mapper adalah layanan yang menyediakan antarmuka berikut: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Saya menekankan: ini adalah antarmuka yang paling primitif, yang, dari sudut pandang saya, nyaman untuk penjelasan.  Pada kenyataannya, kita kemungkinan besar akan berurusan dengan mapper yang lebih spesifik (IMapper &lt;TIn, TOut&gt;) atau dengan fasad yang lebih umum (IMapper), yang dengan sendirinya akan memilih mapper spesifik untuk jenis objek input-output yang ditentukan. <br><br><h3>  Implementasi naif </h3><br>  Catatan: bahkan implementasi naif dari mapper membutuhkan pengetahuan dasar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reflection</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ExpressionTrees</a> .  Jika Anda belum mengikuti tautan atau mendengar apa pun tentang teknologi ini - lakukan, baca.  Saya berjanji dunia tidak akan pernah sama. <br><br>  Namun, kami menulis mapper Anda sendiri.  Untuk memulai, mari kita dapatkan semua properti ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PropertyInfo</a> ) dari tipe data yang akan di-output (selanjutnya saya akan menyebutnya <b>TOUT</b> ).  Ini cukup sederhana: kita tahu jenisnya, karena kita menulis implementasi kelas generik yang diparameterisasi dengan tipe TOut.  Selanjutnya, dengan menggunakan instance dari kelas Type, kita mendapatkan semua propertinya. <br><br><pre> <code class="cs hljs">Type outType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut); PropertyInfo[] outProperties = outType.GetProperties();</code> </pre><br>  Saat mendapatkan properti, saya menghilangkan fitur.  Misalnya, beberapa di antaranya mungkin tanpa fungsi setter, beberapa mungkin ditandai sebagai diabaikan oleh atribut, beberapa mungkin dengan akses khusus.  Kami sedang mempertimbangkan opsi paling sederhana. <br><br>  Kami melangkah lebih jauh.  Akan lebih baik untuk dapat membuat turunan dari tipe TOut, yaitu objek yang kita "peta" objek yang masuk.  Di C #, ada beberapa cara untuk melakukan ini.  Sebagai contoh, kita dapat melakukan ini: System.Activator.CreateInstance ().  Atau bahkan hanya TOut baru (), tetapi untuk ini Anda perlu membuat batasan untuk TOut, yang tidak ingin Anda lakukan di antarmuka umum.  Namun, kami berdua tahu sesuatu tentang ExpressionTrees, yang berarti kami bisa melakukannya seperti ini: <br><br><pre> <code class="cs hljs">ConstructorInfo outConstructor = outType.GetConstructor(Array.Empty&lt;Type&gt;()); Func&lt;TOut&gt; activator = outConstructor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"Default constructor for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{outType.Name}</span></span></span><span class="hljs-string"> not found"</span></span>) : Expression.Lambda&lt;Func&lt;TOut&gt;&gt;(Expression.New(outConstructor)).Compile();</code> </pre><br>  Kenapa begitu?  Karena kita tahu bahwa instance kelas Type dapat memberikan informasi tentang konstruktor apa yang dimilikinya - ini sangat cocok untuk kasus ketika kita memutuskan untuk mengembangkan mapper kita sehingga kita akan meneruskan data apa pun ke konstruktor.  Kami juga belajar lebih banyak tentang ExpressionTrees, yaitu, mereka memungkinkan plak untuk membuat dan mengkompilasi kode, yang kemudian dapat digunakan kembali.  Dalam kasus ini, ini adalah fungsi yang benar-benar terlihat seperti () =&gt; new TOut (). <br><br>  Sekarang Anda perlu menulis metode mapper utama, yang akan menyalin nilai-nilai.  Kita akan pergi dengan cara yang paling sederhana: kita pergi melalui properti dari objek yang datang kepada kita di pintu masuk, dan mencari properti dengan nama yang sama di antara properti dari objek yang keluar.  Jika ditemukan - salin, jika tidak - pindah. <br><br><pre> <code class="cs hljs">TOut outInstance = _activator(); PropertyInfo[] sourceProperties = source.GetType().GetProperties(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceProperties.Length; i++) { PropertyInfo sourceProperty = sourceProperties[i]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = sourceProperty.Name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_outProperties.TryGetValue(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> PropertyInfo outProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceValue = sourceProperty.GetValue(source); outProperty.SetValue(outInstance, sourceValue); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outInstance;</code> </pre><br>  Dengan demikian, kami telah sepenuhnya membentuk kelas <a href="">BasicMapper</a> .  Anda dapat membiasakan diri dengan tes-tesnya di <a href="">sini</a> .  Harap perhatikan bahwa sumber dapat berupa objek jenis apa pun atau objek anonim. <br><br><h3>  Performa dan tinju </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Refleksi itu</a> bagus, tetapi lambat.  Selain itu, penggunaannya yang sering meningkatkan lalu lintas memori, yang berarti memuat GC, yang berarti memperlambat aplikasi lebih banyak lagi.  Misalnya, kami hanya menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PropertyInfo.SetValue</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PropertyInfo.GetValue</a> .  Metode GetValue mengembalikan objek di mana nilai tertentu dibungkus (tinju).  Ini artinya kami menerima alokasi dari awal. <br><br>  Pemetaan biasanya terletak di mana Anda perlu mengubah satu objek menjadi yang lain ... Tidak, bukan satu, tetapi banyak objek.  Misalnya, ketika kita mengambil sesuatu dari database.  Di tempat ini, saya ingin melihat kinerja normal dan tidak kehilangan memori pada operasi dasar. <br><br>  Apa yang bisa kita lakukan  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ExpressionTrees</a> akan membantu kami lagi.  Faktanya adalah. NET memungkinkan Anda untuk membuat dan mengkompilasi kode "on the fly": kami menggambarkannya dalam representasi objek, katakan apa dan di mana kami akan menggunakannya ... dan kompilasi.  Hampir tidak ada sihir. <br><br><h3>  Mapper yang dikompilasi </h3><br>  Sebenarnya, semuanya relatif sederhana: kami sudah melakukan yang baru dengan Expression.New (ConstructorInfo).  Anda mungkin telah memperhatikan bahwa metode New statis disebut persis sama dengan operator.  Faktanya adalah bahwa hampir semua sintaks C # tercermin dalam bentuk metode statis dari kelas Ekspresi.  Jika ada sesuatu yang hilang, itu berarti Anda mencari apa yang disebut  "Gula sintaksis." <br><br>  Berikut ini beberapa operasi yang akan kami gunakan di mapper kami: <br><br><ul><li>  Deklarasi variabel - Ekspresi. Variabel (Jenis, string).  Argumen Type memberitahu tipe variabel apa yang akan dibuat, dan string adalah nama variabel. </li><li>  Penugasan - Ekspresi. Menugaskan (Ekspresi, Ekspresi).  Argumen pertama adalah apa yang kita tetapkan, dan argumen kedua adalah apa yang kita tetapkan. </li><li>  Akses ke properti objek adalah Expression.Property (Expression, PropertyInfo).  Ekspresi adalah pemilik properti, dan PropertyInfo adalah representasi objek dari properti yang diperoleh melalui Refleksi. </li></ul><br>  Dengan pengetahuan ini, kita bisa membuat variabel, mengakses properti objek, dan menetapkan nilai ke properti objek.  Kemungkinan besar, kami juga memahami bahwa ExpressionTree perlu dikompilasi menjadi delegasi dari bentuk <b>Fungsi &lt;objek, TOut&gt;</b> .  Rencananya adalah ini: kita mendapatkan variabel yang berisi data input, membuat instance bertipe TOut dan membuat ekspresi yang menetapkan satu properti ke yang lain. <br><br>  Sayangnya, kode ini tidak terlalu kompak, jadi saya sarankan Anda melihat implementasi <a href="">CompiledMapper</a> segera.  Saya membawa ke sini hanya poin-poin penting. <br><br>  Pertama, kita membuat representasi objek dari parameter fungsi kita.  Karena mengambil objek sebagai input, objek akan menjadi parameter. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameter = Expression.Parameter(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>), <span class="hljs-string"><span class="hljs-string">"source"</span></span>);</code> </pre><br>  Selanjutnya, kita membuat dua variabel dan daftar Ekspresi di mana kita akan secara berurutan menambahkan ekspresi penugasan.  Urutan itu penting, karena begitulah perintah akan dieksekusi ketika kita memanggil metode yang dikompilasi.  Misalnya, kami tidak dapat menetapkan nilai ke variabel yang belum dideklarasikan. <br><br>  Lebih jauh, dengan cara yang sama seperti dalam kasus implementasi naif, kita melihat daftar properti tipe dan mencoba mencocokkannya dengan nama.  Namun, alih-alih segera menetapkan nilai, kami membuat ekspresi untuk mengekstraksi nilai dan menetapkan nilai untuk setiap properti terkait. <br><br><pre> <code class="cs hljs">Expression sourceValue = Expression.Property(sourceInstance, sourceProperty); Expression outValue = Expression.Property(outInstance, outProperty); expressions.Add(Expression.Assign(outValue, sourceValue));</code> </pre><br>  Poin penting: setelah kita membuat semua operasi penugasan, kita perlu mengembalikan hasilnya dari fungsi.  Untuk melakukan ini, ekspresi terakhir dalam daftar harus berupa Ekspresi, yang berisi instance kelas yang kami buat.  Saya meninggalkan komentar di sebelah baris ini.  Mengapa perilaku yang terkait dengan kata kunci kembali di ExpressionTree terlihat seperti ini?  Saya khawatir ini masalah tersendiri.  Sekarang saya sarankan agar mudah diingat. <br><br>  Ya, pada akhirnya, kita harus mengkompilasi semua ekspresi yang kita buat.  Apa yang kami minati di sini?  Variabel tubuh berisi "tubuh" fungsi.  "Fungsi normal" memiliki tubuh, bukan?  Nah, yang kami sertakan dalam kurung kurawal.  Jadi, Expression. Blocklock persis seperti itu.  Karena kurung kurawal juga merupakan ruang lingkup, kita harus memberikan variabel yang akan digunakan di sana - dalam case sourceInstance dan outInstance kita. <br><br><pre> <code class="cpp hljs">var body = Expression.Block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {sourceInstance, outInstance}, expressions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;object, TOut&gt;&gt;(body, parameter).Compile();</code> </pre><br>  Pada output, kita mendapatkan Func &lt;object, TOut&gt;, i.e.  fungsi yang dapat mengkonversi data dari satu objek ke objek lainnya.  Mengapa kesulitan seperti itu, Anda bertanya?  Saya mengingatkan Anda bahwa, pertama, kami ingin menghindari tinju saat menyalin nilai ValueType, dan kedua, kami ingin meninggalkan metode PropertyInfo.GetValue dan PropertyInfo.SetValue, karena agak lambat. <br><br>  Kenapa tidak bertinju?  Karena ExpressionTree yang dikompilasi adalah IL nyata, dan untuk runtime, sepertinya (hampir) seperti kode Anda.  Mengapa "kompilasi mapper" lebih cepat?  Sekali lagi: karena itu hanyalah IL biasa.  Ngomong-ngomong, kami dapat dengan mudah mengkonfirmasi kecepatan menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BenchmarkDotNet</a> , dan tolok ukur itu sendiri dapat dilihat di <a href="">sini</a> . <br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th><th>  Dialokasikan </th></tr></thead><tbody><tr><td>  Pemeta Otomatis </td><td>  1.291,6 kita </td><td>  3.3173 kami </td><td>  3.1030 kami </td><td>  1,00 </td><td>  312,5 KB </td></tr><tr><td>  Velo_BasicMapper </td><td>  11.987,0 kami </td><td>  33.8389 kami </td><td>  28.2570 kami </td><td>  9.28 </td><td>  3437.5 KB </td></tr><tr><td>  Velo_CompiledMapper </td><td>  341.3 kita </td><td>  2.8230 kami </td><td>  2.6407 kami </td><td>  0,26 </td><td>  312,5 KB </td></tr></tbody></table></div><br>  Di kolom Rasio, "CompiledMapper" (CompiledMapper) menunjukkan hasil yang sangat baik, bahkan dibandingkan dengan AutoMapper (ini adalah baseline, mis. 1).  Namun, jangan bersukacita: AutoMapper memiliki kemampuan yang jauh lebih besar dibandingkan dengan motor kami.  Dengan plat ini saya hanya ingin menunjukkan bahwa ExpressionTrees jauh lebih cepat daripada "pendekatan Refleksi klasik". <br><br><h3>  Ringkasan </h3><br>  Saya harap saya bisa menunjukkan bahwa menulis mapper Anda cukup sederhana.  Reflection dan ExpressionTrees adalah alat yang sangat kuat yang digunakan pengembang untuk menyelesaikan banyak tugas berbeda.  Ketergantungan injeksi, Serialization / Deserialization, repositori CRUD, membangun query SQL, menggunakan bahasa lain sebagai skrip untuk aplikasi .NET - semua ini dilakukan dengan menggunakan Reflection, Reflection.Emit dan ExpressionTrees. <br><br>  Bagaimana dengan mapper?  Mapper adalah contoh yang bagus untuk mempelajari semua ini. <br><br>  PS: Jika Anda ingin ExpressionTrees lagi, saya sarankan membaca tentang bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat konverter JSON Anda</a> menggunakan teknologi ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463961/">https://habr.com/ru/post/id463961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463943/index.html">Kesengsaraan unicorn hitam</a></li>
<li><a href="../id463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../id463953/index.html">Menerapkan Pola Desain Perintah di Unity</a></li>
<li><a href="../id463955/index.html">Bagaimana mengembangkan konsep untuk mengubah platform IP? Instruksi untuk digunakan</a></li>
<li><a href="../id463957/index.html">Bagaimana cara menyebarkan daftar wawancara yang terhubung sendiri</a></li>
<li><a href="../id463963/index.html">Pengenalan wajah di lokasi konstruksi</a></li>
<li><a href="../id463965/index.html">Aplikasi typeset di LaTeX</a></li>
<li><a href="../id463969/index.html">Anggaran Keluarga Telegram</a></li>
<li><a href="../id463971/index.html">Catatan Pentester: Pelindung Kasus</a></li>
<li><a href="../id463975/index.html">Lingkungan Modern untuk Bereaksi Aplikasi Asli</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>