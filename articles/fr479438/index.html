<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛 🐯 🙌🏼 Postgres-Tuesday # 5: «PostgreSQL et Kubernetes. CI / CD. Automatisation des tests » 👰🏻 🧘🏿 🧓🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À la fin de l'année dernière, une autre diffusion en direct de la communauté russe PostgreSQL #RuPostgres a eu lieu , au cours de laquelle son co-fond...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres-Tuesday # 5: «PostgreSQL et Kubernetes. CI / CD. Automatisation des tests »</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/479438/"><img src="https://habrastorage.org/webt/qm/rm/ln/qmrmlnm8gjj_8gih4dzhy2ybrvy.jpeg"><br><br>  À la fin de l'année dernière, une autre diffusion en direct de la communauté russe PostgreSQL <a href="https://www.meetup.com/postgresqlrussia/">#RuPostgres a eu lieu</a> , au cours de laquelle son co-fondateur Nikolai Samokhvalov a parlé avec le directeur technique de Flanta Dmitry Stolyarov de ce SGBD dans le contexte de Kubernetes. <br><br>  Nous publions une transcription du corps principal de cette discussion, et une vidéo complète a été publiée <a href="https://www.youtube.com/channel/UC0SBGSNmBLrTZIkbN-lJHnw">sur la chaîne YouTube de la communauté</a> : <a name="habracut"></a><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qXc9VTr4TFc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bases de données et Kubernetes </h2><br>  <i><b>NS</b> : Nous ne parlerons pas de vide et de points de contrôle aujourd'hui.</i>  <i>Nous voulons parler de Kubernetes.</i>  <i>Je sais que vous avez de nombreuses années d'expérience.</i>  <i>J'ai regardé vos vidéos et même revu certaines des pièces ... Allons-y tout de suite: pourquoi Postgres ou MySQL dans K8s?</i> <br><br>  <b>DS</b> : Il n'y a pas de réponse unique à cette question et elle ne peut pas l'être.  Mais en général, c'est la simplicité et la commodité ... le potentiel.  Après tout, tout le monde veut des services gérés. <br><br>  <i><b>NS</b> : Pour aimer <a href="https://aws.amazon.com/rds/">RDS</a> , uniquement à la maison?</i> <br><br>  <b>DS</b> : Oui: pour aimer RDS, seulement n'importe où. <br><br>  <i><b>NS</b> : «N'importe où» est un bon point.</i>  <i>Dans les grandes entreprises, tout est situé à différents endroits.</i>  <i>Et pourquoi alors, s'il s'agit d'une grande entreprise, ne prenez pas une solution toute faite?</i>  <i>Par exemple, Nutanix a ses propres développements, tandis que d'autres sociétés (VMware ...) ont le même «RDS, uniquement à domicile».</i> <br><br>  <b>DS</b> : Mais nous parlons d'une implémentation unique qui ne fonctionnera que sous certaines conditions.  Et si nous parlons de Kubernetes, il existe une grande variété d'infrastructures (qui peuvent être dans les K8).  C'est essentiellement la norme pour l'API vers le cloud ... <br><br>  <i><b>NS</b> : C'est gratuit aussi!</i> <br><br>  <b>DS</b> : Ce n'est pas si important.  La gratuité n'est pas importante pour un très grand segment du marché.  Une autre chose est importante ... Vous vous souvenez probablement du rapport " <a href="https://habr.com/ru/company/flant/blog/431500/">Bases de données et Kubernetes</a> "? <br><br>  <i><b>NS</b> : Oui.</i> <br><br>  <b>DS</b> : J'ai réalisé qu'il était perçu de manière très ambiguë.  Certaines personnes pensaient que je disais: "Les gars, nous sommes allés toutes les bases de données à Kubernetes!", Tandis que d'autres ont décidé que ce sont tous des vélos terribles.  Et je voulais dire autre chose: «Regardez ce qui se passe, quels sont les problèmes et comment ils peuvent être résolus.  Allez maintenant des bases à Kubernetes?  La production?  Eh bien, seulement si vous aimez ... faire certaines choses.  Mais pour les développeurs, je peux dire que je le recommande.  Pour les développeurs, la création / suppression dynamique d'environnements est très importante. » <br><br>  <i>NS: Par dev, voulez-vous dire tous les environnements qui ne sont pas prod?</i>  <i>Mise en scène, QA ...</i> <br><br>  <b>DS</b> : Si nous parlons de stands de perf, ce n'est probablement pas déjà le cas, car les exigences y sont spécifiques.  Si nous parlons de cas particuliers où la mise en scène a besoin d'une très grande base de données, alors probablement pas non plus ... S'il s'agit d'un environnement statique, de longue durée, alors quel est l'avantage d'avoir la base située dans les K8? <br><br>  <i><b>NS</b> : Aucun.</i>  <i>Mais où voit-on des environnements statiques?</i>  <i>L'environnement statique est dépassé demain.</i> <br><br>  <b>DS</b> : la mise en scène peut être statique.  Nous avons des clients ... <br><br>  <i><b>NS</b> : Oui, je l'ai aussi.</i>  <i>Le gros problème est que si vous avez une base de 10 To et une mise en scène - 200 Go ...</i> <br><br>  <b>DS</b> : J'ai un étui très cool!  Lors de la mise en scène, il existe une base prod'ovy dans laquelle des modifications sont apportées.  Et un bouton est fourni: "déploiement en production".  Ces changements - deltas - sont ajoutés (il semble, ils sont juste synchronisés par les API) en production.  C'est une option très exotique. <br><br>  <i><b>NS</b> : J'ai vu des startups dans la vallée qui sont encore assis dans RDS ou même dans Heroku - ce sont des histoires d'il y a 2-3 ans - et ils téléchargent le vidage sur leur ordinateur portable.</i>  <i>Parce que la base ne fait que 80 Go jusqu'à présent, et qu'il y a une place sur l'ordinateur portable.</i>  <i>Ensuite, ils achètent des disques pour tout le monde, afin qu'ils aient 3 bases, afin qu'ils puissent effectuer différents développements.</i>  <i>Cela arrive aussi.</i>  <i>J'ai également vu qu'ils n'avaient pas peur de copier la prod dans la mise en scène - cela dépend beaucoup de l'entreprise.</i>  <i>Mais il a vu qu'ils avaient très peur et que souvent ils n'avaient pas assez de temps et de mains.</i>  <i>Mais avant de passer à ce sujet, je veux entendre parler de Kubernetes.</i>  <i>Je comprends bien que dans prod'e jusqu'ici personne?</i> <br><br>  <b>DS</b> : Nous avons de petites bases en prod.  Nous parlons de volumes de dizaines de gigaoctets et de services non critiques, pour lesquels il était trop paresseux pour faire des répliques (et il n'y a pas un tel besoin).  Et à condition que sous Kubernetes il y ait un stockage normal.  Cette base de données fonctionnait dans une machine virtuelle - conditionnellement dans VMware, en plus du stockage.  Nous l'avons placé en <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">PV</a> et maintenant nous pouvons le transférer de voiture en voiture. <br><br>  <i><b>NS</b> : Des bases de cette taille, jusqu'à 100 Go, sur de bons disques et avec un bon réseau peuvent être déployées en quelques minutes, non?</i>  <i>Une vitesse de 1 Go par seconde n'est plus exotique.</i> <br><br>  <b>DS</b> : Oui, pour une opération linéaire ce n'est pas un problème. <br><br>  <i><b>NS</b> : D'accord, nous ne devrions penser qu'à prod.</i>  <i>Et si nous considérons Kubernetes pour les environnements non prod - comment le faire?</i>  <i>Je vois qu'à Zalando <a href="https://github.com/zalando/postgres-operator">ils font un opérateur</a> , à Crunchy ils <a href="https://github.com/CrunchyData/postgres-operator">scient</a> , il y a d'autres options.</i>  <i>Et il y a <a href="https://ongres.com/">OnGres</a> - c'est notre bon ami espagnol Alvaro: ils ne sont pas seulement un <a href="https://habr.com/ru/company/flant/blog/326414/">opérateur</a> , mais une distribution entière ( <a href="https://gitlab.com/ongresinc/stackgres">StackGres</a> ), dans laquelle, en plus de Postgres lui-même, ils ont également décidé de bourrer la sauvegarde, le proxy Envoy ...</i> <br><br>  <b>DS</b> : Envoyé pour quoi?  L'équilibrage du trafic Postgres exactement? <br><br>  <i><b>NS</b> : Oui.</i>  <i>Autrement dit, ils le voient comme: si vous prenez la distribution Linux et le noyau, alors le PostgreSQL habituel est le noyau, et ils veulent faire une distribution qui est compatible avec le cloud et fonctionne sur Kubernetes.</i>  <i>Ils ancrent les composants (sauvegardes, etc.) et déboguent pour qu'ils fonctionnent bien.</i> <br><br>  <b>DS</b> : Très cool!  En substance, c'est un logiciel pour créer vos Postgres gérés. <br><br>  <i><b>NS</b> : les distributions Linux ont des problèmes éternels: comment créer des pilotes pour que tout le matériel soit pris en charge.</i>  <i>Et ils ont l'idée de travailler chez Kubernetes.</i>  <i>Je sais que chez l'opérateur Zalando, nous avons récemment vu les globes oculaires sur AWS et ce n'est pas très bon.</i>  <i>Il ne devrait pas y avoir de liens avec une infrastructure spécifique - à quoi bon alors?</i> <br><br>  <b>DS</b> : Je ne sais pas dans quelle situation spécifique Zalando s'est impliqué, mais dans Kubernetes, le stockage est désormais réalisé de telle manière qu'il est impossible de supprimer une sauvegarde de disque de manière générique.  Récemment, la norme - dans la dernière version de <a href="https://habr.com/ru/company/flant/blog/465417/">la spécification CSI</a> - a rendu possible les instantanés, mais où est-elle implémentée?  Honnêtement, c'est toujours aussi brut ... Nous essayons CSI par-dessus AWS, GCE, Azure, vSphere, mais nous commençons à l'utiliser un peu, car vous pouvez voir qu'il n'est pas encore prêt. <br><br>  <i><b>NS</b> : Par conséquent, il faut parfois se rattacher à l'infrastructure.</i>  <i>Je pense que ce n'est encore qu'un stade précoce - des problèmes de croissance.</i>  <i>Question: que recommanderiez-vous aux débutants qui souhaitent essayer PgSQL dans les K8?</i>  <i>Quel opérateur peut-être?</i> <br><br>  <b>DS</b> : Le problème est que pour nous, Postgres est de 3%.  Nous avons toujours une très grande liste de différents logiciels dans Kubernetes, je ne vais même pas tout énumérer.  Par exemple, Elasticsearch.  Il y a beaucoup d'opérateurs: certains se développent activement, d'autres non.  Pour nous, nous avons fait des exigences qui devraient être dans l'opérateur, afin que nous le prenions au sérieux.  L'opérateur est spécifiquement pour Kubernetes - pas "l'opérateur pour faire quelque chose dans les conditions d'Amazon ..." En fait, nous utilisons un seul opérateur assez largement (= pour presque tous les clients) - <a href="https://github.com/spotahome/redis-operator">pour Redis</a> <i>(nous publierons bientôt un article à ce sujet)</i> . <br><br>  <i><b>NS</b> : Mais pour MySQL aussi?</i>  <i>Je sais que Percona ... puisqu'ils sont maintenant impliqués dans MySQL, MongoDB et Postgres, ils devront avoir une sorte d'entaille universelle: pour toutes les bases de données, pour tous les fournisseurs de cloud.</i> <br><br>  <b>DS</b> : Nous n'avons pas eu le temps de regarder les déclarations pour MySQL.  Pour nous, ce n'est pas l'objectif principal maintenant.  MySQL fonctionne très bien en autonome.  Pourquoi un opérateur, si vous pouvez simplement démarrer la base de données ... Vous pouvez démarrer le conteneur Docker avec Postrges, ou vous pouvez le démarrer de manière simple. <br><br>  <i><b>NS</b> : C'était aussi une question.</i>  <i>Pas d'opérateur du tout?</i> <br><br>  <b>DS</b> : Oui, 100% d'entre nous ont PostgreSQL fonctionnant sans opérateur.  Jusqu'à présent.  Nous utilisons activement l'opérateur pour Prometheus, pour Redis.  Nous avons l'intention de trouver un opérateur pour Elasticsearch - il brûle le plus parce que nous voulons l'installer dans 100% des cas à Kubernetes.  Tout comme nous voulons nous assurer que MongoDB est toujours également installé dans Kubernetes.  Certaines listes de souhaits apparaissent ici - on a le sentiment que dans ces cas, quelque chose peut être fait.  Et à propos de Postgres, nous n'avons même pas regardé.  Bien sûr, nous connaissons l'existence de différentes options, mais en fait, nous en avons une autonome. <br><br><h2>  Tester la base de données dans Kubernetes </h2><br>  <i><b>NS</b> : Passons au sujet des tests.</i>  <i>Comment déployer les modifications dans la base de données - du point de vue de la perspective DevOps.</i>  <i>Il y a des microservices, de nombreuses bases de données, tout le temps quelque part quelque chose change.</i>  <i>Comment garantir un CI / CD normal afin que tout soit en ordre à partir de la position du SGBD.</i>  <i>Quelle est votre approche?</i> <br><br>  <b>DS</b> : Il ne peut y avoir qu'une seule réponse.  Il existe plusieurs options.  Le premier est la taille de la base que nous voulons déployer.  Vous avez vous-même mentionné que les entreprises ont une attitude différente à l'idée d'avoir une copie de la base de production sur le développement et la scène. <br><br>  <i><b>NS</b> : Et en termes de RGPD, je pense qu'ils sont de plus en plus soignés ... Je peux dire qu'en Europe, ils ont déjà commencé à aller bien.</i> <br><br>  <b>DS</b> : Mais vous pouvez souvent écrire des logiciels qui déchargent la production et la brouillent.  Il s'avère que les données prod'ovye (snapshot, dump, copie binaire ...), mais elles sont anonymes.  Au lieu de cela, il peut y avoir des scripts de génération: il peut s'agir de fixtures ou simplement d'un script qui génère une grande base de données.  Le problème est quoi: combien de temps prend l'image de base pour être créée?  Et combien de temps pour le déployer sur le bon environnement? <br><br>  Nous sommes arrivés au schéma: si le client a un ensemble de données de fixture (version minimale de la base de données), alors par défaut nous les utilisons.  Si nous parlons d'environnements d'examen, lorsque nous avons créé une branche, nous avons déployé une instance d'application - nous y déployons une petite base de données.  Mais l' <a href="https://habr.com/ru/company/flant/blog/417509/">option</a> s'est avérée bien, lorsque nous supprimons le vidage de la production une fois par jour (la nuit) et collectons sur sa base un conteneur Docker avec PostgreSQL et MySQL avec ces données chargées.  Si vous devez déployer la base 50 fois à partir de cette image, cela se fait assez simplement et rapidement. <br><br>  <i><b>NS</b> : Copie simple?</i> <br><br>  <b>DS</b> : les données sont stockées directement dans l'image Docker.  C'est-à-dire  nous avons une image prête à l'emploi, bien que 100 Go.  Grâce aux couches de Docker, nous pouvons rapidement déployer cette image autant de fois que nécessaire.  La méthode est stupide, mais elle fonctionne plutôt bien. <br><br>  <i><b>NS</b> : De plus, lors des tests, cela change directement à l'intérieur du Docker, non?</i>  <i>Copie sur écriture dans Docker - jetez-le et recommencez, tout va bien.</i>  <i>Classe!</i>  <i>Et vous l'utilisez déjà avec might et main?</i> <br><br>  <b>DS</b> : Pendant longtemps. <br><br>  <i><b>NS</b> : Nous faisons des choses très similaires.</i>  <i>Seulement, nous n'utilisons pas la copie sur écriture de Docker, mais quelques autres.</i> <br><br>  <b>JS</b> : Il n'est pas générique.  Et Docker'ny fonctionne partout. <br><br>  <i><b>NS</b> : En théorie, oui.</i>  <i>Mais nous avons également des modules là-bas, vous pouvez créer différents modules et travailler avec différents systèmes de fichiers.</i>  <i>Quel moment.</i>  <i>De Postgres, nous regardons tout cela différemment.</i>  <i>Maintenant, j'ai regardé du côté de Docker et j'ai vu que tout fonctionnait pour vous.</i>  <i>Mais si la base de données est énorme, par exemple, 1 To, alors c'est tout long: à la fois les opérations de nuit et tout bourrer dans Docker ... Et si 5 To sont bourrés dans Docker ... Ou est-ce que tout est normal?</i> <br><br>  <b>DS</b> : Quelle différence cela fait-il: ce sont des blobs, juste des bits et des octets. <br><br>  <i><b>NS</b> : La différence est la suivante: faites-vous cela via le vidage et la restauration?</i> <br><br>  <b>DS</b> : Pas du tout nécessaire.  Les méthodes de génération de cette image peuvent être différentes. <br><br>  <i><b>NS</b> : Pour certains clients, nous avons fait en sorte qu'au lieu de générer régulièrement une image de base, nous la maintenions constamment à jour.</i>  <i>Il s'agit essentiellement d'une réplique, mais les données ne sont pas reçues directement du maître, mais via l'archive.</i>  <i>L'archive binaire où les WAL sont roulés tous les jours, les sauvegardes y sont également supprimées ... Ces WAL volent ensuite - avec un léger retard (littéralement 1-2 secondes) - vers l'image de base.</i>  <i>Nous le clonons de quelque façon que ce soit - nous avons maintenant ZFS par défaut.</i> <br><br>  <b>DS</b> : Mais avec ZFS, vous êtes limité à un seul nœud. <br><br>  <i><b>NS</b> : Oui.</i>  <i>Mais ZFS a aussi un <a href="https://docs.oracle.com/cd/E18752_01/html/819-5461/gbchx.html">envoi</a> magique: vous pouvez envoyer un instantané avec lui et même (je ne l'ai pas encore vraiment testé, mais ...) vous pouvez envoyer un delta entre deux <code>PGDATA</code> .</i>  <i>En fait, nous avons un autre outil que nous n'avons pas particulièrement pris en compte pour de telles tâches.</i>  <i>PostgreSQL a <a href="https://www.postgresql.org/docs/12/app-pgrewind.html">pg_rewind</a> , qui fonctionne comme une rsync «intelligente», sautant beaucoup de choses que vous n’avez pas à regarder, car rien n’a changé à coup sûr.</i>  <i>Nous pouvons effectuer une synchronisation rapide entre les deux serveurs et rembobiner exactement de la même manière.</i> <br><br>  <i>Donc, nous essayons sur ce point, plus DBA'noy, de créer un outil qui vous permet de faire la même chose que vous avez dit: nous avons une base, mais nous voulons tester quelque chose 50 fois, presque en même temps.</i> <br><br>  <b>DS</b> : 50 fois signifie que vous devez commander 50 instances Spot. <br><br>  <i><b>NS</b> : Non, nous faisons tout sur une seule machine.</i> <br><br>  <b>DS</b> : Mais comment déployez-vous 50 fois si cette base est, disons, un téraoctet.  Très probablement, elle a besoin conditionnellement de 256 Go de RAM? <br><br>  <i><b>NS</b> : Oui, parfois beaucoup de mémoire est nécessaire - c'est normal.</i>  <i>Mais un tel exemple de la vie.</i>  <i>La machine de production a 96 cœurs et 600 Go.</i>  <i>Dans le même temps, 32 cœurs sont utilisés pour la base de données (même 16 cœurs sont parfois désormais utilisés) et 100 à 120 Go de mémoire.</i> <br><br>  <b>DS</b> : Et 50 exemplaires y entrent? <br><br>  <i><b>NS</b> : Il n'y a donc qu'une seule copie, puis la copie sur écriture (ZFS'ny) fonctionne ... Je vais vous en dire plus.</i> <br><br>  <i>Par exemple, nous avons une base de 10 To.</i>  <i>Ils ont fait un disque pour cela, ZFS a encore réduit sa taille en pourcentage de 30 à 40.</i>  <i>Comme nous ne faisons pas de test de charge, le temps de réponse exact n'est pas important pour nous: laissez-le être jusqu'à 2 fois plus lent - c'est correct.</i> <br><br>  <i>Nous permettons aux programmeurs, QA, DBA, etc.</i>  <i>Effectuez des tests dans 1-2 threads.</i>  <i>Par exemple, ils peuvent démarrer une sorte de migration.</i>  <i>Il ne nécessite pas 10 cœurs à la fois - il a besoin de 1 backend Postgres, 1 core.</i>  <i>La migration commencera - peut-être que le <a href="https://www.postgresql.org/docs/12/routine-vacuuming.html">vide automatique</a> démarrera toujours, puis le deuxième noyau sera activé.</i>  <i>Nous avons alloué 16 à 32 cœurs, donc 10 personnes peuvent travailler simultanément, il n'y a aucun problème.</i> <br><br>  <i>Étant donné que <code>PGDATA</code> physiquement le même, il s'avère que nous trompons réellement Postgres.</i>  <i>L'astuce est la suivante: elle démarre, par exemple, 10 Postgres en même temps.</i>  <i>Quel problème est généralement quoi?</i>  <i>Ils ont <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html">mis les tampons partagés</a> , disons, à 25%.</i>  <i>En conséquence, cela fait 200 Go.</i>  <i>Vous n'en démarrerez pas plus de trois, car la mémoire se terminera.</i> <br><br>  <i>Mais à un moment donné, nous avons réalisé que ce n'était pas nécessaire: nous avons défini shared_buffers sur 2 Go.</i>  <i>PostgreSQL a <a href="https://www.postgresql.org/docs/current/runtime-config-query.html">effective_cache_size</a> , et en réalité, cela n'affecte que les <a href="https://en.wikipedia.org/wiki/Query_plan">plans</a> .</i>  <i>Nous le mettons à 0,5 To.</i>  <i>Et peu importe qu’ils ne soient pas vraiment là: il fait des plans comme si c’était le cas.</i> <br><br>  <i>En conséquence, lorsque nous testons une sorte de migration, nous pouvons collecter tous les plans - nous verrons comment cela se produira en production.</i>  <i>Les secondes seront différentes (plus lentes), mais les données que nous lisons réellement et les plans eux-mêmes (quel type de JOIN, etc.) sont obtenus exactement de la même manière qu'en production.</i>  <i>Et en parallèle, vous pouvez exécuter plusieurs de ces vérifications sur une seule machine.</i> <br><br>  <b>DS</b> : Pensez-vous qu'il y a plusieurs problèmes?  La première est une solution qui ne fonctionne que sur PostgreSQL.  Cette approche est très privée, elle n'est pas générique.  La seconde - Kubernetes (et c'est là que le cloud va maintenant) implique de nombreux nœuds, et ces nœuds sont éphémères.  Et dans votre cas, il s'agit d'un nœud persistant avec état.  Ces choses me contredisent. <br><br>  <i><b>NS</b> : Tout d'abord - je suis d'accord, c'est une histoire purement Postgres.</i>  <i>Je pense que si nous avons des E / S directes et un pool de mémoire tampon pour presque toute la mémoire, cette approche ne fonctionnera pas - il y aura des plans différents.</i>  <i>Mais nous ne travaillons avec Postgres que pour le moment, nous ne pensons pas aux autres.</i> <br><br>  <i>À propos de Kubernetes.</i>  <i>Vous dites vous-même toujours que nous avons une base persistante.</i>  <i>Si l'instance se bloque, l'essentiel est de sauvegarder le disque.</i>  <i>Ici, nous avons également la plate-forme entière dans Kubernetes, et le composant avec Postgres est séparé (bien qu'il soit là un jour).</i>  <i>Par conséquent, tout est ainsi: l'instance est tombée, mais nous l'avons enregistrée PV et nous nous sommes juste connectés à une autre (nouvelle) instance, comme si rien ne s'était passé.</i> <br><br>  <b>DS</b> : De mon point de vue, nous créons des pods dans Kubernetes.  K8 - élastique: les composants sont commandés seuls selon les besoins.  La tâche consiste simplement à créer un pod et à dire qu'il a besoin de ressources X, puis les K8 le découvriront.  Mais le support de stockage dans Kubernetes est toujours instable: en <a href="https://habr.com/ru/company/flant/blog/467477/">1.16</a> , en <a href="https://habr.com/ru/company/flant/blog/476998/">1.17</a> (cette version est sortie il y a des <i>semaines</i> ), ces fonctionnalités ne deviennent que bêta. <br><br>  Six mois ou un an s'écouleront - il deviendra plus ou moins stable, ou du moins sera déclaré comme tel.  Ensuite, la possibilité d'instantanés et de redimensionner résout déjà complètement votre problème.  Parce que vous avez une base.  Oui, ce n'est peut-être pas très rapide, mais la vitesse dépend de ce qui est «sous le capot», car certaines implémentations peuvent copier et copier-écrire au niveau du sous-système de disque. <br><br>  <i><b>NS</b> : Il est également nécessaire que tous les moteurs (Amazon, Google ...) commencent à prendre en charge cette version - cela prend également un certain temps.</i> <br><br>  <b>DS</b> : Bien que nous ne les utilisions pas.  Nous utilisons le nôtre. <br><br><h2>  Développement local sous Kubernetes </h2><br>  <i><b>NS</b> : Avez-vous rencontré une telle liste de souhaits lorsque vous devez lever tous les pods sur une seule machine et faire un si petit test.</i>  <i>Afin d'obtenir rapidement une preuve de concept, vérifiez que l'application fonctionne dans Kubernetes, sans lui allouer un tas de machines.</i>  <i>Y a-t-il un Minikube, non?</i> <br><br>  <b>DS</b> : Il me semble que ce cas - déployer sur un nœud - concerne exclusivement le développement local.  Ou certaines manifestations d'un tel schéma.  Il y a <a href="https://habr.com/ru/company/flant/blog/333470/">Minikube</a> , il y a des <a href="https://k3s.io/">k3</a> , <a href="https://github.com/kubernetes-sigs/kind">KIND</a> .  Nous allons utiliser Kubernetes IN Docker.  Maintenant, ils ont commencé à travailler avec lui pour des tests. <br><br>  <i><b>NS</b> : Je pensais que c'était une tentative d'envelopper tous les pods dans une seule image Docker.</i>  <i>Mais il s'est avéré qu'il s'agissait d'autre chose.</i>  <i>Quoi qu'il en soit, il y a des conteneurs séparés, des pods séparés - juste dans le Docker.</i> <br><br>  <b>DS</b> : Oui.  Et là, une imitation assez drôle est faite, mais le fait est ... Nous avons un outil de déploiement - <a href="https://werf.io/">werf</a> .  Nous voulons y faire un mode - <code>werf up</code> conditionnellement: «Élevez-moi un Kubernetes local».  Et puis exécutez le <code>werf follow</code> conditionnel <code>werf follow</code> .  Ensuite, le développeur pourra éditer dans l'IDE, et un processus est lancé dans le système qui voit les changements et rassemble les images, les remodèle dans les K8 locaux.  Nous voulons donc essayer de résoudre le problème du développement local. <br><br><h2>  Instantanés et clonage de base de données dans la réalité des K8 </h2><br>  <i><b>NS</b> : Si vous revenez à la copie sur écriture.</i>  <i>J'ai remarqué que les nuages ​​ont également des instantanés.</i>  <i>Ils fonctionnent différemment.</i>  <i>Par exemple, dans GCP: vous avez une instance de plusieurs téraoctets sur la côte est des États-Unis.</i>  <i>Vous effectuez régulièrement des instantanés.</i>  <i>Vous prenez une copie du disque sur la côte ouest à partir d'un instantané - en quelques minutes tout est prêt, cela fonctionne très rapidement, seul le cache doit être rempli en mémoire.</i>  <i>Mais ces clones (instantanés) - afin de «provisionner» un nouveau volume.</i>  <i>C'est formidable lorsque vous devez créer de nombreuses instances.</i> <br><br>  <i>Mais pour les tests, il me semble, les instantanés dont vous parlez dans Docker ou dont je parle dans ZFS, btrfs et même LVM ... - ils vous permettent de ne pas faire vraiment de nouvelles données sur la même machine.</i>  <i>Dans le cloud, vous devez toujours les payer à chaque fois et attendre non pas des minutes, mais des minutes (et dans le cas d'un <a href="https://aws.amazon.com/about-aws/whats-new/2019/11/amazon-ebs-fast-snapshot-restore-eliminates-need-for-prewarming-data-into-volumes-created-snapshots/">chargement paresseux</a> , c'est probablement des heures).</i> <br><br>  <i>Au lieu de cela, vous pouvez obtenir ces données en une seconde ou deux, effectuer le test et le jeter.</i>  <i>Ces instantanés résolvent différents problèmes.</i>  <i>Dans le premier cas - pour évoluer et obtenir de nouvelles répliques, et dans le second - pour les tests.</i> <br><br>  <b>DS</b> : Je ne suis pas d'accord.  Le clonage de volumes est normalement la tâche du cloud.  Je n'ai pas regardé leur mise en œuvre, mais je sais comment nous le faisons sur le matériel.  Nous avons Ceph, vous pouvez dire à n'importe quel volume physique ( <a href="https://docs.ceph.com/docs/master/rbd/">RBD</a> ) de <i>cloner</i> et obtenir un deuxième volume avec les mêmes caractéristiques, <a href="https://en.wikipedia.org/wiki/IOPS">IOPS</a> , etc., en dizaines de millisecondes.  Vous devez comprendre qu'il y a une copie sur écriture délicate à l'intérieur.  Pourquoi le cloud ne fait-il pas de même?  Je suis sûr qu'ils essaient en quelque sorte de le faire. <br><br>  <i><b>NS</b> : Mais il leur faudra encore des secondes, des dizaines de secondes pour soulever l'instance, amener Docker là-bas, etc.</i> <br><br>  <b>DS</b> : Pourquoi est-il nécessaire de générer une instance entière?  Mais nous avons une instance pour 32 cœurs, pour 16 ... et il s'intègre en quelque sorte - par exemple, quatre.  Lorsque nous commandons le cinquième, l'instance augmentera, puis elle sera supprimée. <br><br>  <i><b>NS</b> : Oui, fait intéressant, Kubernetes a une histoire différente.</i>  <i>Notre base de données n'est pas en K8 et une seule instance.</i>  <i>Mais le clonage d'une base de données de plusieurs téraoctets ne prend pas plus de deux secondes.</i> <br><br>  <b>DS</b> : C'est cool.  Mais mon message initial est que ce n'est pas une solution générique.  Oui, c'est cool, mais seul Postgres convient et sur un seul nœud. <br><br>  <i><b>NS</b> : Il ne convient pas seulement à Postgres: ces plans, comme je l'ai décrit, ne fonctionneront que de cette manière.</i>  <i>Mais si vous ne vous embêtez pas avec les plans, mais nous avons juste besoin de toutes les données pour les tests fonctionnels, alors cela convient à n'importe quel SGBD.</i> <br><br>  <b>DS</b> : Il y a de nombreuses années, nous l'avons fait sur des instantanés LVM.  Ceci est un classique.  Cette approche a été utilisée très activement.  Seuls les nœuds avec état sont une douleur.  Parce qu'ils n'ont pas besoin d'être abandonnés, souvenez-vous toujours d'eux ... <br><br>  <i><b>NS</b> : Voyez-vous une possibilité hybride ici?</i>  <i>Disons que stateful est une sorte de pod, il fonctionne pour plusieurs personnes (de nombreux testeurs).</i>  <i>Nous avons un volume, mais grâce au système de fichiers, les clones sont locaux.</i>  <i>Si le pod tombe, le disque reste - le pod monte, il considère les informations sur tous les clones, reprend tout et dit: "Voici vos clones sur ces ports, commencez à travailler avec eux."</i> <br><br>  <b>DS</b> : Techniquement, cela signifie qu'au sein de Kubernetes, il s'agit d'un seul pod, à l'intérieur duquel nous exécutons de nombreux Postgres. <br><br>  <i><b>NS</b> : Oui.</i>  <i>Il a une limite: supposons, en même temps, pas plus de 10 personnes travaillent avec lui.</i>  <i>Si vous en avez besoin de 20, exécutez le deuxième module de ce type.</i>  <i>De façon réaliste, clonez-le, après avoir reçu le deuxième volume complet, il aura les mêmes 10 clones «fins».</i>  <i>Vous ne voyez pas une telle opportunité?</i> <br><br>  <b>DS</b> : Nous devons ajouter des problèmes de sécurité ici.  Une telle option d'organisation implique que ce pod a des capacités élevées car il peut effectuer des opérations non standard sur le système de fichiers ... Mais je répète: je pense qu'à moyen terme, le stockage sera fixé dans Kubernetes, toute l'histoire avec des volumes sera fixée dans les nuages - tout fonctionnera "simplement".  Il va redimensionner, cloner ... Il y a un volume - nous disons: «Créez-en un nouveau sur la base de cela» - et après une seconde et demie nous obtenons ce dont nous avons besoin. <br><br>  <i><b>NS</b> : Je ne crois pas en une seconde et demie pour plusieurs téraoctets.</i>  <i>Chez Ceph, vous le faites vous-même et vous parlez de nuages.</i>  <i>Accédez au cloud, sur EC2, faites un clone du volume EBS de plusieurs téraoctets et voyez quelles seront les performances.</i>  <i>Cela ne prend pas quelques secondes.</i>  <i>Je suis très intéressé quand ils atteignent un tel indicateur.</i>  <i>Je comprends de quoi vous parlez, mais je ne suis pas d'accord.</i> <br><br>  <b>DS</b> : D'accord, mais je l'ai dit à moyen terme, pas à court terme.  Depuis plusieurs années. <br><br><h2>  Opérateur Pro pour PostgreSQL de Zalando </h2><br>  Au milieu de cette réunion, Alexey Klyukin, un ancien développeur de Zalando, qui a parlé de l'histoire de l'opérateur PostgreSQL, l'a également rejoint: <br><br><blockquote>  C'est formidable qu'en général, ce sujet ait été abordé: Postgres et Kubernetes.  Lorsque nous avons commencé à le faire à Zalando en 2017, c'était un sujet que tout le monde voulait faire, mais personne ne l'a fait.  Tout le monde avait déjà Kubernetes, mais lorsqu'on leur a demandé quoi faire avec les bases de données, même des gens comme <a href="https://github.com/kelseyhightower">Kelsey Hightower</a> qui ont prêché les K8 ont dit quelque chose comme ceci: <br><br>  <i>«Accédez aux services gérés et utilisez-les, ne démarrez pas la base de données dans Kubernetes.</i>  <i>Sinon, vos K8 décideront, par exemple, de mettre à niveau, d'éteindre tous les nœuds et vos données voleront très loin. "</i> <br><br>  Nous avons décidé de faire un opérateur qui, contrairement à ce conseil, lancera la base de données Postgres à Kubernetes.  Et nous avions une bonne base - <a href="https://github.com/zalando/patroni">Patroni</a> .  Il s'agit d'un basculement automatique pour PostgreSQL, effectué correctement, c'est-à-dire  en utilisant etcd, consul ou ZooKeeper comme référentiel pour les informations de cluster.  Un tel référentiel qui sera remis à tous ceux qui demanderont, par exemple, quel leader est maintenant, les mêmes informations - malgré le fait que nous ayons tout distribué - pour qu'il n'y ait pas de cerveau divisé.  De plus, nous avions une <a href="https://github.com/zalando/patroni/tree/master/docker">image Docker</a> pour lui. <br><br>  En général, le besoin de basculement automatique dans l'entreprise est apparu après la migration du centre de données Iron vers le cloud.  Le cloud était basé sur une solution propriétaire PaaS (Platform-as-a-Service).  C'est de l'Open Source, mais pour le développer, il a fallu travailler dur.  Cela s'appelait <a href="https://stups.io/">STUPS</a> . <br><br>  Au départ, il n'y avait pas de Kubernetes.  Plus précisément, lorsque sa propre solution a été déployée, les K8 l'étaient déjà, mais si grossiers qu'ils n'étaient pas adaptés à la production.  C'était, à mon avis, 2015 ou 2016.  En 2017, Kubernetes est devenu plus ou moins mature - il fallait y migrer. <br><br>  Et nous avions déjà un conteneur docker.  Il y avait PaaS qui utilisait Docker.  Pourquoi ne pas essayer les K8?  Pourquoi ne pas écrire votre propre déclaration?  Murat Kabilov, qui nous est venu d'Avito, a commencé cela comme un projet de sa propre initiative - «jouer» - et le projet «a décollé». <br><br>  Mais en général, je voulais parler d'AWS.  Pourquoi y avait-il un code historiquement lié à AWS ... <br><br>  Lorsque vous exécutez quelque chose dans Kubernetes, vous devez comprendre que K8s est un tel travail en cours.  Il se développe constamment, s'améliore et se brise même périodiquement.  Vous devez surveiller attentivement tous les changements dans Kubernetes, vous devez être prêt à vous y plonger et à découvrir comment cela fonctionne en détail - peut-être plus que vous ne le souhaiteriez.  Il s'agit, en principe, de toute plateforme sur laquelle vous exécutez vos bases de données ... <br><br>  Ainsi, lorsque nous avons fait la déclaration, nous avions Postgres, qui fonctionnait avec un volume externe (dans ce cas, EBS, puisque nous travaillions dans AWS).  La base de données grandissait, à un moment donné, il a fallu la redimensionner: par exemple, la taille d'origine de l'EBS est de 100 To, la base de données a grandi, maintenant nous voulons faire de l'EBS en 200 To.  Comment?  Supposons que vous puissiez vider / restaurer vers une nouvelle instance, mais cela est long et avec des temps d'arrêt. <br><br>  Par conséquent, je voulais un redimensionnement qui étendrait la partition EBS, puis indiquerait au système de fichiers d'utiliser le nouvel espace.  Et nous l'avons fait, mais à ce moment-là, Kubernetes n'avait pas d'API pour l'opération de redimensionnement.  Depuis que nous avons travaillé sur AWS, nous avons écrit du code pour son API. <br><br>  Personne ne prend la peine de faire de même pour les autres plates-formes.  Il n'y a aucune complication dans la déclaration selon laquelle il ne peut être exécuté que sur AWS, et il ne fonctionnera pas sur tout le reste.  Il s'agit en général d'un projet Open Source: si quelqu'un veut accélérer l'émergence de l'utilisation de la nouvelle API, nous sommes les bienvenus.  Il y a <a href="https://github.com/zalando/postgres-operator">GitHub</a> , pull-requests - l'équipe Zalando essaie de leur répondre rapidement et de promouvoir l'opérateur.  Pour autant que je sache, le projet a <a href="https://summerofcode.withgoogle.com/archive/2019/organizations/6187982082539520/">participé</a> à Google Summer of Code et à d'autres initiatives similaires.  Zalando y est très actif. <br></blockquote><br><h2>  Bonus PS! </h2><br>  Si vous êtes intéressé par le sujet de PostgreSQL et Kubernetes, alors nous attirons également l'attention sur le fait que la semaine dernière, le prochain Postgres a eu lieu, où <b>Alexander Kukushkin de Zalando a</b> parlé avec Nikolai.  La vidéo est disponible <a href="https://www.youtube.com/watch%3Fv%3DFE0xi7SBqsg">ici</a> . <br><br><h2>  PPS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://habr.com/ru/company/flant/blog/431500/">Bases de données et Kubernetes (revue et reportage vidéo)</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/475036/">Migration de Cassandra vers Kubernetes: fonctionnalités et solutions</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/461149/">Migration sans entrave de MongoDB vers Kubernetes</a> »; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/450662/">Migration sans obstacle de RabbitMQ vers Kubernetes</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479438/">https://habr.com/ru/post/fr479438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479422/index.html">[Animation vidéo] Monde filaire: comment en 35 ans un réseau de câbles sous-marins a enveloppé le globe</a></li>
<li><a href="../fr479426/index.html">Semaine de la sécurité 50: Attaques d'homme au milieu dans Confluence et Linux</a></li>
<li><a href="../fr479428/index.html">Événements numériques à Moscou du 9 au 15 décembre</a></li>
<li><a href="../fr479430/index.html">Événements numériques à Saint-Pétersbourg du 9 au 15 décembre</a></li>
<li><a href="../fr479432/index.html">Yandex.Maps: Je suis allé au contrôleur de carte - j'ai immédiatement obtenu la position de l'utilisateur (d'accord, maintenant sérieusement)</a></li>
<li><a href="../fr479442/index.html">Alexey Savvateev: Modèle de schisme social de la théorie des jeux (+ enquête nginx)</a></li>
<li><a href="../fr479446/index.html">Les voitures ont déjà une longueur d'avance sur les tests de lecture; mais comprennent-ils ce qu'ils lisent?</a></li>
<li><a href="../fr479450/index.html">AppCode 2019.3: fonctionne plus rapidement, comprend mieux Swift, connaît Mac Catalyst et affiche facilement les messages d'assemblage</a></li>
<li><a href="../fr479452/index.html">Comment le système de noms de domaine s'est développé: l'ère ARPANET</a></li>
<li><a href="../fr479458/index.html">Beauté ou praticité dans la salle des serveurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>