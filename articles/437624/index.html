<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº üñïüèø üöñ OpenSceneGraph: Conceptos b√°sicos de textura ‚òùüèΩ üê§ üëÉüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Ya hemos examinado un ejemplo en el que pintaron un cuadrado con todos los colores del arco√≠ris. Sin embargo, existe otra tecnolog√≠a, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Conceptos b√°sicos de textura</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437624/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><br><h1>  Introduccion </h1><br>  Ya hemos examinado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> en el que pintaron un cuadrado con todos los colores del arco√≠ris.  Sin embargo, existe otra tecnolog√≠a, a saber, la aplicaci√≥n a la geometr√≠a tridimensional del llamado <em>mapa de textura</em> o simplemente textura: una imagen r√°ster bidimensional.  En este caso, el efecto no est√° en los v√©rtices de la geometr√≠a, sino que se modifican los datos de todos los p√≠xeles obtenidos cuando se rasteriza la escena.  Esta t√©cnica puede aumentar significativamente el realismo y los detalles de la imagen final. <br><br>  OSG admite varios atributos de textura y modos de textura.  Pero, antes de hablar sobre texturas, hablemos sobre c√≥mo OSG maneja las im√°genes de mapa de bits.  Para trabajar con im√°genes r√°ster, se proporciona una clase especial: osg :: Image, que almacena los datos de la imagen en su interior, destinados, en √∫ltima instancia, a texturizar el objeto. <br><a name="habracut"></a><br><h1>  1. Presentaci√≥n de datos de imagen r√°ster.  Clase Osg :: Imagen </h1><br>  La mejor manera de cargar una imagen desde el disco es usar la llamada osgDB :: readImageFile ().  Es muy similar a la llamada osg :: readNodeFile () que ya nos ha aburrido.  Si tenemos un mapa de bits llamado picture.bmp, entonces cargarlo se ver√° as√≠ <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>);</code> </pre> <br>  Si la imagen se carga correctamente, el puntero ser√° v√°lido; de lo contrario, la funci√≥n devolver√° NULL.  Despu√©s de la descarga, podemos obtener informaci√≥n de la imagen utilizando los siguientes m√©todos p√∫blicos <br><br><ol><li>  t (), s () y r (): devuelve el ancho, la altura y la profundidad de la imagen. <br></li><li>  data (): devuelve un puntero de tipo unsigned char * a los datos de la imagen "en bruto".  A trav√©s de este puntero, el desarrollador puede actuar directamente sobre los datos de la imagen.  Puede hacerse una idea del formato de datos de imagen utilizando los m√©todos getPixalFormat () y getDataType ().  Los valores devueltos por ellos son equivalentes a los par√°metros del formato y tipo de las funciones de OpenGL glTexImage * ().  Por ejemplo, si la imagen tiene el formato de p√≠xel GL_RGB y el tipo es GL_UNSIGNED_BYTE, se utilizan tres elementos independientes (bytes sin signo) para representar el componente de color RGB <br></li></ol><br><img src="https://habrastorage.org/webt/6g/mo/or/6gmoorwfvryg44pq7sdi0cb4l9s.png"><br><br>  Puede crear un nuevo objeto de imagen y asignarle memoria. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage(s, t, r, GL_RGB, GL_UNSIGNED_BYTE); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = image-&gt;data(); <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre><br>  Aqu√≠ s, t, r son tama√±os de imagen;  GL_RGB establece el formato de p√≠xel y GL_UNSIGNED_BYTE establece el tipo de datos para describir un solo componente de color.  Se asigna un b√∫fer de datos interno del tama√±o requerido en la memoria y se destruye autom√°ticamente si no hay un solo enlace a esta imagen. <br><br>  El sistema de complemento OSG admite la descarga de casi todos los formatos de imagen populares: * .jpg, * .bmp, * .png, * .tif, etc.  Esta lista es f√°cil de expandir escribiendo su propio complemento, pero este es un tema para otra discusi√≥n. <br><br><h1>  2. Los fundamentos de la textura </h1><br>  Para aplicar textura a un modelo tridimensional, debe realizar una serie de pasos: <br><br><ol><li>  Defina las coordenadas de textura de los v√©rtices para el objeto geom√©trico (en el entorno de los dise√±adores 3D, esto se llama escaneo UV). <br></li><li>  Cree un objeto de atributo de textura para 1D, 2D, 3D o textura c√∫bica. <br></li><li>  Establezca una o m√°s im√°genes para un atributo de textura. <br></li><li>  Adjunte un atributo y modo de textura al conjunto de estados aplicados al objeto que se est√° dibujando. <br></li></ol><br>  OSG define la clase osg :: Texture, que encapsula todo tipo de texturas.  Las subclases osg :: Texture1D, osg :: Texture2D, osg :: Texture3D y osg :: TextureCubeMap se heredan de √©l, lo que representa varias t√©cnicas de texturas adoptadas en OpenGL. <br><br>  El m√©todo m√°s com√∫n de la clase osg :: Texture es setImage (), que establece la imagen utilizada en la textura, por ejemplo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setImage(image.get());</code> </pre><br>  o puede pasar el objeto de imagen directamente al constructor de la clase de textura <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D(image.get());</code> </pre><br>  La imagen se puede recuperar del objeto de textura llamando al m√©todo getImage (). <br><br>  Otro punto importante es establecer las coordenadas de textura para cada v√©rtice en el objeto osg :: Geometry.  La transferencia de estas coordenadas ocurre a trav√©s de la matriz osg :: Vec2Array y osg :: Vec3Array llamando al m√©todo setTexCoordArray (). <br><br>  Despu√©s de establecer las coordenadas de textura, necesitamos establecer el n√∫mero de ranura de textura (unidad), ya que OSG admite la superposici√≥n de m√∫ltiples texturas en la misma geometr√≠a.  Cuando se usa una textura √∫nica, el n√∫mero de unidad es siempre 0. Por ejemplo, el siguiente c√≥digo ilustra la configuraci√≥n de las coordenadas de textura para la unidad 0 de la geometr√≠a <br><br><pre> <code class="cpp hljs">osf::ref_ptr&lt;osg::Vec2Array&gt; texcoord = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoord-&gt;push_back( osg::Vec2(...) ); ... geom-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoord.get());</code> </pre><br>  Despu√©s de eso, podemos agregar el atributo de textura al conjunto de estados, activando autom√°ticamente el modo de textura correspondiente (en nuestro ejemplo GL_TEXTURE_2D) y aplicar el atributo a la geometr√≠a o nodo que contiene esta geometr√≠a <br><br><pre> <code class="cpp hljs">geom-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(texture.get());</code> </pre><br>  Tenga en cuenta que OpenGL gestiona los datos de la imagen en la memoria gr√°fica de la tarjeta de video, pero el objeto osg :: Image junto con los mismos datos se encuentra en la memoria del sistema.  Como resultado, encontraremos el hecho de que hemos almacenado dos copias de los mismos datos, ocupando la memoria del proceso.  Si esta imagen no es compartida por varios atributos de textura, se puede eliminar de la memoria del sistema inmediatamente despu√©s de que OpenGL la transfiera a la memoria del adaptador de video.  La clase osg :: Texture proporciona el m√©todo apropiado para habilitar esta funci√≥n. <br><br><pre> <code class="cpp hljs">texture-&gt;setUnRefImageDataAfterApply( <span class="hljs-literal"><span class="hljs-literal">true</span></span> );</code> </pre> <br><h1>  3. Cargue y aplique una textura 2D </h1><br>  La t√©cnica m√°s utilizada es el texturizado 2D: superposici√≥n de una imagen (o im√°genes) bidimensional en el borde de una superficie tridimensional.  Considere el ejemplo m√°s simple de aplicar una textura √∫nica a un pol√≠gono cuadrangular <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de textura</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet( new osg::DrawArrays(GL_QUADS, 0, 4) ); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Crea una matriz de v√©rtices y normales a la cara <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  Crea una matriz de coordenadas de textura <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  El punto es que cada v√©rtice del modelo tridimensional corresponde a un punto en la textura bidimensional, y las coordenadas de los puntos en la textura son relativas: est√°n normalizadas al ancho y la altura reales de la imagen.  Queremos estirar toda la imagen cargada en un cuadrado, respectivamente, las esquinas del cuadrado corresponder√°n a los puntos de textura (0, 0), (0, 1), (1, 1) y (1, 0).  El orden de los v√©rtices en la matriz de v√©rtices debe coincidir con el orden de los v√©rtices de textura. <br><br>  Luego, crea un cuadrado, asignando a la geometr√≠a una matriz de v√©rtices y una matriz de normales <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) );</code> </pre><br>  Cree un objeto de textura y cargue la imagen utilizada para ello. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"../data/Images/lz.rgb"</span></span>); texture-&gt;setImage(image.get());</code> </pre><br>  Crea el nodo ra√≠z de la escena y coloca la geometr√≠a que creamos all√≠ <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get());</code> </pre><br>  y finalmente aplique el atributo de textura al nodo en el que se coloca la geometr√≠a <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br><img src="https://habrastorage.org/webt/wm/2a/fy/wm2afywfx6dnkhwaagvceqkycd8.png"><br><br>  La clase osg :: Texture2D determina si los tama√±os de imagen de textura son m√∫ltiplos de una potencia de dos (por ejemplo, 64x64 o 256x512), escalando autom√°ticamente las im√°genes que no son apropiadas para el tama√±o, en realidad usando la funci√≥n OpenGL gluScaleImage ().  Existe un m√©todo setResizeNonPowerOfTwoHint () que determina si se debe cambiar el tama√±o de la imagen o no.  Algunas tarjetas de video requieren un m√∫ltiplo del tama√±o de una imagen de la potencia de dos, mientras que la clase osg :: Texture2D admite trabajar con un tama√±o de textura arbitrario. <br><br><h1>  Algo sobre la mezcla de texturas </h1><br>  Como ya dijimos, las coordenadas de textura se normalizan de 0 a 1. El punto (0, 0) corresponde a la esquina superior izquierda de la imagen, y el punto (1, 1) corresponde a la esquina inferior derecha.  ¬øQu√© sucede si establece coordenadas de textura mayores que uno? <br><br>  Por defecto, en OpenGL, como en OSG, la textura se repetir√° en la direcci√≥n del eje, el valor de la coordenada de textura exceder√° uno.  Esta t√©cnica se usa a menudo, por ejemplo, para crear un modelo de una pared de ladrillo larga, utilizo una textura peque√±a, repitiendo su superposici√≥n muchas veces tanto en ancho como en altura. <br><br>  Este comportamiento se puede controlar mediante el m√©todo setWrap () de la clase osg :: Texture.  Como primer par√°metro, el m√©todo toma el identificador del eje al que debe aplicarse el modo de mezcla, pasado como el segundo par√°metro, por ejemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     s texture-&gt;setWrap( osg::Texture::WRAP_S, osg::Texture::REPEAT ); //     r texture-&gt;setWrap( osg::Texture::WRAP_R, osg::Texture::REPEAT );</span></span></code> </pre><br>  Este c√≥digo le dice expl√≠citamente al motor que repita la textura a lo largo de los ejes syr si los valores de coordenadas de textura exceden 1. Una lista completa de modos de mapeo de textura: <br><br><ol><li>  REPETIR - repite la textura. <br></li><li>  ESPEJO - repita la textura, reflej√°ndola. <br></li><li>  CLAMP_TO_EDGE: las coordenadas que van m√°s all√° de 0 a 1 se ajustan al borde correspondiente de la textura. <br></li><li>  CLAMP_TO_BORDER: las coordenadas que van m√°s all√° de 0 a 1 proporcionar√°n el color del borde establecido por el usuario. <br></li></ol><br><h1>  4. Renderizado a textura </h1><br>  La t√©cnica de representaci√≥n de texturas permite al desarrollador crear una textura basada en una subescena o modelo tridimensional y aplicarla a la superficie de la escena principal.  Una tecnolog√≠a similar a menudo se llama textura "hornear". <br><br>  Para hornear din√°micamente una textura, debe completar tres pasos: <br><br><ol><li>  Cree un objeto de textura para representarlo. <br></li><li>  Renderiza la escena en una textura. <br></li><li>  Use la textura resultante seg√∫n lo previsto. <br></li></ol><br>  Debemos crear un objeto de textura vac√≠o.  OSG le permite crear una textura vac√≠a de un tama√±o determinado.  El m√©todo setTextureSize () le permite establecer el ancho y el alto de la textura, as√≠ como la profundidad como un par√°metro adicional (para texturas 3D). <br><br>  Para renderizar a una textura, debe adjuntarla al objeto de la c√°mara llamando al m√©todo attach (), que toma un objeto de textura como argumento.  Adem√°s, este m√©todo acepta un argumento que indica qu√© parte del b√∫fer de trama se debe representar en esta textura.  Por ejemplo, para transferir un b√∫fer de color a una textura, debe ejecutar el siguiente c√≥digo <br><br><pre> <code class="cpp hljs">camera-&gt;attach( osg::Camera::COLOR_BUFFER, texture.get() );</code> </pre><br>  Otras partes del b√∫fer de trama disponibles para renderizar incluyen el b√∫fer de profundidad DEPTH_BUFFER, el b√∫fer de plantilla STENCIL_BUFFER y los b√∫feres de color adicionales de COLOR_BUFFER0 a COLOR_BUFFER15.  La presencia de buffers de color adicionales y su n√∫mero est√° determinado por el modelo de la tarjeta de video. <br><br>  Adem√°s, para una c√°mara que se convierte en una textura, debe establecer los par√°metros de la matriz de proyecci√≥n y la vista, cuyo tama√±o corresponde al tama√±o de la textura.  La textura se actualizar√° a medida que se dibuja cada cuadro.  Tenga en cuenta que la c√°mara principal no debe usarse para renderizar en una textura, ya que proporciona la representaci√≥n de la escena principal y solo obtiene una pantalla en negro.  Es posible que este requisito no se cumpla solo cuando realice el procesamiento fuera de la pantalla. <br><br><h1>  5. Un ejemplo de la implementaci√≥n de renderizado a textura </h1><br>  Para demostrar la t√©cnica de renderizado en una textura, implementamos la siguiente tarea: crear un cuadrado, dibujar una textura cuadrada en √©l y renderizar una escena animada en la textura, por supuesto con el cessna que amamos.  El programa que implementa el ejemplo es bastante voluminoso.  Sin embargo, le dar√© su c√≥digo fuente completo de todos modos. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de Texrender</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Camera&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/TrackballManipulator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad(const osg::Vec3 &amp;pos, float w, float h) { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, -h / 2) ); vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, -h / 2) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(0.0, osg::Vec3(0.0f, 0.0f, 1.0f))); transform1-&gt;addChild(sub_model.get()); osg::ref_ptr&lt;osg::Geode&gt; model = new osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(0.0f, 0.0f, 0.0f), 2.0f, 2.0f)); int tex_widht = 1024; int tex_height = 1024; osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR); model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osg::ref_ptr&lt;osg::Camera&gt; camera = new osg::Camera; camera-&gt;setViewport(0, 0, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get()); camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(new osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(0); camera-&gt;setProjectionMatrixAsPerspective(30.0, static_cast&lt;double&gt;(tex_widht) / static_cast&lt;double&gt;(tex_height), 0.1, 1000.0); float dist = 100.0f; float alpha = 10.0f * 3.14f / 180.0f; osg::Vec3 eye(0.0f, -dist * cosf(alpha), dist * sinf(alpha)); osg::Vec3 center(0.0f, 0.0f, 0.0f); osg::Vec3 up(0.0f, 0.0f, -1.0f); camera-&gt;setViewMatrixAsLookAt(eye, center, up); float phi = 0.0f; float delta = -0.01f; while (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(static_cast&lt;double&gt;(phi), osg::Vec3(0.0f, 0.0f, 1.0f))); viewer.frame(); phi += delta; } return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Para crear un cuadrado, escriba una funci√≥n libre separada <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  La funci√≥n acepta la posici√≥n del centro del cuadrado y sus dimensiones geom√©tricas como entrada.  A continuaci√≥n, se crea una matriz de v√©rtices, una matriz de normales y coordenadas de textura, despu√©s de lo cual la geometr√≠a creada se devuelve de la funci√≥n. <br><br>  En el cuerpo del programa principal, cargue el modelo de cessna <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Para animar este modelo, cree e inicialice la transformaci√≥n de rotaci√≥n alrededor del eje Z <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); transform1-&gt;addChild(sub_model.get());</code> </pre><br>  Ahora cree un modelo para la escena principal: un cuadrado en el que representaremos <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>));</code> </pre><br>  Cree una textura vac√≠a para un cuadrado de 1024x1024 p√≠xeles con un formato de p√≠xel RGBA (color de tres componentes de 32 bits con canal alfa) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_widht = <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_height = <span class="hljs-number"><span class="hljs-number">1024</span></span>; osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);</code> </pre><br>  Aplica esta textura al modelo cuadrado. <br><br><pre> <code class="cpp hljs">model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br>  Luego crea una c√°mara que hornee la textura <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Camera&gt; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Camera; camera-&gt;setViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code> </pre><br>  La vista de la c√°mara tiene el mismo tama√±o que la textura.  Adem√°s, no olvide establecer el color de fondo al limpiar la pantalla y la m√°scara de limpieza, lo que indica que debe borrar tanto el b√∫fer de color como el b√∫fer de profundidad.  Luego, configure la c√°mara para renderizar a textura <br><br><pre> <code class="cpp hljs">camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get());</code> </pre><br>  El orden de renderizado de PRE_RENDER indica que esta c√°mara est√° renderizando antes de renderizar a la escena principal.  Especifique el FBO como el objetivo de representaci√≥n y adjunte nuestra textura a la c√°mara.  Ahora configuramos la c√°mara para que funcione en un sistema de coordenadas absoluto y, como escena, configuramos nuestro sub√°rbol, que queremos convertir en una textura: transformaci√≥n de rotaci√≥n con un modelo Cessna adjunto <br><br><pre> <code class="cpp hljs">camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get());</code> </pre><br>  Cree un nodo de grupo ra√≠z agregando el modelo principal (cuadrado) y una textura de procesamiento de c√°mara. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get());</code> </pre><br>  Crea y personaliza un visor <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Configure la matriz de proyecci√≥n para la c√°mara: una proyecci√≥n en perspectiva a trav√©s de los par√°metros de la pir√°mide de recorte <br><br><pre> <code class="cpp hljs">camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_widht) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_height), <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  Configuramos una matriz de vista que establece la posici√≥n de la c√°mara en el espacio con respecto al origen de la subcesa <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = <span class="hljs-number"><span class="hljs-number">100.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">10.0f</span></span> * <span class="hljs-number"><span class="hljs-number">3.14f</span></span> / <span class="hljs-number"><span class="hljs-number">180.0f</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eye</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, -dist * cosf(alpha), dist * sinf(alpha))</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">center</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; camera-&gt;setViewMatrixAsLookAt(eye, center, up);</code> </pre><br>  Finalmente, anime y muestre la escena, cambiando el √°ngulo de rotaci√≥n de la aeronave alrededor del eje Z en cada cuadro <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> phi = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> delta = <span class="hljs-number"><span class="hljs-number">-0.01f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(phi), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); viewer.frame(); phi += delta; }</code> </pre><br>  Como resultado, obtenemos una imagen bastante interesante <br><br><img src="https://habrastorage.org/webt/se/g1/jr/seg1jrflbtmzfkb5cbtwys1hleg.gif"><br><br>  En este ejemplo, implementamos algunas animaciones de escena, pero recuerde que expandir el ciclo run () y cambiar los par√°metros de representaci√≥n antes o despu√©s de representar el cuadro es una actividad insegura en t√©rminos de organizar el acceso a los datos de diferentes flujos.  Dado que OSG utiliza la representaci√≥n de subprocesos m√∫ltiples, tambi√©n existen mecanismos regulares para incorporar sus propias acciones en el proceso de representaci√≥n, que proporcionan acceso seguro a los datos. <br><br><h1>  6. Guardar el resultado de la representaci√≥n en un archivo </h1><br>  OSG admite la capacidad de adjuntar un objeto osg :: Image a la c√°mara y guardar el contenido del b√∫fer de cuadros en el b√∫fer de datos de imagen.  Despu√©s de eso, es posible guardar estos datos en el disco usando la funci√≥n osg :: writeImageFile () <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage( width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE ); camera-&gt;attach( osg::Camera::COLOR_BUFFER, image.get() ); ... osgDB::writeImageFile( *image, <span class="hljs-string"><span class="hljs-string">"saved_image.bmp"</span></span> );</code> </pre><br><h1>  Conclusi√≥n </h1><br>  Quiz√°s el material presentado en el art√≠culo parece trivial.  Sin embargo, describe los conceptos b√°sicos de trabajar con texturas en OpenSceneGraph, en el que se basan t√©cnicas m√°s complejas para trabajar con este motor, de las que definitivamente hablaremos en el futuro. <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√° ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437624/">https://habr.com/ru/post/437624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437614/index.html">El patr√≥n arquitect√≥nico iterador en el universo r√°pido</a></li>
<li><a href="../437616/index.html">Seis meses sin ca√≠da de las ventas de CEO y iPhone: por qu√© caen las acciones de Intel</a></li>
<li><a href="../437618/index.html">42 operadores de b√∫squeda avanzada de Google (lista completa)</a></li>
<li><a href="../437620/index.html">C√≥mo la tecnolog√≠a en la nube est√° cambiando la forma en que tratamos</a></li>
<li><a href="../437622/index.html">Introducci√≥n al servicio Azure Machine Learning</a></li>
<li><a href="../437626/index.html">Rendimiento de la plataforma de negociaci√≥n con un ejemplo simple</a></li>
<li><a href="../437630/index.html">Los principales anuncios de Microsoft de la conferencia BETT</a></li>
<li><a href="../437632/index.html">Mash, los fundamentos del lenguaje</a></li>
<li><a href="../437634/index.html">Enrutador inal√°mbrico de bricolaje</a></li>
<li><a href="../437636/index.html">Publicaci√≥n de la aplicaci√≥n en Microsoft Store: algunos cambios para el a√±o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>