<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ì üë©üèº‚Äçü§ù‚Äçüë©üèª ‚òÅÔ∏è OS1: un n√∫cleo primitivo en Rust para x86. Parte 3. Tarjeta de memoria, excepci√≥n de falla de p√°gina, mont√≥n y asignaciones üñäÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèø ü§•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Primera parte 
 Segunda parte 


 El tema de la conversaci√≥n de hoy es trabajar con la memoria. Hablar√© sobre la inicializaci√≥n del directorio de la p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: un n√∫cleo primitivo en Rust para x86. Parte 3. Tarjeta de memoria, excepci√≥n de falla de p√°gina, mont√≥n y asignaciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446214/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda parte</a> </p><br><p>  El tema de la conversaci√≥n de hoy es trabajar con la memoria.  Hablar√© sobre la inicializaci√≥n del directorio de la p√°gina, el mapeo de la memoria f√≠sica, la administraci√≥n virtual y el mont√≥n de mi organizaci√≥n para el asignador. </p><br><p>  Como dije en el primer art√≠culo, decid√≠ usar p√°ginas de 4 MB para simplificar mi vida y no tener que lidiar con tablas jer√°rquicas.  En el futuro, espero ir a p√°ginas de 4 KB, como la mayor√≠a de los sistemas modernos.  Podr√≠a usar uno listo (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un asignador de bloques</a> ), pero escribir el m√≠o fue un poco m√°s interesante y quer√≠a entender un poco m√°s c√≥mo vive la memoria, as√≠ que tengo algo que decirte. </p><a name="habracut"></a><br><p> La √∫ltima vez que me decid√≠ por el m√©todo setup_pd dependiente de la arquitectura y quer√≠a continuar con √©l, sin embargo, hab√≠a un detalle m√°s que no cubr√≠ en el art√≠culo anterior: salida VGA usando Rust y la macro println est√°ndar.  Como su implementaci√≥n es trivial, la eliminar√© debajo del spoiler.  El c√≥digo est√° en el paquete de depuraci√≥n. </p><br><div class="spoiler">  <b class="spoiler_title">Macro println</b> <div class="spoiler_text"><pre><code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> print { ($($arg:tt)*) =&gt; ($crate::debug::_print(<span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> println { () =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)); ($($arg:tt)*) =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; vga::VGA_WRITER.lock().write_fmt(args).unwrap(); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; <span class="hljs-comment"><span class="hljs-comment">// vga::VGA_WRITER.lock().write_fmt(args).unwrap(); }</span></span></code> </pre> </div></div><br><p>  Ahora, con la conciencia tranquila, vuelvo a la memoria. </p><br><h1 id="inicializaciya-direktorii-stranic">  Inicializaci√≥n del directorio de p√°ginas </h1><br><p>  Nuestro m√©todo kmain tom√≥ tres argumentos como entrada, uno de los cuales es la direcci√≥n virtual de la tabla de p√°ginas.  Para usarlo m√°s tarde para la asignaci√≥n y la administraci√≥n de la memoria, debe designar la estructura de registros y directorios.  Para x86, el directorio de la p√°gina y la tabla de la p√°gina se describen bastante bien, por lo que me limitar√© a una peque√±a introducci√≥n.  La entrada del directorio de la p√°gina es una estructura de tama√±o de puntero, para nosotros es de 4 bytes.  El valor contiene una direcci√≥n f√≠sica de 4KB de la p√°gina.  El byte menos significativo del registro est√° reservado para banderas.  El mecanismo para convertir una direcci√≥n virtual en una f√≠sica se ve as√≠ (en el caso de mi granularidad de 4 MB, el cambio se produce en 22 bits. Para otras granularidades, el cambio ser√° diferente y se usar√°n tablas jer√°rquicas): </p><br><blockquote>  Direcci√≥n virtual 0xC010A110 -&gt; Obtenga el √≠ndice en el directorio moviendo la direcci√≥n 22 bits a la derecha -&gt; √≠ndice 0x300 -&gt; Obtenga la direcci√≥n f√≠sica de la p√°gina por √≠ndice 0x300, verifique los indicadores y el estado -&gt; 0x1000000 -&gt; Tome los 22 bits inferiores de la direcci√≥n virtual como un desplazamiento, agregue a la direcci√≥n f√≠sica de la p√°gina -&gt; 0x1000000 + 0x10A110 = direcci√≥n f√≠sica en memoria 0x110A110 </blockquote><p>  Para acelerar el acceso, el procesador utiliza TLB, el b√∫fer de traducci√≥n, que almacena en cach√© las direcciones de las p√°ginas. </p><br><p>  Entonces, as√≠ es como se describe mi directorio y sus entradas, y se implementa el m√©todo setup_pd.  Para escribir una p√°gina, se implementa el m√©todo "constructor", que garantiza la alineaci√≥n en 4 KB y la configuraci√≥n de banderas, y un m√©todo para obtener la direcci√≥n f√≠sica de la p√°gina.  Un directorio es solo una matriz de 1024 entradas de cuatro bytes.  El directorio puede asociar una direcci√≥n virtual con una p√°gina utilizando el m√©todo set_by_addr. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectoryEntry</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_phys_address</span></span></span></span>(address: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flags: PDEntryFlags) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { PDirectoryEntry((address <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) &amp; ADDRESS_MASK | flags.bits()) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flags</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; PDEntryFlags { PDEntryFlags::from_bits_truncate(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_address</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &amp; ADDRESS_MASK } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbg</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectory</span></span></span></span> { entries: [PDirectoryEntry; <span class="hljs-number"><span class="hljs-number">1024</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectory { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_by_addr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set(PDirectory::to_idx(logical_addr), entry); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] = entry; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { invalidate_page(idx); } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_logical_addr</span></span></span></span>(idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (idx &lt;&lt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_idx</span></span></span></span>(logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (logical_addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> PAGE_DIRECTORY: Mutex&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory&gt; = Mutex::new( <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC0000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory) } ); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pd</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> data = PAGE_DIRECTORY.lock(); *data = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(pd <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory); }</code> </pre> <br><p>  Muy torpemente hice que la inicializaci√≥n est√°tica inicial fuera una direcci√≥n inexistente, por lo que le agradecer√≠a que me escribiera c√≥mo es habitual en la comunidad de Rust hacer tales inicializaciones con la reasignaci√≥n de enlaces. </p><br><p>  Ahora que podemos administrar p√°ginas desde c√≥digo de alto nivel, podemos pasar a compilar la inicializaci√≥n de memoria.  Esto suceder√° en dos etapas: procesando la tarjeta de memoria f√≠sica e inicializando el administrador virtual </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mb_magic { <span class="hljs-number"><span class="hljs-number">0x2BADB002</span></span> =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"multibooted v1, yeah, reading mb info"</span></span>); boot::init_with_mb1(mb_pointer); }, . . . . . . } memory::init();</code> </pre> <br><h1 id="karta-pamyati-grub-i-karta-fizicheskoy-pamyati-os1">  Tarjeta de memoria GRUB y tarjeta de memoria f√≠sica OS1 </h1><br><p>  Para obtener una tarjeta de memoria de GRUB, en la etapa de arranque configur√© la bandera correspondiente en el encabezado, y GRUB me dio la direcci√≥n f√≠sica de la estructura.  Lo port√© de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> a la notaci√≥n Rust, y tambi√©n agregu√© m√©todos para iterar c√≥modamente sobre la tarjeta de memoria.  La mayor parte de la estructura de GRUB no se completar√°, y en esta etapa no es muy interesante para m√≠.  Lo principal es que no quiero determinar la cantidad de memoria disponible manualmente. </p><br><p>  Al inicializar a trav√©s de Multiboot, primero convertimos la direcci√≥n f√≠sica a virtual.  Te√≥ricamente, GRUB puede colocar la estructura en cualquier lugar, por lo que si la direcci√≥n se extiende m√°s all√° de la p√°gina, debe asignar una p√°gina virtual en el directorio de la p√°gina.  En la pr√°ctica, la estructura casi siempre se encuentra al lado del primer megabyte, que ya hemos asignado en la etapa de arranque.  Por si acaso, verificamos la bandera de que la tarjeta de memoria est√° presente y procedemos a su an√°lisis. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot2; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_pointer</span></span></span></span>(mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-comment"><span class="hljs-comment">//if in first 4 MB - map to kernel address space if mb_pointer &lt; 0x400000 { arch::KERNEL_BASE | mb_pointer } else { arch::paging::allocate_page(mb_pointer, arch::MB_INFO_BASE, arch::paging::PDEntryFlags::PRESENT | arch::paging::PDEntryFlags::WRITABLE | arch::paging::PDEntryFlags::HUGE_PAGE ); arch::MB_INFO_BASE | mb_pointer } } pub fn init_with_mb1(mb_pointer: usize) { let ln_pointer = unsafe { process_pointer(mb_pointer) }; println!("mb pointer 0x{:X}", ln_pointer); let mb_info = multiboot::from_ptr(ln_pointer); println!("mb flags: {:?}", mb_info.flags().unwrap()); if mb_info.flags().unwrap().contains(multiboot::MBInfoFlags::MEM_MAP) { multiboot::parse_mmap(mb_info); println!("Multiboot memory map parsed, physical memory map has been built"); } else { panic!("MB mmap is not presented"); } }</span></span></code> </pre> <br><p>  Una tarjeta de memoria es una lista vinculada para la cual la direcci√≥n f√≠sica inicial se especifica en la estructura b√°sica (no olvide traducir todo en virtuales) y el tama√±o de la matriz en bytes.  Debe recorrer la lista en funci√≥n del tama√±o de cada elemento, ya que, en <em>teor√≠a,</em> sus tama√±os pueden diferir.  As√≠ es como se ve la iteraci√≥n: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> MultibootInfo { . . . . . . <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mmap</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, index: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry&gt; { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::arch::get_mb_pointer_base; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> base: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = get_mb_pointer_base(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry = (base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..index { iter = ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + ((*iter).size <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) - base) &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_lenght) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {} } <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(iter) } }</code> </pre> <br><p>  Al analizar una tarjeta de memoria, iteramos a trav√©s de la estructura GRUB y la convertimos en un mapa de bits, con el cual OS1 trabajar√° para administrar la memoria f√≠sica.  Decid√≠ limitarme a un peque√±o conjunto de valores disponibles para el control: libre, ocupado, reservado, no disponible, aunque GRUB y BIOS ofrecen m√°s opciones.  Entonces, iteramos sobre las entradas del mapa y convertimos su estado de valores GRUB / BIOS a valores para OS1: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_mmap</span></span></span></span>(mbi: &amp;MultibootInfo) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmap_opt = mbi.get_mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = mmap_opt.unwrap(); crate::memory::physical::map((*mmap).addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, (*mmap).len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, translate_multiboot_mem_to_os1(&amp;(*mmap).mtype)); mmap_opt = mbi.get_mmap(i); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mmap_opt { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, _ =&gt; i += <span class="hljs-number"><span class="hljs-number">1</span></span>, } } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translate_multiboot_mem_to_os1</span></span></span></span>(mtype: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::memory::physical::{RESERVED, UNUSABLE, USABLE}; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mtype { &amp;MULTIBOOT_MEMORY_AVAILABLE =&gt; USABLE, &amp;MULTIBOOT_MEMORY_RESERVED =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_ACPI_RECLAIMABLE =&gt; RESERVED, &amp;MULTIBOOT_MEMORY_NVS =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_BADRAM =&gt; UNUSABLE, _ =&gt; UNUSABLE } }</code> </pre> <br><p>  La memoria f√≠sica se administra en el m√≥dulo memory :: physical, para el cual llamamos al m√©todo de mapa anterior, pas√°ndole la direcci√≥n de la regi√≥n, su longitud y estado.  Los 4 GB de memoria potencialmente disponibles para el sistema y divididos en p√°ginas de cuatro megabytes est√°n representados por dos bits en un mapa de bits, lo que le permite almacenar 4 estados para 1024 p√°ginas.  En total, esta construcci√≥n toma 256 bytes.  Un mapa de bits conduce a una terrible fragmentaci√≥n de la memoria, pero es comprensible y f√°cil de implementar, lo cual es lo m√°s importante para mi prop√≥sito. </p><br><p>  Eliminar√© la implementaci√≥n de mapa de bits debajo del spoiler para no saturar el art√≠culo.  La estructura puede contar el n√∫mero de clases y memoria libre, marcar p√°ginas por √≠ndice y direcci√≥n, y tambi√©n buscar p√°ginas libres (esto ser√° necesario en el futuro para implementar el mont√≥n).  La tarjeta en s√≠ es una matriz de 64 elementos u32, para aislar los dos bits (bloques) necesarios, se utiliza la conversi√≥n al llamado fragmento (√≠ndice en la matriz, empaque de 16 bloques) y el bloque (posici√≥n de bit en el fragmento). </p><br><div class="spoiler">  <b class="spoiler_title">Mapa de bits de memoria f√≠sica</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESERVED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UNUSABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEAD: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0xDEAD</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysMemoryInfo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> total: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, used: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, reserved: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunks: [<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>], } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PhysMemoryInfo { <span class="hljs-comment"><span class="hljs-comment">// returns (chunk, page) pub fn find_free(&amp;self) -&gt; (usize, usize) { for chunk in 0..64 { for page in 0.. 16 { if ((self.chunks[chunk] &gt;&gt; page * 2) &amp; 3) ^ 3 == 3 { return (chunk, page) } else {} } } (DEAD, 0) } // marks page to given flag and returns its address pub fn mark(&amp;mut self, chunk: usize, block: usize, flag: usize) -&gt; usize { self.chunks[chunk] = self.chunks[chunk] ^ (3 &lt;&lt; (block * 2)); let mask = (0xFFFFFFFC ^ flag).rotate_left(block as u32 * 2); self.chunks[chunk] = self.chunks[chunk] &amp; (mask as u32); if flag == USED { self.used += 1; } else if flag == UNUSABLE || flag == RESERVED { self.reserved += 1; } else { if self.used &gt; 0 { self.used -= 1; } } (chunk * 16 + block) &lt;&lt; 22 } pub fn mark_by_addr(&amp;mut self, addr: usize, flag: usize) { let block_num = addr &gt;&gt; 22; let chunk: usize = (block_num / 16) as usize; let block: usize = block_num - chunk * 16; self.mark(chunk, block, flag); } pub fn count_total(&amp; mut self) { let mut count: usize = 0; for i in 0..64 { let mut chunk = self.chunks[i]; for _j in 0..16 { if chunk &amp; 0b11 != 0b11 { count += 1; } chunk = chunk &gt;&gt; 2; } } self.total = count; } pub fn get_total(&amp;self) -&gt; usize { self.total } pub fn get_used(&amp;self) -&gt; usize { self.used } pub fn get_reserved(&amp;self) -&gt; usize { self.reserved } pub fn get_free(&amp;self) -&gt; usize { self.total - self.used - self.reserved } }</span></span></code> </pre> </div></div><br><p>  Y ahora llegamos al an√°lisis de un elemento del mapa.  Si un elemento del mapa describe un √°rea de memoria de menos de una p√°gina de 4 MB o igual, marcamos esta p√°gina como un todo.  Si es m√°s, batir en pedazos de 4 MB y marcar cada pieza por separado a trav√©s de la recursi√≥n.  En la etapa de inicializaci√≥n del mapa de bits, consideramos que todas las secciones de la memoria son inaccesibles, de modo que cuando la tarjeta se agota, por ejemplo, a 128 MB, las secciones restantes se marcan como inaccesibles. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> RAM_INFO: Mutex&lt;PhysMemoryInfo&gt; = Mutex::new(PhysMemoryInfo { total: <span class="hljs-number"><span class="hljs-number">0</span></span>, used: <span class="hljs-number"><span class="hljs-number">0</span></span>, reserved: <span class="hljs-number"><span class="hljs-number">0</span></span>, chunks: [<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>] }); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flag: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// if len &lt;= 4MiB then mark whole page with flag if len &lt;= 4 * 1024 * 1024 { RAM_INFO.lock().mark_by_addr(addr, flag); } else { let pages: usize = len &gt;&gt; 22; for map_page in 0..(pages - 1) { map(addr + map_page &lt;&lt; 22, 4 * 1024 * 1024, flag); } map(addr + (pages &lt;&lt; 22), len - (pages &lt;&lt; 22), flag); } }</span></span></code> </pre> <br><h1 id="kucha-i-upravlenie-ey">  Heap y manej√°ndola </h1><br><p>  Actualmente, la administraci√≥n de memoria virtual se limita solo a la administraci√≥n de almacenamiento din√°mico, ya que el n√∫cleo no sabe mucho m√°s.  En el futuro, por supuesto, ser√° necesario administrar toda la memoria, y este peque√±o administrador se reescribir√°.  Sin embargo, por el momento, todo lo que necesito es memoria est√°tica, que contiene el c√≥digo ejecutable y la pila, y memoria din√°mica de mont√≥n, donde asignar√© las estructuras para subprocesamiento m√∫ltiple.  Asignamos memoria est√°tica en la etapa de arranque (y hasta ahora tenemos 4 MB limitados, porque el n√∫cleo encaja en ellos) y, en general, no hay problemas con eso ahora.  Adem√°s, en esta etapa, no tengo dispositivos DMA, por lo que todo es extremadamente simple, pero comprensible. </p><br><p>  Le di 512 MB del espacio de memoria superior del n√∫cleo (0xE0000000) al mont√≥n, almaceno el mapa de uso del mont√≥n (0xDFC00000) 4 MB m√°s bajo.  Utilizo un mapa de bits para describir el estado, al igual que para la memoria f√≠sica, pero solo contiene 2 estados: ocupado / libre.  El tama√±o del bloque de memoria es de 64 bytes; esto es mucho para peque√±as variables como u32, u8, pero, tal vez, es √≥ptimo para almacenar estructuras de datos.  A√∫n as√≠, es poco probable que necesitemos almacenar variables individuales en el mont√≥n, ahora su prop√≥sito principal es almacenar estructuras de contexto para la multitarea. </p><br><p>  Los bloques de 64 bytes se agrupan en estructuras que describen el estado de una p√°gina completa de 4 MB, por lo que podemos asignar peque√±as y grandes cantidades de memoria a varias p√°ginas.  Utilizo los siguientes t√©rminos: fragmento - 64 bytes, paquete - 2 KB (uno u32 - 64 bytes * 32 bits por paquete), p√°gina - 4 MB. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(packed)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeapPageInfo</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], }</span></span></code> </pre> <br><p>  Cuando solicito memoria de un asignador, considero tres casos, dependiendo de la granularidad: </p><br><ul><li>  Una solicitud de memoria de menos de 2 KB vino del asignador.  Debe encontrar un paquete en el que estar√° libre [tama√±o / 64, cualquier resto distinto de cero agrega uno] fragmentos seguidos, marque estos fragmentos como ocupados, devuelva la direcci√≥n del primer fragmento. </li><li>  El asignador solicit√≥ una memoria de menos de 4 MB pero m√°s de 2 KB.  Debe encontrar una p√°gina que tenga paquetes gratuitos [tama√±o / 2048, cualquier resto distinto de cero agrega uno] seguidos.  Marque los paquetes [tama√±o / 2048] como ocupados; si hay un resto, marque los fragmentos [restantes] en el √∫ltimo paquete como ocupados. </li><li>  Una solicitud de memoria de m√°s de 4 MB vino del asignador.  Encuentre [tama√±o / 4 Mi, cualquier saldo distinto de cero agrega una] p√°ginas seguidas, marque las p√°ginas [tama√±o / 4 Mi] como ocupadas, si hay un saldo - marque los paquetes [saldo] como ocupados.  En el √∫ltimo paquete, marque el resto de los fragmentos como ocupados. </li></ul><br><p>  La b√∫squeda de √°reas libres tambi√©n depende de la granularidad: se selecciona una matriz para iteraci√≥n o m√°scaras de bits.  Cada vez que vas al extranjero, OOM sucede.  Cuando se desasigna, se usa un algoritmo similar, solo para el marcado lanzado.  La memoria liberada no se restablece.  Todo el c√≥digo es grande, lo pondr√© debajo del spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Mapa de bits de memoria virtual</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//512 MiB should be enough for kernel heap. If not - ooops... pub const KHEAP_START: usize = 0xE0000000; //I will keep 1MiB info about my heap in separate 4MiB page before heap at this point pub const KHEAP_INFO_ADDR: usize = 0xDFC00000; pub const KHEAP_CHUNK_SIZE: usize = 64; pub fn init() { KHEAP_INFO.lock().init(); } #[repr(packed)] #[derive(Copy, Clone)] struct HeapPageInfo { //every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } impl HeapPageInfo { pub fn init(&amp;mut self) { for i in 0..2048 { self._4mb_by_64b[i] = 0; } } pub fn mark_chunks_used(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] | mask; } pub fn mark_chunks_free(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] ^ mask; } pub fn empty(&amp;self) -&gt; bool { for i in 0..2048 { if self._4mb_by_64b[i] != 0 { return false } } true } } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], } impl HeapInfo { pub fn init(&amp;mut self) { for i in 0..128 { self._512mb_by_4mb[i].init(); } } // returns page number pub fn find_free_pages_of_size(&amp;self, n: usize) -&gt; usize { if n &gt;= 128 { 0xFFFFFFFF } else { let mut start_page: usize = 0xFFFFFFFF; let mut current_page: usize = 0xFFFFFFFF; for page in 0..128 { if self._512mb_by_4mb[page].empty() { if current_page - start_page == n { return start_page } if start_page == 0xFFFFFFFF { start_page = page; } current_page = page; } else { start_page = 0xFFFFFFFF; current_page = 0xFFFFFFFF; } } 0xFFFFFFFF } } // returns (page number, 32pack number) pub fn find_free_packs_of_size(&amp;self, n: usize) -&gt; (usize, usize) { if n &lt; 2048 { for page in 0..128 { let mut start_pack: usize = 0xFFFFFFFF; let mut current_pack: usize = 0xFFFFFFFF; for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; if _32pack_info == 0 { if current_pack - start_pack == n { return (page, start_pack) } if start_pack == 0xFFFFFFFF { start_pack = _32pack; } current_pack = _32pack; } else { start_pack = 0xFFFFFFFF; current_pack = 0xFFFFFFFF; } } } (0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF) } } // returns (page number, 32pack number, chunk number) pub fn find_free_chunks_of_size(&amp;self, n: usize) -&gt; (usize, usize, usize) { if n &lt; 32 { for page in 0..128 { for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n); for chunk in 0..(32-n) { if ((_32pack_info &gt;&gt; chunk) &amp; mask) ^ mask == mask { return (page, _32pack, chunk) } } } } (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } } fn mark_chunks_used(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_used(_32pack, chunk, n); } fn mark_chunks_free(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_free(_32pack, chunk, n); } fn mark_packs_used(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0xFFFFFFFF; } } fn mark_packs_free(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0; } } } use lazy_static::lazy_static; use spin::Mutex; lazy_static! { static ref KHEAP_INFO: Mutex&lt;&amp;'static mut HeapInfo&gt; = Mutex::new(unsafe { &amp;mut *(KHEAP_INFO_ADDR as *mut HeapInfo) }); } fn allocate_n_chunks_less_than_pack(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let (page, _32pack, chunk) = heap_info.find_free_chunks_of_size(n); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + _32pack * 32 * 64 + chunk * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_chunks_used(page, _32pack, chunk, n); uptr as *mut u8 } else { core::ptr::null_mut() } } } fn allocate_n_chunks_less_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let (page, pack) = heap_info.find_free_packs_of_size(packs_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + pack * 32 * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_packs_used(page, pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_used(page, pack + packs_to_alloc, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } //unsupported yet fn allocate_n_chunks_more_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let pages_n: usize = packs_to_alloc / 2048; let mut lost_packs = packs_to_alloc - pages_n * 2048; let mut pages_to_alloc = pages_n; if lost_packs != 0 { pages_to_alloc += 1; } if lost_chunks != 0 { lost_packs -= 1; } let page = heap_info.find_free_pages_of_size(pages_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B * n //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { for i in page..(page + pages_n) { heap_info.mark_packs_used(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_used(page + pages_to_alloc, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_used(page + pages_to_alloc, lost_packs, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } // returns pointer pub fn allocate_n_chunks(n: usize, align: usize) -&gt; *mut u8 { if n &lt; 32 { allocate_n_chunks_less_than_pack(n, align) } else if n &lt; 32 * 2048 { allocate_n_chunks_less_than_page(n, align) } else { allocate_n_chunks_more_than_page(n, align) } } pub fn free_chunks(ptr: usize, n: usize) { let page: usize = (ptr - KHEAP_START) / 0x400000; let _32pack: usize = ((ptr - KHEAP_START) - (page * 0x400000)) / (32 * 64); let chunk: usize = ((ptr - KHEAP_START) - (page * 0x400000) - (_32pack * (32 * 64))) / 64; let mut heap_info = KHEAP_INFO.lock(); if n &lt; 32 { heap_info.mark_chunks_free(page, _32pack, chunk, n); } else if n &lt; 32 * 2048 { let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; heap_info.mark_packs_free(page, _32pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_free(page, _32pack + packs_n, 0, lost_chunks); } } else { let packs_n: usize = n / 32; let pages_n: usize = packs_n / 2048; let lost_packs: usize = packs_n - pages_n * 2048; let lost_chunks = n - packs_n * 32; for i in page..(page + pages_n) { heap_info.mark_packs_free(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_free(page + pages_n, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_free(page + pages_n, packs_n, 0, lost_chunks); } } }</span></span></code> </pre> </div></div><br><h1 id="allokaciya-i-page-fault">  Asignaci√≥n y fallo de p√°gina </h1><br><p>  Para usar el mont√≥n, necesita un asignador.  Agregarlo nos abrir√° un vector, √°rboles, tablas hash, cajas y m√°s, sin los cuales es casi imposible vivir.  Tan pronto como conectemos el m√≥dulo de asignaci√≥n y declaremos un asignador global, la vida se volver√° m√°s f√°cil de inmediato. </p><br><p>  La implementaci√≥n del asignador es muy simple: simplemente se refiere al mecanismo descrito anteriormente. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::alloc::{GlobalAlloc, Layout}; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Os1Allocator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator {} <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GlobalAlloc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, layout: Layout) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, allocate_n_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } allocate_n_chunks(chunk_count, layout.align()) } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dealloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ptr: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, layout: Layout) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, free_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } free_chunks(ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunk_count); } }</code> </pre> <br><p>  El asignador en lib.rs se activa de la siguiente manera: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(alloc, alloc_error_handler)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> alloc; <span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOCATOR: memory::allocate::Os1Allocator = memory::allocate::Os1Allocator;</code> </pre> <br><p>  Y cuando tratamos de asignarnos de tal manera, obtenemos una excepci√≥n de falla de p√°gina, porque todav√≠a no hemos resuelto la asignaci√≥n de memoria virtual.  Bueno, como es eso!  Bueno, debe volver al material del art√≠culo anterior y agregar excepciones.  Decid√≠ implementar una asignaci√≥n diferida de memoria virtual, es decir, que la p√°gina se asign√≥ no en el momento de la solicitud de memoria, sino en el momento de intentar acceder a ella.  Afortunadamente, el procesador x86 permite e incluso fomenta esto.   Page fault     ,   ,    ,          ‚Äî      ,     ,    CR2 ‚Äî  ,    . </p><br><p>    ,      .        32 (     ,     ,     32 ),    .           Rust.           ,        .  ,   ,   iret    ,    ,     Page fault   Protection fault.        Protection fault ‚Äî ,        . </p><br><pre> <code class="plaintext hljs">eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret</code> </pre> <br><p>  Rust         ,    .     ,     .            .            . </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">bitflags!</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PFErrorCode</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PROTECTION = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 - protection caused, 0 - not present page caused const WRITE = 1 &lt;&lt; 1; //1 - write caused, 0 - read caused const USER_MODE = 1 &lt;&lt; 2; //1 - from user mode, 0 - from kernel const RESERVED = 1 &lt;&lt; 3; //1 - reserved page (PAE/PSE), 0 - not const INSTRUCTION = 1 &lt;&lt; 4; //1 - instruction fetch caused, 0 - not } } impl PFErrorCode { pub fn to_pd_flags(&amp;self) -&gt; super::super::paging::PDEntryFlags { use super::super::paging; let mut flags = paging::PDEntryFlags::empty(); if self.contains(PFErrorCode::WRITE) { flags.set(paging::PDEntryFlags::WRITABLE, true); } if self.contains(PFErrorCode::USER_MODE) { flags.set(paging::PDEntryFlags::USER_ACCESSIBLE, true); } flags } } #[no_mangle] pub unsafe extern fn kE_page_fault(ptr: usize, code: usize) { use super::super::paging; println!("Page fault occured at addr 0x{:X}, code {:X}", ptr, code); let phys_address = crate::memory::physical::alloc_page(); let code_flags: PFErrorCode = PFErrorCode::from_bits(code).unwrap(); if !code_flags.contains(PFErrorCode::PROTECTION) { //page not presented, we need to allocate the new one let mut flags: paging::PDEntryFlags = code_flags.to_pd_flags(); flags.set(paging::PDEntryFlags::HUGE_PAGE, true); paging::allocate_page(phys_address, ptr, flags); println!("Page frame allocated at Paddr {:#X} Laddr {:#X}", phys_address, ptr); } else { panic!("Protection error occured, cannot handle yet"); } }</span></span></code> </pre> <br><p>        ,   .  ,       .           .          ,      .    ,      ,        : </p><br><pre> <code class="rust hljs"> <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free()); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::vec::<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000</span></span> { vec.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec len {}, ptr is {:?}"</span></span>, vec.len(), vec.as_ptr()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works, check reusage!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec2: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span> { vec2.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec2 len {}, ptr is {:?}, vec is still here? {}"</span></span>, vec2.len(), vec2.as_ptr(), vec.get(<span class="hljs-number"><span class="hljs-number">1000</span></span>).unwrap()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free());</code> </pre> <br><p>     : <br><img src="https://habrastorage.org/webt/7x/y3/bs/7xy3bs8m91uxbmexphxpelzc2cs.jpeg" alt="Mont√≥n OS1"></p><br><p>  ,   ,           .          3,5  + 3 ,   .          3,5     . </p><br><p> IRQ 1    ‚Äî        Alt + PrntScrn :) </p><br><p> ,    ,      Rust ‚Äî       ,   ‚Äî    ,    ! </p><br><p>       ,                . </p><br><p>  Gracias por su atencion! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446214/">https://habr.com/ru/post/446214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446204/index.html">Pron√≥stico sobre c√≥mo se superar√°n las restricciones de Internet</a></li>
<li><a href="../446206/index.html">Tutorial de React Parte 26: Arquitectura de aplicaci√≥n, patr√≥n de contenedor / componente</a></li>
<li><a href="../446208/index.html">Tutorial React Parte 25: Taller sobre formularios</a></li>
<li><a href="../446210/index.html">ADAM-3600 - un controlador industrial multifuncional</a></li>
<li><a href="../446212/index.html">Profundidades SIEM: correlaciones listas para usar. Parte 5. Metodolog√≠a para desarrollar reglas de correlaci√≥n</a></li>
<li><a href="../446218/index.html">El dise√±ador de juegos no es muy diferente de un psic√≥pata. C√≥mo hicimos el juego CMAN</a></li>
<li><a href="../446222/index.html">Uso de potenciales t√©rmicos para el an√°lisis del territorio.</a></li>
<li><a href="../446228/index.html">Mejora de la calidad de la clasificaci√≥n de texto conectando Wikipedia</a></li>
<li><a href="../446230/index.html">Monitoreo y administraci√≥n remotos de dispositivos basados ‚Äã‚Äãen Linux / OpenWrt / Lede a trav√©s del puerto 80, continuaci√≥n</a></li>
<li><a href="../446234/index.html">C√≥mo los voluntarios de todo el mundo crean transmisiones en vivo de ICPC-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>