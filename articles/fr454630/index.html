<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß• üêÄ üëñ Situations exceptionnelles: partie 1 de 4 üëÇüèæ üë®üèæ‚Äçüè≠ üôãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 


 Il est temps de parler d'exceptions ou, plut√¥t, de situations exceptionnelles. Avant de commencer, regardons la d√©finition. Qu'est-ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Situations exceptionnelles: partie 1 de 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454630/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="introduction">  Pr√©sentation </h2><br><p>  Il est temps de parler d'exceptions ou, plut√¥t, de situations exceptionnelles.  Avant de commencer, regardons la d√©finition.  Qu'est-ce qu'une situation exceptionnelle? </p><br><p>  Il s'agit d'une situation qui rend l'ex√©cution du code actuel ou ult√©rieur incorrecte.  Je veux dire diff√©rent de la fa√ßon dont il a √©t√© con√ßu ou con√ßu.  Une telle situation compromet l'int√©grit√© d'une application ou de sa partie, par exemple un objet.  Il am√®ne l'application dans un √©tat extraordinaire ou exceptionnel. </p><br><p>  Mais pourquoi devons-nous d√©finir cette terminologie?  Parce que cela nous maintiendra dans certaines limites.  Si nous ne suivons pas la terminologie, nous pouvons nous √©loigner trop d'un concept con√ßu qui peut entra√Æner de nombreuses situations ambigu√´s.  Voyons quelques exemples pratiques: <br><br></p><br><pre><code class="plaintext hljs">struct Number { public static Number Parse(string source) { // ... if(!parsed) { throw new ParsingException(); } // ... } public static bool TryParse(string source, out Number result) { // .. return parsed; } }</code> </pre> <br><p>  Cet exemple semble un peu √©trange, et c'est pour une raison.  J'ai rendu ce code l√©g√®rement artificiel pour montrer l'importance des probl√®mes qui y apparaissent.  Tout d'abord, regardons la m√©thode <code>Parse</code> .  Pourquoi devrait-il lever une exception? </p><a name="habracut"></a><br><ul><li>  Parce que le param√®tre qu'il accepte est une cha√Æne, mais sa sortie est un nombre, qui est un type de valeur.  Ce nombre ne peut pas indiquer la validit√© des calculs: il existe simplement.  En d'autres termes, la m√©thode n'a aucun moyen dans son interface pour communiquer un probl√®me potentiel. </li><li>  D'un autre c√¥t√©, la m√©thode attend une cha√Æne correcte qui contient un certain nombre et aucun caract√®re redondant.  S'il ne contient pas, il y a un probl√®me dans les pr√©requis de la m√©thode: le code qui appelle notre m√©thode a pass√© des donn√©es erron√©es. </li></ul><br><p>  Ainsi, la situation lorsque cette m√©thode obtient une cha√Æne avec des donn√©es incorrectes est exceptionnelle car la m√©thode ne peut renvoyer ni une valeur correcte ni rien.  Ainsi, la seule fa√ßon est de lever une exception. </p><br><p>  La deuxi√®me variante de la m√©thode peut signaler certains probl√®mes avec les donn√©es d'entr√©e: la valeur de retour ici est <code>boolean</code> qui indique une ex√©cution r√©ussie de la m√©thode.  Cette m√©thode n'a pas besoin d'utiliser d'exceptions pour signaler des probl√®mes: elles sont toutes couvertes par la <code>false</code> valeur de retour. </p><br><h2 id="overview">  Pr√©sentation </h2><br><p>  La gestion des exceptions peut sembler aussi simple que ABC: il suffit de placer <code>try-catch</code> blocs <code>try-catch</code> et d'attendre les √©v√©nements correspondants.  Cependant, cette simplicit√© est devenue possible gr√¢ce au travail consid√©rable des √©quipes du CLR et du CoreCLR qui ont unifi√© toutes les erreurs provenant de toutes les directions et sources dans le CLR.  Pour comprendre de quoi nous allons parler ensuite, regardons un sch√©ma: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e12/163/521/e121635214ad6b5b5675ba4231eb85e7.png"></p><br><p>  Nous pouvons voir qu'√† l'int√©rieur du grand .NET Framework, il y a deux mondes: tout ce qui appartient √† CLR et tout ce qui ne l'est pas, y compris toutes les erreurs possibles apparaissant dans Windows et d'autres parties du monde dangereux. </p><br><ul><li>  La gestion structur√©e des exceptions (SEH) est une m√©thode standard utilis√©e par Windows pour g√©rer les exceptions.  Lorsque des m√©thodes <code>unsafe</code> sont appel√©es et que des exceptions sont lev√©es, il y a une conversion CLR &lt;-&gt; non s√ªre des exceptions dans les deux sens: de non s√©curis√© √† CLR et inversement.  Cela est d√ª au fait que CLR peut appeler une m√©thode non s√ªre qui peut appeler une m√©thode CLR √† son tour. </li><li>  Le traitement d'exception vectoris√© (VEH) est une racine de SEH et vous permet de placer vos gestionnaires dans des endroits o√π des exceptions peuvent √™tre lev√©es.  En particulier, il a √©t√© utilis√© pour placer <code>FirstChanceException</code> . </li><li>  Des exceptions COM + apparaissent lorsque la source d'un probl√®me est un composant COM.  Dans ce cas, une couche entre COM et une m√©thode .NET doit convertir une erreur COM en une exception .NET. </li><li>  Et, bien s√ªr, des emballages pour HRESULT.  Ils sont introduits pour convertir un mod√®le WinAPI (un code d'erreur est contenu dans une valeur de retour, tandis que les valeurs de retour sont obtenues √† l'aide des param√®tres de m√©thode) en un mod√®le d'exceptions car il s'agit d'une exception standard pour .NET. </li></ul><br><p>  D'un autre c√¥t√©, il existe des langages au-dessus de CLI, chacun ayant plus ou moins des fonctions pour g√©rer les exceptions.  Par exemple, r√©cemment VB.NET ou F # avait une fonctionnalit√© de gestion des exceptions plus riche exprim√©e dans un certain nombre de filtres qui n'existaient pas en C #. </p><br><h2 id="return-codes-vs-exception">  Codes retour vs.  exception </h2><br><p>  S√©par√©ment, je devrais mentionner un mod√®le de gestion des erreurs d'application √† l'aide de codes retour.  L'id√©e de simplement renvoyer une erreur est claire et claire.  De plus, si nous traitons les exceptions comme un op√©rateur <code>goto</code> , l'utilisation de codes retour devient plus raisonnable: dans ce cas, l'utilisateur d'une m√©thode voit la possibilit√© d'erreurs et peut comprendre quelles erreurs peuvent survenir.  Cependant, ne devinons pas ce qui est mieux et pour quoi, mais discutons du probl√®me du choix en utilisant une th√©orie bien raisonn√©e. </p><br><p>  Supposons que toutes les m√©thodes aient des interfaces pour traiter les erreurs.  Ensuite, toutes les m√©thodes devraient ressembler √†: </p><br><pre> <code class="plaintext hljs">public bool TryParseInteger(string source, out int result); public DialogBoxResult OpenDialogBox(...); public WebServiceResult IWebService.GetClientsList(...); public class DialogBoxResult : ResultBase { ... } public class WebServiceResult : ResultBase { ... }</code> </pre> <br><p>  Et leur utilisation ressemblerait √†: </p><br><pre> <code class="plaintext hljs">public ShowClientsResult ShowClients(string group) { if(!TryParseInteger(group, out var clientsGroupId)) return new ShowClientsResult { Reason = ShowClientsResult.Reason.ParsingFailed }; var webResult = _service.GetClientsList(clientsGroupId); if(!webResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.ServiceFailed, WebServiceResult = webResult }; } var dialogResult = _dialogsService.OpenDialogBox(webResult.Result); if(!dialogResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.DialogOpeningFailed, DialogServiceResult = dialogResult }; } return ShowClientsResult.Success(); }</code> </pre> <br><p>  Vous pensez peut-√™tre que ce code est surcharg√© par la gestion des erreurs.  Cependant, je voudrais que vous reconsid√©riez votre position: tout ici est une √©mulation d'un m√©canisme qui l√®ve et g√®re les exceptions. </p><br><p>  Comment une m√©thode peut-elle signaler un probl√®me?  Il peut le faire en utilisant une interface pour signaler les erreurs.  Par exemple, dans la m√©thode <code>TryParseInteger</code> , cette interface est repr√©sent√©e par une valeur de retour: si tout est OK, la m√©thode retournera <code>true</code> .  Si ce n'est pas OK, il retournera <code>false</code> .  Cependant, il y a un inconv√©nient ici: la valeur r√©elle est retourn√©e via le param√®tre de <code>out int result</code> .  L'inconv√©nient est que d'une part la valeur de retour est logiquement et par perception a plus d'essence de "valeur de retour" que celle du param√®tre <code>out</code> . D'autre part, nous ne nous soucions pas toujours des erreurs. En effet, si une cha√Æne destin√©e √† l'analyse provient d'un service qui a g√©n√©r√© cette cha√Æne, nous n'avons pas besoin de la v√©rifier pour les erreurs: la cha√Æne sera toujours correcte et bonne pour l'analyse. Cependant, supposons que nous prenions une autre impl√©mentation de la m√©thode: </p><br><pre> <code class="plaintext hljs">public int ParseInt(string source);</code> </pre> <br><p>  Ensuite, il y a une question: si une cha√Æne contient des erreurs, que doit faire la m√©thode?  Doit-il retourner z√©ro?  Ce ne sera pas correct: il n'y a pas de z√©ro dans la cha√Æne.  Dans ce cas, nous avons un conflit d'int√©r√™ts: la premi√®re variante a trop de code, tandis que la deuxi√®me variante n'a aucun moyen de signaler les erreurs.  Cependant, il est en fait facile de d√©cider quand utiliser des codes retour et quand utiliser des exceptions. </p><br><blockquote>  Si obtenir une erreur est une norme, choisissez un code retour.  Par exemple, il est normal qu'un algorithme d'analyse de texte rencontre des erreurs dans un texte, mais si un autre algorithme qui fonctionne avec une cha√Æne analys√©e obtient une erreur d'un analyseur, il peut √™tre critique ou, en d'autres termes, exceptionnel. </blockquote><br><h2 id="try-catch-finally-in-brief">  Try-catch-finally en bref </h2><br><p>  Un bloc <code>try</code> couvre une section o√π un programmeur s'attend √† obtenir une situation critique qui est trait√©e comme une norme par du code externe.  En d'autres termes, si un code consid√®re que son √©tat interne est incoh√©rent en fonction de certaines r√®gles et l√®ve une exception, un syst√®me externe, qui a une vue plus large de la m√™me situation, peut intercepter cette exception √† l'aide d'un bloc <code>catch</code> et normaliser l'ex√©cution du code d'application .  Ainsi, <em>vous l√©galisez les exceptions dans cette section de code en les interceptant</em> .  Je pense que c'est une id√©e importante qui justifie l'interdiction de capturer toutes <code>try-catch(Exception ex){ ...}</code> <em>au cas o√π</em> . </p><br><p>  Cela ne signifie pas que la capture d'exceptions contredit certaines id√©ologies.  Je dis que vous ne devez d√©tecter que les erreurs que vous attendez d'une section particuli√®re de code.  Par exemple, vous ne pouvez pas vous attendre √† tous les types d'exceptions h√©rit√©es de <code>ArgumentException</code> ou vous ne pouvez pas obtenir <code>NullReferenceException</code> , car cela signifie souvent qu'un probl√®me est plut√¥t dans <em>votre</em> code que dans celui appel√©.  Mais il convient de s'attendre √† ce que vous ne puissiez pas ouvrir un fichier pr√©vu.  M√™me si vous √™tes s√ªr √† 200% que vous pourrez, n'oubliez pas de v√©rifier. </p><br><p>  Le bloc <code>finally</code> est √©galement bien connu.  Il convient √† tous les cas couverts par <code>try-catch</code> blocs <code>try-catch</code> .  √Ä l'exception de plusieurs rares situations <em>sp√©ciales</em> , ce bloc fonctionnera <em>toujours</em> .  Pourquoi une telle garantie de performance a-t-elle √©t√© introduite?  Pour nettoyer les ressources et les groupes d'objets qui ont √©t√© allou√©s ou captur√©s dans le bloc <code>try</code> et dont ce bloc est responsable. </p><br><p>  Ce bloc est souvent utilis√© sans bloc <code>catch</code> lorsque nous ne nous soucions pas de l'erreur qui a cass√© un algorithme, mais nous devons nettoyer toutes les ressources allou√©es √† cet algorithme.  Regardons un exemple simple: un algorithme de copie de fichiers a besoin de deux fichiers ouverts et d'une plage de m√©moire pour un tampon de tr√©sorerie.  Imaginez que nous avons allou√© de la m√©moire et ouvert un fichier, mais que nous ne pouvions pas en ouvrir un autre.  Pour envelopper tout dans une "transaction" atomiquement, nous mettons les trois op√©rations dans un seul bloc <code>try</code> (comme variante d'impl√©mentation) avec des ressources <code>finally</code> nettoy√©es. Cela peut sembler un exemple simplifi√© mais le plus important est de montrer l'essentiel. </p><br><p>  Ce qui manque r√©ellement √† C #, c'est un bloc de <code>fault</code> qui est activ√© chaque fois qu'une erreur se produit.  C'est <code>finally</code> comme sous st√©ro√Ødes.  Si nous avions cela, nous pourrions, par exemple, cr√©er un point d'entr√©e unique pour enregistrer les situations exceptionnelles: </p><br><pre> <code class="plaintext hljs">try { //... } fault exception { _logger.Warn(exception); }</code> </pre><br><p>  Une autre chose que je devrais toucher dans cette introduction est les filtres d'exception.  Ce n'est pas une nouvelle fonctionnalit√© sur la plate-forme .NET mais les d√©veloppeurs C # peuvent √™tre nouveaux pour elle: le filtrage des exceptions n'apparaissait que dans v.  6.0.  Les filtres doivent normaliser une situation lorsqu'il existe un seul type d'exception combinant plusieurs types d'erreurs.  Cela devrait nous aider lorsque nous voulons traiter un sc√©nario particulier, mais devons d'abord attraper tout le groupe d'erreurs et les filtrer plus tard.  Bien s√ªr, je veux dire le code du type suivant: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) { switch(exception.ErrorCode) { case ErrorCode.MissingModifier: // ... break; case ErrorCode.MissingBracket: // ... break; default: throw; } }</code> </pre> <br><p>  Eh bien, nous pouvons maintenant r√©√©crire ce code correctement: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingModifier) { // ... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingBracket) { // ... }</code> </pre> <br><p>  L'am√©lioration ici n'est pas dans le manque de construction de <code>switch</code> .  Je crois que cette nouvelle construction est meilleure √† plusieurs √©gards: </p><br><ul><li>  en utilisant <code>when</code> pour filtrer, nous capturons exactement ce que nous voulons et c'est juste en termes d'id√©ologie; </li><li>  le code devient plus lisible sous cette nouvelle forme.  En parcourant le code, notre cerveau peut identifier plus facilement les blocs pour g√©rer les erreurs car il recherche initialement les <code>catch</code> et non les <code>switch-case</code> ; </li><li>  le dernier mais non le moindre: une comparaison pr√©liminaire est AVANT d'entrer dans le bloc de capture.  Cela signifie que si nous faisons de fausses suppositions sur des situations potentielles, cette construction fonctionnera plus rapidement que de <code>switch</code> dans le cas de lever une exception √† nouveau. </li></ul><br><p>  De nombreuses sources disent que la particularit√© de ce code est que le filtrage a lieu <em>avant le</em> d√©roulement de la pile.  Vous pouvez le voir dans les situations o√π il n'y a aucun autre appel, sauf d'habitude entre l'endroit o√π une exception est lev√©e et l'endroit o√π la v√©rification du filtrage se produit. </p><br><pre> <code class="plaintext hljs">static void Main() { try { Foo(); } catch (Exception ex) when (Check(ex)) { ; } } static void Foo() { Boo(); } static void Boo() { throw new Exception("1"); } static bool Check(Exception ex) { return ex.Message == "1"; }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e41/c44/c6b/e41c44c6b41164af3aff1aa9489f417f.png" alt="Empiler sans d√©rouler"></p><br><p>  Vous pouvez voir sur l'image que la trace de la pile contient non seulement le premier appel de <code>Main</code> comme point pour intercepter une exception, mais la pile enti√®re avant le point de lever une exception et la seconde entrant dans <code>Main</code> via un code non manag√©.  Nous pouvons supposer que ce code est exactement le code pour lever des exceptions qui est au stade du filtrage et du choix d'un gestionnaire final.  Cependant, <em>tous les appels ne peuvent pas √™tre trait√©s sans d√©roulement de la pile</em> .  Je pense qu'une uniformit√© excessive de la plateforme g√©n√®re trop de confiance en elle.  Par exemple, lorsqu'un domaine appelle une m√©thode d'un autre domaine, il est absolument transparent en termes de code.  Cependant, la fa√ßon dont les m√©thodes appellent le travail est une tout autre histoire.  Nous allons en parler dans la prochaine partie. </p><br><h3 id="serialization">  S√©rialisation </h3><br><p>  Commen√ßons par regarder les r√©sultats de l'ex√©cution du code suivant (j'ai ajout√© le transfert d'un appel √† travers la fronti√®re entre deux domaines d'application). </p><br><pre> <code class="plaintext hljs"> class Program { static void Main() { try { ProxyRunner.Go(); } catch (Exception ex) when (Check(ex)) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { throw new Exception("1"); } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner) dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } } }</code> </pre><br><p>  Nous pouvons voir que le d√©roulement de la pile se produit avant d'arriver au filtrage.  Regardons les captures d'√©cran.  La premi√®re est prise avant la g√©n√©ration d'une exception: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bda/8d8/792/bda8d87928516a8213cafdf953d029b6.png" alt="Stackunnroll"></p><br><p>  Le second est apr√®s: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c2b/f45/dee/c2bf45dee3a13091259468415719dbea.png" alt="Stackacknroll2"></p><br><p>  √âtudions le suivi des appels avant et apr√®s le filtrage des exceptions.  Que se passe-t-il ici?  Nous pouvons voir que les d√©veloppeurs de plates-formes ont cr√©√© quelque chose qui, √† premi√®re vue, ressemble √† la protection d'un sous-domaine.  Le suivi est coup√© apr√®s la derni√®re m√©thode de la cha√Æne d'appel, puis il y a le transfert vers un autre domaine.  Mais je pense que cela semble √©trange.  Pour comprendre pourquoi cela se produit, rappelons la r√®gle principale pour les types qui organisent l'interaction entre les domaines.  Ces types doivent h√©riter de <code>MarshalByRefObject</code> et √™tre s√©rialisables.  Cependant, malgr√© la rigueur des types d'exception C #, ils peuvent √™tre de toute nature.  Qu'est-ce que cela signifie?  Cela signifie que des situations peuvent se produire lorsqu'une exception √† l'int√©rieur d'un sous-domaine peut √™tre intercept√©e dans un domaine parent.  De plus, si un objet de donn√©es qui peut entrer dans une situation exceptionnelle a des m√©thodes dangereuses en termes de s√©curit√©, il peut √™tre appel√© dans un domaine parent.  Pour √©viter cela, l'exception est d'abord s√©rialis√©e, puis elle franchit la fronti√®re entre les domaines d'application et r√©appara√Æt avec une nouvelle pile.  V√©rifions cette th√©orie: </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] class Cast { [FieldOffset(0)] public Exception Exception; [FieldOffset(0)] public object obj; } static void Main() { try { ProxyRunner.Go(); Console.ReadKey(); } catch (RuntimeWrappedException ex) when (ex.WrappedException is Program) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { var x = new Cast {obj = new Program()}; throw x.Exception; } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner)dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } }</code> </pre> <br><p>  Pour que le code C # puisse lever une exception de n'importe quel type (je ne veux pas vous torturer avec MSIL), j'ai ex√©cut√© une astuce dans cet exemple en convertissant un type en un type non comparable, afin que nous puissions lever une exception de tout type, mais le traducteur penserait que nous utilisons le type <code>Exception</code> .  Nous cr√©ons une instance du type <code>Program</code> , qui n'est pas s√©rialisable √† coup s√ªr, et levons une exception en utilisant ce type comme charge de travail.  La bonne nouvelle est que vous obtenez un wrapper pour les exceptions non-exception de <code>RuntimeWrappedException</code> qui stockera une instance de notre objet de type <code>Program</code> int√©rieur et nous pourrons intercepter cette exception.  Cependant, il y a de mauvaises nouvelles qui soutiennent notre id√©e: appeler <code>proxy.MethodInsideAppDomain();</code>  va g√©n√©rer <code>SerializationException</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1ad/ace/7f1/1adace7f1c21e2ad7edc51b36f343dc9.png"></p><br><p>  Ainsi, vous ne pouvez pas transf√©rer une telle exception entre des domaines car il n'est pas possible de la s√©rialiser.  Cela, √† son tour, signifie que l'utilisation de filtres d'exception pour encapsuler les appels de m√©thodes dans d'autres domaines entra√Ænera de toute fa√ßon un d√©roulement de la pile malgr√© le fait que la s√©rialisation ne semble pas n√©cessaire avec les param√®tres <code>FullTrust</code> d'un sous-domaine. </p><br><blockquote>  Nous devons pr√™ter une attention suppl√©mentaire √† la raison pour laquelle la s√©rialisation entre les domaines est si n√©cessaire.  Dans notre exemple artificiel, nous cr√©ons un sous-domaine qui n'a pas de param√®tres.  Cela signifie que cela fonctionne de mani√®re FullTrust.  CLR fait enti√®rement confiance √† son contenu et n'ex√©cute aucune v√©rification suppl√©mentaire.  Cependant, lorsque vous ins√©rez au moins un param√®tre de s√©curit√©, la confiance totale dispara√Ætra et CLR commencera √† contr√¥ler tout ce qui se passe √† l'int√©rieur d'un sous-domaine.  Ainsi, lorsque vous avez un domaine enti√®rement fiable, vous n'avez pas besoin d'une s√©rialisation.  Admettez, nous n'avons pas besoin de nous prot√©ger.  Mais la s√©rialisation existe non seulement pour la protection.  Chaque domaine charge tous les assemblys n√©cessaires une deuxi√®me fois et cr√©e leurs copies.  Ainsi, il cr√©e des copies de tous les types et de tous les VMT.  Bien s√ªr, lorsque vous passez un objet de domaine en domaine, vous obtiendrez le m√™me objet.  Mais ses VMT ne seront pas les siens et cet objet ne peut pas √™tre converti en un autre type.  En d'autres termes, si nous cr√©ons une instance d'un type <code>Boo</code> et l'obtenons dans un autre domaine, le casting de <code>(Boo)boo</code> ne fonctionnera pas.  Dans ce cas, la s√©rialisation et la d√©s√©rialisation r√©soudront le probl√®me car l'objet existera dans deux domaines simultan√©ment.  Il existera avec toutes ses donn√©es l√† o√π il a √©t√© cr√©√© et il existera dans le domaine d'utilisation en tant qu'objet proxy, garantissant que les m√©thodes d'un objet d'origine sont appel√©es. </blockquote><p>  En transf√©rant un objet s√©rialis√© entre domaines, vous obtenez une copie compl√®te de l'objet d'un domaine dans un autre tout en conservant une d√©limitation en m√©moire.  Cependant, cette d√©limitation est fictive.  Il est utilis√© uniquement pour les types qui ne sont pas dans <code>Shared AppDomain</code> .  Ainsi, si vous lancez quelque chose de non s√©rialisable en tant qu'exception, mais √† partir de <code>Shared AppDomain</code> , vous n'obtiendrez pas d'erreur de s√©rialisation (nous pouvons essayer de lancer <code>Action</code> au lieu de <code>Program</code> ).  Cependant, le d√©roulement de la pile se produira de toute fa√ßon dans ce cas: car les deux variantes devraient fonctionner de mani√®re standard.  Pour que personne ne soit confus. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454630/">https://habr.com/ru/post/fr454630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454618/index.html">Fosse de productivit√©: comment Slack blesse notre flux de travail</a></li>
<li><a href="../fr454620/index.html">#NoDeployFriday: aide ou nuit?</a></li>
<li><a href="../fr454622/index.html">Kreisel EVEX 910e: mod√®le historique - nouvelle vie</a></li>
<li><a href="../fr454626/index.html">DevOops hier et aujourd'hui</a></li>
<li><a href="../fr454628/index.html">Construire un syst√®me de mod√©ration automatique des messages</a></li>
<li><a href="../fr454634/index.html">Security Week 23: vuln√©rabilit√© du bloc-notes, un million de syst√®mes avec RDP non corrig√©</a></li>
<li><a href="../fr454640/index.html">D√©bogage √† distance du microservice via SSH sous VPN en 4 tours</a></li>
<li><a href="../fr454642/index.html">"" Faire une application pour les gens "- ce n'est pas √† gribouiller": √† propos du d√©veloppement mobile dans CFT</a></li>
<li><a href="../fr454644/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 8. Configuration du commutateur</a></li>
<li><a href="../fr454646/index.html">@Pythonetc compilation, mai 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>