<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õîÔ∏è üöµüèº üö• Hexagon Maps in Unity: Pfadfinder, Spielertrupps, Animationen üõ¢Ô∏è ü¶ã üöæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenh√∂hen 

 Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen 

 Teile 8-11: Wasser, Landformen und W√§lle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hexagon Maps in Unity: Pfadfinder, Spielertrupps, Animationen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426481/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenh√∂hen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und W√§lle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 16: Den Weg finden </h1><br><ul><li>  Markieren Sie Zellen </li><li>  W√§hlen Sie ein Suchziel </li><li>  Finde den k√ºrzesten Weg </li><li>  Erstellen Sie eine Priorit√§tswarteschlange </li></ul><br>  Nachdem wir die Abst√§nde zwischen den Zellen berechnet hatten, suchten wir die Pfade zwischen ihnen. <br><br>  Ab diesem Teil werden in Unity 5.6.0 Hexagon Map-Tutorials erstellt.  Es sollte beachtet werden, dass es in 5.6 einen Fehler gibt, der Arrays von Texturen in Assemblys f√ºr mehrere Plattformen zerst√∂rt.  Sie k√∂nnen dies umgehen, indem Sie <em>Is Readable</em> in den Texturarray-Inspektor aufnehmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/165/c4e/1d9165c4e1862b050015df3c9dcc48cd.jpg"></div><br>  <i>Eine Reise planen</i> <br><a name="habracut"></a><br><h2>  Markierte Zellen </h2><br>  Um den Pfad zwischen zwei Zellen zu durchsuchen, m√ºssen wir zuerst diese Zellen ausw√§hlen.  Es ist mehr als nur die Auswahl einer Zelle und die √úberwachung der Suche auf der Karte.  Zum Beispiel werden wir zuerst die erste Zelle und dann die letzte ausw√§hlen.  In diesem Fall w√§re es praktisch, wenn sie hervorgehoben w√ºrden.  F√ºgen wir daher eine solche Funktionalit√§t hinzu.  Bis wir eine ausgefeilte oder effiziente Art der Hervorhebung erstellen, erstellen wir nur etwas, das uns bei der Entwicklung hilft. <br><br><h3>  Gliederung Textur </h3><br>  Eine einfache M√∂glichkeit, Zellen auszuw√§hlen, besteht darin, ihnen einen Pfad hinzuzuf√ºgen.  Der einfachste Weg, dies zu tun, ist mit einer Textur, die einen sechseckigen Umriss enth√§lt.  <a href="">Hier k√∂nnen</a> Sie eine solche Textur herunterladen.  Es ist bis auf den wei√üen Umriss des Sechsecks transparent.  Nachdem wir es wei√ü gemacht haben, k√∂nnen wir es in Zukunft nach Bedarf einf√§rben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/4u/vs/0j4uvsbyjtxiavcwaajn73csp68.png"></div><br>  <i>Zellenumriss auf schwarzem Hintergrund</i> <br><br>  Importieren Sie die Textur und setzen Sie den <em>Texturtyp</em> auf <em>Sprite</em> .  Ihr <em>Sprite-Modus</em> wird mit den Standardeinstellungen auf <em>Single eingestellt</em> .  Da dies eine au√üergew√∂hnlich wei√üe Textur ist, m√ºssen wir nicht in <em>sRGB</em> konvertieren.  Der Alpha-Kanal zeigt Transparenz an. Aktivieren Sie also <em>Alpha ist Transparenz</em> .  Ich habe auch die <em>Filtermodus-</em> Textur auf <em>Trilinear eingestellt</em> , da sonst die Mip-√úberg√§nge f√ºr die Pfade m√∂glicherweise zu auff√§llig werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebb/e4a/a88/ebbe4aa88f93b71cf5946c4c011339dc.png"></div><br>  <i>Texturimportoptionen</i> <br><br><h3>  Ein Sprite pro Zelle </h3><br>  Der schnellste Weg besteht darin, den Zellen eine m√∂gliche Kontur hinzuzuf√ºgen und jedes eigene Sprite hinzuzuf√ºgen.  Erstellen Sie ein neues Spielobjekt, f√ºgen Sie die Image-Komponente ( <em>Component / UI / Image</em> ) hinzu und weisen Sie ihr unser Gliederungssprite zu.  F√ºgen Sie dann die <em>Hex Cell Label-</em> Fertighausinstanz in die Szene ein, machen Sie das Sprite-Objekt zu einem untergeordneten Objekt, √ºbernehmen Sie die √Ñnderungen auf das Fertighaus und entfernen Sie das Fertighaus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/7f6/7f4/5c27f67f4596673f5b2e73b2db5073cd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/f7c/ea8/5daf7cea84e2ff46829460e0523bfa91.png"></div><br>  <i>Fertiges untergeordnetes Auswahlelement</i> <br><br>  Jetzt hat jede Zelle ein Sprite, aber es wird zu gro√ü sein.  √Ñndern Sie die <em>Breite</em> und <em>H√∂he</em> der Transformationskomponente des Sprites auf 17, damit die Konturen mit den Zentren der Zellen √ºbereinstimmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/069/e42/bc1069e4216435f1a30af953af5b948a.png"></div><br>  <i>Auswahl-Sprites, die teilweise durch ein Relief verborgen sind</i> <br><br><h3>  Auf alles zeichnen </h3><br>  Da die Kontur dem Bereich der Zellenr√§nder √ºberlagert ist, erscheint sie h√§ufig unter der Geometrie des Reliefs.  Aus diesem Grund verschwindet ein Teil der Schaltung.  Dies kann vermieden werden, indem die Sprites leicht vertikal angehoben werden, jedoch nicht bei Br√ºchen.  Stattdessen k√∂nnen wir Folgendes tun: Zeichne immer Sprites √ºber alles andere.  Erstellen Sie dazu Ihren eigenen Sprite-Shader.  Es wird ausreichen, den Standard-Unity-Sprite-Shader zu kopieren und einige √Ñnderungen daran vorzunehmen. <br><br><pre><code class="hljs powershell">Shader <span class="hljs-string"><span class="hljs-string">"Custom/Highlight"</span></span> { Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">MaterialToggle</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PixelSnap</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Pixel snap"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RendererColor</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"RendererColor"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Flip"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"External Alpha"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableExternalAlpha</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Enable External Alpha"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"PreviewType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Plane"</span></span> <span class="hljs-string"><span class="hljs-string">"CanUseSpriteAtlas"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> } Cull Off ZWrite Off Blend One OneMinusSrcAlpha Pass { CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">#pragma vertex SpriteVert #pragma fragment SpriteFrag #pragma target 2.0 #pragma multi_compile_instancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #include "UnitySprites.cginc" ENDCG } } }</span></span></code> </pre> <br>  Die erste √Ñnderung besteht darin, dass wir den Tiefenpuffer ignorieren, sodass der Z-Test immer erfolgreich ist. <br><br><pre> <code class="hljs pgsql"> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span></code> </pre> <br>  Die zweite √Ñnderung besteht darin, dass wir nach dem Rest der transparenten Geometrie rendern.  Genug, um der Transparenzwarteschlange 10 hinzuzuf√ºgen. <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+10"</span></span></code> </pre> <br>  Erstellen Sie ein neues Material, das dieser Shader verwenden wird.  Wir k√∂nnen alle seine Eigenschaften ignorieren und dabei die Standardwerte einhalten.  Lassen Sie dann das Sprite-Fertighaus dieses Material verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/d01/812/15bd01812d94f52ced67308dd000c430.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/393/e24/ef5393e241252d81513a0ff5f8972b50.png"></div><br>  <i>Wir verwenden unser eigenes Sprite-Material</i> <br><br>  Jetzt sind die Konturen der Auswahl immer sichtbar.  Selbst wenn die Zelle unter einem h√∂heren Relief verborgen ist, wird ihr Umriss immer noch √ºber alles andere gezeichnet.  Es mag nicht sch√∂n aussehen, aber die ausgew√§hlten Zellen sind immer sichtbar, was f√ºr uns n√ºtzlich ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/8bc/418/ce28bc418dc0ec116cff1bcbaddf0363.png"></div><br>  <i>Ignorieren Sie den Tiefenpuffer</i> <br><br><h3>  Auswahlkontrolle </h3><br>  Wir m√∂chten nicht, dass alle Zellen gleichzeitig hervorgehoben werden.  Tats√§chlich sollten sie zun√§chst alle nicht ausgew√§hlt sein.  Wir k√∂nnen dies implementieren, indem wir die Image-Komponente des Prelight-Objekts <em>Highlight</em> deaktivieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/00e/164/82f00e164316900fb9d9694030298bcc.png"></div><br>  <i>Bildkomponente deaktiviert</i> <br><br>  <code>HexCell</code> <code>EnableHighlight</code> die <code>HexCell</code> Methode hinzu, um die <code>HexCell</code> zu <code>EnableHighlight</code> .  Es sollte das einzige Kind seines <code>uiRect</code> und seine Image-Komponente enthalten.  Wir werden auch die <code>DisableHighlight</code> Methode erstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Schlie√ülich k√∂nnen wir die Farbe so festlegen, dass die Hintergrundbeleuchtung beim Einschalten einen Farbton erh√§lt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.color = color; highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Den Weg finden </h2><br>  Nachdem wir die Zellen ausw√§hlen k√∂nnen, m√ºssen wir zwei Zellen ausw√§hlen und dann den Pfad zwischen ihnen finden.  Zuerst m√ºssen wir die Zellen ausw√§hlen, dann die Suche auf einen Pfad zwischen ihnen beschr√§nken und schlie√ülich diesen Pfad anzeigen. <br><br><h3>  Suche starten </h3><br>  Wir m√ºssen zwei verschiedene Zellen ausw√§hlen, den Start- und den Endpunkt der Suche.  Angenommen, um die erste Suchzelle auszuw√§hlen, halten Sie die linke Umschalttaste gedr√ºckt, w√§hrend Sie mit der Maus klicken.  In diesem Fall wird die Zelle blau hervorgehoben.  Wir m√ºssen den Link zu dieser Zelle f√ºr die weitere Suche speichern.  Au√üerdem muss bei der Auswahl einer neuen Startzelle die Auswahl der alten deaktiviert werden.  Daher f√ºgen wir <code>searchFromCell</code> das Feld <code>searchFromCell</code> . <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell;</code> </pre> <br>  In <code>HandleInput</code> wir <code>Input.GetKey(KeyCode.LeftShift)</code> , um die gedr√ºckte Umschalttaste zu testen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/a63/1c3/d50a631c3f4701e414b2e9a9078a57a2.png"></div><br>  <i>Wo soll man suchen?</i> <br><br><h3>  Endpunkt suchen </h3><br>  Anstatt nach allen Abst√§nden zu einer Zelle zu suchen, suchen wir jetzt nach einem Pfad zwischen zwei bestimmten Zellen.  <code>HexGrid.FindDistancesTo</code> <code>HexGrid.FindPath</code> daher <code>HexGrid.FindDistancesTo</code> in <code>HexGrid.FindPath</code> und geben Sie ihm den zweiten <code>HexCell</code> Parameter. <code>HexGrid.FindPath</code> Sie au√üerdem die <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(fromCell); ‚Ä¶ }</code> </pre> <br>  Jetzt sollte <code>HexMapEditor.HandleInput</code> die ge√§nderte Methode aufrufen und <code>currentCell</code> und <code>currentCell</code> als Argumente verwenden.  Au√üerdem k√∂nnen wir nur suchen, wenn wir wissen, aus welcher Zelle wir suchen sollen.  Und wir m√ºssen uns nicht die M√ºhe machen, zu suchen, ob Start- und Endpunkt √ºbereinstimmen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { hexGrid.FindPath(searchFromCell, currentCell); }</code> </pre> <br>  Wenn wir uns der Suche zuwenden, m√ºssen wir zuerst alle vorherigen Auswahlen entfernen.  <code>HexGrid.Search</code> daher <code>HexGrid.Search</code> , dass <code>HexGrid.Search</code> die Auswahl <code>HexGrid.Search</code> , wenn Sie Entfernungen zur√ºcksetzen.  Da dies auch die Beleuchtung der Ausgangszelle ausschaltet, schalten Sie sie wieder ein.  In dieser Phase k√∂nnen wir auch den Endpunkt hervorheben.  Lass sie rot werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].DisableHighlight(); } fromCell.EnableHighlight(Color.blue); toCell.EnableHighlight(Color.red); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/01c/5e5/18101c5e578322ea99598cbca70f60a9.png"></div><br>  <i>Endpunkte eines m√∂glichen Pfades</i> <br><br><h3>  Suche einschr√§nken </h3><br>  Zu diesem Zeitpunkt berechnet unser Suchalgorithmus noch die Entfernungen zu allen Zellen, die von der Startzelle aus erreichbar sind.  Aber wir brauchen es nicht mehr.  Wir k√∂nnen anhalten, sobald wir die endg√ºltige Entfernung zur endg√ºltigen Zelle gefunden haben.  Das hei√üt, wenn die aktuelle Zelle endlich ist, k√∂nnen wir die Algorithmusschleife verlassen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/424/6e0/d49/4246e0d491a1938dfb1e9b3a00080e42.png"></div><br>  <i>Halten Sie am Endpunkt an</i> <br><br><div class="spoiler">  <b class="spoiler_title">Was passiert, wenn der Endpunkt nicht erreicht werden kann?</b> <div class="spoiler_text">  Dann arbeitet der Algorithmus weiter, bis alle erreichbaren Zellen gefunden sind.  Ohne die M√∂glichkeit eines vorzeitigen Ausstiegs funktioniert es wie die alte <code>FindDistancesTo</code> Methode. </div></div><br><h3>  Pfadanzeige </h3><br>  Wir k√∂nnen den Abstand zwischen dem Anfang und dem Ende des Pfades finden, wissen aber noch nicht, wie der tats√§chliche Pfad aussehen wird.  Um es zu finden, m√ºssen Sie verfolgen, wie jede Zelle erreicht wird.  Aber wie geht das? <br><br>  Wenn Sie dem Rand eine Zelle hinzuf√ºgen, tun wir dies, weil sie ein Nachbar der aktuellen Zelle ist.  Die einzige Ausnahme ist die Startzelle.  Alle anderen Zellen wurden √ºber die aktuelle Zelle erreicht.  Wenn wir verfolgen, von welcher Zelle aus jede Zelle erreicht wurde, erhalten wir ein Netzwerk von Zellen.  Genauer gesagt, ein baumartiges Netzwerk, dessen Wurzel der Ausgangspunkt ist.  Wir k√∂nnen es verwenden, um den Pfad nach Erreichen des Endpunkts zu erstellen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a71/331/153/a713311534e05f46c6fd22a632100494.png"></div><br>  <i>Baumnetzwerk, das Pfade zum Zentrum beschreibt</i> <br><br>  Wir k√∂nnen diese Informationen speichern, indem wir einen Link zu einer anderen Zelle in <code>HexCell</code> .  Wir m√ºssen diese Daten nicht serialisieren, daher verwenden wir hierf√ºr die Standardeigenschaft. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell PathFrom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  <code>HexGrid.Search</code> in <code>HexGrid.Search</code> den <code>PathFrom</code> Wert des Nachbarn auf die aktuelle Zelle fest, wenn Sie ihn dem Rahmen hinzuf√ºgen.  Au√üerdem m√ºssen wir diesen Link √§ndern, wenn wir einen k√ºrzeren Weg zum Nachbarn finden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; neighbor.PathFrom = current; }</code> </pre> <br>  Nachdem wir den Endpunkt erreicht haben, k√∂nnen wir den Pfad visualisieren, indem wir diesen Links zur√ºck zur Startzelle folgen und sie ausw√§hlen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/9cc/8de/f899cc8de04e0c5666a2a05558b28042.png"></div><br>  <i>Pfad gefunden</i> <br><br>  Es ist zu bedenken, dass es oft mehrere k√ºrzeste Wege gibt.  Die gefundene h√§ngt von der Verarbeitungsreihenfolge der Zellen ab.  Einige Pfade m√∂gen gut aussehen, andere m√∂gen schlecht sein, aber es gibt nie einen k√ºrzeren Pfad.  Wir werden sp√§ter darauf zur√ºckkommen. <br><br><h3>  Start der Suche √§ndern </h3><br>  Nach Auswahl des Startpunkts wird durch √Ñndern des Endpunkts eine neue Suche ausgel√∂st.  Das gleiche sollte passieren, wenn Sie eine neue Startzelle ausw√§hlen.  Um dies zu erm√∂glichen, muss sich <code>HexMapEditor</code> auch den Endpunkt merken. <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell, searchToCell;</code> </pre> <br>  √úber dieses Feld k√∂nnen wir auch eine neue Suche starten, wenn wir einen neuen Anfang ausw√§hlen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell); }</code> </pre> <br>  Au√üerdem m√ºssen wir gleiche Start- und Endpunkte vermeiden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { ‚Ä¶ }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Intelligentere Suche </h2><br>  Obwohl unser Algorithmus den k√ºrzesten Weg findet, verbringt er viel Zeit damit, Punkte zu erkunden, die offensichtlich nicht Teil dieses Weges werden.  Zumindest ist es f√ºr uns offensichtlich.  Der Algorithmus kann nicht auf die Karte herabblicken und nicht erkennen, dass eine Suche in einige Richtungen bedeutungslos ist.  Er zieht es vor, auf den Stra√üen zu fahren, obwohl sie vom Endpunkt in die entgegengesetzte Richtung fahren.  Ist es m√∂glich, die Suche intelligenter zu gestalten? <br><br>  Im Moment ber√ºcksichtigen wir bei der Auswahl der Zelle, die als n√§chstes verarbeitet werden soll, nur den Abstand von der Zelle zum Anfang.  Wenn wir kl√ºger machen wollen, m√ºssen wir auch den Abstand zum Endpunkt ber√ºcksichtigen.  Leider kennen wir ihn noch nicht.  Wir k√∂nnen jedoch eine Sch√§tzung der verbleibenden Entfernung erstellen.  Wenn wir diese Sch√§tzung zur Entfernung zur Zelle hinzuf√ºgen, erhalten wir ein Verst√§ndnis der Gesamtl√§nge des Pfades, der durch diese Zelle verl√§uft.  Dann k√∂nnen wir damit die Zellensuche priorisieren. <br><br><h3>  Suchheuristik </h3><br>  Wenn wir anstelle genau bekannter Daten Sch√§tzungen oder Vermutungen verwenden, spricht man von Suchheuristiken.  Diese Heuristik gibt die beste Sch√§tzung der verbleibenden Entfernung wieder.  Wir m√ºssen diesen Wert f√ºr jede Zelle bestimmen, nach der wir suchen, und f√ºgen daher eine <code>HexCell</code> Ganzzahl-Eigenschaft hinzu.  Wir m√ºssen es nicht serialisieren, daher reicht eine andere Standardeigenschaft aus. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchHeuristic { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Wie nehmen wir eine Annahme √ºber die verbleibende Entfernung an?  Im Idealfall haben wir eine Stra√üe, die direkt zum Endpunkt f√ºhrt.  Wenn ja, ist der Abstand gleich dem unver√§nderten Abstand zwischen den Koordinaten dieser Zelle und der endg√ºltigen Zelle.  Nutzen wir dies in unserer Heuristik. <br><br>  Da die Heuristik nicht von einem zuvor zur√ºckgelegten Pfad abh√§ngt, ist sie im Suchprozess konstant.  Daher m√ºssen wir es nur einmal berechnen, wenn <code>HexGrid.Search</code> dem Rand eine Zelle hinzuf√ºgt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); frontier.Add(neighbor); }</code> </pre> <br><h3>  Suchpriorit√§t </h3><br>  Von nun an bestimmen wir die Priorit√§t der Suche anhand der Entfernung zur Zelle und ihrer Heuristiken.  <code>HexCell</code> wir in <code>HexCell</code> eine Eigenschaft f√ºr diesen Wert <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance + SearchHeuristic; } }</code> </pre> <br>  Damit dies funktioniert, <code>HexGrid.Search</code> so, dass diese Eigenschaft zum Sortieren des <code>HexGrid.Search</code> verwendet wird. <br><br><pre> <code class="cs hljs"> frontier.Sort( (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/a22/c9a/b58a22c9a65a2088309a46c6cbc2d102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br>  <i>Suche ohne Heuristik und mit Heuristik</i> <br><br><h3>  G√ºltige Heuristik </h3><br>  Dank der neuen Suchpriorit√§ten werden wir dadurch tats√§chlich weniger Zellen besuchen.  Auf einer einheitlichen Karte verarbeitet der Algorithmus jedoch immer noch Zellen, die in die falsche Richtung weisen.  Dies liegt daran, dass die Kosten f√ºr jeden Bewegungsschritt standardm√§√üig 5 betragen und die Heuristik pro Schritt nur 1 addiert. Das hei√üt, der Einfluss der Heuristik ist nicht sehr stark. <br><br>  Wenn die Kosten f√ºr das Weiterziehen aller Karten gleich sind, k√∂nnen wir bei der Ermittlung der Heuristik dieselben Kosten verwenden.  In unserem Fall ist dies die aktuelle Heuristik multipliziert mit 5. Dies reduziert die Anzahl der verarbeiteten Zellen erheblich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a4/6c7/ac3/9a46c7ac3c0df63797bfda1f143f9409.png"></div><br>  <i>Verwenden von Heuristiken √ó 5</i> <br><br>  Wenn sich jedoch Stra√üen auf der Karte befinden, k√∂nnen wir die verbleibende Entfernung √ºbersch√§tzen.  Infolgedessen kann der Algorithmus Fehler machen und einen Pfad erstellen, der eigentlich nicht der k√ºrzeste ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/7bb/dc7/cd27bbdc7043804a8d2a21ac096a6409.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/017/2a2/0af0172a264285358f99b0ece93833a3.png"></div><br>  <i>√úberbewertete und g√ºltige Heuristiken</i> <br><br>  Um sicherzustellen, dass der k√ºrzeste Weg gefunden wird, m√ºssen wir sicherstellen, dass wir die verbleibende Entfernung niemals √ºbersch√§tzen.  Dieser Ansatz wird als g√ºltige Heuristik bezeichnet.  Da die minimalen Umzugskosten 1 betragen, haben wir keine andere Wahl, als die gleichen Kosten f√ºr die Bestimmung der Heuristik zu verwenden. <br><br>  Genau genommen ist es ganz normal, noch niedrigere Kosten zu verwenden, aber dies wird die Heuristik nur schw√§cher machen.  Die minimal m√∂gliche Heuristik ist Null, was uns nur den Dijkstra-Algorithmus gibt.  Bei einer Heuristik ungleich Null hei√üt der Algorithmus A <sup>*</sup> (ausgesprochen "A-Stern"). <br><br><div class="spoiler">  <b class="spoiler_title">Warum hei√üt es A *?</b> <div class="spoiler_text">  Die Idee, dem Dijkstra-Algorithmus Heuristiken hinzuzuf√ºgen, wurde zuerst von Niels Nilsson vorgeschlagen.  Er nannte seine Version A1.  Bertram Rafael fand sp√§ter die beste Version, die er A2 nannte.  Dann hat Peter Hart bewiesen, dass mit einer guten Heuristik A2 optimal ist, das hei√üt, es kann keine bessere Version geben.  Dies zwang ihn, den Algorithmus A <sup>*</sup> aufzurufen, um zu zeigen, dass er nicht verbessert werden konnte, dh A3 oder A4 w√ºrden nicht erscheinen.  Ja, der A <sup>*</sup> -Algorithmus ist der beste, den wir bekommen k√∂nnen, aber er ist so gut wie seine Heuristik. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Priorit√§tswarteschlange </h2><br>  Obwohl A <sup>* ein</sup> guter Algorithmus ist, ist unsere Implementierung nicht so effektiv, da wir eine Liste zum Speichern des Rahmens verwenden, der bei jeder Iteration sortiert werden muss.  Wie im vorherigen Teil erw√§hnt, ben√∂tigen wir eine Priorit√§tswarteschlange, deren Standardimplementierung jedoch nicht vorhanden ist.  Lassen Sie es uns deshalb selbst erstellen. <br><br>  Unser Zug sollte die Einstellung und den Ausschluss aus der Warteschlange basierend auf der Priorit√§t unterst√ºtzen.  Es sollte auch das √Ñndern der Priorit√§t einer Zelle unterst√ºtzen, die sich bereits in der Warteschlange befindet.  Im Idealfall implementieren wir es und minimieren die Suche nach Sortierung und zugewiesenem Speicher.  Au√üerdem sollte es einfach bleiben. <br><br><h3>  Erstellen Sie Ihre eigene Warteschlange </h3><br>  Erstellen Sie eine neue <code>HexCellPriorityQueue</code> Klasse mit den erforderlichen allgemeinen Methoden.  Wir verwenden eine einfache Liste, um den Inhalt einer Warteschlange zu verfolgen.  Au√üerdem f√ºgen wir die <code>Clear</code> Methode hinzu, um die Warteschlange zu l√∂schen, damit sie wiederholt verwendet werden kann. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellPriorityQueue</span></span> { List&lt;HexCell&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); } }</code> </pre> <br>  Wir speichern Zellpriorit√§ten in den Zellen selbst.  Das hei√üt, bevor eine Zelle zur Warteschlange hinzugef√ºgt wird, muss ihre Priorit√§t festgelegt werden.  Im Falle einer Priorit√§ts√§nderung ist es wahrscheinlich hilfreich zu wissen, wie die alte Priorit√§t lautete.  F√ºgen wir dies also als Parameter zu <code>Change</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Es ist auch n√ºtzlich zu wissen, wie viele Zellen sich in der Warteschlange befinden. F√ºgen Sie daher die <code>Count</code> Eigenschaft hinzu.  Verwenden Sie einfach das Feld, f√ºr das wir das entsprechende Inkrementieren und Dekrementieren durchf√ºhren. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3>  Zur Warteschlange hinzuf√ºgen </h3><br>  Wenn eine Zelle zur Warteschlange hinzugef√ºgt wird, verwenden wir zun√§chst ihre Priorit√§t als Index und behandeln die Liste als einfaches Array. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; list[priority] = cell; }</code> </pre> <br>  Dies funktioniert jedoch nur, wenn die Liste lang genug ist, da wir sonst die Grenzen √ºberschreiten.  Sie k√∂nnen dies vermeiden, indem Sie der Liste leere Elemente hinzuf√ºgen, bis die erforderliche L√§nge erreicht ist.  Diese leeren Elemente verweisen nicht auf die Zelle, sodass Sie sie erstellen k√∂nnen, indem Sie der Liste <code>null</code> hinzuf√ºgen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priority &gt;= list.Count) { list.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e77/000/fec/e77000feca5c0bfdb769062356ca9935.png"></div><br>  <i>Liste mit L√∂chern</i> <br><br>  Auf diese Weise speichern wir jedoch nur eine Zelle pro Priorit√§t, und h√∂chstwahrscheinlich wird es mehrere geben.  Um alle Zellen mit derselben Priorit√§t zu verfolgen, m√ºssen wir eine andere Liste verwenden.  Obwohl wir f√ºr jede Priorit√§t eine echte Liste verwenden k√∂nnen, k√∂nnen wir <code>HexCell</code> auch eine Eigenschaft <code>HexCell</code> , um sie miteinander zu verbinden.  Auf diese Weise k√∂nnen wir eine Zellkette erstellen, die als verkn√ºpfte Liste bezeichnet wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell NextWithSamePriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Lassen Sie <code>HexCellPriorityQueue.Enqueue</code> die neu hinzugef√ºgte Zelle zwingen, auf den aktuellen Wert mit derselben Priorit√§t zu verweisen, bevor Sie sie l√∂schen, um eine Kette zu erstellen. <br><br><pre> <code class="cs hljs"> cell.NextWithSamePriority = list[priority]; list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/082/87c/45b08287cf76c4636d7a673869aa39b5.png"></div><br>  <i>Liste der verkn√ºpften Listen</i> <br><br><h3>  Aus der Warteschlange entfernen </h3><br>  Um eine Zelle aus einer Priorit√§tswarteschlange abzurufen, m√ºssen wir auf die verkn√ºpfte Liste am niedrigsten nicht leeren Index zugreifen.  Daher werden wir die Liste in einer Schleife durchlaufen, bis wir sie finden.  Wenn wir nicht finden, ist die Warteschlange leer und wir geben <code>null</code> . <br><br>  Aus der gefundenen Kette k√∂nnen wir jede Zelle zur√ºckgeben, da sie alle die gleiche Priorit√§t haben.  Am einfachsten ist es, die Zelle vom Anfang der Kette zur√ºckzugeben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { HexCell cell = list[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Verwenden Sie die n√§chste Zelle mit der gleichen Priorit√§t wie der Neustart, um die Verbindung zur verbleibenden Kette aufrechtzuerhalten.  Wenn es auf dieser Priorit√§tsstufe nur eine Zelle gab, wird das Element <code>null</code> und wird in Zukunft √ºbersprungen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[i] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre> <br><h3>  Minimale Verfolgung </h3><br>  Dieser Ansatz funktioniert, durchl√§uft die Liste jedoch jedes Mal, wenn eine Zelle empfangen wird.  Wir k√∂nnen es nicht vermeiden, den kleinsten nicht leeren Index zu finden, aber wir m√ºssen nicht jedes Mal von vorne anfangen.  Stattdessen k√∂nnen wir die Mindestpriorit√§t verfolgen und die Suche damit starten.  Anfangs ist das Minimum im Wesentlichen gleich unendlich. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; }</code> </pre> <br>  Wenn Sie der Warteschlange eine Zelle hinzuf√ºgen, √§ndern wir das Minimum nach Bedarf. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority &lt; minimum) { minimum = priority; } ‚Ä¶ }</code> </pre> <br>  Und wenn wir uns aus der Warteschlange zur√ºckziehen, verwenden wir mindestens die Liste f√ºr Iterationen und beginnen nicht bei Null. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; minimum &lt; list.Count; minimum++) { HexCell cell = list[minimum]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[minimum] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Dies reduziert die Zeit, die zum Umgehen der Priorit√§tslistenschleife ben√∂tigt wird, erheblich. <br><br><h3>  Priorit√§ten √§ndern </h3><br>  Wenn Sie die Priorit√§t einer Zelle √§ndern, muss diese aus der verkn√ºpften Liste entfernt werden, zu der sie geh√∂rt.  Dazu m√ºssen wir der Kette folgen, bis wir sie finden. <br><br>  Beginnen wir damit, dass der Kopf der alten Priorit√§tsliste die aktuelle Zelle ist und wir auch die n√§chste Zelle verfolgen.  Wir k√∂nnen sofort die n√§chste Zelle nehmen, da wir wissen, dass dieser Index mindestens eine Zelle enth√§lt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; }</code> </pre> <br>  Wenn die aktuelle Zelle eine ge√§nderte Zelle ist, ist dies die Kopfzelle, und wir k√∂nnen sie abschneiden, als h√§tten wir sie aus der Warteschlange gezogen. <br><br><pre> <code class="cs hljs"> HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; }</code> </pre> <br>  Wenn dies nicht der Fall ist, m√ºssen wir der Kette folgen, bis wir uns in der Zelle vor der ver√§nderten Zelle befinden.  Es enth√§lt einen Link zu der Zelle, die ge√§ndert wurde. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } }</code> </pre> <br>  Zu diesem Zeitpunkt k√∂nnen wir die ge√§nderte Zelle aus der verkn√ºpften Liste entfernen und √ºberspringen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } current.NextWithSamePriority = cell.NextWithSamePriority;</code> </pre> <br>  Nachdem Sie eine Zelle gel√∂scht haben, m√ºssen Sie sie erneut hinzuf√ºgen, damit sie in der Liste ihrer neuen Priorit√§t angezeigt wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Enqueue(cell); }</code> </pre> <br>  Die <code>Enqueue</code> Methode erh√∂ht den Z√§hler, aber in Wirklichkeit f√ºgen wir keine neue Zelle hinzu.  Um dies zu kompensieren, m√ºssen wir daher den Z√§hler dekrementieren. <br><br><pre> <code class="cs hljs"> Enqueue(cell); count -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h3>  Verwendung der Warteschlange </h3><br>  Jetzt k√∂nnen wir unsere Priorit√§tswarteschlange bei <code>HexGrid</code> .  Dies kann mit einer einzigen Instanz erfolgen, die f√ºr alle Suchvorg√§nge wiederverwendbar ist. <br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor dem Starten der Schleife muss die Methode </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuerst zur Warteschlange hinzugef√ºgt werden </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und jede Iteration beginnt mit der Ausgabe der Zelle aus der Warteschlange. </font><font style="vertical-align: inherit;">Dies ersetzt den alten Grenzcode.</font></font><br><br><pre> <code class="cs hljs"> WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// List&lt;HexCell&gt; frontier = new List&lt;HexCell&gt;(); fromCell.Distance = 0; // frontier.Add(fromCell); searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { yield return delay; HexCell current = searchFrontier.Dequeue(); // frontier.RemoveAt(0); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie den Code so, dass er den Nachbarn hinzuf√ºgt und √§ndert. </font><font style="vertical-align: inherit;">Vor der √Ñnderung werden wir uns an die alte Priorit√§t erinnern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); <span class="hljs-comment"><span class="hljs-comment">// frontier.Add(neighbor); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au√üerdem m√ºssen wir die Grenze nicht mehr sortieren. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// frontier.Sort( // (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) // );</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suche mit einer Priorit√§tswarteschlange</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie bereits erw√§hnt, h√§ngt der k√ºrzeste gefundene Pfad von der Verarbeitungsreihenfolge der Zellen ab. </font><font style="vertical-align: inherit;">Unser Zug erstellt eine andere Reihenfolge als die sortierte Liste, damit wir andere Wege finden k√∂nnen. </font><font style="vertical-align: inherit;">Da wir f√ºr jede Priorit√§t den Kopf der verkn√ºpften Liste hinzuf√ºgen und daraus entfernen, √§hneln sie eher Stapeln als Warteschlangen. </font><font style="vertical-align: inherit;">Zuletzt hinzugef√ºgte Zellen werden zuerst verarbeitet. </font><font style="vertical-align: inherit;">Ein Nebeneffekt dieses Ansatzes ist, dass der Algorithmus zickzackanf√§llig ist. </font><font style="vertical-align: inherit;">Daher steigt auch die Wahrscheinlichkeit von Zickzackpfaden. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise sehen solche Pfade normalerweise besser aus, so dass dieser Nebeneffekt zu unseren Gunsten ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/1e9/cc5/9081e9cc5b0ea1d6f4309b6221eab1ac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierte Liste und Warteschlange mit </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Unitypackage- </font></a><i><font style="vertical-align: inherit;">Priorit√§t</font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 17: Bewegungseinschr√§nkung </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir finden Wege f√ºr eine schrittweise Bewegung. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie den Pfad sofort an. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schaffen eine effektivere Suche. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir visualisieren nur den Weg. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Teil werden wir die Bewegung in Bewegungen unterteilen und die Suche so weit wie m√∂glich beschleunigen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/572/9cc/c4d5729ccbf9cc994b7c8328950e6f5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reisen Sie aus mehreren Z√ºgen</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt f√ºr Schritt Bewegung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategiespiele mit Sechsecknetzen sind fast immer rundenbasiert. </font><font style="vertical-align: inherit;">Einheiten, die sich auf der Karte bewegen, haben eine begrenzte Geschwindigkeit, die die in einer Runde zur√ºckgelegte Strecke begrenzt.</font></font><br><br><h3>  Geschwindigkeit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die eingeschr√§nkte Bewegung zu unterst√ºtzen, f√ºgen wir </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integer-Parameter hinzu </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es bestimmt den Bewegungsbereich f√ºr eine Bewegung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell, speed)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiedene Arten von Einheiten im Spiel verwenden unterschiedliche Geschwindigkeiten. </font><font style="vertical-align: inherit;">Kavallerie ist schnell, Infanterie ist langsam und so weiter. </font><font style="vertical-align: inherit;">Wir haben noch keine Einheiten, daher werden wir vorerst eine konstante Geschwindigkeit verwenden. </font><font style="vertical-align: inherit;">Nehmen wir einen Wert von 24. Dies ist ein ziemlich gro√üer Wert, der nicht durch 5 teilbar ist (die Standardkosten f√ºr den Umzug). </font><font style="vertical-align: inherit;">F√ºgen Sie </font><font style="vertical-align: inherit;">f√ºr ein Argument </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer konstanten Geschwindigkeit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegt sich </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich zur Verfolgung der Gesamtkosten f√ºr die Bewegung entlang des Pfades m√ºssen wir jetzt auch wissen, wie viele Bewegungen erforderlich sind, um sich entlang des Pfades zu bewegen. Wir m√ºssen diese Informationen jedoch nicht in jeder Zelle speichern. Sie kann durch Teilen der zur√ºckgelegten Strecke durch die Geschwindigkeit erhalten werden. Da es sich um Ganzzahlen handelt, verwenden wir die Ganzzahldivision. Das hei√üt, die Gesamtentfernungen von nicht mehr als 24 entsprechen dem Kurs 0. Dies bedeutet, dass der gesamte Pfad im aktuellen Kurs abgeschlossen werden kann. Wenn sich der Endpunkt in einem Abstand von 30 befindet, muss dies Runde 1 sein. Um zum Endpunkt zu gelangen, muss die Einheit ihre gesamte Bewegung in der aktuellen Runde und in einem Teil der n√§chsten Runde ausf√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns den Verlauf der aktuellen Zelle und aller darin befindlichen Nachbarn bestimmen</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Verlauf der aktuellen Zelle kann nur einmal berechnet werden, bevor der Nachbarzyklus ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Die Bewegung des Nachbarn kann bestimmt werden, sobald wir die Entfernung zu ihm finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = current.Distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verlorene Bewegung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Zug des Nachbarn gr√∂√üer ist als der aktuelle Zug, haben wir die Grenze des Zuges √ºberschritten. </font><font style="vertical-align: inherit;">Wenn die Bewegung, die notwendig ist, um einen Nachbarn zu erreichen, 1 war, ist alles in Ordnung. </font><font style="vertical-align: inherit;">Wenn der Umzug in die n√§chste Zelle jedoch teurer ist, wird alles komplizierter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, wir bewegen uns entlang einer homogenen Karte, dh um in jede Zelle zu gelangen, ben√∂tigen Sie 5 Bewegungseinheiten. </font><font style="vertical-align: inherit;">Unsere Geschwindigkeit betr√§gt 24. Nach vier Schritten haben wir 20 Einheiten aus unserem Bewegungsbestand ausgegeben, und es sind noch 4 √ºbrig. Im n√§chsten Schritt werden wieder 5 Einheiten ben√∂tigt, dh eine mehr als die verf√ºgbaren. </font><font style="vertical-align: inherit;">Was m√ºssen wir in dieser Phase tun?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei Ans√§tze f√ºr diese Situation. Die erste besteht darin, der Einheit zu erlauben, in der aktuellen Runde die f√ºnfte Zelle zu betreten, selbst wenn wir nicht genug Bewegung haben. Die zweite besteht darin, die Bewegung w√§hrend der aktuellen Bewegung zu verbieten, dh die verbleibenden Bewegungspunkte k√∂nnen nicht verwendet werden und gehen verloren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahl der Option h√§ngt vom Spiel ab. Im Allgemeinen ist der erste Ansatz besser f√ºr Spiele geeignet, bei denen sich Einheiten nur wenige Schritte pro Spielzug bewegen k√∂nnen, z. B. f√ºr Spiele der Civilization-Reihe. Dies stellt sicher, dass Einheiten immer mindestens eine Zelle pro Runde bewegen k√∂nnen. Wenn Einheiten viele Zellen pro Spielzug bewegen k√∂nnen, wie in Age of Wonders oder in Battle for Wesnoth, ist die zweite Option besser.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir Geschwindigkeit 24 verwenden, w√§hlen wir den zweiten Ansatz. </font><font style="vertical-align: inherit;">Damit es funktioniert, m√ºssen wir die Kosten f√ºr den Einstieg in die n√§chste Zelle isolieren, bevor wir sie zur aktuellen Entfernung hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int distance = current.Distance; int moveCost; if (current.HasRoadThroughEdge(d)) { moveCost = 1; } else if (current.Walled != neighbor.Walled) { continue; } else { moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } int distance = current.Distance + moveCost; int turn = distance / speed;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir als Ergebnis die Grenze der Bewegung √ºberschreiten, verwenden wir zuerst alle Bewegungspunkte der aktuellen Bewegung. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir einfach die Bewegung mit der Geschwindigkeit multiplizieren. </font><font style="vertical-align: inherit;">Danach addieren wir die Umzugskosten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen werden wir den ersten Zug in der vierten Zelle mit 4 nicht verwendeten Bewegungspunkten abschlie√üen. </font><font style="vertical-align: inherit;">Diese verlorenen Punkte werden zu den Kosten der f√ºnften Zelle addiert, sodass ihre Entfernung 29 und nicht 25 betr√§gt. Infolgedessen sind die Entfernungen gr√∂√üer als zuvor. </font><font style="vertical-align: inherit;">Zum Beispiel hatte die zehnte Zelle einen Abstand von 50. Um jetzt hineinzukommen, m√ºssen wir die Grenzen von zwei Z√ºgen √ºberschreiten und 8 Bewegungspunkte verlieren, dh der Abstand dazu wird jetzt 58.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/7f4/1f1/ff37f41f11c85f7f759367fd2b33334d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√§nger als erwartet</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da nicht verwendete Bewegungspunkte zu den Abst√§nden zu den Zellen hinzugef√ºgt werden, werden sie bei der Bestimmung des k√ºrzesten Pfades ber√ºcksichtigt. </font><font style="vertical-align: inherit;">Am effektivsten ist es, so wenig Punkte wie m√∂glich zu verschwenden. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir bei unterschiedlichen Geschwindigkeiten unterschiedliche Pfade erhalten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegungen statt Entfernungen anzeigen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir das Spiel spielen, sind wir nicht sehr an den Entfernungswerten interessiert, die verwendet werden, um den k√ºrzesten Weg zu finden. </font><font style="vertical-align: inherit;">Wir sind an der Anzahl der Bewegungen interessiert, die erforderlich sind, um den Endpunkt zu erreichen. </font><font style="vertical-align: inherit;">Lassen Sie uns daher anstelle von Entfernungen die Bewegungen anzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Befreien Sie sich zuerst von </font></font><code>UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seinem Anruf </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// UpdateDistanceLabel(); } } ‚Ä¶ // void UpdateDistanceLabel () { // UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); // label.text = distance == int.MaxValue ? "" : distance.ToString(); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stattdessen f√ºgen wir der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode hinzu </font></font><code>SetLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die eine beliebige Zeichenfolge empf√§ngt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = text; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese neue Methode zur </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reinigung von Zellen. </font><font style="vertical-align: inherit;">Um Zellen auszublenden, weisen Sie sie einfach zu </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); cells[i].DisableHighlight(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann weisen wir dem Nachbarn den Wert seines Zuges zu. </font><font style="vertical-align: inherit;">Danach k√∂nnen wir sehen, wie viele zus√§tzliche Z√ºge erforderlich sind, um den gesamten Weg zu gehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/6d6/97d/0d46d697d7c08be6d3381ce030541e4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Bewegungen, die erforderlich sind, um sich entlang des </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Unitypackage- </font></a><i><font style="vertical-align: inherit;">Pfads zu bewegen</font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sofortige Pfade </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem ist es uns beim Spielen des Spiels egal, wie der Pfad-Suchalgorithmus den Weg findet. </font><font style="vertical-align: inherit;">Wir m√∂chten den angeforderten Pfad sofort sehen. </font><font style="vertical-align: inherit;">Im Moment k√∂nnen wir sicher sein, dass der Algorithmus funktioniert. Lassen Sie uns also die Suchvisualisierung loswerden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ohne Corutin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr einen langsamen Durchgang durch den Algorithmus verwendeten wir Corutin. </font><font style="vertical-align: inherit;">Wir m√ºssen dies nicht mehr tun, damit wir Anrufe loswerden </font></font><code>StartCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>StopAllCoroutines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen rufen wir es einfach </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als regul√§re Methode auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// StopAllCoroutines(); ‚Ä¶ } public void FindPath (HexCell fromCell, HexCell toCell, int speed) { // StopAllCoroutines(); // StartCoroutine(Search(fromCell, toCell, speed)); Search(fromCell, toCell, speed); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir es nicht mehr </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Coroutine verwenden, ben√∂tigt es keine Ausbeute, sodass wir diesen Operator loswerden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir auch die Deklaration entfernen </font></font><code>WaitForSeconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den R√ºckgabetyp der Methode in √§ndern </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// WaitForSeconds delay = new WaitForSeconds(1 / 60f); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { // yield return delay; HexCell current = searchFrontier.Dequeue(); ‚Ä¶ } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sofortige Ergebnisse</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchzeitdefinition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Pfade sofort abrufen, aber wie schnell werden sie berechnet? Kurze Pfade erscheinen fast sofort, aber lange Pfade auf gro√üen Karten scheinen etwas langsam zu sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns messen, wie lange es dauert, den Pfad zu finden und anzuzeigen. Wir k√∂nnen einen Profiler verwenden, um die Suchzeit zu bestimmen, aber dies ist etwas zu viel und verursacht zus√§tzliche Kosten. Verwenden wir stattdessen </font></font><code>Stopwatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Namespace </font></font><code>System.Diagnostics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Da wir es nur vor√ºbergehend verwenden, werde ich das Konstrukt nicht </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Anfang des Skripts </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie kurz vor der Suche eine neue Stoppuhr und starten Sie sie. Stoppen Sie nach Abschluss der Suche die Stoppuhr und zeigen Sie die verstrichene Zeit in der Konsole an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen wir den schlechtesten Fall f√ºr unseren Algorithmus - eine Suche von links unten nach rechts oben auf einer gro√üen Karte. Das Schlimmste ist eine einheitliche Karte, da der Algorithmus alle 4.800 Kartenzellen verarbeiten muss.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/c03/524/ce1c0352479d7d8cddcff0b014291662.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suche im schlimmsten Fall Die</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchzeit kann unterschiedlich sein, da der Unity-Editor nicht der einzige Prozess ist, der auf Ihrem Computer ausgef√ºhrt wird. Testen Sie es also mehrmals, um die durchschnittliche Dauer zu verstehen. In meinem Fall dauert die Suche ungef√§hr 45 Millisekunden. Dies ist nicht sehr viel und entspricht 22,22 Pfaden pro Sekunde; bezeichnen dies als 22 pps (Pfade pro Sekunde). Dies bedeutet, dass die Framerate des Spiels in diesem Frame bei der Berechnung dieses Pfades ebenfalls um maximal 22 fps abnimmt. Und dies ohne Ber√ºcksichtigung aller anderen Arbeiten, zum Beispiel des Renderns des Rahmens selbst. Das hei√üt, wir bekommen eine ziemlich starke Abnahme der Bildrate, sie wird auf 20 fps fallen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einen solchen Leistungstest durchf√ºhren, m√ºssen Sie ber√ºcksichtigen, dass die Leistung des Unity-Editors nicht so hoch ist wie die Leistung der fertigen Anwendung. </font><font style="vertical-align: inherit;">Wenn ich den gleichen Test mit der Baugruppe durchf√ºhre, dauert es im Durchschnitt nur 15 ms. </font><font style="vertical-align: inherit;">Das sind 66 pps, was viel besser ist. </font><font style="vertical-align: inherit;">Dies ist jedoch immer noch ein gro√üer Teil der pro Frame zugewiesenen Ressourcen, sodass die Framerate unter 60 fps liegt.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wo kann ich das Debug-Protokoll f√ºr die Assembly sehen?</font></font></b> <div class="spoiler_text">  Unity     ,    .     .  ,       ,   Unity  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Log Files</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchen Sie nur bei Bedarf. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen eine einfache Optimierung vornehmen - f√ºhren Sie eine Suche nur dann durch, wenn sie ben√∂tigt wird. </font><font style="vertical-align: inherit;">W√§hrend wir in jedem Frame, in dem die Maustaste gedr√ºckt gehalten wird, eine neue Suche starten. </font><font style="vertical-align: inherit;">Daher wird die Bildrate beim Ziehen und Ablegen st√§ndig untersch√§tzt. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies vermeiden, </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem wir </font><font style="vertical-align: inherit;">eine neue Suche </font><font style="vertical-align: inherit;">nur dann </font><font style="vertical-align: inherit;">einleiten, </font><font style="vertical-align: inherit;">wenn es sich wirklich um einen neuen Endpunkt handelt. </font><font style="vertical-align: inherit;">Wenn nicht, ist der aktuell sichtbare Pfad weiterhin g√ºltig.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beschriftungen nur f√ºr den Pfad anzeigen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anzeigen von Reisemarken ist ein ziemlich teurer Vorgang, insbesondere weil wir einen nicht optimierten Ansatz verwenden. </font><font style="vertical-align: inherit;">Das Ausf√ºhren dieses Vorgangs f√ºr alle Zellen verlangsamt definitiv die Ausf√ºhrung. </font><font style="vertical-align: inherit;">√úberspringen wir also die Beschriftung </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; <span class="hljs-comment"><span class="hljs-comment">// neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen diese Informationen nur f√ºr den gefundenen Pfad sehen. </font><font style="vertical-align: inherit;">Daher werden wir nach Erreichen des Endpunkts den Kurs berechnen und nur die Beschriftungen der Zellen festlegen, die sich auf dem Weg befinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/f8f/2f1/090f8f2f121b6fafdb7b95d48fb41c8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzeigen von Beschriftungen nur f√ºr Pfadzellen</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt schlie√üen wir nur Zellbeschriftungen zwischen Anfang und Ende ein. </font><font style="vertical-align: inherit;">Aber der Endpunkt ist das Wichtigste, wir m√ºssen auch ein Label daf√ºr setzen. </font><font style="vertical-align: inherit;">Sie k√∂nnen dies tun, indem Sie den Pfadzyklus von der Zielzelle aus und nicht von der Zelle davor aus starten. </font><font style="vertical-align: inherit;">In diesem Fall √§ndert sich die Beleuchtung des Endpunkts von Rot zu Wei√ü, sodass die Hintergrundbeleuchtung unter dem Zyklus entfernt wird.</font></font><br><br><pre> <code class="cs hljs"> fromCell.EnableHighlight(Color.blue); <span class="hljs-comment"><span class="hljs-comment">// toCell.EnableHighlight(Color.red); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); if (current == toCell) { // current = current.PathFrom; while (current != fromCell) { int turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } toCell.EnableHighlight(Color.red); break; } ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/273/ea9/dda273ea9b4aa1767db16c19abf512cd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortschrittsinformationen sind f√ºr den Endpunkt am wichtigsten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach diesen √Ñnderungen wird die Worst-Case-Zeit im Editor auf 23 Millisekunden und in der fertigen Baugruppe auf bis zu 6 Millisekunden reduziert. </font><font style="vertical-align: inherit;">Dies sind 43 pps und 166 pps - viel besser. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die kl√ºgste Suche </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir das Suchverfahren durch Implementierung des A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Algorithmus intelligenter gestaltet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In der Realit√§t f√ºhren wir die Suche jedoch immer noch nicht optimal durch. </font><font style="vertical-align: inherit;">In jeder Iteration berechnen wir die Abst√§nde von der aktuellen Zelle zu allen Nachbarn. </font><font style="vertical-align: inherit;">Dies gilt f√ºr Zellen, die noch nicht oder derzeit Teil des Suchrahmens sind. </font><font style="vertical-align: inherit;">Die Zellen, die bereits von der Grenze entfernt wurden, m√ºssen jedoch nicht mehr ber√ºcksichtigt werden, da wir bereits den k√ºrzesten Weg zu diesen Zellen gefunden haben. </font><font style="vertical-align: inherit;">Bei der korrekten Implementierung von A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* werden</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Zellen √ºbersprungen, sodass wir dasselbe tun k√∂nnen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellensuchphase </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Woher wissen wir, ob eine Zelle die Grenze bereits verlassen hat? </font><font style="vertical-align: inherit;">Wir k√∂nnen dies zwar nicht feststellen. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie verfolgen, in welcher Phase der Suche sich die Zelle befindet. </font><font style="vertical-align: inherit;">Sie war noch nicht an der Grenze oder ist jetzt dort oder ist im Ausland. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies verfolgen, indem wir eine </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfache Ganzzahl-Eigenschaft </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPhase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zum Beispiel bedeutet 0, dass die Zellen noch nicht erreicht sind, 1 - dass sich die Zelle jetzt im Rand befindet und 2 - dass sie bereits vom Rand entfernt wurde. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Grenze treffen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In k√∂nnen </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir alle Zellen auf 0 zur√ºcksetzen und immer 1 f√ºr den Rand verwenden. </font><font style="vertical-align: inherit;">Oder wir k√∂nnen die Anzahl der Rahmen mit jeder neuen Suche erh√∂hen. </font><font style="vertical-align: inherit;">Dank dessen m√ºssen wir uns nicht mit dem Dumping von Zellen befassen, wenn wir die Anzahl der Grenzen jedes Mal um zwei erh√∂hen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir die Phase der Zellsuche festlegen, wenn wir sie dem Rand hinzuf√ºgen. </font><font style="vertical-align: inherit;">Der Prozess beginnt mit einer Anfangszelle, die dem Rand hinzugef√ºgt wird.</font></font><br><br><pre> <code class="cs hljs"> fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und auch jedes Mal, wenn wir der Grenze einen Nachbarn hinzuf√ºgen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grenzkontrolle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu √ºberpr√ºfen, ob die Zelle noch nicht zum Rand hinzugef√ºgt wurde, haben wir bisher einen Abstand von verwendet </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Phase der Zellsuche mit dem aktuellen Rand vergleichen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// if (neighbor.Distance == int.MaxValue) { if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies bedeutet, dass wir vor der Suche keine Zellabst√§nde mehr zur√ºcksetzen m√ºssen, dh weniger arbeiten m√ºssen, was gut ist. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// cells[i].Distance = int.MaxValue; cells[i].SetLabel(null); cells[i].DisableHighlight(); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Grenze verlassen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Zelle von der Grenze entfernt wird, bezeichnen wir dies durch eine Erh√∂hung ihrer Suchphase. </font><font style="vertical-align: inherit;">Dies bringt sie √ºber die aktuelle Grenze hinaus und vor die n√§chste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir Zellen √ºberspringen, die vom Rand entfernt wurden, wodurch sinnlose Berechnungen und der Vergleich von Entfernungen vermieden werden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt liefert unser Algorithmus immer noch die gleichen Ergebnisse, jedoch effizienter. </font><font style="vertical-align: inherit;">Auf meinem Computer dauert die Worst-Case-Suche im Editor 20 ms und in der Assembly 5 ms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen auch berechnen, wie oft die Zelle vom Algorithmus verarbeitet wurde, und den Z√§hler bei der Berechnung des Abstands zur Zelle erh√∂hen. </font><font style="vertical-align: inherit;">Zuvor berechnete unser Algorithmus im schlimmsten Fall 28.239 Entfernungen. </font><font style="vertical-align: inherit;">Im vorgefertigten A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Algorithmus </font><font style="vertical-align: inherit;">berechnen wir seine 14.120 Entfernungen. </font><font style="vertical-align: inherit;">Die Menge verringerte sich um 50%. </font><font style="vertical-align: inherit;">Der Grad der Auswirkung dieser Indikatoren auf die Produktivit√§t h√§ngt von den Kosten bei der Berechnung der Umzugskosten ab. </font><font style="vertical-align: inherit;">In unserem Fall gibt es hier nicht viel Arbeit, daher ist die Verbesserung in der Baugruppe nicht sehr gro√ü, aber im Editor sehr auff√§llig. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Den Weg frei machen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine neue Suche starten, m√ºssen Sie zuerst die Visualisierung des vorherigen Pfads l√∂schen. </font><font style="vertical-align: inherit;">Deaktivieren Sie dabei die Auswahl und entfernen Sie die Beschriftungen aus jeder Rasterzelle. </font><font style="vertical-align: inherit;">Dies ist ein sehr schwieriger Ansatz. </font><font style="vertical-align: inherit;">Im Idealfall m√ºssen wir nur die Zellen verwerfen, die Teil des vorherigen Pfads waren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur suchen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir damit, den Visualisierungscode vollst√§ndig zu entfernen </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er muss nur eine Pfadsuche durchf√ºhren und muss nicht wissen, was wir mit diesen Informationen machen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // cells[i].SetLabel(null); // cells[i].DisableHighlight(); // } // fromCell.EnableHighlight(Color.blue); fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += 1; if (current == toCell) { // while (current != fromCell) { // int turn = current.Distance / speed; // current.SetLabel(turn.ToString()); // current.EnableHighlight(Color.white); // current = current.PathFrom; // } // toCell.EnableHighlight(Color.red); // break; } ‚Ä¶ } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu melden, dass </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir einen Weg gefunden haben, werden wir boolean zur√ºckgeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erinnere dich an den Weg </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Pfad gefunden ist, m√ºssen wir uns daran erinnern. </font><font style="vertical-align: inherit;">Dank dessen k√∂nnen wir es in Zukunft reinigen. </font><font style="vertical-align: inherit;">Daher werden wir die Endpunkte verfolgen und feststellen, ob zwischen ihnen ein Pfad besteht.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentPathFrom, currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentPathExists; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie den Pfad erneut an </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die von uns aufgezeichneten Suchdaten verwenden, um den Pfad erneut zu visualisieren. </font><font style="vertical-align: inherit;">Erstellen wir hierf√ºr eine neue Methode </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es durchl√§uft den Zyklus vom Ende bis zum Anfang des Pfads, hebt die Zellen hervor und weist ihren Beschriftungen einen Strichwert zu. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir die Geschwindigkeit kennen, also machen Sie es zu einem Parameter. </font><font style="vertical-align: inherit;">Wenn wir keinen Pfad haben, w√§hlt die Methode einfach die Endpunkte aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } } currentPathFrom.EnableHighlight(Color.blue); currentPathTo.EnableHighlight(Color.red); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie diese Methode </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach der Suche auf.</font></font><br><br><pre> <code class="cs hljs"> currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen den Weg wieder, aber jetzt bewegt er sich nicht weg. </font><font style="vertical-align: inherit;">Erstellen Sie zum L√∂schen eine Methode </font></font><code>ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tats√§chlich handelt es sich um eine Kopie </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der Ausnahme, dass die Auswahl und die Beschriftungen deaktiviert werden, diese jedoch nicht enthalten sind. </font><font style="vertical-align: inherit;">Danach muss er die aufgezeichneten Pfaddaten l√∂schen, die nicht mehr g√ºltig sind.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { current.SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); current.DisableHighlight(); current = current.PathFrom; } current.DisableHighlight(); currentPathExists = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } currentPathFrom = currentPathTo = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser Methode k√∂nnen wir die Visualisierung des alten Pfades l√∂schen, indem wir nur die erforderlichen Zellen besuchen. Die Gr√∂√üe der Karte ist nicht mehr wichtig. </font><font style="vertical-align: inherit;">Wir werden es aufrufen, </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">eine neue Suche starten.</font></font><br><br><pre> <code class="cs hljs"> sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { ShowPath(speed); } sw.Stop();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au√üerdem wird der Pfad beim Erstellen einer neuen Karte gel√∂scht. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und auch vor dem Laden einer weiteren Karte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Pfadvisualisierung wird wie vor dieser √Ñnderung wieder gel√∂scht. </font><font style="vertical-align: inherit;">Aber jetzt verwenden wir einen effizienteren Ansatz, und im schlimmsten Fall der Suche hat sich die Zeit auf 14 Millisekunden verringert. </font><font style="vertical-align: inherit;">Genug ernsthafte Verbesserung nur durch intelligentere Reinigung. </font><font style="vertical-align: inherit;">Die Montagezeit verringerte sich auf 3 ms, was 333 pps entspricht. </font><font style="vertical-align: inherit;">Dank dessen ist die Suche nach Pfaden genau in Echtzeit anwendbar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir schnell nach Pfaden gesucht haben, k√∂nnen wir den tempor√§ren Debugging-Code entfernen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); // sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed); // sw.Stop(); // Debug.Log(sw.ElapsedMilliseconds); }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 18: Einheiten </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir platzieren die Trupps auf der Karte. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern und laden Sie Trupps. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir finden Wege f√ºr die Truppen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bewegen die Einheiten. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir herausgefunden haben, wie Sie nach einem Pfad suchen k√∂nnen, platzieren wir die Trupps auf der Karte. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/881/316/9bb/8813169bb32795f4ea1d0c4696fddde2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verst√§rkungen kamen an</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Squads erstellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir uns nur mit Zellen und ihren festen Objekten befasst. </font><font style="vertical-align: inherit;">Einheiten unterscheiden sich von ihnen dadurch, dass sie mobil sind. </font><font style="vertical-align: inherit;">Ein Trupp kann alles in jeder Gr√∂√üenordnung bedeuten, von einer Person oder einem Fahrzeug bis zu einer ganzen Armee. </font><font style="vertical-align: inherit;">In diesem Tutorial beschr√§nken wir uns auf einen einfachen verallgemeinerten Einheitentyp. </font><font style="vertical-align: inherit;">Danach werden wir Kombinationen verschiedener Arten von Einheiten unterst√ºtzen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighaus-Trupp </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen neuen Komponententyp, um mit Trupps zu arbeiten </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beginnen wir zun√§chst mit einem leeren </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºgen sp√§ter Funktionen hinzu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie mit dieser Komponente ein leeres Spielobjekt, das zu einem Fertighaus werden soll. </font><font style="vertical-align: inherit;">Dies wird das Stammobjekt des Trupps sein.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8de/c85/2f2/8dec852f21d7aaa2c3002dc119d890ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie ein 3D-Modell hinzu, das die Abl√∂sung als untergeordnetes Objekt symbolisiert. </font><font style="vertical-align: inherit;">Ich habe einen einfachen skalierten W√ºrfel verwendet, f√ºr den ich blaues Material erstellt habe. </font><font style="vertical-align: inherit;">Das Wurzelobjekt bestimmt das Bodenniveau der Abl√∂sung, daher verschieben wir das untergeordnete Element entsprechend.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untergeordnetes W√ºrfelelement</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie dem Trupp einen Collider hinzu, damit die Auswahl in Zukunft einfacher wird. </font><font style="vertical-align: inherit;">Der Collider des Standardw√ºrfels ist f√ºr uns sehr gut geeignet. Passen Sie den Collider einfach in eine Zelle an.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen von Squad-Instanzen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir noch kein Gameplay haben, erfolgt die Erstellung von Einheiten im Bearbeitungsmodus. </font><font style="vertical-align: inherit;">Daher sollte dies angegangen werden </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dazu ben√∂tigt er ein Fertighaus. F√ºgen Sie also ein Feld hinzu </font></font><code>HexUnit unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verbinden Sie es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b00/4bd/85cb004bd7bae06a6feaa8c93f144de9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschlie√üen des Fertighauses</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Erstellen von Einheiten platzieren wir diese in der Zelle unter dem Cursor. </font><font style="vertical-align: inherit;">Es </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt einen Code zum Auffinden dieser Zelle beim Bearbeiten eines Gel√§ndes. </font><font style="vertical-align: inherit;">Jetzt brauchen wir es auch f√ºr die Trupps, also verschieben wir den entsprechenden Code in eine separate Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir diese Methode verwenden, </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um sie zu vereinfachen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); // RaycastHit hit; // if (Physics.Raycast(inputRay, out hit)) { // HexCell currentCell = hexGrid.GetCell(hit.point); HexCell currentCell = GetCellUnderCursor(); if (currentCell) { ‚Ä¶ } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie als N√§chstes eine neue Methode hinzu </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die ebenfalls verwendet wird </font></font><code>GetCellUnderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn es eine Zelle gibt, erstellen wir einen neuen Kader.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { Instantiate(unitPrefab); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Hierarchie sauber zu halten, verwenden wir das Raster als √ºbergeordnetes Element f√ºr alle Spielobjekte in den Trupps. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzung f√ºr das Erstellen von Einheiten </font><font style="vertical-align: inherit;">hinzuzuf√ºgen </font><font style="vertical-align: inherit;">, ist das Dr√ºcken einer Taste. </font><font style="vertical-align: inherit;">√Ñndern Sie die Methode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass sie </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Dr√ºcken der U-Taste aufgerufen wird. Wie bei c </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte dies geschehen, wenn sich der Cursor nicht √ºber dem GUI-Element befindet. </font><font style="vertical-align: inherit;">Zuerst pr√ºfen wir, ob wir die Karte bearbeiten sollen, und wenn nicht, pr√ºfen wir, ob wir einen Trupp hinzuf√ºgen sollen. </font><font style="vertical-align: inherit;">Wenn ja, dann rufen Sie an </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// if ( // Input.GetMouseButton(0) &amp;&amp; // !EventSystem.current.IsPointerOverGameObject() // ) { // HandleInput(); // } // else { // previousCell = null; // } if (!EventSystem.current.IsPointerOverGameObject()) { if (Input.GetMouseButton(0)) { HandleInput(); return; } if (Input.GetKeyDown(KeyCode.U)) { CreateUnit(); return; } } previousCell = null; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55e/b48/c86/55eb48c8601711d74720f29cfba7a4f3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instanz des Trupps erstellt</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Truppenplatzierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir Einheiten erstellen, die jedoch am Ursprung der Karte angezeigt werden. </font><font style="vertical-align: inherit;">Wir m√ºssen sie an den richtigen Ort bringen. </font><font style="vertical-align: inherit;">Dazu ist es notwendig, dass sich die Truppen ihrer Position bewusst sind. </font><font style="vertical-align: inherit;">Daher f√ºgen wir der </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft hinzu, </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die die Zelle angibt, die sie belegen. </font><font style="vertical-align: inherit;">Wenn Sie die Eigenschaft festlegen, √§ndern wir die Position des Teams so, dass sie mit der Position der Zelle √ºbereinstimmt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } } HexCell location;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss </font><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">die Position der Squad-Zelle unter dem Cursor zuweisen. </font><font style="vertical-align: inherit;">Dann werden die Einheiten dort sein, wo sie sollten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/71f/92d/bf671f92d2e587bebec2bf08efafadbc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trupps auf der Karte</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheitenorientierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben alle Einheiten die gleiche Ausrichtung, was ziemlich unnat√ºrlich aussieht. </font><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, um sie wiederzubeleben </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein Float-Wert, der die Drehung des Trupps entlang der Y-Achse in Grad angibt. </font><font style="vertical-align: inherit;">Beim Einstellen √§ndern wir entsprechend die Drehung des Spielobjekts.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Orientation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { orientation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assign Zufallsrotation von 0 bis 360 Grad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/c4a/8c9/74fc4a8c943830b4abd6049889b41843.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiedliche Einheitenorientierungen</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Trupp pro Zelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheiten sehen gut aus, wenn sie nicht in einer Zelle erstellt werden. </font><font style="vertical-align: inherit;">In diesem Fall erhalten wir eine Gruppe seltsam aussehender W√ºrfel.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/a68/4b6/9f8a684b6425be20e23ac65901bf5888.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlagerte Einheiten Bei</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einigen Spielen k√∂nnen mehrere Einheiten an einem Ort platziert werden, bei anderen nicht. </font><font style="vertical-align: inherit;">Da es einfacher ist, mit einem Trupp pro Zelle zu arbeiten, werde ich diese Option w√§hlen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir nur dann einen neuen Kader erstellen sollten, wenn die aktuelle Zelle nicht besetzt ist. </font><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardeigenschaft </font><font style="vertical-align: inherit;">hinzu, damit Sie dies herausfinden k√∂nnen </font></font><code>Unit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit Unit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Eigenschaft in </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um der Zelle mitzuteilen, ob sich das Ger√§t darauf befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann √ºberpr√ºft werden, ob die aktuelle Zelle frei ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { HexUnit unit = Instantiate(unitPrefab); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Besetzte Zellen bearbeiten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangs werden Einheiten korrekt platziert, aber alles kann sich √§ndern, wenn ihre Zellen sp√§ter bearbeitet werden. </font><font style="vertical-align: inherit;">Wenn sich die H√∂he der Zelle √§ndert, h√§ngt die Einheit, die sie besetzt, entweder dar√ºber oder st√ºrzt hinein.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/b7d/1c1/27bb7d1c120bc1546dfa0fd42823d66c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√§ngende und ertrunkene Trupps</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die L√∂sung besteht darin, die Position des Trupps nach √Ñnderungen zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu die Methode hinzu </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bisher interessiert uns nur die Position des Kaders, also fragen Sie es einfach noch einmal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateLocation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition = location.Position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen die Position der Abl√∂sung beim Aktualisieren der Zelle koordinieren, was passiert, wenn die Methoden </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder das </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekt </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgerufen werden. </font><font style="vertical-align: inherit;">Dies ist nat√ºrlich nur dann notwendig, wenn sich tats√§chlich eine Abl√∂sung in der Zelle befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trupps entfernen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich zum Erstellen von Einheiten w√§re es n√ºtzlich, diese zu zerst√∂ren. </font><font style="vertical-align: inherit;">F√ºgen Sie daher der </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er muss pr√ºfen, ob sich in der Zelle unter dem Cursor eine Abl√∂sung befindet, und in diesem Fall das Spielobjekt der Abl√∂sung zerst√∂ren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { Destroy(cell.Unit.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass wir durch die Zelle gehen, um zum Kader zu gelangen. </font><font style="vertical-align: inherit;">Um mit dem Trupp zu interagieren, bewegen Sie einfach die Maus √ºber die Zelle. </font><font style="vertical-align: inherit;">Damit dies funktioniert, muss der Trupp keinen Collider haben. </font><font style="vertical-align: inherit;">Das Hinzuf√ºgen eines Colliders erleichtert jedoch die Auswahl, da er die Strahlen blockiert, die sonst mit der Zelle hinter dem Trupp kollidieren w√ºrden. </font><font style="vertical-align: inherit;">Verwenden </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Kombination aus Links-Umschalt + U </font><font style="vertical-align: inherit;">, um den Trupp zu zerst√∂ren </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { DestroyUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CreateUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir mehrere Einheiten erstellen und zerst√∂ren, gehen wir vorsichtig vor und l√∂schen die Eigenschaft, wenn wir die Einheit entfernen. </font><font style="vertical-align: inherit;">Das hei√üt, wir l√∂schen explizit die Zellverbindung zum Kader. </font><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>Die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich damit befasst, sowie der Zerst√∂rung Ihres eigenen Spielobjekts hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Methode aufrufen </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Trupp nicht direkt zerst√∂ren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// Destroy(cell.Unit.gameObject); cell.Unit.Die(); } }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trupps speichern und laden </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir Einheiten auf der Karte haben k√∂nnen, m√ºssen wir sie in den Speicher- und Ladevorgang einbeziehen. </font><font style="vertical-align: inherit;">Wir k√∂nnen diese Aufgabe auf zwei Arten angehen. </font><font style="vertical-align: inherit;">Die erste besteht darin, Squad-Daten beim Aufzeichnen einer Zelle aufzuzeichnen, so dass die Zellen- und Squad-Daten gemischt werden. </font><font style="vertical-align: inherit;">Die zweite M√∂glichkeit besteht darin, Zellen- und Squad-Daten getrennt zu speichern. </font><font style="vertical-align: inherit;">Obwohl es den Anschein hat, dass der erste Ansatz einfacher zu implementieren ist, liefert der zweite Ansatz strukturiertere Daten. </font><font style="vertical-align: inherit;">Wenn wir die Daten teilen, wird es in Zukunft einfacher sein, mit ihnen zu arbeiten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheitenverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um alle Einheiten zusammenzuhalten, m√ºssen wir sie verfolgen. </font><font style="vertical-align: inherit;">Wir werden dies tun, indem wir der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste der Einheiten </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Liste sollte alle Einheiten auf der Karte enthalten.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexUnit&gt; units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexUnit&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen oder Laden einer neuen Karte m√ºssen alle Einheiten auf der Karte entfernt werden. </font><font style="vertical-align: inherit;">Um diesen Prozess zu vereinfachen, erstellen Sie eine Methode </font></font><code>ClearUnits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der alle Personen in der Liste get√∂tet und gel√∂scht werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearUnits</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Die(); } units.Clear(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir nennen diese Methode in </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lass es uns tun, nachdem wir den Weg gereinigt haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); ClearUnits(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hinzuf√ºgen von Trupps zum Raster </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt neue Einheiten erstellen, m√ºssen wir sie der Liste hinzuf√ºgen. </font><font style="vertical-align: inherit;">Legen wir hierf√ºr eine Methode fest </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich auch mit der Position des Trupps und den Parametern seines √ºbergeordneten Objekts befasst.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt reicht es </font></font><code>HexMapEditor.CreatUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus, </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer neuen Instanz der Abteilung, ihrer Position und zuf√§lligen Ausrichtung </font><font style="vertical-align: inherit;">aufzurufen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// HexUnit unit = Instantiate(unitPrefab); // unit.transform.SetParent(hexGrid.transform, false); // unit.Location = cell; // unit.Orientation = Random.Range(0f, 360f); hexGrid.AddUnit( Instantiate(unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Squads aus dem Raster entfernen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Methode zum Entfernen des Trupps hinzu und c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Entferne einfach den Trupp von der Liste und befehle ihm zu sterben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { units.Remove(unit); unit.Die(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir rufen diese Methode auf </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, anstatt den Trupp direkt zu zerst√∂ren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// cell.Unit.Die(); hexGrid.RemoveUnit(cell.Unit); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheiten speichern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir alle Einheiten zusammenhalten, m√ºssen wir uns daran erinnern, welche Zellen sie besetzen. </font><font style="vertical-align: inherit;">Am zuverl√§ssigsten ist es, die Koordinaten ihres Standorts zu speichern. </font><font style="vertical-align: inherit;">Um dies zu erm√∂glichen, f√ºgen wir der </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die es schreibt </font><font style="vertical-align: inherit;">, die </font><font style="vertical-align: inherit;">Felder X und Z hinzu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(x); writer.Write(z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann jetzt die Koordinaten und die Ausrichtung des Teams aufzeichnen. </font><font style="vertical-align: inherit;">Dies sind alle Daten der Einheiten, die wir im Moment haben.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { location.coordinates.Save(writer); writer.Write(orientation); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheiten verfolgt, zeichnet seine Methode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Daten von Einheiten auf. </font><font style="vertical-align: inherit;">Schreiben Sie zuerst die Gesamtzahl der Einheiten auf und gehen Sie dann alle in einer Schleife um.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } writer.Write(units.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die gespeicherten Daten ge√§ndert, sodass wir die Versionsnummer </font></font><code>SaveLoadMenu.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf 2 </font><font style="vertical-align: inherit;">erh√∂hen </font><font style="vertical-align: inherit;">. Der alte Startcode funktioniert weiterhin, da die Squad-Daten einfach nicht gelesen werden. </font><font style="vertical-align: inherit;">Sie m√ºssen jedoch die Versionsnummer erh√∂hen, um anzuzeigen, dass die Datei Ger√§teinformationen enth√§lt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">2</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ladetrupps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es sich </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um eine Struktur handelt, ist es wenig sinnvoll, die √ºbliche Methode hinzuzuf√ºgen </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Machen wir es zu einer statischen Methode, die gespeicherte Koordinaten liest und zur√ºckgibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates c; cx = reader.ReadInt32(); cz = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Anzahl der Einheiten variabel ist, haben wir keine bereits vorhandenen Einheiten, in die Daten geladen werden k√∂nnen. </font><font style="vertical-align: inherit;">Wir k√∂nnen neue Instanzen von Einheiten erstellen, bevor wir ihre Daten laden. Dies erfordert jedoch, dass wir </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Booten Instanzen neuer Einheiten erstellen. </font><font style="vertical-align: inherit;">Also ist es besser, es zu verlassen </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir verwenden auch die statische Methode </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beginnen wir damit, diese Trupps einfach zu lesen. </font><font style="vertical-align: inherit;">Um den Wert des Orientierungs-Floats zu lesen, verwenden wir die Methode </font></font><code>BinaryReader.ReadSingle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum Single?</font></font></b> <div class="spoiler_text">  <code>float</code>        ,     .     ,   <code>double</code> ,     .  Unity   . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Schritt besteht darin, eine Instanz eines neuen Teams zu erstellen. </font><font style="vertical-align: inherit;">Dazu ben√∂tigen wir jedoch einen Link zum Fertighaus des Ger√§ts. </font><font style="vertical-align: inherit;">Um dies noch nicht zu komplizieren, f√ºgen wir hierf√ºr eine </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statische Methode hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexUnit unitPrefab;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diesen Link zu setzen, verwenden wir ihn erneut </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie wir es mit der Rauschtextur getan haben. </font><font style="vertical-align: inherit;">Wenn wir viele Arten von Einheiten unterst√ºtzen m√ºssen, werden wir zu einer besseren L√∂sung √ºbergehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/e2e/9c0/251e2e9c0e0f9ec8c6da0a0a7bce6f85.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir passieren das Fertighaus des Ger√§ts.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach dem Anschlie√üen des Feldes ben√∂tigen wir keine direkte Verbindung mehr zu </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen kann er verwenden </font></font><code>HexUnit.unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public HexUnit unitPrefab; ‚Ä¶ void CreateUnit () { HexCell cell = GetCellUnderCursor(); if (cell &amp;&amp; !cell.Unit) { hexGrid.AddUnit( Instantiate(HexUnit.unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir eine Instanz des neuen Teams in erstellen </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstatt es zur√ºckzugeben, k√∂nnen wir die geladenen Koordinaten und die Ausrichtung verwenden, um es dem Raster hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu einen Parameter hinzu </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, HexGrid grid</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); grid.AddUnit( Instantiate(unitPrefab), grid.GetCell(coordinates), orientation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z√§hlen wir die Anzahl der Einheiten und laden damit alle gespeicherten Einheiten, wobei wir uns als zus√§tzliches Argument √ºbergeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies funktioniert nat√ºrlich nur f√ºr Sicherungsdateien mit einer Version von nicht weniger als 2, in j√ºngeren Versionen m√ºssen keine Einheiten geladen werden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir Dateien der Version 2 korrekt hochladen, also </font></font><code>SaveLoadMenu.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erh√∂hen Sie die Anzahl der unterst√ºtzten Versionen auf 2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Truppenbewegung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trupps sind mobil, daher m√ºssen wir sie auf der Karte bewegen k√∂nnen. </font><font style="vertical-align: inherit;">Wir haben bereits einen Pfad-Suchcode, aber bisher haben wir ihn nur f√ºr beliebige Stellen getestet. </font><font style="vertical-align: inherit;">Jetzt m√ºssen wir die alte Test-Benutzeroberfl√§che entfernen und eine neue Benutzeroberfl√§che f√ºr das Squad-Management erstellen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bereinigung des Karteneditors </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verschieben von Einheiten entlang von Pfaden ist Teil des Spiels und gilt nicht f√ºr den Karteneditor. </font><font style="vertical-align: inherit;">Daher werden wir den </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gesamten Code entfernen, der mit dem Finden des Pfades verbunden ist.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// HexCell previousCell, searchFromCell, searchToCell; HexCell previousCell; ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } if (editMode) { EditCells(currentCell); } // else if ( // Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell // ) { // if (searchFromCell != currentCell) { // if (searchFromCell) { // searchFromCell.DisableHighlight(); // } // searchFromCell = currentCell; // searchFromCell.EnableHighlight(Color.blue); // if (searchToCell) { // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } // } // else if (searchFromCell &amp;&amp; searchFromCell != currentCell) { // if (searchToCell != currentCell) { // searchToCell = currentCell; // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Entfernen dieses Codes ist es nicht mehr sinnvoll, den Editor aktiv zu lassen, wenn wir uns nicht im Bearbeitungsmodus befinden. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir anstelle eines Modusverfolgungsfelds die Komponente einfach aktivieren oder deaktivieren </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au√üerdem muss sich der Editor jetzt nicht mehr mit UI-Labels befassen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// bool editMode; ‚Ä¶ public void SetEditMode (bool toggle) { // editMode = toggle; // hexGrid.ShowUI(!toggle); enabled = toggle; } ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } // if (editMode) { EditCells(currentCell); // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da wir uns standardm√§√üig nicht im Kartenbearbeitungsmodus befinden, deaktivieren wir in Awake den Editor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie Raycast, um beim Bearbeiten der Karte nach der aktuellen Zelle unter dem Cursor zu suchen und Einheiten zu verwalten. </font><font style="vertical-align: inherit;">Vielleicht wird es uns in Zukunft f√ºr etwas anderes n√ºtzlich sein. </font><font style="vertical-align: inherit;">Verschieben wir die Raycasting-Logik von </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer neuen Methode </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Strahlparameter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> <code>HexMapEditor.GetCellUniderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann diese Methode einfach mit dem Cursorstrahl aufrufen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel-Benutzeroberfl√§che </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Benutzeroberfl√§che des Spielmodus zu steuern, verwenden wir eine neue Komponente. </font><font style="vertical-align: inherit;">W√§hrend er sich nur mit der Auswahl und Bewegung von Einheiten befasst. </font><font style="vertical-align: inherit;">Erstellen Sie einen neuen Komponententyp daf√ºr </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Verbindung zum Stromnetz reicht aus, um seine Arbeit zu erledigen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGameUI</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie diese Komponente dem neuen Spielobjekt in der UI-Hierarchie hinzu. </font><font style="vertical-align: inherit;">Er muss kein eigenes Objekt haben, aber es wird uns klar sein, dass es eine separate Benutzeroberfl√§che f√ºr das Spiel gibt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/515/769/bdd/515769bdd0b6fbee9cb8451348595a57.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b3/b7c/0d7/9b3b7c0d719d05862a76ba8e70409970.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game UI Object</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie eine </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie in hinzu </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Benutzeroberfl√§che des Spiels sollte aktiviert sein, wenn wir uns nicht im Bearbeitungsmodus befinden. </font><font style="vertical-align: inherit;">Au√üerdem m√ºssen hier Beschriftungen eingef√ºgt werden, da die Benutzeroberfl√§che des Spiels mit Pfaden arbeitet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie die UI-Methode des Spiels mit der Ereignisliste des Bearbeitungsmodusschalters hinzu. </font><font style="vertical-align: inherit;">Dies bedeutet, dass beide Methoden aufgerufen werden, wenn der Spieler den Modus √§ndert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92b/dde/778/92bdde778bfc97ae4b5bdc1d49a2bb6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehrere Ereignismethoden. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfolgen Sie die aktuelle Zelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je nach Situation m√ºssen </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie wissen, welche Zelle sich derzeit unter dem Cursor befindet. </font><font style="vertical-align: inherit;">Deshalb f√ºgen wir ein Feld hinzu </font></font><code>currentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Methode </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cursorstrahl verwendet, um dieses Feld zu aktualisieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { currentCell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die aktuelle Zelle aktualisieren, m√ºssen wir m√∂glicherweise herausfinden, ob sie sich ge√§ndert hat. </font><font style="vertical-align: inherit;">Erzwingen Sie die </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckgabe dieser Informationen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != currentCell) { currentCell = cell; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheitenauswahl </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor ein Trupp bewegt wird, muss er ausgew√§hlt und verfolgt werden. </font><font style="vertical-align: inherit;">F√ºgen Sie daher ein Feld hinzu </font></font><code>selectedUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexUnit selectedUnit;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir versuchen, eine Auswahl zu treffen, m√ºssen wir zun√§chst die aktuelle Zelle aktualisieren. </font><font style="vertical-align: inherit;">Wenn sich die aktuelle Zelle befindet, wird die Einheit, die diese Zelle belegt, zur ausgew√§hlten Einheit. </font><font style="vertical-align: inherit;">Befindet sich keine Einheit in der Zelle, wird keine Einheit ausgew√§hlt. </font><font style="vertical-align: inherit;">Lassen Sie uns eine Methode daf√ºr erstellen </font></font><code>DoSelection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erkennen die Auswahl der Einheiten mit einem einfachen Mausklick. </font><font style="vertical-align: inherit;">Daher f√ºgen wir eine Methode hinzu </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die eine Auswahl trifft, wenn die Maustaste aktiviert ist. Nat√ºrlich m√ºssen wir sie nur ausf√ºhren, wenn sich der Cursor nicht √ºber dem GUI-Element befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir gelernt, wie Sie jeweils eine Einheit per Mausklick ausw√§hlen. </font><font style="vertical-align: inherit;">Wenn Sie auf eine leere Zelle klicken, wird die Auswahl einer Einheit entfernt. </font><font style="vertical-align: inherit;">Wir erhalten jedoch keine visuelle Best√§tigung daf√ºr.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Squad-Suche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Einheit ausgew√§hlt ist, k√∂nnen wir ihre Position als Ausgangspunkt f√ºr die Suche nach einem Pfad verwenden. </font><font style="vertical-align: inherit;">Um dies zu aktivieren, ben√∂tigen wir keinen weiteren Mausklick. </font><font style="vertical-align: inherit;">Stattdessen finden und zeigen wir automatisch den Pfad zwischen der Truppposition und der aktuellen Zelle. </font><font style="vertical-align: inherit;">Wir werden dies immer tun </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, au√üer wenn die Wahl getroffen wird. </font><font style="vertical-align: inherit;">Um dies zu tun, rufen wir die Methode auf, wenn wir eine Abl√∂sung haben </font></font><code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { DoPathfinding(); } } }</code> </pre> <br> <code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert einfach die aktuelle Zelle und ruft an, </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn ein Endpunkt vorhanden ist. </font><font style="vertical-align: inherit;">Wir verwenden wieder eine konstante Geschwindigkeit von 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bitte beachten Sie, dass wir nicht jedes Mal, wenn wir aktualisieren, einen neuen Pfad finden sollten, sondern nur, wenn sich die aktuelle Zelle √§ndert. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/8d1/ce9/39f8d1ce9040ae5370fd12f447ecd8e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchen eines Pfads f√ºr einen Trupp</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt sehen wir die Pfade, die angezeigt werden, wenn Sie den Cursor nach Auswahl eines Trupps bewegen. </font><font style="vertical-align: inherit;">Dank dessen ist es offensichtlich, welches Ger√§t ausgew√§hlt ist. </font><font style="vertical-align: inherit;">Die Pfade werden jedoch nicht immer korrekt gel√∂scht. </font><font style="vertical-align: inherit;">Lassen Sie uns zun√§chst den alten Pfad l√∂schen, wenn sich der Cursor au√üerhalb der Karte befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies setzt nat√ºrlich voraus, dass es </font></font><code>HexGrid.ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºblich ist, also nehmen wir eine solche √Ñnderung vor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zweitens werden wir den alten Weg frei machen, wenn wir eine Abteilung w√§hlen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { grid.ClearPath(); UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlie√ülich werden wir den Pfad l√∂schen, wenn wir den Bearbeitungsmodus √§ndern. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchen Sie nur nach g√ºltigen Endpunkten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen nicht immer den Weg finden, weil es manchmal unm√∂glich ist, die letzte Zelle zu erreichen. </font></font> Es ist in Ordnung.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber manchmal ist die letzte Zelle selbst nicht akzeptabel. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir entschieden, dass Pfade keine Unterwasserzellen enthalten d√ºrfen. </font><font style="vertical-align: inherit;">Dies kann jedoch vom Ger√§t abh√§ngen. </font><font style="vertical-align: inherit;">F√ºgen wir eine </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu, die uns sagt, ob eine Zelle ein g√ºltiger Endpunkt ist. </font><font style="vertical-align: inherit;">Unterwasserzellen gibt es nicht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem haben wir nur eine Einheit in der Zelle stehen lassen. </font><font style="vertical-align: inherit;">Daher ist die letzte Zelle nicht g√ºltig, wenn sie besch√§ftigt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Methode </font></font><code>HexGameUI.DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um ung√ºltige Endpunkte zu ignorieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zum Endpunkt gehen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir einen g√ºltigen Pfad haben, k√∂nnen wir den Trupp zum Endpunkt bewegen. </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wei√ü, wann dies m√∂glich ist. </font><font style="vertical-align: inherit;">Wir lassen diese Informationen in einer neuen schreibgesch√ºtzten Eigenschaft weitergeben </font></font><code>HasPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPathExists; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">hinzu, um einen Trupp zu verschieben </font></font><code>DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode wird aufgerufen, wenn ein Befehl ausgegeben wird und wenn eine Einheit ausgew√§hlt ist. </font><font style="vertical-align: inherit;">Daher muss er pr√ºfen, ob es einen Weg gibt, und wenn ja, den Ort der Abteilung √§ndern. </font><font style="vertical-align: inherit;">W√§hrend wir den Trupp sofort zum Endpunkt teleportieren. </font><font style="vertical-align: inherit;">In einem der folgenden Tutorials werden wir den Kader dazu bringen, den ganzen Weg zu gehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { selectedUnit.Location = currentCell; grid.ClearPath(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Maustaste 1 (Rechtsklick), um den Befehl zu senden. </font><font style="vertical-align: inherit;">Wir werden dies √ºberpr√ºfen, wenn eine Abteilung ausgew√§hlt ist. </font><font style="vertical-align: inherit;">Wenn die Taste nicht gedr√ºckt wird, suchen wir nach dem Pfad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { DoMove(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DoPathfinding(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir Einheiten bewegen! </font><font style="vertical-align: inherit;">Aber manchmal weigern sie sich, einen Weg zu einigen Zellen zu finden. </font><font style="vertical-align: inherit;">Insbesondere f√ºr jene Zellen, in denen sich die Abl√∂sung befand. </font><font style="vertical-align: inherit;">Dies liegt daran, </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dass der alte Speicherort beim Festlegen eines neuen nicht aktualisiert wird. </font><font style="vertical-align: inherit;">Um dies zu beheben, werden wir den Link zum Kader an seinem alten Standort l√∂schen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie Trupps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Finden des Weges funktioniert jetzt korrekt und Einheiten k√∂nnen sich auf der Karte teleportieren. </font><font style="vertical-align: inherit;">Obwohl sie sich nicht in Zellen bewegen k√∂nnen, in denen sich bereits ein Trupp befindet, werden im Weg stehende Abteilungen ignoriert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/3d8/7dd/5193d87dd25bfa2fbc9e0ba26529b926.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheiten auf dem Weg werden ignoriert.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheiten derselben Fraktion k√∂nnen sich normalerweise gegenseitig bewegen, aber bisher haben wir keine Fraktionen. </font><font style="vertical-align: inherit;">Betrachten wir daher alle Einheiten als voneinander getrennt und blockieren die Pfade. </font><font style="vertical-align: inherit;">Dies kann implementiert werden, indem ausgelastete Zellen √ºbersprungen werden </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater || neighbor.Unit) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3c/f3b/698/f3cf3b698191010f55c0c994d3e324d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie </font><font style="vertical-align: inherit;">Abl√∂sungen </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 19: Bewegungsanimation </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bewegen die Einheiten zwischen den Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisieren Sie den zur√ºckgelegten Weg. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bewegen die Truppen entlang der Kurven. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir zwingen die Truppen, in Bewegungsrichtung zu schauen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Teil werden wir Einheiten anstelle von Teleportation zwingen, sich entlang der Gleise zu bewegen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a08/e41/a4f/a08e41a4fd0e90ea26dc11f16ff518f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trupps unterwegs</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegung auf dem Weg </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir Einheiten hinzugef√ºgt und die M√∂glichkeit, sie zu bewegen. </font><font style="vertical-align: inherit;">Obwohl wir die Suche nach dem Pfad verwendet haben, um die g√ºltigen Endpunkte zu bestimmen, teleportierten sich die Truppen nach Erteilung des Befehls einfach in die letzte Zelle. </font><font style="vertical-align: inherit;">Um dem gefundenen Pfad tats√§chlich zu folgen, m√ºssen wir diesen Pfad verfolgen und einen Animationsprozess erstellen, der den Trupp zwingt, sich von Zelle zu Zelle zu bewegen. </font><font style="vertical-align: inherit;">Da es bei den Animationen schwierig ist zu bemerken, wie sich der Trupp bewegt hat, visualisieren wir auch den zur√ºckgelegten Weg mit Hilfe von Gizmos. </font><font style="vertical-align: inherit;">Aber bevor wir weitermachen, m√ºssen wir den Fehler beheben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler beim Abbiegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund eines Versehens berechnen wir den Kurs, auf dem die Zelle erreicht wird, falsch. </font><font style="vertical-align: inherit;">Jetzt bestimmen wir den Kurs, indem wir die Gesamtdistanz durch die Geschwindigkeit des Trupps dividieren</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-5"><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Verwerfen des Restes. </font><font style="vertical-align: inherit;">Der Fehler tritt auf, wenn Sie zum Betreten der Zelle genau alle verbleibenden Bewegungspunkte pro Bewegung ausgeben m√ºssen. </font><font style="vertical-align: inherit;">Wenn zum Beispiel jeder Schritt 1 kostet und die Geschwindigkeit 3 ‚Äã‚Äãbetr√§gt, k√∂nnen wir drei Zellen pro Runde bewegen. </font><font style="vertical-align: inherit;">Mit vorhandenen Berechnungen k√∂nnen wir jedoch nur zwei Schritte im ersten Schritt ausf√ºhren, da f√ºr den dritten Schritt</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.407ex" height="2.66ex" viewBox="0 -832 3189.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-73" x="2719" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">t = d / s</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s </font></font></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-17"><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-19"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-21"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.254ex" height="2.66ex" viewBox="0 -832 7859.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-73" x="2719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-3D" x="3466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-33" x="4523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2F" x="5023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-33" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-3D" x="6302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-31" x="7358" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2">t = d / s = 3 / 3 = 1</script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/9ec/098/d809ec098cac1850cf16d47ce45ed030.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die summierten Kosten f√ºr das Bewegen mit falsch definierten Z√ºgen, Geschwindigkeit 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºr die korrekte Berechnung der Z√ºge m√ºssen wir den Rand einen Schritt von der Anfangszelle entfernen. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir den Abstand um 1 verringern, bevor wir die Bewegung berechnen. Dann wird die Bewegung f√ºr den dritten Schritt sein</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-28"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.686ex" height="2.66ex" viewBox="0 -832 5031.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-32" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2F" x="2196" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-33" x="2696" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-3D" x="3474" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-30" x="4531" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">t = 2 / 3 = 0</script><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/291/37e/65629137e3267e033d1f5f6d3fd1f724.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtige Bewegungen</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen dies tun, indem wir die Berechnungsformel auf √§ndern</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.219ex" height="2.66ex" viewBox="0 -832 5691.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-28" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-64" x="2085" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2212" x="2830" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-31" x="3831" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-29" x="4332" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2F" x="4721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-73" x="5222" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4">t = (d - 1) / s</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese √Ñnderung an vornehmen </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; } ‚Ä¶ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir √§ndern auch die Noten der Z√ºge. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; ‚Ä¶ } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass bei diesem Ansatz der anf√§ngliche Zellenpfad -1 ist. </font><font style="vertical-align: inherit;">Dies ist normal, da wir es nicht anzeigen und der Suchalgorithmus funktionsf√§hig bleibt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weg bekommen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sich auf dem Weg zu bewegen, ist die Aufgabe des Teams. </font><font style="vertical-align: inherit;">Damit er dies tun kann, muss er den Weg kennen. </font><font style="vertical-align: inherit;">Wir haben diese Informationen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also f√ºgen wir eine Methode hinzu, um den aktuellen Pfad in Form einer Liste von Zellen zu erhalten. </font><font style="vertical-align: inherit;">Er kann es aus dem Listenpool nehmen und zur√ºckkehren, wenn es wirklich einen Weg gibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentPathExists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Liste wird gef√ºllt, indem Sie dem Verkn√ºpfungspfad von der letzten zur ersten Zelle folgen, wie dies bei der Visualisierung des Pfads der Fall ist. </font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Fall ben√∂tigen wir den gesamten Pfad, der die urspr√ºngliche Zelle enth√§lt. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } path.Add(currentPathFrom); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir den Pfad in umgekehrter Reihenfolge. </font><font style="vertical-align: inherit;">Wir k√∂nnen mit ihm arbeiten, aber es wird nicht sehr intuitiv sein. </font><font style="vertical-align: inherit;">Lassen Sie uns die Liste so umdrehen, dass sie von Anfang bis Ende verl√§uft.</font></font><br><br><pre> <code class="cs hljs"> path.Add(currentPathFrom); path.Reverse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegungsanfrage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">erg√§nzen </font><font style="vertical-align: inherit;">und ihm befehlen, dem Pfad zu folgen. </font><font style="vertical-align: inherit;">Zun√§chst lassen wir ihn einfach in die letzte Zelle teleportieren. </font><font style="vertical-align: inherit;">Wir werden die Liste nicht sofort an den Pool zur√ºckgeben, da dies f√ºr eine Weile n√ºtzlich sein wird.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine Bewegung anzufordern, √§ndern wir sie </font></font><code>HexGameUI.DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass sie eine neue Methode mit dem aktuellen Pfad aufruft und nicht nur den Standort der Einheit festlegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { <span class="hljs-comment"><span class="hljs-comment">// selectedUnit.Location = currentCell; selectedUnit.Travel(grid.GetPath()); grid.ClearPath(); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pfadvisualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir mit der Animation des Teams beginnen, √ºberpr√ºfen wir, ob die Pfade korrekt sind. </font><font style="vertical-align: inherit;">Wir werden dies tun, indem wir </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befehlen </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">uns den Pfad </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">merken, auf dem es sich bewegen muss, damit es mit Gizmos visualisiert werden kann.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; pathToTravel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Methode hinzu </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den letzten Pfad anzuzeigen (falls vorhanden). </font><font style="vertical-align: inherit;">Wenn sich das Ger√§t noch nicht bewegt hat, sollte der Pfad gleich sein </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aufgrund der Serialisierung von Unity w√§hrend der Bearbeitung nach der Neukompilierung im Wiedergabemodus kann es sich jedoch auch um eine leere Liste handeln.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, den Pfad anzuzeigen, besteht darin, f√ºr jede Zelle des Pfads eine Gizmo-Kugel zu zeichnen. </font><font style="vertical-align: inherit;">Eine Kugel mit einem Radius von 2 Einheiten ist f√ºr uns geeignet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pathToTravel.Count; i++) { Gizmos.DrawSphere(pathToTravel[i].Position, <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da wir die Pfade f√ºr die Abl√∂sung zeigen, k√∂nnen wir gleichzeitig alle ihre letzten Pfade sehen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/907/a7d/dac907a7da12a75436c7ae26956884bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gizmos zeigen die zuletzt zur√ºckgelegten Pfade an.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Zellverbindungen besser </font><i><font style="vertical-align: inherit;">darzustellen</font></i><font style="vertical-align: inherit;"> , zeichnen Sie mehrere Kugeln in einer Schleife auf einer Linie zwischen der vorherigen und der aktuellen Zelle. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir den Prozess von der zweiten Zelle aus starten. </font><font style="vertical-align: inherit;">Kugeln k√∂nnen durch lineare Interpolation mit einem Inkrement von 0,1 Einheiten angeordnet werden, so dass wir zehn Kugeln pro Segment erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/46a/11c/5c246a11c0753d03b2572de5bfc297a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offensichtlichere Wege</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleiten Sie den Weg entlang </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen dieselbe Methode verwenden, um Einheiten zu verschieben. </font><font style="vertical-align: inherit;">Lassen Sie uns eine Coroutine daf√ºr erstellen. </font><font style="vertical-align: inherit;">Anstatt ein Gizmo zu zeichnen, legen wir die Position des Trupps fest. </font><font style="vertical-align: inherit;">Anstatt zu erh√∂hen, verwenden wir das Zeitdelta von 0,1 und f√ºhren f√ºr jede Iteration eine Ausbeute durch. </font><font style="vertical-align: inherit;">In diesem Fall bewegt sich der Trupp in einer Sekunde von einer Zelle zur n√§chsten.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir am Ende der Methode mit Coroutine </font></font><code>Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber zuerst werden wir alle vorhandenen Coroutinen stoppen. </font><font style="vertical-align: inherit;">Wir garantieren also, dass zwei Coroutinen nicht gleichzeitig starten, da dies sonst zu sehr seltsamen Ergebnissen f√ºhren w√ºrde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verschieben einer Zelle pro Sekunde ist ziemlich langsam. </font><font style="vertical-align: inherit;">Der Spieler wird w√§hrend des Spiels nicht so lange warten wollen. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Bewegungsgeschwindigkeit des Trupps zu einer Konfigurationsoption machen, aber jetzt verwenden wir eine Konstante. </font><font style="vertical-align: inherit;">Ich habe ihr einen Wert von 4 Zellen pro Sekunde zugewiesen. </font><font style="vertical-align: inherit;">Es ist ziemlich schnell, aber lassen Sie uns bemerken, was passiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> travelSpeed = <span class="hljs-number"><span class="hljs-number">4f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So wie wir mehrere Pfade gleichzeitig visualisieren k√∂nnen, k√∂nnen wir mehrere Einheiten gleichzeitig fahren lassen. </font><font style="vertical-align: inherit;">Aus Sicht des Spielzustands ist die Bewegung immer noch Teleportation, die Animationen sind ausschlie√ülich visuell. </font><font style="vertical-align: inherit;">Einheiten besetzen sofort die letzte Zelle. </font><font style="vertical-align: inherit;">Sie k√∂nnen sogar Wege finden und einen neuen Zug beginnen, bevor sie eintreffen. </font><font style="vertical-align: inherit;">In diesem Fall werden sie visuell an den Anfang eines neuen Pfades teleportiert. </font><font style="vertical-align: inherit;">Dies kann vermieden werden, indem Einheiten oder sogar die gesamte Benutzeroberfl√§che blockiert werden, w√§hrend sie sich bewegen. Eine so schnelle Reaktion ist jedoch beim Entwickeln und Testen von Bewegungen sehr praktisch.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheiten bewegen. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit dem H√∂henunterschied?</font></font></b> <div class="spoiler_text">        ,      .       ,           .        ,    .   ,      .      ,  Endless Legend,   ,         .     ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position nach der Kompilierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einer der Nachteile von Corutin ist, dass sie beim erneuten Kompilieren im Wiedergabemodus nicht ‚Äû√ºberleben‚Äú. </font><font style="vertical-align: inherit;">Obwohl der Spielstatus immer wahr ist, kann dies dazu f√ºhren, dass Trupps irgendwo auf ihrem letzten Pfad stecken bleiben, wenn die Neukompilierung gestartet wird, w√§hrend sie sich noch bewegen. </font><font style="vertical-align: inherit;">Um die Konsequenzen abzuschw√§chen, stellen wir sicher, dass sich die Einheiten nach der Neukompilierung immer in der richtigen Position befinden. </font><font style="vertical-align: inherit;">Dies kann durch Aktualisieren ihrer Position in erfolgen </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reibungslose Bewegung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bewegung von der Mitte zur Mitte der Zelle wirkt zu mechanistisch und f√ºhrt zu scharfen Richtungs√§nderungen. </font><font style="vertical-align: inherit;">F√ºr viele Spiele ist dies normal, aber nicht akzeptabel, wenn Sie zumindest eine leicht realistische Bewegung ben√∂tigen. </font><font style="vertical-align: inherit;">√Ñndern wir also die Bewegung, damit sie etwas organischer aussieht.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegung von Rippe zu Rippe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Trupp beginnt seine Reise von der Mitte der Zelle aus. </font><font style="vertical-align: inherit;">Es geht in die Mitte des Zellenrandes und tritt dann in die n√§chste Zelle ein. </font><font style="vertical-align: inherit;">Anstatt sich in Richtung Zentrum zu bewegen, kann er geradewegs zur n√§chsten Kante gehen, die er √ºberqueren muss. </font><font style="vertical-align: inherit;">Tats√§chlich schneidet das Ger√§t den Pfad, wenn es die Richtung √§ndern muss. </font><font style="vertical-align: inherit;">Dies ist f√ºr alle Zellen au√üer den Endpunkten des Pfades m√∂glich.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8f0/1b9/2bc8f01b93b55b7acab8d9f56dd6f4be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei M√∂glichkeiten, sich von Kante zu Kante zu bewegen</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns die </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf diese Weise erzeugten Pfade anzeigen. </font><font style="vertical-align: inherit;">Es muss zwischen den Kanten der Zellen interpolieren, was durch Mitteln der Positionen benachbarter Zellen ermittelt werden kann. </font><font style="vertical-align: inherit;">Es reicht aus, eine Kante pro Iteration zu berechnen und den Wert aus der vorherigen Iteration wiederzuverwenden. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen wir die Methode f√ºr die urspr√ºngliche Zelle verwenden, aber anstelle der Kante nehmen wir ihre Position ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += 0.1f) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), 2f); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Mitte der Endzelle zu erreichen, m√ºssen wir die Zellenposition als letzten Punkt und nicht als Kante verwenden. </font><font style="vertical-align: inherit;">Sie k√∂nnen der Schleife eine √úberpr√ºfung dieses Falls hinzuf√ºgen, aber es ist ein so einfacher Code, dass es offensichtlicher ist, den Code einfach zu duplizieren und leicht zu √§ndern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ } a = b; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/466/4d4/deb4664d4f8bcffcc3839dddfaa0d792.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rippenbasierte</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pfade Die resultierenden Pfade √§hneln weniger Zickzackpfaden, und der maximale Drehwinkel wird von 120 ¬∞ auf 90 ¬∞ verringert. </font><font style="vertical-align: inherit;">Dies kann als Verbesserung angesehen werden. Daher wenden wir dieselben √Ñnderungen in der Coroutine </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an, um zu sehen, wie sie in der Animation aussehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } } a = b; b = pathToTravel[pathToTravel.Count - 1].Position; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegen mit wechselnder Geschwindigkeit</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach dem Schneiden der Winkel wurde die L√§nge der Pfadsegmente von der Richtungs√§nderung abh√§ngig. </font><font style="vertical-align: inherit;">Aber wir stellen die Geschwindigkeit in Zellen pro Sekunde ein. </font><font style="vertical-align: inherit;">Infolgedessen √§ndert sich die Abl√∂segeschwindigkeit zuf√§llig.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurven folgen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sofortige Richtungs- und Geschwindigkeits√§nderungen beim √úberschreiten von Zellgrenzen sehen h√§sslich aus. </font><font style="vertical-align: inherit;">Verwenden Sie besser eine allm√§hliche Richtungs√§nderung. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies unterst√ºtzen, indem wir die Truppen zwingen, eher Kurven als geraden Linien zu folgen. </font><font style="vertical-align: inherit;">Hierf√ºr k√∂nnen Sie Bezier-Kurven verwenden. </font><font style="vertical-align: inherit;">Insbesondere k√∂nnen wir quadratische Bezier-Kurven nehmen, bei denen der Mittelpunkt der Zellen die mittleren Kontrollpunkte sind. </font><font style="vertical-align: inherit;">In diesem Fall sind die Tangenten benachbarter Kurven spiegelbildlich zueinander, dh der gesamte Pfad wird zu einer kontinuierlichen glatten Kurve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/c46/0b8/a94c460b8e7b3fd2ecc3b4ea4e3225a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurven von Kante zu Kante</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie eine Hilfsklasse </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer Methode zum Erhalten von Punkten auf einer quadratischen Bezier-Kurve. </font><font style="vertical-align: inherit;">Wie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial Kurven und Splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erl√§utert </font><font style="vertical-align: inherit;">, wird hierf√ºr die Formel verwendet</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-44">1</span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">t</span><span class="MJXp-msubsup" id="MJXp-Span-47"><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-49" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">A</span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-52">2</span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-54">1</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">t</span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">B</span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62" style="margin-right: 0.05em;">t</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-63" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.208ex" height="2.901ex" viewBox="0 -935.7 12575.6 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2212" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="2112" y="0"></use><g transform="translate(2474,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-32" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-41" x="3317" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2B" x="4290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-32" x="5291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-28" x="5791" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-31" x="6181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2212" x="6904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="7904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-29" x="8266" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="8655" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-42" x="9017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-2B" x="9998" y="0"></use><g transform="translate(10999,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMAIN-32" x="511" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-43" x="11815" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">(1 - t)^2 A + 2(1 - t) t B + t^2 C</script>  wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">A</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.057ex" viewBox="0 -780.1 750.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-41" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> A </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">B</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-42" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> B </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhhxunu6aQVYTdwYX9tBvSB43Ts1tw#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8">C</script> ‚Äî   ,  t ‚Äî . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bezier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = <span class="hljs-number"><span class="hljs-number">1f</span></span> - t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * r * a + <span class="hljs-number"><span class="hljs-number">2f</span></span> * r * t * b + t * t * c; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> GetPoint      0-1?</b> <div class="spoiler_text">         0-1,    .          .  ,    <code>GetPointClamped</code> ,    <code>t</code> .      ,      <code>GetPointUnclamped</code> . </div></div><br>      <code>OnDrawGizmos</code> ,     ,   .   ‚Äî   ,       ,   <code>i - 1</code> ,      1.   ,    <code>Vector3.Lerp</code>  <code>Bezier.GetPoint</code> . <br><br>                . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/79d/cae/14079dcae70b7b2522c137e0af848883.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Bezier-Kurven erstellte Pfade Ein gekr√ºmmter</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pfad sieht viel besser aus. </font><font style="vertical-align: inherit;">Wir wenden die gleichen √Ñnderungen an </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sehen, wie die Einheiten mit diesem Ansatz animiert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bewegen uns entlang der Kurven. Die</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animation wurde auch dann fl√ºssig, wenn die Geschwindigkeit der Abl√∂sung instabil ist. </font><font style="vertical-align: inherit;">Da die Tangenten der Kurve der benachbarten Segmente zusammenfallen, ist die Geschwindigkeit kontinuierlich. </font><font style="vertical-align: inherit;">Die Geschwindigkeits√§nderung erfolgt allm√§hlich und tritt auf, wenn eine Abl√∂sung die Zelle passiert, und verlangsamt sich beim Richtungswechsel. </font><font style="vertical-align: inherit;">Wenn er geradeaus f√§hrt, bleibt die Geschwindigkeit konstant. </font><font style="vertical-align: inherit;">Au√üerdem beginnt und endet der Trupp mit null Geschwindigkeit. </font><font style="vertical-align: inherit;">Dies ahmt die nat√ºrliche Bewegung nach, also lass es so.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiterfassung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Punkt haben wir begonnen, √ºber jedes der Segmente von 0 zu iterieren, bis wir 1 erreicht haben. Dies funktioniert gut, wenn wir um einen konstanten Wert erh√∂hen, aber unsere Iteration h√§ngt vom Zeitdelta ab. Wenn die Iteration √ºber ein Segment abgeschlossen ist, werden wir wahrscheinlich 1 um einen gewissen Betrag √ºberschreiten, abh√§ngig vom Delta der Zeit. Dies ist bei hohen Bildraten unsichtbar, kann jedoch bei niedrigen Bildraten zu Ruckeln f√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Zeitverlust zu vermeiden, m√ºssen wir die verbleibende Zeit von einem Segment zum n√§chsten √ºbertragen. Dies kann durch Verfolgen </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des gesamten Pfads und nicht nur in jedem Segment erfolgen. Am Ende jedes Segments subtrahieren wir dann 1 davon.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * traveSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir dies bereits tun, stellen wir sicher, dass das Zeitdelta am Anfang des Pfads ber√ºcksichtigt wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir uns sofort bewegen und nicht f√ºr einen Frame unt√§tig bleiben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem beenden wir nicht genau zu dem Zeitpunkt, an dem der Pfad enden soll, sondern kurz zuvor. </font><font style="vertical-align: inherit;">Hier kann der Unterschied auch von der Bildrate abh√§ngen. </font><font style="vertical-align: inherit;">Lassen Sie den Trupp daher den Pfad genau am Endpunkt vervollst√§ndigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = location.Position; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Orientierungsanimation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Einheiten begannen sich entlang einer glatten Kurve zu bewegen, √§nderten jedoch nicht die Ausrichtung entsprechend der Bewegungsrichtung. </font><font style="vertical-align: inherit;">Infolgedessen scheinen sie zu gleiten. </font><font style="vertical-align: inherit;">Damit die Bewegung wie eine echte Bewegung aussieht, m√ºssen wir sie drehen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich freue mich darauf </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial "Kurven und Splines"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen wir die Ableitung der Kurve verwenden, um die Ausrichtung der Einheit zu bestimmen. </font><font style="vertical-align: inherit;">Die Formel f√ºr die Ableitung einer quadratischen Bezier-Kurve:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mn" id="MJXp-Span-72"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-75"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-76" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font></span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-86" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-91" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">2 ((1 - t) (B - A) + t (C - B))</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnungsmethode hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDerivative</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2f</span></span> * ((<span class="hljs-number"><span class="hljs-number">1f</span></span> - t) * (b - a) + t * (c - b)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Ableitungsvektor befindet sich auf einer geraden Linie mit der Bewegungsrichtung. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Methode verwenden </font></font><code>Quaternion.LookRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um sie in eine Squad-Runde umzuwandeln. </font><font style="vertical-align: inherit;">Wir werden es bei jedem Schritt durchf√ºhren </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ‚Ä¶ transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt es am Anfang des Pfades keinen Fehler?</font></font></b> <div class="spoiler_text">    ,        .    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">A</span></span></span><script type="math/tex" id="MathJax-Element-10"> A </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">B</span></span></span><script type="math/tex" id="MathJax-Element-11"> B </script>  ,    .   ,   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">t</span><span class="MJXp-mo" id="MJXp-Span-98" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-99">0</span></span></span><script type="math/tex" id="MathJax-Element-12">t = 0</script> ,     ,      <code>Quaternion.LookRotation</code> .  ,    ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">t</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-103">0</span></span></span><script type="math/tex" id="MathJax-Element-13">t = 0</script>   .     .       ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">t</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-107">0</span></span></span><script type="math/tex" id="MathJax-Element-14">t > 0</script>    . <br>         ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mn" id="MJXp-Span-111">1</span></span></span><script type="math/tex" id="MathJax-Element-15">t < 1</script>  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zur Position der Abl√∂sung ist die Nichtidealit√§t ihrer Ausrichtung am Ende des Pfades nicht wichtig. </font><font style="vertical-align: inherit;">Wir m√ºssen jedoch sicherstellen, dass seine Ausrichtung der endg√ºltigen Drehung entspricht. </font><font style="vertical-align: inherit;">Dazu setzen wir nach Abschluss seine Ausrichtung mit seiner Drehung in Y gleich.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = location.Position; orientation = transform.localRotation.eulerAngles.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt schauen die Einheiten genau in die Bewegungsrichtung, sowohl horizontal als auch vertikal. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie sich vorw√§rts und r√ºckw√§rts lehnen, von den H√§ngen absteigen und sie erklimmen. </font><font style="vertical-align: inherit;">Um sicherzustellen, dass sie immer gerade stehen, zwingen wir die Komponente Y des Richtungsvektors auf Null, bevor wir sie zur Bestimmung der Drehung der Einheit verwenden.</font></font><br><br><pre> <code class="cs hljs"> Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); ‚Ä¶ Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich freue mich darauf, mich zu bewegen</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schauen uns den Punkt an </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend des gesamten Weges blicken die Einheiten nach vorne, aber bevor sie sich bewegen, k√∂nnen sie in die andere Richtung schauen. In diesem Fall √§ndern sie sofort ihre Ausrichtung. Es ist besser, wenn sie sich vor Beginn der Bewegung in Richtung des Pfades drehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Blick in die richtige Richtung kann in anderen Situationen hilfreich sein. Erstellen wir also eine Methode </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der der Trupp gezwungen wird, die Ausrichtung zu √§ndern, um einen bestimmten Punkt zu betrachten. Die erforderliche Drehung kann mithilfe der Methode eingestellt werden </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, indem zun√§chst der Punkt in derselben vertikalen Position wie die Abl√∂sung platziert wird. Danach k√∂nnen wir die Ausrichtung des Teams abrufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit sich die Abl√∂sung tats√§chlich dreht, verwandeln wir die Methode in ein anderes Corutin, das sie mit konstanter Geschwindigkeit dreht. Die Drehgeschwindigkeit kann ebenfalls angepasst werden, aber wir werden die Konstante wieder verwenden. Die Drehung sollte schnell sein, ungef√§hr 180 ¬∞ pro Sekunde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed = <span class="hljs-number"><span class="hljs-number">180f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist nicht notwendig, an der Beschleunigung der Kurve zu basteln, da dies nicht wahrnehmbar ist. Es wird f√ºr uns ausreichen, einfach zwischen den beiden Orientierungen zu interpolieren. Leider ist dies nicht so einfach wie bei zwei Zahlen, da die Winkel kreisf√∂rmig sind. Zum Beispiel sollte ein √úbergang von 350 ¬∞ zu 10 ¬∞ zu einer Drehung um 20 ¬∞ im Uhrzeigersinn f√ºhren, aber eine einfache Interpolation erzwingt eine Drehung um 340 ¬∞ gegen den Uhrzeigersinn. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, eine korrekte Rotation zu erstellen, besteht darin, zwischen zwei Quaternionen mithilfe der sph√§rischen Interpolation zu interpolieren. Dies f√ºhrt zur k√ºrzesten Kurve. Dazu erhalten wir die Quaternionen von Anfang und Ende und machen dann mit einen √úbergang zwischen ihnen </font></font><code>Quaternion.Slerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert, aber die Interpolation geht unabh√§ngig vom Drehwinkel immer von 0 auf 1. </font><font style="vertical-align: inherit;">Um eine gleichm√§√üige Winkelgeschwindigkeit zu gew√§hrleisten, m√ºssen wir die Interpolation mit zunehmendem Drehwinkel verlangsamen.</font></font><br><br><pre> <code class="cs hljs"> Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * speed; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * speed ) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir den Winkel kennen, k√∂nnen wir die Kurve vollst√§ndig √ºberspringen, wenn sich herausstellt, dass sie Null ist. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ‚Ä¶ ) { ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Rotation der Einheit hinzuf√ºgen, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">einfach die Ausbeute ausf√ºhren, bevor </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">die </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position der zweiten Zelle verschieben. </font><font style="vertical-align: inherit;">Unity startet Coroutine automatisch </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wartet auf den Abschluss.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie den Code √ºberpr√ºfen, teleportiert sich der Trupp in die letzte Zelle, dreht sich dort um und teleportiert sich dann zur√ºck zum Anfang des Pfades und beginnt, sich von dort aus zu bewegen. </font><font style="vertical-align: inherit;">Dies geschieht, weil wir einer Eigenschaft </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor Beginn der Coroutine </font><font style="vertical-align: inherit;">einen Wert zuweisen </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um die Teleportation loszuwerden, k√∂nnen wir zu Beginn </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Position der Abteilung in die urspr√ºngliche Zelle zur√ºckbringen.</font></font><br><br><pre> <code class="cs hljs"> Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; transform.localPosition = c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor dem Bewegen drehen</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Bewegung erhalten haben, die wir brauchen, k√∂nnen wir die Methode loswerden </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L√∂schen Sie es oder kommentieren Sie es aus, falls wir in Zukunft Pfade sehen m√ºssen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void OnDrawGizmos () { // ‚Ä¶ // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir uns nicht mehr merken m√ºssen, in welche Richtung wir uns bewegt haben, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen Sie </font><font style="vertical-align: inherit;">am Ende </font><font style="vertical-align: inherit;">die Liste der Zellen freigeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ ListPool&lt;HexCell&gt;.Add(pathToTravel); pathToTravel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit echten Squad-Animationen?</font></font></b> <div class="spoiler_text">         ,   .    3D-       .      .        ,     .       Mecanim,     <code>TravelPath</code> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426481/">https://habr.com/ru/post/de426481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426471/index.html">Wie Spyware-Daten auslaufen</a></li>
<li><a href="../de426473/index.html">Redux-Architektur. Ja oder Nein?</a></li>
<li><a href="../de426475/index.html">Miya - Assistent vom Smartphone</a></li>
<li><a href="../de426477/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 15. Speicherpartitionen: Dienste und Datenstrukturen</a></li>
<li><a href="../de426479/index.html">Selbst gemachter Pr√ºfstand f√ºr Motherboards</a></li>
<li><a href="../de426483/index.html">Einer, der Tesla √ºberholt. F√ºr profitabler</a></li>
<li><a href="../de426485/index.html">Dritter Qt 5 Test mit PVS-Studio</a></li>
<li><a href="../de426487/index.html">Testen Sie die Automatisierung von Grund auf neu. Teil 1</a></li>
<li><a href="../de426489/index.html">√úber das Verh√§ltnis von Primzahlen und irrationalen Zahlen</a></li>
<li><a href="../de426491/index.html">Sicherheitswoche 39: Zum Tod von Google+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>