<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎨 📧 👨‍👦 So erstellen Sie Ihren Autoscaler für einen Cluster 👩🏾‍🍳 👑 🧛🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Wir schulen Menschen in der Arbeit mit Big Data. Ein eigenes Cluster, an dem alle Beteiligten zusammenarbeiten, ist aus einem Bildungsprogramm ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So erstellen Sie Ihren Autoscaler für einen Cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/newprolab/blog/482198/"><p>  Hallo!  Wir schulen Menschen in der Arbeit mit Big Data.  Ein eigenes Cluster, an dem alle Beteiligten zusammenarbeiten, ist aus einem Bildungsprogramm zu Big Data nicht mehr wegzudenken.  Aus diesem Grund haben wir es immer auf unserem Programm :) Wir sind mit Tuning, Tuning und Administration beschäftigt und die Jungs starten MapReduce-Jobs direkt dort und nutzen Spark. </p><br><p>  In diesem Beitrag beschreiben wir, wie wir das Problem des ungleichmäßigen Ladens von Clustern gelöst haben, indem wir unseren Autoscaler mithilfe der <a href="https://mcs.mail.ru/">Cloud von Mail.ru Cloud Solutions geschrieben haben</a> . </p><a name="habracut"></a><br><h2 id="problema">  Das problem </h2><br><p>  Der von uns verwendete Cluster ist nicht ganz typisch.  Die Entsorgung ist sehr ungleichmäßig.  Beispielsweise gibt es praktische Übungen, bei denen alle 30 Personen und der Lehrer in den Cluster eintreten und ihn verwenden.  Oder es gibt Tage vor dem Stichtag, an dem die Last dramatisch zunimmt.  In der restlichen Zeit arbeitet der Cluster im Unterlastmodus. </p><br><p>  Lösung Nr. 1 besteht darin, einen Cluster beizubehalten, der Spitzenlasten standhält, aber den Rest der Zeit im Leerlauf bleibt. </p><br><p>  Lösung Nr. 2 besteht darin, einen kleinen Cluster beizubehalten, in dem Knoten vor Klassen und während Spitzenlasten manuell hinzugefügt werden können. </p><br><p>  Lösung Nr. 3 besteht darin, einen kleinen Cluster beizubehalten und einen Autoscaler zu schreiben, der die aktuelle Clusterlast überwacht und mithilfe verschiedener APIs Knoten zum Cluster hinzufügt und daraus entfernt. </p><br><p>  In diesem Beitrag werden wir über die Entscheidung Nr. 3 sprechen.  Ein solcher Autoscaler ist in hohem Maße von externen und nicht von internen Faktoren abhängig und wird von Anbietern häufig nicht bereitgestellt.  Wir verwenden die Cloud-Infrastruktur von Mail.ru Cloud Solutions und haben einen Autoscaler unter Verwendung der MCS-API geschrieben.  Da wir in der Arbeit mit Daten geschult sind, haben wir uns entschlossen zu zeigen, wie Sie einen ähnlichen Autoscaler für Ihre Zwecke schreiben und mit Ihrer Cloud verwenden können </p><br><h2 id="prerequisites">  Voraussetzungen </h2><br><p>  Zunächst muss ein Hadoop-Cluster vorhanden sein.  Zum Beispiel verwenden wir die HDP-Distribution. </p><br><p>  Damit Ihre Knoten schnell hinzugefügt und entfernt werden können, müssen Sie eine bestimmte Rollenverteilung zwischen den Knoten haben. </p><br><ol><li>  Hauptknoten.  Hier ist nichts besonders zu erklären: Der Hauptknoten des Clusters, auf dem beispielsweise der Spark-Treiber gestartet wird, wenn Sie den interaktiven Modus verwenden. </li><li>  Datumsknoten.  Dies ist der Knoten, auf dem Sie Daten in HDFS speichern und auf dem Berechnungen ausgeführt werden. </li><li>  Rechenknoten.  Dies ist ein Knoten, auf dem Sie nichts in HDFS speichern, sondern Berechnungen durchführen. </li></ol><br><p>  Ein wichtiger Punkt.  Die automatische Skalierung erfolgt aufgrund des dritten Knotentyps.  Wenn Sie mit dem Aufnehmen und Hinzufügen von Knoten des zweiten Typs beginnen, ist die Antwortgeschwindigkeit sehr niedrig - dekomprimiert und empfohlen dauert es Stunden, bis Ihr Cluster vollständig entpackt ist.  Dies ist natürlich nicht das, was Sie von der automatischen Skalierung erwarten.  Das heißt, wir berühren nicht die Knoten des ersten und zweiten Typs.  Sie werden ein minimal lebensfähiger Cluster sein, der während des gesamten Programms existieren wird. </p><br><p>  Daher ist unser Autoscoiler in Python 3 geschrieben, verwendet die Ambari-API zum Verwalten von Clusterdiensten und <a href="https://mcs.mail.ru/help/iaas-api/openstack-api">die Mail.ru Cloud Solutions</a> (MCS) <a href="https://mcs.mail.ru/help/iaas-api/openstack-api">-API</a> zum Starten und Stoppen von Computern. </p><br><h2 id="arhitektura-resheniya">  Lösungsarchitektur </h2><br><ol><li> Modul <code>autoscaler.py</code> .  Darin sind drei Klassen registriert: 1) Funktionen für die Arbeit mit Ambari, 2) Funktionen für die Arbeit mit MCS, 3) Funktionen, die sich direkt auf die Autoscaler-Logik beziehen. </li><li>  Script <code>observer.py</code> .  Tatsächlich besteht es aus verschiedenen Regeln: Wann und zu welchen Zeitpunkten sollen die Autoscaler-Funktionen aufgerufen werden? </li><li>  Die Datei mit den Konfigurationsparametern <code>config.py</code> .  Es enthält zum Beispiel eine Liste von Knoten, die für die automatische Skalierung zugelassen sind, und andere Parameter, die sich zum Beispiel darauf auswirken, wie lange nach dem Hinzufügen eines neuen Knotens gewartet werden muss.  Es gibt auch Zeitstempel für den Beginn von Klassen, sodass vor der Sitzung die maximal zulässige Cluster-Konfiguration gestartet wird. </li></ol><br><p>  Schauen wir uns die Code-Teile in den ersten beiden Dateien an. </p><br><h2 id="1-modul-autoscalerpy">  1. Das Modul autoscaler.py </h2><br><h3 id="klass-ambari">  Klasse Ambari </h3><br><p>  Dies ist der Code, der die <code>Ambari</code> Klasse enthält: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ambari</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ambari_url, cluster_name, headers, auth)</span></span></span><span class="hljs-function">:</span></span> self.ambari_url = ambari_url self.cluster_name = cluster_name self.headers = headers self.auth = auth <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_all_services</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, hostname)</span></span></span><span class="hljs-function">:</span></span> url = self.ambari_url + self.cluster_name + <span class="hljs-string"><span class="hljs-string">'/hosts/'</span></span> + hostname + <span class="hljs-string"><span class="hljs-string">'/host_components/'</span></span> url2 = self.ambari_url + self.cluster_name + <span class="hljs-string"><span class="hljs-string">'/hosts/'</span></span> + hostname req0 = requests.get(url2, headers=self.headers, auth=self.auth) services = req0.json()[<span class="hljs-string"><span class="hljs-string">'host_components'</span></span>] services_list = list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-string"><span class="hljs-string">'HostRoles'</span></span>][<span class="hljs-string"><span class="hljs-string">'component_name'</span></span>], services)) data = { <span class="hljs-string"><span class="hljs-string">"RequestInfo"</span></span>: { <span class="hljs-string"><span class="hljs-string">"context"</span></span>:<span class="hljs-string"><span class="hljs-string">"Stop All Host Components"</span></span>, <span class="hljs-string"><span class="hljs-string">"operation_level"</span></span>: { <span class="hljs-string"><span class="hljs-string">"level"</span></span>:<span class="hljs-string"><span class="hljs-string">"HOST"</span></span>, <span class="hljs-string"><span class="hljs-string">"cluster_name"</span></span>: self.cluster_name, <span class="hljs-string"><span class="hljs-string">"host_names"</span></span>: hostname }, <span class="hljs-string"><span class="hljs-string">"query"</span></span>:<span class="hljs-string"><span class="hljs-string">"HostRoles/component_name.in({0})"</span></span>.format(<span class="hljs-string"><span class="hljs-string">","</span></span>.join(services_list)) }, <span class="hljs-string"><span class="hljs-string">"Body"</span></span>: { <span class="hljs-string"><span class="hljs-string">"HostRoles"</span></span>: { <span class="hljs-string"><span class="hljs-string">"state"</span></span>:<span class="hljs-string"><span class="hljs-string">"INSTALLED"</span></span> } } } req = requests.put(url, data=json.dumps(data), headers=self.headers, auth=self.auth) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req.status_code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">201</span></span>, <span class="hljs-number"><span class="hljs-number">202</span></span>]: message = <span class="hljs-string"><span class="hljs-string">'Request accepted'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: message = req.status_code <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message</code> </pre> <br><p>  Ein Beispiel oben zeigt die Implementierung der Funktion <code>stop_all_services</code> , mit der alle Dienste auf dem gewünschten Clusterknoten <code>stop_all_services</code> werden. </p><br><p>  An die <code>Ambari</code> Klasse übergeben Sie: </p><br><ul><li>  <code>ambari_url</code> zum Beispiel mit der Form <code>'http://localhost:8080/api/v1/clusters/'</code> , </li><li>  <code>cluster_name</code> ist der Name Ihres Clusters in Ambari. </li><li> <code>headers = {'X-Requested-By': 'ambari'}</code> </li> <li>  und in <code>auth</code> liegt dein Benutzername und Passwort von Ambari: <code>auth = ('login', 'password')</code> . </li></ul><br><p>  Die Funktion selbst besteht lediglich aus ein paar Aufrufen über die REST-API an Ambari.  Aus logischer Sicht erhalten wir zunächst eine Liste der auf dem Knoten ausgeführten Dienste und fordern dann diesen Cluster auf, die Dienste von der Liste in den <code>INSTALLED</code> .  Die Funktionen zum Starten aller Dienste, zum Versetzen der Knoten in den <code>Maintenance</code> usw. sehen ähnlich aus - dies sind nur einige wenige Anforderungen über die API. </p><br><h3 id="klass-mcs">  Klasse mcs </h3><br><p>  Dies ist der Code, der die <code>Mcs</code> Klasse enthält: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mcs</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id1, id2, password)</span></span></span><span class="hljs-function">:</span></span> self.id1 = id1 self.id2 = id2 self.password = password self.mcs_host = <span class="hljs-string"><span class="hljs-string">'https://infra.mail.ru:8774/v2.1'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_turn_on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, hostname)</span></span></span><span class="hljs-function">:</span></span> self.token = self.get_mcs_token() host = self.hostname_to_vmname(hostname) vm_id = self.get_vm_id(host) mcs_url1 = self.mcs_host + <span class="hljs-string"><span class="hljs-string">'/servers/'</span></span> + self.vm_id + <span class="hljs-string"><span class="hljs-string">'/action'</span></span> headers = { <span class="hljs-string"><span class="hljs-string">'X-Auth-Token'</span></span>: <span class="hljs-string"><span class="hljs-string">'{0}'</span></span>.format(self.token), <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } data = {<span class="hljs-string"><span class="hljs-string">'os-start'</span></span> : <span class="hljs-string"><span class="hljs-string">'null'</span></span>} mcs = requests.post(mcs_url1, data=json.dumps(data), headers=headers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mcs.status_code</code> </pre> <br><p>  An die <code>Mcs</code> Klasse übergeben wir die Projekt-ID in der Cloud und die Benutzer-ID sowie sein Passwort.  In der Funktion <code>vm_turn_on</code> möchten wir eine der Maschinen aktivieren.  Die Logik hier ist etwas komplizierter.  Zu Beginn des Codes werden drei weitere Funktionen aufgerufen: 1) Wir müssen das Token abrufen, 2) Wir müssen den Hostnamen in den Namen der Maschine in MCS konvertieren, 3) Die ID dieser Maschine abrufen.  Als Nächstes erstellen wir eine einfache Nachanforderung und führen diese Maschine aus. </p><br><p>  So sieht die Funktion zum Empfangen von Token aus: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mcs_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://infra.mail.ru:35357/v3/auth/tokens?nocatalog'</span></span> headers = {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>} data = { <span class="hljs-string"><span class="hljs-string">'auth'</span></span>: { <span class="hljs-string"><span class="hljs-string">'identity'</span></span>: { <span class="hljs-string"><span class="hljs-string">'methods'</span></span>: [<span class="hljs-string"><span class="hljs-string">'password'</span></span>], <span class="hljs-string"><span class="hljs-string">'password'</span></span>: { <span class="hljs-string"><span class="hljs-string">'user'</span></span>: { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: self.id1, <span class="hljs-string"><span class="hljs-string">'password'</span></span>: self.password } } }, <span class="hljs-string"><span class="hljs-string">'scope'</span></span>: { <span class="hljs-string"><span class="hljs-string">'project'</span></span>: { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: self.id2 } } } } params = ((<span class="hljs-string"><span class="hljs-string">'nocatalog'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>),) req = requests.post(url, data=json.dumps(data), headers=headers, params=params) self.token = req.headers[<span class="hljs-string"><span class="hljs-string">'X-Subject-Token'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.token</code> </pre> <br><h3 id="klass-autoscaler">  Klasse Autoscaler </h3><br><p>  Diese Klasse enthält Funktionen, die sich auf die Logik der Arbeit selbst beziehen. </p><br><p>  So sieht ein Teil des Codes dieser Klasse aus: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Autoscaler</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ambari, mcs, scaling_hosts, yarn_ram_per_node, yarn_cpu_per_node)</span></span></span><span class="hljs-function">:</span></span> self.scaling_hosts = scaling_hosts self.ambari = ambari self.mcs = mcs self.q_ram = deque() self.q_cpu = deque() self.num = <span class="hljs-number"><span class="hljs-number">0</span></span> self.yarn_ram_per_node = yarn_ram_per_node self.yarn_cpu_per_node = yarn_cpu_per_node <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale_down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, hostname)</span></span></span><span class="hljs-function">:</span></span> flag1 = flag2 = flag3 = flag4 = flag5 = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hostname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.scaling_hosts: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status1 = self.ambari.decommission_nodemanager(hostname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status1 == <span class="hljs-string"><span class="hljs-string">'Request accepted'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> status1 == <span class="hljs-number"><span class="hljs-number">500</span></span>: flag1 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Decomission request accepted: {0}'</span></span>.format(flag1)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status3 = self.ambari.check_service(hostname, <span class="hljs-string"><span class="hljs-string">'NODEMANAGER'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status3 == <span class="hljs-string"><span class="hljs-string">'INSTALLED'</span></span>: flag3 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Nodemaneger decommissioned: {0}'</span></span>.format(flag3)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status2 = self.ambari.maintenance_on(hostname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status2 == <span class="hljs-string"><span class="hljs-string">'Request accepted'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> status2 == <span class="hljs-number"><span class="hljs-number">500</span></span>: flag2 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Maintenance request accepted: {0}'</span></span>.format(flag2)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status4 = self.ambari.check_maintenance(hostname, <span class="hljs-string"><span class="hljs-string">'NODEMANAGER'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status4 == <span class="hljs-string"><span class="hljs-string">'ON'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> status4 == <span class="hljs-string"><span class="hljs-string">'IMPLIED_FROM_HOST'</span></span>: flag4 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.ambari.stop_all_services(hostname) logging.info(<span class="hljs-string"><span class="hljs-string">'Maintenance is on: {0}'</span></span>.format(flag4)) logging.info(<span class="hljs-string"><span class="hljs-string">'Stopping services'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">90</span></span>) status5 = self.mcs.vm_turn_off(hostname) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status5 = self.mcs.get_vm_info(hostname)[<span class="hljs-string"><span class="hljs-string">'server'</span></span>][<span class="hljs-string"><span class="hljs-string">'status'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status5 == <span class="hljs-string"><span class="hljs-string">'SHUTOFF'</span></span>: flag5 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'VM is turned off: {0}'</span></span>.format(flag5)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> flag1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag2 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag3 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag4 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag5: message = <span class="hljs-string"><span class="hljs-string">'Success'</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Scale-down finished'</span></span>) logging.info(<span class="hljs-string"><span class="hljs-string">'Cooldown period has started. Wait for several minutes'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message</code> </pre> <br><p>  Wir akzeptieren die Klassen <code>Ambari</code> und <code>Mcs</code> , die Liste der für die Skalierung zulässigen Knoten und die Konfigurationsparameter der Knoten: Speicher und CPU, die dem Knoten in YARN zugewiesen sind.  Es gibt auch 2 interne Parameter q_ram, q_cpu, die Warteschlangen sind.  Mit ihnen speichern wir die Werte der aktuellen Clusterlast.  Wenn wir in den letzten 5 Minuten feststellen, dass die Last stabil gestiegen ist, müssen wir dem Cluster einen +1-Knoten hinzufügen.  Gleiches gilt für den Cluster-Unterlastzustand. </p><br><p>  Der obige Code zeigt ein Beispiel für eine Funktion, mit der ein Computer aus einem Cluster entfernt und in der Cloud gestoppt wird.  Zuerst wird der <code>YARN Nodemanager</code> , dann der <code>Maintenance</code> <code>YARN Nodemanager</code> , dann werden alle Dienste auf dem <code>YARN Nodemanager</code> und die virtuelle Maschine in der Cloud ausgeschaltet. </p><br><h2 id="2-skript-observerpy">  2. Script observer.py </h2><br><p>  Beispielcode von dort: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scaler.assert_up(config.scale_up_thresholds) == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: hostname = cloud.get_vm_to_up(config.scaling_hosts) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hostname != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: status1 = scaler.scale_up(hostname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status1 == <span class="hljs-string"><span class="hljs-string">'Success'</span></span>: text = {<span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"{0} has been successfully scaled-up"</span></span>.format(hostname)} post = {<span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"{0}"</span></span>.format(text)} json_data = json.dumps(post) req = requests.post(webhook, data=json_data.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>), headers={<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>}) time.sleep(config.cooldown_period*<span class="hljs-number"><span class="hljs-number">60</span></span>)</code> </pre> <br><p>  Darin prüfen wir, ob die Bedingungen für die Erhöhung der Clusterkapazitäten gegeben sind und ob sich überhaupt Maschinen in der Reserve befinden, erhalten den Hostnamen einer von ihnen, fügen ihn dem Cluster hinzu und veröffentlichen eine entsprechende Meldung in Slack unseres Teams.  Danach wird <code>cooldown_period</code> gestartet, wenn wir nichts zum Cluster hinzufügen oder daraus entfernen, sondern lediglich die Auslastung überwachen.  Wenn es sich stabilisiert hat und sich innerhalb des Korridors der optimalen Lastwerte befindet, setzen wir die Überwachung einfach fort.  Wenn ein Knoten nicht ausreicht, fügen Sie einen anderen hinzu. </p><br><p>  In Fällen, in denen wir eine Lektion vor uns haben, wissen wir bereits, dass ein Knoten nicht ausreicht. Deshalb starten wir sofort alle freien Knoten und lassen sie bis zum Ende der Lektion aktiv.  Dies geschieht mit einer Liste von Zeitstempelklassen. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Autoscaler ist eine gute und praktische Lösung für Fälle, in denen die Clusterlast ungleichmäßig ist.  Sie erreichen gleichzeitig die gewünschte Cluster-Konfiguration für Spitzenlasten und halten diesen Cluster gleichzeitig nicht während des Unterladens, was Geld spart.  Außerdem geschieht alles automatisch ohne Ihre Teilnahme.  Der Autoscaler selbst ist nichts anderes als eine Reihe von Anforderungen an die Cluster-Manager-API und die Cloud-Provider-API, die gemäß einer bestimmten Logik registriert werden.  Was genau beachtet werden muss, ist die Trennung der Knoten in 3 Typen, wie wir zuvor geschrieben haben.  Und du wirst glücklich sein. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482198/">https://habr.com/ru/post/de482198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482186/index.html">Leben und IT oder das Jahr, in dem ich meinen letzten Job gekündigt habe</a></li>
<li><a href="../de482188/index.html">Freitag Umfrage über Updates</a></li>
<li><a href="../de482190/index.html">Wie sehen Durex-Inhalte in sozialen Netzwerken in China aus?</a></li>
<li><a href="../de482194/index.html">Automatische Generierung und Befüllung von Netzwerkgerätekonfigurationselementen mit Nornir</a></li>
<li><a href="../de482196/index.html">Was ist Produktionsmodellierung und warum wird sie benötigt?</a></li>
<li><a href="../de482200/index.html">Blockchain für Cybersicherheit: Erwartungen und Realität</a></li>
<li><a href="../de482202/index.html">Methoden zum Aktualisieren der Kryptografie auf Check Point-Geräten auf GOST 2012</a></li>
<li><a href="../de482206/index.html">Wie man die 3D-Produktion von Flugzeugteilen wirtschaftlicher macht</a></li>
<li><a href="../de482208/index.html">Geschenke, mit denen Sie das neue Jahr verpassen</a></li>
<li><a href="../de482210/index.html">Bot für Tetris und Reverse Engineering Animation. Analyse der mobilen Strecke der zweiten Programmiermeisterschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>