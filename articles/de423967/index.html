<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèª ‚ö™Ô∏è üë©üèæ‚Äçüîß Die ganze Wahrheit √ºber RTOS. Artikel 10. Scheduler: Erweiterte Funktionen und Kontexterhaltung ü§∞üèΩ ‚õπÔ∏è üëµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel haben wir uns mit den verschiedenen vom RTOS unterst√ºtzten Planungsarten und den damit verbundenen Funktionen in Nucleus SE ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 10. Scheduler: Erweiterte Funktionen und Kontexterhaltung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423967/"><img src="https://habrastorage.org/webt/m-/ag/9y/m-ag9yjhbtfwdjmljyermwi6duu.jpeg"><br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel haben</a> wir uns mit den verschiedenen vom RTOS unterst√ºtzten Planungsarten und den damit verbundenen Funktionen in Nucleus SE befasst.  In diesem Artikel werden zus√§tzliche Planungsoptionen in Nucleus SE und der Prozess zum Speichern und Wiederherstellen des Kontexts erl√§utert. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Optionale Funktionen </h2><br>  W√§hrend der Entwicklung von Nucleus SE habe ich die maximale Anzahl von Funktionen optional gemacht, was Speicher und / oder Zeit spart. <br><br><h3>  Aufgaben aussetzen </h3><br>  Wie bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel "Scheduler: Implementierung" erw√§hnt</a> , unterst√ºtzt Nucleus SE verschiedene Optionen zum Anhalten von Aufgaben. Diese Funktion ist jedoch optional und wird durch das Symbol <b>NUSE_SUSPEND_ENABLE</b> in <b>nuse_config.h enthalten</b> .  Bei <b>TRUE</b> wird die Datenstruktur als <b>NUSE_Task_Status [] definiert</b> .  Diese Art der Aussetzung gilt f√ºr alle Aufgaben.  Das Array ist vom Typ <b>U8</b> , wobei 2 Halbbytes separat verwendet werden.  Die unteren 4 Bits enthalten den Status der Aufgabe: <br>  <b>NUSE_READY, NUSE_PURE_SUSPEND</b> , <b>NUSE_SLEEP_SUSPEND</b> , <b>NUSE_MAILBOX_SUSPEND</b> usw.  Wenn eine Aufgabe durch einen API-Aufruf angehalten wird (z. B. <b>NUSE_MAILBOX_SUSPEND</b> ), enthalten die hohen 4 Bits den Index des Objekts, f√ºr das die Aufgabe angehalten wird.  Diese Informationen werden verwendet, wenn die Ressource verf√ºgbar wird. Um die API aufzurufen, m√ºssen Sie herausfinden, welche der angehaltenen Aufgaben fortgesetzt werden m√ºssen. <br><br>  Um die Task-Suspendierung durchzuf√ºhren, werden zwei Scheduler-Funktionen verwendet: <b>NUSE_Suspend_Task ()</b> und <b>NUSE_Wake_Task ()</b> . <br><br>  Der <b>NUSE_Suspend_Task () -</b> Code lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/ep/1j/gi/ep1jgiocsfdclopsjghruszeggq.png"><br><br>  Die Funktion speichert den neuen Status der Aufgabe (alle 8 Bits), der als Parameter suspend_code erhalten wird.  Wenn Sie das Sperren aktivieren (siehe "API-Aufrufe sperren" weiter unten), wird der <b>NUSE_SUCCESS-</b> R√ºckkehrcode <b>gespeichert</b> .  Als n√§chstes wird <b>NUSE_Reschedule ()</b> aufgerufen, um die Steuerung auf die n√§chste Aufgabe zu √ºbertragen. <br><br>  Der Code <b>NUSE_Wake_Task ()</b> ist recht einfach: <br><br><img src="https://habrastorage.org/webt/br/of/0p/brof0ptcaza3ovc4ykffacmkphy.png"><br><br>  Der Status der Aufgabe wird auf <b>NUSE_READY gesetzt</b> .  Wenn der Priorit√§tsplaner nicht verwendet wird, belegt die aktuelle Aufgabe weiterhin den Prozessor, bis die Zeit zum Freigeben der Ressource gekommen ist.  Wenn der Priorit√§tsplaner verwendet wird, wird <b>NUSE_Reschedule ()</b> mit dem Aufgabenindex als Hinweis auf den Abschluss aufgerufen, da die Aufgabe m√∂glicherweise eine h√∂here Priorit√§t hat und sofort ausgef√ºhrt werden muss. <br><br><h3>  API-Aufrufe sperren </h3><br>  Nucleus RTOS unterst√ºtzt eine Reihe von API-Aufrufen, mit denen ein Entwickler eine Aufgabe anhalten (blockieren) kann, wenn keine Ressourcen verf√ºgbar sind.  Die Aufgabe wird fortgesetzt, wenn wieder Ressourcen verf√ºgbar sind.  Dieser Mechanismus ist auch in Nucleus SE implementiert und gilt f√ºr eine Reihe von Kernelobjekten: Eine Aufgabe kann in einem Speicherabschnitt, in einer Ereignisgruppe, einem Postfach, einer Warteschlange, einem Kanal oder einem Semaphor gesperrt werden.  Wie die meisten Tools in Nucleus SE ist es jedoch optional und wird durch das Symbol <b>NUSE_BLOCKING_ENABLE</b> in <b>nuse_config.h definiert</b> .  Wenn <b>TRUE festgelegt ist</b> , wird das Array <b>NUSE_Task_Blocking_Return []</b> definiert, das den R√ºckkehrcode f√ºr jede Task enth√§lt.  <b>Dies</b> kann <b>NUSE_SUCCESS</b> oder der Code <b>NUSE_MAILBOX_WAS_RESET sein</b> , der angibt, dass das Objekt zur√ºckgesetzt wurde, als die Aufgabe gesperrt wurde.  Wenn die Sperre aktiviert ist, wird der entsprechende Code mithilfe der bedingten Kompilierung in die API-Funktionen aufgenommen. <br><br><h3>  Scheduler-Z√§hler </h3><br>  Nucleus RTOS berechnet, wie oft eine Aufgabe seit ihrer Erstellung und ihrem letzten Zur√ºcksetzen geplant wurde.  Diese Funktion ist auch in Nucleus SE implementiert, ist jedoch optional und wird durch das Symbol <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> in <b>nuse_config.h definiert</b> .  Bei <b>TRUE</b> wird ein Array von <b>NUSE_Task_Schedule_Count [] vom</b> Typ <b>U16 erstellt</b> , in dem der Z√§hler jeder Aufgabe in der Anwendung <b>gespeichert</b> <b>wird</b> . <br><br><h3>  Ausgangszustand der Aufgabe </h3><br>  Wenn eine Aufgabe in Nucleus RTOS erstellt wird, k√∂nnen Sie ihren Status ausw√§hlen: Bereit oder angehalten.  In Nucleus SE sind standardm√§√üig alle Aufgaben beim Start bereit.  Mit der Option, die mit dem Symbol <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> in <b>nuse_config.h ausgew√§hlt wurde,</b> k√∂nnen Sie den <b>Startstatus</b> ausw√§hlen.  Das Array <b>NUSE_Task_Initial_State []</b> ist in <b>nuse_config.c</b> definiert und erfordert die Initialisierung von <b>NUSE_READY</b> oder <b>NUSE_PURE_SUSPEND</b> f√ºr jede Aufgabe in der Anwendung. <br><br><h2>  Kontext speichern </h2><br>  Die Idee, den Kontext einer Aufgabe mit einem beliebigen Schedulertyp au√üer RTC (Run to Completion) beizubehalten, wurde in Artikel 3 ‚ÄûAufgaben und Zeitplanung‚Äú vorgestellt.  Wie bereits erw√§hnt, gibt es verschiedene M√∂glichkeiten, den Kontext aufrechtzuerhalten.  Da Nucleus SE nicht f√ºr 32-Bit-Prozessoren ausgelegt ist, habe ich mich f√ºr die Verwendung von Tabellen und nicht von Stapeln entschieden, um den Kontext aufrechtzuerhalten. <br><br>  Ein zweidimensionales Array vom <b>ADDR-</b> Typ <b>NUSE_Task_Context [] [] wird</b> verwendet, um den Kontext f√ºr alle Aufgaben in der Anwendung zu speichern.  Die Zeilen sind <b>NUSE_TASK_NUMBER</b> (die Anzahl der Aufgaben in der Anwendung), die Spalten sind <b>NUSE_REGISTERS</b> (die Anzahl der Register, die gespeichert werden m√ºssen; h√§ngt vom Prozessor ab und ist in <b>nuse_types.h festgelegt)</b> . <br><br>  Das Beibehalten des Kontexts und das Wiederherstellen von Code h√§ngt nat√ºrlich vom Prozessor ab.  Dies ist der einzige Nucleus SE-Code, der an ein bestimmtes Ger√§t (und eine bestimmte Entwicklungsumgebung) gebunden ist.  Ich werde ein Beispiel f√ºr den Speicher- / Wiederherstellungscode f√ºr den ColdFire-Prozessor geben.  Obwohl diese Auswahl aufgrund eines veralteten Prozessors seltsam erscheint, ist sein Assembler leichter zu lesen als die Assembler der meisten modernen Prozessoren.  Der Code ist einfach genug, um als Grundlage f√ºr die Erstellung eines Kontextwechsels f√ºr andere Prozessoren verwendet zu werden: <br><br><img src="https://habrastorage.org/webt/kw/gw/ct/kwgwctpm3q_igjvz2qfhmbi0awm.png"><br><br>  Wenn eine Kontextumschaltung erforderlich ist, wird dieser Code in NUSE_Context_Swap aufgerufen.  Es werden zwei Variablen verwendet: <b>NUSE_Task_Active</b> , der Index der aktuellen Aufgabe, dessen Kontext beibehalten werden muss;  <b>NUSE_Task_Next</b> , der Index der Aufgabe, deren Kontext Sie laden m√∂chten (siehe Abschnitt Globale Daten). <br><br>  Der Kontexterhaltungsprozess funktioniert wie folgt: <br><br><ul><li>  Die Register <b>A0</b> und <b>D0 werden</b> vor√ºbergehend auf dem Stapel gespeichert. </li><li>  <b>A0 ist so</b> konfiguriert, dass es auf ein Array von Kontextbl√∂cken <b>verweist. NUSE_Task_Context [] []</b> ; </li><li>  <b>D0 wird</b> mit <b>NUSE_Task_Active</b> geladen und mit 72 multipliziert (ColdFire verf√ºgt √ºber 18 Register, f√ºr deren Speicherung 72 Byte erforderlich sind). </li><li>  dann wird <b>D0</b> zu <b>A0</b> hinzugef√ºgt, das nun auf einen Kontextblock f√ºr die aktuelle Aufgabe zeigt; </li><li>  dann werden die Register im Kontextblock gespeichert;  zuerst <b>A0</b> und <b>D0</b> (vom Stapel), dann <b>D1-D7</b> und <b>A1-A6</b> , dann <b>SR</b> und <b>PC</b> (vom Stapel sehen wir uns eine schnell eingeleitete Kontextumschaltung an), und am Ende wird der Stapelzeiger gespeichert. </li></ul><br>  Der Kontextladevorgang ist dieselbe Abfolge von Aktionen in umgekehrter Reihenfolge: <br><br><ul><li>  <b>A0 ist so</b> konfiguriert, dass es auf ein Array von Kontextbl√∂cken <b>verweist. NUSE_Task_Context [] []</b> ; </li><li>  <b>D0 wird</b> mit <b>NUSE_Task_Active</b> geladen, inkrementiert und mit 72 multipliziert. </li><li>  dann wird <b>D0</b> zu <b>A0</b> hinzugef√ºgt, das nun auf den Kontextblock f√ºr die neue Aufgabe zeigt (da das Laden des Kontexts im umgekehrten Prozess des Speicherns der Sequenz erfolgen sollte, wird zuerst der Stapelzeiger ben√∂tigt); </li><li>  dann werden die Register aus dem Kontextblock wiederhergestellt;  Zuerst werden der Stapelzeiger, dann <b>PC</b> und <b>SR</b> auf den Stapel <b>geschoben</b> , dann werden <b>D1-D7</b> und <b>A1-A6</b> geladen und am Ende von <b>D0</b> und <b>A0</b> . </li></ul><br>  Die Schwierigkeit bei der Implementierung der Kontextumschaltung besteht darin, dass der Zugriff auf das Statusregister f√ºr viele Prozessoren schwierig ist (f√ºr ColdFire ist dies <b>SR</b> ).  Eine √ºbliche L√∂sung ist eine Unterbrechung, d. H. Eine Programmunterbrechung oder eine bedingte Verzweigungsunterbrechung, die bewirkt, dass der <b>SR</b> zusammen mit dem <b>PC</b> auf den Stapel geladen wird.  So funktioniert Nucleus SE unter ColdFire.  Das Makro <b>NUSE_CONTEXT_SWAP ()</b> wird in <b>nuse_types.h festgelegt</b> , das sich auf <b>Folgendes</b> erstreckt: <br>  <b>asm ("trap # 0");</b> <br><br>  Das Folgende ist der Initialisierungscode ( <b>NUSE_Init_Task ()</b> in <b>nuse_init.c</b> ) f√ºr Kontextbl√∂cke: <br><br><img src="https://habrastorage.org/webt/h7/8n/td/h78ntdz05whdi70d0pkfx-ffnok.png"><br><br>  Auf diese Weise erfolgt die Initialisierung des Stapelzeigers, des <b>PCs</b> und des <b>SR</b> .  Die ersten beiden haben vom Benutzer in <b>nuse_config.c</b> festgelegte Werte.  Der Wert von <b>SR ist</b> als das Zeichen <b>NUSE_STATUS_REGISTER</b> in <b>nuse_types.h definiert</b> .  F√ºr ColdFire ist dieser Wert <b>0x40002000</b> . <br><br><h2>  Globale Daten </h2><br>  Der Nucleus SE-Scheduler ben√∂tigt nur sehr wenig Speicher zum Speichern von Daten, verwendet jedoch nat√ºrlich Datenstrukturen, die mit Aufgaben verkn√ºpft sind. Dies wird in den folgenden Artikeln ausf√ºhrlich erl√§utert. <br><br><h3>  RAM-Daten </h3><br>  Der Scheduler verwendet die im ROM befindlichen Daten nicht und 2 bis 5 globale Variablen werden im RAM abgelegt (alle sind in <b>nuse_globals.c festgelegt</b> ), je nachdem, welcher Scheduler verwendet wird: <br><br><ul><li>  <b>NUSE_Task_Active</b> - eine Variable vom Typ <b>U8,</b> die den Index der aktuellen Aufgabe enth√§lt; </li><li>  <b>NUSE_Task_State</b> - eine Variable vom Typ <b>U8,</b> die einen Wert enth√§lt, der den Status des aktuell ausgef√ºhrten Codes angibt. <b>Dies</b> kann eine Task, ein Interrupt-Handler oder ein Startcode sein.  m√∂gliche Werte sind: <b>NUSE_TASK_CONTEXT</b> , <b>NUSE_STARTUP_CONTEXT</b> , <b>NUSE_NISR_CONTEXT</b> und <b>NUSE_MISR_CONTEXT</b> ; </li><li>  <b>NUSE_Task_Saved_State</b> - eine Variable vom Typ <b>U8,</b> die zum Schutz des Werts von <b>NUSE_Task_State</b> in einem verwalteten Interrupt verwendet wird. </li><li>  <b>NUSE_Task_Next</b> - eine Variable vom Typ <b>U8,</b> die den Index der n√§chsten Task enth√§lt, die f√ºr alle Scheduler au√üer RTC geplant werden sollte; </li><li>  <b>NUSE_Time_Slice_Ticks</b> - eine Variable vom Typ <b>U16,</b> die einen Z√§hler f√ºr <b>Zeitscheiben enth√§lt</b> ;  Wird nur mit dem TS-Scheduler verwendet. </li></ul><br><h3>  Scheduler-Daten-Footprint </h3><br>  Der Nucleus SE-Scheduler verwendet keine ROM-Daten.  Die genaue Menge der RAM-Daten h√§ngt vom verwendeten Scheduler ab: <br><br><ul><li>  f√ºr RTC - 2 Bytes ( <b>NUSE_Task_Active</b> und <b>NUSE_Task_State</b> ); </li><li>  f√ºr RR und Priorit√§t - 4 Bytes ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> und <b>NUSE_Task_Next</b> ); </li><li>  f√ºr TS - 6 Bytes ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> , <b>NUSE_Task_Next</b> und <b>NUSE_Time_Slice_Ticks</b> ). </li></ul><br><h2>  Implementierung anderer Planungsmechanismen </h2><br>  Trotz der Tatsache, dass Nucleus SE eine Auswahl von 4 Schedulern bietet, die die meisten F√§lle abdecken, k√∂nnen Sie mit der offenen Architektur M√∂glichkeiten f√ºr andere F√§lle implementieren. <br><br><h3>  Zeitscheiben mit Hintergrundaufgabe </h3><br>  Wie bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3, ‚ÄûAufgaben und Zeitplanung‚Äú beschrieben,</a> weist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> einfache Zeitscheiben-Zeitplaner Einschr√§nkungen auf, da er die maximale Zeit begrenzt, die ein Prozessor f√ºr eine Aufgabe verwenden kann.  Eine komplexere Option w√§re das Hinzuf√ºgen von Unterst√ºtzung f√ºr die Hintergrundaufgabe.  Eine solche Aufgabe kann f√ºr jeden f√ºr angehaltene Aufgaben zugewiesenen Steckplatz geplant und ausgef√ºhrt werden, wenn der Steckplatz teilweise freigegeben ist.  Mit diesem Ansatz k√∂nnen Sie Aufgaben in regelm√§√üigen Abst√§nden und mit einem vorhergesagten Prozentsatz der zu erledigenden Prozessorkernzeit planen. <br><br><h3>  Priorit√§t und Round Robin (RR) </h3><br>  In den meisten Echtzeitkernen unterst√ºtzt der Priorit√§tsplaner im Gegensatz zu Nucleus SE, bei dem jede Aufgabe eine eindeutige Ebene hat, mehrere Aufgaben auf jeder Priorit√§tsstufe.  Ich habe die letztere Option bevorzugt, da sie die Datenstrukturen und damit den Scheduler-Code erheblich vereinfacht.  Zur Unterst√ºtzung komplexerer Architekturen w√§ren zahlreiche ROM- und RAM-Tabellen erforderlich. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. <br><br>  <b>√úber die √úbersetzung:</b> Diese Artikelserie schien insofern interessant zu sein, als der Autor trotz der an einigen Stellen veralteten beschriebenen Ans√§tze den schlecht ausgebildeten Leser in die Funktionen des Echtzeit-Betriebssystems einf√ºhrt.  Ich selbst geh√∂re zu dem Team von Entwicklern des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischen RTOS</a> , das wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlos machen wollen</a> , und ich hoffe, dass der Zyklus f√ºr unerfahrene Entwickler n√ºtzlich sein wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423967/">https://habr.com/ru/post/de423967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423957/index.html">Generierung von User Space-Verkehr</a></li>
<li><a href="../de423959/index.html">Unterwassergeh√§use - F√ºr Roboter</a></li>
<li><a href="../de423961/index.html">Verlieren Sie sich nicht: eine neue Methode zur Diagnose von Demenz</a></li>
<li><a href="../de423963/index.html">Kelvin Point Prolog</a></li>
<li><a href="../de423965/index.html">Sie haben SIEM gekauft und sind sich sicher, dass SOC in Ihrer Tasche ist, oder?</a></li>
<li><a href="../de423971/index.html">Skillbox Friday Webinare: F√ºr Entwickler von Entwicklern</a></li>
<li><a href="../de423973/index.html">Die Sch√∂pfer des Mirai-Botnetzes bek√§mpfen jetzt das Verbrechen auf FBI-Seite</a></li>
<li><a href="../de423977/index.html">Treffen mit DevOps Deflope auf der DevOpsConf 2018</a></li>
<li><a href="../de423979/index.html">UK Healtharker Aging Biomarker Panel</a></li>
<li><a href="../de423981/index.html">DDIA-Buch (Buch mit einem Schwein) - verbessern Sie das Verst√§ndnis von Datenbanken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>