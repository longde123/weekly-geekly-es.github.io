<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚋 👓 🖐🏿 第0部分。需要一个elf在Matrix中工作。 可以搬迁 🚵🏾 👎🏻 ⏱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意：包含系统编程。 是的，实质上，它不包含任何其他内容。 


假设您被赋予编写幻想游戏的任务。 好吧，关于精灵。 关于虚拟现实。 从小开始，您就梦想着写这样的东西，并且毫不犹豫地同意。 很快，您就会意识到，您已经从古老的bashorgh和其他不同来源的笑话中了解了大多数精灵。 糟糕，是个问题。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>第0部分。需要一个elf在Matrix中工作。 可以搬迁</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452592/"><p>  <strong>注意：包含系统编程。</strong>  <strong>是的，实质上，它不包含任何其他内容。</strong> </p><br><p>假设您被赋予编写幻想游戏的任务。 好吧，关于精灵。 关于虚拟现实。 从小开始，您就梦想着写这样的东西，并且毫不犹豫地同意。 很快，您就会意识到，您已经从古老的bashorgh和其他不同来源的笑话中了解了大多数精灵。  <em>糟糕，是个问题。</em> 好吧，我们的生活并没有消失……凭借丰富的编程经验，您可以去Google，输入“ Elf规范”，然后点击链接。 喔！ 这导致了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">某种PDF</a> ...因此我们在这里拥有了... <code>Elf32_Sword</code>精灵之剑-看起来像您所需要的。  32显然是角色的等级，并且以下各列中的四个四分之一可能是损坏的。 正是您需要的，以及系统化的方式！ </p><a name="habracut"></a><br><p> 正如在一项奥运会编程任务中所述，在有关日本，武士和艺妓的主题的详细文本的几段之后：“正如您已经了解的那样，该任务根本不会与之有关。” 哦，是的，比赛当然是有一段时间了。 总的来说，我宣布坚持5分钟。 </p><br><p> 今天，我将尝试讨论解析64位<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ELF</a>格式的文件。 原则上，它们只是不存储在其中，它们是本机程序，静态库，动态库，特定于实现的所有内容，例如崩溃转储...例如，在Linux和许多其他类似Unix的系统上使用它们，是的，他们说，甚至在电话上也是如此。以前，它的支持被积极地填充到修补的固件中。 似乎很难支持用于存储来自严重操作系统的程序的格式。 所以我想。 是的，可能是。 但是我们将支持一个非常特定的用例：从<code>.o</code>文件中加载eBPF字节码。 为什么这样 只是为了进行进一步的实验，我需要一些严肃的（即不是<em>膝盖高的</em> ）跨平台字节码，可以从C获取而不是手​​动编写，因此eBPF很简单，并且有一个LLVM后端。 我只需要将ELF解析为编译器将此字节码放入其中的容器。 </p><br><p> 为了以防万一，我将澄清一下：该文章是探索性编程，并不声称是详尽的指南。 最终目标是制作一个引导加载程序，使您可以阅读使用Clang（我拥有的Clang）在eBPF中编译的C程序，其数量足以继续进行实验。 </p><br><h1 id="zagolovok"> 标题 </h1><br><p> 标头位于ELF的零偏移处。 它包含字母E，L，F，如果您尝试使用文本编辑器打开它，可以看到它们，以及一些全局变量。 实际上，标头是文件中位于固定偏移量处的唯一结构，并且它包含查找结构其余部分的信息。  <em>（此后，我受32位格式文档<code>elf.h</code>和<code>elf.h</code>了解，他们了解64位。因此，如果您发现错误，请随时进行纠正）</em> </p><br><p> 在文件中遇到的第一件事是<code>unsigned char e_ident[16]</code> 。 还记得“以下所有陈述都是错误的”系列中的这些有趣的文章吗？ 两者大致相同：ELF可以包含32位或64位代码，Little Endian或Big Endian，甚至是十几种处理器体系结构。 您将在Little endian下将其阅读为Elf64-好吧，祝您好运...这个字节数组是内部内容以及如何解析它的一种签名。 </p><br><p> 对于前四个字节，一切都很简单-它是<code>[0x7f, 'E', 'L', 'F']</code> 。 如果它们不匹配，则有理由相信它们是某种错误的蜜蜂。 下一个字节包含类 <del> 性格 </del> 文件： <code>ELFCLASS32</code>或<code>ELFCLASS64</code>位深度。 为简单起见，我们仅处理64位文件（是否有32位eBPF？）。 如果该类最终是<code>ELFCLASS32</code> ，我们将简单地退出并返回一个错误：都一样，结构将“浮动”，并且进行健全性检查不会有任何伤害。 在此结构中，我们感兴趣的最后一个字节指示文件的字节序-我们将仅使用处理器的本机字节顺序。 </p><br><p> 为了以防万一，我将澄清一下：在C语言中使用ELF格式时，您不应该通过巧妙地计算出的偏移量减去每个int- <code>elf.h</code>包含必要的结构，甚至在<code>e_ident</code>包含字节数： <code>EI_MAG0</code> ， <code>EI_MAG1</code> ， <code>EI_MAG2</code> ， <code>EI_MAG3</code> ， <code>EI_CLASS</code> ， <code>EI_DATA</code> ...指向从文件读取或映射到内存的数据的指针，从文件到指向结构的指针并读取。 </p><br><p> 除了<code>e_ident</code>标头还包含其他字段，我们将仅检查其中一些字段，而某些字段将用于进一步分析，但稍后。 即，我们检查<code>e_machine == EM_BPF</code> （也就是说，它是“在eBPF处理器的体系结构之下”）， <code>e_type == ET_REL</code> ， <code>e_shoff != 0</code> 。 最后的检查具有以下含义：文件可以包含用于链接（节表和节），启动（程序表和段）或两者的信息。 经过最后两次检查，我们确认文件中需要我们所需要的信息（好像用于链接）。 还要检查格式的版本是否为<code>EV_CURRENT</code> 。 </p><br><p>  <strong>立即进行预订，假设我们将其加载到进程中，那么我们将不信任该文件的有效性。</strong> 在处理不受信任文件的内核或其他程序的代码中，自然<strong>不可能在任何情况下都这样做</strong> 。 </p><br><h1 id="tablica-sekciy"> 截面表 </h1><br><p> 如我所说，我们对文件的链接视图（即节表和节本身）感兴趣。 标头中包含有关在何处查找节表的信息。 它的大小以及<strong>一个元素</strong>的<strong>大小</strong>也都在<code>sizeof(Elf64_Shdr)</code> -它可以大于<code>sizeof(Elf64_Shdr)</code> （因为它影响格式的版本号，老实说，我不知道）。 一些主要的节号是保留的，实际上不在表中。 引用它们具有特殊含义。 显然，我们只对<code>SHN_UNDEF</code>感兴趣（零也保留-缺少的部分；顺便说一句，如您所知，表中的标题仍然存在） <code>SHN_ABS</code> 。 字符“在<code>SHN_UNDEF</code>部分中定义”实际上是未定义的，而在<code>SHN_ABS</code>它实际上具有绝对值并且不会重定位。 但是，似乎也不<code>SHN_ABS</code> 。 </p><br><h2 id="tablica-strok"> 行表 </h2><br><p> 在这里，我们第一次遇到字符串表-文件中使用的字符串表。 实际上，如果<code>const char *strtab</code>是一个字符串表，则名称<code>sh_name</code>只是<code>strtab + sh_name</code> 。 是的，它只是一行，从某个索引开始，一直到零字节。 线可能相交（更确切地说，一条可能是另一条的后缀）。 节可以有名称，然后在ELF标题中， <code>e_shstrndx</code>字段将指向行表的节（如果有多个，则为节名称），节标题中的<code>sh_name</code>字段指向特定行。 </p><br><p> 行表的第一个（零）和最后一个字节包含空字符。 后者是可以理解的原因：价值小时，结束最后一行。 但是零偏移量指定了一个<em>不存在</em>或为<em>空的</em>名称-取决于上下文。 </p><br><h2 id="zagruzka-sekciy"> 载入部分 </h2><br><p> 每个节的标头中都有两个地址：一个， <code>sh_addr</code>是加载地址（该节将放置在内存中），另一个， <code>sh_offset</code>是此节所在文件的偏移量。 我不知道这两个值是多少，但是每个值都可以分别为0：在一种情况下，“保留在磁盘上”部分是因为存在某种服务信息。 在另一部分中，该部分<em>未从磁盘加载</em> ，例如，您只需要选择该部分并用零（ <code>.bss</code> ）对其打分即可。 老实说，虽然我不必处理下载地址-上传地址，但上传地址是:)但是，坦率地说，我们也有特定的程序。 </p><br><h1 id="relokaciya"> 搬迁 </h1><br><p> 现在有趣的事情是：根据安全措施，如您所知，如果没有操作员留在基地，它们就不会进入矩阵。 由于这里我们仍然有幻想，因此与运营商的联系将是心灵感应。 哦，是的，我宣布了五分钟的坚韧期。 通常，我们将简要讨论链接过程。 </p><br><p> 对于我的实验，我需要将一段代码编译成一个常规的so-boot，并用常规的<code>libdl</code>加载。 在这里，我什至不详细介绍-只是打开<code>dlopen</code> ，通过<code>dlsym</code>提取字符，在程序<code>dlclose</code>时用<code>dlclose</code>将其关闭。 但是，即使这些是与<em>我们的</em> ELF文件加载器都不相关的实现细节。 仅存在一些<em>上下文</em> ：按名称获取指针的能力。 </p><br><p> 通常，eBPF指令集是对齐的机器代码的胜利：一条指令始终占用8个字节，并具有一个结构 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p> 此外，可能不会使用每个特定指令中的许多字段-为“机器”代码节省空间与我们无关。 </p><br><p> 实际上，第一条指令可以紧跟第二条指令，第二条指令不包含任何操作码，而只是将立即数字段从32位扩展到64位。 这是称为<code>R_BPF_64_64</code>的复合指令的<code>R_BPF_64_64</code> 。 </p><br><p> 为了执行重定位，我们将再次查看<code>sh_type == SHT_REL</code>的节表。 标头的<code>sh_link</code>字段将指示我们正在修补的部分，以及<code>sh_link</code>从哪个表获取字符的描述。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Elf64_Addr r_offset; Elf64_Xword r_info; } Elf64_Rel;</code> </pre> <br><p> 实际上，有两种类型的重定位部分： <code>REL</code>和<code>RELA</code>第二部分显式包含一个附加术语，但是我还没有看到它，因此我们仅对断言不符合这一事实添加断言，然后对其进行处理。 接下来，我将在指令中写入的值添加符号的地址。 在哪里得到呢？ 正如我们已经知道的，在这里可以选择： </p><br><ul><li> 该符号指的是<code>SHN_ABS</code>部分。 然后就取<code>st_value</code> </li><li> 字符指的是`SHN_UNDEF部分。 然后拉外线符号 </li><li> 在其他情况下，只需将链接修补到同一文件的另一部分即可。 </li></ul><br><h1 id="kak-poprobovat-samomu"> 如何自己尝试 </h1><br><p> 首先，要读什么？ 除了已经指定的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范外，</a>读取<a href="">该文件</a>也是有意义的，iovisor团队在其中收集了通过eBPF从Linux内核提取的信息。 </p><br><p> 其次，实际上每个人应该如何处理？ 首先，您需要从某处获取ELF文件。 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StackOverfow</a>所述，团队将为我们提供帮助。 </p><br><pre> <code class="bash hljs">clang -O2 -emit-llvm -c bpf.c -o - | llc -march=bpf -filetype=obj -o bpf.o</code> </pre> <br><p> 其次，您需要以某种方式对文件进行参考分析。 在正常情况下， <code>objdump</code>命令将帮助我们： </p><br><pre> <code class="plaintext hljs">$ objdump : objdump &lt;&gt; &lt;()&gt;     &lt;()&gt;.          : -a, --archive-headers Display archive header information -f, --file-headers Display the contents of the overall file header -p, --private-headers Display object format specific file header contents -P, --private=OPT,OPT... Display object format specific contents -h, --[section-]headers Display the contents of the section headers -x, --all-headers Display the contents of all headers -d, --disassemble Display assembler contents of executable sections -D, --disassemble-all Display assembler contents of all sections --disassemble=&lt;sym&gt; Display assembler contents from &lt;sym&gt; -S, --source Intermix source code with disassembly -s, --full-contents Display the full contents of all sections requested -g, --debugging Display debug information in object file -e, --debugging-tags Display debug information using ctags style -G, --stabs Display (in raw form) any STABS info in the file -W[lLiaprmfFsoRtUuTgAckK] or --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames, =frames-interp,=str,=loc,=Ranges,=pubtypes, =gdb_index,=trace_info,=trace_abbrev,=trace_aranges, =addr,=cu_index,=links,=follow-links] Display DWARF info in the file -t, --syms Display the contents of the symbol table(s) -T, --dynamic-syms Display the contents of the dynamic symbol table -r, --reloc Display the relocation entries in the file -R, --dynamic-reloc Display the dynamic relocation entries in the file @&lt;file&gt; Read options from &lt;file&gt; -v, --version Display this program's version number -i, --info List object formats and architectures supported -H, --help Display this information</code> </pre> <br><p> 但是在这种情况下，它是无能为力的： </p><br><pre> <code class="plaintext hljs">$ objdump -d test-bpf.o test-bpf.o:   elf64-little objdump:      UNKNOWN!</code> </pre> <br><p> 更确切地说，它将显示各个部分，但是拆卸是个问题。 在这里，我们回想起使用LLVM收集的内容。  LLVM具有来自binutils的实用程序扩展类，其名称形式为<code>llvm-&lt; &gt;</code> 。 例如，他们了解LLVM位代码。 而且他们也了解eBPF-可以肯定的是，它取决于编译选项，但是由于它已经编译，因此应该始终对其进行解析。 因此，为方便起见，我建议创建一个脚本： </p><br><pre> <code class="bash hljs">vim <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-bpf.c <span class="hljs-comment"><span class="hljs-comment">#     clang -Oz -emit-llvm -c test-bpf.c -o - | llc -march=bpf -filetype=obj -o test-bpf.o llvm-objdump -d -t -r test-bpf.o</span></span></code> </pre> <br><p> 然后对于这样的来源： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint64_t z; uint64_t func(uint64_t x, uint64_t y) { return x + y + z; }</span></span></span></span></code> </pre> <br><p> 会有这样的结果： </p><br><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 func: 0: bf 20 00 00 00 00 00 00 r0 = r2 1: 0f 10 00 00 00 00 00 00 r0 += r1 2: 18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r1 = 0 ll 0000000000000010: R_BPF_64_64 z 4: 79 11 00 00 00 00 00 00 r1 = *(u64 *)(r1 + 0) 5: 0f 10 00 00 00 00 00 00 r0 += r1 6: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 g F .text 00000038 func 0000000000000000 *UND* 00000000 z</code> </pre> <br><p>  <a href="">代号</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分。QInst：最好先输掉一天，然后在五分钟内飞起来（编写文书非常琐碎）</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452592/">https://habr.com/ru/post/zh-CN452592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452576/index.html">关于IT内向的人</a></li>
<li><a href="../zh-CN452580/index.html">20个项目，20种语言，截止日期为昨天。 第三部分</a></li>
<li><a href="../zh-CN452584/index.html">程序员对Unix时间的误解</a></li>
<li><a href="../zh-CN452586/index.html">如何在Adobe Illustrator中开始编程。 第一部分</a></li>
<li><a href="../zh-CN452590/index.html">美国人为低预算3D打印学校的孩子们创建了一个移动教室，该项目已经收集了超过100,000个</a></li>
<li><a href="../zh-CN452596/index.html">从一个骗子那里获得了735,000个IPv4地址，并将其返回注册表</a></li>
<li><a href="../zh-CN452598/index.html">程序员团队的管理：如何以及如何正确激励他们？ 第一部分</a></li>
<li><a href="../zh-CN452602/index.html">适用于高负载数据库管理系统的Cisco Hyperflex</a></li>
<li><a href="../zh-CN452606/index.html">UDB。 这是什么 第8部分。处理UDB</a></li>
<li><a href="../zh-CN452608/index.html">第1部分。QInst：最好先输掉一天，然后在五分钟内飞起来（编写文书非常琐碎）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>