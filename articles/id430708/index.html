<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐕 💇🏿 🤘🏻 Tic Tac Toe “Tanpa Batas” 🤾 🧑🏽‍🤝‍🧑🏼 📼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tic-tac-toe ... semua orang memainkannya, saya yakin. Permainan ini menarik dalam kesederhanaannya, terutama ketika Anda menyeret jam di suatu tempat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tic Tac Toe “Tanpa Batas”</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/">  Tic-tac-toe ... semua orang memainkannya, saya yakin.  Permainan ini menarik dalam kesederhanaannya, terutama ketika Anda menyeret jam di suatu tempat dalam pelajaran, pasangan, dan tidak ada yang ada di sana kecuali lembar notebook dan pensil sederhana.  Saya tidak tahu siapa yang pertama kali menebak menggambar salib dan lingkaran dalam 9 kotak, tetapi sejak itu permainan tidak kehilangan permintaan, terutama karena orang-orang telah datang dengan banyak variasi. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  Artikel ini adalah tentang proses pengembangan AI pada javascript untuk memainkan salah satu variasi tic-tac-toe ini: Saya punya banyak materi, tapi saya melarutkannya dengan animasi dan gambar.  Bagaimanapun, setidaknya ada baiknya mencoba memainkannya. <br>  Perbedaan antara versi gim ini dan yang asli adalah sebagai berikut: <br><br><ol><li>  <b>Bidang</b> dapat menjadi <b>besar secara</b> sewenang-wenang (Berapa lama notebook akan bertahan) </li><li>  Pemenangnya adalah orang yang menempatkan <b>5 buah</b> (jika Anda bisa menyebutnya begitu) berturut-turut. </li></ol><br>  Semuanya sederhana ... dan pada saat yang sama rumit: hasil permainan tidak dapat dihitung sebelumnya, seperti pada analog klasik.  "Proyeksi kecil" ini menghilangkan banyak waktu dan saraf saya.  Semoga Anda menemukan itu menarik. <a name="habracut"></a><br><br><h3>  Sebelum kita mulai </h3><br>  Terpaksa untuk meminta maaf sebelumnya atas volume artikel dan di beberapa tempat presentasi pemikiran yang tidak cukup masuk akal, bagaimanapun, saya tidak bisa memeras kawanan tanpa kehilangan konten dan kualitas. <br>  Saya sarankan Anda membiasakan diri dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hasilnya</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Tombol cepat dan perintah: <br><br><ul><li>  <b>D</b> - AI akan bergerak untuk Anda </li><li>  <b>T</b> - lihat berat sel </li><li>  Tulis <b>SHOW_WEIGHTS = true</b> di konsol untuk melihat bobot semua sel yang dianalisis. </li></ul><br><h3>  Mari kita mulai </h3><br>  Anda harus mulai dengan implementasi game itu sendiri, mis.  menulis aplikasi untuk dua pemain, sejauh ini tanpa bot.  Untuk tujuan saya, saya memutuskan untuk menggunakan javascript + jquery + bootstrap4, meskipun secara praktis tidak digunakan di sana, tetapi lebih baik meninggalkannya - atau tabel akan mengambang.  Tidak ada yang istimewa untuk diceritakan, ada banyak materi tentang js, jquery dan bootstrap.  Saya hanya bisa mengatakan bahwa saya menggunakan MVC.  Bagaimanapun, saya tidak akan menjelaskan sepenuhnya semua kode - sudah ada banyak materi. <br><br>  Jadi, lapangan sudah siap.  Anda bisa mengatur bentuk dalam sel.  Tapi kemenangan salah satu pemain itu tidak pasti. <br><br><h3>  Akhir pemindaian game </h3><br>  Permainan berakhir ketika salah satu pemain menempatkan <b>5 buah</b> berturut-turut.  "Sederhana!"  Saya pikir.  Dan dia mulai memindai sepenuhnya semua sel lapangan: pertama semua horizontal, lalu vertikal, dan akhirnya diagonal. <br><br>  Ini cara yang bodoh, tetapi berhasil.  Namun, itu bisa ditingkatkan secara signifikan, yang saya lakukan: Sebagian besar sel akan tetap kosong sepanjang permainan - lapangan bermain terlalu besar untuk diisi seluruhnya.  Karena itu perlu untuk memindai setiap gerakan, dan hanya satu bagian ditempatkan dalam satu gerakan - Anda hanya dapat fokus pada bagian ini (sel): memindai hanya satu horisontal, vertikal dan dua diagonal sel yang memiliki sel yang sama. <br><br>  Plus, Anda tidak perlu memindai semua garis sel.  Karena akhir permainan adalah 5 buah berturut-turut, potongan-potongan yang 6 sel terpisah satu sama lain tidak menarik bagi kami.  Cukup dengan memindai lima sel di setiap sisi.  Tidak mengerti  Lihat animasi di bawah ini. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Lihat kode</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Mari kita turun ke bot itu sendiri </h3><br>  Jadi, kami sudah menulis halaman dengan tic-tac-toe.  Kami lolos ke tugas utama - AI. <br>  Anda tidak bisa hanya mengambil dan menulis kode jika Anda tidak tahu caranya: Anda perlu memikirkan logika bot. <br><br>  Intinya adalah untuk menganalisis lapangan bermain, setidaknya sebagian darinya, dan menghitung <b>harga (berat)</b> setiap sel di lapangan.  Sel dengan berat tertinggi - yang paling menjanjikan - bot akan meletakkan angka di sana.  Kesulitan utama adalah dalam menghitung berat satu sel. <br><br><h3>  Terminologi </h3><br>  <b>Persilangan dan jari kaki</b> adalah angka. <br>  <b>Sebuah serangan</b> akan disebut beberapa tokoh identik yang berdiri berdampingan di garis yang sama.  Sebenarnya, ini banyak.  Jumlah bagian dalam serangan adalah <b>kekuatannya</b> .  Satu bagian yang terpisah juga merupakan serangan (kekuatan 1). <br><br>  Pada sel serangan yang berdekatan (di ujung) mungkin ada sel kosong atau potongan musuh.  Adalah logis untuk berpikir bahwa serangan dengan dua sel kosong di "ujung" dapat dikembangkan dalam dua arah, yang membuatnya lebih menjanjikan.  Jumlah sel kosong di "ujung" serangan akan disebut <b>potensinya</b> .  Potensinya bisa 0, 1 atau 2. <br>  Kami menyatakan serangan sebagai berikut: <b>[kekuatan serangan, potensial]</b> .  Misalnya, <b>serangan [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Gambar 1. Serang [4: 1]</i> <br><br>  Dalam proses analisis, kami akan mengevaluasi semua sel yang memasuki area tertentu.  Setiap sel akan menghitung <b>beratnya</b> .  Itu dihitung berdasarkan bobot semua serangan yang mempengaruhi sel ini. <br><br><h3>  Esensi dari analisis </h3><br>  Bayangkan di lapangan bermain sudah ada beberapa serangan pemain satu dan yang kedua.  Salah satu pemain bergerak (biarkan umpan silang).  Secara alami, ia pindah ke sel kosong - dan dengan demikian ia dapat: <br><br><ol><li>  Kembangkan serangan Anda, dan mungkin lebih dari satu, tingkatkan kekuatannya.  Dapat meluncurkan serangan baru, dll. </li><li>  Cegah pengembangan serangan musuh atau blokir sepenuhnya. </li></ol><br>  Artinya, protagonis kita dapat menyerang dan bertahan.  Atau mungkin sekaligus sekaligus.  Baginya, yang pertama dan yang kedua adalah penting. <br><br>  Inti dari analisis adalah sebagai berikut: <br><br><ol><li>  Bot menggantikan angka-angka di sel yang diperiksa: pertama sebuah salib, lalu nol. </li><li>  Kemudian dia mencari semua serangan yang diterima oleh gerakan seperti itu dan merangkum bobotnya. </li><li>  Jumlah yang diterima adalah berat sel. </li><li>  Algoritma serupa dilakukan untuk semua sel bidang bermain. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  Faktanya, kami memeriksa dengan algoritme seperti apa yang akan terjadi jika kami pergi dengan cara ini ... dan apa yang akan terjadi jika lawan seperti itu.  Kami menantikan satu langkah dan memilih sel yang paling cocok - dengan bobot tertinggi. <br><br>  Jika sebuah sel memiliki bobot lebih dari yang lain, maka itu mengarah pada penciptaan serangan yang lebih berbahaya, atau untuk memblokir serangan musuh yang kuat.  Semuanya logis ... menurut saya. <br>  Jika Anda pergi ke halaman dan menulis di konsol SHOW_WEIGHTS = true, Anda dapat secara visual merasakan operasi algoritma (Bobot sel akan ditampilkan). <br><br><h3>  Berat Serangan </h3><br>  Saya memeriksa otak saya dan membawa korespondensi serangan dan beban: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Dipilih secara empiris - mungkin ini bukan pilihan terbaik. <br><br>  Saya menambahkan kekuatan serangan 5 dengan bobot yang sangat besar ke array.  Hal ini dapat dijelaskan oleh fakta bahwa bot menganalisis permainan, melihat langkah maju (menggantikan sosok di dalam sel).  Melewati serangan seperti itu hanyalah kekalahan.  Ya, atau kemenangan ... tergantung siapa. <br><br>  Serangan dengan potensi tinggi dihargai lebih tinggi. <br><br>  Serang [4: 2] dalam banyak kasus menentukan hasil pertandingan.  Jika pemain berhasil membuat serangan seperti itu, maka lawan tidak akan lagi dapat memblokirnya.  Namun, ini bukan kemenangan.  Musuh dapat menyelesaikan permainan lebih cepat, bahkan jika kita memiliki serangan [4: 2] di lapangan, jadi bobotnya lebih rendah daripada serangan dengan kekuatan 5. Lihat contoh di bawah ini. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Gambar 2. Serang [4: 2]</i> <br><br><h3>  Serangan Robek </h3><br>  Kode tidak disajikan dalam paragraf ini.  Di sini kami memperkenalkan konsep pembagi serangan dan menjelaskan esensi dari <b>"serangan robek"</b> . <br><br>  Pertimbangkan situasi berikut: ketika mengganti gambar untuk menghilangkan beberapa sel kosong, tetapi tidak lebih dari 5, satu lagi terletak. <br><br>  Dan, tampaknya, dua tokoh yang identik, pada baris yang sama ... secara visual terlihat seperti serangan, tetapi kenyataannya tidak.  Bukan perintah, karena serangan "sobek" seperti itu juga membawa potensi ancaman. <br><br>  Khusus untuk kasus seperti itu, untuk setiap serangan kami akan menghitung pembagi.  Awalnya, nilainya 1. <br><br><ol><li>  Kami menghadirkan serangan "sobek" sebagai beberapa serangan biasa </li><li>  Kami menghitung jumlah sel kosong antara serangan pusat dan samping </li><li>  Untuk setiap sel kosong, pembagi akan bertambah 1 </li><li>  Kami menghitung berat serangan pusat seperti biasa, berat serangan samping - dibagi dengan pembagi </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Gambar 3. Analisis "Serangan robek".</i>  <i>Sel dengan palang kuning dipindai.</i> <br><br>  Dengan demikian, serangan yang terkoyak juga akan diperhitungkan oleh AI.  Sebenarnya, ini akan menjadi serangan biasa, tetapi semakin jauh mereka dari sel yang dipindai, semakin sedikit pengaruh yang dimilikinya terhadapnya, dan karenanya, mereka memiliki berat yang lebih sedikit (terima kasih kepada pembagi). <br><br><h3>  Algoritma Pencarian Serangan </h3><br>  Pertama, buat <b>kelas</b> serangan.  Serangan itu akan memiliki 3 atribut, yang saya tulis sebelumnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  Dan satu <b>metode</b> yang akan mengembalikan bobot serangan yang diberikan: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Selanjutnya  Kami akan membagi pencarian untuk semua serangan untuk satu sel menjadi: <br><br><ol><li>  Pencarian Horisontal </li><li>  Pencarian vertikal </li><li>  Pencarian diagonal 45 derajat </li><li>  Pencarian diagonal 135 derajat </li></ol><br>  Semua ini adalah <b>garis</b> , dan algoritma untuk mencari serangan pada garis ini dapat digeneralisasi: <b>kelas checkLine</b> . <br><br>  Namun, kami tidak perlu memeriksa seluruh baris.  Kekuatan serangan maksimum yang menarik minat kita adalah 5. Tentu saja, dimungkinkan untuk membuat serangan dengan kekuatan, katakanlah, 6.  Tetapi untuk AI yang menganalisis situasi permainan dari langkah selanjutnya, itu sama dengan 6 atau 5. Prospek mendapatkan salah satu dari serangan ini menunjukkan akhir dari permainan di langkah berikutnya.  Dengan demikian, berat sel yang dianalisis akan sama dalam kedua kasus. <br><br>  Atribut kelas: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "×"; //     .    «0» - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  Penting untuk berhenti di sini, karena pertanyaan mungkin muncul: mengapa memeriksa sel ke-6 jika kekuatan serangan maksimum adalah 5. Jawabannya adalah untuk menentukan potensi jarak jauh dari pusat serangan. <br><br>  Berikut ini sebuah contoh: serangan dengan kekuatan 1 pada gambar terletak di perbatasan area yang dipindai.  Untuk mengetahui potensi serangan ini, Anda perlu "mencari ke luar negeri." <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Fig.</i>  <i>3. Memindai sel ke-6.</i>  <i>Jika Anda tidak memindai sel ke-6, Anda dapat salah menentukan potensi serangan.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  Mungkin tidak ada cukup ruang untuk menyelesaikan beberapa serangan.  Setelah menghitung tempat penyerangan, kita dapat memahami sebelumnya serangan mana yang tidak menjanjikan. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Fig.</i>  <i>4. Tempat untuk menyerang</i> <br><br>  Algoritma adalah sebagai berikut: <br><br>  1) Mari kita mulai dengan sel pusat.  Itu harus kosong (kita akan bergerak ke dalamnya, kan? Tapi kita tidak lupa bahwa AI kita harus mengganti angka dalam sel ini untuk analisis langkah selanjutnya. Angka yang kita gantikan adalah ini. <b>Subfig</b> - defaultnya adalah salib. Karena sel pusat awalnya akan berisi beberapa bentuk setelah substitusi, itu akan menjadi milik beberapa serangan ini. <br><br><ul><li>  kekuatannya tidak kurang dari 1 (angka di sel pusat) </li><li>  divider - 1, karena  itu adalah serangan pusat (itu milik sel yang dipindai); </li><li>  potensi belum diketahui - standarnya adalah 0; </li></ul><br><br>  Kami menampilkan semua titik ini dalam nilai konstruktor default - lihat kode di atas. <br><br>  2) Selanjutnya, mengurangi iterator, mengulangi lebih dari 5 sel di satu sisi yang dipindai.  Fungsi <b>getAttacks (cellX, cellY, subFig, dx, dy)</b> bertanggung jawab untuk ini, di mana: <br><br>  <b>cellX, cellY</b> - koordinat dari sel yang diperiksa <br>  <b>subFig</b> - gambar yang kami gantikan dalam sel yang diperiksa <br>  <b>dx, dy</b> - perubahan dalam koordinat x dan y dalam siklus - ini adalah bagaimana kami menetapkan arah pencarian: <br><br><ul><li>  Horisontal (dx = 1, dy = 0) </li><li>  Vertikal (dx = 0, dy = 1) </li><li>  Diagonal 45 (dx = 1, dy = -1) </li><li>  Diagonal 135 (dx = 1, dy = 1) </li></ul><br>  Dalam arti tertentu, ini adalah paralel vektor ke baris pencarian.  Dengan demikian, satu fungsi akan dapat mencari dalam 4 arah dan kami tidak akan melanggar prinsip KERING sekali lagi. <br><br>  Kode fungsi: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  –  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Harap dicatat bahwa jika checkCell () mengembalikan sesuatu, maka loop berhenti. <br><br>  3) Kami memeriksa angka sel-sel ini. <br>  Fungsi <b>checkCell (x, y)</b> bertanggung jawab untuk ini: <br><br>  Pertama, tulis bentuk ke variabel <b>ara</b> : <br>  <b>Model.Field</b> adalah lapangan bermain kami. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>ara</b> dapat berupa 'x', 'o', 'b' (perbatasan), 0 (sel kosong). <br><br><ul><li>  Jika angka seperti itu bertepatan dengan angka sel pusat ( <b>this.subFig</b> ), maka kami melanjutkan algoritme - maka kami terus memindai serangan, semuanya baik-baik saja, kami melanjutkan dengan semangat yang sama.  Bagian tambahan dalam serangan adalah nilai tambah untuk kekuatannya ( <b>this.curAttack.capability</b> ) dan tempat ( <b>this.attackplace</b> ). <br><br>  (Lihat kode pada paragraf berikutnya) </li><li>  Jika ini adalah angka yang berbeda, maka serangan yang kami pindai sebelumnya (this.curAttack) diblokir dari sisi ini.  Kami tidak mengubah apa pun di parameter serangan, menulisnya ke array serangan dan keluar dari loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'○'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'×'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  Jika tidak ada sel seperti itu, itu berarti mereka jatuh dari batas lapangan, yang berarti serangan diblokir.  Kami menulisnya ke dalam array semua serangan dan keluar dari loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  Jika Anda menangkap sangkar kosong, itu berarti serangan saat ini sudah berakhir atau kami sedang menghadapi "serangan sobek."  Ditambah potensi dan tempat untuk menyerang (karena serangan tidak terhalang).  Namun, kami tidak keluar dari loop - mungkin ini adalah "serangan robek" - kami hanya menulis ini.curAttack ke array semua serangan dari baris ini. Serangan [].  Buat serangan "saat ini" baru dan tingkatkan pembagi sebesar 1 (ini adalah serangan samping). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) Jika pada sel ke 5 angkanya bertepatan dengan sel pusat, maka serangan "beristirahat" terhadap perbatasan dan untuk menentukan potensi serangan Anda harus "memeriksa perbatasan" ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  Fungsi <b>checkCell</b> sudah siap.  Namun, kami terus bekerja pada kelas <b>checkLine</b> . <br><br>  5) Setelah menyelesaikan siklus pertama, Anda perlu "berbalik."  Kami menerjemahkan iterator ke pusat dan serangan pusat, dengan indeks 0, menghapusnya dari susunan serangan dan menetapkannya sebagai serangan saat ini. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) Selanjutnya, pergi ke sisi lain dari sel saat ini, meningkatkan iterator. <br>  Benar-benar cek angka yang sama.  (Kode sudah ditulis - fungsi <b>getAttacks</b> ) <br><br>  7) Semuanya, kami mengumpulkan semua serangan yang ada di baris dalam satu array. <br>  Itu saja dengan kelas <b>checkLine ...</b> semuanya dilakukan. <br><br>  Nah, maka semuanya sederhana - buat objek <b>checkLine</b> untuk masing-masing garis (2 diagonal, horizontal dan vertikal) dan panggil fungsi <b>getAttacks</b> .  Yaitu, untuk setiap baris - objek <b>checkLine</b> sendiri dan, karenanya, set serangannya sendiri. <br><br>  Biarkan fungsi <b>getAllAttacks ()</b> bertanggung jawab untuk semua ini - sudah terpisah dari kelas yang dijelaskan di atas; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '×', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '×', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '×', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '×', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '○', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '○', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '○', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '○', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  Pada output, kami memiliki objek dengan semua serangan untuk sel yang diuji <br><br>  Namun, Anda mungkin telah memperhatikan semacam fungsi filter.  Tugasnya adalah untuk menyaring serangan "sia-sia": <br><br><ul><li>  Dengan nol daya (Anda tidak pernah tahu apakah mereka masuk ke array) </li><li>  Serangan yang kekurangan ruang (tempat serangan &lt;5) </li><li>  Dengan nol potensi. </li></ul><br>  Namun, jika serangan memiliki kekuatan lebih besar dari 5, maka filter akan melewatinya.  Bot harus melihat serangan seperti itu, skrining mereka akan mengarah ke tiang tembok di akhir pertandingan. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Breakpoints </h3><br>  Ya ... lagi, maaf!  Jadi kami akan memanggil situasi dalam permainan, ketika satu langkah yang salah menentukan hasil pertandingan. <br><br>  Sebagai contoh, serangan [3: 2] adalah breakpoint.  Jika lawan tidak menghalanginya dengan menempatkan sepotong di sebelahnya, maka langkah selanjutnya, kita sudah memiliki serangan [4: 2] di lapangan bermain - yah, hasil pertandingan diputuskan, apa pun yang orang katakan (dalam sebagian besar kasus). <br><br>  Atau serangan [4: 1].  Satu menguap - dan permainan bisa dengan mudah diselesaikan. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Gambar 5. Breakpoint</i> <br><br>  Semuanya jelas dan dapat dimengerti, dan algoritma yang dijelaskan di atas sudah dapat memperhitungkan breakpoint akun dan memblokirnya tepat waktu.  Bot melihat ke depan.  Dia akan melihat bahwa pada giliran berikutnya lawan dapat membuat serangan [5: 1], misalnya, yang beratnya 200 - yang berarti bahwa kutu buku yang licik akan pergi ke sini. <br><br>  Namun, bayangkan sebuah situasi ketika salah satu pemain berhasil mendapatkan 2 breakpoint di lapangan.  Dan ini, jelas, tidak meninggalkan peluang bagi lawan, karena  dalam satu langkah kita hanya dapat memblokir satu breakpoint.  Bagaimana cara mengajarkan AI kami untuk memblokir serangan seperti itu? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Gambar 6. 2 Breakpoints</i> <br><br>  Semuanya sederhana, ketika menganalisis sel, ketika mengganti bagian di dalamnya, kita akan menghitung jumlah breakpoint yang akan kita dapatkan pada langkah berikutnya (bot melihat langkah maju, jangan lupa).  Dengan menghitung 2 breakpoint, kami menambah berat sel sebanyak 100. <br><br>  Dan sekarang, bot tidak hanya akan mencegah situasi permainan seperti itu, tetapi juga akan dapat menciptakannya, yang membuatnya sekarang menjadi lawan yang lebih tangguh. <br><br><h3>  Bagaimana memahami bahwa serangan adalah sebuah breakpoint </h3><br>  Mari kita mulai dengan yang sudah jelas: setiap serangan dengan kekuatan 4 adalah breakpoint.  Hanya satu gerakan yang terlewat memberi kita kesempatan untuk menyelesaikan permainan, mis.  letakkan 5 buah berturut-turut. <br><br>  Lebih lanjut, jika potensi serangannya adalah 2, maka kita akan menghabiskan 1 turn lebih untuk memblokir serangan seperti itu, yang berarti ada breakpoint dengan kekuatan 3. Tetapi hanya ada satu breakpoint seperti itu - ini adalah serangan [3: 2]. <br><br>  Dan selanjutnya lebih sulit - <b>"serangan robek"</b> . <br>  Kami hanya akan mempertimbangkan serangan dengan satu sel kosong di tengah - tidak lagi.  Ini karena untuk menyelesaikan serangan dengan dua sel kosong di tengah, Anda harus menghabiskan setidaknya 2 gerakan - ini jelas bukan breakpoint. <br><br>  Seperti yang kita ingat, kita menganggap serangan robek sebagai beberapa serangan konvensional: satu serangan sentral dan serangan samping.  Serangan pusat adalah milik sel yang dipindai, pembagi samping memiliki lebih dari 1 - ini dijelaskan di atas. <br><br>  Algoritma untuk menemukan breakpoint (lebih mudah, baca di bawah): <br><br><ol><li>  Kami memperkenalkan <b>skor</b> variabel </li><li>  Kami mengambil serangan sentral, kami mempertimbangkan kekuatan </li><li>  Kami mengambil salah satu yang samping jika pembagi nya tidak lebih dari 2x. </li><li>  <b>Skor</b> - jumlah kekuatan serangan pusat dan samping </li><li>  Jika potensi serangan pusat dan samping adalah 2, maka untuk memblokir serangan seperti itu Anda perlu menghabiskan satu putaran lagi.  Oleh karena itu, skor bertambah 1 </li><li>  Jika <b>skor</b> &gt; = 4, maka ini adalah breakpoint <br>  Bahkan, breakpoints bisa saja disebutkan, tidak banyak dari mereka, tetapi saya tidak segera mengerti ini. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  Ya, kami akhirnya akan menyatukan semuanya </h3><br>  Jadi, neraka utama di belakang dijelaskan di atas.  Sudah waktunya untuk membentuk sesuatu yang bekerja darinya.  Function <b>countWeight (x, y)</b> - mengambil koordinat sel sebagai input, dan mengembalikan beratnya.  Apa yang ada di bawah tudungnya? <br><br>  Pertama, kita mendapatkan berbagai serangan yang dimiliki sel.  ( <b>getAllAttacks (x, y)</b> ).  Melewati semua baris, kami menghitung jumlah breakpoints.  Jika ada 2 breakpoint, kami ingat bahwa situasi seperti itu dapat menentukan hasil permainan, dan menambah berat sel hingga 100. <br>  Namun, semua breakpoint harus dimiliki oleh satu pemain, jadi saya harus menerapkan pemeriksaan dalam 2 langkah: salib pertama, lalu nol. <br><br>  Karena dalam deretan bobot serangan ( <b>ATTACK_WEIGHTS []</b> ) saya tidak memberikan serangan dengan kekuatan 6 atau lebih, saya harus menggantinya dengan serangan dengan kekuatan 5. Tidak ada bedanya - mereka semua mengarah ke akhir permainan. <br><br>  Ya, kami merangkum bobot serangan - itu saja. <br><br>  Poin kecil lainnya: agar bot tidak bodoh pada akhir permainan, ketika telah membangun serangan dengan kekuatan 4 dan berpikir tentang gerakan saat ini, perlu untuk secara signifikan meningkatkan berat sel untuk menyelesaikan serangan seperti itu.  Tanpa ini, AI, secara sederhana, dapat mulai mempertahankan diri dari serangan "berbahaya" lawan, meskipun permainan tampaknya dimenangkan.  Langkah terakhir itu penting. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'×'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'○'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Sekarang, ketika memanggil fungsi ini untuk sel tertentu, kita akan mendapatkan bobotnya.  Kami melakukan operasi ini untuk semua sel dan memilih yang terbaik (dengan bobot terbesar).  Disana dan pergi) <br><br>  Anda dapat menemukan sisa kode di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> .  Sudah ada banyak materi, dan presentasinya, karena saya belum mencoba, meninggalkan banyak yang harus diinginkan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetapi jika Anda dapat membaca sampai titik ini, pembaca yang budiman, maka saya berterima kasih kepada Anda. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendapat saya tentang hasilnya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turun! </font><font style="vertical-align: inherit;">Ya, Anda bisa mengalahkannya, tetapi melakukannya sedikit bermasalah bagi saya secara pribadi. </font><font style="vertical-align: inherit;">Mungkin saya tidak cukup berhati-hati. </font><font style="vertical-align: inherit;">Coba kekuatanmu juga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tahu itu lebih mudah, tetapi saya tidak tahu caranya. </font><font style="vertical-align: inherit;">Saya ingin mendengarkan orang-orang yang tahu atau melihat implementasi lain dari bot semacam itu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tahu apa yang bisa lebih baik. </font><font style="vertical-align: inherit;">Ya ... Anda dapat menggunakan algoritme terkenal, seperti minimax, tetapi untuk ini Anda perlu memiliki basis pengetahuan di bidang teori permainan, yang sayangnya tidak dapat saya banggakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di masa depan saya berencana untuk menambahkan analisis breakpoint beberapa langkah ke depan, yang akan membuat bot menjadi lawan yang lebih serius. </font><font style="vertical-align: inherit;">Namun, sekarang saya tidak memiliki ide yang jelas tentang implementasi ini; </font><font style="vertical-align: inherit;">Saya hanya memiliki sesi mendatang dan diploma tidak lengkap - yang menyedihkan saya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih sudah membaca sampai akhir.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430708/">https://habr.com/ru/post/id430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430692/index.html">Rekayasa Sosial dengan Perangkat Lunak Universal Windows Platform (APPX)</a></li>
<li><a href="../id430694/index.html">Panduan singkat untuk mempelajari C ++: apa, kapan dan apa yang harus dibuat</a></li>
<li><a href="../id430700/index.html">Sistem terpadu untuk merekam tayangan film online akan mulai berfungsi di Rusia</a></li>
<li><a href="../id430704/index.html">Bagaimana Teknologi Kecerdasan Buatan Membantu Aviasales Tumbuh: Tujuh Contoh</a></li>
<li><a href="../id430706/index.html">Teori Evolusi Baru</a></li>
<li><a href="../id430710/index.html">Apa yang harus dilakukan jika Black Friday besok dan server Anda belum siap</a></li>
<li><a href="../id430712/index.html">NeurIPS: Cara Menaklukkan Konferensi ML Terbaik</a></li>
<li><a href="../id430714/index.html">VMware membeli Heptio - apa artinya untuk Kubernetes</a></li>
<li><a href="../id430718/index.html">Untuk objek apa layak menggunakan pengawasan video cloud?</a></li>
<li><a href="../id430720/index.html">Intel RealSense D435i: pembaruan kecil dan penyimpangan sejarah singkat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>