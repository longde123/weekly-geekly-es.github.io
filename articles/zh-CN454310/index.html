<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏼 🤲🏻 🍣 Rust中的通用类型闭包 🧚🏼 ⏰ ✊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在这篇简短的文章中，我将讨论Rust中的模式，该模式允许您“保存”供以后使用通过通用方法传递的类型。 这种模式可以在Rust库的源库中找到，有时我也会在我的项目中使用它。 我无法在网络上找到有关他的出版物，所以给他起了我的名字：“通用类型闭包”，在本文中，我想告诉您它的含义，使用原因以及使用方法。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust中的通用类型闭包</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454310/"><p><img src="https://habrastorage.org/webt/jc/35/qj/jc35qjpmk7ypmaece7ki1xpzsz8.jpeg"></p><br><p> 在这篇简短的文章中，我将讨论Rust中的模式，该模式允许您“保存”供以后使用通过通用方法传递的类型。 这种模式可以在Rust库的源库中找到，有时我也会在我的项目中使用它。 我无法在网络上找到有关他的出版物，所以给他起了我的名字：“通用类型闭包”，在本文中，我想告诉您它的含义，使用原因以及使用方法。 </p><a name="habracut"></a><br><h2 id="problema"> 问题 </h2><br><p> 在Rust中，开发的静态类型系统及其静态功能足以满足80％的情况。 但是，当您要将不同类型的对象存储在同一位置时，碰巧需要动态键入。 字符类型对象在这里很抢手：它们擦除对象的真实类型，将它们简化为由类型定义的某个通用接口，然后您可以像对待相同类型的对象一样对这些对象进行操作。 </p><br><p>在其余的一半情况下，这种方法效果很好。 但是，如果在使用对象时我们仍然需要恢复已擦除对象的类型，该怎么办？ 例如，如果我们的对象的行为是由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不能用作type-object的类型确定的</a> 。 对于具有关联类型的特征，这是一种常见情况。 在这种情况下该怎么办？ </p><br><h2 id="reshenie"> 解决方案 </h2><br><p>对于所有<code>'static</code>类型”（即，不包含非静态链接的类型），Rust实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Any</code></a>类型，这允许将<code>dyn Any</code>类型对象转换为对原始对象类型的引用： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-string"><span class="hljs-string">"test"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value_any = &amp;value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Any; <span class="hljs-comment"><span class="hljs-comment">//       String.  //   -      . if let Some(as_string) = value_any.downcast_ref::&lt;String&gt;() { println!("String: {}", as_string); } else { println!("Unknown type"); }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p>  <code>Box</code>也有一个为此目的的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>downcast</code></a>方法。 </p><br><p> 此解决方案适用于在工作地点知道源类型的情况。 但是，如果不是这样呢？ 如果调用代码只是不知道使用对象的源类型，该怎么办？ 然后，我们需要以某种方式记住原始类型，将其放在定义的位置，并与<code>dyn Any</code>类型对象一起保存，以便稍后将后者转换到正确位置的原始类型。 </p><br><p>  Rust中的通用类型可以视为类型变量，在调用时可以将一个或另一个类型值传递到其中。 但是在Rust中，没有办法记住这种类型以便在其他地方进一步使用。 但是，有一种方法可以记住使用此类型以及该类型的所有功能。 这就是“关闭通用类型”模式的想法：使用类型的代码以闭包的形式执行，该闭包以普通函数的形式存储，因为除通用类型外，它不使用环境的任何对象。 </p><br><h2 id="realizaciya"> 实作 </h2><br><p> 让我们看一个实现示例。 假设我们要创建一个表示图形对象层次结构的递归树，其中每个节点可以是带有子节点的图形基元，也可以是一个组件-一个单独的图形对象树： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> { Prim(Primitive), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span> { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span></span> { Rectangle, Circle, }</code> </pre> <br><p> 由于<code>Component</code>结构本身是在<code>Node</code>使用的，因此必须在<code>Component</code>结构中打包<code>Node</code> 。 </p><br><p> 现在假设我们的树只是它应该与之关联的某种模型的表示。 此外，每个组件都有自己的模型： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&lt;Model&gt;&gt;, model: Model, <span class="hljs-comment"><span class="hljs-comment">//   Model }</span></span></code> </pre> <br><p> 我们可以这样写： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component&lt;Model&gt;), }</code> </pre> <br><p> 但是此代码无法按照我们的需要工作。 因为组件必须具有自己的模型，而不是包含组件的父元素的模型。 也就是说，我们需要： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, _model: PhantomData&lt;Model&gt;, <span class="hljs-comment"><span class="hljs-comment">//   Model } struct Component { node: Box&lt;dyn Any&gt;, model: Box&lt;dyn Any&gt;, } impl Component { fn new&lt;Model: 'static&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; Self { Self { node: Box::new(node), model: Box::new(model), } } }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 我们已经将模型的特定类型的指示移到了<code>new</code>方法上，并且在组件本身中，我们已经存储了具有擦除类型的模型和子树。 </p><br><p> 现在添加<code>use_model</code>方法，该方法将使用模型，但不会通过其类型进行参数化： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, use_model_closure: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(&amp;Component), } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Component { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;Model: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> use_model_closure = |comp: &amp;Component| { comp.model.downcast_ref::&lt;Model&gt;().unwrap(); }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(node), model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(model), use_model_closure, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.use_model_closure)(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 请注意，在组件中，我们存储了一个指向在<code>new</code>方法中使用定义闭包的语法创建的函数的指针。 但是它应该从外部捕获的全部是<code>Model</code>类型，因此我们被迫通过参数将指向组件本身的链接传递给该函数。 </p><br><blockquote> 似乎可以使用内部函数来代替闭包，但是此类代码无法编译。 因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust</a>仅在可见性方面与常规顶级函数不同，所以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内部函数无法从外部捕获通用类型</a> 。 </blockquote><p>  <code>use_model</code>可以在实际的<code>Model</code>类型未知的上下文中使用<code>use_model</code>方法。 例如，在包含许多具有不同模型的不同组件的递归树遍历中。 </p><br><h2 id="alternativa"> 另类 </h2><br><p> 如果可以将组件的接口转换为允许创建类型对象的类型，则最好这样做，而应使用组件本身对其类型对象进行操作： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn ComponentApi&gt;), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: Node&lt;Model&gt;, model: Model, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node, model, } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentApi</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; ComponentApi <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model; } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 事实证明，Rust中的闭包不仅可以捕获环境对象，还可以捕获类型。 但是，它们可以解释为普通功能。 如果字符类型不适用，当您需要统一处理不同类型而不丢失有关它们的信息时，此属性将非常有用。 </p><br><p> 我希望本文能帮助您使用Rust。 在评论中分享您的想法。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454310/">https://habr.com/ru/post/zh-CN454310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454300/index.html">CTT与传统热管有何不同以及如何应用</a></li>
<li><a href="../zh-CN454302/index.html">QVD文件-里面有什么</a></li>
<li><a href="../zh-CN454304/index.html">陶瓷自己动手做的台达3D打印机</a></li>
<li><a href="../zh-CN454306/index.html">我作为首席开发人员犯的五个错误</a></li>
<li><a href="../zh-CN454308/index.html">带有Habr V.9.0的AMA。 播客，会议和概念</a></li>
<li><a href="../zh-CN454312/index.html">如何在Angular框架中使用jQuery库（确实需要时）</a></li>
<li><a href="../zh-CN454314/index.html">每个开发人员都应了解的面向对象编程的10条原则</a></li>
<li><a href="../zh-CN454316/index.html">跟随工业忍者的脚步：我们邀请您参加在线工业安全竞赛</a></li>
<li><a href="../zh-CN454318/index.html">听起来过去。 历史学家有关将数据转换为声音的指南</a></li>
<li><a href="../zh-CN454320/index.html">劳动力市场分析师和数据科学家</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>