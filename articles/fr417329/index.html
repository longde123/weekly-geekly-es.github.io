<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👦 🖐🏻 👆🏿 Vous et Brad Pitt êtes à 99% 🐈 ♣️ 👩🏽‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous, dans le département d'analyse du cinéma en ligne Okko, aimons automatiser autant que possible le calcul des frais de film d'Alexander Nevsky, et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vous et Brad Pitt êtes à 99%</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/417329/"><p><img src="https://habrastorage.org/webt/bg/8z/-p/bg8z-pmvxneor2kulnu9tmg3qoy.jpeg" alt="Demain en vacances"></p><br><p>  Nous, dans le département d'analyse du cinéma en ligne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Okko,</a> aimons automatiser autant que possible le calcul des frais de film d'Alexander Nevsky, et pendant le temps libre pour apprendre de nouvelles choses et mettre en œuvre des choses intéressantes qui, pour une raison quelconque, se traduisent généralement en bots pour Telegram.  Par exemple, avant le début de la Coupe du Monde de la FIFA 2018, nous avons déployé un bot sur le chat de travail, qui a collecté des paris sur la distribution des places finales, et après la finale, nous avons calculé les résultats selon une métrique pré-inventée et déterminé les gagnants.  La Croatie n'a pas mis quatre dans le top quatre. </p><br><p>  Récent temps libre de la compilation des 10 meilleures comédies russes que nous avons consacrées à la création d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bot</a> qui trouve une célébrité à laquelle l'utilisateur ressemble le plus.  Dans le chat de travail, tout le monde a tellement apprécié l'idée que nous avons décidé de rendre le bot accessible au public.  Dans cet article, nous rappelons brièvement la théorie, parlons de la création de notre bot et comment le faire vous-même. </p><a name="habracut"></a><br><h1 id="nemnogo-teorii-v-osnovnom-v-kartinkah">  Un peu de théorie (surtout en images) </h1><br><p> En détail sur la façon dont les systèmes de reconnaissance faciale sont organisés, j'en ai parlé dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un de mes articles précédents</a> .  Un lecteur intéressé peut suivre le lien, et je décrirai ci-dessous uniquement les principaux points. </p><br><p>  Donc, vous avez une photographie sur laquelle peut-être même un visage est montré et vous voulez comprendre de qui il s'agit.  Pour ce faire, vous devez suivre 4 étapes simples: </p><br><ol><li>  Sélectionnez le rectangle bordant le visage. </li><li>  Mettez en surbrillance les points clés du visage. </li><li>  Alignez et recadrez votre visage. </li><li>  Convertissez une image de visage en une représentation interprétée par une machine. </li><li>  Comparez cette vue avec celles dont vous disposez. </li></ol><br><h3 id="vydelenie-lica">  Sélection du visage </h3><br><p>  Bien que les réseaux de neurones convolutifs aient récemment appris à trouver des visages dans une image pas pire que les méthodes classiques, ils sont toujours inférieurs au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HOG</a> classique en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">termes</a> de vitesse et de facilité d'utilisation. </p><br><p>  HOG - Histogrammes de dégradés orientés.  Ce gars associe chaque pixel de l'image source à son gradient - un vecteur dans le sens duquel la luminosité des pixels change le plus.  L'avantage de cette approche est qu'elle ne se soucie pas des valeurs absolues de la luminosité des pixels, seul leur rapport suffit.  Par conséquent, un visage normal, sombre et mal éclairé et bruyant sera affiché dans approximativement le même histogramme de dégradés. </p><br><p><img src="https://habrastorage.org/webt/ke/_h/b_/ke_hb_cyd3odkvkwmqb0soancka.png" alt="Histogramme des gradients directionnels du visage"></p><br><p> Il n'est pas nécessaire de calculer le gradient pour chaque pixel, il suffit de calculer le gradient moyen pour chaque petit carré <code>n</code> par <code>n</code> .  En utilisant le champ vectoriel reçu, vous pouvez ensuite passer par un détecteur avec une fenêtre et déterminer pour chaque fenêtre la probabilité que le visage y soit.  Le détecteur peut être SVM, une forêt aléatoire ou autre chose. </p><br><p><img src="https://habrastorage.org/webt/mz/hk/2y/mzhk2ycaurneywpy32a0linnm3o.png" alt="Détection des visages"></p><br><h3 id="vydelenie-klyuchevyh-tochek">  Mettre en évidence les points clés </h3><br><p><img src="https://habrastorage.org/webt/wd/bi/dc/wdbidcix45fpf74iglc7f0f1rpg.png" alt="Points clés du visage"></p><br><p>  Les points clés sont des points qui aident à identifier une personne dans l'espace.  Les scientifiques faibles et peu sûrs ont généralement besoin de 68 points clés, et dans des cas particulièrement négligés, encore plus.  Les garçons normaux et confiants, gagnant 300k par seconde, en avaient toujours assez de cinq: les coins intérieurs et extérieurs des yeux et du nez. </p><br><p><img src="https://habrastorage.org/webt/6t/tb/-8/6ttb-8bq0ugffanbs0qcrihy2a4.jpeg" alt="Vieux mème"></p><br><p>  De tels points peuvent être extraits, par exemple, par une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cascade de régresseurs</a> . </p><br><h3 id="vyravnivanie-lica">  Alignement du visage </h3><br><p>  Applications collées dans l'enfance?  Ici, tout est exactement le même: vous créez une transformation affine qui traduit trois points arbitraires à leurs positions standard.  Le nez peut être laissé tel quel, mais pour que les yeux comptent leurs centres - ce sont les trois points prêts. </p><br><p><img src="https://habrastorage.org/webt/ms/3q/s7/ms3qs7hagupsaooas-eqrjjmqpy.png" alt="Face de rotation face"></p><br><h3 id="preobrazovanie-izobrazheniya-lica-v-vektor">  Convertir des images de visage en vecteur </h3><br><p><img src="https://habrastorage.org/webt/ab/8w/jo/ab8wjody73ybfs_opnftpipbcz0.png" alt="Mème moins vieux"></p><br><p>  Trois ans se sont écoulés depuis la publication de l'article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FaceNet</a> , pendant ce temps de nombreux programmes de formation et fonctions de perte intéressants sont apparus, mais c'est elle qui domine parmi les solutions OpenSource disponibles.  Apparemment, le tout est une combinaison de facilité de compréhension, de mise en œuvre et de résultats décents.  Merci au moins pour le fait qu'au cours des trois dernières années, l'architecture a été modifiée pour ResNet. </p><br><p><img src="https://habrastorage.org/webt/af/pt/cx/afptcx5ixcu2r0_mjkckckpt2zo.jpeg" alt="Nouveau mème"></p><br><p>  FaceNet apprend à partir de trois exemples: (ancre, positif, négatif).  L'ancre et les exemples positifs appartiennent à une personne, tandis que le négatif est choisi comme le visage d'une autre personne, ce qui, pour une raison quelconque, le réseau est trop proche de la première.  La fonction de perte est conçue de manière à corriger ce malentendu, à rassembler les exemples nécessaires et à en supprimer les inutiles. </p><br><p><img src="https://habrastorage.org/webt/tp/yf/sw/tpyfswhgnyco4w_0ap3zy8i5zhs.png" alt="Guccinet"></p><br><p><img src="https://habrastorage.org/webt/gj/fi/zq/gjfizqzcwjybnypbv-ugovr5hl0.png" alt="Visages faciaux et Dmitry Malikov"></p><br><p>  La sortie de la dernière couche du réseau est appelée intégration - une représentation représentative d'une personne dans un certain espace de petite dimension (généralement 128 dimensions). </p><br><h3 id="sravnenie-lic">  Comparaison des visages </h3><br><p>  La beauté des plongements bien entraînés est que les visages d'une personne sont affichés dans un petit voisinage de l'espace, éloigné des incrustations des visages d'autres personnes.  Ainsi, pour cet espace, vous pouvez entrer une mesure de similitude, l'inverse de la distance: euclidienne ou cosinus, selon la distance sur laquelle le réseau a été formé. </p><br><p><img src="https://habrastorage.org/webt/pn/u8/ba/pnu8barwdzvdryma24yezil7kvo.jpeg" alt="Un exemple complètement artificiel de plongements"></p><br><p>  Ainsi, à l'avance, nous devons construire des intégrations pour toutes les personnes parmi lesquelles la recherche sera effectuée, puis, pour chaque demande, trouver le vecteur le plus proche parmi elles.  Ou, d'une autre manière, résolvez le problème de trouver <code>k</code> voisins les plus proches, où <code>k</code> peut être égal à un, ou peut-être pas, si nous voulons utiliser une logique métier plus avancée.  La personne qui possède le vecteur de résultat sera la plus similaire à la personne de demande. </p><br><p><img src="https://habrastorage.org/webt/6f/uz/nx/6fuznxdig3uiw1mjuv1eezx5h3u.jpeg" alt="Similitude du visage à face et non du visage à face"></p><br><h3 id="kakuyu-biblioteku-ispolzovat">  Quelle bibliothèque utiliser? </h3><br><p>  Le choix des bibliothèques ouvertes qui implémentent diverses parties du pipeline est excellent.  <code>dlib</code> et <code>OpenCV</code> peuvent trouver des visages et des points clés, et des versions pré-formées de réseaux peuvent être trouvées pour n'importe quelle grande infrastructure de réseau neuronal.  Il y a un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenFace</a> où vous pouvez choisir l'architecture pour vos exigences de rapidité et de qualité.  Mais une seule bibliothèque vous permet d'implémenter les 5 points de reconnaissance faciale dans les appels à trois fonctions de haut niveau: <code>dlib</code> .  En même temps, il est écrit en C ++ moderne, utilise BLAS, a un wrapper pour Python, ne nécessite pas de GPU et fonctionne assez rapidement sur un CPU.  Notre choix est tombé sur elle. </p><br><h1 id="delaem-sobstvennogo-bota">  Faire votre propre bot </h1><br><p>  Cette section a déjà été décrite dans tous les guides de création de robots, mais une fois que nous aurons écrit la même chose, nous devrons la répéter.  Nous écrivons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@BotFather</a> et lui demandons un jeton pour notre nouveau bot. </p><br><p><img src="https://habrastorage.org/webt/um/qe/ew/umqeewdk64wtealh1ldudqsv0m8.png" alt="Flou le jeton xs pourquoi"></p><br><p>  Le jeton ressemble à ceci: <code>643075690:AAFC8ola8WRdhGbJtzjmkOhne1FGfu1BFg</code> .  Il est nécessaire d'obtenir une autorisation à chaque demande adressée à l'API Telegram bot. </p><br><p>  J'espère que personne à ce stade n'aura de doutes lors du choix d'un langage de programmation.  Bien sûr, vous devez écrire en Haskell.  Commençons par le module principal. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Process main :: IO () main = do (<span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">handle</span></span>) &lt;- createProcess (<span class="hljs-title"><span class="hljs-title">shell</span></span> "<span class="hljs-title"><span class="hljs-title">python</span></span> <span class="hljs-title"><span class="hljs-title">bot</span></span>.<span class="hljs-title"><span class="hljs-title">py</span></span>") _ &lt;- waitForProcess handle putStrLn "Done!"</code> </pre> <br><p>  Comme vous pouvez le voir dans le code, nous utiliserons à l'avenir une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DSL</a> spéciale pour écrire des robots télégrammes.  Le code de cette DSL est écrit dans des fichiers séparés.  Installez la langue du domaine et tout ce qui est nécessaire. </p><br><pre> <code class="bash hljs">python -m venv .env <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> .env/bin/activate pip install python-telegram-bot</code> </pre> <br><p>  <code>python-telegram-bot</code> est actuellement le framework le plus pratique pour créer des bots.  Il est facile à apprendre, flexible, évolutif, prend en charge le multithreading.  Malheureusement, à l'heure actuelle, il n'y a pas un seul cadre asynchrone normal et des fils anciens doivent être utilisés à la place des coroutines divines. </p><br><p><img src="https://habrastorage.org/webt/t2/8b/qv/t28bqvhxxznqmzsobr4hjmuxlta.jpeg" alt="asyncio est mon seul dieu"></p><br><p>  Démarrer un bot avec <code>python-telegram-bot</code> est facile.  Ajoutez le code suivant à <code>bot.py</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def echo(bot, update): bot.send_message(chat_id=update.message.chat_id, text=update.message.text) updater = Updater(token=TOKEN) dispatcher = updater.dispatcher echo_handler = MessageHandler(Filters.text, echo) dispatcher.add_handler(echo_handler)</span></span></code> </pre> <br><p>  Exécutez le bot.  À des fins de débogage, cela peut être fait avec la <code>python bot.py</code> sans exécuter le code Haskell. </p><br><p>  Un tel robot simple est capable de maintenir une conversation minimale et, par conséquent, il peut facilement être organisé pour fonctionner en tant que développeur frontal. </p><br><p><img src="https://habrastorage.org/webt/xs/pk/sm/xspksm1d8ehnslmqjsj33dzyekm.png" alt="Dialogue typique avec le développeur frontal"></p><br><p>  Mais le frontend des développeurs est déjà trop, nous allons donc le tuer dès que possible et procéder à l'implémentation de la fonctionnalité principale.  Par souci de simplicité, notre bot ne répondra qu'aux messages contenant des photos et ignorera les autres.  Modifiez le code comme suit. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def handle_photo(bot, update): bot.send_message(chat_id=update.message.chat_id, text='nice') updater = Updater(token=TOKEN) dispatcher = updater.dispatcher photo_handler = MessageHandler(Filters.photo, handle_photo) dispatcher.add_handler(photo_handler) updater.start_polling() updater.idle()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/-8/1k/hq/-81khq5z9redcz29_ut7sunfrpg.png" alt="Déjà pas un développeur front-end"></p><br><p>  Lorsque l'image entre dans le serveur Telegram, elle est automatiquement ajustée à plusieurs tailles prédéterminées.  Le bot, à son tour, peut télécharger une image de n'importe quelle taille parmi celles contenues dans la liste <code>message.photo</code> triée par ordre croissant.  L'option la plus simple: prendre la plus grande image.  Bien sûr, dans un environnement d'épicerie, vous devez penser à la charge du réseau et au temps de chargement et choisir une image de la taille minimale appropriée.  Ajoutez le code de téléchargement d'image en haut de la fonction <code>handle_photo</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io</code> </pre> <br><pre> <code class="python hljs">message = update.message photo = message.photo[~<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> io.BytesIO() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fd: file_id = bot.get_file(photo.file_id) file_id.download(out=fd) fd.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  L'image a été téléchargée et est en mémoire.  Pour l'interpréter et le présenter sous la forme d'une matrice d'intensité de pixels, nous utilisons les bibliothèques <code>Pillow</code> et <code>numpy</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre> <br><p>  Le code suivant doit être ajouté au bloc <code>with</code> . </p><br><pre> <code class="python hljs">image = Image.open(fd) image.load() image = np.asarray(image)</code> </pre> <br><p>  Le temps est venu dlib.  En dehors de la fonction, créez un détecteur de visage. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib</code> </pre> <br><pre> <code class="python hljs">face_detector = dlib.get_frontal_face_detector()</code> </pre> <br><p>  Et à l'intérieur de la fonction, nous l'utilisons. </p><br><pre> <code class="python hljs">face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Le deuxième paramètre de la fonction signifie le grossissement qui doit être appliqué avant de tenter de détecter les visages.  Plus il est grand, plus les visages seront petits et complexes que le détecteur pourra détecter, mais plus il fonctionnera longtemps.  <code>face_detects</code> - une liste de visages triés par ordre décroissant de la confiance du détecteur que le visage est devant lui.  Dans une application réelle, vous voudrez probablement appliquer une logique de choix de la personne principale, et dans l'étude de cas, nous nous limiterons à choisir la première. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> face_detects: bot.send_message(chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">'no faces'</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>  Nous passons à l'étape suivante - la recherche de points clés.  Téléchargez le <a href="">modèle entraîné</a> et déplacez sa charge en dehors de la fonction. </p><br><pre> <code class="python hljs">shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'path/to/shape_predictor_5_face_landmarks.dat'</span></span>)</code> </pre> <br><p>  Trouvez les points clés. </p><br><pre> <code class="python hljs">landmarks = shape_predictor(image, face)</code> </pre> <br><p>  La seule chose qui reste est petite: pour redresser le visage, le conduire à travers ResNet et obtenir une intégration à 128 dimensions.  Heureusement, dlib vous permet de faire tout cela en un seul appel.  Il vous suffit de télécharger le <a href="">modèle pré-formé</a> . </p><br><pre> <code class="python hljs">face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'path/to/dlib_face_recognition_resnet_model_v1.dat'</span></span>)</code> </pre> <br><pre> <code class="python hljs">embedding = face_recognition_model.compute_face_descriptor(image, landmarks) embedding = np.asarray(embedding)</code> </pre> <br><p>  Il suffit de regarder dans quelle merveilleuse période nous vivons.  Toute la complexité des réseaux de neurones convolutifs, la méthode des vecteurs de support et les transformations affines appliquées à la reconnaissance faciale sont encapsulées dans trois appels de bibliothèque. </p><br><p>  Puisque nous ne savons pas encore faire quoi que ce soit de significatif, rendons à l'utilisateur la valeur moyenne de son intégration, multipliée par mille. </p><br><pre> <code class="python hljs">bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'yours embedding mean: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{embedding.mean() * </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1e3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">:</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">.2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">f}</span></span></span><span class="hljs-string">'</span></span> )</code> </pre> <br><p><img src="https://habrastorage.org/webt/ud/av/o6/udavo6i5srwrl93jbopenn84tae.png" alt="Je ne sais pas ce que je fais"></p><br><p>  Pour que notre bot puisse déterminer à quelles célébrités les utilisateurs ressemblent, nous devons maintenant trouver au moins une photo de chaque célébrité, construire une intégration sur elle et l'enregistrer quelque part.  Nous ajouterons seulement 10 célébrités à notre bot de formation, trouvant leurs photos à la main et les mettant dans le répertoire des <code>photos</code> .  Voici à quoi cela devrait ressembler: </p><br><p><img src="https://habrastorage.org/webt/yz/rd/1o/yzrd1ockvqezvybwzo-yulsivqq.png" alt="Écoutez, je n'avais pas assez d'argent pour un MacBook."></p><br><p>  Si vous voulez avoir un million de célébrités dans la base de données, tout se ressemblera exactement, seulement il y a plus de fichiers et il est peu probable que vous puissiez les rechercher avec vos mains.  <code>build_embeddings.py</code> utilitaire <code>build_embeddings.py</code> utilisant les appels <code>dlib</code> que nous connaissons déjà et enregistrons les incorporations de célébrités avec leurs noms au format binaire. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image face_detector = dlib.get_frontal_face_detector() shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'assets/shape_predictor_5_face_landmarks.dat'</span></span>) face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'assets/dlib_face_recognition_resnet_model_v1.dat'</span></span>) fs = os.listdir(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>) es = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs: print(f) image = np.asarray(Image.open(os.path.join(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>, f))) face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>] landmarks = shape_predictor(image, face) embedding = face_recognition_model.compute_face_descriptor(image, landmarks, num_jitters=<span class="hljs-number"><span class="hljs-number">10</span></span>) embedding = np.asarray(embedding) name, _ = os.path.splitext(f) es.append((name, embedding)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: pickle.dump(es, f)</code> </pre> <br><p>  Ajoutez le chargement intégré à notre code bot. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: star_embeddings = pickle.load(f)</code> </pre> <br><p>  Et grâce à une recherche exhaustive, nous découvrirons à quoi ressemble notre utilisateur. </p><br><pre> <code class="python hljs">ds = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> star_embeddings: distance = np.linalg.norm(embedding - emb) ds.append((name, distance)) best_match, best_distance = min(ds, key=itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>)) bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'your look exactly like *</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{best_match}</span></span></span><span class="hljs-string">*'</span></span>, parse_mode=<span class="hljs-string"><span class="hljs-string">'Markdown'</span></span> )</code> </pre> <br><p>  Veuillez noter que nous utilisons la distance euclidienne comme distance, car  le réseau de dlib a été formé précisément avec l'aide de celui-ci. </p><br><p><img src="https://habrastorage.org/webt/yd/fl/wi/ydflwigundswx6_qbctjir_itge.png" alt="J'ai été déçu de l'article"></p><br><p>  C'est tout, félicitations!  Nous avons créé un bot simple qui peut déterminer la célébrité de l'utilisateur.  Il reste à trouver plus de photos, ajouter une image de marque, une évolutivité, une pincée de journalisation et tout peut être publié en production.  Tous ces sujets sont trop volumineux pour être abordés en détail avec d'énormes listes de codes. Je vais donc simplement décrire les principaux points du format question-réponse dans la section suivante. </p><br><p>  Le code bot de formation complet est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><h1 id="rasskazyvaem-pro-nashego-bota">  On parle de notre bot </h1><br><h3 id="skolko-u-vas-v-baze-znamenitostey-gde-vy-ih-nashli">  Combien de célébrités avez-vous dans votre base de données?  Où les avez-vous trouvés? </h3><br><p>  La décision la plus logique lors de la création du bot semblait prendre des données sur les célébrités de notre base de contenu interne.  Dans le format du graphique, elle stocke les films et toutes les entités associées aux films, y compris les acteurs et les réalisateurs.  Pour chaque personne, nous connaissons son nom, son identifiant et son mot de passe d'iCloud, des films et alias associés, qui peuvent être utilisés pour générer des liens vers le site.  Après avoir nettoyé et extrait uniquement les informations nécessaires, le fichier <code>json</code> reste le suivant: </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"tilda-swinton"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"michael-shannon"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">22</span></span> }, ... ]</code> </pre> <br><p>  Il y avait <strong>22 000</strong> entrées de ce type dans le catalogue.  Soit dit en passant, pas un catalogue, mais un catalogue. </p><br><h3 id="gde-nayti-fotografii-dlya-vseh-etih-lyudey">  Où trouver des photos pour toutes ces personnes? </h3><br><p><img src="https://habrastorage.org/webt/_n/5i/pl/_n5iplsi4yqnrm2lpvzyjwhjigm.jpeg" alt="Dans les moments dangereux, nous vivons"></p><br><p>  Eh bien, tu sais, <em>ici et là</em> .  Il y a, par exemple, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">merveilleuse bibliothèque</a> qui vous permet de télécharger des résultats de recherche d'images depuis Google.  22 mille personnes - pas tellement, en utilisant 56 flux, nous avons réussi à télécharger des photos pour eux en moins d'une heure. </p><br><p>  Parmi les photos téléchargées, vous devez jeter les photos cassées, bruyantes, au mauvais format.  Ne laissez ensuite que ceux où il y a des visages et où ces visages remplissent certaines conditions: la distance minimale entre les yeux, l'inclinaison de la tête.  Tout cela nous laisse avec <strong>12 000</strong> photos. </p><br><p>  Sur les 12 000 célébrités, les utilisateurs n'en ont trouvé que 2 pour le moment, c'est-à-dire qu'il y a environ 8 000 célébrités qui ne ressemblent à personne.  Ne le laissez pas comme ça!  Ouvrez des télégrammes et trouvez-les tous. </p><br><h3 id="kak-opredelit-procent-shozhesti-dlya-evklidovoy-distancii">  Comment déterminer le pourcentage de similitude pour la distance euclidienne? </h3><br><p>  Grande question!  En effet, la distance euclidienne, contrairement au cosinus, n'est pas bornée ci-dessus.  Par conséquent, une question raisonnable se pose, comment montrer à l'utilisateur quelque chose de plus significatif que "Félicitations, la distance entre votre intégration et l'intégration d'Angelina Jolie est de 0,27635462738"?  Un des membres de notre équipe a proposé la solution simple et ingénieuse suivante.  Si vous construisez la distribution des distances entre les encastrements, ce sera normal.  Donc, pour lui, vous pouvez calculer la moyenne et l'écart-type, puis pour chaque utilisateur, en fonction de ces paramètres, considérez <em>combien de pour cent des gens ressemblent moins à leurs célébrités que lui</em> .  Cela équivaut à intégrer une fonction de densité de probabilité de <code>d</code> à plus l'infini, où <code>d</code> est la distance entre l'utilisateur et les célébrités. </p><br><p><img src="https://habrastorage.org/webt/fh/yc/4r/fhyc4r87otryweg9v-xznackhfq.png" alt="Ce n'est pas marin"></p><br><p>  Voici la fonction exacte que nous utilisons: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_transform_dist_to_sim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, dist)</span></span></span><span class="hljs-function">:</span></span> p = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> + erf((dist - self._dist_mean) / (self._dist_std * <span class="hljs-number"><span class="hljs-number">1.4142135623730951</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(min(<span class="hljs-number"><span class="hljs-number">1</span></span> - p, <span class="hljs-number"><span class="hljs-number">1.0</span></span>), self._min_similarity)</code> </pre> <br><h3 id="neuzheli-nuzhno-perebirat-spisok-vseh-embedingov-chtoby-nayti-sovpadenie">  Est-il vraiment nécessaire de parcourir la liste de tous les syndicats afin de trouver une correspondance? </h3><br><p>  Bien sûr que non, ce n'est pas optimal et prend beaucoup de temps.  La façon la plus simple d'optimiser les calculs est d'utiliser des opérations matricielles.  Au lieu de soustraire les vecteurs les uns des autres, vous pouvez en composer une matrice et soustraire un vecteur de la matrice, puis calculer la norme L2 en lignes. </p><br><pre> <code class="python hljs">scores = np.linalg.norm(emb - embeddings, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_idx = scores.argmax()</code> </pre> <br><p>  Cela donne déjà une énorme augmentation de la productivité, mais il s'avère que vous pouvez encore plus rapidement.  La recherche peut être considérablement accélérée en perdant un peu de sa précision à l'aide de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nmslib</a> .  Il utilise la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HNSW</a> pour approximer la recherche de <code>k</code> voisins les plus proches.  Pour tous les vecteurs disponibles, un soi-disant index doit être construit, dans lequel ensuite une recherche sera effectuée.  Vous pouvez créer et enregistrer l'index pour la distance euclidienne comme suit: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nmslib index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(embeddings): index.addDataPoint(idx, emb) index_time_params = { <span class="hljs-string"><span class="hljs-string">'indexThreadQty'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'skip_optimized_index'</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'delaunay_type'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'M'</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'efConstruction'</span></span>: <span class="hljs-number"><span class="hljs-number">2000</span></span> } index.createIndex(index_time_params, print_progress=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) index.saveIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>)</code> </pre> <br><p>  Les paramètres <code>M</code> et <code>efConstruction</code> sont décrits en détail dans la <a href="">documentation</a> et sont sélectionnés expérimentalement en fonction de la précision requise, du temps de construction de l'index et de la vitesse de recherche.  Avant d'utiliser l'index, vous devez télécharger: </p><br><pre> <code class="python hljs">index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) index.loadIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>) query_time_params = {<span class="hljs-string"><span class="hljs-string">'efSearch'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>} index.setQueryTimeParams(query_time_params)</code> </pre> <br><p>  Le paramètre <code>efSearch</code> affecte la précision et la vitesse des requêtes et peut ne pas correspondre à <code>efConstruction</code> .  Vous pouvez maintenant faire des demandes. </p><br><pre> <code class="python hljs">ids, dists = index.knnQuery(embedding, k=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_dx = ids[<span class="hljs-number"><span class="hljs-number">0</span></span>] best_dist = dists[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>  Dans notre cas, <code>nmslib</code> est 20 fois plus rapide que la version linéaire vectorisée, et une demande est traitée en moyenne <code>0.005</code> seconde. </p><br><h3 id="kak-sdelat-moego-bota-gotovym-k-prodakshenu">  Comment préparer mon bot pour la production? </h3><br><h5 id="1-asinhronnost">  1. Asynchronie </h5><br><p>  Tout d'abord, vous devez rendre la fonction <code>handle_photo</code> asynchrone.  Comme je l'ai déjà dit, <code>python-telegram-bot</code> propose le multithreading pour cela et implémente un décorateur pratique. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.dispatcher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> run_async @run_async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_photo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bot, update)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre> <br><p>  Maintenant, le framework lui-même lancera votre gestionnaire dans un thread séparé dans son pool.  La taille du pool est définie lors de la création du programme de mise à jour.  "Mais en python, il n'y a pas de multithreading!"  s'exclament déjà les plus impatients d'entre vous.  Et ce n'est pas tout à fait vrai.  En raison du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GIL,</a> le code Python ordinaire ne peut vraiment pas être exécuté en parallèle, mais le GIL est publié pour attendre toutes les opérations d'E / S, et il peut également être publié par les bibliothèques qui utilisent des extensions C. </p><br><p>  Analysons maintenant notre fonction <code>handle_photo</code> : elle consiste simplement à attendre les opérations d'E / S (télécharger une photo, envoyer une réponse, lire une photo à partir du disque, etc.) et appeler les fonctions des <code>numpy</code> , <code>nmslib</code> et <code>Pillow</code> . </p><br><p>  Je n'ai pas mentionné <code>dlib</code> pour une raison.  La bibliothèque qui appelle le code natif n'est pas nécessaire pour libérer le GIL et <code>dlib</code> ce droit.  Elle n'a pas besoin de cette serrure, elle ne la laisse pas partir.  L'auteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit</a> qu'il acceptera volontiers la Pull Request appropriée, mais je suis trop paresseux. </p><br><h5 id="2-mnogoprocessnost">  2. Multiprocessing </h5><br><p>  Le moyen le plus simple de gérer <code>dlib</code> consiste à encapsuler le modèle dans une entité distincte et à l'exécuter dans un processus distinct.  Et mieux dans le pool de processus. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> model model = Model(config) model.load_state() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.process_image(image) pool = multiprocessing.Pool(<span class="hljs-number"><span class="hljs-number">8</span></span>, initializer=_worker_initialize, initargs=(config,))</code> </pre> <br><pre> <code class="python hljs">result = pool.apply(_worker_do, (image,))</code> </pre> <br><h5 id="3-zhelezo">  3. Fer </h5><br><p>  Si votre bot a besoin de lire constamment les photos d'un disque, assurez-vous que le disque est un SSD.  Ou même les monter dans la RAM.  Le ping vers les serveurs de télégrammes et la qualité des canaux sont également importants. </p><br><h5 id="4-flood-control">  4. Contrôle des inondations </h5><br><p>  Les télégrammes ne permettent pas aux bots d'envoyer plus de 30 messages par seconde.  Si votre bot est populaire et que beaucoup de gens l'utilisent en même temps, il est très facile d'intercepter une interdiction pendant quelques secondes, ce qui se transformera en déception par rapport aux attentes de nombreux utilisateurs.  Pour résoudre ce problème, <code>python-telegram-bot</code> nous propose une file d'attente qui ne peut pas envoyer plus que la limite de messages spécifiée par seconde, en maintenant des intervalles égaux entre les envois. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.messagequeue <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageQueue</code> </pre> <br><p>  Pour l'utiliser, vous devez définir votre propre bot et le remplacer lors de la création de <code>Updater</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.utils.promise <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Promise <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MQBot</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bot)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._message_queue = MessageQueue( all_burst_limit=<span class="hljs-number"><span class="hljs-number">30</span></span>, all_time_limit_ms=<span class="hljs-number"><span class="hljs-number">1000</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._message_queue.stop() <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: super().__del__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> is_group = kwargs.get(<span class="hljs-string"><span class="hljs-string">'chat_id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._message_queue(Promise(super().send_message, args, kwargs), is_group)</code> </pre> <br><pre> <code class="python hljs">bot = MQBot(token=TOKEN) updater = Updater(bot=bot)</code> </pre> <br><h5 id="5-web-hooks">  5. Crochets Web </h5><br><p>  Dans un environnement de produit, les Web Hooks doivent toujours être utilisés au lieu de l'interrogation longue pour recevoir des mises à jour des serveurs Telegram.  De quoi s'agit-il et comment l'utiliser peut être lu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h5 id="6-melochi">  6. Anecdotes </h5><br><p>              <code>json</code> .    ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ultrajson</a> . </p><br><p>          IO-:    ,  ,  .      ,         . </p><br><h5 id="6-analitika"> 6.  </h5><br><p>   ,   .        ,   ,  ,       .        ,        . </p><br><p> , ,      BI-tool <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Splunk</a>     . </p><br><p><img src="https://habrastorage.org/webt/oh/8e/ve/oh8eve_hczr4pahrzum56fonxxg.jpeg" alt="Planche publicitaire (veuillez nous prolonger une licence)"></p><br><p>   ,         .     ,                       . </p><br><p>    ,         .      ,    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@OkkoFaceBot</a> . </p><br><p><del>        </del> ,     . ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417329/">https://habr.com/ru/post/fr417329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417319/index.html">Systèmes dans le boîtier ou ce qui se trouve réellement sous le capot du microprocesseur</a></li>
<li><a href="../fr417321/index.html">Comment recherchons-nous des enseignants de cours en ligne parmi les développeurs?</a></li>
<li><a href="../fr417323/index.html">Problèmes pour garantir l'accessibilité à 100% du projet</a></li>
<li><a href="../fr417325/index.html">Journée portes ouvertes Netrology, thème Science des données</a></li>
<li><a href="../fr417327/index.html">Surveillance budgétaire de la température dans la salle des serveurs (MP707 + nettop avec Linux + PRTG)</a></li>
<li><a href="../fr417331/index.html">Security Week 26: Spectre mis à jour, maintenant un enregistrement de bon goût</a></li>
<li><a href="../fr417333/index.html">Évaluation sociale</a></li>
<li><a href="../fr417337/index.html">Principes de fonctionnement et caractéristiques d'application du swap atomique</a></li>
<li><a href="../fr417339/index.html">3DTouch - Échelles sur iPhone: achèvement</a></li>
<li><a href="../fr417345/index.html">Chasse aux menaces avec Cisco Visibility</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>