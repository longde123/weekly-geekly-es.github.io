<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïç ü¶í üï∫üèª Prueba de caja blanca üéë ü§πüèΩ üë∂üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El desarrollo de programas de alta calidad implica que el programa y sus partes se prueban. La prueba de unidad cl√°sica implica dividir un programa gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba de caja blanca</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  El desarrollo de programas de alta calidad implica que el programa y sus partes se prueban.  La prueba de unidad cl√°sica implica dividir un programa grande en bloques peque√±os que son convenientes para la prueba.  O, si el desarrollo de las pruebas se lleva a cabo en paralelo con el desarrollo del c√≥digo o las pruebas se desarrollan antes del programa (TDD - desarrollo impulsado por pruebas), el programa se desarrolla inicialmente en peque√±os bloques adecuados para los requisitos de las pruebas. </p><br><p>  Una de las variedades de pruebas unitarias puede considerarse una prueba basada en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedad</a> (este enfoque se implementa, por ejemplo, en las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bibliotecas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScalaCheck</a> ).  Este enfoque se basa en encontrar propiedades universales que deber√≠an ser v√°lidas para cualquier dato de entrada.  Por ejemplo, la <em>serializaci√≥n seguida de la deserializaci√≥n deber√≠a producir el mismo objeto</em> .  O bien, la <em>reordenaci√≥n no deber√≠a cambiar el orden de los elementos de la lista</em> .  Para verificar tales propiedades universales, las bibliotecas anteriores admiten un mecanismo para generar datos de entrada aleatorios.  Este enfoque funciona especialmente bien para programas basados ‚Äã‚Äãen leyes matem√°ticas que sirven como propiedades universales que son v√°lidas para una amplia clase de programas.  Incluso hay una biblioteca de propiedades matem√°ticas preparadas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">disciplina</a> ) que le permite verificar el rendimiento de estas propiedades en nuevos programas (un buen ejemplo de reutilizaci√≥n de pruebas). </p><br><p>  A veces resulta que es necesario probar un programa complejo sin poder analizarlo en partes verificables independientemente.  En este caso, el programa de prueba es <del>  negro </del>  caja blanca (blanca, porque tenemos la oportunidad de estudiar la estructura interna del programa). </p><br><p>  Debajo del corte, se describen varios enfoques para probar programas complejos con una entrada con diferentes grados de complejidad (participaci√≥n) y diferentes grados de cobertura. </p><a name="habracut"></a><br><p>  * <em>En este art√≠culo, suponemos que el programa bajo prueba se puede representar como una funci√≥n pura sin un estado interno.</em>  <em>(Algunas de las siguientes consideraciones se pueden aplicar si el estado interno est√° presente, pero es posible restablecer este estado a un valor fijo).</em> </p><br><h3 id="testovyy-stend-test-bench">  Banco de pruebas </h3><br><p> En primer lugar, dado que solo se prueba una funci√≥n, cuyo c√≥digo de llamada es siempre el mismo, no necesitamos crear pruebas unitarias separadas.  Todas esas pruebas ser√≠an las mismas, precisas para la entrada y las comprobaciones.  Es suficiente transmitir los datos de origen ( <code>input</code> ) en un bucle y verificar los resultados ( <code>input</code> <code>expectedOutput</code> ).  Para identificar un conjunto problem√°tico de datos de prueba en caso de detecci√≥n de errores, todos los datos de prueba deben estar etiquetados.  Por lo tanto, un conjunto de datos de prueba se puede representar como un triple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  El resultado de una ejecuci√≥n se puede representar como <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Presentamos el resultado del lanzamiento usando <code>Try</code> detectar posibles excepciones). </p><br><p>  Para simplificar la ejecuci√≥n de todos los datos de prueba a trav√©s del programa bajo prueba, puede usar una funci√≥n auxiliar que llamar√° al programa para cada valor de entrada: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Esta funci√≥n auxiliar devolver√° los datos problem√°ticos y los resultados que son diferentes de lo esperado. </p><br><p>  Para mayor comodidad, puede formatear los resultados de la prueba. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  y mostrar un informe solo en caso de errores: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Preparaci√≥n de entrada </h3><br><p>  En el caso m√°s simple, puede crear manualmente datos de prueba para probar el programa, escribirlos directamente en el c√≥digo de prueba y usarlos, como se muestra arriba.  A menudo resulta que los casos interesantes de datos de prueba tienen mucho en com√∫n y pueden presentarse como una instancia b√°sica, con cambios menores. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Cuando se trabaja con estructuras de datos inmutables anidadas, las lentes son de gran ayuda, por ejemplo, de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monocle</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Las lentes le permiten "modificar" con elegancia las partes profundamente anidadas de las estructuras de datos: cada lente es un captador y configurador para una propiedad.  Las lentes se pueden combinar para producir lentes que se "enfoquen" en el siguiente nivel. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Usando DSL para presentar cambios </h3><br><p>  A continuaci√≥n, consideraremos la formaci√≥n de datos de prueba haciendo cambios en alg√∫n objeto de entrada inicial.  Por lo general, para obtener el objeto de prueba que necesitamos, necesitamos hacer algunos cambios.  Al mismo tiempo, es muy √∫til incluir una lista de cambios en la descripci√≥n del texto de TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Entonces siempre sabremos para qu√© datos de prueba se realiza la prueba. </p><br><p>  Para que la lista textual de cambios no difiera de los cambios reales, debe seguir el principio de "una √∫nica versi√≥n de la verdad".  (Si se requiere / utiliza la misma informaci√≥n en varios puntos, entonces deber√≠a haber una √∫nica fuente primaria de informaci√≥n √∫nica, y la informaci√≥n deber√≠a distribuirse a todos los dem√°s puntos de uso autom√°ticamente, con las transformaciones necesarias. Si se viola este principio y la copia manual de la informaci√≥n es inevitable . informaci√≥n de la versi√≥n discrepancia en diferentes puntos en otras palabras, en la descripci√≥n de los datos de prueba, que vemos uno, y datos de prueba -. otro ejemplo, la copia de un cambio <code>field2 = "456"</code> y realizar los ajustes en el <code>field3 = "789"</code> que Mauger  accidentalmente se olvide de corregir la descripci√≥n. Como resultado, la descripci√≥n reflejar√° solamente dos cambios de tres). </p><br><p>  En nuestro caso, la fuente principal de informaci√≥n son los cambios en s√≠ mismos, o m√°s bien, el c√≥digo fuente del programa que realiza los cambios.  Nos gustar√≠a deducir de ellos un texto que describe los cambios.  De manera informal, como primera opci√≥n, puede sugerir el uso de una macro que capturar√° el c√≥digo fuente de los cambios y usar el c√≥digo fuente como documentaci√≥n.  Aparentemente, esta es una forma buena y relativamente sencilla de documentar los cambios reales y bien puede aplicarse en algunos casos.  Desafortunadamente, si presentamos los cambios en texto plano, perdemos la capacidad de realizar transformaciones significativas de la lista de cambios.  Por ejemplo, detecte y elimine cambios duplicados o superpuestos, elabore una lista de cambios de una manera conveniente para el usuario final. </p><br><p>  Para poder manejar los cambios, debe tener un modelo estructurado de ellos.  El modelo debe ser lo suficientemente expresivo como para describir todos los cambios que nos interesan.  Parte de este modelo, por ejemplo, ser√° el direccionamiento de campos de objetos, constantes, operaciones de asignaci√≥n. </p><br><p>  El modelo de cambio deber√≠a permitir resolver las siguientes tareas: </p><br><ol><li>  Generar instancias de modelo de cambio.  (Es decir, crear una lista espec√≠fica de cambios). </li><li>  Formaci√≥n de una descripci√≥n textual de los cambios. </li><li>  Aplicaci√≥n de cambios a objetos de dominio. </li><li>  Realizando transformaciones de optimizaci√≥n en el modelo. </li></ol><br><p>  Si se usa un lenguaje de programaci√≥n universal para realizar cambios, puede ser dif√≠cil representar estos cambios en el modelo.  El c√≥digo fuente del programa puede usar construcciones complejas que no son compatibles con el modelo.  Dicho programa puede usar patrones secundarios, como lentes o el m√©todo de <code>copy</code> , para cambiar los campos de un objeto, que son abstracciones de nivel inferior en relaci√≥n con el nivel del modelo de cambio.  Como resultado, puede ser necesario un an√°lisis adicional de dichos patrones para generar instancias de cambios.  Por lo tanto, inicialmente una buena opci√≥n usando una macro no es muy conveniente. </p><br><p>  Otra forma de crear instancias del modelo de cambio puede ser un lenguaje especializado (DSL), que crea objetos de modelo de cambio utilizando un conjunto de m√©todos de extensi√≥n y operadores auxiliares.  Bueno, en los casos m√°s simples, las instancias del modelo de cambio se pueden crear directamente a trav√©s de los constructores. </p><br><div class="spoiler">  <b class="spoiler_title">Cambiar detalles del idioma</b> <div class="spoiler_text"><p>  El cambio de lenguaje es una construcci√≥n bastante compleja que incluye varios componentes que, a su vez, no son triviales. </p><br><ol><li>  Modelo de estructura de datos. </li><li>  Cambiar modelo </li><li>  DSL realmente integrado (?): Construcciones auxiliares, m√©todos de extensi√≥n, para la construcci√≥n conveniente de cambios. </li><li>  Un int√©rprete de cambios que le permite realmente "modificar" un objeto (de hecho, por supuesto, crear una copia modificada). </li></ol><br><p>  Aqu√≠ hay un ejemplo de un programa escrito usando DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Es decir, utilizando los m√©todos de extensi√≥n <code>\</code> y <code>:=</code> , <code>PropertyAccess</code> , los objetos <code>SetProperty</code> se forman a partir de los objetos <code>target</code> , <code>field1</code> , <code>subobject</code> , <code>field2</code> creados previamente.  Adem√°s, debido a las conversiones impl√≠citas (peligrosas), la cadena "123" est√° empaquetada en un <code>LiftedString</code> (puede hacerlo sin conversiones impl√≠citas y llamar expl√≠citamente al m√©todo correspondiente: <code>lift("123")</code> ). </p><br><p>  Una ontolog√≠a escrita puede usarse como modelo de datos (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/post/229035/</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/post/222553/</a> ).  (En resumen: se declaran objetos de nombre que representan las propiedades de cualquier tipo de dominio: <code>val field1: Property[Target, String]</code> ). En este caso, los datos reales se pueden almacenar, por ejemplo, en forma de JSON.  La conveniencia de una ontolog√≠a tipificada en nuestro caso radica en el hecho de que el modelo de cambio generalmente opera con propiedades individuales de los objetos, y la ontolog√≠a solo proporciona una herramienta adecuada para abordar las propiedades. </p><br><p>  Para representar los cambios, necesita un conjunto de clases del mismo plan que la clase <code>SetProperty</code> anterior: </p><br><ul><li>  <code>Modify</code> - aplicaci√≥n de la funci√≥n, </li><li>  <code>Changes</code> : aplicar m√∫ltiples cambios secuencialmente </li><li>  <code>ForEach</code> : aplique los cambios a cada elemento de la colecci√≥n, </li><li>  etc. </li></ul><br><p>  El int√©rprete de cambio de lenguaje es un evaluador de expresiones recursivas regular basado en PatternMatching.  Algo como: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Para operar directamente sobre las propiedades de los objetos, debe especificar getter y setter para cada propiedad utilizada en el modelo de cambio.  Esto se puede lograr completando el mapa entre las propiedades ontol√≥gicas y sus lentes correspondientes. </p></div></div><br><p>  Este enfoque en su conjunto funciona y, de hecho, le permite describir los cambios una vez, pero gradualmente es necesario representar cambios cada vez m√°s complejos y el modelo de cambios est√° creciendo un poco.  Por ejemplo, si necesita cambiar una propiedad utilizando el valor de otra propiedad del mismo objeto (por ejemplo, <code>field1 = field2 + 1</code> ), debe admitir variables en el nivel DSL.  Y si cambiar una propiedad no es trivial, a nivel DSL, se requiere soporte para expresiones y funciones aritm√©ticas. </p><br><h3 id="testirovanie-vetvey">  Prueba de rama </h3><br><p>  El c√≥digo de prueba puede ser lineal y, en general, un conjunto de datos de prueba es suficiente para comprender si funciona.  Si hay una rama ( <code>if-then-else</code> ), debe ejecutar el cuadro blanco al menos dos veces con diferentes datos de entrada para que ambas ramas se ejecuten.  El n√∫mero de conjuntos de datos de entrada suficientes para cubrir todas las ramas es aparentemente num√©ricamente igual a la complejidad ciclom√°tica del c√≥digo con ramas. </p><br><p>  ¬øC√≥mo formar todos los conjuntos de datos de entrada?  Como estamos tratando con un cuadro blanco, podemos aislar las condiciones de ramificaci√≥n y modificar el objeto de entrada dos veces para que en un caso se ejecute una rama, en el otro caso.  Considere un ejemplo: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Teniendo tal condici√≥n, podemos formar dos casos de prueba: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(En caso de que no se pueda crear uno de los escenarios de prueba, podemos suponer que se ha detectado un c√≥digo muerto y que la condici√≥n, junto con la rama correspondiente, se puede eliminar de forma segura).</em> </p><br><p>  Si se comprueban las propiedades independientes de un objeto en varias ramas, entonces es bastante simple formar un conjunto exhaustivo de objetos de prueba modificados que cubra completamente todas las combinaciones posibles. </p><br><div class="spoiler">  <b class="spoiler_title">DSL para formar todas las combinaciones de cambios</b> <div class="spoiler_text"><p>  Consideremos con m√°s detalle el mecanismo que permite formar todas las listas posibles de cambios que brindan una cobertura total de todas las sucursales.  Para usar la lista de cambios durante las pruebas, necesitamos combinar todos los cambios en un solo objeto, que enviaremos a la entrada del c√≥digo probado, es decir, se requiere soporte para la composici√≥n.  Para hacer esto, puede usar el DSL anterior para modelar cambios, y luego una simple lista de cambios es suficiente, o puede presentar un cambio como una funci√≥n de modificaci√≥n <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  entonces la cadena de cambios ser√° simplemente una composici√≥n de funciones: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  o, para obtener una lista de cambios: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Para registrar de forma compacta todos los cambios correspondientes a todas las ramas posibles, puede usar el DSL del siguiente nivel de abstracci√≥n, que simula la estructura del cuadro blanco probado: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Aqu√≠ la colecci√≥n de <code>tests</code> contiene cambios agregados correspondientes a todas las combinaciones posibles de ramas.  Un par√°metro de tipo <code>String</code> contendr√° todos los nombres de las condiciones y todas las descripciones de los cambios a partir de los cuales se forma la funci√≥n de cambio agregado.  Y el segundo elemento de un par de tipo <code>T =&gt; T</code> es solo la funci√≥n agregada de los cambios obtenidos como resultado de la composici√≥n de los cambios individuales. </p><br><p>  Para obtener los objetos modificados, debe aplicar todas las funciones de cambio agregado al objeto de l√≠nea de base: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  Como resultado, obtenemos una colecci√≥n de pares, y la l√≠nea describir√° los cambios aplicados, y el segundo elemento del par ser√° el objeto en el que se combinan todos estos cambios. </p><br><p>  Seg√∫n la estructura del modelo del c√≥digo probado en forma de √°rbol, las listas de cambios representar√°n la ruta desde la ra√≠z hasta las hojas de este √°rbol.  Por lo tanto, una parte significativa de los cambios se duplicar√°.  Puede deshacerse de esta duplicaci√≥n utilizando la opci√≥n DSL, en la que los cambios se aplican directamente al objeto de l√≠nea de base a medida que avanza por las ramas.  En este caso, se realizar√°n menos c√°lculos innecesarios. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Generaci√≥n autom√°tica de datos de prueba. </h3><br><p>  Como estamos tratando con una caja blanca, podemos ver todas las ramas.  Esto hace posible construir un modelo de l√≥gica contenido en un cuadro blanco y usar el modelo para generar datos de prueba.  Si el c√≥digo de prueba est√° escrito en Scala, puede, por ejemplo, usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">scalameta</a> para leer el c√≥digo, con la posterior conversi√≥n a un modelo l√≥gico.  Nuevamente, como en el tema previamente discutido de modelar la l√≥gica de los cambios, es dif√≠cil para nosotros modelar todas las posibilidades de un lenguaje universal.  Adem√°s, asumiremos que el c√≥digo probado se implementa utilizando un subconjunto limitado del idioma, o en otro idioma o DSL, que inicialmente es limitado.  Esto nos permite centrarnos en aquellos aspectos del lenguaje que nos interesan. </p><br><p>  Considere un ejemplo de c√≥digo que contiene una sola rama: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  La condici√≥n divide el conjunto de valores de <code>field1</code> en dos clases de equivalencia: <code>== "123"</code> y <code>!= "123"</code> .  Por lo tanto, todo el conjunto de datos de entrada tambi√©n se divide en dos clases de equivalencia con respecto a esta condici√≥n: <code>ClassCondition1IsTrue</code> y <code>ClassCondition1IsFalse</code> .  Desde el punto de vista de la cobertura completa, es suficiente que tomemos al menos un ejemplo de estas dos clases para cubrir ambas ramas <code>A</code> y <code>B</code>  Para la primera clase, podemos construir un ejemplo, en cierto sentido, de una manera √∫nica: tome un objeto aleatorio, pero cambie <code>field1</code> a <code>"123"</code> .  Adem√°s, el objeto ciertamente <code>ClassCondition1IsTrue</code> en la clase de equivalencia <code>ClassCondition1IsTrue</code> y los c√°lculos ir√°n a lo largo de la rama <code>A</code>  Hay m√°s ejemplos para la segunda clase.  Una forma de generar alg√∫n ejemplo de la segunda clase es generar objetos de entrada arbitrarios y descartar aquellos con <code>field1 == "123"</code> .  Otra forma: tomar un objeto aleatorio, pero cambie el <code>field1</code> a <code>"123" + "*"</code> (para modificar, puede usar cualquier cambio en la l√≠nea de control para asegurarse de que la nueva l√≠nea no sea igual a la l√≠nea de control). </p><br><p>  <a href=""><code>  Arbitrary</code> y <code>Gen</code> de la biblioteca ScalaCheck</a> son bastante adecuados como <a href=""><code>  Arbitrary</code></a> datos aleatorios. </p><br><p>  Esencialmente, <strong>llamamos a la</strong> funci√≥n booleana utilizada en la <code>if</code> .  Es decir, encontramos todos los valores del objeto de entrada para los cuales esta funci√≥n booleana toma el valor <code>true</code> - <code>ClassCondition1IsTrue</code> , y todos los valores del objeto de entrada para el cual toma el valor <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  De manera similar, es posible generar datos adecuados para las restricciones generadas por operadores condicionales simples con constantes (m√°s / menos que una constante, incluida en un conjunto, comienza con una constante).  Tales condiciones son f√°ciles de revertir.  Incluso si se invocan funciones simples en el c√≥digo de prueba, podemos reemplazar su llamada con su definici√≥n (en l√≠nea) y a√∫n invertir expresiones condicionales. </p><br><h4 id="trudno-obratimye-funkcii">  Funciones reversibles duras </h4><br><p>  La situaci√≥n es diferente cuando la condici√≥n usa una funci√≥n que es dif√≠cil de revertir.  Por ejemplo, si se utiliza una funci√≥n hash, no parece posible generar autom√°ticamente un ejemplo que proporcione el valor deseado del c√≥digo hash. </p><br><p>  En este caso, puede agregar un par√°metro adicional al objeto de entrada que represente el resultado del c√°lculo de la funci√≥n, reemplazar la llamada de funci√≥n con una llamada a este par√°metro y actualizar este par√°metro, a pesar de la violaci√≥n de la conexi√≥n funcional: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Un par√°metro adicional permite la ejecuci√≥n de c√≥digo dentro de la rama, pero, obviamente, puede conducir a resultados realmente incorrectos.  Es decir, el programa de prueba producir√° resultados que nunca se pueden observar en la realidad.  Sin embargo, verificar parte del c√≥digo que de otro modo ser√≠a inaccesible para nosotros sigue siendo √∫til y puede considerarse como una forma de prueba unitaria.  Despu√©s de todo, incluso durante las pruebas unitarias, se llama a una subfunci√≥n con argumentos que nunca se pueden usar en el programa. </p><br><p>  Con tales manipulaciones, reemplazamos (reemplazamos) el objeto de prueba.  Sin embargo, en cierto sentido, el programa reci√©n creado incluye la l√≥gica del programa anterior.  De hecho, si como valores de los nuevos par√°metros artificiales tomamos los resultados del c√°lculo de las funciones que reemplazamos con los par√°metros, el programa producir√° los mismos resultados.  Aparentemente, probar el programa modificado a√∫n puede ser de inter√©s.  Solo necesita recordar bajo qu√© condiciones el programa modificado se comportar√° igual que el original. </p><br><h4 id="zavisimye-usloviya">  Condiciones dependientes </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   ‚Äî <code>x &lt;= 1</code> .         ,           ‚Äî <code>(-‚àû, 0]</code> , <code>(0, 1]</code> , <code>(1, +‚àû)</code> , ‚Äî      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       ‚Äî <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         ‚Äî <code>true</code>  <code>false</code> .       .           .  Por ejemplo </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Conclusi√≥n </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Agradecimientos </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422283/">https://habr.com/ru/post/es422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422269/index.html">El libro "Dispositivo interno Windows. 7ma ed</a></li>
<li><a href="../es422273/index.html">No hay caminos est√∫pidos en una ciudad inteligente. ¬øQu√© es RWIS y c√≥mo reducir√° el costo del trabajo en la carretera?</a></li>
<li><a href="../es422275/index.html">Un empleado de Google pudo controlar el sistema de apertura de puertas en la oficina de la empresa debido a una vulnerabilidad de software</a></li>
<li><a href="../es422277/index.html">Arquitectura y programaci√≥n RCA Studio II</a></li>
<li><a href="../es422281/index.html">Servidor de datos A7: gesti√≥n de datos en l√≠nea</a></li>
<li><a href="../es422285/index.html">¬øPor qu√© las compras en l√≠nea tienen suficiente lealtad del 1% de los clientes?</a></li>
<li><a href="../es422291/index.html">Peque√±a caja negra (visualizaci√≥n de todo el dinero y los mercados mundiales)</a></li>
<li><a href="../es422293/index.html">Obtenci√≥n de la lista de alarmas de OSS a trav√©s de la interfaz AlarmIRP</a></li>
<li><a href="../es422297/index.html">La primera experiencia o c√≥mo tratar de convertirse en una leyenda del c√≥digo y la magia.</a></li>
<li><a href="../es422299/index.html">TsNIImash: SpaceX supuestamente implementa desarrollos sovi√©ticos. ¬øPor qu√© Ilon Mask tiene tantos enemigos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>