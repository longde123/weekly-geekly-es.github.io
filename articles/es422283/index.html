<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕍 🦒 🕺🏻 Prueba de caja blanca 🎑 🤹🏽 👶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El desarrollo de programas de alta calidad implica que el programa y sus partes se prueban. La prueba de unidad clásica implica dividir un programa gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba de caja blanca</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  El desarrollo de programas de alta calidad implica que el programa y sus partes se prueban.  La prueba de unidad clásica implica dividir un programa grande en bloques pequeños que son convenientes para la prueba.  O, si el desarrollo de las pruebas se lleva a cabo en paralelo con el desarrollo del código o las pruebas se desarrollan antes del programa (TDD - desarrollo impulsado por pruebas), el programa se desarrolla inicialmente en pequeños bloques adecuados para los requisitos de las pruebas. </p><br><p>  Una de las variedades de pruebas unitarias puede considerarse una prueba basada en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedad</a> (este enfoque se implementa, por ejemplo, en las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bibliotecas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScalaCheck</a> ).  Este enfoque se basa en encontrar propiedades universales que deberían ser válidas para cualquier dato de entrada.  Por ejemplo, la <em>serialización seguida de la deserialización debería producir el mismo objeto</em> .  O bien, la <em>reordenación no debería cambiar el orden de los elementos de la lista</em> .  Para verificar tales propiedades universales, las bibliotecas anteriores admiten un mecanismo para generar datos de entrada aleatorios.  Este enfoque funciona especialmente bien para programas basados ​​en leyes matemáticas que sirven como propiedades universales que son válidas para una amplia clase de programas.  Incluso hay una biblioteca de propiedades matemáticas preparadas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">disciplina</a> ) que le permite verificar el rendimiento de estas propiedades en nuevos programas (un buen ejemplo de reutilización de pruebas). </p><br><p>  A veces resulta que es necesario probar un programa complejo sin poder analizarlo en partes verificables independientemente.  En este caso, el programa de prueba es <del>  negro </del>  caja blanca (blanca, porque tenemos la oportunidad de estudiar la estructura interna del programa). </p><br><p>  Debajo del corte, se describen varios enfoques para probar programas complejos con una entrada con diferentes grados de complejidad (participación) y diferentes grados de cobertura. </p><a name="habracut"></a><br><p>  * <em>En este artículo, suponemos que el programa bajo prueba se puede representar como una función pura sin un estado interno.</em>  <em>(Algunas de las siguientes consideraciones se pueden aplicar si el estado interno está presente, pero es posible restablecer este estado a un valor fijo).</em> </p><br><h3 id="testovyy-stend-test-bench">  Banco de pruebas </h3><br><p> En primer lugar, dado que solo se prueba una función, cuyo código de llamada es siempre el mismo, no necesitamos crear pruebas unitarias separadas.  Todas esas pruebas serían las mismas, precisas para la entrada y las comprobaciones.  Es suficiente transmitir los datos de origen ( <code>input</code> ) en un bucle y verificar los resultados ( <code>input</code> <code>expectedOutput</code> ).  Para identificar un conjunto problemático de datos de prueba en caso de detección de errores, todos los datos de prueba deben estar etiquetados.  Por lo tanto, un conjunto de datos de prueba se puede representar como un triple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  El resultado de una ejecución se puede representar como <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Presentamos el resultado del lanzamiento usando <code>Try</code> detectar posibles excepciones). </p><br><p>  Para simplificar la ejecución de todos los datos de prueba a través del programa bajo prueba, puede usar una función auxiliar que llamará al programa para cada valor de entrada: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Esta función auxiliar devolverá los datos problemáticos y los resultados que son diferentes de lo esperado. </p><br><p>  Para mayor comodidad, puede formatear los resultados de la prueba. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  y mostrar un informe solo en caso de errores: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Preparación de entrada </h3><br><p>  En el caso más simple, puede crear manualmente datos de prueba para probar el programa, escribirlos directamente en el código de prueba y usarlos, como se muestra arriba.  A menudo resulta que los casos interesantes de datos de prueba tienen mucho en común y pueden presentarse como una instancia básica, con cambios menores. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Cuando se trabaja con estructuras de datos inmutables anidadas, las lentes son de gran ayuda, por ejemplo, de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monocle</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Las lentes le permiten "modificar" con elegancia las partes profundamente anidadas de las estructuras de datos: cada lente es un captador y configurador para una propiedad.  Las lentes se pueden combinar para producir lentes que se "enfoquen" en el siguiente nivel. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Usando DSL para presentar cambios </h3><br><p>  A continuación, consideraremos la formación de datos de prueba haciendo cambios en algún objeto de entrada inicial.  Por lo general, para obtener el objeto de prueba que necesitamos, necesitamos hacer algunos cambios.  Al mismo tiempo, es muy útil incluir una lista de cambios en la descripción del texto de TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Entonces siempre sabremos para qué datos de prueba se realiza la prueba. </p><br><p>  Para que la lista textual de cambios no difiera de los cambios reales, debe seguir el principio de "una única versión de la verdad".  (Si se requiere / utiliza la misma información en varios puntos, entonces debería haber una única fuente primaria de información única, y la información debería distribuirse a todos los demás puntos de uso automáticamente, con las transformaciones necesarias. Si se viola este principio y la copia manual de la información es inevitable . información de la versión discrepancia en diferentes puntos en otras palabras, en la descripción de los datos de prueba, que vemos uno, y datos de prueba -. otro ejemplo, la copia de un cambio <code>field2 = "456"</code> y realizar los ajustes en el <code>field3 = "789"</code> que Mauger  accidentalmente se olvide de corregir la descripción. Como resultado, la descripción reflejará solamente dos cambios de tres). </p><br><p>  En nuestro caso, la fuente principal de información son los cambios en sí mismos, o más bien, el código fuente del programa que realiza los cambios.  Nos gustaría deducir de ellos un texto que describe los cambios.  De manera informal, como primera opción, puede sugerir el uso de una macro que capturará el código fuente de los cambios y usar el código fuente como documentación.  Aparentemente, esta es una forma buena y relativamente sencilla de documentar los cambios reales y bien puede aplicarse en algunos casos.  Desafortunadamente, si presentamos los cambios en texto plano, perdemos la capacidad de realizar transformaciones significativas de la lista de cambios.  Por ejemplo, detecte y elimine cambios duplicados o superpuestos, elabore una lista de cambios de una manera conveniente para el usuario final. </p><br><p>  Para poder manejar los cambios, debe tener un modelo estructurado de ellos.  El modelo debe ser lo suficientemente expresivo como para describir todos los cambios que nos interesan.  Parte de este modelo, por ejemplo, será el direccionamiento de campos de objetos, constantes, operaciones de asignación. </p><br><p>  El modelo de cambio debería permitir resolver las siguientes tareas: </p><br><ol><li>  Generar instancias de modelo de cambio.  (Es decir, crear una lista específica de cambios). </li><li>  Formación de una descripción textual de los cambios. </li><li>  Aplicación de cambios a objetos de dominio. </li><li>  Realizando transformaciones de optimización en el modelo. </li></ol><br><p>  Si se usa un lenguaje de programación universal para realizar cambios, puede ser difícil representar estos cambios en el modelo.  El código fuente del programa puede usar construcciones complejas que no son compatibles con el modelo.  Dicho programa puede usar patrones secundarios, como lentes o el método de <code>copy</code> , para cambiar los campos de un objeto, que son abstracciones de nivel inferior en relación con el nivel del modelo de cambio.  Como resultado, puede ser necesario un análisis adicional de dichos patrones para generar instancias de cambios.  Por lo tanto, inicialmente una buena opción usando una macro no es muy conveniente. </p><br><p>  Otra forma de crear instancias del modelo de cambio puede ser un lenguaje especializado (DSL), que crea objetos de modelo de cambio utilizando un conjunto de métodos de extensión y operadores auxiliares.  Bueno, en los casos más simples, las instancias del modelo de cambio se pueden crear directamente a través de los constructores. </p><br><div class="spoiler">  <b class="spoiler_title">Cambiar detalles del idioma</b> <div class="spoiler_text"><p>  El cambio de lenguaje es una construcción bastante compleja que incluye varios componentes que, a su vez, no son triviales. </p><br><ol><li>  Modelo de estructura de datos. </li><li>  Cambiar modelo </li><li>  DSL realmente integrado (?): Construcciones auxiliares, métodos de extensión, para la construcción conveniente de cambios. </li><li>  Un intérprete de cambios que le permite realmente "modificar" un objeto (de hecho, por supuesto, crear una copia modificada). </li></ol><br><p>  Aquí hay un ejemplo de un programa escrito usando DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Es decir, utilizando los métodos de extensión <code>\</code> y <code>:=</code> , <code>PropertyAccess</code> , los objetos <code>SetProperty</code> se forman a partir de los objetos <code>target</code> , <code>field1</code> , <code>subobject</code> , <code>field2</code> creados previamente.  Además, debido a las conversiones implícitas (peligrosas), la cadena "123" está empaquetada en un <code>LiftedString</code> (puede hacerlo sin conversiones implícitas y llamar explícitamente al método correspondiente: <code>lift("123")</code> ). </p><br><p>  Una ontología escrita puede usarse como modelo de datos (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/post/229035/</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/post/222553/</a> ).  (En resumen: se declaran objetos de nombre que representan las propiedades de cualquier tipo de dominio: <code>val field1: Property[Target, String]</code> ). En este caso, los datos reales se pueden almacenar, por ejemplo, en forma de JSON.  La conveniencia de una ontología tipificada en nuestro caso radica en el hecho de que el modelo de cambio generalmente opera con propiedades individuales de los objetos, y la ontología solo proporciona una herramienta adecuada para abordar las propiedades. </p><br><p>  Para representar los cambios, necesita un conjunto de clases del mismo plan que la clase <code>SetProperty</code> anterior: </p><br><ul><li>  <code>Modify</code> - aplicación de la función, </li><li>  <code>Changes</code> : aplicar múltiples cambios secuencialmente </li><li>  <code>ForEach</code> : aplique los cambios a cada elemento de la colección, </li><li>  etc. </li></ul><br><p>  El intérprete de cambio de lenguaje es un evaluador de expresiones recursivas regular basado en PatternMatching.  Algo como: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Para operar directamente sobre las propiedades de los objetos, debe especificar getter y setter para cada propiedad utilizada en el modelo de cambio.  Esto se puede lograr completando el mapa entre las propiedades ontológicas y sus lentes correspondientes. </p></div></div><br><p>  Este enfoque en su conjunto funciona y, de hecho, le permite describir los cambios una vez, pero gradualmente es necesario representar cambios cada vez más complejos y el modelo de cambios está creciendo un poco.  Por ejemplo, si necesita cambiar una propiedad utilizando el valor de otra propiedad del mismo objeto (por ejemplo, <code>field1 = field2 + 1</code> ), debe admitir variables en el nivel DSL.  Y si cambiar una propiedad no es trivial, a nivel DSL, se requiere soporte para expresiones y funciones aritméticas. </p><br><h3 id="testirovanie-vetvey">  Prueba de rama </h3><br><p>  El código de prueba puede ser lineal y, en general, un conjunto de datos de prueba es suficiente para comprender si funciona.  Si hay una rama ( <code>if-then-else</code> ), debe ejecutar el cuadro blanco al menos dos veces con diferentes datos de entrada para que ambas ramas se ejecuten.  El número de conjuntos de datos de entrada suficientes para cubrir todas las ramas es aparentemente numéricamente igual a la complejidad ciclomática del código con ramas. </p><br><p>  ¿Cómo formar todos los conjuntos de datos de entrada?  Como estamos tratando con un cuadro blanco, podemos aislar las condiciones de ramificación y modificar el objeto de entrada dos veces para que en un caso se ejecute una rama, en el otro caso.  Considere un ejemplo: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Teniendo tal condición, podemos formar dos casos de prueba: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(En caso de que no se pueda crear uno de los escenarios de prueba, podemos suponer que se ha detectado un código muerto y que la condición, junto con la rama correspondiente, se puede eliminar de forma segura).</em> </p><br><p>  Si se comprueban las propiedades independientes de un objeto en varias ramas, entonces es bastante simple formar un conjunto exhaustivo de objetos de prueba modificados que cubra completamente todas las combinaciones posibles. </p><br><div class="spoiler">  <b class="spoiler_title">DSL para formar todas las combinaciones de cambios</b> <div class="spoiler_text"><p>  Consideremos con más detalle el mecanismo que permite formar todas las listas posibles de cambios que brindan una cobertura total de todas las sucursales.  Para usar la lista de cambios durante las pruebas, necesitamos combinar todos los cambios en un solo objeto, que enviaremos a la entrada del código probado, es decir, se requiere soporte para la composición.  Para hacer esto, puede usar el DSL anterior para modelar cambios, y luego una simple lista de cambios es suficiente, o puede presentar un cambio como una función de modificación <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  entonces la cadena de cambios será simplemente una composición de funciones: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  o, para obtener una lista de cambios: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Para registrar de forma compacta todos los cambios correspondientes a todas las ramas posibles, puede usar el DSL del siguiente nivel de abstracción, que simula la estructura del cuadro blanco probado: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Aquí la colección de <code>tests</code> contiene cambios agregados correspondientes a todas las combinaciones posibles de ramas.  Un parámetro de tipo <code>String</code> contendrá todos los nombres de las condiciones y todas las descripciones de los cambios a partir de los cuales se forma la función de cambio agregado.  Y el segundo elemento de un par de tipo <code>T =&gt; T</code> es solo la función agregada de los cambios obtenidos como resultado de la composición de los cambios individuales. </p><br><p>  Para obtener los objetos modificados, debe aplicar todas las funciones de cambio agregado al objeto de línea de base: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  Como resultado, obtenemos una colección de pares, y la línea describirá los cambios aplicados, y el segundo elemento del par será el objeto en el que se combinan todos estos cambios. </p><br><p>  Según la estructura del modelo del código probado en forma de árbol, las listas de cambios representarán la ruta desde la raíz hasta las hojas de este árbol.  Por lo tanto, una parte significativa de los cambios se duplicará.  Puede deshacerse de esta duplicación utilizando la opción DSL, en la que los cambios se aplican directamente al objeto de línea de base a medida que avanza por las ramas.  En este caso, se realizarán menos cálculos innecesarios. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Generación automática de datos de prueba. </h3><br><p>  Como estamos tratando con una caja blanca, podemos ver todas las ramas.  Esto hace posible construir un modelo de lógica contenido en un cuadro blanco y usar el modelo para generar datos de prueba.  Si el código de prueba está escrito en Scala, puede, por ejemplo, usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">scalameta</a> para leer el código, con la posterior conversión a un modelo lógico.  Nuevamente, como en el tema previamente discutido de modelar la lógica de los cambios, es difícil para nosotros modelar todas las posibilidades de un lenguaje universal.  Además, asumiremos que el código probado se implementa utilizando un subconjunto limitado del idioma, o en otro idioma o DSL, que inicialmente es limitado.  Esto nos permite centrarnos en aquellos aspectos del lenguaje que nos interesan. </p><br><p>  Considere un ejemplo de código que contiene una sola rama: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  La condición divide el conjunto de valores de <code>field1</code> en dos clases de equivalencia: <code>== "123"</code> y <code>!= "123"</code> .  Por lo tanto, todo el conjunto de datos de entrada también se divide en dos clases de equivalencia con respecto a esta condición: <code>ClassCondition1IsTrue</code> y <code>ClassCondition1IsFalse</code> .  Desde el punto de vista de la cobertura completa, es suficiente que tomemos al menos un ejemplo de estas dos clases para cubrir ambas ramas <code>A</code> y <code>B</code>  Para la primera clase, podemos construir un ejemplo, en cierto sentido, de una manera única: tome un objeto aleatorio, pero cambie <code>field1</code> a <code>"123"</code> .  Además, el objeto ciertamente <code>ClassCondition1IsTrue</code> en la clase de equivalencia <code>ClassCondition1IsTrue</code> y los cálculos irán a lo largo de la rama <code>A</code>  Hay más ejemplos para la segunda clase.  Una forma de generar algún ejemplo de la segunda clase es generar objetos de entrada arbitrarios y descartar aquellos con <code>field1 == "123"</code> .  Otra forma: tomar un objeto aleatorio, pero cambie el <code>field1</code> a <code>"123" + "*"</code> (para modificar, puede usar cualquier cambio en la línea de control para asegurarse de que la nueva línea no sea igual a la línea de control). </p><br><p>  <a href=""><code>  Arbitrary</code> y <code>Gen</code> de la biblioteca ScalaCheck</a> son bastante adecuados como <a href=""><code>  Arbitrary</code></a> datos aleatorios. </p><br><p>  Esencialmente, <strong>llamamos a la</strong> función booleana utilizada en la <code>if</code> .  Es decir, encontramos todos los valores del objeto de entrada para los cuales esta función booleana toma el valor <code>true</code> - <code>ClassCondition1IsTrue</code> , y todos los valores del objeto de entrada para el cual toma el valor <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  De manera similar, es posible generar datos adecuados para las restricciones generadas por operadores condicionales simples con constantes (más / menos que una constante, incluida en un conjunto, comienza con una constante).  Tales condiciones son fáciles de revertir.  Incluso si se invocan funciones simples en el código de prueba, podemos reemplazar su llamada con su definición (en línea) y aún invertir expresiones condicionales. </p><br><h4 id="trudno-obratimye-funkcii">  Funciones reversibles duras </h4><br><p>  La situación es diferente cuando la condición usa una función que es difícil de revertir.  Por ejemplo, si se utiliza una función hash, no parece posible generar automáticamente un ejemplo que proporcione el valor deseado del código hash. </p><br><p>  En este caso, puede agregar un parámetro adicional al objeto de entrada que represente el resultado del cálculo de la función, reemplazar la llamada de función con una llamada a este parámetro y actualizar este parámetro, a pesar de la violación de la conexión funcional: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Un parámetro adicional permite la ejecución de código dentro de la rama, pero, obviamente, puede conducir a resultados realmente incorrectos.  Es decir, el programa de prueba producirá resultados que nunca se pueden observar en la realidad.  Sin embargo, verificar parte del código que de otro modo sería inaccesible para nosotros sigue siendo útil y puede considerarse como una forma de prueba unitaria.  Después de todo, incluso durante las pruebas unitarias, se llama a una subfunción con argumentos que nunca se pueden usar en el programa. </p><br><p>  Con tales manipulaciones, reemplazamos (reemplazamos) el objeto de prueba.  Sin embargo, en cierto sentido, el programa recién creado incluye la lógica del programa anterior.  De hecho, si como valores de los nuevos parámetros artificiales tomamos los resultados del cálculo de las funciones que reemplazamos con los parámetros, el programa producirá los mismos resultados.  Aparentemente, probar el programa modificado aún puede ser de interés.  Solo necesita recordar bajo qué condiciones el programa modificado se comportará igual que el original. </p><br><h4 id="zavisimye-usloviya">  Condiciones dependientes </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   — <code>x &lt;= 1</code> .         ,           — <code>(-∞, 0]</code> , <code>(0, 1]</code> , <code>(1, +∞)</code> , —      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       — <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         — <code>true</code>  <code>false</code> .       .           .  Por ejemplo </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Conclusión </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Agradecimientos </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422283/">https://habr.com/ru/post/es422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422269/index.html">El libro "Dispositivo interno Windows. 7ma ed</a></li>
<li><a href="../es422273/index.html">No hay caminos estúpidos en una ciudad inteligente. ¿Qué es RWIS y cómo reducirá el costo del trabajo en la carretera?</a></li>
<li><a href="../es422275/index.html">Un empleado de Google pudo controlar el sistema de apertura de puertas en la oficina de la empresa debido a una vulnerabilidad de software</a></li>
<li><a href="../es422277/index.html">Arquitectura y programación RCA Studio II</a></li>
<li><a href="../es422281/index.html">Servidor de datos A7: gestión de datos en línea</a></li>
<li><a href="../es422285/index.html">¿Por qué las compras en línea tienen suficiente lealtad del 1% de los clientes?</a></li>
<li><a href="../es422291/index.html">Pequeña caja negra (visualización de todo el dinero y los mercados mundiales)</a></li>
<li><a href="../es422293/index.html">Obtención de la lista de alarmas de OSS a través de la interfaz AlarmIRP</a></li>
<li><a href="../es422297/index.html">La primera experiencia o cómo tratar de convertirse en una leyenda del código y la magia.</a></li>
<li><a href="../es422299/index.html">TsNIImash: SpaceX supuestamente implementa desarrollos soviéticos. ¿Por qué Ilon Mask tiene tantos enemigos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>