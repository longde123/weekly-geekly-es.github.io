<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüî¨ ‚èÆÔ∏è üöÄ Raycard-Entschl√ºsselung im Postkartenformat üà∏ üôÖüèª üëßüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Er hat es wieder getan!" - das ist mir als erstes eingefallen, als ich auf die R√ºckseite des Pixar-Flyers [1] schaute, der vollst√§ndig mit Code gef√ºl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raycard-Entschl√ºsselung im Postkartenformat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434528/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cr/xz/vj/crxzvjqqbw5gl4mv3wxxx2zw6wa.png"></div><br>  "Er hat es wieder getan!" - das ist mir als erstes eingefallen, als ich auf die R√ºckseite des Pixar-Flyers <sup>[1]</sup> schaute, der vollst√§ndig mit Code gef√ºllt war.  Eine Gruppe von Konstruktionen und Ausdr√ºcken wurde in der unteren rechten Ecke von niemand anderem als Andrew Kensler signiert.  F√ºr diejenigen, die ihn nicht kennen, sage ich: Andrew ist ein Programmierer, der 2009 einen 1337-Byte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Raytracer</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visitenkartengr√∂√üe</a> erfunden hat. <br><br>  Diesmal hatte Andrew etwas umfangreicheres, aber ein viel interessanteres visuelles Ergebnis.  Seit ich meine Game Engine Black Books √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolf3D</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DOOM</a> fertig geschrieben habe, hatte ich Zeit, die Innenseiten des kryptischen Codes zu lernen.  Und fast sofort war ich buchst√§blich fasziniert von den Techniken, die in ihm entdeckt wurden.  Sie unterschieden sich sehr von Andrews fr√ºheren Arbeiten, die auf einem "Standard" -Rochen-Tracer basierten.  Ich war daran interessiert, etwas √ºber Strahlenmarsch, Merkmale konstruktiver volumetrischer Geometrie, Monte-Carlo-Rendering / Pfadverfolgung sowie viele andere Tricks zu lernen, mit denen er Code in ein so kleines St√ºck Papier dr√ºckte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/z4/nt/ycz4ntg3qh91i6m2wymfccaekvk.png"></div><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lf/2o/qv/lf2oqvd5d39pyfwxyixvjnrmlqq.png"></div><br><h2>  Quellcode </h2><br><hr><br>  Die Vorderseite des Flyers ist eine Anzeige f√ºr die Personalabteilung von Pixar.  Auf der R√ºckseite sind 2.037 Bytes C ++ - Code gedruckt, der verschleiert ist, um die kleinstm√∂gliche Oberfl√§che zu belegen. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; // card &gt; pixar.ppm #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define R return #define O operator typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F c=0){x=a;y=b;z=c;}V O+(V r){RV(x+rx,y+ry,z+rz);}VO*(V r){RV(x*rx,y*r. y,z*rz);}FO%(V r){R x*r.x+y*r.y+z*rz;}VO!(){R*this*(1/sqrtf(*this%*this) );}};FL(F l,F r){R l&lt;r?l:r;}FU(){R(F)rand()/RAND_MAX;}FB(V p,V l,V h){l=p +l*-1;h=h+p*-1;RL(L(L(lx,hx),L(ly,hy)),L(lz,hz));}FS(V p,I&amp;m){F d=1\ e9;V f=p;fz=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\ eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l [i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\ rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,ox&gt;0?f\ absf(sqrtf(o%o)-2):(o.y+=oy&gt;0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(pz, 8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V (25,20,25))),B(V(fmodf(fabsf(px),8),py,pz),V(1.5,18.5,-25),V(6.5,20,25))) ;if(r&lt;d)d=r,m=2;F s=19.9-py;if(s&lt;d)d=s,m=3;R d;}IM(V o,V d,V&amp;h,V&amp;n){I m,s= 0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))&lt;.01||++s&gt;99)R n=!V(S(h+V(.01,0 ),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}VT(V o,V d){V h,n,r,t= 1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*( n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c), g=nz&lt;0?-1:1,u=-1/(g+nz),v=nx*ny*u;d=V(v,g+ny*ny*u,-ny)*(cosf(p)*s)+V( 1+g*nx*nx*u,g*v,-g*nx)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i&gt;0&amp;&amp;M(h +n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}} R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(gz, 0,-gx)*(1./w),u(gy*lz-gz*ly,gz*lx-gx*lz,gx*ly-gy*lx);printf("P\ 6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e ,!(g+l*(xw/2+U())+u*(yh/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(cx/ox,c. y/oy,cz/oz)*255;printf("%c%c%c",(I)cx,(I)cy,(I)cz);}}// Andrew Kensler</span></span></span></span></code> </pre> <br><h2>  Arbeitet er √ºberhaupt? </h2><br><hr><br>  Mit dem Code gibt es eine Anweisung f√ºr den Start.  Die Idee ist, die Standardausgabe in eine Datei umzuleiten.  In der Erweiterung k√∂nnen wir annehmen, dass das Ausgabeformat ein Textbildformat namens NetPBM <sup>[2] ist</sup> . <br><br><pre>  $ clang -o card2 -O3 raytracer.cpp
 $ time ./card&gt; pixar.ppm<font></font>
<font></font>
 echte 2m58.524s
 Benutzer 2m57.567s
 sys 0m0.415s </pre><br>  Nach zwei Minuten und achtundf√ºnfzig Sekunden <sup>[3]</sup> wird das folgende Bild erzeugt.  Es ist erstaunlich, wie wenig Code daf√ºr ben√∂tigt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/b34/b5c/caeb34b5c6c57c4598adc8f6b3f28f38.webp"></div><br>  Sie k√∂nnen viel aus dem obigen Bild extrahieren.  Grit ist ein offensichtliches Zeichen f√ºr einen "Pfad-Tracer".  Diese Art von Renderer unterscheidet sich von Raytracing dadurch, dass die Strahlen nicht auf die Lichtquellen zur√ºckgef√ºhrt werden.  Bei diesem Verfahren werden Tausende von Strahlen pro Pixel von den Quellen emittiert und vom Programm √ºberwacht, in der Hoffnung, dass sie die Lichtquelle finden.  Dies ist eine interessante Technik, die viel besser als Raytracing das Rendern von Umgebungsokklusion, weichen Schatten, √Ñtzmitteln und Radiosit√§t handhaben kann. <br><br><h2>  Wir werden den Code in Teile zerlegen </h2><br><hr><br>  Durch die √úbergabe der Eingabe an CLion wird der Code formatiert (siehe Ausgabe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) und in kleinere Teile / Aufgaben unterteilt. <br><br><pre>  <font color="grey">#include &lt;stdlib.h&gt; // card&gt; pixar.ppm</font> <font color="grey">
</font>  <font color="grey">#include &lt;stdio.h&gt;</font> <font color="grey">
</font>  <font color="grey">#include &lt;math.h&gt;</font> </pre><br><pre>  <font color="fuchsia">#define R return</font> <font color="fuchsia">
</font>  <font color="fuchsia">#define O Operator</font> <font color="fuchsia">
</font>  <font color="fuchsia">typedef float F; typedef int I;</font> </pre><pre>  <font color="blue">Struktur V {F x, y, z; V (F v = 0) {x = y = z = v;} V (F a, F b, F.</font> <font color="blue">
</font>  <font color="blue">c = 0) {x = a; y = b; z = c;} V O + (V r) {RV (x + rx, y + ry, z + rz);} VO * (V r) {RV ( x * rx, y * r.</font> <font color="blue">
</font>  <font color="blue">y, z * rz);} FO% (V r) {R x * r.x + y * r.y + z * rz;} VO! () {R * this * (1 / sqrtf (* this%) * this)</font> <font color="blue">
</font>  <font color="blue">);}};</font> </pre><pre>  <font color="orange">FL (F l, F r) {R l &lt;r? L: r;} FU () {R (F) rand () / RAND_MAX;} FB (V p, V l, V h) {l = p</font> <font color="orange">
</font>  <font color="orange">+ l * -1; h = h + p * -1; RL (L (L (L (lx, hx), L (ly, hy)), L (lz, hz));}</font> </pre><pre>  <font color="LimeGreen">FS (V p, I &amp; m) {F d = 1 \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">e9; V f = p; fz = 0; char l [] = "5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_] OWW [WaOa_aW \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">eWa_e_cWiO "; f√ºr (I i = 0; i &lt;60; i + = 4) {V b = V (l [i] -79, l [i + 1] -79) *. 5, e = V (l [ i + 2] -79, l</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">[i + 3] -79) *. 5 + b * -1, o = f + (b + e * L (-L ((b + f * -1)% e / (e% e), 0), 1)) * - 1; d = L (d, o% o);} d = sq \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">rtf (d); Va [] = {V (-11,6), V (11,6)}; f√ºr (I i = 2; i -;) {V o = f + a [i] * -1; d = L (d, ox&gt; 0? F \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">absf (sqrtf (o% o) -2) :( o.y + = oy&gt; 0 &amp; le; -2: 2, sqrtf (o% o));} d = powf (powf (d, 8) + powf (pz ,</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">8), 125) - 5; m = 1; F r = L (-L (B (p, V (-30, - 5, -30), V (30, 18, 30)), B. (p, V (-25,17, -25), V.</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">(25, 20, 25))), B (V (fmodf (fabsf (px), 8), py, pz), V (1,5, 18,5, -25), V (6,5, 20, 25)))</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">; wenn (r &lt;d) d = r, m = 2; F s = 19,9-py; wenn (s &lt;d) d = s, m = 3; R d;}</font> </pre><pre>  <font color="black">IM (V o, V d, V &amp; h, V &amp; n) {I m, s =</font> <font color="black">
</font>  <font color="black">0; F t = 0, c; f√ºr (; t &lt;100; t + = c) wenn ((c = S (h = o + d * t, m)) &lt;. 01 || ++ s&gt; 99) R. n =! V (S (h + V (0,01,0)</font> <font color="black">
</font>  <font color="black">), s) -c, S (h + V (0, 0,01), s) -c, S (h + V (0,0, 0,01), s) -c), m; R 0;}</font> </pre><pre>  <font color="SkyBlue">VT (V o, V d) {V h, n, r, t =</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1, l (! V (.6, .6,1)); f√ºr (I b = 3; b -;) {I m = M (o, d, h, n); wenn (! M) brechen ; wenn (m == 1) {d = d + n * (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">n% d * -2); o = h + d * .1; t = t * .2;} wenn (m == 2) {Fi = n% l, p = 6,283185 * U (), c = U (), s = sqrtf (1-c),</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">g = nz &lt;0? -1: 1, u = -1 / (g + nz), v = nx * ny * u; d = V (v, g + ny * ny * u, -ny) * (cosf (p) * s) + V (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 + g * nx * nx * u, g * v, -g * nx) * (sinf (p) * s) + n * sqrtf (c); o = h + d * 0,1; t = t *. 2; wenn (i&gt; 0 &amp;&amp; M (h</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">+ n * 0,1, l, h, n) == 3) r = r + t * V (500.400,100) * i;} wenn (m == 3) {r = r + t * V (50,80,100) ; break;}}</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">R r;}</font> </pre><pre>  <font color="red">I main () {I w = 960, h = 540, s = 16; V e (-22,5,25), g =! (V (-3,4,0) + e * -1), l =! V (gz,</font> <font color="red">
</font>  <font color="red">0, -gx) * (1./w), u (gy * lz-gz * ly, gz * lx-gx * lz, gx * ly-gy * lx); printf ("P \</font> <font color="red">
</font>  <font color="red">6% d% d 255 ", w, h); f√ºr (I y = h; y -;) f√ºr (I x = w; x -;) {V c; f√ºr (I p = s; p- -;) c = c + T (e</font> <font color="red">
</font>  <font color="red">,! (g + 1 * (xw / 2 + U ()) + u * (yh / 2 + U ())); c = c * (1./s) + 14./241; V o = c + 1; c = V (cx / ox, c.</font> <font color="red">
</font>  <font color="red">y / oy, cz / oz) * 255; printf ("% c% c% c", (I) cx, (I) cy, (I) cz);}}</font> </pre><pre>  <font color="LightGray">// Andrew Kensler</font> </pre><br>  Jeder der Abschnitte wird im Rest des Artikels ausf√ºhrlich beschrieben: <br>  <font color="fuchsia">‚ñ†</font> - gew√∂hnliche Tricks, <font color="blue">‚ñ†</font> - Vektorklasse, <font color="orange">‚ñ†</font> - Hilfscode, <font color="LimeGreen">‚ñ†</font> - Datenbank, <font color="black">‚ñ†</font> - Ray Marching, <font color="SkyBlue">‚ñ†</font> - Sampling, <font color="red">‚ñ†</font> - Hauptcode. <br><br><h2>  Allgemeine Tricks mit #define und typedef </h2><br><hr><br>  √úbliche Tricks sind die Verwendung von #define und typedef, um die Codemenge erheblich zu reduzieren.  Hier bezeichnen wir F = float, I = int, R = return und O = operator.  Reverse Engineering ist trivial. <br><br><h2>  Klasse v </h2><br><hr><br>  Als n√§chstes kommt die Klasse V, die ich in Vec umbenannt habe (obwohl sie, wie wir weiter unten sehen werden, auch zum Speichern von RGB-Kan√§len im Float-Format verwendet wird). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = y = z = v; } Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = a; y = b; z = c;} Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x + rx, y + ry, z + rz); } Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x * rx, y * ry, z * rz); } <span class="hljs-comment"><span class="hljs-comment">// dot product float operator%(Vec r) { return x * rx + y * ry + z * rz; } // inverse square root Vec operator!() {return *this * (1 / sqrtf(*this % *this) );} };</span></span></code> </pre> <br>  Beachten Sie, dass es keinen Subtraktionsoperator (-) gibt. Statt "X = A - B" zu schreiben, wird "X = A + B * -1" verwendet.  Die inverse Quadratwurzel ist sp√§ter n√ºtzlich, um die Vektoren zu normalisieren. <br><br><h2>  Hauptfunktion </h2><br><hr><br>  main () ist das einzige Zeichen, das nicht verschleiert werden kann, da es von der _start-Funktion der libc-Bibliothek aufgerufen wird.  Es lohnt sich normalerweise, damit zu beginnen, da es einfacher ist, auf diese Weise zu arbeiten.  Es dauerte eine Weile, bis ich die Bedeutung der ersten Buchstaben herausgefunden hatte, aber es gelang mir trotzdem, etwas Lesbares zu schaffen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">960</span></span>, h = <span class="hljs-number"><span class="hljs-number">540</span></span>, samplesCount = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-22</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vec goal = !(Vec(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + position * <span class="hljs-number"><span class="hljs-number">-1</span></span>); Vec left = !Vec(goal.z, <span class="hljs-number"><span class="hljs-number">0</span></span>, -goal.x) * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / w); <span class="hljs-comment"><span class="hljs-comment">// Cross-product to get the up vector Vec up(goal.y * left.z - goal.z * left.y, goal.z * left.x - goal.x * left.z, goal.x * left.y - goal.y * left.x); printf("P6 %d %d 255 ", w, h); for (int y = h; y--;) for (int x = w; x--;) { Vec color; for (int p = samplesCount; p--;) color = color + Trace(position, !(goal + left * (x - w / 2 + randomVal())+ up * (y - h / 2 + randomVal()))); // Reinhard tone mapping color = color * (1. / samplesCount) + 14. / 241; Vec o = color + 1; color = Vec(color.x / ox, color.y / oy, color.z / oz) * 255; printf("%c%c%c", (int) color.x, (int) color.y, (int) color.z); } }</span></span></code> </pre> <br>  Beachten Sie, dass Float-Literale nicht den Buchstaben ‚Äûf‚Äú enthalten und der Bruchteil aus Platzgr√ºnden verworfen wird.  Der gleiche Trick wird unten verwendet, wo der ganzzahlige Teil gel√∂scht wird (float x = .5).  Ungew√∂hnlich ist auch das Konstrukt "for" mit einem Iterationsausdruck, der in die Unterbrechungsbedingung eingef√ºgt wird. <br><br>  Dies ist eine ziemlich standardm√§√üige Hauptfunktion f√ºr einen Ray / Path-Tracer.  Hier werden Kameravektoren eingestellt und f√ºr jedes Pixel Strahlen ausgesendet.  Der Unterschied zwischen dem Ray Tracer und dem Path Tracer besteht darin, dass pro TP im TP mehrere Strahlen emittiert werden, die leicht zuf√§llig verschoben sind.  Dann wird die f√ºr jeden Strahl in einem Pixel erhaltene Farbe in drei Gleitkan√§len R, B, G akkumuliert.  Am Ende wird eine tonale Korrektur des Ergebnisses der Reinhardt-Methode durchgef√ºhrt. <br><br>  Der wichtigste Teil ist sampleCount, das theoretisch auf 1 gesetzt werden kann, um das Rendern und die Iteration zu beschleunigen.  Hier sind Beispiel-Renderings mit Beispielwerten von 1 bis 2048. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler √úberschrift</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/550/e66/b2b/550e66b2b1347f8cafdf18c50d89e40d.png"><br><br>  1 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/724/1f0/f497241f0e3bb43fcc9913d8a2745419.png"><br><br>  2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/3f3/35c/f713f335c2842b995936db1499e307e5.png"><br><br>  4 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/6d4/f56/b4f6d4f56198a64b8e569a62f7159e8a.png"><br><br>  8 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/200/3c6/a702003c61d4080c2f92fe84844238cd.png"><br><br>  16 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/0d6/43c/bcf0d643c501839c2506c7c026bc445c.png"><br><br>  32 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/5cf/569/8f05cf5690fa3265a1a4fa6f60a35749.png"><br><br>  64 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebd/c87/660/ebdc87660263ff14eb6bf03a95865f34.png"><br><br>  128 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0d3/1ae/d170d31aed20aeafc54d877ed447a1cc.png"><br><br>  256 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"><br><br>  512 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/50f/715/46050f71582834ddebbeb29dd86940fc.png"><br><br>  1024 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/ea8/88b/947ea888b63c32f0892cc1e25b187bf8.png"><br><br>  2048 </div></div><br><h2>  Hilfecode </h2><br><hr><br>  Ein weiterer einfacher Code sind Hilfsfunktionen.  In diesem Fall haben wir eine triviale Funktion min (), einen Zufallswertgenerator im Intervall [0,1] und einen viel interessanteren boxTest (), der Teil des CSG-Systems (Constructive Solid Geometry) ist, mit dem die Welt ausgeschnitten wird.  CSG wird im n√§chsten Abschnitt behandelt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r ? l : r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) rand() / RAND_MAX; } <span class="hljs-comment"><span class="hljs-comment">// Rectangle CSG equation. Returns minimum signed distance from // space carved by lowerLeft vertex and opposite rectangle // vertex upperRight. float BoxTest(Vec position, Vec lowerLeft, Vec upperRight) { lowerLeft = position + lowerLeft * -1; upperRight = upperRight + position * -1; return -min( min( min(lowerLeft.x, upperRight.x), min(lowerLeft.y, upperRight.y) ), min(lowerLeft.z, upperRight.z)); }</span></span></code> </pre> <br><h2>  Funktionen der konstruktiven Volumengeometrie </h2><br><hr><br>  Der Code enth√§lt keine Eckpunkte.  Alles wird mit CSG-Funktionen erledigt.  Wenn Sie mit ihnen nicht vertraut sind, sagen Sie einfach, dass dies Funktionen sind, die beschreiben, ob sich die Koordinate innerhalb oder au√üerhalb des Objekts befindet.  Wenn die Funktion einen positiven Abstand zur√ºckgibt, befindet sich der Punkt innerhalb des Objekts.  Ein negativer Abstand zeigt an, dass sich der Punkt au√üerhalb des Objekts befindet.  Es gibt viele Funktionen zum Beschreiben verschiedener Objekte. Zur Vereinfachung nehmen wir zum Beispiel eine Kugel und zwei Punkte, A und B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/424/13a/56f42413a77c51a3d06e12fd4b4b385e.svg" alt="Bild"></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to sphere(c,r) float testSphere(Vec p, Vec c, float r) { Vec delta = c - p; float distance = sqrtf(delta%delta); return radius - distance; } Vec A {4, 6}; Vec B {3, 2}; Vec C {4, 2}; float r = 2.; testSphere(A, C, r); // == -1 (outside) testSphere(B, C, r); // == 1 (inside)</span></span></code> </pre> <br>  Die Funktion testSphere () gibt -1 f√ºr Punkt A (dh au√üerhalb) und 1 f√ºr B (dh innen) zur√ºck.  Zeichen in Entfernungen sind nur ein Trick, mit dem Sie bei einem einzelnen Wert zwei Informationen anstelle von einer erhalten k√∂nnen.  Ein √§hnlicher Funktionstyp kann auch zur Beschreibung eines Parallelogramms geschrieben werden (genau dies wird in der Funktion BoxTest ausgef√ºhrt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/1cd/25b/7571cd25baa7d2f9cfbd01f62e84aef1.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to Box(c1,c2) float testRectangle(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testRectangle(A, C1, C2); // 1.41 (inside) testRectangle(B, C1, C2); // -2.23 (outside)</span></span></code> </pre> <br>  Nun wollen wir sehen, was passiert, wenn Sie das Vorzeichen des R√ºckgabewerts umdrehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/017/bd8/dcd017bd89a9e9d3955c94be3645aa20.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to carved box(c1,c2) float testCarveBox(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return -min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testCarveBox(A, C1, C2); // == -1.41 (outside) testCarveBox(B, C1, C2); // == 2.23 (inside)</span></span></code> </pre> <br>  Jetzt beschreiben wir kein festes Objekt, sondern erkl√§ren die ganze Welt f√ºr fest und schneiden darin leeren Raum aus.  Funktionen k√∂nnen als Bausteine ‚Äã‚Äãverwendet werden, die in Kombination komplexere Formen beschreiben k√∂nnen.  Mit dem logischen Additionsoperator (min-Funktion) k√∂nnen wir ein Paar Rechtecke √ºbereinander ausschneiden, und das Ergebnis sieht folgenderma√üen aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/f78/615/48bf786150f9d37af1f51fd12987162e.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point to room float testRoom(Vec p) { Vec C1 {2, 4}; Vec C2 {5, 2}; // Lower room Vec C3 {3, 5}; Vec C4 {4, 4}; // Upper room // min() is the union of the two carved volumes. return min(testCarvedBox(p, C1, C2), testCarvedBox(p, C3, C4)); } Vec A {3, 3}; Vec B {4, 6}; testRoom(A, C1, C2); // == -1.41 (outside) testRoom(B, C1, C2); // == 1.00 (inside)</span></span></code> </pre> <br>  Wenn Sie dar√ºber nachdenken, sieht es aus wie der Raum, den wir studieren, weil der untere Raum genau so ausgedr√ºckt wird - mit Hilfe von zwei geschnittenen Parallelogrammen. <br><br>  Nachdem wir nun die leistungsstarken Kenntnisse von CSG beherrschen, k√∂nnen wir zum Code zur√ºckkehren und die Datenbankfunktion betrachten, die am schwierigsten zu handhaben ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_NONE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_LETTER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_WALL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_SUN 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sample the world using Signed Distance Fields. float QueryDatabase(Vec position, int &amp;hitType) { float distance = 1e9; Vec f = position; // Flattened position (z=0) fz = 0; char letters[15*4+1] = // 15 two points lines "5O5_" "5W9W" "5_9_" // P (without curve) "AOEO" "COC_" "A_E_" // I "IOQ_" "I_QO" // X "UOY_" "Y_]O" "WW[W" // A "aOa_" "aWeW" "a_e_" "cWiO"; // R (without curve) for (int i = 0; i &lt; sizeof(letters); i += 4) { Vec begin = Vec(letters[i] - 79, letters[i + 1] - 79) * .5; Vec e = Vec(letters[i + 2] - 79, letters[i + 3] - 79) * .5 + begin * -1; Vec o = f + (begin + e * min(-min((begin + f * -1) % e / (e % e), 0), 1) ) * -1; distance = min(distance, o % o); // compare squared distance. } distance = sqrtf(distance); // Get real distance, not square distance. // Two curves (for P and R in PixaR) with hard-coded locations. Vec curves[] = {Vec(-11, 6), Vec(11, 6)}; for (int i = 2; i--;) { Vec o = f + curves[i] * -1; distance = min(distance, ox &gt; 0 ? fabsf(sqrtf(o % o) - 2) : (oy += oy &gt; 0 ? -2 : 2, sqrtf(o % o)) ); } distance = powf(powf(distance, 8) + powf(position.z, 8), .125) - .5; hitType = HIT_LETTER; float roomDist ; roomDist = min(// min(A,B) = Union with Constructive solid geometry //-min carves an empty space -min(// Lower room BoxTest(position, Vec(-30, -.5, -30), Vec(30, 18, 30)), // Upper room BoxTest(position, Vec(-25, 17, -25), Vec(25, 20, 25)) ), BoxTest( // Ceiling "planks" spaced 8 units apart. Vec(fmodf(fabsf(position.x), 8), position.y, position.z), Vec(1.5, 18.5, -25), Vec(6.5, 20, 25) ) ); if (roomDist &lt; distance) distance = roomDist, hitType = HIT_WALL; float sun = 19.9 - position.y ; // Everything above 19.9 is light source. if (sun &lt; distance)distance = sun, hitType = HIT_SUN; return distance; }</span></span></span></span></code> </pre> <br>  Sie k√∂nnen hier die Funktion des "Ausschneidens" des Parallelogramms sehen, bei dem nur zwei Rechtecke verwendet werden, um den gesamten Raum zu konstruieren (unser Gehirn erledigt den Rest, es repr√§sentiert W√§nde).  Die horizontale Leiter ist eine etwas komplexere CSG-Funktion unter Verwendung der Restteilung.  Und schlie√ülich bestehen die Buchstaben des Wortes PIXAR aus 15 Zeilen mit einem ‚ÄûUrsprung / Delta‚Äú -Paar und zwei Sonderf√§llen f√ºr Kurven in den Buchstaben P und R. <br><br><h2>  Ray marschiert </h2><br><hr><br>  Mit einer Datenbank von CSG-Funktionen, die die Welt beschreiben, reicht es aus, alle in der main () - Funktion emittierten Strahlen zu √ºberspringen.  Ray Marching verwendet die Distanzfunktion.  Dies bedeutet, dass sich die Probenahmeposition um eine Strecke nach vorne zum n√§chsten Hindernis verschiebt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Perform signed sphere marching // Returns hitType 0, 1, 2, or 3 and update hit position/normal int RayMarching(Vec origin, Vec direction, Vec &amp;hitPos, Vec &amp;hitNorm) { int hitType = HIT_NONE; int noHitCount = 0; float d; // distance from closest object in world. // Signed distance marching for (float total_d=0; total_d &lt; 100; total_d += d) if ((d = QueryDatabase(hitPos = origin + direction * total_d, hitType)) &lt; .01 || ++noHitCount &gt; 99) return hitNorm = !Vec(QueryDatabase(hitPos + Vec(.01, 0), noHitCount) - d, QueryDatabase(hitPos + Vec(0, .01), noHitCount) - d, QueryDatabase(hitPos + Vec(0, 0, .01), noHitCount) - d) , hitType; // Weird return statement where a variable is also updated. return 0; }</span></span></code> </pre> <br>  Die Idee des Strahlmarschierens basierend auf der Entfernung besteht darin, eine Entfernung vorw√§rts zum n√§chsten Objekt zu bewegen.  Am Ende n√§hert sich der Strahl der Oberfl√§che so sehr, dass er als Einfallspunkt angesehen werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e99/774/398/e997743989aa1cb22fb65e6d5d8e93f2.svg"></div><br>  Beachten Sie, dass Ray Marching keinen echten Schnittpunkt mit der Oberfl√§che zur√ºckgibt, sondern eine Ann√§herung.  Deshalb stoppt das Marschieren im Code, wenn d &lt;0,01f ist. <br><br><h2>  Alles zusammen: Sampling </h2><br><hr><br>  Die Untersuchung des Pfadverfolgers ist fast abgeschlossen.  Es fehlt eine Br√ºcke, die die main () - Funktion mit dem Ray Marcher verbindet.  Dieser letzte Teil, den ich in ‚ÄûSpur‚Äú umbenannt habe, ist das ‚ÄûGehirn‚Äú, in dem die Strahlen je nach Begegnung abprallen oder aufh√∂ren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec origin, Vec direction)</span></span></span><span class="hljs-function"> </span></span>{ Vec sampledPosition, normal, color, attenuation = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!Vec(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Directional light for (int bounceCount = 3; bounceCount--;) { int hitType = RayMarching(origin, direction, sampledPosition, normal); if (hitType == HIT_NONE) break; // No hit. This is over, return color. if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc. direction = direction + normal * ( normal % direction * -2); origin = sampledPosition + direction * 0.1; attenuation = attenuation * 0.2; // Attenuation via distance traveled. } if (hitType == HIT_WALL) { // Wall hit uses color yellow? float incidence = normal % lightDirection; float p = 6.283185 * randomVal(); float c = randomVal(); float s = sqrtf(1 - c); float g = normal.z &lt; 0 ? -1 : 1; float u = -1 / (g + normal.z); float v = normal.x * normal.y * u; direction = Vec(v, g + normal.y * normal.y * u, -normal.y) * (cosf(p) * s) + Vec(1 + g * normal.x * normal.x * u, g * v, -g * normal.x) * (sinf(p) * s) + normal * sqrtf(c); origin = sampledPosition + direction * .1; attenuation = attenuation * 0.2; if (incidence &gt; 0 &amp;&amp; RayMarching(sampledPosition + normal * .1, lightDirection, sampledPosition, normal) == HIT_SUN) color = color + attenuation * Vec(500, 400, 100) * incidence; } if (hitType == HIT_SUN) { // color = color + attenuation * Vec(50, 80, 100); break; // Sun Color } } return color; }</span></span></code> </pre> <br>  Ich habe ein wenig mit dieser Funktion experimentiert, um die maximal zul√§ssige Anzahl von Strahlreflexionen zu √§ndern.  Der Wert ‚Äû2‚Äú verleiht den Buchstaben eine √ºberraschend sch√∂ne lackierte Vantablack-Farbe <sup>[4]</sup> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/940/a3e/d10940a3ed7efab3271097904ce50d77.png"></div><br>  <i>1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/8b2/c3b/e0c8b2c3b249057b1f5fd0d166e12014.png"></div><br>  <i>2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"></div><br>  <i>3</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/2f5/716/65c2f5716578caaa2fcc454a49376578.png"></div><br>  <i>4</i> <br><br><h2>  Vollst√§ndig bereinigter Quellcode </h2><br><hr><br>  Um alles zusammenzusetzen, habe ich einen v√∂llig sauberen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode erstellt</a> . <br><br><h2>  Referenzen </h2><br><hr><br>  [1] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lexfrench Twitter-Beitrag am 8. Oktober 2018.</a> <br><br>  [2] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia: NetPBM-Bildformat</a> <br><br>  [3] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visualisierung auf dem leistungsst√§rksten MacBook Pro, 2017</a> <br><br>  [4] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia: Vantablack</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434528/">https://habr.com/ru/post/de434528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434514/index.html">"Geheimnisse" DPAPI oder DPAPI f√ºr Pentester</a></li>
<li><a href="../de434516/index.html">Eine einfache M√∂glichkeit, mit Ihren Karrierezielen umzugehen.</a></li>
<li><a href="../de434518/index.html">Applaus und Prost: sorgf√§ltig kontrolliertes Drama in Apple Stores</a></li>
<li><a href="../de434522/index.html">Aufgabenbegr√ºndungsmuster und Antimuster</a></li>
<li><a href="../de434524/index.html">Kubernetes Ingress mit den Augen eines Anf√§ngers</a></li>
<li><a href="../de434530/index.html">Standardkalender, Korrekturen in LDAP und andere Neuerungen in Zimbra 8.8.11</a></li>
<li><a href="../de434532/index.html">Die Geschichte eines Projekts: Wenn ein Team keinen leitenden Entwickler hat</a></li>
<li><a href="../de434534/index.html">ONYX BOOX ‚ÄûMein erstes Buch‚Äú: harmloses Lesen f√ºr Mama und Baby</a></li>
<li><a href="../de434538/index.html">Der Kampf um den Weltraum: Was passiert auf dem Satelliten-Internetmarkt?</a></li>
<li><a href="../de434540/index.html">Was tun mit Menschen, die durch Roboter ersetzt werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>