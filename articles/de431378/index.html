<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíâ ü•ë üëÇüèæ Die ganze Wahrheit √ºber RTOS. Artikel 23. Warteschlangen: Einf√ºhrung und Grundversorgung üåã üëî üåä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warteschlangen wurden in einem der vorherigen Artikel (Nr. 5) erw√§hnt. Sie bieten eine flexiblere M√∂glichkeit, einfache Nachrichten zwischen Aufgaben ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 23. Warteschlangen: Einf√ºhrung und Grundversorgung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431378/"><img src="https://habrastorage.org/webt/oy/fg/jv/oyfgjvk1xivp4zfhajjwfzycshs.jpeg"><br><br>  Warteschlangen wurden in einem der vorherigen Artikel (Nr. 5) erw√§hnt.  Sie bieten eine flexiblere M√∂glichkeit, einfache Nachrichten zwischen Aufgaben zu √ºbertragen als Postf√§cher. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br><br><h2>  Warteschlangen verwenden </h2><br>  In Nucleus SE werden Warteschlangen w√§hrend der Erstellungsphase definiert.  Eine Anwendung kann bis zu 16 Warteschlangen haben.  Wenn die Anwendung keine Warteschlangen enth√§lt, sind weder Datenstrukturen noch Dienstcode in Bezug auf Warteschlangen in der Anwendung enthalten. <br><br>  Eine Warteschlange ist eine Reihe von Bereichen im Speicher, die gro√ü genug f√ºr ein <b>Element vom</b> Typ <b>ADDR sind</b> und auf die sicher zugegriffen werden kann, damit mehrere Aufgaben sie verwenden k√∂nnen.  Aufgaben k√∂nnen Daten in die Warteschlange schreiben, bis alle Bereiche voll sind.  Aufgaben k√∂nnen Daten aus der Warteschlange lesen, wobei Daten normalerweise auf FIFO-Basis (First-in-First-Out) eingehen.  Der Versuch, Daten in eine √ºberf√ºllte Warteschlange zu schreiben oder Daten aus einer leeren Warteschlange zu lesen, kann abh√§ngig von den ausgew√§hlten API-Aufrufparametern und der Nucleus SE-Konfiguration zu einem Fehler oder einer Aufgabenpause f√ºhren. <br><br><h2>  Warteschlangen und Datenverbindungen </h2><br>  Nucleus SE unterst√ºtzt Datenkan√§le, die ebenfalls in einem fr√ºheren Artikel (Nr. 5) erw√§hnt wurden und in einem der folgenden Punkte ausf√ºhrlich erl√§utert werden.  Der Hauptunterschied zwischen Warteschlangen und Kan√§len ist die Gr√∂√üe der Nachricht.  Warteschlangen enthalten Nachrichten, die aus einer einzelnen Variablen vom Typ <b>ADDR bestehen</b> (normalerweise Zeiger).  Der Kanal enth√§lt Nachrichten beliebiger Gr√∂√üe, die f√ºr jeden Kanal in der Anwendung individuell sind und bei den Parametereinstellungen zugewiesen werden. <br><br><h2>  Warteschlangeneinstellung </h2><br><h3>  Anzahl der Warteschlangen </h3><br>  Wie bei den meisten Nucleus SE-Objekten wird die Warteschlangenkonfiguration haupts√§chlich durch die Direktiven <b>#define</b> in der Datei <b>nuse_config.h</b> gesteuert.  Der Hauptparameter ist <b>NUSE_QUEUE_NUMBER</b> , der die Anzahl der in der Anwendung konfigurierten Warteschlangen bestimmt.  Der Standardwert ist Null ( <b>dh</b> es gibt keine Warteschlangen in der Anwendung) und kann Werte bis 16 annehmen. Ein falscher Wert f√ºhrt zu einem Fehler beim Kompilieren, der w√§hrend der √úberpr√ºfung in der Datei <b>nuse_config_check.h generiert</b> wird (er ist in der Datei <b>nuse_config.c</b> enthalten und kompiliert zusammen mit ihm), wodurch die Direktive <b>#error ausgel√∂st wird</b> . <br><br>  Die Auswahl eines Werts ungleich Null dient als Hauptaktivator f√ºr die Warteschlangen.  Dieser Parameter wird beim Definieren von Datenstrukturen verwendet und ihre Gr√∂√üe h√§ngt von ihrem Wert ab (mehr dazu im n√§chsten Artikel).  Dar√ºber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE verf√ºgt √ºber die Direktive <b>#define</b> enable in <b>nuse_config.h</b> .  F√ºr Warteschlangen sind diese Anweisungen: <br><br><pre><code class="plaintext hljs">NUSE_QUEUE_SEND NUSE_QUEUE_RECEIVE NUSE_QUEUE_JAM NUSE_QUEUE_RESET NUSE_QUEUE_INFORMATION NUSE_QUEUE_COUNT</code> </pre> <br>  Standardm√§√üig sind sie auf <b>FALSE gesetzt</b> , wodurch alle Serviceaufrufe deaktiviert und die Aufnahme von Code blockiert werden, der sie implementiert.  Um die Warteschlangen in der Anwendung zu konfigurieren, m√ºssen Sie die erforderlichen API-Aufrufe ausw√§hlen und auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein <b>Codeausschnitt</b> aus der Datei <b>nuse_config.h</b> : <br><br><pre> <code class="plaintext hljs">#define NUSE_QUEUE_NUMBER 0 /* Number of queues in the system - 0-16 */ /* Service call enablers */ #define NUSE_QUEUE_SEND FALSE #define NUSE_QUEUE_RECEIVE FALSE #define NUSE_QUEUE_JAM FALSE #define NUSE_QUEUE_RESET FALSE #define NUSE_QUEUE_INFORMATION FALSE #define NUSE_QUEUE_COUNT FALSE</code> </pre><br>  Wenn die Funktionen der Warteschlangen-API aktiviert sind, die Anwendung jedoch keine Warteschlangen enth√§lt (mit Ausnahme von <b>NUSE_Queue_Count ()</b> , das immer aktiviert ist), wird ein Kompilierungsfehler <b>angezeigt</b> .  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, f√ºhrt dies zu einem Layoutfehler, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Anrufwarteschlange </h2><br>  Nucleus RTOS unterst√ºtzt zehn Warteschlangendienstaufrufe mit den folgenden Funktionen: <br><br><ul><li>  Eine Nachricht in die Warteschlange stellen.  Nucleus SE ist in der Funktion <b>NUSE_Queue_Send ()</b> implementiert. </li><li>  Akzeptieren einer Nachricht aus der Warteschlange.  Nucleus SE implementiert die Funktion <b>NUSE_Queue_Receive ()</b> . </li><li>  Posting an den Kopf der Warteschlange.  In Nucleus SE, implementiert in <b>NUSE_Queue_Jam ()</b> . </li><li>  Wiederherstellen eines nicht verwendeten Status der Warteschlange mit Freigabe aller angehaltenen Aufgaben (Zur√ºcksetzen).  Nucleus SE ist in <b>NUSE_Queue_Reset ()</b> implementiert. </li><li>  Bereitstellung von Informationen zu einer bestimmten Warteschlange.  Nucleus SE in <b>NUSE_Queue_Information ()</b> implementiert. </li><li>  Gibt die Anzahl der aktuell in der Anwendung konfigurierten Warteschlangen zur√ºck.  In Nucleus SE, implementiert in <b>NUSE_Queue_Count ()</b> . </li><li>  Hinzuf√ºgen einer neuen Warteschlange zur Anwendung (Erstellen einer Warteschlange).  Nucleus SE ist nicht implementiert. </li><li>  Entfernen einer Warteschlange aus einer Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  Geben Sie Zeiger auf alle Warteschlangen in der Anwendung zur√ºck.  Nucleus SE ist nicht implementiert. </li><li>  Senden einer Nachricht an alle in der Warteschlange angehaltenen Aufgaben (Broadcast).  Nucleus SE ist nicht implementiert. </li></ul><br>  Die Implementierung jedes dieser Overhead-Aufrufe wird nachstehend ausf√ºhrlich beschrieben. <br><br><h2>  Service ruft zum Schreiben und Lesen aus Warteschlangen auf </h2><br>  Die grundlegenden Operationen, die an den Warteschlangen ausgef√ºhrt werden, sind Schreiben (was manchmal als Warteschlangennachrichten bezeichnet wird) und Lesen (auch als Empfangen von Nachrichten bezeichnet).  Es ist auch m√∂glich, an den Anfang der Warteschlange zu schreiben (Jamming).  Nucleus RTOS und Nucleus SE bieten drei grundlegende API-Aufrufe f√ºr diese Operationen, die nachfolgend erl√§utert werden. <br><br><h3>  Anstehen </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben in die Warteschlange ist sehr flexibel und erm√∂glicht es Ihnen, die Aufgabe implizit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. beim Versuch, in eine vollst√§ndige Warteschlange zu schreiben).  Nucleus SE bietet dieselben Funktionen, die Unterbrechung der Aufgabe ist jedoch optional und eine Zeit√ºberschreitung ist nicht implementiert. <br><br>  <b><i>Anrufwarteschlange in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Queue (NU_QUEUE * Warteschlange, VOID * Nachricht, UNSIGNED Gr√∂√üe, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf den vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Gr√∂√üe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Wenn die Warteschlange Nachrichten mit variabler L√§nge unterst√ºtzt, muss dieser Parameter der Gr√∂√üe der Nachricht entsprechen oder kleiner als die von der Warteschlange unterst√ºtzte Nachrichtengr√∂√üe sein.  Wenn die Warteschlange Nachrichten mit fester Gr√∂√üe unterst√ºtzt, muss dieser Parameter genau mit der von der Warteschlange unterst√ºtzten Nachrichtengr√∂√üe √ºbereinstimmen. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder einen Timeout-Wert <b>annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengr√∂√üe ist nicht mit der von der Warteschlange unterst√ºtzten Nachrichtengr√∂√üe kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Die Suspendierung wurde von einem nicht aufgabenbezogenen Thread durchgef√ºhrt. <br>  <b>NU_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Die Warteschlange ist auch dann voll, wenn die Aufgabe f√ºr das angegebene Zeitlimit angehalten wurde. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Einreihen einer Nachricht in Nucleus SE</i></b> <br>  Dieser API-Serviceaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Send (NUSE_QUEUE-Warteschlange, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - <b>Warteschlangenindex</b> (ID); <br>  <b>message</b> - ein Zeiger auf die zu sendende Nachricht; es ist eine Variable vom Typ <b>ADDR</b> ; <br>  <b>suspend</b> - Spezifikation zum Anhalten von Aufgaben, kann die Werte <b>NUSE_NO_SUSPEND oder NUSE_SUSPEND annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Versuch, eine Aufgabe von einem Thread <b>anzuhalten, der</b> nicht mit der Aufgabe verkn√ºpft ist, oder wenn API-Dienstaufrufe deaktiviert sind, um Aufgaben zu blockieren. <br>  <b>NUSE_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NUSE_QUEUE_WAS_RESET</b> - Die Warteschlange wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Implementieren Sie Queuing in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Queue_Send ()</b> (nach √úberpr√ºfung der Parameter) wird mithilfe der bedingten Kompilierung ausgew√§hlt, je nachdem, ob die Unterst√ºtzung f√ºr das Sperren von Aufgaben aktiviert ist oder nicht.  Wir werden beide Optionen pr√ºfen. <br><br>  Wenn die Task-Sperre nicht aktiviert ist, ist der Code f√ºr diesen Serviceabruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion pr√ºft einfach, ob in der Warteschlange freier Speicherplatz vorhanden ist, und speichert die Nachricht mithilfe des <b>NUSE_Queue_Head []</b> -Index im Datenbereich der Warteschlange. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_FULL; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* queue element available */ NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erl√§uterungen k√∂nnen hilfreich sein. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgef√ºhrt wird, w√§hrend der Parameter f√ºr die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn die Warteschlange voll ist und <b>suspend</b> <b>NUSE_NO_SUSPEND ist</b> , endet der API-Aufruf mit <b>NUSE_QUEUE_FULL</b> .  Wenn der Suspend-Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird), wenn der R√ºckgabewert <b>NUSE_SUCCESS</b> lautet, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gelesen wurde (und nicht, weil die Warteschlange zur√ºckgesetzt wurde), kehrt der Code zum Anfang der Schleife zur√ºck. <br>  Wenn die Warteschlange nicht voll ist, wird die bereitgestellte Nachricht mithilfe des Index <b>NUSE_Queue_Head []</b> im Datenbereich der Warteschlange gespeichert.  Es wird √ºberpr√ºft, ob sich angehaltene Aufgaben (wartende Nachrichten) in der Warteschlange befinden.  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die Suspend-Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Wert <b>NUSE_SUCCESS abgeschlossen</b> . <br><br><h3>  Lesen aus der Warteschlange </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Lesen aus der Warteschlange ist sehr flexibel und erm√∂glicht es Ihnen, Aufgaben implizit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. beim Versuch, aus einer leeren Warteschlange zu lesen).  Nucleus SE bietet die gleiche Funktionalit√§t, aber die Unterbrechung der Aufgabe ist optional und eine Zeit√ºberschreitung ist nicht implementiert. <br><br>  <b><i>Rufen Sie an, um Nachrichten aus der Warteschlange in Nucleus RTOS zu empfangen</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Receive_From_Queue (NU_QUEUE * Warteschlange, VOID * -Nachricht, UNSIGNED-Gr√∂√üe, UNSIGNED * actual_size, UNSIGNED suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf den vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>Nachricht</b> - ein Zeiger auf den Speicher f√ºr empfangene Nachrichten; <br>  <b>Gr√∂√üe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Diese Nummer sollte mit der Nachrichtengr√∂√üe √ºbereinstimmen, die beim Erstellen der Warteschlange definiert wurde. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder einen Timeout-Wert <b>annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND -</b> Versuch, eine Aufgabe von einem Thread <b>anzuhalten</b> , der nicht mit der Aufgabe zusammenh√§ngt; <br>  <b>NU_QUEUE_EMPTY</b> - Die Warteschlange ist leer und die Aussetzung wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - <b>Gibt</b> an, dass die Warteschlange auch nach dem <b>Anhalten</b> der Aufgabe f√ºr einen bestimmten Zeitraum noch leer ist. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Rufen Sie an, um Nachrichten von der Nucleus SE-Warteschlange zu empfangen</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Receive (NUSE_QUEUE-Warteschlange, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - <b>Warteschlangenindex</b> (ID); <br>  <b>message</b> - ein Zeiger auf das Repository f√ºr empfangene Nachrichten; es ist eine Variable vom Typ <b>ADDR</b> ; <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - ein Versuch, eine Aufgabe in einem Thread <b>anzuhalten, der</b> nicht mit der Aufgabe verkn√ºpft ist oder dessen Unterst√ºtzung f√ºr das Blockieren von Aufgaben deaktiviert ist; <br>  <b>NUSE_QUEUE_EMPTY</b> - Die Warteschlange ist leer und die Aussetzung wurde nicht angegeben. <br>  <b>NUSE_QUEUE_WAS_RESET</b> - Die Warteschlange wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Implementierung des Empfangs von Nachrichten aus Warteschlangen in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Queue_Receive ()</b> (nach √úberpr√ºfung der Parameter) wird mithilfe der bedingten Kompilierung ausgew√§hlt, je nachdem, ob die Unterst√ºtzung f√ºr das Sperren von Aufgaben aktiviert ist oder nicht.  Betrachten Sie beide Optionen. <br><br>  Wenn die Sperrunterst√ºtzung aktiviert ist, ist der Code f√ºr diesen API-Aufruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { return_value = NUSE_QUEUE_EMPTY; } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion pr√ºft einfach, ob sich eine Nachricht in der Warteschlange befindet, und verwendet den Index <b>NUSE_Queue_Tail []</b> , um die Nachricht aus der Warteschlange abzurufen und Daten mithilfe eines Zeigers auf die Nachricht zur√ºckzugeben. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_EMPTY; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked */ /* on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erl√§uterungen sind hilfreich. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgef√ºhrt wird, w√§hrend der Parameter f√ºr die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn die Warteschlange leer ist und suspend <b>NUSE_NO_SUSPEND ist</b> , endet der API-Aufruf mit <b>NUSE_QUEUE_EMPTY</b> .  Wenn der <b>Suspend-</b> Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird), wenn der R√ºckgabewert <b>NUSE_SUCCESS</b> ist, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gesendet wurde (und nicht, weil die Warteschlange zur√ºckgesetzt wurde), kehrt der Code zum Anfang der Schleife zur√ºck. <br><br>  Wenn die Warteschlange Nachrichten enth√§lt, wird die gespeicherte Nachricht mithilfe des Index <b>NUSE_Queue_Tail [] zur√ºckgegeben</b> .  Es wird √ºberpr√ºft, ob in dieser Warteschlange angehaltene (ausstehende) Aufgaben vorhanden sind.  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die Suspend-Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Code <b>NUSE_SUCCESS</b> beendet. <br><br><h3>  Schreiben Sie an den Kopf der Warteschlange </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben einer Nachricht in den Warteschlangenkopf ist sehr flexibel und erm√∂glicht es Ihnen, die Aufgabe implizit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. beim Versuch, in eine √ºberf√ºllte Warteschlange zu schreiben).  Nucleus SE bietet die gleiche Funktionalit√§t, aber die Unterbrechung der Aufgabe ist optional und ein Timeout ist nicht implementiert. <br><br>  <b><i>Rufen Sie an, um eine Nachricht an den Kopf der Nucleus RTOS-Warteschlange zu schreiben</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Front_Of_Queue (NU_QUEUE * Warteschlange, VOID * Nachricht, UNSIGNED Gr√∂√üe, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf den vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Gr√∂√üe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Wenn die Warteschlange Nachrichten mit variabler L√§nge unterst√ºtzt, muss dieser Parameter der Nachrichtengr√∂√üe entsprechen oder kleiner als die von der Warteschlange unterst√ºtzte Nachrichtengr√∂√üe sein.  Wenn die Warteschlange Nachrichten fester L√§nge unterst√ºtzt, muss dieser Parameter genau mit der Gr√∂√üe der von der Warteschlange unterst√ºtzten Nachricht √ºbereinstimmen. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder einen Timeout-Wert <b>annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengr√∂√üe ist nicht mit der Gr√∂√üe der von der Warteschlange unterst√ºtzten Nachricht kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, eine Pause von einem Nicht-Task-Flow <b>einzulegen</b> <br>  <b>NU_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Die Warteschlange ist voll, auch nachdem die Aufgabe f√ºr eine bestimmte Zeit unterbrochen wurde. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Ein Aufruf zum Schreiben einer Nachricht an den Kopf einer Warteschlange in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Jam (NUSE_QUEUE-Warteschlange, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - <b>Warteschlangenindex</b> (ID); <br>  <b>Nachricht</b> - Ein Zeiger auf eine Nachricht ist eine Variable vom Typ <b>ADDR</b> . <br>  <b>suspend</b> - Die Angabe f√ºr die Suspendierung der Aufgabe kann <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND sein</b> <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - ein Versuch, eine Aufgabe in einem Thread <b>anzuhalten, der</b> nicht mit der Aufgabe verkn√ºpft ist oder dessen Unterst√ºtzung f√ºr das Blockieren von Aufgaben deaktiviert ist; <br>  <b>NUSE_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NUSE_QUEUE_WAS_RESET</b> - Die Warteschlange wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Implementieren eines Warteschlangen-Top-Datensatzes in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Queue_Jam () ist NUSE_Queue_Send ()</b> sehr √§hnlich. Nur die Daten werden mithilfe des <b>NUSE_Queue_Tail []</b> -Index gespeichert. <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { if (NUSE_Queue_Tail[queue] == 0) { NUSE_Queue_Tail[queue] = NUSE_Queue_Size[queue] - 1; } else { NUSE_Queue_Tail[queue]--; } NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]] = *message; NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Der n√§chste Artikel befasst sich mit zus√§tzlichen API-Aufrufen, die Warteschlangen zugeordnet sind, sowie mit Datenstrukturen. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431378/">https://habr.com/ru/post/de431378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431362/index.html">Wie kann ein Designer die Routine loswerden und das Interesse an seinem Job behalten?</a></li>
<li><a href="../de431370/index.html">Die schnellsten Berichte im wilden Westen. Und noch eine Handvoll Bugs ...</a></li>
<li><a href="../de431372/index.html">Interrupts von externen Ger√§ten in einem x86-System. Teil 2. Startoptionen f√ºr den Linux-Kernel</a></li>
<li><a href="../de431374/index.html">Letztes Urteil: Analyse der Finanzindikatoren des Spiels beim fr√ºhen Zugriff</a></li>
<li><a href="../de431376/index.html">Datenmigration im blutigen Unternehmen: Was zu analysieren ist, um das Projekt nicht zu √ºberfordern</a></li>
<li><a href="../de431380/index.html">Mitap Netologiya und Skyeng √ºber Soft Skills ‚ÄûWas ein Entwickler au√üer Code wissen muss‚Äú</a></li>
<li><a href="../de431382/index.html">Ergebnisse der JVM-√ñkosystemumfrage</a></li>
<li><a href="../de431384/index.html">CLion 2018.3: Remote-Entwicklung, Code-Profilerstellung, Leistung und mehr</a></li>
<li><a href="../de431388/index.html">Die Welt mit den Augen eines Autos. Wie sehen ihn Drohnen?</a></li>
<li><a href="../de431390/index.html">Digitale Trends 2019 und ihre Auswirkungen auf das ver√§nderte Verbraucherverhalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>