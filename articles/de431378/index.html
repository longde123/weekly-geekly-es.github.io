<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💉 🥑 👂🏾 Die ganze Wahrheit über RTOS. Artikel 23. Warteschlangen: Einführung und Grundversorgung 🌋 👔 🌊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warteschlangen wurden in einem der vorherigen Artikel (Nr. 5) erwähnt. Sie bieten eine flexiblere Möglichkeit, einfache Nachrichten zwischen Aufgaben ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel 23. Warteschlangen: Einführung und Grundversorgung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431378/"><img src="https://habrastorage.org/webt/oy/fg/jv/oyfgjvk1xivp4zfhajjwfzycshs.jpeg"><br><br>  Warteschlangen wurden in einem der vorherigen Artikel (Nr. 5) erwähnt.  Sie bieten eine flexiblere Möglichkeit, einfache Nachrichten zwischen Aufgaben zu übertragen als Postfächer. <br><a name="habracut"></a><br>  Frühere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br><br><h2>  Warteschlangen verwenden </h2><br>  In Nucleus SE werden Warteschlangen während der Erstellungsphase definiert.  Eine Anwendung kann bis zu 16 Warteschlangen haben.  Wenn die Anwendung keine Warteschlangen enthält, sind weder Datenstrukturen noch Dienstcode in Bezug auf Warteschlangen in der Anwendung enthalten. <br><br>  Eine Warteschlange ist eine Reihe von Bereichen im Speicher, die groß genug für ein <b>Element vom</b> Typ <b>ADDR sind</b> und auf die sicher zugegriffen werden kann, damit mehrere Aufgaben sie verwenden können.  Aufgaben können Daten in die Warteschlange schreiben, bis alle Bereiche voll sind.  Aufgaben können Daten aus der Warteschlange lesen, wobei Daten normalerweise auf FIFO-Basis (First-in-First-Out) eingehen.  Der Versuch, Daten in eine überfüllte Warteschlange zu schreiben oder Daten aus einer leeren Warteschlange zu lesen, kann abhängig von den ausgewählten API-Aufrufparametern und der Nucleus SE-Konfiguration zu einem Fehler oder einer Aufgabenpause führen. <br><br><h2>  Warteschlangen und Datenverbindungen </h2><br>  Nucleus SE unterstützt Datenkanäle, die ebenfalls in einem früheren Artikel (Nr. 5) erwähnt wurden und in einem der folgenden Punkte ausführlich erläutert werden.  Der Hauptunterschied zwischen Warteschlangen und Kanälen ist die Größe der Nachricht.  Warteschlangen enthalten Nachrichten, die aus einer einzelnen Variablen vom Typ <b>ADDR bestehen</b> (normalerweise Zeiger).  Der Kanal enthält Nachrichten beliebiger Größe, die für jeden Kanal in der Anwendung individuell sind und bei den Parametereinstellungen zugewiesen werden. <br><br><h2>  Warteschlangeneinstellung </h2><br><h3>  Anzahl der Warteschlangen </h3><br>  Wie bei den meisten Nucleus SE-Objekten wird die Warteschlangenkonfiguration hauptsächlich durch die Direktiven <b>#define</b> in der Datei <b>nuse_config.h</b> gesteuert.  Der Hauptparameter ist <b>NUSE_QUEUE_NUMBER</b> , der die Anzahl der in der Anwendung konfigurierten Warteschlangen bestimmt.  Der Standardwert ist Null ( <b>dh</b> es gibt keine Warteschlangen in der Anwendung) und kann Werte bis 16 annehmen. Ein falscher Wert führt zu einem Fehler beim Kompilieren, der während der Überprüfung in der Datei <b>nuse_config_check.h generiert</b> wird (er ist in der Datei <b>nuse_config.c</b> enthalten und kompiliert zusammen mit ihm), wodurch die Direktive <b>#error ausgelöst wird</b> . <br><br>  Die Auswahl eines Werts ungleich Null dient als Hauptaktivator für die Warteschlangen.  Dieser Parameter wird beim Definieren von Datenstrukturen verwendet und ihre Größe hängt von ihrem Wert ab (mehr dazu im nächsten Artikel).  Darüber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE verfügt über die Direktive <b>#define</b> enable in <b>nuse_config.h</b> .  Für Warteschlangen sind diese Anweisungen: <br><br><pre><code class="plaintext hljs">NUSE_QUEUE_SEND NUSE_QUEUE_RECEIVE NUSE_QUEUE_JAM NUSE_QUEUE_RESET NUSE_QUEUE_INFORMATION NUSE_QUEUE_COUNT</code> </pre> <br>  Standardmäßig sind sie auf <b>FALSE gesetzt</b> , wodurch alle Serviceaufrufe deaktiviert und die Aufnahme von Code blockiert werden, der sie implementiert.  Um die Warteschlangen in der Anwendung zu konfigurieren, müssen Sie die erforderlichen API-Aufrufe auswählen und auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein <b>Codeausschnitt</b> aus der Datei <b>nuse_config.h</b> : <br><br><pre> <code class="plaintext hljs">#define NUSE_QUEUE_NUMBER 0 /* Number of queues in the system - 0-16 */ /* Service call enablers */ #define NUSE_QUEUE_SEND FALSE #define NUSE_QUEUE_RECEIVE FALSE #define NUSE_QUEUE_JAM FALSE #define NUSE_QUEUE_RESET FALSE #define NUSE_QUEUE_INFORMATION FALSE #define NUSE_QUEUE_COUNT FALSE</code> </pre><br>  Wenn die Funktionen der Warteschlangen-API aktiviert sind, die Anwendung jedoch keine Warteschlangen enthält (mit Ausnahme von <b>NUSE_Queue_Count ()</b> , das immer aktiviert ist), wird ein Kompilierungsfehler <b>angezeigt</b> .  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, führt dies zu einem Layoutfehler, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Anrufwarteschlange </h2><br>  Nucleus RTOS unterstützt zehn Warteschlangendienstaufrufe mit den folgenden Funktionen: <br><br><ul><li>  Eine Nachricht in die Warteschlange stellen.  Nucleus SE ist in der Funktion <b>NUSE_Queue_Send ()</b> implementiert. </li><li>  Akzeptieren einer Nachricht aus der Warteschlange.  Nucleus SE implementiert die Funktion <b>NUSE_Queue_Receive ()</b> . </li><li>  Posting an den Kopf der Warteschlange.  In Nucleus SE, implementiert in <b>NUSE_Queue_Jam ()</b> . </li><li>  Wiederherstellen eines nicht verwendeten Status der Warteschlange mit Freigabe aller angehaltenen Aufgaben (Zurücksetzen).  Nucleus SE ist in <b>NUSE_Queue_Reset ()</b> implementiert. </li><li>  Bereitstellung von Informationen zu einer bestimmten Warteschlange.  Nucleus SE in <b>NUSE_Queue_Information ()</b> implementiert. </li><li>  Gibt die Anzahl der aktuell in der Anwendung konfigurierten Warteschlangen zurück.  In Nucleus SE, implementiert in <b>NUSE_Queue_Count ()</b> . </li><li>  Hinzufügen einer neuen Warteschlange zur Anwendung (Erstellen einer Warteschlange).  Nucleus SE ist nicht implementiert. </li><li>  Entfernen einer Warteschlange aus einer Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  Geben Sie Zeiger auf alle Warteschlangen in der Anwendung zurück.  Nucleus SE ist nicht implementiert. </li><li>  Senden einer Nachricht an alle in der Warteschlange angehaltenen Aufgaben (Broadcast).  Nucleus SE ist nicht implementiert. </li></ul><br>  Die Implementierung jedes dieser Overhead-Aufrufe wird nachstehend ausführlich beschrieben. <br><br><h2>  Service ruft zum Schreiben und Lesen aus Warteschlangen auf </h2><br>  Die grundlegenden Operationen, die an den Warteschlangen ausgeführt werden, sind Schreiben (was manchmal als Warteschlangennachrichten bezeichnet wird) und Lesen (auch als Empfangen von Nachrichten bezeichnet).  Es ist auch möglich, an den Anfang der Warteschlange zu schreiben (Jamming).  Nucleus RTOS und Nucleus SE bieten drei grundlegende API-Aufrufe für diese Operationen, die nachfolgend erläutert werden. <br><br><h3>  Anstehen </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben in die Warteschlange ist sehr flexibel und ermöglicht es Ihnen, die Aufgabe implizit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. beim Versuch, in eine vollständige Warteschlange zu schreiben).  Nucleus SE bietet dieselben Funktionen, die Unterbrechung der Aufgabe ist jedoch optional und eine Zeitüberschreitung ist nicht implementiert. <br><br>  <b><i>Anrufwarteschlange in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Queue (NU_QUEUE * Warteschlange, VOID * Nachricht, UNSIGNED Größe, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf den vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Größe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Wenn die Warteschlange Nachrichten mit variabler Länge unterstützt, muss dieser Parameter der Größe der Nachricht entsprechen oder kleiner als die von der Warteschlange unterstützte Nachrichtengröße sein.  Wenn die Warteschlange Nachrichten mit fester Größe unterstützt, muss dieser Parameter genau mit der von der Warteschlange unterstützten Nachrichtengröße übereinstimmen. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder einen Timeout-Wert <b>annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ungültiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengröße ist nicht mit der von der Warteschlange unterstützten Nachrichtengröße kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Die Suspendierung wurde von einem nicht aufgabenbezogenen Thread durchgeführt. <br>  <b>NU_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Die Warteschlange ist auch dann voll, wenn die Aufgabe für das angegebene Zeitlimit angehalten wurde. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Einreihen einer Nachricht in Nucleus SE</i></b> <br>  Dieser API-Serviceaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Send (NUSE_QUEUE-Warteschlange, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - <b>Warteschlangenindex</b> (ID); <br>  <b>message</b> - ein Zeiger auf die zu sendende Nachricht; es ist eine Variable vom Typ <b>ADDR</b> ; <br>  <b>suspend</b> - Spezifikation zum Anhalten von Aufgaben, kann die Werte <b>NUSE_NO_SUSPEND oder NUSE_SUSPEND annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ungültiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Versuch, eine Aufgabe von einem Thread <b>anzuhalten, der</b> nicht mit der Aufgabe verknüpft ist, oder wenn API-Dienstaufrufe deaktiviert sind, um Aufgaben zu blockieren. <br>  <b>NUSE_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NUSE_QUEUE_WAS_RESET</b> - Die Warteschlange wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Implementieren Sie Queuing in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Queue_Send ()</b> (nach Überprüfung der Parameter) wird mithilfe der bedingten Kompilierung ausgewählt, je nachdem, ob die Unterstützung für das Sperren von Aufgaben aktiviert ist oder nicht.  Wir werden beide Optionen prüfen. <br><br>  Wenn die Task-Sperre nicht aktiviert ist, ist der Code für diesen Serviceabruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion prüft einfach, ob in der Warteschlange freier Speicherplatz vorhanden ist, und speichert die Nachricht mithilfe des <b>NUSE_Queue_Head []</b> -Index im Datenbereich der Warteschlange. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_FULL; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* queue element available */ NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erläuterungen können hilfreich sein. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgeführt wird, während der Parameter für die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn die Warteschlange voll ist und <b>suspend</b> <b>NUSE_NO_SUSPEND ist</b> , endet der API-Aufruf mit <b>NUSE_QUEUE_FULL</b> .  Wenn der Suspend-Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird), wenn der Rückgabewert <b>NUSE_SUCCESS</b> lautet, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gelesen wurde (und nicht, weil die Warteschlange zurückgesetzt wurde), kehrt der Code zum Anfang der Schleife zurück. <br>  Wenn die Warteschlange nicht voll ist, wird die bereitgestellte Nachricht mithilfe des Index <b>NUSE_Queue_Head []</b> im Datenbereich der Warteschlange gespeichert.  Es wird überprüft, ob sich angehaltene Aufgaben (wartende Nachrichten) in der Warteschlange befinden.  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die Suspend-Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Wert <b>NUSE_SUCCESS abgeschlossen</b> . <br><br><h3>  Lesen aus der Warteschlange </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Lesen aus der Warteschlange ist sehr flexibel und ermöglicht es Ihnen, Aufgaben implizit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. beim Versuch, aus einer leeren Warteschlange zu lesen).  Nucleus SE bietet die gleiche Funktionalität, aber die Unterbrechung der Aufgabe ist optional und eine Zeitüberschreitung ist nicht implementiert. <br><br>  <b><i>Rufen Sie an, um Nachrichten aus der Warteschlange in Nucleus RTOS zu empfangen</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Receive_From_Queue (NU_QUEUE * Warteschlange, VOID * -Nachricht, UNSIGNED-Größe, UNSIGNED * actual_size, UNSIGNED suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf den vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>Nachricht</b> - ein Zeiger auf den Speicher für empfangene Nachrichten; <br>  <b>Größe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Diese Nummer sollte mit der Nachrichtengröße übereinstimmen, die beim Erstellen der Warteschlange definiert wurde. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder einen Timeout-Wert <b>annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ungültiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND -</b> Versuch, eine Aufgabe von einem Thread <b>anzuhalten</b> , der nicht mit der Aufgabe zusammenhängt; <br>  <b>NU_QUEUE_EMPTY</b> - Die Warteschlange ist leer und die Aussetzung wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - <b>Gibt</b> an, dass die Warteschlange auch nach dem <b>Anhalten</b> der Aufgabe für einen bestimmten Zeitraum noch leer ist. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Rufen Sie an, um Nachrichten von der Nucleus SE-Warteschlange zu empfangen</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Receive (NUSE_QUEUE-Warteschlange, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - <b>Warteschlangenindex</b> (ID); <br>  <b>message</b> - ein Zeiger auf das Repository für empfangene Nachrichten; es ist eine Variable vom Typ <b>ADDR</b> ; <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ungültiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - ein Versuch, eine Aufgabe in einem Thread <b>anzuhalten, der</b> nicht mit der Aufgabe verknüpft ist oder dessen Unterstützung für das Blockieren von Aufgaben deaktiviert ist; <br>  <b>NUSE_QUEUE_EMPTY</b> - Die Warteschlange ist leer und die Aussetzung wurde nicht angegeben. <br>  <b>NUSE_QUEUE_WAS_RESET</b> - Die Warteschlange wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Implementierung des Empfangs von Nachrichten aus Warteschlangen in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Queue_Receive ()</b> (nach Überprüfung der Parameter) wird mithilfe der bedingten Kompilierung ausgewählt, je nachdem, ob die Unterstützung für das Sperren von Aufgaben aktiviert ist oder nicht.  Betrachten Sie beide Optionen. <br><br>  Wenn die Sperrunterstützung aktiviert ist, ist der Code für diesen API-Aufruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { return_value = NUSE_QUEUE_EMPTY; } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion prüft einfach, ob sich eine Nachricht in der Warteschlange befindet, und verwendet den Index <b>NUSE_Queue_Tail []</b> , um die Nachricht aus der Warteschlange abzurufen und Daten mithilfe eines Zeigers auf die Nachricht zurückzugeben. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_EMPTY; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked */ /* on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erläuterungen sind hilfreich. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgeführt wird, während der Parameter für die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn die Warteschlange leer ist und suspend <b>NUSE_NO_SUSPEND ist</b> , endet der API-Aufruf mit <b>NUSE_QUEUE_EMPTY</b> .  Wenn der <b>Suspend-</b> Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird), wenn der Rückgabewert <b>NUSE_SUCCESS</b> ist, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gesendet wurde (und nicht, weil die Warteschlange zurückgesetzt wurde), kehrt der Code zum Anfang der Schleife zurück. <br><br>  Wenn die Warteschlange Nachrichten enthält, wird die gespeicherte Nachricht mithilfe des Index <b>NUSE_Queue_Tail [] zurückgegeben</b> .  Es wird überprüft, ob in dieser Warteschlange angehaltene (ausstehende) Aufgaben vorhanden sind.  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die Suspend-Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Code <b>NUSE_SUCCESS</b> beendet. <br><br><h3>  Schreiben Sie an den Kopf der Warteschlange </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben einer Nachricht in den Warteschlangenkopf ist sehr flexibel und ermöglicht es Ihnen, die Aufgabe implizit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. beim Versuch, in eine überfüllte Warteschlange zu schreiben).  Nucleus SE bietet die gleiche Funktionalität, aber die Unterbrechung der Aufgabe ist optional und ein Timeout ist nicht implementiert. <br><br>  <b><i>Rufen Sie an, um eine Nachricht an den Kopf der Nucleus RTOS-Warteschlange zu schreiben</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Front_Of_Queue (NU_QUEUE * Warteschlange, VOID * Nachricht, UNSIGNED Größe, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf den vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Größe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Wenn die Warteschlange Nachrichten mit variabler Länge unterstützt, muss dieser Parameter der Nachrichtengröße entsprechen oder kleiner als die von der Warteschlange unterstützte Nachrichtengröße sein.  Wenn die Warteschlange Nachrichten fester Länge unterstützt, muss dieser Parameter genau mit der Größe der von der Warteschlange unterstützten Nachricht übereinstimmen. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder einen Timeout-Wert <b>annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ungültiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengröße ist nicht mit der Größe der von der Warteschlange unterstützten Nachricht kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, eine Pause von einem Nicht-Task-Flow <b>einzulegen</b> <br>  <b>NU_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Die Warteschlange ist voll, auch nachdem die Aufgabe für eine bestimmte Zeit unterbrochen wurde. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Ein Aufruf zum Schreiben einer Nachricht an den Kopf einer Warteschlange in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Jam (NUSE_QUEUE-Warteschlange, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - <b>Warteschlangenindex</b> (ID); <br>  <b>Nachricht</b> - Ein Zeiger auf eine Nachricht ist eine Variable vom Typ <b>ADDR</b> . <br>  <b>suspend</b> - Die Angabe für die Suspendierung der Aufgabe kann <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND sein</b> <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ungültiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - ein Versuch, eine Aufgabe in einem Thread <b>anzuhalten, der</b> nicht mit der Aufgabe verknüpft ist oder dessen Unterstützung für das Blockieren von Aufgaben deaktiviert ist; <br>  <b>NUSE_QUEUE_FULL</b> - Die Warteschlange ist voll und die Aussetzung wurde nicht angegeben. <br>  <b>NUSE_QUEUE_WAS_RESET</b> - Die Warteschlange wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Implementieren eines Warteschlangen-Top-Datensatzes in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Queue_Jam () ist NUSE_Queue_Send ()</b> sehr ähnlich. Nur die Daten werden mithilfe des <b>NUSE_Queue_Tail []</b> -Index gespeichert. <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { if (NUSE_Queue_Tail[queue] == 0) { NUSE_Queue_Tail[queue] = NUSE_Queue_Size[queue] - 1; } else { NUSE_Queue_Tail[queue]--; } NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]] = *message; NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Der nächste Artikel befasst sich mit zusätzlichen API-Aufrufen, die Warteschlangen zugeordnet sind, sowie mit Datenstrukturen. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431378/">https://habr.com/ru/post/de431378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431362/index.html">Wie kann ein Designer die Routine loswerden und das Interesse an seinem Job behalten?</a></li>
<li><a href="../de431370/index.html">Die schnellsten Berichte im wilden Westen. Und noch eine Handvoll Bugs ...</a></li>
<li><a href="../de431372/index.html">Interrupts von externen Geräten in einem x86-System. Teil 2. Startoptionen für den Linux-Kernel</a></li>
<li><a href="../de431374/index.html">Letztes Urteil: Analyse der Finanzindikatoren des Spiels beim frühen Zugriff</a></li>
<li><a href="../de431376/index.html">Datenmigration im blutigen Unternehmen: Was zu analysieren ist, um das Projekt nicht zu überfordern</a></li>
<li><a href="../de431380/index.html">Mitap Netologiya und Skyeng über Soft Skills „Was ein Entwickler außer Code wissen muss“</a></li>
<li><a href="../de431382/index.html">Ergebnisse der JVM-Ökosystemumfrage</a></li>
<li><a href="../de431384/index.html">CLion 2018.3: Remote-Entwicklung, Code-Profilerstellung, Leistung und mehr</a></li>
<li><a href="../de431388/index.html">Die Welt mit den Augen eines Autos. Wie sehen ihn Drohnen?</a></li>
<li><a href="../de431390/index.html">Digitale Trends 2019 und ihre Auswirkungen auf das veränderte Verbraucherverhalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>