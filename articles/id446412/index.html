<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐣 #⃣ 🕵🏻 Basis Data KDB +: Dari Keuangan ke Formula 1 🥃 🥙 🏘️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="KDB +, produk KX , adalah lingkaran kecil yang terkenal, sangat cepat, basis data kolom yang dirancang untuk menyimpan deret waktu dan perhitungan ana...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Basis Data KDB +: Dari Keuangan ke Formula 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/446412/">  KDB +, produk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KX</a> , adalah lingkaran kecil yang terkenal, sangat cepat, basis data kolom yang dirancang untuk menyimpan deret waktu dan perhitungan analitik berdasarkan pada mereka.  Awalnya, ia menikmati (dan menikmati) popularitas besar di industri keuangan - ini digunakan oleh semua 10 bank investasi top dan banyak dana lindung nilai yang terkenal, bursa dan organisasi lain.  Baru-baru ini, KX memutuskan untuk memperluas basis pelanggannya dan sekarang menawarkan solusi di bidang lain di mana ada sejumlah besar data yang diurutkan berdasarkan waktu atau dengan cara lain - telekomunikasi, bioinformatika, produksi, dll.  Secara khusus, mereka menjadi mitra tim Aston Martin Red Bull Racing di Formula 1, di mana mereka membantu mengumpulkan dan memproses data dari sensor mobil dan menganalisis tes di terowongan angin.  Pada artikel ini saya ingin memberi tahu Anda fitur-fitur apa dari KDB + yang membuatnya superproduksi, mengapa perusahaan mau mengeluarkan banyak uang untuk itu, dan akhirnya, mengapa ini bukan database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efa/f84/839/efaf84839e64d7c0026568d2b8019cd9.jpg"><br><a name="habracut"></a><br>  Pada artikel ini saya akan mencoba memberi tahu secara umum apa itu KDB +, fitur dan batasan apa yang dimilikinya, apa manfaatnya bagi perusahaan yang ingin memproses data dalam volume besar.  Saya tidak akan membahas rincian implementasi KDB + dan rincian bahasa pemrograman Q. Kedua topik ini sangat luas dan layak mendapatkan artikel terpisah.  Banyak informasi tentang topik-topik ini dapat ditemukan di code.kx.com, termasuk buku tentang Q - Q For Mortals (lihat tautan di bawah). <br><br><h2>  Beberapa istilah </h2><br><ul><li> <b>Database dalam memori.</b>  Database yang menyimpan data dalam RAM untuk akses yang lebih cepat.  Kelebihan dari basis data seperti itu dapat dipahami, dan kerugiannya adalah kemungkinan kehilangan data, kebutuhan untuk memiliki banyak memori di server. <br></li><li>  <b>Database kolom.</b>  Basis data tempat data disimpan secara seri, bukan catatan demi catatan.  Keuntungan utama dari database tersebut adalah bahwa data dari satu kolom disimpan bersama dalam disk dan memori, yang sangat mempercepat aksesnya.  Tidak perlu memuat kolom yang tidak digunakan dalam permintaan.  Kerugian utama adalah sulit untuk memodifikasi dan menghapus catatan. <br></li><li>  <b>Seri waktu.</b>  Data dengan kolom seperti tanggal atau waktu.  Sebagai aturan, memesan dalam waktu penting untuk data tersebut, sehingga Anda dapat dengan mudah menentukan rekaman mana yang mendahului atau mengikuti arus, atau untuk menerapkan fungsi yang hasilnya tergantung pada urutan catatan.  Database klasik dibangun di atas prinsip yang sama sekali berbeda - mewakili serangkaian catatan sebagai satu set, di mana urutan catatan tidak didefinisikan pada prinsipnya. <br></li><li>  <b>Vektor.</b>  Dalam konteksnya, KDB + adalah daftar elemen dengan tipe atom yang sama, misalnya angka.  Dengan kata lain, array elemen.  Array, tidak seperti daftar, dapat disimpan secara kompak dan diproses menggunakan instruksi prosesor vektor. <br></li></ul><br><h2>  Latar belakang sejarah </h2><br>  KX didirikan pada tahun 1993 oleh Arthur Whitney, yang sebelumnya bekerja di Morgan Stanley Bank pada A +, penerus APL, bahasa yang sangat asli dan populer di dunia keuangan.  Tentu saja, di KX, Arthur melanjutkan semangat yang sama dan menciptakan bahasa fungsional vektor K, dipandu oleh ide-ide minimalis radikal.  Program K terlihat seperti sekumpulan tanda baca dan karakter khusus yang berantakan, makna karakter dan fungsi tergantung pada konteksnya, dan setiap operasi membawa lebih banyak makna daripada dalam bahasa pemrograman biasa.  Karena itu, program K membutuhkan ruang minimum - beberapa baris dapat menggantikan halaman teks dari bahasa verbose seperti Java - dan merupakan implementasi algoritma yang sangat terkonsentrasi. <br><br>  Fungsi pada K yang mengimplementasikan sebagian besar generator parser LL1 menurut tata bahasa yang diberikan: <br><br><pre><code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> pp:{q:{(x;p3(),y)};r:$[<span class="hljs-number"><span class="hljs-number">-11</span></span>=@x;$x;<span class="hljs-number"><span class="hljs-number">11</span></span>=@x;q[`N;$*x];<span class="hljs-number"><span class="hljs-number">10</span></span>=abs@@x;q[`N;x]  <span class="hljs-number"><span class="hljs-number">2.</span></span>   ($)~*x;(`P;p3 x <span class="hljs-number"><span class="hljs-number">1</span></span>);(<span class="hljs-number"><span class="hljs-number">1</span></span>=<span class="hljs-meta"><span class="hljs-meta">#x)&amp;11=@*x;pp[{(1#x;$[2=#x;;,:]1_x)}@*x]  3.      (?)~*x;(`Q;pp[x 1]);(*)~*x;(`M;pp[x 1]);(+)~*x;(`MP;pp[x 1]);(!)~*x;(`Y;p3 x 1)  4.      (2=#x)&amp;(@x 1)in 100 101 107 7 -7h;($[(@x 1)in 100 101 107h;`Ff;`Fi];p3 x 1;pp[*x])  5.      (|)~*x;`S,(pp'1_x);2=#x;`C,{@[@[x;-1+#x;{x,")"}];0;"(",]}({$[".sC"~4#x;6_-2_x;x]}'pp'x);'`pp];  6.   $[@r;r;($[1&lt;#r;".s.";""],$*r),$[1&lt;#r;"[",(";"/:1_r),"]";""]]}</span></span></code> </pre> <br>  Arthur juga mewujudkan filosofi efisiensi ekstrem ini dengan gerakan tubuh minimum di KDB +, yang muncul pada tahun 2003 (saya pikir sekarang sudah jelas dari mana huruf K berasal dari namanya) dan tidak ada yang lebih dari seorang penerjemah dari versi keempat bahasa K. Versi yang lebih menyenangkan bagi mata pengguna ditambahkan ke K K dengan nama Q. Q juga menambahkan dukungan untuk dialek SQL tertentu - QSQL, dan pada interpreter - dukungan untuk tabel sebagai tipe data sistem, alat untuk bekerja dengan tabel dalam memori dan pada disk, dll. <br><br>  Jadi, dari sudut pandang pengguna, KDB + hanyalah penerjemah bahasa Q dengan dukungan untuk tabel dan ekspresi gaya-LINQ seperti SQL dari C #.  Ini adalah perbedaan paling penting antara KDB + dan basis data lainnya dan keunggulan kompetitif utamanya, yang seringkali diabaikan.  Ini bukan basis data + bahasa bantu yang dinonaktifkan, tetapi bahasa pemrograman yang kuat lengkap + dukungan bawaan untuk fungsi basis data.  Perbedaan ini akan memainkan peran yang menentukan dalam daftar semua manfaat KDB +.  Misalnya ... <br><br><h2>  Ukuran </h2><br>  Dengan standar modern, KDB + hanyalah ukuran mikroskopis.  Ini benar-benar satu file yang dapat dieksekusi lebih kecil dari satu megabyte dan satu file teks kecil dengan beberapa fungsi sistem.  Sebenarnya - kurang dari satu megabyte dan untuk program ini perusahaan membayar puluhan ribu dolar per tahun untuk satu prosesor di server. <br><br><ul><li>  Ukuran ini memungkinkan KDB + untuk merasa hebat pada perangkat keras apa pun - dari komputer mikro Pi ke server dengan memori terabyte.  Ini tidak mempengaruhi fungsi dengan cara apa pun, apalagi, Q mulai secara instan, yang memungkinkannya untuk digunakan termasuk sebagai bahasa scripting. <br></li><li>  Dengan ukuran ini, interpreter Q sepenuhnya ditempatkan dalam cache prosesor, yang mempercepat eksekusi program. <br></li><li>  Dengan ukuran file yang dapat dieksekusi ini, proses Q membutuhkan ruang memori yang dapat diabaikan, Anda dapat menjalankannya dalam ratusan.  Pada saat yang sama, jika perlu, Q dapat beroperasi dengan puluhan atau ratusan gigabyte memori dalam satu proses. <br></li></ul><br><h2>  Keserbagunaan </h2><br>  Q sangat cocok untuk berbagai tugas.  Proses Q dapat berfungsi sebagai basis data historis dan menyediakan akses cepat ke terabyte informasi.  Sebagai contoh, kami memiliki lusinan database historis, di mana beberapa hari dalam satu data terkompresi membutuhkan lebih dari 100 gigabita.  Namun, dengan batasan yang masuk akal, kueri basis data akan dieksekusi dalam puluhan hingga ratusan milidetik.  Secara umum, kami memiliki batas waktu universal untuk permintaan pengguna - 30 detik - dan ini berfungsi sangat jarang. <br><br>  Dengan kemudahan yang sama, Q bisa menjadi basis data dalam memori.  Menambahkan data baru ke tabel dalam memori sangat cepat sehingga permintaan pengguna adalah faktor pembatas.  Data dalam tabel disimpan dalam kolom, yang berarti bahwa setiap operasi dalam kolom akan menggunakan cache prosesor pada kapasitas penuh.  Selain itu, KX mencoba menerapkan semua operasi dasar seperti aritmatika melalui instruksi prosesor vektor, memaksimalkan kecepatannya.  Q dapat melakukan tugas yang bukan merupakan karakteristik dari basis data - misalnya, memproses streaming data dan menghitung dalam "waktu nyata" (dengan penundaan puluhan milidetik hingga beberapa detik tergantung pada tugasnya) berbagai fungsi agregat untuk instrumen keuangan untuk interval waktu yang berbeda atau membangun model dampak sempurna. transaksi ke pasar dan melakukan pembuatan profil segera setelah selesai.  Dalam masalah seperti itu, paling sering waktu tunda utama bukanlah Q, tetapi kebutuhan untuk menyinkronkan data dari berbagai sumber.  Kecepatan tinggi dicapai karena fakta bahwa data dan fungsi yang memprosesnya berada dalam proses yang sama, dan pemrosesan dikurangi menjadi beberapa ekspresi QSQL dan gabungan yang tidak diinterpretasikan, tetapi dieksekusi dalam kode biner. <br><br>  Akhirnya, setiap proses layanan juga dapat ditulis dalam Q.  Misalnya, Gateway memproses yang secara otomatis mendistribusikan permintaan pengguna ke database dan server yang diperlukan.  Programmer memiliki kebebasan penuh untuk menerapkan algoritma apa pun untuk menyeimbangkan, memprioritaskan, toleransi kesalahan, hak akses, kuota, dan umumnya apa pun yang diinginkan hati Anda.  Masalah utama di sini adalah Anda harus menerapkan semua ini sendiri. <br><br>  Sebagai contoh, saya akan mencantumkan jenis proses yang kita miliki.  Semuanya secara aktif digunakan dan bekerja bersama, menggabungkan puluhan database yang berbeda, memproses data dari berbagai sumber dan melayani ratusan pengguna dan aplikasi. <br><br><ul><li>  <b>Konektor (pengumpan) ke sumber data.</b>  Proses ini biasanya menggunakan pustaka eksternal yang dimuat di Q. Antarmuka C di Q sangat sederhana dan memungkinkan Anda untuk dengan mudah membuat fungsi proxy untuk pustaka C / C ++ apa pun.  Q cukup cepat untuk menangani, misalnya, memproses aliran pesan FIX dari semua bursa efek Eropa secara bersamaan. <br></li><li>  <b>Distributor Tickerplant,</b> yang berfungsi sebagai penghubung antara konektor dan konsumen.  Pada saat yang sama, mereka menulis data yang masuk dalam log biner khusus, memberikan perlawanan bagi konsumen untuk kehilangan koneksi atau memulai kembali. <br></li><li>  <b>Database dalam memori (rdb).</b>  Database ini menyediakan akses tercepat ke data mentah, segar, menyimpannya dalam memori.  Sebagai aturan, mereka mengakumulasi data dalam tabel di siang hari dan nol di malam hari. <br></li><li>  <b>Database Persist (pdb).</b>  Basis data ini menyediakan penyimpanan data hari ini di basis data historis.  Sebagai aturan, tidak seperti rdb, mereka tidak menyimpan data dalam memori, tetapi menggunakan cache khusus pada disk selama sehari dan menyalin data pada tengah malam ke database historis. <br></li><li>  <b>Basis historis (hdb).</b>  Basis data ini menyediakan akses ke data untuk hari, bulan, dan tahun sebelumnya.  Ukurannya (dalam berhari-hari) hanya dibatasi oleh ukuran hard drive.  Data dapat ditemukan di mana saja, khususnya pada disk yang berbeda untuk akses yang lebih cepat.  Dimungkinkan untuk memampatkan data menggunakan beberapa algoritma untuk dipilih.  Struktur basis data terdokumentasi dengan baik dan sederhana, data disimpan berdasarkan per-unit dalam file biasa, sehingga dapat diproses, termasuk menggunakan sistem operasi. <br></li><li>  <b>Database dengan informasi agregat.</b>  Berbagai agregasi disimpan, biasanya dengan, dikelompokkan berdasarkan nama instrumen dan interval waktu.  Database dalam memori memperbarui status mereka dengan setiap pesan yang masuk, dan yang historis menyimpan data yang sudah dihitung untuk mempercepat akses ke data historis. <br></li><li>  Akhirnya, <b>gateway memproses</b> aplikasi dan pengguna.  Q memungkinkan Anda untuk mengimplementasikan pemrosesan pesan masuk yang sepenuhnya tidak sinkron, mendistribusikannya di antara basis data, memeriksa hak akses, dll.  Saya perhatikan bahwa pesan tidak terbatas dan paling sering bukan pernyataan SQL, seperti halnya di database lain.  Paling sering, ekspresi SQL disembunyikan dalam fungsi khusus dan dibangun berdasarkan parameter yang diminta oleh pengguna - waktu dikonversi, disaring, data dinormalisasi (misalnya, harga saham disamakan jika dividen dibayarkan), dll. <br></li></ul><br>  Arsitektur khas untuk satu tipe data: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99a/13e/5e9/99a13e5e9813f09a2d40b676669c052a.png"><br><br><h2>  Kecepatan </h2><br>  Meskipun Q adalah bahasa yang diartikan, itu secara bersamaan adalah bahasa vektor.  Ini berarti bahwa banyak fungsi bawaan, khususnya aritmatika, menerima argumen dalam bentuk apa pun - angka, vektor, matriks, daftar, dan pemrogram diharapkan untuk mengimplementasikan program sebagai operasi pada array.  Dalam bahasa seperti itu, jika Anda menambahkan dua vektor dalam sejuta elemen, itu tidak lagi berarti bahwa bahasa ditafsirkan, penambahan akan dilakukan oleh fungsi biner yang dioptimalkan.  Karena bagian terbesar dari waktu dalam program Q dihabiskan untuk operasi dengan tabel menggunakan fungsi-fungsi dasar vektor ini, output memiliki kecepatan yang sangat baik yang memungkinkan Anda untuk memproses sejumlah besar data bahkan dalam satu proses.  Ini mirip dengan perpustakaan matematika di python - walaupun python sendiri adalah bahasa yang sangat lambat, ia memiliki banyak perpustakaan numpy yang memungkinkan Anda untuk memproses data numerik dengan kecepatan bahasa yang dikompilasi (omong-omong, numpy secara ideologis dekat dengan Q). <br><br>  Selain itu, KX sangat hati-hati mendekati desain tabel dan mengoptimalkan pekerjaan dengannya.  Pertama, beberapa jenis indeks didukung, yang didukung oleh fungsi bawaan dan dapat diterapkan tidak hanya pada kolom tabel, tetapi juga untuk vektor apa pun - pengelompokan, pengurutan, atribut keunikan dan pengelompokan khusus untuk basis data historis.  Indeks ditumpangkan secara elemen dan secara otomatis disesuaikan ketika menambahkan elemen ke kolom / vektor.  Indeks dapat juga tumpang tindih kolom tabel baik di memori dan pada disk.  Saat menjalankan kueri QSQL, indeks digunakan secara otomatis, jika memungkinkan.  Kedua, bekerja dengan data historis dilakukan melalui mekanisme pemetaan file OS (peta memori).  Tabel besar tidak pernah dimuat ke dalam memori, sebaliknya, kolom yang diperlukan dipetakan langsung ke memori dan hanya sebagian dari mereka yang benar-benar dimuat (indeks juga membantu di sini), yang diperlukan.  Tidak ada perbedaan untuk programmer apakah data ada dalam memori atau tidak, mekanisme untuk bekerja dengan mmap sepenuhnya tersembunyi di dalam usus Q. <br><br>  KDB + bukan database relasional, tabel dapat berisi data arbitrer, sedangkan urutan baris dalam tabel tidak berubah ketika elemen baru ditambahkan dan dapat dan harus digunakan saat menulis kueri.  Fitur ini sangat diperlukan untuk bekerja dengan deret waktu (data dari pertukaran, telemetri, event log), karena jika data diurutkan berdasarkan waktu, maka pengguna tidak perlu menggunakan trik SQL apa pun untuk menemukan baris pertama atau terakhir atau baris N dalam tabel. , tentukan baris mana yang mengikuti baris ke-N, dll.  Gabungan tabel bahkan lebih disederhanakan, misalnya, menemukan untuk 16.000 transaksi VOD.L (Vodafone) kutipan terakhir dalam tabel 500 juta elemen membutuhkan waktu sekitar satu detik pada disk dan selusin milidetik dalam memori. <br><br>  Contoh waktu bergabung adalah tabel kutipan dipetakan ke memori, sehingga tidak perlu menentukan VOD.L di mana, indeks pada kolom sym secara implisit digunakan dan fakta bahwa data diurutkan berdasarkan waktu.  Hampir semua gabungan dalam Q adalah fungsi biasa, bukan bagian dari pernyataan pilih: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> aj[`sym`time;<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> trade <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date=<span class="hljs-number"><span class="hljs-number">2019.03</span></span><span class="hljs-number"><span class="hljs-number">.26</span></span>, sym=`VOD.L;<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> quote <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date=<span class="hljs-number"><span class="hljs-number">2019.03</span></span><span class="hljs-number"><span class="hljs-number">.26</span></span>]</code> </pre><br>  Akhirnya, perlu dicatat bahwa para insinyur di KX, dimulai dengan Arthur Whitney sendiri, benar-benar terobsesi dengan efisiensi dan melakukan segala upaya untuk mendapatkan hasil maksimal dari fungsi Q standar dan mengoptimalkan pola penggunaan yang paling umum. <br><br><h2>  Ringkasan </h2><br>  KDB + populer di kalangan bisnis terutama karena keserbagunaannya yang luar biasa - ia berfungsi dengan baik sebagai basis di memori, dan sebagai basis untuk menyimpan terabyte data historis, dan sebagai platform untuk analisis data.  Karena kenyataan bahwa pemrosesan data terjadi langsung dalam database, kecepatan tinggi operasi dan penghematan sumber daya tercapai.  Bahasa pemrograman lengkap, terintegrasi dengan fungsi basis data, memungkinkan Anda untuk mengimplementasikan pada platform yang sama seluruh tumpukan proses yang diperlukan - mulai dari menerima data hingga memproses permintaan pengguna. <br><br><h2>  Informasi tambahan </h2><br><h3>  Kekurangan </h3><br>  Kelemahan signifikan dari KDB + / Q adalah ambang masuknya yang tinggi.  Bahasa ini memiliki sintaks yang aneh, beberapa fungsi kelebihan beban (nilai, misalnya, memiliki sekitar 11 kasus penggunaan).  Yang paling penting, ini membutuhkan pendekatan yang sangat berbeda untuk program penulisan.  Dalam bahasa vektor, Anda harus berpikir sepanjang waktu dalam hal transformasi array, mengimplementasikan semua siklus melalui beberapa opsi peta / mengurangi fungsi (disebut keterangan dalam Q), tidak pernah mencoba menghemat uang dengan mengganti operasi vektor dengan yang atom.  Misalnya, untuk menemukan indeks kemunculan elemen ke-N dalam array, tulis: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> element=vector)[N]</code> </pre><br>  meskipun ini terlihat sangat tidak efisien oleh standar C / Java (= menciptakan vektor Boolean, di mana mengembalikan indeks elemen sebenarnya di dalamnya).  Tetapi catatan seperti itu membuat makna ungkapan lebih dapat dipahami dan Anda menggunakan operasi vektor cepat alih-alih yang lambat atom.  Perbedaan konseptual antara bahasa vektor dan sisanya sebanding dengan perbedaan antara pendekatan imperatif dan fungsional untuk pemrograman, dan Anda harus siap untuk ini. <br><br>  Beberapa pengguna juga tidak senang dengan QSQL.  Faktanya adalah itu hanya tampak seperti SQL nyata.  Pada kenyataannya, itu hanya sebuah penafsiran ekspresi seperti SQL yang tidak mendukung optimisasi kueri.  Pengguna sendiri harus menulis kueri optimal, dan pada Q, yang banyak di antaranya tidak siap.  Di sisi lain, tentu saja, Anda selalu dapat menulis sendiri kueri optimal Anda sendiri, dan tidak mengandalkan pengoptimal kotak hitam. <br><br>  Sebagai plus, buku tentang Q - Q For Mortals tersedia secara gratis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web perusahaan</a> , dan ada juga banyak bahan bermanfaat lainnya. <br><br>  Kekurangan besar lainnya adalah biaya lisensi.  Ini adalah puluhan ribu dolar per tahun untuk satu CPU.  Hanya perusahaan besar yang mampu membayar biaya seperti itu.  Baru-baru ini, KX telah membuat kebijakan lisensi lebih fleksibel dan memberikan kemampuan untuk membayar hanya untuk saat menggunakan atau menyewa KDB + di cloud Google dan Amazon.  KX juga menawarkan untuk mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi gratis untuk tujuan non-komersial</a> (versi 32-bit atau 64-bit atas permintaan). <br><br><h3>  Pesaing </h3><br>  Ada beberapa basis data khusus yang dibangun berdasarkan prinsip yang sama - kolumnis, di dalam memori, berfokus pada jumlah data yang sangat besar.  Masalahnya adalah bahwa ini adalah database khusus.  Contoh utama adalah Clickhouse.  Basis data ini memiliki prinsip yang sangat mirip dengan KDB + untuk menyimpan data pada disk dan membangun indeks, ia melakukan beberapa pertanyaan lebih cepat daripada KDB +, meskipun tidak signifikan.  Tetapi bahkan ketika basis data Clickhouse lebih terspesialisasi daripada KDB + - analisis web vs deret waktu sewenang-wenang (perbedaan ini sangat penting - karena itu, misalnya, tidak ada cara untuk menggunakan pemesanan catatan di Clickhouse).  Tapi, yang paling penting, Clickhouse tidak memiliki universalitas KDB +, bahasa yang memungkinkan pemrosesan data secara langsung dalam database, daripada memuatnya sebelumnya ke dalam aplikasi terpisah, membangun ekspresi SQL yang sewenang-wenang, menerapkan fungsi sewenang-wenang dalam kueri, menciptakan proses yang tidak terkait dengan pelaksanaan fungsi database historis .  Oleh karena itu, sulit untuk membandingkan KDB + dengan database lain, mereka mungkin lebih baik dalam kasus penggunaan terpisah atau hanya lebih baik jika kita berbicara tentang tugas-tugas database klasik, tetapi saya tidak tahu alat lain yang sama efektif dan universal untuk memproses data sementara. <br><br><h3>  Integrasi Python </h3><br>  Untuk membuat KDB + lebih mudah bagi orang-orang yang baru mengenal teknologi, KX telah membuat perpustakaan untuk integrasi ketat dengan Python dalam satu proses tunggal.  Anda bisa memanggil fungsi python dari Q, atau sebaliknya - memanggil fungsi Q dari Python (khususnya ekspresi QSQL).  Perpustakaan mengkonversi jika perlu (demi efisiensi tidak selalu) data dari format satu bahasa ke format yang lain.  Akibatnya, Q dan Python hidup dalam simbiosis yang sangat dekat sehingga batas-batas di antara mereka terhapus.  Akibatnya, seorang programmer, di satu sisi, memiliki akses penuh ke berbagai pustaka Python yang bermanfaat, di sisi lain, ia mendapatkan basis cepat untuk bekerja dengan data besar yang diintegrasikan dengan Python, yang sangat berguna bagi mereka yang terlibat dalam pembelajaran mesin atau pemodelan. <br><br>  Bekerja dengan Q dengan Python: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> &gt;&gt;&gt; q() <span class="hljs-number"><span class="hljs-number">2.</span></span>q)trade:([]date:();sym:();qty:()) <span class="hljs-number"><span class="hljs-number">3.</span></span> q)\ <span class="hljs-number"><span class="hljs-number">4.</span></span> &gt;&gt;&gt; q.insert(<span class="hljs-string"><span class="hljs-string">'trade'</span></span>, (date(<span class="hljs-number"><span class="hljs-number">2006</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'IBM'</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)) <span class="hljs-number"><span class="hljs-number">5.</span></span> k(<span class="hljs-string"><span class="hljs-string">',0'</span></span>) <span class="hljs-number"><span class="hljs-number">6.</span></span> &gt;&gt;&gt; q.insert(<span class="hljs-string"><span class="hljs-string">'trade'</span></span>, (date(<span class="hljs-number"><span class="hljs-number">2006</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'MSFT'</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)) <span class="hljs-number"><span class="hljs-number">7.</span></span> k(<span class="hljs-string"><span class="hljs-string">',1'</span></span>)</code> </pre><br><h3>  Referensi </h3><br>  Situs web perusahaan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://kx.com/</a> <br>  Situs web untuk pengembang - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://code.kx.com/v2/</a> <br>  Buku Q For Mortals (dalam bahasa Inggris) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://code.kx.com/q4m3/</a> <br>  Artikel tentang topik aplikasi KDB + / Q dari karyawan kx - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://code.kx.com/v2/wp/</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446412/">https://habr.com/ru/post/id446412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446394/index.html">5. Periksa Titik Memulai R80.20. Gaia & CLI</a></li>
<li><a href="../id446396/index.html">Atur ulang penghitung minggu GPS</a></li>
<li><a href="../id446400/index.html">Dmitry Dumik, Chatfuel: Tentang Y Combinator, Kewirausahaan Teknologi, Perubahan Perilaku dan Kesadaran</a></li>
<li><a href="../id446402/index.html">Aplikasi multibahasa dalam Angular</a></li>
<li><a href="../id446404/index.html">Alternatif modern untuk PGP</a></li>
<li><a href="../id446414/index.html">Suatu hal yang baik tidak disebut karat</a></li>
<li><a href="../id446418/index.html">Cloudflare memperkenalkan layanan VPN-nya sendiri berdasarkan aplikasi 1.1.1.1 untuk perangkat seluler</a></li>
<li><a href="../id446422/index.html">QuietOn - headphone yang membunuh ...</a></li>
<li><a href="../id446424/index.html">Sejarah satu laporan</a></li>
<li><a href="../id446428/index.html">Bagaimana HR Bumblebee Plant Dibangun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>