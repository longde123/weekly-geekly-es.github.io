<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔲 🙁 👊🏿 Réplication de haut niveau dans le SGBD Tarantool 🅾️ 👸🏻 ✍️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, je crée des applications pour le SGBD Tarantool - il s'agit d'une plateforme développée par Mail.ru Group qui combine un SGBD hautes performa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Réplication de haut niveau dans le SGBD Tarantool</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/455146/">  Bonjour, je crée des applications pour le SGBD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tarantool</a> - il s'agit d'une plateforme développée par Mail.ru Group qui combine un SGBD hautes performances et un serveur d'applications à Lua.  La vitesse élevée des solutions basées sur Tarantool est obtenue, en particulier, en prenant en charge le mode SGBD en mémoire et la possibilité d'exécuter la logique d'application métier dans un espace d'adressage unique avec des données.  Cela garantit la persistance des données à l'aide des transactions ACID (un journal WAL est conservé sur le disque).  Tarantool a un support de réplication et de partitionnement intégré.  À partir de la version 2.1, les requêtes SQL sont prises en charge.  Tarantool est open source et sous licence BSD simplifiée.  Il existe également une version commerciale d'entreprise. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4aa/22f/d04/4aa22fd046775dd3b44af444ddcde28d.jpg"><br>  <i>Ressentez le pouvoir!</i>  <i>(... aka profitez de la performance)</i> <br><br>  Tout cela fait de Tarantool une plate-forme attrayante pour créer des applications de base de données très chargées.  Dans de telles applications, la réplication des données devient souvent nécessaire. <br><a name="habracut"></a><br>  Comme mentionné ci-dessus, Tarantool a une réplication de données intégrée.  Le principe de son travail est l'exécution séquentielle sur des répliques de toutes les transactions contenues dans le journal de l'assistant (WAL).  Typiquement, une telle réplication (nous l'appellerons <i>bas niveau</i> ci <i>-</i> dessous) est utilisée pour fournir une tolérance aux pannes de l'application et / ou pour répartir la charge de lecture entre les nœuds du cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1c/31b/83b/d1c31b83b1c71220a514deebb7d49952.png"><br>  <i>Fig.</i>  <i>1. Réplication au sein du cluster</i> <br><br>  Un exemple de scénario alternatif est le transfert de données créées dans une base de données vers une autre base de données pour traitement / surveillance.  Dans ce dernier cas, une solution plus pratique peut être d'utiliser la réplication de <i>haut niveau</i> - réplication des données au niveau de la logique métier de l'application.  C'est-à-dire  Nous n'utilisons pas de solution prête à l'emploi intégrée au SGBD, mais nous implémentons nous-mêmes la réplication dans l'application que nous développons.  Cette approche présente à la fois des avantages et des inconvénients.  Nous listons les avantages. <br><br>  1. Économisez du trafic: <br><br><ul><li>  vous ne pouvez pas transférer toutes les données, mais seulement une partie de celles-ci (par exemple, vous ne pouvez transférer que certaines tables, certaines de leurs colonnes ou enregistrements qui répondent à un certain critère); <br></li><li>  contrairement à la réplication de bas niveau, qui est effectuée en continu en mode asynchrone (implémenté dans la version actuelle de Tarantool - 1.10) ou synchrone (à implémenter dans les futures versions de Tarantool), la réplication de haut niveau peut être effectuée par sessions (c'est-à-dire que l'application effectue d'abord la synchronisation des données - session d'échange données, puis il y a une pause dans la réplication, après quoi la prochaine session d'échange a lieu, etc.); <br></li><li>  si l'enregistrement a changé plusieurs fois, vous ne pouvez transférer que sa dernière version (contrairement à la réplication de bas niveau, dans laquelle toutes les modifications apportées à l'assistant seront lues séquentiellement sur les répliques). <br></li></ul><br>  2. La mise en œuvre de l'échange via HTTP ne pose aucune difficulté, ce qui vous permet de synchroniser des bases de données distantes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/551/551/7aa/5515517aaa739f6260023c5e8ff30bf0.png"><br>  <i>Fig.</i>  <i>2. Réplication HTTP</i> <br><br>  3. Les structures de base de données entre lesquelles les données sont transmises ne doivent pas être les mêmes (en outre, dans le cas général, il est même possible d'utiliser différents SGBD, langages de programmation, plates-formes, etc.). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/830/85a/64b/83085a64b69ff5dba2431db97213fa82.png"><br>  <i>Fig.</i>  <i>3. Réplication dans des systèmes hétérogènes</i> <br><br>  L'inconvénient est qu'en moyenne, la programmation est plus compliquée / plus chère que la configuration, et au lieu de configurer la fonctionnalité intégrée, vous devrez implémenter la vôtre. <br><br>  Si dans votre situation, les avantages ci-dessus jouent un rôle décisif (ou sont une condition nécessaire), il est alors judicieux d'utiliser la réplication de haut niveau.  Examinons plusieurs façons d'implémenter la réplication de données de haut niveau dans le SGBD Tarantool. <br><br><h2>  Minimisation du trafic </h2><br>  Ainsi, l'un des avantages de la réplication de haut niveau est la réduction du trafic.  Pour que cet avantage se manifeste pleinement, il est nécessaire de minimiser la quantité de données transmises lors de chaque session d'échange.  Bien entendu, il ne faut pas oublier qu'à la fin de la session le récepteur de données doit être synchronisé avec la source (au moins pour la partie des données impliquée dans la réplication). <br><br>  Comment minimiser la quantité de données transférées lors de la réplication de haut niveau?  La solution "au front" peut être la sélection des données par date-heure.  Pour ce faire, vous pouvez utiliser le champ date-heure déjà dans le tableau (le cas échéant).  Par exemple, un document «ordre» peut avoir un champ «temps requis pour l'exécution de l'ordre» - <code>delivery_time</code> .  Le problème avec cette solution est que les valeurs de ce champ ne doivent pas nécessairement être dans la séquence correspondant à la création des commandes.  Ainsi, nous ne pouvons pas nous souvenir de la valeur maximale du champ <code>delivery_time</code> transmise lors de la session d'échange précédente, et lors de la session d'échange suivante, sélectionnez tous les enregistrements avec une valeur plus élevée du champ <code>delivery_time</code> .  Dans l'intervalle entre les sessions d'échange, des enregistrements avec une valeur plus petite du champ <code>delivery_time</code> peuvent être ajoutés.  De plus, la commande pourrait subir des modifications, ce qui n'affectait néanmoins pas le champ <code>delivery_time</code> .  Dans les deux cas, les modifications ne seront pas transmises de la source au récepteur.  Pour résoudre ces problèmes, nous devrons transmettre des données "en chevauchement".  C'est-à-dire  au cours de chaque session d'échange, nous transférerons toutes les données avec une valeur de champ <code>delivery_time</code> qui dépasse un certain point dans le passé (par exemple, N heures à partir du moment actuel).  Cependant, il est évident que pour les grands systèmes, cette approche est très redondante et peut réduire les économies de trafic que nous visons.  De plus, la table transmise peut ne pas avoir de champ date-heure. <br><br>  Une autre solution, plus complexe en termes de mise en œuvre, consiste à accuser réception des données.  Dans ce cas, à chaque session d'échange, toutes les données sont transmises, dont la réception n'est pas confirmée par le destinataire.  Pour l'implémentation, vous devez ajouter une colonne booléenne à la table source (par exemple, <code>is_transferred</code> ).  Si le destinataire confirme la réception de l'enregistrement, le champ correspondant est défini sur <code>true</code> , après quoi l'enregistrement n'est plus impliqué dans les échanges.  Cette option de mise en œuvre présente les inconvénients suivants.  Tout d'abord, pour chaque enregistrement transféré, il est nécessaire de générer et d'envoyer une confirmation.  En gros, cela peut être comparable à doubler la quantité de données transférées et à doubler le nombre de voyages aller-retour.  Deuxièmement, il n'est pas possible d'envoyer le même enregistrement à plusieurs récepteurs (le premier récepteur confirmera la réception pour lui-même et pour tout le monde). <br><br>  La méthode, dépourvue des inconvénients ci-dessus, consiste à ajouter des colonnes au tableau à transmettre pour suivre les modifications de ses lignes.  Une telle colonne peut être de type date-heure et doit être définie / mise à jour par l'application pour l'heure actuelle à chaque fois en ajoutant / changeant des enregistrements (atomiquement avec en ajoutant / changeant).  À titre d'exemple, appelons la colonne <code>update_time</code> .  Après avoir enregistré la valeur maximale du champ de cette colonne pour les enregistrements transférés, nous pouvons démarrer la prochaine session d'échange à partir de cette valeur (sélectionnez les enregistrements dont la valeur du champ <code>update_time</code> dépasse la valeur précédemment enregistrée).  Le problème avec cette dernière approche est que les changements de données peuvent se produire en mode batch.  Par conséquent, les valeurs de champ dans la colonne <code>update_time</code> ne pas être uniques.  Par conséquent, cette colonne ne peut pas être utilisée pour la sortie de données par lots (page).  Pour la sortie des données page par page, il sera nécessaire d'inventer des mécanismes supplémentaires susceptibles d'avoir une très faible efficacité (par exemple, extraire de la base de données tous les enregistrements avec <code>update_time</code> au-dessus de la valeur spécifiée et émettre un certain nombre d'enregistrements, en commençant à un certain décalage par rapport au début de l'échantillon). <br><br>  Vous pouvez augmenter l'efficacité du transfert de données en améliorant légèrement l'approche précédente.  Pour ce faire, nous utiliserons un type entier (entier long) comme valeurs des champs de colonne pour suivre les modifications.  <code>row_ver</code> colonne <code>row_ver</code> .  La valeur de champ de cette colonne doit toujours être définie / mise à jour chaque fois qu'un enregistrement est créé / modifié.  Mais dans ce cas, le champ sera attribué non pas la date-heure actuelle, mais la valeur d'un compteur augmentée d'une unité.  Par conséquent, la colonne <code>row_ver</code> contiendra des valeurs uniques et peut être utilisée non seulement pour sortir des données «delta» (données ajoutées / modifiées après la fin de la session d'échange précédente), mais aussi pour une pagination simple et efficace. <br><br>  La dernière méthode proposée pour minimiser la quantité de données transférées dans le cadre d'une réplication de haut niveau me semble la plus optimale et la plus universelle.  Arrêtons-nous dessus plus en détail. <br><br><h2>  Transfert de données à l'aide du compteur de version de ligne </h2><br><h4>  Implémentation serveur / maître </h4><br>  Dans MS SQL Server, pour implémenter cette approche, il existe un type de colonne spécial - <code>rowversion</code> .  Chaque base de données a un compteur, qui augmente d'une unité chaque fois que vous ajoutez / modifiez un enregistrement dans une table qui a une colonne de type <code>rowversion</code> .  La valeur de ce compteur est automatiquement affectée au champ de cette colonne dans l'enregistrement ajouté / modifié.  Tarantool DBMS n'a pas de mécanisme intégré similaire.  Cependant, dans Tarantool, il n'est pas difficile de l'implémenter manuellement.  Considérez comment cela se fait. <br><br>  Tout d'abord, un peu de terminologie: les tables de Tarantool sont appelées espace et les enregistrements sont appelés tuple.  Dans Tarantool, vous pouvez créer des séquences.  Les séquences ne sont rien de plus que des générateurs nommés de valeurs ordonnées d'entiers.  C'est-à-dire  c'est exactement ce dont nous avons besoin pour nos besoins.  Ci-dessous, nous allons créer une telle séquence. <br><br>  Avant d'effectuer une opération de base de données dans Tarantool, vous devez exécuter la commande suivante: <br><br><pre> <code class="lua hljs">box.cfg{}</code> </pre> <br>  Par conséquent, Tarantool commencera à écrire des instantanés et un journal des transactions dans le répertoire actuel. <br><br>  Créez une séquence <code>row_version</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_version'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  L'option <code>if_not_exists</code> permet d'exécuter le script de création plusieurs fois: si l'objet existe, Tarantool n'essaiera pas de le recréer.  Cette option sera utilisée dans toutes les commandes DDL suivantes. <br><br>  Créons un espace pour un exemple. <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Ici, nous définissons le nom de l'espace ( <code>goods</code> ), les noms des champs et leurs types. <br><br>  Les champs d'incrémentation automatique de Tarantool sont également créés à l'aide de séquences.  Créez une clé primaire à incrémentation automatique pour le champ <code>id</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Tarantool prend en charge plusieurs types d'index.  Le plus souvent, des index des types TREE et HASH sont utilisés, qui sont basés sur les structures correspondant au nom.  TREE est le type d'index le plus polyvalent.  Il vous permet de récupérer des données de manière ordonnée.  Mais pour le choix de l'égalité, HASH est plus adapté.  En conséquence, il est conseillé d'utiliser HASH pour la clé primaire (ce que nous avons fait). <br><br>  Pour utiliser la colonne <code>row_ver</code> pour transmettre des données modifiées, vous devez lier les valeurs de séquence <code>row_ver</code> aux champs de cette colonne.  Mais contrairement à la clé primaire, la valeur du champ dans la colonne <code>row_ver</code> doit augmenter d'une <code>row_ver</code> , non seulement lors de l'ajout de nouveaux enregistrements, mais également lors de la modification des enregistrements existants.  Pour ce faire, vous pouvez utiliser des déclencheurs.  Tarantool a deux types de déclencheurs pour les espaces: <code>before_replace</code> et <code>on_replace</code> .  Les déclencheurs sont déclenchés chaque fois que les données de l'espace sont modifiées (pour chaque tuple affecté par les modifications, la fonction de déclenchement est déclenchée).  Contrairement à <code>on_replace</code> , les déclencheurs <code>before_replace</code> vous permettent de modifier les données du tuple pour lequel le déclencheur est exécuté.  En conséquence, le dernier type de déclencheurs nous convient. <br><br><pre> <code class="lua hljs">box.space.goods:before_replace(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old, new)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> box.tuple.new({new[<span class="hljs-number"><span class="hljs-number">1</span></span>], new[<span class="hljs-number"><span class="hljs-number">2</span></span>], new[<span class="hljs-number"><span class="hljs-number">3</span></span>], box.sequence.row_version:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br>  Ce déclencheur remplace la valeur du champ <code>row_ver</code> du tuple stocké par la <code>row_version</code> séquence <code>row_version</code> suivante. <br><br>  Afin de pouvoir extraire des données de l'espace <code>goods</code> sur la colonne <code>row_ver</code> , créez un index: <br><br><pre> <code class="lua hljs">box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'TREE'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Le type d'index est un arbre ( <code>TREE</code> ), car  nous devons récupérer les données dans l'ordre croissant des valeurs dans la colonne <code>row_ver</code> . <br><br>  Ajoutez des données à l'espace: <br><br><pre> <code class="lua hljs">box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pen'</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pencil'</span></span>, <span class="hljs-number"><span class="hljs-number">321</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'brush'</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'watercolour'</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'album'</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'notebook'</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'rubber'</span></span>, <span class="hljs-number"><span class="hljs-number">531</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'ruler'</span></span>, <span class="hljs-number"><span class="hljs-number">135</span></span>}</code> </pre> <br>  Parce que  le premier champ est un compteur d'incrémentation automatique, nous passons nil à la place.  Tarantool remplacera automatiquement la valeur suivante.  De même, vous pouvez passer nil comme valeur des champs dans la colonne <code>row_ver</code> - ou ne pas spécifier la valeur du tout, car  cette colonne prend la dernière position dans l'espace. <br><br>  Vérifiez le résultat de l'insert: <br><br><pre> <code class="lua hljs">tarantool&gt; box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>() <span class="hljs-comment"><span class="hljs-comment">--- - - [1, 'pen', 123, 1] - [2, 'pencil', 321, 2] - [3, 'brush', 100, 3] - [4, 'watercolour', 456, 4] - [5, 'album', 101, 5] - [6, 'notebook', 800, 6] - [7, 'rubber', 531, 7] - [8, 'ruler', 135, 8] ...</span></span></code> </pre> <br>  Comme vous pouvez le voir, le premier et le dernier champ ont été remplis automatiquement.  Maintenant, il sera facile d'écrire une fonction pour paginer le déchargement des <code>goods</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> page_size = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> index = box.space.goods.index.row_ver <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> goods = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tuple <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> index:<span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(row_ver, { iterator = <span class="hljs-string"><span class="hljs-string">'GT'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = tuple:tomap({ names_only = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(goods, obj) counter = counter + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> counter &gt;= page_size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goods <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La fonction prend en paramètre la valeur <code>row_ver</code> du dernier enregistrement reçu (0 pour le premier appel) et renvoie le prochain lot de données modifiées (s'il y en a un, sinon un tableau vide). <br><br>  La récupération des données dans Tarantool se fait via des index.  La fonction <code>get_goods</code> utilise l' <code>row_ver</code> index <code>row_ver</code> pour récupérer les données modifiées.  Le type d'itérateur est GT (supérieur à, supérieur à).  Cela signifie que l'itérateur parcourra séquentiellement les valeurs d'index à partir de la valeur suivante après la clé transmise. <br><br>  L'itérateur renvoie les tuples.  Afin de pouvoir ultérieurement transférer des données via HTTP, il est nécessaire de convertir les tuples en une structure pratique pour une sérialisation ultérieure.  Dans l'exemple, la fonction <code>tomap</code> standard est utilisée pour cela.  Au lieu d'utiliser <code>tomap</code> vous pouvez écrire votre propre fonction.  Par exemple, nous pourrions vouloir renommer le champ de <code>name</code> , ne pas passer le champ de <code>code</code> et ajouter le champ de <code>comment</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unflatten_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = {} obj.id = tuple.id obj.goods_name = tuple.name obj.comment = <span class="hljs-string"><span class="hljs-string">'some comment'</span></span> obj.row_ver = tuple.row_ver <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La taille de page des données de sortie (le nombre d'enregistrements dans une partie) est déterminée par la variable <code>page_size</code> .  Dans l'exemple, la valeur de <code>page_size</code> est 5. Dans un programme réel, la taille de la page est généralement plus importante.  Cela dépend de la taille moyenne du tuple spatial.  La taille de page optimale peut être sélectionnée empiriquement en mesurant le temps de transfert des données.  Plus la page est grande, plus le nombre d'allers-retours entre les côtés émetteur et récepteur est faible.  Vous pouvez donc réduire le temps total de téléchargement des modifications.  Cependant, si la taille de la page est trop grande, nous prendrons trop de temps au serveur pour sérialiser la sélection.  Par conséquent, il peut y avoir des retards dans le traitement des autres demandes qui sont parvenues au serveur.  Le paramètre <code>page_size</code> peut être chargé à partir du fichier de configuration.  Pour chaque espace transmis, vous pouvez définir votre propre valeur.  Cependant, pour la plupart des espaces, la valeur par défaut (par exemple, 100) peut convenir. <br><br>  <code>get_goods</code> fonction <code>get_goods</code> dans le module.  Créez un fichier repl.lua contenant la description de la variable <code>page_size</code> et la fonction <code>get_goods</code> .  À la fin du fichier, ajoutez la fonction d'exportation: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get_goods = get_goods }</code> </pre><br>  Pour charger le module, exécutez: <br><br><pre> <code class="lua hljs">tarantool&gt; repl = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'repl'</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- ...</span></span></code> </pre><br>  <code>get_goods</code> fonction <code>get_goods</code> : <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 1 code: 123 name: pen id: 1 - row_ver: 2 code: 321 name: pencil id: 2 - row_ver: 3 code: 100 name: brush id: 3 - row_ver: 4 code: 456 name: watercolour id: 4 - row_ver: 5 code: 101 name: album id: 5 ...</span></span></code> </pre> <br>  Prenez la valeur du champ <code>row_ver</code> de la dernière ligne et appelez à nouveau la fonction: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 6 code: 800 name: notebook id: 6 - row_ver: 7 code: 531 name: rubber id: 7 - row_ver: 8 code: 135 name: ruler id: 8 ...</span></span></code> </pre> <br>  Et encore: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - [] ...</span></span></code> </pre> <br>  Comme vous pouvez le voir, avec cette utilisation, la fonction page par page renvoie tous les enregistrements de l'espace <code>goods</code> .  La dernière page est suivie d'une sélection vide. <br><br>  Nous apporterons des modifications à l'espace: <br><br><pre> <code class="lua hljs">box.space.goods:update(<span class="hljs-number"><span class="hljs-number">4</span></span>, {{<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'copybook'</span></span>}}) box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'clip'</span></span>, <span class="hljs-number"><span class="hljs-number">234</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'folder'</span></span>, <span class="hljs-number"><span class="hljs-number">432</span></span>}</code> </pre> <br>  Nous avons modifié la valeur du champ de <code>name</code> pour un enregistrement et ajouté deux nouveaux enregistrements. <br><br>  Répétez le dernier appel de fonction: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 9 code: 800 name: copybook id: 6 - row_ver: 10 code: 234 name: clip id: 9 - row_ver: 11 code: 432 name: folder id: 10 ...</span></span></code> </pre> <br>  La fonction a renvoyé les enregistrements modifiés et ajoutés.  Ainsi, la fonction <code>get_goods</code> permet d'obtenir des données qui ont changé depuis son dernier appel, qui est la base de la méthode de réplication considérée. <br><br>  Nous laissons la sortie des résultats via HTTP sous forme de JSON au-delà de la portée de cet article.  Vous pouvez en lire plus ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/ru/company/mailru/blog/272141/</a> <br><br><h4>  Réalisation de la partie client / esclave </h4><br>  Considérez à quoi ressemble la mise en œuvre du côté récepteur.  Créez un espace côté réception pour stocker les données téléchargées: <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  La structure de l'espace ressemble à la structure de l'espace dans la source.  Mais comme nous <code>row_ver</code> pas transférer les données reçues ailleurs, la colonne <code>row_ver</code> est <code>row_ver</code> dans l'espace du récepteur.  Dans le champ <code>id</code> seront inscrits les identifiants de la source.  Par conséquent, côté récepteur, il n'est pas nécessaire de l'incrémenter automatiquement. <br><br>  De plus, nous avons besoin d'un espace pour enregistrer les valeurs <code>row_ver</code> : <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'space_name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.row_ver:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'space_name'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Pour chaque espace chargé (champ <code>space_name</code> ), nous enregistrerons ici la dernière valeur chargée <code>row_ver</code> ( <code>value</code> champ).  La clé primaire est la colonne <code>space_name</code> . <br><br>  Créons une fonction pour charger les données de l'espace <code>goods</code> via HTTP.  Pour ce faire, nous avons besoin d'une bibliothèque qui implémente un client HTTP.  La ligne suivante charge la bibliothèque et instancie le client HTTP: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> http_client = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http.client'</span></span>).new()</code> </pre> <br>  Nous avons également besoin d'une bibliothèque pour la désérialisation json: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> json = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'json'</span></span>)</code> </pre> <br>  Cela suffit pour créer une fonction de chargement des données: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> url = (<span class="hljs-string"><span class="hljs-string">'%s?rowVer=%s'</span></span>):<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(url, <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(row_ver)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> data = http_client:request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, body, { keepalive_idle = <span class="hljs-number"><span class="hljs-number">1</span></span>, keepalive_interval = <span class="hljs-number"><span class="hljs-number">1</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.decode(data.body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La fonction exécute une requête HTTP à l'URL, lui transmet <code>row_ver</code> comme paramètre et renvoie le résultat désérialisé de la requête. <br><br>  La fonction de sauvegarde des données reçues est la suivante: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(goods)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> n = #goods box.atomic(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, n <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = goods[i] box.space.goods:put( obj.id, obj.name, obj.code) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Le cycle de stockage des données dans l'espace <code>goods</code> est placé dans une transaction (la fonction <code>box.atomic</code> est utilisée pour cela) afin de réduire le nombre d'opérations sur disque. <br><br>  Enfin, la fonction de synchronisation des <code>goods</code> spatiaux locaux avec la source peut être implémentée comme suit: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tuple = box.space.row_ver:get(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> row_ver = tuple <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tuple.value <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set your url here: local url = 'http://127.0.0.1:81/test/goods/list' while true do local goods = load_goods(url, row_ver) local count = #goods if count == 0 then return end save_goods(goods) row_ver = goods[count].rowVer box.space.row_ver:put({'goods', row_ver}) end end</span></span></code> </pre> <br>  Tout d'abord, nous lisons la valeur <code>row_ver</code> précédemment enregistrée pour l'espace des <code>goods</code> .  S'il est absent (la première session d'échange), alors nous prenons zéro comme <code>row_ver</code> .  Ensuite, dans la boucle, nous paginons les données modifiées de la source vers l'URL spécifiée.  À chaque itération, nous enregistrons les données reçues dans l'espace local correspondant et <code>row_ver</code> jour la valeur <code>row_ver</code> (dans l' <code>row_ver</code> row_ver et dans la variable <code>row_ver</code> ) - nous prenons la valeur <code>row_ver</code> de la dernière ligne des données chargées. <br><br>  Pour se protéger contre les boucles accidentelles (en cas d'erreur dans le programme), la <code>while</code> peut être remplacée par <code>for</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ = <span class="hljs-number"><span class="hljs-number">1</span></span>, max_req <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ...</code> </pre> <br>  Grâce à la fonction <code>sync_goods</code> , les <code>goods</code> dans le récepteur contiendront les dernières versions de tous les enregistrements d'espace <code>goods</code> dans la source. <br><br>  De toute évidence, la suppression des données ne peut pas être diffusée de cette manière.  Si un tel besoin existe, vous pouvez utiliser la marque de suppression.  Ajoutez le champ booléen <code>is_deleted</code> espace des <code>goods</code> et utilisez la suppression logique au lieu de supprimer physiquement l'enregistrement - définissez la valeur du champ <code>is_deleted</code> sur <code>true</code> .  Parfois, au lieu du champ booléen <code>is_deleted</code> , <code>is_deleted</code> plus pratique d'utiliser le champ <code>deleted</code> , qui stocke la date-heure de la suppression logique de l'enregistrement.  Après avoir effectué une suppression logique, l'enregistrement marqué pour suppression sera transféré de la source au récepteur (selon la logique décrite ci-dessus). <br><br>  La séquence <code>row_ver</code> peut être utilisée pour transférer des données depuis d'autres espaces: il n'est pas nécessaire de créer une séquence distincte pour chaque espace transmis. <br><br>  Nous avons examiné un moyen efficace de réplication de données de haut niveau dans les applications utilisant le SGBD Tarantool. <br><br><h2>  Conclusions </h2><br><ol><li>  Tarantool DBMS est un produit attrayant et prometteur pour la création d'applications très chargées. <br></li><li>  La réplication de haut niveau offre une approche plus flexible du transfert de données par rapport à la réplication de bas niveau. <br></li><li>  La méthode de réplication de haut niveau envisagée dans l'article permet de minimiser la quantité de données transmises en transférant uniquement les enregistrements qui ont changé depuis la dernière session d'échange. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455146/">https://habr.com/ru/post/fr455146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455132/index.html">Antiquités: Philips Velo 1, le cauchemar d'un passionné de technologie</a></li>
<li><a href="../fr455134/index.html">Que s'est-il souvenu du passé Heisenbug et que va-t-il se passer ensuite?</a></li>
<li><a href="../fr455136/index.html">Pourquoi le simple pompage du codage ne fera pas de vous un meilleur développeur</a></li>
<li><a href="../fr455138/index.html">JetBrains Night Moscou: comment c'était</a></li>
<li><a href="../fr455144/index.html">Se préparer pour 2020: 8 tendances en matière de développement JavaScript côté client que vous devez connaître</a></li>
<li><a href="../fr455148/index.html">Nous résolvons les tâches décisionnelles basées sur les données</a></li>
<li><a href="../fr455152/index.html">Améliorez votre application mobile grâce à la technologie d'apprentissage automatique</a></li>
<li><a href="../fr455156/index.html">Tâches de séquençage domestique (juin 2019)</a></li>
<li><a href="../fr455158/index.html">Les merveilles de la méthodologie comptable: fonds d'amortissement</a></li>
<li><a href="../fr455160/index.html">Entity Framework 6 avec recherche en texte intégral via LINQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>