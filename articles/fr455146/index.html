<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≤ üôÅ üëäüèø R√©plication de haut niveau dans le SGBD Tarantool üÖæÔ∏è üë∏üèª ‚úçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, je cr√©e des applications pour le SGBD Tarantool - il s'agit d'une plateforme d√©velopp√©e par Mail.ru Group qui combine un SGBD hautes performa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©plication de haut niveau dans le SGBD Tarantool</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/455146/">  Bonjour, je cr√©e des applications pour le SGBD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tarantool</a> - il s'agit d'une plateforme d√©velopp√©e par Mail.ru Group qui combine un SGBD hautes performances et un serveur d'applications √† Lua.  La vitesse √©lev√©e des solutions bas√©es sur Tarantool est obtenue, en particulier, en prenant en charge le mode SGBD en m√©moire et la possibilit√© d'ex√©cuter la logique d'application m√©tier dans un espace d'adressage unique avec des donn√©es.  Cela garantit la persistance des donn√©es √† l'aide des transactions ACID (un journal WAL est conserv√© sur le disque).  Tarantool a un support de r√©plication et de partitionnement int√©gr√©.  √Ä partir de la version 2.1, les requ√™tes SQL sont prises en charge.  Tarantool est open source et sous licence BSD simplifi√©e.  Il existe √©galement une version commerciale d'entreprise. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4aa/22f/d04/4aa22fd046775dd3b44af444ddcde28d.jpg"><br>  <i>Ressentez le pouvoir!</i>  <i>(... aka profitez de la performance)</i> <br><br>  Tout cela fait de Tarantool une plate-forme attrayante pour cr√©er des applications de base de donn√©es tr√®s charg√©es.  Dans de telles applications, la r√©plication des donn√©es devient souvent n√©cessaire. <br><a name="habracut"></a><br>  Comme mentionn√© ci-dessus, Tarantool a une r√©plication de donn√©es int√©gr√©e.  Le principe de son travail est l'ex√©cution s√©quentielle sur des r√©pliques de toutes les transactions contenues dans le journal de l'assistant (WAL).  Typiquement, une telle r√©plication (nous l'appellerons <i>bas niveau</i> ci <i>-</i> dessous) est utilis√©e pour fournir une tol√©rance aux pannes de l'application et / ou pour r√©partir la charge de lecture entre les n≈ìuds du cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1c/31b/83b/d1c31b83b1c71220a514deebb7d49952.png"><br>  <i>Fig.</i>  <i>1. R√©plication au sein du cluster</i> <br><br>  Un exemple de sc√©nario alternatif est le transfert de donn√©es cr√©√©es dans une base de donn√©es vers une autre base de donn√©es pour traitement / surveillance.  Dans ce dernier cas, une solution plus pratique peut √™tre d'utiliser la r√©plication de <i>haut niveau</i> - r√©plication des donn√©es au niveau de la logique m√©tier de l'application.  C'est-√†-dire  Nous n'utilisons pas de solution pr√™te √† l'emploi int√©gr√©e au SGBD, mais nous impl√©mentons nous-m√™mes la r√©plication dans l'application que nous d√©veloppons.  Cette approche pr√©sente √† la fois des avantages et des inconv√©nients.  Nous listons les avantages. <br><br>  1. √âconomisez du trafic: <br><br><ul><li>  vous ne pouvez pas transf√©rer toutes les donn√©es, mais seulement une partie de celles-ci (par exemple, vous ne pouvez transf√©rer que certaines tables, certaines de leurs colonnes ou enregistrements qui r√©pondent √† un certain crit√®re); <br></li><li>  contrairement √† la r√©plication de bas niveau, qui est effectu√©e en continu en mode asynchrone (impl√©ment√© dans la version actuelle de Tarantool - 1.10) ou synchrone (√† impl√©menter dans les futures versions de Tarantool), la r√©plication de haut niveau peut √™tre effectu√©e par sessions (c'est-√†-dire que l'application effectue d'abord la synchronisation des donn√©es - session d'√©change donn√©es, puis il y a une pause dans la r√©plication, apr√®s quoi la prochaine session d'√©change a lieu, etc.); <br></li><li>  si l'enregistrement a chang√© plusieurs fois, vous ne pouvez transf√©rer que sa derni√®re version (contrairement √† la r√©plication de bas niveau, dans laquelle toutes les modifications apport√©es √† l'assistant seront lues s√©quentiellement sur les r√©pliques). <br></li></ul><br>  2. La mise en ≈ìuvre de l'√©change via HTTP ne pose aucune difficult√©, ce qui vous permet de synchroniser des bases de donn√©es distantes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/551/551/7aa/5515517aaa739f6260023c5e8ff30bf0.png"><br>  <i>Fig.</i>  <i>2. R√©plication HTTP</i> <br><br>  3. Les structures de base de donn√©es entre lesquelles les donn√©es sont transmises ne doivent pas √™tre les m√™mes (en outre, dans le cas g√©n√©ral, il est m√™me possible d'utiliser diff√©rents SGBD, langages de programmation, plates-formes, etc.). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/830/85a/64b/83085a64b69ff5dba2431db97213fa82.png"><br>  <i>Fig.</i>  <i>3. R√©plication dans des syst√®mes h√©t√©rog√®nes</i> <br><br>  L'inconv√©nient est qu'en moyenne, la programmation est plus compliqu√©e / plus ch√®re que la configuration, et au lieu de configurer la fonctionnalit√© int√©gr√©e, vous devrez impl√©menter la v√¥tre. <br><br>  Si dans votre situation, les avantages ci-dessus jouent un r√¥le d√©cisif (ou sont une condition n√©cessaire), il est alors judicieux d'utiliser la r√©plication de haut niveau.  Examinons plusieurs fa√ßons d'impl√©menter la r√©plication de donn√©es de haut niveau dans le SGBD Tarantool. <br><br><h2>  Minimisation du trafic </h2><br>  Ainsi, l'un des avantages de la r√©plication de haut niveau est la r√©duction du trafic.  Pour que cet avantage se manifeste pleinement, il est n√©cessaire de minimiser la quantit√© de donn√©es transmises lors de chaque session d'√©change.  Bien entendu, il ne faut pas oublier qu'√† la fin de la session le r√©cepteur de donn√©es doit √™tre synchronis√© avec la source (au moins pour la partie des donn√©es impliqu√©e dans la r√©plication). <br><br>  Comment minimiser la quantit√© de donn√©es transf√©r√©es lors de la r√©plication de haut niveau?  La solution "au front" peut √™tre la s√©lection des donn√©es par date-heure.  Pour ce faire, vous pouvez utiliser le champ date-heure d√©j√† dans le tableau (le cas √©ch√©ant).  Par exemple, un document ¬´ordre¬ª peut avoir un champ ¬´temps requis pour l'ex√©cution de l'ordre¬ª - <code>delivery_time</code> .  Le probl√®me avec cette solution est que les valeurs de ce champ ne doivent pas n√©cessairement √™tre dans la s√©quence correspondant √† la cr√©ation des commandes.  Ainsi, nous ne pouvons pas nous souvenir de la valeur maximale du champ <code>delivery_time</code> transmise lors de la session d'√©change pr√©c√©dente, et lors de la session d'√©change suivante, s√©lectionnez tous les enregistrements avec une valeur plus √©lev√©e du champ <code>delivery_time</code> .  Dans l'intervalle entre les sessions d'√©change, des enregistrements avec une valeur plus petite du champ <code>delivery_time</code> peuvent √™tre ajout√©s.  De plus, la commande pourrait subir des modifications, ce qui n'affectait n√©anmoins pas le champ <code>delivery_time</code> .  Dans les deux cas, les modifications ne seront pas transmises de la source au r√©cepteur.  Pour r√©soudre ces probl√®mes, nous devrons transmettre des donn√©es "en chevauchement".  C'est-√†-dire  au cours de chaque session d'√©change, nous transf√©rerons toutes les donn√©es avec une valeur de champ <code>delivery_time</code> qui d√©passe un certain point dans le pass√© (par exemple, N heures √† partir du moment actuel).  Cependant, il est √©vident que pour les grands syst√®mes, cette approche est tr√®s redondante et peut r√©duire les √©conomies de trafic que nous visons.  De plus, la table transmise peut ne pas avoir de champ date-heure. <br><br>  Une autre solution, plus complexe en termes de mise en ≈ìuvre, consiste √† accuser r√©ception des donn√©es.  Dans ce cas, √† chaque session d'√©change, toutes les donn√©es sont transmises, dont la r√©ception n'est pas confirm√©e par le destinataire.  Pour l'impl√©mentation, vous devez ajouter une colonne bool√©enne √† la table source (par exemple, <code>is_transferred</code> ).  Si le destinataire confirme la r√©ception de l'enregistrement, le champ correspondant est d√©fini sur <code>true</code> , apr√®s quoi l'enregistrement n'est plus impliqu√© dans les √©changes.  Cette option de mise en ≈ìuvre pr√©sente les inconv√©nients suivants.  Tout d'abord, pour chaque enregistrement transf√©r√©, il est n√©cessaire de g√©n√©rer et d'envoyer une confirmation.  En gros, cela peut √™tre comparable √† doubler la quantit√© de donn√©es transf√©r√©es et √† doubler le nombre de voyages aller-retour.  Deuxi√®mement, il n'est pas possible d'envoyer le m√™me enregistrement √† plusieurs r√©cepteurs (le premier r√©cepteur confirmera la r√©ception pour lui-m√™me et pour tout le monde). <br><br>  La m√©thode, d√©pourvue des inconv√©nients ci-dessus, consiste √† ajouter des colonnes au tableau √† transmettre pour suivre les modifications de ses lignes.  Une telle colonne peut √™tre de type date-heure et doit √™tre d√©finie / mise √† jour par l'application pour l'heure actuelle √† chaque fois en ajoutant / changeant des enregistrements (atomiquement avec en ajoutant / changeant).  √Ä titre d'exemple, appelons la colonne <code>update_time</code> .  Apr√®s avoir enregistr√© la valeur maximale du champ de cette colonne pour les enregistrements transf√©r√©s, nous pouvons d√©marrer la prochaine session d'√©change √† partir de cette valeur (s√©lectionnez les enregistrements dont la valeur du champ <code>update_time</code> d√©passe la valeur pr√©c√©demment enregistr√©e).  Le probl√®me avec cette derni√®re approche est que les changements de donn√©es peuvent se produire en mode batch.  Par cons√©quent, les valeurs de champ dans la colonne <code>update_time</code> ne pas √™tre uniques.  Par cons√©quent, cette colonne ne peut pas √™tre utilis√©e pour la sortie de donn√©es par lots (page).  Pour la sortie des donn√©es page par page, il sera n√©cessaire d'inventer des m√©canismes suppl√©mentaires susceptibles d'avoir une tr√®s faible efficacit√© (par exemple, extraire de la base de donn√©es tous les enregistrements avec <code>update_time</code> au-dessus de la valeur sp√©cifi√©e et √©mettre un certain nombre d'enregistrements, en commen√ßant √† un certain d√©calage par rapport au d√©but de l'√©chantillon). <br><br>  Vous pouvez augmenter l'efficacit√© du transfert de donn√©es en am√©liorant l√©g√®rement l'approche pr√©c√©dente.  Pour ce faire, nous utiliserons un type entier (entier long) comme valeurs des champs de colonne pour suivre les modifications.  <code>row_ver</code> colonne <code>row_ver</code> .  La valeur de champ de cette colonne doit toujours √™tre d√©finie / mise √† jour chaque fois qu'un enregistrement est cr√©√© / modifi√©.  Mais dans ce cas, le champ sera attribu√© non pas la date-heure actuelle, mais la valeur d'un compteur augment√©e d'une unit√©.  Par cons√©quent, la colonne <code>row_ver</code> contiendra des valeurs uniques et peut √™tre utilis√©e non seulement pour sortir des donn√©es ¬´delta¬ª (donn√©es ajout√©es / modifi√©es apr√®s la fin de la session d'√©change pr√©c√©dente), mais aussi pour une pagination simple et efficace. <br><br>  La derni√®re m√©thode propos√©e pour minimiser la quantit√© de donn√©es transf√©r√©es dans le cadre d'une r√©plication de haut niveau me semble la plus optimale et la plus universelle.  Arr√™tons-nous dessus plus en d√©tail. <br><br><h2>  Transfert de donn√©es √† l'aide du compteur de version de ligne </h2><br><h4>  Impl√©mentation serveur / ma√Ætre </h4><br>  Dans MS SQL Server, pour impl√©menter cette approche, il existe un type de colonne sp√©cial - <code>rowversion</code> .  Chaque base de donn√©es a un compteur, qui augmente d'une unit√© chaque fois que vous ajoutez / modifiez un enregistrement dans une table qui a une colonne de type <code>rowversion</code> .  La valeur de ce compteur est automatiquement affect√©e au champ de cette colonne dans l'enregistrement ajout√© / modifi√©.  Tarantool DBMS n'a pas de m√©canisme int√©gr√© similaire.  Cependant, dans Tarantool, il n'est pas difficile de l'impl√©menter manuellement.  Consid√©rez comment cela se fait. <br><br>  Tout d'abord, un peu de terminologie: les tables de Tarantool sont appel√©es espace et les enregistrements sont appel√©s tuple.  Dans Tarantool, vous pouvez cr√©er des s√©quences.  Les s√©quences ne sont rien de plus que des g√©n√©rateurs nomm√©s de valeurs ordonn√©es d'entiers.  C'est-√†-dire  c'est exactement ce dont nous avons besoin pour nos besoins.  Ci-dessous, nous allons cr√©er une telle s√©quence. <br><br>  Avant d'effectuer une op√©ration de base de donn√©es dans Tarantool, vous devez ex√©cuter la commande suivante: <br><br><pre> <code class="lua hljs">box.cfg{}</code> </pre> <br>  Par cons√©quent, Tarantool commencera √† √©crire des instantan√©s et un journal des transactions dans le r√©pertoire actuel. <br><br>  Cr√©ez une s√©quence <code>row_version</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_version'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  L'option <code>if_not_exists</code> permet d'ex√©cuter le script de cr√©ation plusieurs fois: si l'objet existe, Tarantool n'essaiera pas de le recr√©er.  Cette option sera utilis√©e dans toutes les commandes DDL suivantes. <br><br>  Cr√©ons un espace pour un exemple. <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Ici, nous d√©finissons le nom de l'espace ( <code>goods</code> ), les noms des champs et leurs types. <br><br>  Les champs d'incr√©mentation automatique de Tarantool sont √©galement cr√©√©s √† l'aide de s√©quences.  Cr√©ez une cl√© primaire √† incr√©mentation automatique pour le champ <code>id</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Tarantool prend en charge plusieurs types d'index.  Le plus souvent, des index des types TREE et HASH sont utilis√©s, qui sont bas√©s sur les structures correspondant au nom.  TREE est le type d'index le plus polyvalent.  Il vous permet de r√©cup√©rer des donn√©es de mani√®re ordonn√©e.  Mais pour le choix de l'√©galit√©, HASH est plus adapt√©.  En cons√©quence, il est conseill√© d'utiliser HASH pour la cl√© primaire (ce que nous avons fait). <br><br>  Pour utiliser la colonne <code>row_ver</code> pour transmettre des donn√©es modifi√©es, vous devez lier les valeurs de s√©quence <code>row_ver</code> aux champs de cette colonne.  Mais contrairement √† la cl√© primaire, la valeur du champ dans la colonne <code>row_ver</code> doit augmenter d'une <code>row_ver</code> , non seulement lors de l'ajout de nouveaux enregistrements, mais √©galement lors de la modification des enregistrements existants.  Pour ce faire, vous pouvez utiliser des d√©clencheurs.  Tarantool a deux types de d√©clencheurs pour les espaces: <code>before_replace</code> et <code>on_replace</code> .  Les d√©clencheurs sont d√©clench√©s chaque fois que les donn√©es de l'espace sont modifi√©es (pour chaque tuple affect√© par les modifications, la fonction de d√©clenchement est d√©clench√©e).  Contrairement √† <code>on_replace</code> , les d√©clencheurs <code>before_replace</code> vous permettent de modifier les donn√©es du tuple pour lequel le d√©clencheur est ex√©cut√©.  En cons√©quence, le dernier type de d√©clencheurs nous convient. <br><br><pre> <code class="lua hljs">box.space.goods:before_replace(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old, new)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> box.tuple.new({new[<span class="hljs-number"><span class="hljs-number">1</span></span>], new[<span class="hljs-number"><span class="hljs-number">2</span></span>], new[<span class="hljs-number"><span class="hljs-number">3</span></span>], box.sequence.row_version:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br>  Ce d√©clencheur remplace la valeur du champ <code>row_ver</code> du tuple stock√© par la <code>row_version</code> s√©quence <code>row_version</code> suivante. <br><br>  Afin de pouvoir extraire des donn√©es de l'espace <code>goods</code> sur la colonne <code>row_ver</code> , cr√©ez un index: <br><br><pre> <code class="lua hljs">box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'TREE'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Le type d'index est un arbre ( <code>TREE</code> ), car  nous devons r√©cup√©rer les donn√©es dans l'ordre croissant des valeurs dans la colonne <code>row_ver</code> . <br><br>  Ajoutez des donn√©es √† l'espace: <br><br><pre> <code class="lua hljs">box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pen'</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pencil'</span></span>, <span class="hljs-number"><span class="hljs-number">321</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'brush'</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'watercolour'</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'album'</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'notebook'</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'rubber'</span></span>, <span class="hljs-number"><span class="hljs-number">531</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'ruler'</span></span>, <span class="hljs-number"><span class="hljs-number">135</span></span>}</code> </pre> <br>  Parce que  le premier champ est un compteur d'incr√©mentation automatique, nous passons nil √† la place.  Tarantool remplacera automatiquement la valeur suivante.  De m√™me, vous pouvez passer nil comme valeur des champs dans la colonne <code>row_ver</code> - ou ne pas sp√©cifier la valeur du tout, car  cette colonne prend la derni√®re position dans l'espace. <br><br>  V√©rifiez le r√©sultat de l'insert: <br><br><pre> <code class="lua hljs">tarantool&gt; box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>() <span class="hljs-comment"><span class="hljs-comment">--- - - [1, 'pen', 123, 1] - [2, 'pencil', 321, 2] - [3, 'brush', 100, 3] - [4, 'watercolour', 456, 4] - [5, 'album', 101, 5] - [6, 'notebook', 800, 6] - [7, 'rubber', 531, 7] - [8, 'ruler', 135, 8] ...</span></span></code> </pre> <br>  Comme vous pouvez le voir, le premier et le dernier champ ont √©t√© remplis automatiquement.  Maintenant, il sera facile d'√©crire une fonction pour paginer le d√©chargement des <code>goods</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> page_size = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> index = box.space.goods.index.row_ver <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> goods = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tuple <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> index:<span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(row_ver, { iterator = <span class="hljs-string"><span class="hljs-string">'GT'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = tuple:tomap({ names_only = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(goods, obj) counter = counter + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> counter &gt;= page_size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goods <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La fonction prend en param√®tre la valeur <code>row_ver</code> du dernier enregistrement re√ßu (0 pour le premier appel) et renvoie le prochain lot de donn√©es modifi√©es (s'il y en a un, sinon un tableau vide). <br><br>  La r√©cup√©ration des donn√©es dans Tarantool se fait via des index.  La fonction <code>get_goods</code> utilise l' <code>row_ver</code> index <code>row_ver</code> pour r√©cup√©rer les donn√©es modifi√©es.  Le type d'it√©rateur est GT (sup√©rieur √†, sup√©rieur √†).  Cela signifie que l'it√©rateur parcourra s√©quentiellement les valeurs d'index √† partir de la valeur suivante apr√®s la cl√© transmise. <br><br>  L'it√©rateur renvoie les tuples.  Afin de pouvoir ult√©rieurement transf√©rer des donn√©es via HTTP, il est n√©cessaire de convertir les tuples en une structure pratique pour une s√©rialisation ult√©rieure.  Dans l'exemple, la fonction <code>tomap</code> standard est utilis√©e pour cela.  Au lieu d'utiliser <code>tomap</code> vous pouvez √©crire votre propre fonction.  Par exemple, nous pourrions vouloir renommer le champ de <code>name</code> , ne pas passer le champ de <code>code</code> et ajouter le champ de <code>comment</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unflatten_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = {} obj.id = tuple.id obj.goods_name = tuple.name obj.comment = <span class="hljs-string"><span class="hljs-string">'some comment'</span></span> obj.row_ver = tuple.row_ver <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La taille de page des donn√©es de sortie (le nombre d'enregistrements dans une partie) est d√©termin√©e par la variable <code>page_size</code> .  Dans l'exemple, la valeur de <code>page_size</code> est 5. Dans un programme r√©el, la taille de la page est g√©n√©ralement plus importante.  Cela d√©pend de la taille moyenne du tuple spatial.  La taille de page optimale peut √™tre s√©lectionn√©e empiriquement en mesurant le temps de transfert des donn√©es.  Plus la page est grande, plus le nombre d'allers-retours entre les c√¥t√©s √©metteur et r√©cepteur est faible.  Vous pouvez donc r√©duire le temps total de t√©l√©chargement des modifications.  Cependant, si la taille de la page est trop grande, nous prendrons trop de temps au serveur pour s√©rialiser la s√©lection.  Par cons√©quent, il peut y avoir des retards dans le traitement des autres demandes qui sont parvenues au serveur.  Le param√®tre <code>page_size</code> peut √™tre charg√© √† partir du fichier de configuration.  Pour chaque espace transmis, vous pouvez d√©finir votre propre valeur.  Cependant, pour la plupart des espaces, la valeur par d√©faut (par exemple, 100) peut convenir. <br><br>  <code>get_goods</code> fonction <code>get_goods</code> dans le module.  Cr√©ez un fichier repl.lua contenant la description de la variable <code>page_size</code> et la fonction <code>get_goods</code> .  √Ä la fin du fichier, ajoutez la fonction d'exportation: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get_goods = get_goods }</code> </pre><br>  Pour charger le module, ex√©cutez: <br><br><pre> <code class="lua hljs">tarantool&gt; repl = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'repl'</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- ...</span></span></code> </pre><br>  <code>get_goods</code> fonction <code>get_goods</code> : <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 1 code: 123 name: pen id: 1 - row_ver: 2 code: 321 name: pencil id: 2 - row_ver: 3 code: 100 name: brush id: 3 - row_ver: 4 code: 456 name: watercolour id: 4 - row_ver: 5 code: 101 name: album id: 5 ...</span></span></code> </pre> <br>  Prenez la valeur du champ <code>row_ver</code> de la derni√®re ligne et appelez √† nouveau la fonction: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 6 code: 800 name: notebook id: 6 - row_ver: 7 code: 531 name: rubber id: 7 - row_ver: 8 code: 135 name: ruler id: 8 ...</span></span></code> </pre> <br>  Et encore: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - [] ...</span></span></code> </pre> <br>  Comme vous pouvez le voir, avec cette utilisation, la fonction page par page renvoie tous les enregistrements de l'espace <code>goods</code> .  La derni√®re page est suivie d'une s√©lection vide. <br><br>  Nous apporterons des modifications √† l'espace: <br><br><pre> <code class="lua hljs">box.space.goods:update(<span class="hljs-number"><span class="hljs-number">4</span></span>, {{<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'copybook'</span></span>}}) box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'clip'</span></span>, <span class="hljs-number"><span class="hljs-number">234</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'folder'</span></span>, <span class="hljs-number"><span class="hljs-number">432</span></span>}</code> </pre> <br>  Nous avons modifi√© la valeur du champ de <code>name</code> pour un enregistrement et ajout√© deux nouveaux enregistrements. <br><br>  R√©p√©tez le dernier appel de fonction: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 9 code: 800 name: copybook id: 6 - row_ver: 10 code: 234 name: clip id: 9 - row_ver: 11 code: 432 name: folder id: 10 ...</span></span></code> </pre> <br>  La fonction a renvoy√© les enregistrements modifi√©s et ajout√©s.  Ainsi, la fonction <code>get_goods</code> permet d'obtenir des donn√©es qui ont chang√© depuis son dernier appel, qui est la base de la m√©thode de r√©plication consid√©r√©e. <br><br>  Nous laissons la sortie des r√©sultats via HTTP sous forme de JSON au-del√† de la port√©e de cet article.  Vous pouvez en lire plus ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/ru/company/mailru/blog/272141/</a> <br><br><h4>  R√©alisation de la partie client / esclave </h4><br>  Consid√©rez √† quoi ressemble la mise en ≈ìuvre du c√¥t√© r√©cepteur.  Cr√©ez un espace c√¥t√© r√©ception pour stocker les donn√©es t√©l√©charg√©es: <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  La structure de l'espace ressemble √† la structure de l'espace dans la source.  Mais comme nous <code>row_ver</code> pas transf√©rer les donn√©es re√ßues ailleurs, la colonne <code>row_ver</code> est <code>row_ver</code> dans l'espace du r√©cepteur.  Dans le champ <code>id</code> seront inscrits les identifiants de la source.  Par cons√©quent, c√¥t√© r√©cepteur, il n'est pas n√©cessaire de l'incr√©menter automatiquement. <br><br>  De plus, nous avons besoin d'un espace pour enregistrer les valeurs <code>row_ver</code> : <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'space_name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.row_ver:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'space_name'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Pour chaque espace charg√© (champ <code>space_name</code> ), nous enregistrerons ici la derni√®re valeur charg√©e <code>row_ver</code> ( <code>value</code> champ).  La cl√© primaire est la colonne <code>space_name</code> . <br><br>  Cr√©ons une fonction pour charger les donn√©es de l'espace <code>goods</code> via HTTP.  Pour ce faire, nous avons besoin d'une biblioth√®que qui impl√©mente un client HTTP.  La ligne suivante charge la biblioth√®que et instancie le client HTTP: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> http_client = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http.client'</span></span>).new()</code> </pre> <br>  Nous avons √©galement besoin d'une biblioth√®que pour la d√©s√©rialisation json: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> json = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'json'</span></span>)</code> </pre> <br>  Cela suffit pour cr√©er une fonction de chargement des donn√©es: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> url = (<span class="hljs-string"><span class="hljs-string">'%s?rowVer=%s'</span></span>):<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(url, <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(row_ver)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> data = http_client:request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, body, { keepalive_idle = <span class="hljs-number"><span class="hljs-number">1</span></span>, keepalive_interval = <span class="hljs-number"><span class="hljs-number">1</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.decode(data.body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  La fonction ex√©cute une requ√™te HTTP √† l'URL, lui transmet <code>row_ver</code> comme param√®tre et renvoie le r√©sultat d√©s√©rialis√© de la requ√™te. <br><br>  La fonction de sauvegarde des donn√©es re√ßues est la suivante: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(goods)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> n = #goods box.atomic(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, n <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = goods[i] box.space.goods:put( obj.id, obj.name, obj.code) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Le cycle de stockage des donn√©es dans l'espace <code>goods</code> est plac√© dans une transaction (la fonction <code>box.atomic</code> est utilis√©e pour cela) afin de r√©duire le nombre d'op√©rations sur disque. <br><br>  Enfin, la fonction de synchronisation des <code>goods</code> spatiaux locaux avec la source peut √™tre impl√©ment√©e comme suit: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tuple = box.space.row_ver:get(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> row_ver = tuple <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tuple.value <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set your url here: local url = 'http://127.0.0.1:81/test/goods/list' while true do local goods = load_goods(url, row_ver) local count = #goods if count == 0 then return end save_goods(goods) row_ver = goods[count].rowVer box.space.row_ver:put({'goods', row_ver}) end end</span></span></code> </pre> <br>  Tout d'abord, nous lisons la valeur <code>row_ver</code> pr√©c√©demment enregistr√©e pour l'espace des <code>goods</code> .  S'il est absent (la premi√®re session d'√©change), alors nous prenons z√©ro comme <code>row_ver</code> .  Ensuite, dans la boucle, nous paginons les donn√©es modifi√©es de la source vers l'URL sp√©cifi√©e.  √Ä chaque it√©ration, nous enregistrons les donn√©es re√ßues dans l'espace local correspondant et <code>row_ver</code> jour la valeur <code>row_ver</code> (dans l' <code>row_ver</code> row_ver et dans la variable <code>row_ver</code> ) - nous prenons la valeur <code>row_ver</code> de la derni√®re ligne des donn√©es charg√©es. <br><br>  Pour se prot√©ger contre les boucles accidentelles (en cas d'erreur dans le programme), la <code>while</code> peut √™tre remplac√©e par <code>for</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ = <span class="hljs-number"><span class="hljs-number">1</span></span>, max_req <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ...</code> </pre> <br>  Gr√¢ce √† la fonction <code>sync_goods</code> , les <code>goods</code> dans le r√©cepteur contiendront les derni√®res versions de tous les enregistrements d'espace <code>goods</code> dans la source. <br><br>  De toute √©vidence, la suppression des donn√©es ne peut pas √™tre diffus√©e de cette mani√®re.  Si un tel besoin existe, vous pouvez utiliser la marque de suppression.  Ajoutez le champ bool√©en <code>is_deleted</code> espace des <code>goods</code> et utilisez la suppression logique au lieu de supprimer physiquement l'enregistrement - d√©finissez la valeur du champ <code>is_deleted</code> sur <code>true</code> .  Parfois, au lieu du champ bool√©en <code>is_deleted</code> , <code>is_deleted</code> plus pratique d'utiliser le champ <code>deleted</code> , qui stocke la date-heure de la suppression logique de l'enregistrement.  Apr√®s avoir effectu√© une suppression logique, l'enregistrement marqu√© pour suppression sera transf√©r√© de la source au r√©cepteur (selon la logique d√©crite ci-dessus). <br><br>  La s√©quence <code>row_ver</code> peut √™tre utilis√©e pour transf√©rer des donn√©es depuis d'autres espaces: il n'est pas n√©cessaire de cr√©er une s√©quence distincte pour chaque espace transmis. <br><br>  Nous avons examin√© un moyen efficace de r√©plication de donn√©es de haut niveau dans les applications utilisant le SGBD Tarantool. <br><br><h2>  Conclusions </h2><br><ol><li>  Tarantool DBMS est un produit attrayant et prometteur pour la cr√©ation d'applications tr√®s charg√©es. <br></li><li>  La r√©plication de haut niveau offre une approche plus flexible du transfert de donn√©es par rapport √† la r√©plication de bas niveau. <br></li><li>  La m√©thode de r√©plication de haut niveau envisag√©e dans l'article permet de minimiser la quantit√© de donn√©es transmises en transf√©rant uniquement les enregistrements qui ont chang√© depuis la derni√®re session d'√©change. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455146/">https://habr.com/ru/post/fr455146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455132/index.html">Antiquit√©s: Philips Velo 1, le cauchemar d'un passionn√© de technologie</a></li>
<li><a href="../fr455134/index.html">Que s'est-il souvenu du pass√© Heisenbug et que va-t-il se passer ensuite?</a></li>
<li><a href="../fr455136/index.html">Pourquoi le simple pompage du codage ne fera pas de vous un meilleur d√©veloppeur</a></li>
<li><a href="../fr455138/index.html">JetBrains Night Moscou: comment c'√©tait</a></li>
<li><a href="../fr455144/index.html">Se pr√©parer pour 2020: 8 tendances en mati√®re de d√©veloppement JavaScript c√¥t√© client que vous devez conna√Ætre</a></li>
<li><a href="../fr455148/index.html">Nous r√©solvons les t√¢ches d√©cisionnelles bas√©es sur les donn√©es</a></li>
<li><a href="../fr455152/index.html">Am√©liorez votre application mobile gr√¢ce √† la technologie d'apprentissage automatique</a></li>
<li><a href="../fr455156/index.html">T√¢ches de s√©quen√ßage domestique (juin 2019)</a></li>
<li><a href="../fr455158/index.html">Les merveilles de la m√©thodologie comptable: fonds d'amortissement</a></li>
<li><a href="../fr455160/index.html">Entity Framework 6 avec recherche en texte int√©gral via LINQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>