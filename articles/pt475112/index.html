<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬇️ 🙇🏼 ✌🏿 Autentique-me. Se você puder ... 📁 👨🏽‍⚖️ 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Frequentemente ouço perguntas como "Como implementar a autenticação em um aplicativo Android?", "Onde armazenar um PIN?", "Ei, cara, eu estarei seguro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Autentique-me. Se você puder ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/475112/"><p><img src="https://habrastorage.org/webt/p9/kd/qs/p9kdqsyke71dvzl72vxr24da0yc.jpeg"></p><br><p>  Frequentemente ouço perguntas como "Como implementar a autenticação em um aplicativo Android?", "Onde armazenar um PIN?", "Ei, cara, eu estarei seguro se implementar um recurso de autenticação dessa maneira?"  e muito do tipo.  Eu estava realmente cansado de responder a essas perguntas, então decidi escrever todos os meus pensamentos sobre isso uma vez para compartilhar com todos os questionadores. </p><a name="habracut"></a><br><h1 id="table-of-contents">  Sumário </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Autenticação: Por que eu tenho que fazer isso?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Maneira simples</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vamos melhorar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O caminho certo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mas espere, e quanto à biometria?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estou completamente protegido?</a> </li></ul><br><a name="why-do-I-have-to-do-it"></a><br><h1 id="authentication-why-do-i-have-to-do-it">  Autenticação: Por que eu tenho que fazer isso? </h1><br><p>  Vamos começar pela definição.  <strong>A autenticação</strong> (do grego: αὐθεντικός authentikos, "real, genuíno", de αὐθέντης authentes, "autor") é o ato de provar uma afirmação, como a identidade de um usuário de sistema de computador. </p><br><p>  Portanto, se seu aplicativo tiver informações confidenciais (as informações de qualquer usuário são sensíveis ao IMHO), você deverá adicionar um cenário de autenticação ao aplicativo para impedir o acesso não autorizado a essas informações. </p><br><p>  Os cenários de autenticação mais populares são os seguintes: </p><br><ul><li>  Login + Senha </li><li>  Senha mestra </li><li>  PIN (4 ou mais dígitos) </li><li>  Biometria </li></ul><br><p>  Naturalmente, a <strong>autenticação de login e senha</strong> chega ao seu aplicativo a partir de um back-end e a segurança desse mecanismo é deixada para a equipe de garantia de segurança;) Não se esqueça de implementar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Public Key Pinning</a> . </p><br><p>  <strong>A</strong> autenticação de <strong>senha mestra</strong> é muito raramente usada e apenas em aplicativos que exigem um alto nível de segurança (por exemplo, gerenciadores de senhas). </p><br><p>  Portanto, temos apenas dois cenários mais populares: um <strong>PIN</strong> e <strong>Biometria</strong> .  Eles são bastante fáceis de usar e relativamente fáceis de implementar (na verdade, não são ...).  Neste artigo, abordaremos os principais aspectos da implementação correta desses recursos. </p><br><a name="simple-way"></a><br><h1 id="simple-way">  Maneira simples </h1><br><p>  Imagine que você é um desenvolvedor Android e seu código imprime dinheiro.  Você não se preocupa com nada e não precisa de muita experiência em segurança de aplicativos móveis.  Mas um dia, um gerente chega até você e dá a tarefa de "Implementar uma autenticação adicional por meio de um PIN e uma impressão digital em nosso aplicativo".  A história começa aqui ... </p><br><p>  Para implementar a autenticação de PIN, você deve criar duas telas como estas: <br><img src="https://habrastorage.org/webt/7i/fe/0u/7ife0uw4kwm-yybqkot0pkvwue8.png"><img src="https://habrastorage.org/webt/mp/bl/ou/mpblouhttk5kpu9u5haezm6659i.png"></p><br><p>  E escreva esse código para criar e verificar seu PIN </p><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { preferences.edit().putString(StorageKey.PIN, pin).apply() }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { authenticationState.value = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pinIsValid(pin)) { AuthenticationState.AUTHENTICATED } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AuthenticationState.INVALID_AUTHENTICATION } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> preferences.getString(StorageKey.PIN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) == pin }</code> </pre> <br><p>  Isso é tudo!  Agora, você tem um sistema de autenticação legal por meio de um PIN.  Parabéns.  Foi tão fácil, não foi? </p><br><p>  Claro, você já pegou a ironia em minhas palavras.  Dessa forma, é muito ruim porque um PIN é armazenado como texto sem formatação.  Se algum malware obtiver acesso ao armazenamento interno do aplicativo, ele receberá o PIN do usuário como está.  Você pode me perguntar "Por que isso é tão ruim? É apenas um PIN da autenticação local ...".  Sim, mas os usuários tendem a definir o mesmo PIN em qualquer lugar.  Portanto, o conhecimento de um PIN de usuário permite que um invasor expanda a superfície de ataque. </p><br><p>  Além disso, esse esquema de autenticação não permite implementar a criptografia de dados do usuário com base em um PIN de maneira segura (falaremos sobre isso mais adiante). </p><br><a name="lets-make-it-better"></a><br><h1 id="lets-make-it-better">  Vamos melhorar </h1><br><p>  Como podemos melhorar nossa implementação anterior?  A primeira e óbvia abordagem é pegar um hash do seu PIN e armazená-lo. </p><br><blockquote>  Uma <strong>função hash</strong> é qualquer função que pode ser usada para mapear dados de tamanho arbitrário para valores de tamanho fixo.  Os valores retornados por uma função de hash são chamados de valores de hash, códigos de hash, resumos ou simplesmente hashes.  Os valores são usados ​​para indexar uma tabela de tamanho fixo chamada tabela de hash.  O uso de uma função hash para indexar uma tabela de hash é chamado de endereçamento de armazenamento de hash ou dispersão. </blockquote><p>  Existem muitas funções de hash disponíveis no Android Framework (na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Cryptography Architecture</a> , para ser mais preciso), mas hoje nem todas são consideradas seguras.  Eu não recomendo usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MD5</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SHA-1</a> devido a colisões.  O SHA-256 é uma boa opção para a maioria das tarefas. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byteArray: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> digest = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: NoSuchAlgorithmException) { MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> with(digest) { update(byteArray) digest() } }</code> </pre> <br><p>  Vamos modificar nosso <code>savePin(...)</code> para armazenar o PIN com hash </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hashedPin = sha256(pin.toByteArray()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedHash = Base64.encodeToString(hashedPin, Base64.DEFAULT) preferences.edit().putString(StorageKey.PIN, encodedHash).apply() }</code> </pre> <br><p>  Usar o hash é um bom começo, mas o hash simples não é suficiente para a nossa tarefa.  Na vida real, um invasor já <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pré-calculou</a> todos os hashes de PIN de 4 dígitos.  Ele poderá descriptografar todos os PINs hash roubados com bastante facilidade.  Existe uma abordagem para lidar com isso - um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sal</a> . </p><br><blockquote>  Na criptografia, um <strong>salt</strong> são dados aleatórios que são usados ​​como uma entrada adicional para uma função unidirecional que "hashes" dados, uma senha ou senha.  Os sais são usados ​​para proteger as senhas no armazenamento.  Historicamente, uma senha era armazenada em texto sem formatação em um sistema, mas com o tempo foram desenvolvidas salvaguardas adicionais para proteger a senha do usuário contra a leitura do sistema.  Um sal é um desses métodos. </blockquote><p>  Para adicionar um sal ao nosso mecanismo de segurança, precisamos alterar o código mostrado acima de maneira a </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lengthByte: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random = SecureRandom() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = ByteArray(lengthByte) random.nextBytes(salt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> salt }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Salt.generate() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> saltedPin = pin.toByteArray() + salt <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hashedPin = Sha256.hash(saltedPin) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedHash = Base64.encodeToString(hashedPin, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = Base64.encodeToString(salt, Base64.DEFAULT) preferences.edit() .putString(StorageKey.PIN, encodedHash) .putString(StorageKey.SALT, encodedSalt) .apply() }</code> </pre> <br><p>  Observe que você precisa armazenar o sal junto com o PIN, pois é necessário calcular o hash resultante (usando sal) sempre que verificar o PIN a partir da entrada do usuário. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = preferences.getString(StorageKey.SALT, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedHashedPin = preferences.getString(StorageKey.PIN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Base64.decode(encodedSalt, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> storedHashedPin = Base64.decode(encodedHashedPin, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enteredHashedPin = Sha256.hash(pin.toByteArray() + salt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> storedHashedPin contentEquals enteredHashedPin }</code> </pre> <br><p>  Como você pode ver, o código ainda não é tão difícil de entender, mas a segurança dessa solução se tornou muito mais forte.  Vou dizer ainda mais, essa abordagem está pronta para a produção para a maioria dos aplicativos que não exigem um alto nível de segurança. </p><br><p>  "Mas e se eu precisar de uma solução muito mais segura?", Você pergunta.  Ok, siga-me. </p><br><a name="the-right-way"></a><br><h1 id="the-right-way">  O caminho certo </h1><br><p>  Vamos discutir vários pontos de melhoria para nossa abordagem de autenticação. </p><br><p>  Em primeiro lugar, a principal falha dos "hashes comuns" (e mesmo dos "hashes comuns salgados") é a velocidade relativamente alta de um ataque de força bruta (cerca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bilhões de hashes por minuto</a> ).  Para eliminar essa falha, precisamos usar uma função KDF especial como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PBKDF2,</a> que é suportada nativamente pelo Android Framework.  Obviamente, há alguma diferença entre as funções do KDF e você provavelmente desejará escolher a outra, mas está fora do escopo deste artigo.  Darei a você vários links úteis sobre esse tópico no final do artigo. </p><br><p>  Em segundo lugar, não temos criptografia de dados do usuário neste momento.  Existem várias maneiras de implementá-lo e mostrarei a mais simples e a mais confiável.  Será um conjunto de duas bibliotecas e algum código em torno delas. </p><br><p>  Vamos escrever uma chave PBKDF2 criando fábrica para começar. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Pbkdf2Factory { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> DEFAULT_ITERATIONS = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> DEFAULT_KEY_LENGTH = <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKeyFactory <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) { SecretKeyFactory.getInstance(<span class="hljs-string"><span class="hljs-string">"PBKDF2withHmacSHA1"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { SecretKeyFactory.getInstance(<span class="hljs-string"><span class="hljs-string">"PBKDF2withHmacSHA256"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( passphraseOrPin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">, salt: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">, iterations: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = DEFAULT_ITERATIONS, outputKeyLength: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = DEFAULT_KEY_LENGTH )</span></span></span></span>: SecretKey { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keySpec = PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secretKeyFactory.generateSecret(keySpec) } }</code> </pre> <br><p>  Agora armados com esta fábrica, temos que refatorar nossos <code>savePin()</code> e <code>pinIsValid()</code> </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Salt.generate() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedKey = Base64.encodeToString(secretKey.encoded, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = Base64.encodeToString(salt, Base64.DEFAULT) preferences.edit() .putString(StorageKey.KEY, encodedKey) .putString(StorageKey.SALT, encodedSalt) .apply() pinIsCreated.value = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = preferences.getString(StorageKey.SALT, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedKey = preferences.getString(StorageKey.KEY, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Base64.decode(encodedSalt, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> storedKey = Base64.decode(encodedKey, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enteredKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> storedKey contentEquals enteredKey.encoded }</code> </pre> <br><p>  Assim, acabamos de mitigar a principal falha de nossa solução anterior.  É bom, e agora precisamos adicionar a criptografia de dados do usuário.  Para implementá-lo, usaremos estas bibliotecas: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sininho</a> - Uma biblioteca de várias plataformas e vários idiomas que fornece APIs criptográficas seguras, fáceis de usar corretamente e difíceis de usar incorretamente. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jetpack Security</a> - Leia e grave arquivos criptografados e preferências compartilhadas seguindo as práticas recomendadas de segurança. </li></ul><br><p>  Para obter um bom armazenamento criptografado, precisamos escrever esse código: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedStorage <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { EncryptedSharedPreferences.create( <span class="hljs-string"><span class="hljs-string">"main_storage"</span></span>, <span class="hljs-string"><span class="hljs-string">"main_storage_key"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV, EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM ) } ... }</code> </pre> <br><p>  Só isso.  Posteriormente, podemos trabalhar com ele como se fossem <code>SharedPreferences</code> regulares, mas todos os dados serão criptografados.  Agora podemos substituir facilmente a implementação anterior. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } ... }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputPinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } ... }</code> </pre> <br><p>  Vamos resumir o subtotal.  Temos uma chave bastante segura derivada de um PIN e uma abordagem bastante confiável para armazená-lo.  Parece legal, mas não o suficiente.  E se assumirmos que o invasor teve acesso ao nosso dispositivo e extraiu todos os dados dele.  Em teoria, ele tem todos os componentes para descriptografar os dados neste momento.  Para resolver esse problema, precisamos realizar duas coisas: </p><br><ul><li>  um PIN não está armazenado </li><li>  operações de criptografia são baseadas no PIN </li></ul><br><p>  Como podemos atingir esses objetivos sem reescrever todo o código?  É fácil!  Na medida em que usamos o Tink, podemos aplicar seu recurso de criptografia denominado como dados associados. </p><br><blockquote>  Dados associados a serem autenticados, mas não criptografados.  Os dados associados são opcionais, portanto, este parâmetro pode ser nulo.  Nesse caso, o valor nulo é equivalente a uma matriz de bytes vazia (comprimento zero).  Para a descriptografia bem-sucedida, os mesmos dados associados devem ser fornecidos junto com o texto cifrado. </blockquote><p>  É isso aí!  Podemos usar um PIN como dados associados para atingir nossas metas designadas.  Assim, a possibilidade ou impossibilidade de descriptografar os dados do usuário atuará como um indicador da correção do PIN.  Esse esquema geralmente funciona da seguinte maneira: </p><br><img src="https://habrastorage.org/webt/gt/b8/lp/gtb8lp4qsvavlqyyopgju6pmyxy.png" width="50%" height="50%"><br><p>  Se um usuário digitar um PIN incorreto, você receberá <strong>GeneralSecurityException</strong> ao tentar descriptografar o token de acesso.  Portanto, a implementação final pode ser assim: </p><br><div class="spoiler">  <b class="spoiler_title">Mostrar o código</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePinViewModel</span></span></span></span>(application: Application): AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fakeAccessToken = <span class="hljs-string"><span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZWNyZXQiOiJXZSdyZSBoaXJpbmcgOykifQ.WZrEWG-l3VsJzJrbnjn2BIYO68gHIGyat6jrw7Iu-Rw"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aead <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().pinSecuredAead } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Salt.generate() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedToken = aead.encrypt( fakeAccessToken.toByteArray(), secretKey.encoded ) preferences.edit { putString(StorageKey.TOKEN, Base64.encodeToString( encryptedToken, Base64.DEFAULT )) putString(StorageKey.SALT, Base64.encodeToString(salt, Base64.DEFAULT)) putBoolean(StorageKey.PIN_IS_ENABLED, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } ... } }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputPinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aead <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().pinSecuredAead } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { authenticationState.value = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pinIsValid(pin)) { AuthenticationState.AUTHENTICATED } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AuthenticationState.INVALID_AUTHENTICATION } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Base64.decode( preferences.getString(StorageKey.SALT, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> token = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedToken = Base64.decode( preferences.getString(StorageKey.TOKEN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) aead.decrypt(encryptedToken, secretKey.encoded) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: GeneralSecurityException) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token?.isNotEmpty() ?: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> </div></div><br><p>  Bom resultado!  Agora não estamos mais armazenando o PIN e todos os dados são criptografados por padrão.  Obviamente, existem várias maneiras de melhorar essa implementação, se você quiser.  Acabei de mostrar o princípio básico. </p><br><a name="what-about-biometrics"></a><br><h1 id="but-wait-what-about-biometrics">  Mas espere, e quanto à biometria? </h1><br><p>  Eu não acho que "biometria" é sobre segurança.  Prefiro chamá-lo de "um recurso de usuário muito conveniente".  E é uma guerra santa terrivelmente antiga entre conveniência e segurança.  Mas a maioria dos usuários gosta desse tipo de autenticação e nós, como desenvolvedores, precisamos implementá-lo o mais seguro possível. </p><br><p>  Infelizmente, a implementação de autenticação biométrica é bastante complicada.  É por isso que vou começar mostrando alguns princípios comuns de implementação e dar algumas explicações.  Depois disso, vamos nos aprofundar no código. </p><br><img src="https://habrastorage.org/webt/v-/dn/et/v-dnetfch9xp5ixpzghi-f1t1co.png" width="70%" height="70%"><br><p>  Este esquema contém uma nuance importante: <strong>A chave secreta é salva no disco</strong> .  Claro que não como um texto simples, mas mesmo assim. </p><br><p>  Como você pode ver, criamos uma nova chave de criptografia no keystore e usamos essa chave para criptografar nossa chave secreta derivada de um PIN.  Esse esquema nos permite não criptografar novamente todos os dados ao alterar um método de autenticação.  Além disso, ainda temos a capacidade de inserir um PIN se a autenticação biométrica falhar por algum motivo.  Ok, vamos escrever muito código. </p><br><p>  Primeiramente, mostrarei as alterações no fluxo de criação do PIN: </p><br><div class="spoiler">  <b class="spoiler_title">Mostrar o código</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePinViewModel</span></span></span></span>(application: Application): AndroidViewModel(application) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ANDROID_KEY_STORE = <span class="hljs-string"><span class="hljs-string">"AndroidKeyStore"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> KEY_NAME = <span class="hljs-string"><span class="hljs-string">"biometric_key"</span></span> } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricEnableDialog = MutableLiveData&lt;SingleLiveEvent&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricParams = MutableLiveData&lt;BiometricParams&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authenticationCallback = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : BiometricPrompt.AuthenticationCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(errorCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, errString: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationError(errorCode, errString) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationSucceeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AuthenticationResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationSucceeded(result) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedSecretKey = result.cryptoObject?.cipher?.doFinal( secretKey.encoded ) preferences.edit { putString(StorageKey.KEY, Base64.encodeToString( encryptedSecretKey, Base64.DEFAULT )) } pinIsCreated.postValue(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationFailed() } } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricManager <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().biometricManager } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyStore = KeyStore.getInstance(ANDROID_KEY_STORE) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secretKey: SecretKey ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enableBiometric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(isEnabled: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { generateKey() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cipher = createCipher().also { preferences.edit { putString(StorageKey.KEY_IV, Base64.encodeToString(it.iv, Base64.DEFAULT)) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> promptInfo = createPromptInfo() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cryptoObject = BiometricPrompt.CryptoObject(cipher) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEnabled) { biometricParams.value = BiometricParams(isEnabled, promptInfo, cryptoObject) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pinIsCreated.value = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPromptInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: BiometricPrompt.PromptInfo { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BiometricPrompt.PromptInfo.Builder() .setTitle(<span class="hljs-string"><span class="hljs-string">"Create biometric authorization"</span></span>) .setSubtitle(<span class="hljs-string"><span class="hljs-string">"Touch your biometric sensor"</span></span>) .setNegativeButtonText(<span class="hljs-string"><span class="hljs-string">"Cancel"</span></span>) .build() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { keyStore.load(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyProperties = PURPOSE_ENCRYPT or PURPOSE_DECRYPT <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> builder = KeyGenParameterSpec.Builder(KEY_NAME, keyProperties) .setBlockModes(BLOCK_MODE_CBC) .setUserAuthenticationRequired(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) .setEncryptionPaddings(ENCRYPTION_PADDING_NONE) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyGenerator = KeyGenerator.getInstance( KEY_ALGORITHM_AES, ANDROID_KEY_STORE ) keyGenerator.run { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(builder.build()) generateKey() } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { authenticationCallback.onAuthenticationError( BiometricConstants.ERROR_NO_DEVICE_CREDENTIAL, e.localizedMessage ) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCipher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Cipher { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = with(keyStore) { load(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) getKey(KEY_NAME, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cipher.getInstance( <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$KEY_ALGORITHM_AES</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BLOCK_MODE_CBC</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ENCRYPTION_PADDING_NONE</span></span></span><span class="hljs-string">"</span></span> ).apply { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(Cipher.ENCRYPT_MODE, key) } } }</code> </pre> </div></div><br><p>  Ficaria feliz se o Google incluísse o Tink em Biometria, mas ... Temos que escrever esse código padrão com o Cipher e o KeyStore.  Esse código é bastante familiar para as pessoas que trabalham com criptografia no Android, mas quero prestar atenção nos campos de criptografia.  Sim, para impedir o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ataque</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Padding Oracle</a> , não usamos o padding.  Assim, atenuamos os riscos ao armazenar a chave secreta no disco. </p><br><p>  O código para verificação biométrica é muito semelhante: </p><br><div class="spoiler">  <b class="spoiler_title">Mostrar o código</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputPinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ANDROID_KEY_STORE = <span class="hljs-string"><span class="hljs-string">"AndroidKeyStore"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> KEY_NAME = <span class="hljs-string"><span class="hljs-string">"biometric_key"</span></span> } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricErrorMessage = MutableLiveData&lt;SingleLiveEvent&lt;String&gt;&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricParams = MutableLiveData&lt;BiometricParams&gt;() ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricManager <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().biometricManager } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyStore = KeyStore.getInstance(ANDROID_KEY_STORE) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authenticationCallback = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : BiometricPrompt.AuthenticationCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(errorCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, errString: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationError(errorCode, errString) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationSucceeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AuthenticationResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationSucceeded(result) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedSecretKey = Base64.decode( preferences.getString(StorageKey.KEY, <span class="hljs-string"><span class="hljs-string">""</span></span>), Base64.DEFAULT ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = result.cryptoObject?.cipher?.doFinal(encryptedSecretKey) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> token = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedToken = Base64.decode( preferences.getString(StorageKey.TOKEN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) aead.decrypt(encryptedToken, secretKey) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: GeneralSecurityException) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token?.isNotEmpty() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { AuthenticationState.AUTHENTICATED } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AuthenticationState.INVALID_AUTHENTICATION } authenticationState.postValue(state) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationFailed() } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biometricAuthenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preferences.contains(StorageKey.KEY)) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (biometricManager.canAuthenticate()) { BiometricManager.BIOMETRIC_SUCCESS -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> promptInfo = createPromptInfo() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cryptoObject = BiometricPrompt.CryptoObject(createCipher()) biometricParams.value = BiometricParams(promptInfo, cryptoObject) } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { biometricErrorMessage.value = SingleLiveEvent( <span class="hljs-string"><span class="hljs-string">"Biometric authentication isn't configured"</span></span> ) } } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPromptInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: BiometricPrompt.PromptInfo { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BiometricPrompt.PromptInfo.Builder() .setTitle(<span class="hljs-string"><span class="hljs-string">"Biometric login for my app"</span></span>) .setSubtitle(<span class="hljs-string"><span class="hljs-string">"Log in using your biometric credential"</span></span>) .setNegativeButtonText(<span class="hljs-string"><span class="hljs-string">"Cancel"</span></span>) .build() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCipher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Cipher { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = with(keyStore) { load(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) getKey(KEY_NAME, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cipher.getInstance( <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$KEY_ALGORITHM_AES</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BLOCK_MODE_CBC</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ENCRYPTION_PADDING_NONE</span></span></span><span class="hljs-string">"</span></span> ).apply { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> iv = Base64.decode( preferences.getString(StorageKey.KEY_IV, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv)) } } }</code> </pre> </div></div><br><p>  Preste atenção ao <code>authenticationCallback.onAuthenticationSucceeded</code> , ele contém a lógica principal da autenticação pós-biométrica.  De fato, essa é uma implementação alternativa do método <code>pinIsValid()</code> .  Se você não tem um forte entendimento do que está acontecendo nos dois blocos de código anteriores, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação oficial biométrica</a> . </p><br><a name="am-i-completely-protected"></a><br><h1 id="am-i-completely-protected">  Estou completamente protegido? </h1><br><p>  Fizemos muitas coisas legais para realizar a autenticação com um PIN e biometria, mas é tão confiável e seguro?  Obviamente, fizemos o nosso melhor, mas há alguns pontos a serem levados em consideração. </p><br><p>  Um PIN clássico possui apenas quatro dígitos e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entropia</a> é muito baixa.  Portanto, esse tipo de código não é muito seguro de usar.  Apesar de tudo o que fizemos, há uma chance de que um invasor possa decifrar esse código.  Sim, ele precisa executar a engenharia reversa do seu aplicativo e entender como você está criptografando os dados do usuário, mas mesmo assim.  Se um atacante estiver motivado o suficiente, ele fará isso sem hesitar. </p><br><p>  O segundo ponto é sobre smartphones enraizados.  Quando se trata de dispositivos raiz, você pode jogar fora todas as suas tentativas de garantia de segurança.  Qualquer malware com acesso root é capaz de ignorar todos os mecanismos de segurança.  Portanto, você precisa adicionar recursos e verificações extras de segurança ao aplicativo.  Sugiro duas coisas simples para atenuar essas falhas: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SafetyNet</a> - fornece um conjunto de serviços e APIs que ajudam a proteger seu aplicativo contra ameaças à segurança, incluindo adulteração de dispositivos, URLs incorretos, aplicativos potencialmente perigosos e usuários falsos </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ofuscação</a> - <strong>lembre-se de</strong> que o ProGuard <strong>não é</strong> uma ferramenta de ofuscação!  O ProGuard trata da redução e redução de recursos, não ofuscação ou segurança.  Use algo como DexGuard, DexProtector, etc. </li></ul><br><p>  O uso do SafetyNet e a ofuscação são um bom próximo passo após a aplicação das abordagens deste artigo.  Se você notar imprecisões, falhas de segurança ou outras besteiras, entre em contato.  Você pode encontrar todo o código do artigo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . </p><br><p>  E da próxima vez, mostrarei como implementar uma autenticação de PIN usando o back-end.  Fique atento. </p><br><h3 id="useful-links">  Links úteis </h3><br><ul><li>  Funções KDF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Argon2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">scrypt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma abordagem alternativa para criptografar preferências compartilhadas (RU)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entropia da informação</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhe com dados com mais segurança</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475112/">https://habr.com/ru/post/pt475112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475098/index.html">Automação da contratação de pôsteres on-line de cinema</a></li>
<li><a href="../pt475100/index.html">Como usar criptografia para criar um "bem público" sem risco para os investidores</a></li>
<li><a href="../pt475104/index.html">Percorremos os módulos: Navegação em um aplicativo de vários módulos com o Jetpack</a></li>
<li><a href="../pt475106/index.html">Os principais anúncios da conferência Microsoft Ignite 2019</a></li>
<li><a href="../pt475110/index.html">.NET Core com notebooks Jupyter - Pré-visualização 1</a></li>
<li><a href="../pt475114/index.html">Apresentando o .NET Core 3.1 Preview 2</a></li>
<li><a href="../pt475116/index.html">.NET Core 3 para área de trabalho do Windows</a></li>
<li><a href="../pt475124/index.html">Caso: Automação do Instagram. Você está vendendo através de postagens de mídia social?</a></li>
<li><a href="../pt475126/index.html">Moscow Node.js Meetup 10: arquitetura de aplicativos Node.js., Hot Reload in Node.js e um relatório secreto</a></li>
<li><a href="../pt475132/index.html">Hélice sem travamento em uma máquina CNC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>