<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧 🏂🏼 👤 Prinsip Tanggung Jawab Tunggal. Tidak sesederhana kedengarannya ✊🏿 🏫 ➗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prinsip tanggung jawab tunggal, ia adalah prinsip tanggung jawab tunggal, 
 dia adalah prinsip variabilitas seragam - seorang pria yang sangat licin u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinsip Tanggung Jawab Tunggal. Tidak sesederhana kedengarannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454290/"><p><img width="500" src="https://habrastorage.org/getpro/habr/post_images/dad/c41/3d4/dadc413d4439871ac1632997daa6416c.png" alt="gambar" align="left">  Prinsip tanggung jawab tunggal, ia adalah prinsip tanggung jawab tunggal, <br>  dia adalah prinsip variabilitas seragam - seorang pria yang sangat licin untuk memahami dan pertanyaan gugup seperti itu pada wawancara seorang programmer. </p><br><p>  Kenalan serius pertama dengan prinsip ini terjadi pada saya di awal tahun pertama, ketika yang muda dan hijau dibawa ke hutan untuk mendapatkan murid nyata dari larva. </p><br><p> Di hutan, kami dibagi menjadi kelompok yang masing-masing terdiri dari 8-9 orang dan mengadakan kompetisi - kelompok mana yang akan minum sebotol vodka lebih cepat, asalkan orang pertama dalam kelompok menuangkan vodka ke dalam gelas, minuman kedua, dan yang ketiga menggigit.  Setelah menyelesaikan operasinya, unit berdiri di akhir antrian grup. </p><br><p>  Kasus ketika ukuran antrian adalah kelipatan dari tiga, dan merupakan implementasi SRP yang baik. </p><a name="habracut"></a><br><h2 id="opredelenie-1-edinaya-otvetstvennost">  Definisi 1. Tanggung jawab tunggal. </h2><br><p>  Definisi resmi dari prinsip tanggung jawab tunggal (SRP) menunjukkan bahwa setiap objek memiliki tanggung jawab dan alasan keberadaannya sendiri, dan tanggung jawab ini hanya memiliki satu. </p><br><p>  Pertimbangkan objek Tippler. <br>  Untuk memenuhi prinsip SRP, kami membagi tanggung jawab menjadi tiga: </p><br><ul><li>  Satu <strong>tuang</strong> ( <strong>PourOperation</strong> ) </li><li>  One <strong>Drinks</strong> ( <strong>DrinkUpOperation</strong> ) </li><li>  One snack ( <strong>TakeBiteOperation</strong> ) </li></ul><br><p>  Setiap peserta dalam proses bertanggung jawab atas satu komponen proses, yaitu, ia memiliki satu tanggung jawab atom - untuk minum, menuangkan atau menggigit. </p><br><p>  Minuman keras, pada gilirannya, adalah penglihatan untuk operasi ini: </p><br><pre><code class="plaintext hljs">lass Tippler { //... void Act(){ _pourOperation.Do() //  _drinkUpOperation.Do() //  _takeBiteOperation.Do() //  } }</code> </pre> <br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/07b/979/ed5/07b979ed5db74fcec05254aadb60220d.png" alt="gambar"></div><br><h4 id="zachem">  Mengapa </h4><br><p>  Pemrogram manusia menulis kode untuk pria monyet, dan pria monyet itu lalai, bodoh dan selalu terburu-buru di suatu tempat.  Dia dapat memegang dan memahami sekitar 3 sampai 7 istilah sekaligus. <br>  Dalam hal minuman keras, ketentuan ini adalah tiga.  Namun, jika kita menulis kodenya dengan satu lembar, maka tangan, kacamata, pembantaian, dan perdebatan tanpa akhir tentang politik akan muncul di dalamnya.  Dan semua ini akan ada di tubuh satu metode.  Saya yakin Anda telah melihat kode seperti itu dalam latihan Anda.  Bukan tes yang paling manusiawi untuk jiwa. </p><br><p>  Di sisi lain, pria monyet dipenjara karena memodelkan objek dunia nyata di kepalanya.  Dalam imajinasinya, ia dapat mendorong mereka bersama-sama, mengumpulkan benda-benda baru dari mereka dan membongkar mereka dengan cara yang sama.  Bayangkan sebuah model mobil tua.  Anda dapat membuka pintu dalam imajinasi Anda, membuka trim pintu dan melihat mekanisme pengangkat jendela di sana, di dalamnya akan ada roda gigi.  Tetapi Anda tidak dapat melihat semua komponen mesin secara bersamaan, dalam satu "daftar".  Setidaknya "manusia monyet" tidak bisa. </p><br><p>  Oleh karena itu, pemrogram manusia menguraikan mekanisme kompleks menjadi satu set elemen yang kurang kompleks dan bekerja.  Namun, penguraian dapat dilakukan dengan cara yang berbeda: pada banyak mobil tua - saluran keluar pintu, dan pada yang modern - kegagalan kunci elektronik mencegah mesin dari start, yang menghasilkan selama perbaikan. </p><br><p>  Jadi, <strong>SRP adalah prinsip yang menjelaskan BAGAIMANA membusuk, yaitu tempat menggambar garis pemisah</strong> . </p><br><p>  Dia mengatakan bahwa dekomposisi harus didasarkan pada prinsip pemisahan "tanggung jawab", yaitu, sesuai dengan tugas berbagai objek. </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/b89/d0f/3c6/b89d0f3c6434ae77a2b858e2af6374b0.png" alt="gambar"></div><br><p>  Mari kita kembali ke minuman keras dan keuntungan yang didapat monyet saat membusuk: </p><br><ul><li>  Kode ini menjadi sangat jelas di setiap level. </li><li>  Beberapa programmer dapat menulis kode sekaligus (masing-masing menulis elemen terpisah) </li><li>  Pengujian otomatis disederhanakan - elemen yang lebih sederhana, semakin mudah untuk diuji </li><li>  Dari ketiga operasi ini, di masa depan, Anda dapat menambahkan pelahap (hanya menggunakan <strong>TakeBitOperation</strong> ), the Alcoholic (hanya menggunakan <strong>DrinkUpOperation</strong> langsung dari botol) dan memenuhi banyak persyaratan bisnis lainnya. </li></ul><br><p>  Dan, tentu saja, kontra: </p><br><ul><li>  Harus membuat lebih banyak jenis. </li><li>  Seorang peminum akan minum untuk pertama kalinya beberapa jam lebih lambat dari yang dia bisa </li></ul><br><h2 id="opredelenie-2-edinaya-izmenchivost">  Definisi 2. Variabilitas terpadu. </h2><br><p>  Bolehkan tuan-tuan!  Kelas minum juga memenuhi satu tanggung jawab - minum!  Dan secara umum, kata "tanggung jawab" adalah konsep yang sangat kabur.  Seseorang bertanggung jawab atas nasib umat manusia, dan seseorang bertanggung jawab untuk mengangkat penguin yang terbalik di tiang. </p><br><p>  Pertimbangkan dua implementasi bingo.  Yang pertama, yang disebutkan di atas, berisi tiga kelas - menuangkan, minum dan menggigit. </p><br><p>  Yang kedua ditulis melalui metodologi Forward and Only Forward dan berisi semua logika dalam metode <strong>Act</strong> : </p><br><pre> <code class="plaintext hljs">//      .    lass BrutTippler { //... void Act(){ //  if(!_hand.TryDischarge(from:_bottle, to:_glass, size:_glass.Capacity)) throw new OverdrunkException(); //  if(!_hand.TryDrink(from: _glass, size: _glass.Capacity)) throw new OverdrunkException(); // for(int i = 0; i&lt; 3; i++){ var food = _foodStore.TakeOrDefault(); if(food==null) throw new FoodIsOverException(); _hand.TryEat(food); } } }</code> </pre> <br><p>  Kedua kelas ini, dari sudut pandang pengamat luar, terlihat persis sama dan memenuhi tanggung jawab tunggal "minum". </p><br><p>  Malu! </p><br><p>  Kemudian kami menjelajahi Internet dan mencari tahu definisi lain SRP - prinsip variabilitas seragam. </p><br><p>  Definisi ini menyatakan bahwa “ <strong>Modul memiliki satu dan hanya satu alasan untuk perubahan</strong> .”  Yaitu, "Tanggung jawab adalah kesempatan untuk perubahan." </p><br><p>  Sekarang semuanya jatuh ke tempatnya.  Secara terpisah, Anda dapat mengubah prosedur menuangkan, minum dan menggigit, dan dalam minuman keras itu sendiri kita hanya dapat mengubah urutan dan komposisi operasi, misalnya, memindahkan camilan sebelum minum atau menambahkan bacaan roti panggang. </p><br><p>  Dalam pendekatan Penerusan dan Penerusan Hanya, semua yang dapat diubah diubah hanya dalam metode <strong>Tindakan</strong> .  Ini dapat dibaca dan efektif dalam kasus ketika ada sedikit logika dan jarang berubah, tetapi sering berakhir dengan metode yang mengerikan masing-masing 500 baris, dengan jumlah lebih banyak jika diperlukan untuk masuknya Rusia ke NATO. </p><br><h2 id="opredelenie-3-lokalizaciya-izmeneniy">  Definisi 3. Lokalisasi perubahan. </h2><br><p>  Peminum sering tidak mengerti mengapa mereka bangun di apartemen orang lain, atau di mana ponsel mereka.  Saatnya untuk menambahkan pencatatan yang terperinci. </p><br><p>  Mari mulai mencatat dengan proses penuangan: </p><br><pre> <code class="plaintext hljs">class PourOperation: IOperation{ PourOperation(ILogger log /*....*/){/*...*/} //... void Do(){ _log.Log($"Before pour with {_hand} and {_bottle}"); //Pour business logic ... _log.Log($"After pour with {_hand} and {_bottle}"); } }</code> </pre> <br><p>  Dengan <strong>merangkumnya</strong> dalam <strong>PourOperation</strong> , kami bertindak bijak dalam hal tanggung jawab dan enkapsulasi, tetapi sekarang dengan prinsip variabilitas, kami sekarang merasa malu.  Selain operasi itu sendiri, yang dapat berubah, logging itu sendiri menjadi variabel.  Kami harus memisahkan dan membuat logger khusus untuk operasi penuangan: </p><br><pre> <code class="plaintext hljs">interface IPourLogger{ void LogBefore(IHand, IBottle){} void LogAfter(IHand, IBottle){} void OnError(IHand, IBottle, Exception){} } class PourOperation: IOperation{ PourOperation(IPourLogger log /*....*/){/*...*/} //... void Do(){ _log.LogBefore(_hand, _bottle); try{ //... business logic _log.LogAfter(_hand, _bottle"); } catch(exception e){ _log.OnError(_hand, _bottle, e) } } }</code> </pre> <br><p>  Pembaca yang teliti akan melihat bahwa <strong>LogAfter</strong> , <strong>LogBefore,</strong> dan <strong>OnError</strong> juga dapat diubah secara individual, dan, dengan analogi dengan langkah-langkah sebelumnya, akan membuat tiga kelas: <strong>PourLoggerSebelum</strong> , <strong>PourLoggerAfter,</strong> dan <strong>PourErrorLogger</strong> . </p><br><p>  Dan mengingat bahwa ada tiga operasi untuk pesta makan - kami mendapatkan sembilan kelas logging.  Hasilnya, seluruh minuman keras terdiri dari 14 kelas (!!!). </p><br><p>  Hiperbola?  Sulit!  Seorang lelaki monyet dengan granat penguraian akan menghancurkan "penuang" ke dalam botol, gelas, operator penuangan, layanan pasokan air, model fisik tabrakan molekul, dan kuartal berikutnya akan mencoba mengurai dependensi tanpa variabel global.  Dan percayalah - dia tidak akan berhenti. </p><br><p>  Pada titik inilah banyak yang sampai pada kesimpulan bahwa SRP adalah dongeng dari kerajaan merah muda, dan pergi untuk memutar mie ... </p><br><p>  ... tidak pernah tahu tentang keberadaan definisi ketiga Srp: </p><br><p>  " <strong>Hal-hal yang mirip dengan perubahan harus disimpan di satu tempat</strong> ."  atau " <strong>Apa yang berubah bersama harus disimpan di satu tempat</strong> " </p><br><p>  Yaitu, jika kita mengubah operasi logging, maka kita harus mengubahnya di <strong>satu</strong> tempat. </p><br><p>  Ini adalah poin yang sangat penting - karena semua penjelasan SRP di atas mengatakan bahwa tipe harus dibagi ketika mereka dibagi, yaitu, menerapkan "batas atas" pada ukuran objek, dan sekarang kita berbicara tentang "batas bawah" .  Dengan kata lain, <strong>SRP tidak hanya membutuhkan "menghancurkan sambil menghancurkan", tetapi juga tidak berlebihan - "jangan hancurkan hal-hal terkait</strong> . <strong>"</strong>  Jangan menyulitkan yang tidak perlu.  Ini adalah pertempuran hebat pisau cukur Occam dengan si monyet! </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/778/0d3/aa2/7780d3aa2ce9b489696c55ea792adb3a.jpg" alt="gambar"></div><br><p>  Sekarang minuman keras seharusnya lebih mudah.  Selain tidak memecah logger IPourLogger menjadi tiga kelas, kami juga dapat menggabungkan semua logger menjadi satu jenis: </p><br><pre> <code class="plaintext hljs">class OperationLogger{ public OperationLogger(string operationName){/*..*/} public void LogBefore(object[] args){/*...*/} public void LogAfter(object[] args){/*..*/} public void LogError(object[] args, exception e){/*..*/} }</code> </pre> <br><p>  Dan jika jenis operasi keempat ditambahkan kepada kami, maka logging siap untuk itu.  Dan kode operasi itu sendiri bersih dan bebas dari kebisingan infrastruktur. </p><br><p>  Akibatnya, kami memiliki 5 kelas untuk menyelesaikan masalah minum: </p><br><ul><li>  Menuangkan operasi </li><li>  Operasi minuman </li><li>  Operasi macet </li><li>  Logger </li><li>  Fasad Booler </li></ul><br><p>  Masing-masing dari mereka bertanggung jawab secara ketat untuk satu fungsi, memiliki satu alasan untuk perubahan.  Semua aturan yang mirip dengan perubahan ada di dekatnya. </p><br><h2 id="primery-iz-realnoy-zhizni">  Contoh kehidupan nyata </h2><br><div class="spoiler">  <b class="spoiler_title">Serialisasi dan Deserialisasi</b> <div class="spoiler_text"><p>  Sebagai bagian dari pengembangan protokol transfer data, perlu untuk membuat serial dan deserialize beberapa jenis "Pengguna" ke dalam string. </p><br><pre> <code class="plaintext hljs">User{ String Name; Int Age; }</code> </pre> <br><p>  Anda mungkin berpikir bahwa serialisasi dan deserialisasi perlu dilakukan di kelas yang berbeda: </p><br><pre> <code class="plaintext hljs">UserDeserializer{ String deserialize(User){...} } UserSerializer{ User serialize(String){...} }</code> </pre> <br><p>  Karena masing-masing dari mereka memiliki tanggung jawab sendiri dan satu alasan untuk perubahan. </p><br><p>  Tetapi mereka memiliki alasan umum untuk perubahan - "mengubah format serialisasi data." <br>  Dan ketika mengubah format ini, serialisasi dan deserialisasi akan selalu berubah. </p><br><p>  Menurut prinsip pelokalan perubahan, kita harus menggabungkannya menjadi satu kelas: </p><br><pre> <code class="plaintext hljs">UserSerializer{ String deserialize(User){...} User serialize(String){...} }</code> </pre> <br><p>  Ini menyelamatkan kita dari kerumitan yang tidak perlu, dan kebutuhan untuk mengingat bahwa setiap kali Anda mengubah serializer, Anda perlu mengingat tentang deserializer. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Hitung dan simpan</b> <div class="spoiler_text"><p>  Anda perlu menghitung pendapatan tahunan perusahaan dan menyimpannya dalam file C: \ results.txt. </p><br><p>  Kami dengan cepat menyelesaikan ini dengan satu metode: </p><br><pre> <code class="plaintext hljs">void SaveGain(Company company){ //     //   }</code> </pre> <br><p>  Sudah dari definisi tugas, jelas bahwa ada dua subtugas - "Hitung pendapatan" dan "Simpan pendapatan".  Masing-masing dari mereka memiliki satu alasan untuk perubahan - "perubahan dalam metodologi perhitungan" dan "perubahan dalam format penyimpanan".  Perubahan ini tidak tumpang tindih.  Selain itu, kami tidak dapat menjawab satu suku kata untuk pertanyaan - “apa yang dilakukan metode SaveGain?”.  Metode <strong>DAN</strong> ini menghitung pendapatan <strong>DAN</strong> menyimpan hasilnya. </p><br><p>  Karena itu, Anda perlu membagi metode ini menjadi dua: </p><br><pre> <code class="plaintext hljs">Gain CalcGain(Company company){..} void SaveGain(Gain gain){..}</code> </pre> <br><p>  Pro: </p><br><ul><li>  dapat diuji secara terpisah CalcGain </li><li>  lebih mudah untuk melokalkan bug dan membuat perubahan </li><li>  pembacaan kode meningkat </li><li>  risiko kesalahan dalam setiap metode berkurang karena penyederhanaannya </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Logika bisnis yang canggih</b> <div class="spoiler_text"><p>  Pernah kami menulis layanan untuk registrasi otomatis klien b2b.  Dan ada metode GOD dengan 200 baris konten serupa: </p><br><ul><li>  Buka 1C dan dapatkan akun </li><li>  Dengan akun ini, buka modul pembayaran dan dapatkan di sana </li><li>  Periksa apakah akun dengan akun seperti itu belum dibuat di server utama </li><li>  Buat akun baru </li><li>  Hasil pendaftaran dalam modul pembayaran dan nomor 1c ditambahkan ke layanan hasil pendaftaran </li><li>  Tambahkan informasi akun ke tabel ini </li><li>  Buat nomor poin untuk pelanggan ini dalam layanan poin.  Berikan nomor akun layanan ini 1s. </li></ul><br><p>  Ada sekitar 10 operasi bisnis lagi dengan keterhubungan yang mengerikan di daftar ini.  Objek akun dibutuhkan oleh hampir semua orang.  ID titik dan nama klien diperlukan dalam setengah panggilan. </p><br><p>  Setelah satu jam refactoring, kami dapat memisahkan kode infrastruktur dan beberapa nuansa bekerja dengan akun menjadi metode / kelas yang terpisah.  Metode Dewa menjadi lebih mudah, tetapi ada 100 baris kode yang tersisa yang tidak ingin diurai. </p><br><p>  Hanya beberapa hari kemudian muncul pemahaman bahwa esensi dari metode "lega" ini adalah algoritma bisnis.  Dan bahwa deskripsi awal TK agak rumit.  Dan ini merupakan upaya untuk memecah metode ini menjadi potongan-potongan yang akan menjadi pelanggaran SRP, dan bukan sebaliknya. </p></div></div><br><h2 id="formalizm">  Formalisme. </h2><br><p>  Sudah waktunya untuk meninggalkan minuman keras kita sendirian.  Seka air mata - kita pasti akan kembali ke sana.  Sekarang kami meresmikan pengetahuan dari artikel ini. </p><br><h4 id="formalizm-1-opredelenie-srp">  Formalisme 1. Definisi SRP </h4><br><ol><li>  Pisahkan elemen sehingga masing-masing bertanggung jawab untuk satu hal. </li><li>  Tanggung jawab berarti “penyebab perubahan”.  Artinya, setiap elemen hanya memiliki satu alasan untuk perubahan, dalam hal logika bisnis. </li><li>  Potensi perubahan logika bisnis.  harus dilokalisasi.  Item yang bisa berubah bersama harus berada di dekat. </li></ol><br><h4 id="formalizm-2-neobhodimye-kriterii-samoproverki">  Formalisme 2. Kriteria yang diperlukan untuk pemeriksaan diri. </h4><br><p>  Saya belum memenuhi kriteria yang cukup untuk implementasi SRP.  Tetapi ada kondisi yang diperlukan: </p><br><p>  1) Ajukan pertanyaan pada diri sendiri - apa yang dilakukan kelas / metode / modul / layanan ini.  Anda harus menjawabnya dengan definisi sederhana.  (terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Brightori</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">penjelasan</b> <div class="spoiler_text"><p>  Namun, terkadang sangat sulit untuk menemukan definisi yang sederhana </p></div></div><br><p>  2) Memperbaiki bug atau menambahkan fitur baru memengaruhi jumlah minimum file / kelas.  Idealnya, satu. </p><br><div class="spoiler">  <b class="spoiler_title">penjelasan</b> <div class="spoiler_text"><p>  Karena tanggung jawab (untuk fitur atau bug) dienkapsulasi dalam satu file / kelas, maka Anda tahu persis ke mana harus mencari dan apa yang harus diedit.  Sebagai contoh: fitur untuk mengubah keluaran dari operasi logging akan memerlukan hanya mengubah logger.  Berlari di sekitar sisa kode tidak diperlukan. </p><br><p>  Contoh lain adalah penambahan kontrol UI baru yang mirip dengan yang sebelumnya.  Jika ini memaksa Anda untuk menambahkan 10 entitas yang berbeda dan 15 konverter yang berbeda - tampaknya Anda telah "rusak". </p></div></div><br><p>  3) Jika beberapa pengembang bekerja pada fitur berbeda dari proyek Anda, maka kemungkinan konflik penggabungan, yaitu, probabilitas bahwa beberapa pengembang akan mengubah file / kelas yang sama pada saat yang sama, minimal. </p><br><div class="spoiler">  <b class="spoiler_title">penjelasan</b> <div class="spoiler_text"><p>  Jika ketika menambahkan operasi baru "Tuang vodka di bawah meja" Anda harus menyentuh logger, operasi minum dan menuangkan - maka sepertinya tanggung jawab dibagi miring.  Tentu saja, ini tidak selalu memungkinkan, tetapi Anda perlu mencoba mengurangi angka ini. </p></div></div><br><p>  4) Ketika mengklarifikasi pertanyaan tentang logika bisnis (dari pengembang atau manajer), Anda naik secara ketat ke satu kelas / file dan menerima informasi hanya dari sana. </p><br><div class="spoiler">  <b class="spoiler_title">penjelasan</b> <div class="spoiler_text"><p>  Fitur, aturan, atau algoritme ditulis dengan kompak masing-masing di satu tempat, dan tidak disebarkan oleh bendera di seluruh ruang kode. </p></div></div><br><p>  5) Penamaan jelas. </p><br><div class="spoiler">  <b class="spoiler_title">penjelasan</b> <div class="spoiler_text"><p>  Kelas atau metode kita bertanggung jawab atas satu hal, dan tanggung jawab itu tercermin dalam namanya. </p><br><p>  AllManagersManagerService - kemungkinan besar, kelas dewa <br>  Pembayaran Lokal - mungkin tidak </p></div></div><br><h4 id="formalizm-3-metodika-razrabotki-okkama-first">  Formalisme 3. Metode pengembangan Occam-first. </h4><br><p>  Pada awal desain, manusia monyet tidak tahu dan tidak merasakan semua seluk-beluk masalah yang sedang dipecahkan dan dapat memberikan kesalahan.  Anda dapat membuat kesalahan dengan berbagai cara: </p><br><ul><li>  Buat benda terlalu besar dengan menempelkan berbagai tanggung jawab </li><li>  Berpisah, membagi satu tanggung jawab menjadi beberapa jenis </li><li>  Batas tanggung jawab yang didefinisikan secara tidak benar </li></ul><br><p>  Penting untuk mengingat aturan: "lebih baik membuat kesalahan besar," atau "tidak yakin - jangan berpisah."  Jika, misalnya, kelas Anda mengumpulkan dua tanggung jawab, maka masih dapat dimengerti dan dapat dibagi menjadi dua dengan sedikit perubahan dalam kode klien.  Mengumpulkan gelas dari pecahan kaca biasanya lebih sulit karena konteksnya tersebar di beberapa file dan kurangnya ketergantungan yang diperlukan dalam kode klien. </p><br><h2 id="pora-zakruglyatsya">  Saatnya untuk mengakhiri </h2><br><p>  Ruang lingkup SRP tidak terbatas pada OOP dan SOLID.  Ini berlaku untuk metode, fungsi, kelas, modul, layanan mikro dan layanan.  Ini berlaku untuk pengembangan "figax-figax-dan-in-prod" dan "rocket-sainz", membuat dunia sedikit lebih baik di mana-mana.  Jika Anda memikirkannya, ini hampir merupakan prinsip dasar dari semua teknik.  Teknik mesin, sistem kontrol, dan memang semua sistem yang kompleks dibangun dari komponen, dan "fragmentasi tidak lengkap" membuat desainer tidak fleksibel, "fragmentasi" - efisiensi, dan batas-batas yang salah - alasan dan ketenangan pikiran. </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/getpro/habr/post_images/5a4/13a/5ec/5a413a5ec8447752d1de83982a0fadea.jpg" alt="gambar"></div><br><p>  SRP tidak ditemukan secara alami dan bukan bagian dari ilmu pasti.  Ini merangkak keluar dari keterbatasan biologis dan psikologis kita.Ini hanya cara untuk mengendalikan dan mengembangkan sistem yang kompleks menggunakan otak monyet manusia.  Dia memberi tahu kita cara menguraikan sistem.  Kata-kata aslinya membutuhkan cukup banyak telepati, tapi saya harap artikel ini sedikit menghilangkan tabir asap. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454290/">https://habr.com/ru/post/id454290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454272/index.html">Seluruh kebenaran tentang RTOS. Artikel # 27. Waktu sistem</a></li>
<li><a href="../id454274/index.html">Cahaya, kamera ... cloud: Bagaimana awan mengubah industri film</a></li>
<li><a href="../id454278/index.html">Asuransi cyber di pasar Rusia</a></li>
<li><a href="../id454280/index.html">Pengembangan jarak jauh dalam Kode VS: hidup Anda tidak akan pernah sama</a></li>
<li><a href="../id454284/index.html">Maaf, saya tidak akan bekerja karena ini musim dingin</a></li>
<li><a href="../id454292/index.html">JS. Proksi Jebakan untuk Tahu Tentang</a></li>
<li><a href="../id454294/index.html">"Tanpa eksperimen yang tidak perlu", atau bagaimana kami meluncurkan akselerator bank</a></li>
<li><a href="../id454296/index.html">Bagaimana Sekolah di Puerto Rico Membawa Kimia ke Kehidupan dengan Minecraft: Edisi Pendidikan</a></li>
<li><a href="../id454298/index.html">The Standoff: bagaimana itu</a></li>
<li><a href="../id454300/index.html">Perbedaan CTT dari pipa panas konvensional dan cara mengaplikasikannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>