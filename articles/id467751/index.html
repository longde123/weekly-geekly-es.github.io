<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 📀 👩🏼‍🔬 Bagaimana cara messenger terdesentralisasi di blockchain 🧑🏼‍🤝‍🧑🏼 👝 🧜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada awal 2017, kami mulai membuat messenger di blockchain [nama dan tautannya ada di profil] dengan membahas kelebihan dibandingkan dengan messenger ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara messenger terdesentralisasi di blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467751/"> Pada awal 2017, kami mulai membuat messenger di blockchain [nama dan tautannya ada di profil] dengan membahas kelebihan dibandingkan dengan messenger P2P klasik. <br><br>  <code>2.5</code> tahun berlalu dan kami dapat mengkonfirmasi konsep kami: aplikasi instant messenger untuk iOS, Web PWA, Windows, GNU / Linux, Mac OS dan Android sekarang tersedia. <br><br>  Hari ini kami akan memberi tahu Anda bagaimana messenger diatur pada blockchain dan bagaimana aplikasi klien dapat bekerja dengan API-nya. <br><img src="https://habrastorage.org/webt/x9/zr/gs/x9zrgsw1wkkm1856yssejnfg5gs.jpeg"><br><a name="habracut"></a><br>  Kami ingin blockchain untuk memecahkan masalah keamanan dan privasi utusan P2P klasik: <br><br><ul><li>  Satu klik untuk membuat akun - tidak ada telepon dan email, tidak ada akses ke buku alamat dan geolokasi. </li><li>  Lawan bicara tidak pernah membuat koneksi langsung, semua komunikasi melewati sistem node terdistribusi.  Alamat IP pengguna tidak dapat diakses satu sama lain. </li><li>  Semua pesan dienkripsi kurva End-to-End25519xsalsa20poly1305.  Tampaknya Anda tidak akan mengejutkan siapa pun, tetapi kami memiliki kode sumber terbuka. </li><li>  Serangan MITM tidak termasuk - setiap pesan adalah transaksi dan ditandatangani oleh Ed25519 EdDSA. </li><li>  Pesan jatuh ke bloknya.  Urutan dan <code>timestamp</code> blok tidak dapat diperbaiki, dan karena itu urutan pesan. </li><li>  "Saya tidak mengatakan ini" tidak akan berfungsi dengan pesan di blockchain. </li><li>  Tidak ada struktur utama yang memeriksa “keaslian” pesan.  Ini dilakukan oleh sistem node terdistribusi berbasis konsensus, dan itu milik pengguna. </li><li>  Tidak mungkin penyensoran - akun tidak dapat diblokir dan pesan dihapus. </li><li>  The 2FA blockchain adalah alternatif untuk 2FA neraka melalui SMS, yang telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merusak banyak kesehatan.</a> </li><li>  Kemampuan untuk mendapatkan semua dialog Anda dari perangkat apa pun kapan saja adalah kemampuan untuk tidak menyimpan dialog sama sekali. </li><li>  Konfirmasi Pengiriman Pesan.  Bukan ke perangkat pengguna, tetapi ke jaringan.  Sebenarnya, ini adalah konfirmasi kemampuan penerima untuk membaca pesan Anda.  Ini adalah fitur yang berguna untuk mengirim pemberitahuan penting. </li></ul><br>  Dari roti blockchain, ada juga integrasi dekat dengan cryptocurrency Ethereum, Dogecoin, Lisk, Dash, Bitcoin (ini masih dalam proses) dan kemampuan untuk mengirim token dalam obrolan.  Kami bahkan membuat exchanger crypto bawaan. <br><br>  Dan kemudian - cara kerjanya. <br><br><h2>  Pesan adalah transaksi </h2><br>  Setiap orang sudah terbiasa dengan fakta bahwa transaksi dalam token transfer blockchain (koin) dari satu pengguna ke yang lain.  Suka bitcoin.  Kami telah membuat jenis transaksi khusus untuk mengirim pesan. <br><br>  Untuk mengirim pesan di messenger di blockchain, Anda harus melewati beberapa tahapan: <br><br><ol><li>  Enkripsi teks pesan </li><li>  Masukkan ciphertext ke dalam transaksi </li><li>  Tanda tangani transaksi </li><li>  Kirim transaksi ke host mana pun </li><li>  Sistem node terdistribusi menentukan "keandalan" pesan </li><li>  Jika semuanya baik-baik saja, transaksi dengan pesan tersebut termasuk dalam blok berikutnya. </li><li>  Penerima mengambil transaksi pesan dan mendekripsi </li></ol><br>  Tahapan 1-3 dan 7 dilakukan secara lokal pada klien, dan 5-6 pada node jaringan. <br><br><h2>  Enkripsi pesan </h2><br>  Pesan dienkripsi dengan kunci pribadi pengirim dan kunci publik penerima.  Kami akan mengambil kunci publik dari jaringan, tetapi untuk ini akun penerima harus diinisialisasi, yaitu, memiliki setidaknya satu transaksi.  Anda dapat menggunakan permintaan REST <code>GET /api/accounts/getPublicKey?address={ADAMANT address}</code> , dan ketika Anda mengunduh obrolan, kunci publik dari teman bicara sudah tersedia. <br><br><img src="https://habrastorage.org/webt/gk/km/ky/gkkmkyvasb6jzq_pgs1zq9w7fi0.png"><br><br>  Utusan mengenkripsi pesan dengan algoritma curve25519xsalsa20poly1305 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak NaCl</a> ).  Karena akun tersebut berisi kunci Ed25519, untuk membentuk sebuah kotak, kunci tersebut terlebih dahulu harus dikonversi ke Curve25519 Diffie-Hellman. <br><br>  Berikut ini contoh dalam JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Encodes a text message for sending to ADM * @param {string} msg message to encode * @param {*} recipientPublicKey recipient's public key * @param {*} privateKey our private key * @returns {{message: string, nonce: string}} */</span></span> adamant.encodeMessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg, recipientPublicKey, privateKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nonce = Buffer.allocUnsafe(<span class="hljs-number"><span class="hljs-number">24</span></span>) sodium.randombytes(nonce) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> recipientPublicKey === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { recipientPublicKey = hexToBytes(recipientPublicKey) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> plainText = Buffer.from(msg) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHPublicKey = ed2curve.convertPublicKey(recipientPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHSecretKey = ed2curve.convertSecretKey(privateKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encrypted = nacl.box(plainText, nonce, DHPublicKey, DHSecretKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: bytesToHex(encrypted), <span class="hljs-attr"><span class="hljs-attr">nonce</span></span>: bytesToHex(nonce) } }</code> </pre> <br><h2>  Pembentukan transaksi dengan pesan </h2><br>  Suatu transaksi memiliki struktur umum sebagai berikut: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"15161295239237781653"</span></span>, <span class="hljs-string"><span class="hljs-string">"height"</span></span>: <span class="hljs-number"><span class="hljs-number">7585271</span></span>, <span class="hljs-string"><span class="hljs-string">"blockId"</span></span>: <span class="hljs-string"><span class="hljs-string">"16391508373936326027"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"block_timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182260</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182254</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"bd39cc708499ae91b937083463fce5e0668c2b37e78df28f69d132fce51d49ed"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U16023712506749300952"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U17653312780572073341"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"23d27f616e304ef2046a60b762683b8dabebe0d8fc26e5ecdb1d5f3d291dbe21"</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">204921300000000</span></span>, <span class="hljs-string"><span class="hljs-string">"fee"</span></span>: <span class="hljs-number"><span class="hljs-number">50000000</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"3c8e551f60fedb81e52835c69e8b158eb1b8b3c89a04d3df5adc0d99017ffbcb06a7b16ad76d519f80df019c930960317a67e8d18ab1e85e575c9470000cf607"</span></span>, <span class="hljs-string"><span class="hljs-string">"signatures"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"confirmations"</span></span>: <span class="hljs-number"><span class="hljs-number">3660548</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: {} }</code> </pre> <br>  Untuk pesan transaksi, <code>asset</code> adalah yang paling penting - Anda perlu menempatkan pesan di dalamnya di objek <code>chat</code> dengan struktur: <br><br><ul><li>  <code>message</code> - simpan pesan terenkripsi </li><li>  <code>own_message</code> - nonce </li><li>  <code>type</code> - tipe pesan </li></ul><br>  Pesan juga dibagi menjadi beberapa tipe.  Pada dasarnya, parameter <code>type</code> memberi tahu cara memahami <code>message</code> .  Anda dapat mengirim hanya teks, atau Anda dapat mengirim objek dengan minat menarik di dalamnya - misalnya, ini adalah cara kurir melakukan transfer cryptocurrency di ruang obrolan. <br><br>  Sebagai hasilnya, kami membentuk transaksi: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"transaction"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U12499126640447739963"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"e9cafb1e7b403c4cf247c94f73ee4cada367fcc130cb3888219a0ba0633230b6"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: { <span class="hljs-string"><span class="hljs-string">"chat"</span></span>: { <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"cb682accceef92d7cddaaddb787d1184ab5428"</span></span>, <span class="hljs-string"><span class="hljs-string">"own_message"</span></span>: <span class="hljs-string"><span class="hljs-string">"e7d8f90ddf7d70efe359c3e4ecfb5ed3802297b248eacbd6"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U15677078342684640219"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228087</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span> } }</code> </pre> <br><h2>  Tanda Tangan Transaksi </h2><br>  Agar setiap orang memastikan keaslian pengirim dan penerima, pada saat pengiriman dan isi pesan, transaksi ditandatangani.  Tanda tangan digital memungkinkan Anda memverifikasi keaslian transaksi menggunakan kunci publik - kunci pribadi tidak diperlukan untuk ini. <br><br>  Tetapi tanda tangan itu sendiri hanya dilakukan oleh kunci pribadi: <br><br><img src="https://habrastorage.org/webt/y_/bk/6k/y_bk6k_7ayzma1-ndyhur2xcaok.png"><br><br>  Dapat dilihat dari diagram bahwa kita pertama kali melakukan hash transaksi dengan SHA-256, dan kemudian kita menandatangani <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ed25519 EdDSA</a> dan mendapatkan tanda <code>signature</code> tanda <code>signature</code> , dan pengidentifikasi transaksi adalah bagian dari hash SHA-256. <br><br><h3>  Contoh Implementasi: </h3><br>  1 - Kami membentuk blok data, termasuk pesan <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Calls `getBytes` based on transaction type * @see privateTypes * @implements {ByteBuffer} * @param {transaction} trs * @param {boolean} skipSignature * @param {boolean} skipSecondSignature * @return {!Array} Contents as an ArrayBuffer. * @throws {error} If buffer fails. */</span></span> adamant.getBytes = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transaction</span></span></span><span class="hljs-function">) </span></span>{ ... switch (transaction.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.SEND: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.CHAT_MESSAGE: assetBytes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.chatGetBytes(transaction) assetSize = assetBytes.length <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: alert(<span class="hljs-string"><span class="hljs-string">'Not supported yet'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuffer(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">32</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + assetSize, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) bb.writeByte(transaction.type) bb.writeInt(transaction.timestamp) ... bb.flip() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(bb.toArrayBuffer()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arrayBuffer.length; i++) { buffer[i] = arrayBuffer[i] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer.from(buffer) }</code> </pre><br>  2 - Kami menganggap SHA-256 dari blok data <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Creates hash based on transaction bytes. * @implements {getBytes} * @implements {crypto.createHash} * @param {transaction} trs * @return {hash} sha256 crypto hash */</span></span> adamant.getHash = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getBytes(trs)).digest() }</code> </pre> <br>  3 - Kami menandatangani transaksi <br><br><pre> <code class="javascript hljs">adamant.transactionSign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHash(trs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sign(hash, keypair).toString(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/** * Creates a signature based on a hash and a keypair. * @implements {sodium} * @param {hash} hash * @param {keypair} keypair * @return {signature} signature */</span></span> adamant.sign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sodium.crypto_sign_detached(hash, Buffer.from(keypair.privateKey, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>)) }</code> </pre> <br><h2>  Mengirim transaksi dengan pesan ke host </h2><br>  Karena jaringan terdesentralisasi, salah satu dari node dengan API terbuka akan melakukannya.  Kami membuat permintaan POST untuk titik <code>api/transactions</code> : <br><br><pre> <code class="javascript hljs">curl <span class="hljs-string"><span class="hljs-string">'api/transactions'</span></span> -X POST \ -d <span class="hljs-string"><span class="hljs-string">'TX_DATA'</span></span></code> </pre> <br>  Sebagai tanggapan, kami mendapatkan ID transaksi jenis <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"success"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"nodeTimestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228852</span></span>, <span class="hljs-string"><span class="hljs-string">"transactionId"</span></span>: <span class="hljs-string"><span class="hljs-string">"6146865104403680934"</span></span> }</code> </pre> <br><h2>  Validasi Transaksi </h2><br>  Sistem node berbasis konsensus terdistribusi menentukan “keandalan” suatu transaksi pesan.  Dari siapa dan kepada siapa, kapan, apakah pesan diganti oleh yang lain, dan apakah waktu pengiriman ditunjukkan dengan benar.  Ini adalah keuntungan yang sangat penting dari blockchain - tidak ada struktur pusat yang bertanggung jawab untuk pemeriksaan, dan urutan pesan dan isinya tidak dapat dipalsukan. <br><br>  Pertama, satu simpul memeriksa keandalan, dan kemudian mengirimkannya ke orang lain - jika sebagian besar mengatakan bahwa semuanya beres, transaksi akan dimasukkan dalam blok rantai berikutnya - ini adalah konsensus. <br><br><img src="https://habrastorage.org/webt/4h/qe/to/4hqetosedsbnm1qnu-pir3jjj4k.gif"><br><br>  Bagian dari kode host yang bertanggung jawab untuk validasi dapat dilihat di GitHub - <a href="">validator.js</a> dan <a href="">verifikasi.js</a> .  Ya, simpul tersebut berjalan di Node.js. <br><br><h2>  Sertakan transaksi dengan pesan di blokir </h2><br>  Jika konsensus tercapai, transaksi dengan pesan kami akan jatuh ke blok berikutnya, bersama dengan transaksi yang dapat diandalkan lainnya. <br><br>  Blok memiliki urutan yang ketat, dan setiap blok berikutnya dibentuk berdasarkan hash dari blok sebelumnya. <br><br><img src="https://habrastorage.org/webt/es/cf/kt/escfktkasqdtkv2hxs5me6urmmm.png"><br><br>  Intinya adalah bahwa pesan kami juga termasuk dalam urutan ini dan tidak dapat "diatur ulang".  Jika beberapa pesan masuk ke dalam blokir, urutannya akan ditentukan oleh <code>timestamp</code> pesan. <br><br><h2>  Membaca pesan </h2><br>  Aplikasi messenger mengambil transaksi dari blockchain yang dikirim ke penerima.  Untuk melakukan ini, kami membuat titik <code>api/chatrooms</code> . <br><br>  Semua transaksi tersedia untuk semua orang - Anda dapat menerima pesan terenkripsi.  Tetapi hanya penerima yang dapat mendekripsi dengan kunci pribadinya dan kunci publik pengirim: <br><br><pre> <code class="javascript hljs">** * Decodes the incoming message * @param {any} msg encoded message * @param {string} senderPublicKey sender public key * @param {string} privateKey our private key * @param {any} nonce nonce * @returns {string} *<span class="hljs-regexp"><span class="hljs-regexp">/ adamant.decodeMessage = function (msg, senderPublicKey, privateKey, nonce) { if (typeof msg === 'string') { msg = hexToBytes(msg) } if (typeof nonce === 'string') { nonce = hexToBytes(nonce) } if (typeof senderPublicKey === 'string') { senderPublicKey = hexToBytes(senderPublicKey) } if (typeof privateKey === 'string') { privateKey = hexToBytes(privateKey) } const DHPublicKey = ed2curve.convertPublicKey(senderPublicKey) const DHSecretKey = ed2curve.convertSecretKey(privateKey) const decrypted = nacl.box.open(msg, nonce, DHPublicKey, DHSecretKey) return decrypted ? decode(decrypted) : '' }</span></span></code> </pre> <br><h2>  Apa lagi </h2><br>  Karena pesan dikirimkan dengan cara ini selama sekitar 5 detik - ini adalah waktu blok jaringan baru muncul - kami datang dengan koneksi socket client-node dan node-to-node.  Ketika sebuah node menerima transaksi baru, ia memeriksa validitasnya dan mentransfernya ke node lain.  Transaksi ini tersedia untuk klien kurir bahkan sebelum dimulainya konsensus dan dimasukkan dalam blok.  Jadi kami akan mengirimkan pesan secara instan, serta pesan biasa. <br><br>  Untuk menyimpan buku alamat, kami membuat KVS - Key-Value Storage adalah jenis transaksi lain di mana <code>asset</code> dienkripsi bukan dengan NaCl-box, tetapi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NaCl-secretbox</a> .  Jadi kurir menyimpan data lainnya. <br><br>  Transfer file / gambar dan obrolan grup masih memerlukan banyak pekerjaan.  Tentu saja, dalam format tyap-bloop, ini dapat diikat dengan cepat, tetapi kami ingin mempertahankan tingkat privasi yang sama. <br><br>  Ya, masih ada pekerjaan yang harus dilakukan - idealnya, privasi nyata menyiratkan bahwa pengguna tidak akan terhubung ke node jaringan publik, tetapi akan meningkatkan sendiri.  Bagaimana menurut Anda, berapa persen pengguna yang melakukan ini?  Itu benar, 0. Sebagian, kami berhasil menyelesaikan masalah ini dengan versi Tor messenger. <br><br>  Kami telah membuktikan bahwa seorang messenger di blockchain dapat ada.  Sebelumnya, hanya ada satu upaya di 2012 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bitmessage</a> , yang gagal karena waktu pengiriman pesan yang lama, beban CPU dan kurangnya aplikasi mobile. <br><br>  Dan skeptisisme terkait dengan fakta bahwa para utusan di blockchain ada di depan - orang tidak siap untuk bertanggung jawab atas akun mereka sendiri, kepemilikan informasi pribadi belum menjadi tren, dan teknologi tidak memungkinkan memastikan kecepatan tinggi pada blockchain.  Berikut ini akan muncul lebih banyak analog teknologi dari proyek kami.  Kamu akan lihat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467751/">https://habr.com/ru/post/id467751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467741/index.html">Pengantar majelis deterministik dalam C / C ++. Bagian 1</a></li>
<li><a href="../id467743/index.html">SamsPcbGuide, bagian 11: Teknologi - penutup tipe BGA, plastik, dan ruang</a></li>
<li><a href="../id467745/index.html">Cluster lebih baik daripada "metode siku"</a></li>
<li><a href="../id467747/index.html">Tes psikologis: cara mendapatkan dari psikolog bersertifikat ke tester</a></li>
<li><a href="../id467749/index.html">GCP: Parsing Google Cloud Platform Computing Stack</a></li>
<li><a href="../id467753/index.html">Rekor dunia untuk transmisi data nirkabel: 40 Gb / s per 11 kilometer</a></li>
<li><a href="../id467755/index.html">Prion, kalsium, mikrobiota, hormon makanan, dan Alzheimer</a></li>
<li><a href="../id467759/index.html">Desain OS seperti Unix - Ruang Alamat Virtual (6)</a></li>
<li><a href="../id467761/index.html">Energi, panas, dan air bagian tiga: buka radio</a></li>
<li><a href="../id467763/index.html">Seluruh kebenaran tentang RTOS. Artikel # 33. Menggunakan Sistem Operasi Real-Time Nucleus SE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>