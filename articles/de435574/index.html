<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍💼 🙌🏾 👨🏼‍🚀 Wie funktioniert Zickzack? 🤷🏼 👨🏼 🗜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem Übersetzer: Dieser Beitrag wurde am 15. März 2018 im Blog des Autors veröffentlicht. Während sich eine Sprache weiterentwickelt, kann ihre S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie funktioniert Zickzack?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>Von einem Übersetzer: Dieser Beitrag wurde am 15. März 2018 im Blog des Autors veröffentlicht.</i>  <i>Während sich eine Sprache weiterentwickelt, kann ihre Syntax derzeit unterschiedlich sein.</i>  <i>Alles, was beschrieben wird, bezieht sich auf Zig 0.2.0, die aktuelle Version der Sprache ist Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich habe den Autor des Beitrags kontaktiert und er hat freundlicherweise einen Link zum Repository mit der aktuellen Version der Projektquellen auf Zig 0.3.0 bereitgestellt</a></i> <i><br></i> <br>  Hallo!  Schreiben wir einen Brainfuck-Dolmetscher!  "Warum?"  "Sie können fragen, aber Sie werden die Antwort hier nicht finden." <br><br>  Ich werde es auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zig machen</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig ist ... </h3><br>  ... eine neue Programmiersprache.  Es befindet sich noch in der Beta und entwickelt sich rasant.  Wenn Sie den Zig-Code schon einmal gesehen haben, scheint Ihnen der Code in diesem Beitrag etwas anders zu sein.  Er ist wirklich anders!  Zig 0.2.0 wurde gerade veröffentlicht, zeitgleich mit der Veröffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM 6 vor</a> einigen Wochen, und enthält viele Syntaxänderungen und allgemeine Sprachverbesserungen.  Meistens wurden viele „Zaubersprüche“ durch Schlüsselwörter ersetzt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier finden Sie</a> eine ausführlichere Erklärung aller Änderungen! <br><br>  Zig ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesbar</a> und für diejenigen, die mit kompilierten und getippten Sprachen wie C, C ++ und an einigen Stellen Rust vertraut sind, relativ intuitiv. <br><br>  Der Code wurde mit Zig 0.2.0 kompiliert und getestet, das derzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über verschiedene Kanäle</a> verfügbar ist, einschließlich Homebrew, wenn Sie unter OSX arbeiten: Brew Install Zig. <br><a name="habracut"></a><br><h3>  Fangen wir an </h3><br>  Informationen zur Funktionsweise von Brainfuck finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Dort gibt es fast nichts zu lernen, aber es ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Turing-vollständige</a> Sprache, was bedeutet, dass Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alles</a> darauf schreiben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können</a> . <br><br>  Ich habe den Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier veröffentlicht</a> , falls Sie das Endprodukt oder frühzeitige Commits sehen möchten. <br><br>  Zig ist eine kompilierte Sprache.  Wenn Sie ein Programm kompilieren, sollte die resultierende Binärdatei (wenn Sie eine ausführbare Binärdatei kompilieren, keine Bibliothek) eine Hauptfunktion haben, die den Einstiegspunkt markiert. <br><br>  Also ... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... und fang an ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... gibt aus ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main muss als öffentlich deklariert werden, um außerhalb des Moduls sichtbar zu sein ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Lassen Sie das Brainfuck-Programm ein Array von 30.000 Bytes als Speicher verwenden, ich werde ein solches Array erstellen. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  Ich kann eine Konstante (const) oder eine Variable (var) deklarieren.  Hier habe ich mem als Array von 30.000 vorzeichenlosen (u) Bytes (8 Bits) deklariert. <br><br>  Dies wird nicht kompiliert. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  Ein äquivalentes C-Programm würde normal kompilieren: Ich kann eine Variable ohne Initialisierung deklarieren, aber Zig zwingt mich, jetzt eine Entscheidung zu treffen, wenn die Variable deklariert wird.  Es ist mir vielleicht egal, was darin geschrieben wird, aber ich muss dies ausdrücklich angeben.  Ich werde dies tun, indem ich die Variable mit einem undefinierten Wert (undefiniert) initialisiere. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  Die Initialisierung einer Variablen mit einem undefinierten Wert gibt keine Garantie für den Wert der Variablen im Speicher.  Dies entspricht einer nicht initialisierten Variablendeklaration in C, außer dass Sie dies explizit angeben müssen. <br><br>  Aber vielleicht ist es mir egal, wie ich diesen Speicher initialisiere.  Vielleicht möchte ich eine Garantie haben, dass die Nullen oder ein beliebiger Wert dort geschrieben sind.  In diesem Fall sollte ich auch ausdrücklich Folgendes angeben: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  Es mag seltsam erscheinen, aber ** ist der Operator, mit dem Arrays erweitert werden.  Ich deklariere ein Array von 0 Bytes, erweitere es dann auf 30.000 und erhalte den endgültigen Initialisierungswert von 30.000 Null-Bytes.  Diese Operation wird einmal <i>zur Kompilierungszeit ausgeführt</i> .  comptime ist eine der großartigen Ideen von Zig, und ich werde in einem der folgenden Beiträge darauf zurückkommen. <br><br>  Jetzt schreiben wir ein Programm über Brainfuck, das nichts anderes tut, als den ersten Speicherplatz fünfmal zu erhöhen! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  In Zig sind Strings Byte-Arrays.  Ich sollte src nicht als Byte-Array deklarieren, da der Compiler dies impliziert.  Dies ist optional, aber wenn Sie möchten, ist es möglich: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  Dies wird gut kompiliert.  Dies ist jedoch: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  wird nicht. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Noch ein Hinweis: Da Strings nur Arrays sind, enden sie nicht mit Null.  Sie können jedoch eine nullterminierte Zeichenfolge C deklarieren. Als Literal sieht dies folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  Für das Gemeinwohl ... </h3><br>  Ich möchte mit jedem Zeichen in einer Zeichenfolge <i>etwas</i> tun.  Ich kann es schaffen!  Zu Beginn von main.zig importiere ich einige Funktionen aus der Standardbibliothek: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Der Import</a> ist wie praktisch alles, was mit dem @ -Zeichen beginnt, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">integrierte Compilerfunktion</a> .  Solche Funktionen sind immer global verfügbar.  Der Import hier funktioniert ähnlich wie bei Javascript. Sie können alles importieren, indem Sie in den Namespace graben und daraus öffentlich verfügbare Funktionen oder Variablen extrahieren.  Im obigen Beispiel importiere ich die Warnfunktion direkt und ordne sie plötzlich der Warnkonstante zu.  Jetzt kann sie angerufen werden.  Dies ist ein gängiges Muster: Wir importieren direkt aus dem Standard-Namespace und rufen dann entweder std.debug.warn () auf oder weisen es der warn-Variablen zu.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  Während des Debuggens und der anfänglichen Entwicklung und des Testens möchte ich nur etwas auf dem Bildschirm drucken.  Zig ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fehleranfällig</a> und stdout ist auch fehleranfällig.  Ich möchte dies jetzt nicht tun und kann mit warn, das wir aus der Standardbibliothek importiert haben, direkt auf stderr drucken. <br><br>  warn nimmt eine formatierte Zeichenfolge an, wie printf in C!  Der obige Code wird gedruckt: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 ist der ASCII-Zeichencode +.  Ich kann auch schreiben: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  und bekommen: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  Also haben wir den Speicherplatz initialisiert und das Programm geschrieben.  Jetzt erkennen wir die Sprache selbst.  Ich beginne mit + und ersetze den Körper der for-Schleife durch switch: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  Ich erhalte zwei Fehler: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  Natürlich kann ich einer Variablen, die eine Konstante ist, keinen neuen Wert zuweisen!  mem muss eine Variable sein ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  Wie bei anderen Fehlern sollte mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schalterkonstrukt</a> wissen, was zu tun ist, wenn das Zeichen nicht + ist, auch wenn nichts getan werden muss.  In meinem Fall ist das genau das, was ich will.  Ich fülle diesen Fall mit einem leeren Block: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Jetzt kann ich das Programm kompilieren.  Rufen Sie am Ende warn auf und führen Sie Folgendes aus: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  Ich bekomme die Nummer 5 wie erwartet in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stderr</a> gedruckt. <br><br><h3>  Lass uns weitermachen ... </h3><br>  Ebenso unterstützen wir. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  Um&gt; und &lt;zu verwenden, müssen Sie eine zusätzliche Variable verwenden, die als "Zeiger" in dem Speicher dient, den ich für das Benutzer-Brainfuck-Programm zugewiesen habe. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Da ein vorzeichenloses 16-Bit maximal 65535 sein kann, ist es mehr als ausreichend, 30.000 Byte Adressraum zu indizieren. <br><br><blockquote>  <i>Tatsächlich würden 15 Bits für uns ausreichen, wodurch wir 32767 Bytes adressieren können.</i>  <i>Zig erlaubt Typen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterschiedlichen Breiten</a> , aber noch nicht u15.</i> <i><br><br></i>  <i>Sie können u15 tatsächlich so machen:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es wird vorgeschlagen,</a> dass jeder [iu] \ d + -Typ als ganzzahliger Typ gültig ist. </blockquote><br>  Anstatt mem [0] zu verwenden, kann ich jetzt diese Variable verwenden. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;und&gt; erhöht und dekrementiert diesen Zeiger einfach. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  Großartig  Wir können jetzt ein echtes Programm schreiben! <br><br><h3>  Überprüfen Sie 1,2,3 </h3><br>  Zig hat einen eingebauten Testmotor.  Überall in einer Datei kann ich einen Testblock schreiben: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  und führen Sie den Test über die Befehlszeile aus: zig test $ FILENAME.  Der Rest der Testblöcke entspricht dem regulären Code. <br><br>  Schauen wir uns das an: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Ein leerer Test ist natürlich nutzlos.  Ich kann assert verwenden, um die Ausführung der Tests tatsächlich zu bestätigen. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  Der Test fiel.  Verwenden Sie den folgenden Befehl, um den Fehler zu reproduzieren: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Stapelspur auf der Mohnblume befindet sich noch in der Entwicklung.</a> <br><br>  Um dies effizient zu testen, muss ich es in Stücke zerbrechen.  Beginnen wir damit: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  Es sollte scheinen zu funktionieren, oder? <br><br>  Aber ... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  Dies wird unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/zig-lang/zig/issues/733 beschrieben</a> . </blockquote><br>  Zig ist diesbezüglich streng.  Komplexe Typen und alle Objekte, deren Größe geändert werden kann, können nicht als Wert übergeben werden.  Dies macht die Stapelzuordnung vorhersehbar und logisch und vermeidet unnötiges Kopieren.  Wenn Sie die Semantik der Wertübertragung in Ihrem Programm verwenden möchten, können Sie sie mithilfe Ihrer Zuordnungsstrategie selbst implementieren. Die Sprache selbst unterstützt dies jedoch unter normalen Umständen nicht. <br><br>  Der natürliche Weg, um diese Einschränkung zu umgehen, besteht darin, einen Zeiger anstelle eines Werts zu übergeben (als Referenz übergeben).  Zig verwendet eine andere Strategie, Scheiben.  Ein Slice ist ein Zeiger mit einer Länge und einem Häkchen für das Fallen in Ränder.  Die Syntax in der Funktionssignatur sieht folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  und beim Aufrufen der Funktion sieht es so aus: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Beachten Sie, dass ich die Obergrenze einfach durch Bezugnahme auf die Länge des Arrays definiert habe.  Für solche Fälle gibt es eine abgekürzte Notationsform: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Jetzt kann ich Tests schreiben, die die Funktion bf () direkt testen.  Ich werde vorerst Testfunktionen am Ende der Datei hinzufügen ... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  Ich nehme das mem-Array von einem Byte und überprüfe dann, was passieren soll (das Byte wird dreimal inkrementiert).  Es funktioniert! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" wird auf die gleiche Weise überprüft: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  Das ____ funktioniert nicht!  Wenn ich versuche, 1 von 0 zu subtrahieren, bekomme ich ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem ist ein Array von vorzeichenlosen Bytes, und das Subtrahieren von 1 von 0 führt zu einem Überlauf.  Wieder lässt mich Zig explizit erklären, was ich will.  In diesem Fall muss ich mir keine Sorgen um einen Überlauf machen, ich möchte, dass dies geschieht, da es sich um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modulare Arithmetik</a> gemäß der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation von Brainfuck handelt</a> .  Dies bedeutet, dass das Dekrementieren einer Zelle mit der Nummer 0 255 ergibt und ein Inkrementieren von 255 0 ergibt. <br><br>  Zig verfügt über mehrere Hilfsarithmetikoperationen, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semantik eines garantierten „Umhüllens“</a> bieten. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  Dies löst das gesamte Überlaufproblem und macht das, was ich erwartet hatte. <br><br>  Zum Testen von &lt;und&gt; navigiere ich durch ein kleines Array und überprüfe den Wert der inkrementierten Zelle: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  und ... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  Im letzteren Fall kann ich das Ergebnis direkt mit einem statischen Array vergleichen, indem ich ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Denken Sie daran, dass ich bereits std importiert habe.  Im folgenden Beispiel verwende ich mem.eql in diesem Namespace: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... und denken Sie daran, String-Literale, dies sind nur U8-Arrays im Zickzack, und ich kann hexadezimale Literale in sie einfügen, d. h.  Der folgende Code funktioniert genauso! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  Fügen Sie das "." Hinzu!  Der Bytewert in der Zelle, auf die der Zeiger zeigt, wird einfach als Zeichen gedruckt.  Ich verwende jetzt warn, aber später werde ich es durch stdout ersetzen.  Dies ist konzeptionell einfach, aber in der Implementierung etwas verwirrt.  Ich werde es später tun! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Zyklen <br>  [und] - hier beginnt die Magie .... <br><br>  [- Wenn der Wert der aktuellen Zelle Null ist, überspringen Sie die Schritte zur schließenden Klammer, ohne den Code auszuführen. <br>  ] - Wenn der Wert der aktuellen Zelle nicht Null ist, kehren Sie zur öffnenden Klammer zurück und führen Sie den Code erneut aus. <br><br>  Dieses Mal werde ich mit einem Test beginnen, ich werde sie zusammen testen (offensichtlich macht es keinen Sinn, sie separat zu testen).  Der erste Testfall - die Speicherzelle [2] sollte leer sein, obwohl die Schleife sie erhöhen sollte, wenn sie startet: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  und ich werde Leerzeichen für die switch-Anweisung erstellen: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  Was ist jetzt zu tun?  Sie können einen naiven Ansatz verwenden.  Ich erhöhe nur den src-Zeiger, bis ich ihn finde].  Ich kann die for-Schleife hierfür jedoch nicht im Zickzack verwenden. Sie wurde nur zum Durchlaufen von Sammlungen erstellt, ohne dass deren Elemente fehlen.  Ein geeignetes Konstrukt hier ist während: <br><br>  war: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  wurde ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Jetzt kann ich den srcptr-Zeiger in der Mitte des Blocks neu zuweisen. Ich werde dies tun: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  Dies erfüllt den Test "[] überspringt die Codeausführung und wird beendet" <br>  Dies erfüllt den Test "[] überspringt die Ausführung und beendet", obwohl er nicht ganz zuverlässig ist, wie wir sehen werden. <br><br>  Was ist mit dem Schließen von Klammern?  Ich glaube, es kann einfach analog geschrieben werden: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  Sie können sehen, was passiert ... Eine naive Lösung mit zwei Klammern weist einen schwerwiegenden Fehler auf und bricht in verschachtelten Schleifen vollständig ab.  Beachten Sie Folgendes: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  Das Ergebnis sollte {2, 0} sein, aber die erste offene Klammer bewegt sich einfach dumm zur ersten schließenden Klammer, und alles wird chaotisch.  Sie müssen zur nächsten schließenden Klammer auf derselben Verschachtelungsebene springen.  Es ist einfach, einen Tiefenzähler hinzuzufügen und ihn zu verfolgen, während Sie sich entlang der Linie vorwärts bewegen.  Wir machen es in beide Richtungen: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  und verwandte Tests: Beachten Sie, dass src in beiden Tests eine innere Schleife enthält. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  Beachten Sie separat [-] - die Redewendung von Brainfuck, was "Null dieser Zelle" bedeutet.  Sie können sehen, dass es keine Rolle spielt, welchen Wert die Zelle zu Beginn hatte. Sie wird dekrementiert, bis sie 0 erreicht, und die Ausführung wird fortgesetzt. </blockquote><br><h3>  Unglücklicher Weg </h3><br>  Ich habe nicht mit der Möglichkeit gerechnet, dass das Programm auf bf kaputt gehen würde.  Was passiert, wenn ich meinem Dolmetscher ein falsches Eingabeprogramm sende?  Zum Beispiel einfach [ohne schließende Klammer oder &lt;, was sofort über das Speicherarray hinausgeht?  (Ich kann den Speicherzeiger umbrechen, aber es ist besser, dies als Fehler zu betrachten). <br><br>  Ich werde ein wenig nach vorne schauen und alle Unterschiede im Code erklären.  Ich werde die bf-Interpreter-Funktion in eine separate Datei einfügen und auch die Funktionen seekBack und seekForward in meine eigenen kleinen Funktionen einfügen. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  Dies macht es meiner Meinung nach viel einfacher, den Schalter zu lesen. SearchForward und seekBack funktionieren und sehen sehr ähnlich aus, und ich war versucht, sie in etwas intelligenteres und kompakteres umzuwandeln, aber am Ende machen sie verschiedene Dinge und behandeln Fehler auch auf verschiedene Arten.  Einfacher zu kopieren und anzupassen, so wird es klarer.  Ich werde seekForward auch später anpassen, irgendwann, möglicherweise in einem nachfolgenden Beitrag. <br><br>  Ich habe einige wichtige Dinge hinzugefügt!  Beachten Sie, dass alle drei Funktionen jetzt einen Typ zurückgeben! Dies ist die neue Syntax für den früheren Typ% T (Fehlerunion).  Dies bedeutet, dass die Funktion entweder einen bestimmten Typ oder einen Fehler zurückgeben kann.  Wenn ich versuche, eine solche Funktion aufzurufen, muss ich entweder try verwenden, bevor ich die Funktion aufrufe, die den Fehler in den Aufrufstapel wirft, wenn der Fehler auftritt, oder catch verwenden: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  Wo ich Fehler in einem Catch-Block behandle.  Wie geschrieben, kann catch Fehler verschlucken.  Dies ist eine schlechte Praxis, aber hier lässt Zig uns dies explizit tun.  Wenn ich einen Fehler in einem leeren Block abfange, gebe ich an, dass ich entweder nicht glaube, dass ein Fehler auftreten kann, oder dass ich ihn nicht behandeln muss.  In der Praxis kann es so etwas wie TODO sein, und tatsächlich ist es sehr einfach, es auch explizit zu machen! <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Denken Sie daran, dass ein solcher Fall im Produktionscode niemals auftreten wird.  Ich benachrichtige den Compiler, dass ich weiß, was ich tue.  Wenn ein Fehler auftreten könnte, müsste ich die Fehlerbehandlung hinzufügen. <br><br>  Welche Fehler sollte ich von seekBack oder seekForward zurückgeben? <br><br>  In seekBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  Ich habe den Dekrementzeiger ersetzt, um die Unterfunktion von std lib zu verwenden, die einen Überlauffehler auslöst, wenn ein Überlauf auftritt.  Ich möchte diesen Fehler abfangen und stattdessen den OutOfBounds-Fehler zurückgeben, den ich hier nur mit ihm erstelle. <br><br><blockquote>  <i>Fehler Zig ist im Grunde ein Array von Fehlercodes, die vom Compiler generiert werden, wenn Sie Fehler verwenden. Eine Art Fehler.</i>  <i>Sie sind garantiert eindeutig und können als Werte in einem Schaltblock verwendet werden.</i> </blockquote><br>  Ich möchte hier OutOfBounds verwenden, da ich semantisch, wenn der Speicherzeiger kleiner als Null wird, die Laufzeit auffordere, über den von mir zugewiesenen Speicherplatz hinauszugehen. <br><br>  ähnlich in der Funktion seekForward: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  In diesem Fall, wenn der Zeiger größer als src.len ist, fange ich den Fehler hier ab und gebe den gleichen Fehler zurück. <br><br>  beim Anruf: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  Ich versuche diese Funktionen aufzurufen.  Wenn sie erfolgreich aufgerufen werden, werden sie korrekt ausgeführt und versuchen, srcptr zurückzugeben.  Wenn sie nicht erfolgreich sind, beendet try die Funktion und gibt einen Fehler an den Ort des Aufrufs an die gesamte Funktion bf zurück. <br><br>  Der Anruf kann von main sein! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  Ich schlucke diesen Fehler hier und er sollte nicht gemacht werden, aber wir werden einen wichtigen Punkt darüber beachten, wie leicht Zick-Zack-Fehler den Aufrufstapel weiterleiten können.  Es liegt nicht in der Verantwortung der aufrufenden Funktion, jeden Fehlerfall zu überprüfen, aber der Compiler erzwingt den Aufruf jeder Funktion, die bei einem Versuch fehlschlagen kann.  Dies muss immer geschehen, auch wenn Fehler ignoriert werden! <br><br><blockquote>  <i>Die neue Try / Catch-Syntax eliminiert die vielen Zaubersprüche wie %% und%, die die Leute nicht so sehr mögen.</i> </blockquote><br>  Jetzt habe ich 7 von 8 Brainfuck-Charakteren implementiert, und dies reicht aus, um ein „aussagekräftiges“ Programm auszuführen. <br><br><h3>  Ein sinnvolles Programm </h3><br>  Hier ist das Programm: <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Lass uns rennen ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  voila! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>Jedes Mal, wenn ich an eine Fibonacci-Serie denke, fällt mir eine Erinnerung ein ... Ich habe es in den 80er Jahren im PBS-Programm (Public Broadcasting Service, ein nichtkommerzieller amerikanischer Fernsehsender) erfahren, und ich erinnere mich immer daran.</i>  <i>Ich dachte, es wäre vergessen, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Youtube ist eine großartige Sache</a> .</i> </blockquote><br><h3>  Wie kann ich das verbessern? </h3><br>  Ich habe bereits einige TODOs angedeutet.  Ich hätte stderr nicht für die Ausgabe verwenden sollen.  Ich möchte stdout verwenden. <br><br>  Jedes Mal, wenn ich den Interpreter öffne, öffne ich den Stream in stdout und drucke ihn aus: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  Was ist hier los?   io.getStdOut(),     (          catch unreachable —     ,  !).   ,    ,      ,       print. print   ,   warn,     . print    ,      . <br><br>    ,         stdout,        stdout. Zig         ,   ,    . <br><br>  ,   ,        ?              ,      ,            ?  ,        ?  , Zig  ! <br><br>     ,  ! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br>  ,  bf   ,     !void.       ,   main.          ,      : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>    ! <br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br>      ,      bf   !   ,     ,  stdout,     bf.  ,   ,       ,  try. ,   ,  ,  catch,   try,      ,       . <br><br> , : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>      ,    ,  ! <br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br> Zig       ,       !   switch   ,  ,   ,  ,     . <br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br>  -     ,  ,     ,   Zig,        !    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>   !  ! <br><br><h3> Todo </h3><br>    ,     !         , ,     ",",   brainfuck-    getc,        .            ,      bf.    ,     ,      Zig.  ,       ,           ,       . <br><br><h3>  Fazit </h3><br>  ,           ,     Zig       . Zig    ,       ,     ,  ,     ,          ++.        ,  ,   .     ,   ,   . Zig ,   ,       ,      . <br><br>         Zig,    ,      0.2.0  !  ,   ,   debug-,          ,    !   --release-fast  --release-safe,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>        Zig.     ,       1.0.0,      Zig,    ,    ,       ! <br><br> ,    #zig  freenode   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435574/">https://habr.com/ru/post/de435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435560/index.html">Erster kommerzieller Quantencomputer - IBM</a></li>
<li><a href="../de435562/index.html">Der Weg eines Rauchers: Wie man als Humanist in den Beruf eines Programmierers einsteigt</a></li>
<li><a href="../de435564/index.html">Verwenden von GtkApplication. Librsvg-Rendering-Funktionen</a></li>
<li><a href="../de435568/index.html">VyOS OpenSource Router</a></li>
<li><a href="../de435572/index.html">Anycubic i3 Mega: Qualitäts-Remake von Prusa i3</a></li>
<li><a href="../de435576/index.html">1C, keine Schmerzen</a></li>
<li><a href="../de435578/index.html">Weltraumspaziergang zu Weihnachten</a></li>
<li><a href="../de435580/index.html">Java, Spring, Kurento und Media Services</a></li>
<li><a href="../de435582/index.html">Wie füge ich einen Index auf einem geladenen System rund um die Uhr ohne Ausfallzeiten hinzu?</a></li>
<li><a href="../de435584/index.html">Slush 2018. Erster Tag, Zweiter Tag</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>