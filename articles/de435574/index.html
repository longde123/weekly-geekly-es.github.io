<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüíº üôåüèæ üë®üèº‚ÄçüöÄ Wie funktioniert Zickzack? ü§∑üèº üë®üèº üóúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem √úbersetzer: Dieser Beitrag wurde am 15. M√§rz 2018 im Blog des Autors ver√∂ffentlicht. W√§hrend sich eine Sprache weiterentwickelt, kann ihre S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie funktioniert Zickzack?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>Von einem √úbersetzer: Dieser Beitrag wurde am 15. M√§rz 2018 im Blog des Autors ver√∂ffentlicht.</i>  <i>W√§hrend sich eine Sprache weiterentwickelt, kann ihre Syntax derzeit unterschiedlich sein.</i>  <i>Alles, was beschrieben wird, bezieht sich auf Zig 0.2.0, die aktuelle Version der Sprache ist Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich habe den Autor des Beitrags kontaktiert und er hat freundlicherweise einen Link zum Repository mit der aktuellen Version der Projektquellen auf Zig 0.3.0 bereitgestellt</a></i> <i><br></i> <br>  Hallo!  Schreiben wir einen Brainfuck-Dolmetscher!  "Warum?"  "Sie k√∂nnen fragen, aber Sie werden die Antwort hier nicht finden." <br><br>  Ich werde es auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zig machen</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig ist ... </h3><br>  ... eine neue Programmiersprache.  Es befindet sich noch in der Beta und entwickelt sich rasant.  Wenn Sie den Zig-Code schon einmal gesehen haben, scheint Ihnen der Code in diesem Beitrag etwas anders zu sein.  Er ist wirklich anders!  Zig 0.2.0 wurde gerade ver√∂ffentlicht, zeitgleich mit der Ver√∂ffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM 6 vor</a> einigen Wochen, und enth√§lt viele Syntax√§nderungen und allgemeine Sprachverbesserungen.  Meistens wurden viele ‚ÄûZauberspr√ºche‚Äú durch Schl√ºsselw√∂rter ersetzt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier finden Sie</a> eine ausf√ºhrlichere Erkl√§rung aller √Ñnderungen! <br><br>  Zig ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesbar</a> und f√ºr diejenigen, die mit kompilierten und getippten Sprachen wie C, C ++ und an einigen Stellen Rust vertraut sind, relativ intuitiv. <br><br>  Der Code wurde mit Zig 0.2.0 kompiliert und getestet, das derzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber verschiedene Kan√§le</a> verf√ºgbar ist, einschlie√ülich Homebrew, wenn Sie unter OSX arbeiten: Brew Install Zig. <br><a name="habracut"></a><br><h3>  Fangen wir an </h3><br>  Informationen zur Funktionsweise von Brainfuck finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Dort gibt es fast nichts zu lernen, aber es ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Turing-vollst√§ndige</a> Sprache, was bedeutet, dass Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alles</a> darauf schreiben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen</a> . <br><br>  Ich habe den Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ver√∂ffentlicht</a> , falls Sie das Endprodukt oder fr√ºhzeitige Commits sehen m√∂chten. <br><br>  Zig ist eine kompilierte Sprache.  Wenn Sie ein Programm kompilieren, sollte die resultierende Bin√§rdatei (wenn Sie eine ausf√ºhrbare Bin√§rdatei kompilieren, keine Bibliothek) eine Hauptfunktion haben, die den Einstiegspunkt markiert. <br><br>  Also ... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... und fang an ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... gibt aus ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main muss als √∂ffentlich deklariert werden, um au√üerhalb des Moduls sichtbar zu sein ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Lassen Sie das Brainfuck-Programm ein Array von 30.000 Bytes als Speicher verwenden, ich werde ein solches Array erstellen. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  Ich kann eine Konstante (const) oder eine Variable (var) deklarieren.  Hier habe ich mem als Array von 30.000 vorzeichenlosen (u) Bytes (8 Bits) deklariert. <br><br>  Dies wird nicht kompiliert. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  Ein √§quivalentes C-Programm w√ºrde normal kompilieren: Ich kann eine Variable ohne Initialisierung deklarieren, aber Zig zwingt mich, jetzt eine Entscheidung zu treffen, wenn die Variable deklariert wird.  Es ist mir vielleicht egal, was darin geschrieben wird, aber ich muss dies ausdr√ºcklich angeben.  Ich werde dies tun, indem ich die Variable mit einem undefinierten Wert (undefiniert) initialisiere. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  Die Initialisierung einer Variablen mit einem undefinierten Wert gibt keine Garantie f√ºr den Wert der Variablen im Speicher.  Dies entspricht einer nicht initialisierten Variablendeklaration in C, au√üer dass Sie dies explizit angeben m√ºssen. <br><br>  Aber vielleicht ist es mir egal, wie ich diesen Speicher initialisiere.  Vielleicht m√∂chte ich eine Garantie haben, dass die Nullen oder ein beliebiger Wert dort geschrieben sind.  In diesem Fall sollte ich auch ausdr√ºcklich Folgendes angeben: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  Es mag seltsam erscheinen, aber ** ist der Operator, mit dem Arrays erweitert werden.  Ich deklariere ein Array von 0 Bytes, erweitere es dann auf 30.000 und erhalte den endg√ºltigen Initialisierungswert von 30.000 Null-Bytes.  Diese Operation wird einmal <i>zur Kompilierungszeit ausgef√ºhrt</i> .  comptime ist eine der gro√üartigen Ideen von Zig, und ich werde in einem der folgenden Beitr√§ge darauf zur√ºckkommen. <br><br>  Jetzt schreiben wir ein Programm √ºber Brainfuck, das nichts anderes tut, als den ersten Speicherplatz f√ºnfmal zu erh√∂hen! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  In Zig sind Strings Byte-Arrays.  Ich sollte src nicht als Byte-Array deklarieren, da der Compiler dies impliziert.  Dies ist optional, aber wenn Sie m√∂chten, ist es m√∂glich: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  Dies wird gut kompiliert.  Dies ist jedoch: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  wird nicht. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Noch ein Hinweis: Da Strings nur Arrays sind, enden sie nicht mit Null.  Sie k√∂nnen jedoch eine nullterminierte Zeichenfolge C deklarieren. Als Literal sieht dies folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  F√ºr das Gemeinwohl ... </h3><br>  Ich m√∂chte mit jedem Zeichen in einer Zeichenfolge <i>etwas</i> tun.  Ich kann es schaffen!  Zu Beginn von main.zig importiere ich einige Funktionen aus der Standardbibliothek: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Der Import</a> ist wie praktisch alles, was mit dem @ -Zeichen beginnt, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">integrierte Compilerfunktion</a> .  Solche Funktionen sind immer global verf√ºgbar.  Der Import hier funktioniert √§hnlich wie bei Javascript. Sie k√∂nnen alles importieren, indem Sie in den Namespace graben und daraus √∂ffentlich verf√ºgbare Funktionen oder Variablen extrahieren.  Im obigen Beispiel importiere ich die Warnfunktion direkt und ordne sie pl√∂tzlich der Warnkonstante zu.  Jetzt kann sie angerufen werden.  Dies ist ein g√§ngiges Muster: Wir importieren direkt aus dem Standard-Namespace und rufen dann entweder std.debug.warn () auf oder weisen es der warn-Variablen zu.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  W√§hrend des Debuggens und der anf√§nglichen Entwicklung und des Testens m√∂chte ich nur etwas auf dem Bildschirm drucken.  Zig ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fehleranf√§llig</a> und stdout ist auch fehleranf√§llig.  Ich m√∂chte dies jetzt nicht tun und kann mit warn, das wir aus der Standardbibliothek importiert haben, direkt auf stderr drucken. <br><br>  warn nimmt eine formatierte Zeichenfolge an, wie printf in C!  Der obige Code wird gedruckt: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 ist der ASCII-Zeichencode +.  Ich kann auch schreiben: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  und bekommen: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  Also haben wir den Speicherplatz initialisiert und das Programm geschrieben.  Jetzt erkennen wir die Sprache selbst.  Ich beginne mit + und ersetze den K√∂rper der for-Schleife durch switch: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  Ich erhalte zwei Fehler: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  Nat√ºrlich kann ich einer Variablen, die eine Konstante ist, keinen neuen Wert zuweisen!  mem muss eine Variable sein ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  Wie bei anderen Fehlern sollte mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schalterkonstrukt</a> wissen, was zu tun ist, wenn das Zeichen nicht + ist, auch wenn nichts getan werden muss.  In meinem Fall ist das genau das, was ich will.  Ich f√ºlle diesen Fall mit einem leeren Block: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Jetzt kann ich das Programm kompilieren.  Rufen Sie am Ende warn auf und f√ºhren Sie Folgendes aus: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  Ich bekomme die Nummer 5 wie erwartet in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stderr</a> gedruckt. <br><br><h3>  Lass uns weitermachen ... </h3><br>  Ebenso unterst√ºtzen wir. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  Um&gt; und &lt;zu verwenden, m√ºssen Sie eine zus√§tzliche Variable verwenden, die als "Zeiger" in dem Speicher dient, den ich f√ºr das Benutzer-Brainfuck-Programm zugewiesen habe. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Da ein vorzeichenloses 16-Bit maximal 65535 sein kann, ist es mehr als ausreichend, 30.000 Byte Adressraum zu indizieren. <br><br><blockquote>  <i>Tats√§chlich w√ºrden 15 Bits f√ºr uns ausreichen, wodurch wir 32767 Bytes adressieren k√∂nnen.</i>  <i>Zig erlaubt Typen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterschiedlichen Breiten</a> , aber noch nicht u15.</i> <i><br><br></i>  <i>Sie k√∂nnen u15 tats√§chlich so machen:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es wird vorgeschlagen,</a> dass jeder [iu] \ d + -Typ als ganzzahliger Typ g√ºltig ist. </blockquote><br>  Anstatt mem [0] zu verwenden, kann ich jetzt diese Variable verwenden. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;und&gt; erh√∂ht und dekrementiert diesen Zeiger einfach. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  Gro√üartig  Wir k√∂nnen jetzt ein echtes Programm schreiben! <br><br><h3>  √úberpr√ºfen Sie 1,2,3 </h3><br>  Zig hat einen eingebauten Testmotor.  √úberall in einer Datei kann ich einen Testblock schreiben: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  und f√ºhren Sie den Test √ºber die Befehlszeile aus: zig test $ FILENAME.  Der Rest der Testbl√∂cke entspricht dem regul√§ren Code. <br><br>  Schauen wir uns das an: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Ein leerer Test ist nat√ºrlich nutzlos.  Ich kann assert verwenden, um die Ausf√ºhrung der Tests tats√§chlich zu best√§tigen. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  Der Test fiel.  Verwenden Sie den folgenden Befehl, um den Fehler zu reproduzieren: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Stapelspur auf der Mohnblume befindet sich noch in der Entwicklung.</a> <br><br>  Um dies effizient zu testen, muss ich es in St√ºcke zerbrechen.  Beginnen wir damit: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  Es sollte scheinen zu funktionieren, oder? <br><br>  Aber ... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  Dies wird unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/zig-lang/zig/issues/733 beschrieben</a> . </blockquote><br>  Zig ist diesbez√ºglich streng.  Komplexe Typen und alle Objekte, deren Gr√∂√üe ge√§ndert werden kann, k√∂nnen nicht als Wert √ºbergeben werden.  Dies macht die Stapelzuordnung vorhersehbar und logisch und vermeidet unn√∂tiges Kopieren.  Wenn Sie die Semantik der Wert√ºbertragung in Ihrem Programm verwenden m√∂chten, k√∂nnen Sie sie mithilfe Ihrer Zuordnungsstrategie selbst implementieren. Die Sprache selbst unterst√ºtzt dies jedoch unter normalen Umst√§nden nicht. <br><br>  Der nat√ºrliche Weg, um diese Einschr√§nkung zu umgehen, besteht darin, einen Zeiger anstelle eines Werts zu √ºbergeben (als Referenz √ºbergeben).  Zig verwendet eine andere Strategie, Scheiben.  Ein Slice ist ein Zeiger mit einer L√§nge und einem H√§kchen f√ºr das Fallen in R√§nder.  Die Syntax in der Funktionssignatur sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  und beim Aufrufen der Funktion sieht es so aus: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Beachten Sie, dass ich die Obergrenze einfach durch Bezugnahme auf die L√§nge des Arrays definiert habe.  F√ºr solche F√§lle gibt es eine abgek√ºrzte Notationsform: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Jetzt kann ich Tests schreiben, die die Funktion bf () direkt testen.  Ich werde vorerst Testfunktionen am Ende der Datei hinzuf√ºgen ... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  Ich nehme das mem-Array von einem Byte und √ºberpr√ºfe dann, was passieren soll (das Byte wird dreimal inkrementiert).  Es funktioniert! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" wird auf die gleiche Weise √ºberpr√ºft: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  Das ____ funktioniert nicht!  Wenn ich versuche, 1 von 0 zu subtrahieren, bekomme ich ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem ist ein Array von vorzeichenlosen Bytes, und das Subtrahieren von 1 von 0 f√ºhrt zu einem √úberlauf.  Wieder l√§sst mich Zig explizit erkl√§ren, was ich will.  In diesem Fall muss ich mir keine Sorgen um einen √úberlauf machen, ich m√∂chte, dass dies geschieht, da es sich um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modulare Arithmetik</a> gem√§√ü der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation von Brainfuck handelt</a> .  Dies bedeutet, dass das Dekrementieren einer Zelle mit der Nummer 0 255 ergibt und ein Inkrementieren von 255 0 ergibt. <br><br>  Zig verf√ºgt √ºber mehrere Hilfsarithmetikoperationen, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semantik eines garantierten ‚ÄûUmh√ºllens‚Äú</a> bieten. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  Dies l√∂st das gesamte √úberlaufproblem und macht das, was ich erwartet hatte. <br><br>  Zum Testen von &lt;und&gt; navigiere ich durch ein kleines Array und √ºberpr√ºfe den Wert der inkrementierten Zelle: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  und ... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  Im letzteren Fall kann ich das Ergebnis direkt mit einem statischen Array vergleichen, indem ich ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Denken Sie daran, dass ich bereits std importiert habe.  Im folgenden Beispiel verwende ich mem.eql in diesem Namespace: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... und denken Sie daran, String-Literale, dies sind nur U8-Arrays im Zickzack, und ich kann hexadezimale Literale in sie einf√ºgen, d. h.  Der folgende Code funktioniert genauso! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  F√ºgen Sie das "." Hinzu!  Der Bytewert in der Zelle, auf die der Zeiger zeigt, wird einfach als Zeichen gedruckt.  Ich verwende jetzt warn, aber sp√§ter werde ich es durch stdout ersetzen.  Dies ist konzeptionell einfach, aber in der Implementierung etwas verwirrt.  Ich werde es sp√§ter tun! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Zyklen <br>  [und] - hier beginnt die Magie .... <br><br>  [- Wenn der Wert der aktuellen Zelle Null ist, √ºberspringen Sie die Schritte zur schlie√üenden Klammer, ohne den Code auszuf√ºhren. <br>  ] - Wenn der Wert der aktuellen Zelle nicht Null ist, kehren Sie zur √∂ffnenden Klammer zur√ºck und f√ºhren Sie den Code erneut aus. <br><br>  Dieses Mal werde ich mit einem Test beginnen, ich werde sie zusammen testen (offensichtlich macht es keinen Sinn, sie separat zu testen).  Der erste Testfall - die Speicherzelle [2] sollte leer sein, obwohl die Schleife sie erh√∂hen sollte, wenn sie startet: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  und ich werde Leerzeichen f√ºr die switch-Anweisung erstellen: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  Was ist jetzt zu tun?  Sie k√∂nnen einen naiven Ansatz verwenden.  Ich erh√∂he nur den src-Zeiger, bis ich ihn finde].  Ich kann die for-Schleife hierf√ºr jedoch nicht im Zickzack verwenden. Sie wurde nur zum Durchlaufen von Sammlungen erstellt, ohne dass deren Elemente fehlen.  Ein geeignetes Konstrukt hier ist w√§hrend: <br><br>  war: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  wurde ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Jetzt kann ich den srcptr-Zeiger in der Mitte des Blocks neu zuweisen. Ich werde dies tun: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  Dies erf√ºllt den Test "[] √ºberspringt die Codeausf√ºhrung und wird beendet" <br>  Dies erf√ºllt den Test "[] √ºberspringt die Ausf√ºhrung und beendet", obwohl er nicht ganz zuverl√§ssig ist, wie wir sehen werden. <br><br>  Was ist mit dem Schlie√üen von Klammern?  Ich glaube, es kann einfach analog geschrieben werden: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  Sie k√∂nnen sehen, was passiert ... Eine naive L√∂sung mit zwei Klammern weist einen schwerwiegenden Fehler auf und bricht in verschachtelten Schleifen vollst√§ndig ab.  Beachten Sie Folgendes: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  Das Ergebnis sollte {2, 0} sein, aber die erste offene Klammer bewegt sich einfach dumm zur ersten schlie√üenden Klammer, und alles wird chaotisch.  Sie m√ºssen zur n√§chsten schlie√üenden Klammer auf derselben Verschachtelungsebene springen.  Es ist einfach, einen Tiefenz√§hler hinzuzuf√ºgen und ihn zu verfolgen, w√§hrend Sie sich entlang der Linie vorw√§rts bewegen.  Wir machen es in beide Richtungen: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  und verwandte Tests: Beachten Sie, dass src in beiden Tests eine innere Schleife enth√§lt. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  Beachten Sie separat [-] - die Redewendung von Brainfuck, was "Null dieser Zelle" bedeutet.  Sie k√∂nnen sehen, dass es keine Rolle spielt, welchen Wert die Zelle zu Beginn hatte. Sie wird dekrementiert, bis sie 0 erreicht, und die Ausf√ºhrung wird fortgesetzt. </blockquote><br><h3>  Ungl√ºcklicher Weg </h3><br>  Ich habe nicht mit der M√∂glichkeit gerechnet, dass das Programm auf bf kaputt gehen w√ºrde.  Was passiert, wenn ich meinem Dolmetscher ein falsches Eingabeprogramm sende?  Zum Beispiel einfach [ohne schlie√üende Klammer oder &lt;, was sofort √ºber das Speicherarray hinausgeht?  (Ich kann den Speicherzeiger umbrechen, aber es ist besser, dies als Fehler zu betrachten). <br><br>  Ich werde ein wenig nach vorne schauen und alle Unterschiede im Code erkl√§ren.  Ich werde die bf-Interpreter-Funktion in eine separate Datei einf√ºgen und auch die Funktionen seekBack und seekForward in meine eigenen kleinen Funktionen einf√ºgen. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  Dies macht es meiner Meinung nach viel einfacher, den Schalter zu lesen. SearchForward und seekBack funktionieren und sehen sehr √§hnlich aus, und ich war versucht, sie in etwas intelligenteres und kompakteres umzuwandeln, aber am Ende machen sie verschiedene Dinge und behandeln Fehler auch auf verschiedene Arten.  Einfacher zu kopieren und anzupassen, so wird es klarer.  Ich werde seekForward auch sp√§ter anpassen, irgendwann, m√∂glicherweise in einem nachfolgenden Beitrag. <br><br>  Ich habe einige wichtige Dinge hinzugef√ºgt!  Beachten Sie, dass alle drei Funktionen jetzt einen Typ zur√ºckgeben! Dies ist die neue Syntax f√ºr den fr√ºheren Typ% T (Fehlerunion).  Dies bedeutet, dass die Funktion entweder einen bestimmten Typ oder einen Fehler zur√ºckgeben kann.  Wenn ich versuche, eine solche Funktion aufzurufen, muss ich entweder try verwenden, bevor ich die Funktion aufrufe, die den Fehler in den Aufrufstapel wirft, wenn der Fehler auftritt, oder catch verwenden: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  Wo ich Fehler in einem Catch-Block behandle.  Wie geschrieben, kann catch Fehler verschlucken.  Dies ist eine schlechte Praxis, aber hier l√§sst Zig uns dies explizit tun.  Wenn ich einen Fehler in einem leeren Block abfange, gebe ich an, dass ich entweder nicht glaube, dass ein Fehler auftreten kann, oder dass ich ihn nicht behandeln muss.  In der Praxis kann es so etwas wie TODO sein, und tats√§chlich ist es sehr einfach, es auch explizit zu machen! <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Denken Sie daran, dass ein solcher Fall im Produktionscode niemals auftreten wird.  Ich benachrichtige den Compiler, dass ich wei√ü, was ich tue.  Wenn ein Fehler auftreten k√∂nnte, m√ºsste ich die Fehlerbehandlung hinzuf√ºgen. <br><br>  Welche Fehler sollte ich von seekBack oder seekForward zur√ºckgeben? <br><br>  In seekBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  Ich habe den Dekrementzeiger ersetzt, um die Unterfunktion von std lib zu verwenden, die einen √úberlauffehler ausl√∂st, wenn ein √úberlauf auftritt.  Ich m√∂chte diesen Fehler abfangen und stattdessen den OutOfBounds-Fehler zur√ºckgeben, den ich hier nur mit ihm erstelle. <br><br><blockquote>  <i>Fehler Zig ist im Grunde ein Array von Fehlercodes, die vom Compiler generiert werden, wenn Sie Fehler verwenden. Eine Art Fehler.</i>  <i>Sie sind garantiert eindeutig und k√∂nnen als Werte in einem Schaltblock verwendet werden.</i> </blockquote><br>  Ich m√∂chte hier OutOfBounds verwenden, da ich semantisch, wenn der Speicherzeiger kleiner als Null wird, die Laufzeit auffordere, √ºber den von mir zugewiesenen Speicherplatz hinauszugehen. <br><br>  √§hnlich in der Funktion seekForward: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  In diesem Fall, wenn der Zeiger gr√∂√üer als src.len ist, fange ich den Fehler hier ab und gebe den gleichen Fehler zur√ºck. <br><br>  beim Anruf: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  Ich versuche diese Funktionen aufzurufen.  Wenn sie erfolgreich aufgerufen werden, werden sie korrekt ausgef√ºhrt und versuchen, srcptr zur√ºckzugeben.  Wenn sie nicht erfolgreich sind, beendet try die Funktion und gibt einen Fehler an den Ort des Aufrufs an die gesamte Funktion bf zur√ºck. <br><br>  Der Anruf kann von main sein! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  Ich schlucke diesen Fehler hier und er sollte nicht gemacht werden, aber wir werden einen wichtigen Punkt dar√ºber beachten, wie leicht Zick-Zack-Fehler den Aufrufstapel weiterleiten k√∂nnen.  Es liegt nicht in der Verantwortung der aufrufenden Funktion, jeden Fehlerfall zu √ºberpr√ºfen, aber der Compiler erzwingt den Aufruf jeder Funktion, die bei einem Versuch fehlschlagen kann.  Dies muss immer geschehen, auch wenn Fehler ignoriert werden! <br><br><blockquote>  <i>Die neue Try / Catch-Syntax eliminiert die vielen Zauberspr√ºche wie %% und%, die die Leute nicht so sehr m√∂gen.</i> </blockquote><br>  Jetzt habe ich 7 von 8 Brainfuck-Charakteren implementiert, und dies reicht aus, um ein ‚Äûaussagekr√§ftiges‚Äú Programm auszuf√ºhren. <br><br><h3>  Ein sinnvolles Programm </h3><br>  Hier ist das Programm: <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Lass uns rennen ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  voila! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>Jedes Mal, wenn ich an eine Fibonacci-Serie denke, f√§llt mir eine Erinnerung ein ... Ich habe es in den 80er Jahren im PBS-Programm (Public Broadcasting Service, ein nichtkommerzieller amerikanischer Fernsehsender) erfahren, und ich erinnere mich immer daran.</i>  <i>Ich dachte, es w√§re vergessen, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Youtube ist eine gro√üartige Sache</a> .</i> </blockquote><br><h3>  Wie kann ich das verbessern? </h3><br>  Ich habe bereits einige TODOs angedeutet.  Ich h√§tte stderr nicht f√ºr die Ausgabe verwenden sollen.  Ich m√∂chte stdout verwenden. <br><br>  Jedes Mal, wenn ich den Interpreter √∂ffne, √∂ffne ich den Stream in stdout und drucke ihn aus: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  Was ist hier los?   io.getStdOut(),     (          catch unreachable ‚Äî     ,  !).   ,    ,      ,       print. print   ,   warn,     . print    ,      . <br><br>    ,         stdout,        stdout. Zig         ,   ,    . <br><br>  ,   ,        ?              ,      ,            ?  ,        ?  , Zig  ! <br><br>     ,  ! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br>  ,  bf   ,     !void.       ,   main.          ,      : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>    ! <br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br>      ,      bf   !   ,     ,  stdout,     bf.  ,   ,       ,  try. ,   ,  ,  catch,   try,      ,       . <br><br> , : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>      ,    ,  ! <br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br> Zig       ,       !   switch   ,  ,   ,  ,     . <br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br>  -     ,  ,     ,   Zig,        !    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>   !  ! <br><br><h3> Todo </h3><br>    ,     !         , ,     ",",   brainfuck-    getc,        .            ,      bf.    ,     ,      Zig.  ,       ,           ,       . <br><br><h3>  Fazit </h3><br>  ,           ,     Zig       . Zig    ,       ,     ,  ,     ,          ++.        ,  ,   .     ,   ,   . Zig ,   ,       ,      . <br><br>         Zig,    ,      0.2.0  !  ,   ,   debug-,          ,    !   --release-fast  --release-safe,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>        Zig.     ,       1.0.0,      Zig,    ,    ,       ! <br><br> ,    #zig  freenode   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435574/">https://habr.com/ru/post/de435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435560/index.html">Erster kommerzieller Quantencomputer - IBM</a></li>
<li><a href="../de435562/index.html">Der Weg eines Rauchers: Wie man als Humanist in den Beruf eines Programmierers einsteigt</a></li>
<li><a href="../de435564/index.html">Verwenden von GtkApplication. Librsvg-Rendering-Funktionen</a></li>
<li><a href="../de435568/index.html">VyOS OpenSource Router</a></li>
<li><a href="../de435572/index.html">Anycubic i3 Mega: Qualit√§ts-Remake von Prusa i3</a></li>
<li><a href="../de435576/index.html">1C, keine Schmerzen</a></li>
<li><a href="../de435578/index.html">Weltraumspaziergang zu Weihnachten</a></li>
<li><a href="../de435580/index.html">Java, Spring, Kurento und Media Services</a></li>
<li><a href="../de435582/index.html">Wie f√ºge ich einen Index auf einem geladenen System rund um die Uhr ohne Ausfallzeiten hinzu?</a></li>
<li><a href="../de435584/index.html">Slush 2018. Erster Tag, Zweiter Tag</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>