<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîé üçß üë®üèª‚Äçüè´ Locks in PostgreSQL: 4. Locks in memory üï¶ üÜë üßìüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Biarkan saya mengingatkan Anda bahwa kita sudah berbicara tentang kunci hubungan , kunci tingkat baris , tentang kunci objek lain (termasuk yang predi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Locks in PostgreSQL: 4. Locks in memory</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/466199/">  Biarkan saya mengingatkan Anda bahwa kita sudah berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hubungan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, kunci tingkat baris</a> , tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci objek lain</a> (termasuk yang predikat), dan tentang hubungan antara berbagai jenis kunci. <br><br>  Hari ini saya mengakhiri seri ini dengan artikel tentang <strong>kunci memori</strong> .  Kami akan berbicara tentang spinlocks, kunci ringan dan kunci buffer, serta alat pemantauan dan pengambilan sampel harapan. <br><br><img src="https://habrastorage.org/webt/2y/vt/2g/2yvt2gpimbdqmnibpzaiuf8qu0q.png"><br><a name="habracut"></a><br><h1>  Putar kunci </h1><br>  Tidak seperti kunci biasa, "berat", kunci lebih ringan dan lebih murah (dalam hal overhead) digunakan untuk melindungi struktur dalam RAM bersama. <br><br>  Yang paling sederhana adalah <em>spin-lock</em> atau <em>spinlocks</em> .  Mereka dirancang untuk menangkap untuk waktu yang sangat singkat (beberapa instruksi prosesor) dan melindungi masing-masing bagian memori dari perubahan simultan. <br><br>  Spin lock diimplementasikan berdasarkan instruksi atom dari prosesor, seperti perbandingan dan pertukaran.  Mereka mendukung mode eksklusif tunggal.  Jika kunci sibuk, proses menunggu melakukan menunggu aktif - perintah diulangi ("berputar" dalam loop, maka nama itu) sampai dieksekusi dengan sukses.  Ini masuk akal, karena kunci pintal digunakan ketika probabilitas konflik diperkirakan sangat rendah. <br><br>  Spin lock tidak menyediakan deteksi kebuntuan (pengembang PostgreSQL memantau ini) dan tidak menyediakan alat pemantauan.  Pada umumnya, satu-satunya hal yang dapat kita lakukan dengan kunci pintal adalah mengetahui keberadaannya. <br><br><h1>  Kunci ringan </h1><br>  Berikutnya datang apa yang disebut <em>kunci cahaya</em> (kunci ringan, lwlocks). <br><br>  Mereka ditangkap untuk waktu yang singkat untuk bekerja dengan struktur data (misalnya, tabel hash atau daftar pointer).  Sebagai aturan, kunci cahaya tidak dipegang dalam waktu lama, tetapi dalam beberapa kasus, kunci ringan melindungi operasi I / O, sehingga pada prinsipnya, waktu dapat berubah menjadi signifikan. <br><br>  Dua mode didukung: eksklusif (untuk mengubah data) dan dibagikan (hanya baca).  Dengan demikian, tidak ada antrian tunggu: jika beberapa proses menunggu kunci dilepaskan, salah satu dari mereka akan mendapatkan akses lebih atau kurang secara acak.  Dalam sistem dengan tingkat paralelisme dan beban berat yang tinggi, ini dapat menyebabkan efek yang tidak menyenangkan (lihat, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi</a> ). <br><br>  Mekanisme untuk memeriksa kebuntuan tidak disediakan, ini tetap pada hati nurani pengembang kernel.  Namun, kunci cahaya memiliki alat pemantauan, oleh karena itu, tidak seperti kunci kunci, mereka dapat "dilihat" (beberapa saat kemudian saya akan menunjukkan caranya). <br><br><h1>  Buffer klip </h1><br>  Jenis kunci lain yang telah kita bahas dalam artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cache</a> <em>buffer</em> adalah <em>pinning buffer</em> . <br><br>  Dengan penyangga tetap, Anda dapat melakukan berbagai tindakan, termasuk mengubah data, tetapi dengan ketentuan bahwa perubahan ini tidak akan terlihat oleh proses lain karena multiversion.  Artinya, Anda dapat menambahkan baris baru ke halaman, tetapi Anda tidak dapat mengganti halaman di buffer dengan yang lain. <br><br>  Jika proses terhambat oleh pengikatan, biasanya hanya melewatkan buffer seperti itu dan memilih yang lain.  Tetapi dalam beberapa kasus, ketika penyangga khusus ini diperlukan, proses mengantri dan tertidur - sistem akan membangunkannya ketika pengancing dihapus. <br><br>  Harapan konsolidasi tersedia untuk pemantauan. <br><br><h1>  Contoh: cache buffer </h1><br><img src="https://habrastorage.org/webt/gt/z8/gy/gtz8gylhroqbvj7jmwemqbd4jys.png"><br><br>  Sekarang, untuk mendapatkan wawasan (tidak lengkap!) Tentang bagaimana dan di mana kunci digunakan, pertimbangkan contoh cache penyangga. <br><br>  Untuk mengakses tabel hash yang berisi referensi ke buffer, proses tersebut harus menangkap kunci pemetaan buffer cahaya dalam mode bersama, dan jika tabel perlu diubah, maka dalam mode luar biasa.  Untuk mengurangi rincian, kunci ini disusun sebagai <em>tahap</em> , yang terdiri dari 128 kunci terpisah, yang masing-masing melindungi bagiannya sendiri dari tabel hash. <br><br>  Proses mendapatkan akses ke header buffer menggunakan spin-lock.  Operasi individual (seperti menambah penghitung) juga dapat dilakukan tanpa kunci eksplisit menggunakan instruksi atom dari prosesor. <br><br>  Untuk membaca konten buffer, diperlukan kunci konten buffer.  Biasanya ditangkap hanya untuk waktu yang diperlukan untuk membaca pointer ke versi garis, dan kemudian perlindungan yang disediakan oleh klip buffer sudah cukup.  Untuk memodifikasi konten buffer, kunci ini harus ditangkap dalam mode luar biasa. <br><br>  Saat membaca buffer dari disk (atau menulis ke disk), IO dalam kunci progres juga ditangkap, yang menandakan proses lain bahwa halaman sedang dibaca (atau ditulis) - mereka dapat mengantri jika mereka juga perlu melakukan sesuatu dengan halaman ini. <br><br>  Pointer ke buffer gratis dan untuk korban berikutnya dilindungi oleh strategi kunci spin kunci penyangga tunggal. <br><br><h1>  Contoh: buffer log </h1><br><img src="https://habrastorage.org/webt/_f/mu/ub/_fmuubhon3hualbtorx4rmjgur4.png"><br>  Contoh lain: log buffer. <br><br>  Untuk cache jurnal, tabel hash juga digunakan yang berisi pemetaan halaman ke buffer.  Tidak seperti cache buffer, tabel hash ini dilindungi oleh satu-satunya kunci ringan WALBufMappingLock, karena ukuran cache jurnal lebih kecil (biasanya 1/32 dari cache buffer) dan akses ke buffer lebih efisien. <br><br>  Menulis halaman ke disk dilindungi oleh kunci WALWriteLock yang ringan sehingga hanya satu proses yang dapat melakukan operasi ini pada satu waktu. <br><br>  Untuk membuat entri jurnal, proses tersebut harus terlebih dahulu menyediakan ruang di halaman WAL.  Untuk melakukan ini, ia menangkap kunci posisi memasukkan kunci pengunci.  Setelah tempat dicadangkan, proses menyalin isi catatannya ke tempat yang ditunjuk.  Menyalin dapat dilakukan oleh beberapa proses pada saat yang sama, di mana catatan dilindungi oleh tranche dari 8 kunci penguncian kunci mudah (proses harus menangkap <em>salah</em> satu dari mereka). <br><br>  Gambar ini tidak menunjukkan semua kunci yang terkait dengan log prarekam, tetapi ini dan contoh sebelumnya harus memberikan beberapa gagasan tentang penggunaan kunci dalam RAM. <br><br><h1>  Pemantauan harapan </h1><br>  Dimulai dengan PostgreSQL 9.6, tunggu alat pemantauan dibangun ke tampilan pg_stat_activity.  Ketika suatu proses (sistem atau pemeliharaan) tidak dapat melakukan pekerjaannya dan sedang menunggu sesuatu, harapan ini dapat dilihat dalam tampilan: kolom wait_event_type menunjukkan jenis harapan, dan kolom wait_event menunjukkan nama harapan tertentu. <br><br>  Perlu diingat bahwa pandangan hanya menunjukkan harapan-harapan yang ditangani dengan tepat dalam kode sumber.  Jika pandangan tidak menunjukkan harapan, ini umumnya tidak berarti dengan probabilitas 100 persen bahwa prosesnya benar-benar tidak mengharapkan apa pun. <br><br>  Sayangnya, satu-satunya informasi yang tersedia tentang harapan adalah informasi <em>saat ini</em> .  Tidak ada statistik yang disimpan.  Satu-satunya cara untuk mendapatkan gambaran harapan dari waktu ke waktu adalah dengan <em>mengambil sampel</em> kondisi tampilan pada interval tertentu.  Tidak ada cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> untuk ini, tetapi Anda dapat menggunakan ekstensi, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_wait_sampling</a> . <br><br>  Penting untuk memperhitungkan sifat probabilistik dari pengambilan sampel.  Untuk mendapatkan gambar yang kurang lebih andal, jumlah pengukuran harus cukup besar.  Pengambilan sampel pada frekuensi rendah mungkin tidak memberikan gambaran yang andal, dan meningkatkan frekuensi akan menyebabkan peningkatan overhead.  Untuk alasan yang sama, pengambilan sampel tidak berguna untuk menganalisis sesi yang berumur pendek. <br><br>  Semua harapan dapat dibagi menjadi beberapa tipe. <br><br>  Harapan dari kunci yang dianggap membentuk kategori besar: <br><br><ul><li>  menunggu kunci objek (Nilai kunci di kolom wait_event_type); </li><li>  menunggu kunci ringan (LWLock); </li><li>  menunggu buffer yang disematkan (BufferPin). </li></ul><br>  Tetapi proses dapat mengharapkan peristiwa lain: <br><br><ul><li>  I / O harapan (IO) terjadi ketika suatu proses perlu menulis atau membaca data; </li><li>  proses dapat menunggu data yang diperlukan untuk bekerja dari klien (Klien) atau dari proses lain (IPC); </li><li>  ekstensi dapat mendaftarkan harapan spesifik mereka (Ekstensi). </li></ul><br>  Ada situasi ketika suatu proses sama sekali tidak melakukan pekerjaan yang bermanfaat.  Kategori ini termasuk: <br><br><ul><li>  menunggu proses latar belakang di loop utama (Aktivitas); </li><li>  menunggu penghitung waktu (Timeout). </li></ul><br>  Sebagai aturan, harapan seperti itu ‚Äúnormal‚Äù dan tidak membicarakan masalah apa pun. <br><br>  Jenis ekspektasi diikuti oleh nama ekspektasi tertentu.  Tabel lengkap dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam dokumentasi</a> . <br><br>  Jika tidak ada nama tunggu yang ditentukan, prosesnya tidak dalam kondisi menunggu.  Waktu seperti itu harus dianggap <em>tidak terhitung</em> , karena pada kenyataannya tidak diketahui apa yang sebenarnya terjadi pada saat ini. <br><br>  Namun, sudah saatnya untuk melihat. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, backend_type, wait_event_type, wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <pre> <code class="plaintext hljs"> pid | backend_type | wait_event_type | wait_event -------+------------------------------+-----------------+--------------------- 28739 | logical replication launcher | Activity | LogicalLauncherMain 28736 | autovacuum launcher | Activity | AutoVacuumMain 28963 | client backend | | 28734 | background writer | Activity | BgWriterMain 28733 | checkpointer | Activity | CheckpointerMain 28735 | walwriter | Activity | WalWriterMain (6 rows)</code> </pre><br>  Dapat dilihat bahwa semua proses layanan latar belakang "main-main." Nilai kosong di wait_event_type dan wait_event menunjukkan bahwa proses tidak mengharapkan apa pun - dalam kasus kami, proses penyajian sibuk mengeksekusi permintaan. <br><br><h2>  Sampling </h2><br>  Untuk mendapatkan gambaran ekspektasi yang kurang lebih lengkap menggunakan sampling, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_wait_sampling</a> ekstensi.  Itu harus dikompilasi dari kode sumber;  Saya akan menghilangkan bagian ini.  Kemudian kami mendaftarkan pustaka di parameter <em>shared_preload_libraries</em> dan me-restart server. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_wait_sampling'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Sekarang instal ekstensi di database. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_wait_sampling;</code> </pre><br>  Ekstensi memungkinkan Anda untuk melihat riwayat ekspektasi, yang disimpan dalam buffer melingkar.  Tetapi hal yang paling menarik adalah melihat profil harapan - statistik yang terakumulasi untuk seluruh waktu kerja. <br><br>  Inilah yang akan kita lihat dalam beberapa detik: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile;</code> </pre><pre> <code class="plaintext hljs"> pid | event_type | event | queryid | count -------+------------+---------------------+---------+------- 29074 | Activity | LogicalLauncherMain | 0 | 220 29070 | Activity | WalWriterMain | 0 | 220 29071 | Activity | AutoVacuumMain | 0 | 219 29069 | Activity | BgWriterMain | 0 | 220 29111 | Client | ClientRead | 0 | 3 29068 | Activity | CheckpointerMain | 0 | 220 (6 rows)</code> </pre><br>  Karena tidak ada yang terjadi sejak server dimulai, harapan utama adalah dari tipe Aktivitas (proses layanan menunggu pekerjaan muncul) dan Klien (psql sedang menunggu pengguna untuk mengirim permintaan). <br><br>  Dengan pengaturan default ( <em>pg_wait_sampling.profile_ Periode</em> parameter), periode sampling adalah 10 milidetik, yaitu, nilai-nilai disimpan 100 kali per detik.  Oleh karena itu, untuk memperkirakan durasi menunggu dalam detik, nilai hitungan harus dibagi 100. <br><br>  Untuk memahami apa yang menjadi harapan proses, kami menambahkan tampilan pg_stat_activity ke permintaan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+------------------------------+------+------------+----------------------+------- 29068 | checkpointer | | Activity | CheckpointerMain | 222 29069 | background writer | | Activity | BgWriterMain | 222 29070 | walwriter | | Activity | WalWriterMain | 222 29071 | autovacuum launcher | | Activity | AutoVacuumMain | 221 29074 | logical replication launcher | | Activity | LogicalLauncherMain | 222 29111 | client backend | psql | Client | ClientRead | 4 29111 | client backend | psql | IPC | MessageQueueInternal | 1 (7 rows)</code> </pre><br>  Mari memuat dengan pgbench dan melihat bagaimana gambar berubah. <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><br>  Kami mereset profil yang dikumpulkan menjadi nol dan menjalankan tes selama 30 detik dalam proses terpisah. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br>  Permintaan harus diselesaikan sebelum proses pgbench selesai: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+------------+------- 29148 | client backend | pgbench | IO | WALWrite | 8 29148 | client backend | pgbench | Client | ClientRead | 1 (2 rows)</code> </pre><br>  Tentu saja, harapan dari proses pgbench akan berubah menjadi sedikit berbeda tergantung pada sistem spesifik.  Dalam kasus kami, sangat mungkin bahwa menunggu entri log (IO / WALWrite) akan disajikan, tetapi sebagian besar waktu prosesnya tidak berhenti, tetapi melakukan sesuatu yang mungkin berguna. <br><br><h2>  Kunci ringan </h2><br>  Anda harus selalu ingat bahwa tidak adanya harapan ketika pengambilan sampel tidak berarti bahwa tidak ada harapan.  Jika lebih pendek dari periode sampling (seperseratus detik dalam contoh kami), maka itu tidak bisa jatuh ke dalam sampel. <br><br>  Oleh karena itu, kunci cahaya tidak muncul di profil - tetapi mereka akan muncul jika Anda mengumpulkan data untuk waktu yang lama.  Untuk menjamin melihatnya, Anda dapat memperlambat sistem file secara artifisial, misalnya, gunakan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slowfs yang</a> dibangun pada sistem file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FUSE</a> . <br><br>  Inilah yang dapat kita lihat dalam pengujian yang sama jika operasi I / O membutuhkan waktu 1/10 detik. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+----------------+------- 29240 | client backend | pgbench | IO | WALWrite | 1445 29240 | client backend | pgbench | LWLock | WALWriteLock | 803 29240 | client backend | pgbench | IO | DataFileExtend | 20 (3 rows)</code> </pre><br>  Sekarang, harapan utama dari proses pgbench terkait dengan I / O, atau lebih tepatnya, entri log yang dieksekusi dalam mode sinkron dengan setiap komit.  Karena (seperti yang ditunjukkan pada contoh di atas), menulis log ke disk dilindungi oleh kunci WALWriteLock yang ringan, kunci ini juga ada di profil - ini persis seperti yang ingin kami lihat. <br><br><h2>  Buffer klip </h2><br>  Untuk melihat pin dari buffer, kami mengambil keuntungan dari fakta bahwa kursor terbuka menahan pin sehingga membaca baris berikutnya lebih cepat. <br><br>  Kami memulai transaksi, buka kursor dan pilih satu baris. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgbench_history; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> tid | bid | aid | delta | mtime | filler -----+-----+-------+-------+----------------------------+-------- 9 | 1 | 35092 | 477 | 2019-09-04 16:16:18.596564 | (1 row)</code> </pre><br>  Periksa apakah buffer disematkan (pinning_backends): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relforknumber = <span class="hljs-number"><span class="hljs-number">0</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------ bufferid | 190 relfilenode | 47050 reltablespace | 1663 reldatabase | 16386 relforknumber | 0 relblocknumber | 0 isdirty | t usagecount | 1 pinning_backends | 1 &lt;--   1 </code> </pre><br>  Sekarang kita akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghapus</a> tabel: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 29367 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><pre> <code class="plaintext hljs">| INFO: vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 0 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 1 page due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. | VACUUM</code> </pre><br>  Seperti yang dapat kita lihat, halaman dilewati (Melewati 1 halaman karena pin penyangga).  Memang, pembersihan tidak dapat mengatasinya, karena dilarang untuk menghapus versi baris secara fisik dari halaman dalam buffer yang disematkan.  Tetapi pembersihan tidak akan menunggu - halaman akan diproses lain kali. <br><br>  Dan sekarang kita akan melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembersihan dengan pembekuan</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><br>  Dengan pembekuan yang diminta dengan jelas, Anda tidak dapat melewati satu halaman yang tidak ditandai di peta pembekuan - jika tidak, tidak mungkin untuk mengurangi usia maksimum transaksi yang tidak dibekukan di pg_class.relfrozenxid.  Oleh karena itu, pembersihan terhenti hingga kursor ditutup. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 27 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre><br><pre> <code class="plaintext hljs">| INFO: aggressively vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 26 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 0 pages due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 3.01 s. | VACUUM</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 0 (1 row)</code> </pre><br>  Baiklah, mari kita lihat profil ekspektasi dari sesi psql kedua di mana perintah VACUUM dijalankan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.pid = <span class="hljs-number"><span class="hljs-number">29367</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+------+------------+------------+------- 29367 | client backend | psql | BufferPin | BufferPin | 294 29367 | client backend | psql | Client | ClientRead | 10 (2 rows)</code> </pre><br>  Tipe menunggu BufferPin menunjukkan bahwa flush sedang menunggu buffer dibebaskan. <br><br>  Dalam hal ini kami akan menganggap bahwa kami telah menyelesaikan kunci.  Terima kasih atas perhatian dan komentar Anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466199/">https://habr.com/ru/post/id466199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466187/index.html">Editor logika visual untuk Unity3d. Bagian 2</a></li>
<li><a href="../id466191/index.html">Hal utama tentang pertempuran untuk netralitas jaringan di AS adalah kronologi peristiwa dan keadaan saat ini</a></li>
<li><a href="../id466193/index.html">Umpan otomatis MailChimp kustom dari umpan RSS</a></li>
<li><a href="../id466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../id466197/index.html">PVS-Studio 7.04</a></li>
<li><a href="../id466201/index.html">Bagaimana meninggalkan ilmu pengetahuan di bidang TI dan menjadi penguji: sejarah satu karier</a></li>
<li><a href="../id466203/index.html">Hari Techdir di St. Petersburg. Bir, pizza, dua mikrofon</a></li>
<li><a href="../id466211/index.html">Project Mainline di Android 10</a></li>
<li><a href="../id466213/index.html">4 langkah untuk membuat profil kandidat</a></li>
<li><a href="../id466215/index.html">Desain berorientasi model. Pembuatan model yang andal, menggunakan contoh penukar panas penerbangan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>