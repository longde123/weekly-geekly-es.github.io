<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèΩ üßëüèº‚Äçü§ù‚Äçüßëüèª üÜö Bloqueios no PostgreSQL: 1. Bloqueios de relacionamento üìØ üí§ üòó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As duas s√©ries anteriores de artigos se concentraram no isolamento, no multiversionismo e no di√°rio . 

 Nesta s√©rie, falaremos sobre bloqueios. Vou a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bloqueios no PostgreSQL: 1. Bloqueios de relacionamento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/462877/">  As duas s√©ries anteriores de artigos se concentraram no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isolamento,</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multiversionismo</a> e no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">di√°rio</a> . <br><br>  Nesta s√©rie, falaremos sobre bloqueios.  Vou aderir a esse termo, mas na literatura tamb√©m pode haver outro: <em>castelo</em> . <br><br>  O ciclo consistir√° em quatro partes: <br><br><ol><li>  Bloqueios de relacionamento (este artigo); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloqueios de linha</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fechaduras de outros objetos</a> e fechaduras predicadas; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloqueios na RAM</a> . </li></ol><br>  O material de todos os artigos √© baseado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cursos de treinamento</a> administrativo que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">pluzanov</a> e eu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">fazemos</a> , mas n√£o os repetimos literalmente e s√£o destinados a uma leitura atenta e a experimenta√ß√µes independentes. <br><br><img src="https://habrastorage.org/webt/rx/jt/bz/rxjtbz_s6otkhbwcm6agmmtldxe.png"><br><br><h1>  Informa√ß√µes gerais sobre bloqueios </h1><br>  O PostgreSQL usa muitos mecanismos diferentes que s√£o usados ‚Äã‚Äãpara bloquear algo (ou pelo menos s√£o chamados assim).  Portanto, come√ßarei com as palavras mais gerais sobre por que os bloqueios s√£o necess√°rios, o que s√£o e como diferem um do outro.  Depois, veremos o que √© encontrado nessa variedade no PostgreSQL e somente depois disso come√ßaremos a lidar com diferentes tipos de bloqueios em detalhes. <br><a name="habracut"></a><br>  Bloqueios s√£o usados ‚Äã‚Äãpara otimizar o acesso simult√¢neo a recursos compartilhados. <br><br>  Acesso competitivo refere-se ao acesso simult√¢neo de v√°rios processos.  Os processos em si podem ser executados em paralelo (se o equipamento permitir) e sequencialmente no modo de compartilhamento de tempo - isso n√£o √© importante. <br><br>  Se n√£o houver concorr√™ncia, n√£o haver√° necessidade de bloqueios (por exemplo, um cache de buffer compartilhado exige bloqueios, mas um local n√£o). <br><br>  Antes de acessar um recurso, um processo deve adquirir o bloqueio associado a esse recurso.  Ou seja, estamos falando de uma certa disciplina: tudo funciona desde que todos os processos cumpram as regras estabelecidas para acessar um recurso compartilhado.  Se o DBMS gerencia os bloqueios, ele pr√≥prio monitora o pedido;  se o bloqueio √© definido pelo aplicativo, essa obriga√ß√£o recai sobre ele. <br><br>  Em um n√≠vel baixo, um bloqueio √© representado por uma se√ß√£o da mem√≥ria compartilhada, na qual √© observado de alguma forma se o bloqueio est√° livre ou capturado (e, possivelmente, informa√ß√µes adicionais s√£o registradas: n√∫mero do processo, tempo de captura etc.). <br><br><blockquote>  Voc√™ pode perceber que esse peda√ßo de mem√≥ria compartilhada √©, por si s√≥, um recurso ao qual o acesso competitivo √© poss√≠vel.  Se descermos um n√≠vel abaixo, veremos que primitivas acess√≥rios especiais (como sem√°foros ou mutexes) fornecidas pelo sistema operacional s√£o usadas para organizar o acesso.  Seu significado √© que o c√≥digo que acessa o recurso compartilhado deve ser executado em apenas um processo por vez.  No n√≠vel mais baixo, essas primitivas s√£o implementadas com base nas instru√ß√µes do processador at√¥mico (como testar e configurar ou comparar e trocar). <br></blockquote><br>  Depois que o recurso n√£o √© mais necess√°rio pelo processo, ele <em>libera o</em> bloqueio para que outras pessoas possam us√°-lo. <br><br>  Obviamente, nem sempre √© poss√≠vel bloquear o bloqueio: o recurso j√° pode ser usado por outra pessoa.  Em seguida, o processo entra na fila de espera (se o mecanismo de bloqueio oferecer essa oportunidade) ou tenta novamente para capturar o bloqueio ap√≥s um certo tempo.  De uma forma ou de outra, isso leva ao fato de que o processo √© for√ßado a ficar ocioso aguardando a libera√ß√£o do recurso. <br><br><blockquote>  √Äs vezes √© poss√≠vel aplicar outras estrat√©gias n√£o bloqueadoras.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o mecanismo de multi-</a> vers√£o permite que v√°rios processos, em alguns casos, trabalhem simultaneamente com diferentes vers√µes de dados sem bloquear um ao outro. <br></blockquote><br>  Em princ√≠pio, um recurso protegido pode ser qualquer coisa, se apenas esse recurso puder ser identificado sem ambiguidade e corresponder a um endere√ßo de bloqueio. <br><br>  Por exemplo, o recurso pode ser o objeto com o qual o DBMS est√° trabalhando, como uma p√°gina de dados (identificada pelo nome e posi√ß√£o do arquivo), uma tabela (oid no diret√≥rio do sistema), uma linha da tabela (p√°gina e deslocamento dentro da p√°gina).  Um recurso pode ser uma estrutura na mem√≥ria, como uma tabela de hash, buffer etc. (identificado por um n√∫mero pr√©-atribu√≠do).  √Äs vezes, √© at√© conveniente usar recursos abstratos que n√£o t√™m nenhum significado f√≠sico (eles s√£o identificados simplesmente por um n√∫mero √∫nico). <br><br>  A efic√°cia dos bloqueios √© influenciada por muitos fatores, dos quais distinguimos dois. <br><br><ul><li>  <strong>A granularidade</strong> (granularidade) √© importante se os recursos formarem uma hierarquia. <br><br>  Por exemplo, uma tabela consiste em p√°ginas que cont√™m linhas da tabela.  Todos esses objetos podem atuar como recursos.  Se os processos geralmente estiverem interessados ‚Äã‚Äãem apenas algumas linhas e o bloqueio estiver definido no n√≠vel da tabela, outros processos n√£o poder√£o trabalhar com linhas diferentes ao mesmo tempo.  Portanto, quanto maior a granularidade, melhor a possibilidade de paraleliza√ß√£o. <br><br>  Mas isso leva a um aumento no n√∫mero de bloqueios (informa√ß√µes sobre quais devem ser armazenadas na mem√≥ria).  Nesse caso, um <em>aumento no n√≠vel</em> (escalonamento) de bloqueios pode ser aplicado: quando o n√∫mero de bloqueios granulares de n√≠vel inferior exceder um determinado limite, eles ser√£o substitu√≠dos por um bloqueio de n√≠vel superior. <br></li><li>  Os bloqueios podem ser capturados em diferentes <strong>modos</strong> . <br><br>  Os nomes dos modos podem ser absolutamente arbitr√°rios, apenas a matriz de sua compatibilidade √© importante.  Um modo incompat√≠vel com qualquer modo (incluindo ele pr√≥prio) geralmente √© chamado de <em>exclusivo</em> ou exclusivo.  Se os modos forem compat√≠veis, o bloqueio poder√° ser capturado por v√°rios processos simultaneamente;  esses modos s√£o chamados de compartilhados.  Em geral, quanto mais modos diferentes compat√≠veis entre si puderem ser distinguidos, mais oportunidades s√£o criadas para o paralelismo. <br></li></ul><br>  De acordo com o tempo de uso, os bloqueios podem ser divididos em longos e curtos. <br><br><ul><li>  <strong>Os</strong> bloqueios de <strong>longo prazo</strong> s√£o capturados por um per√≠odo potencialmente longo (geralmente at√© o final da transa√ß√£o) e geralmente est√£o relacionados a recursos como tabelas (relacionamentos) e linhas.  O PostgreSQL normalmente gerencia esses bloqueios automaticamente, mas o usu√°rio ainda tem algum controle sobre esse processo. <br><br>  Os bloqueios longos s√£o caracterizados por um grande n√∫mero de modos, para que o maior n√∫mero poss√≠vel de a√ß√µes simult√¢neas possa ser executado nos dados.  Normalmente, para esses bloqueios, existe uma infraestrutura desenvolvida (por exemplo, suporte de filas de espera e detec√ß√£o de conflitos) e ferramentas de monitoramento, uma vez que os custos de manuten√ß√£o de todas essas comodidades ainda s√£o incomparavelmente mais baixos em compara√ß√£o ao custo das opera√ß√µes em dados protegidos. <br></li><li>  Bloqueios de <strong>curto prazo</strong> s√£o capturados por um curto per√≠odo de tempo (de algumas instru√ß√µes do processador a fra√ß√µes de segundo) e geralmente se referem a estruturas de dados na mem√≥ria compartilhada.  O PostgreSQL gerencia esses bloqueios completamente automaticamente - voc√™ s√≥ precisa saber sobre a exist√™ncia deles. <br><br>  Os bloqueios curtos s√£o caracterizados por um m√≠nimo de modos (exclusivos e compartilhados) e uma infraestrutura simples.  Em alguns casos, mesmo as ferramentas de monitoramento podem n√£o estar dispon√≠veis. <br></li></ul><br>  O PostgreSQL usa diferentes tipos de bloqueios. <br><br>  <strong>Bloqueios no n√≠vel do objeto</strong> s√£o <strong>bloqueios</strong> "pesados" de longo prazo.  Os recursos aqui s√£o rela√ß√µes e outros objetos.  Se a palavra bloqueio aparecer no texto sem esclarecimentos, isso significa apenas um bloqueio "normal". <br><br>  Entre os bloqueios de longo prazo, os bloqueios <strong>no n√≠vel da linha</strong> se destacam separadamente.  Sua implementa√ß√£o difere de outros bloqueios de longo prazo devido ao seu n√∫mero potencialmente grande (imagine atualizar um milh√£o de linhas em uma transa√ß√£o).  Esses bloqueios ser√£o discutidos no pr√≥ximo artigo. <br><br>  O terceiro artigo da s√©rie ser√° dedicado aos bloqueios restantes no n√≠vel do objeto, bem como aos <strong>bloqueios predicados</strong> (uma vez que as informa√ß√µes sobre todos esses bloqueios s√£o armazenadas na RAM da mesma maneira). <br><br>  Bloqueios curtos incluem v√°rios <strong>bloqueios de estruturas de RAM</strong> .  Vamos consider√°-los no √∫ltimo artigo do ciclo. <br><br><h1>  Bloqueios de objeto </h1><br>  Ent√£o, come√ßamos com bloqueios no n√≠vel do objeto.  Aqui, um objeto √© entendido em primeiro lugar como <em>rela√ß√µes</em> , isto √©, tabelas, √≠ndices, sequ√™ncias, representa√ß√µes materializadas, mas tamb√©m algumas outras entidades.  Esses bloqueios geralmente protegem os objetos de serem alterados ao mesmo tempo ou de serem usados ‚Äã‚Äãenquanto o objeto est√° sendo alterado, mas tamb√©m para outras necessidades. <br><br>  Reda√ß√£o emba√ßada?  √â porque os bloqueios desse grupo s√£o usados ‚Äã‚Äãpara uma variedade de prop√≥sitos.  O que os une √© como eles s√£o organizados. <br><br><h2>  Dispositivo </h2><br>  Os bloqueios de objetos est√£o localizados na mem√≥ria compartilhada do servidor.  Seu n√∫mero √© limitado pelo produto dos valores de dois par√¢metros: <em>max_locks_per_transaction</em> √ó <em>max_connections</em> . <br><br>  O conjunto de bloqueios √© comum a todas as transa√ß√µes, ou seja, uma transa√ß√£o pode capturar mais bloqueios que <em>max_locks_per_transaction</em> : √© importante apenas que o n√∫mero total de bloqueios no sistema n√£o exceda o limite definido.  O pool √© criado na inicializa√ß√£o, portanto, alterar uma das duas op√ß√µes indicadas requer uma reinicializa√ß√£o do servidor. <br><br>  Todos os bloqueios podem ser visualizados na visualiza√ß√£o pg_locks. <br><br>  Se um recurso j√° estiver bloqueado no modo incompat√≠vel, uma transa√ß√£o que tenta captur√°-lo √© colocada na fila e aguarda a libera√ß√£o do bloqueio.  As transa√ß√µes pendentes n√£o consomem recursos do processador: os processos de servi√ßo correspondentes ‚Äúadormecem‚Äù e s√£o ativados pelo sistema operacional quando o recurso √© liberado. <br><br>  √â poss√≠vel uma situa√ß√£o de <em>deadlock</em> ou <em>deadlock</em> , em que uma transa√ß√£o requer que um recurso ocupado pela segunda transa√ß√£o continue e a segunda requer um recurso ocupado pela primeira (no caso geral, um deadlock e mais de duas transa√ß√µes podem ocorrer).  Nesse caso, a espera continuar√° indefinidamente, portanto o PostgreSQL detecta automaticamente essas situa√ß√µes e anula uma das transa√ß√µes para que outras pessoas possam continuar trabalhando.  (Falaremos mais sobre impasses no pr√≥ximo artigo.) <br><br><h2>  Tipos de Objetos </h2><br>  Aqui est√° uma lista dos tipos de bloqueios (ou, se voc√™ preferir, os tipos de objetos) com os quais trataremos neste e no pr√≥ximo artigo.  Os nomes s√£o dados de acordo com a coluna locktype da visualiza√ß√£o pg_locks. <br><br><ul><li>  <strong>rela√ß√£o</strong> <br><br>  Bloqueios de relacionamento. <br></li><li>  <strong>transactionid</strong> e <strong>virtualxid</strong> <br><br>  Bloqueando um n√∫mero de transa√ß√£o (real ou virtual).  Cada transa√ß√£o possui um bloqueio exclusivo de seu pr√≥prio n√∫mero, portanto, √© conveniente usar esses bloqueios quando voc√™ precisar esperar at√© o final de outra transa√ß√£o. <br></li><li>  <strong>tupla</strong> <br><br>  Bloqueio de vers√£o de cadeia.  √â usado em alguns casos para definir a prioridade entre v√°rias transa√ß√µes que esperam bloquear a mesma linha. <br></li></ul><br>  Adiaremos a discuss√£o dos demais tipos de bloqueios at√© o terceiro artigo do ciclo.  Todos eles s√£o capturados apenas no modo excepcional ou em exclusivo e compartilhado. <br><br><ul><li>  <strong>estender</strong> <br><br>  Usado ao adicionar p√°ginas a um arquivo de qualquer relacionamento. <br></li><li>  <strong>objeto</strong> <br><br>  Bloquear objetos que n√£o s√£o relacionamentos (bancos de dados, esquemas, assinaturas etc.). <br></li><li>  <strong>p√°gina</strong> <br><br>  O bloqueio de p√°gina √© usado com pouca frequ√™ncia e apenas por alguns tipos de √≠ndices. <br></li><li>  <strong>consultivo</strong> <br><br>  Bloqueio recomendado, definido manualmente pelo usu√°rio. <br></li></ul><br><h1>  Bloqueios de relacionamento </h1><br>  Para n√£o perder o contexto, vou marcar nessa imagem os tipos de bloqueios, que ser√£o discutidos mais adiante. <br><br><img src="https://habrastorage.org/webt/od/wc/ne/odwcnenfvjv_ikwmqw8x-vaexqi.png"><br><br><h2>  Modos </h2><br>  Se n√£o √© o mais importante, certamente as rela√ß√µes de bloqueio e bloqueio mais ‚Äúramificadas‚Äù.  Para ela, s√£o definidos at√© 8 modos diferentes.  Essa quantidade √© necess√°ria para que o maior n√∫mero poss√≠vel de instru√ß√µes pertencentes a uma tabela possa ser executado simultaneamente. <br><br>  N√£o faz sentido aprender esses modos de cor ou tentar entender o significado de seus nomes;  o principal √© ter uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">matriz</a> na frente dos olhos no momento certo, que mostra quais bloqueios entram em conflito entre si.  Por conveni√™ncia, √© reproduzido aqui, juntamente com exemplos de comandos que requerem n√≠veis de bloqueio apropriados: <br><br><div class="scrollable-table"><table><tbody><tr><th>  modo de bloqueio </th><th>  Como </th><th>  RS </th><th>  RE </th><th>  SUE </th><th>  S </th><th>  SRE </th><th>  E </th><th>  Ae </th><th>  <nobr>comandos SQL de</nobr> amostra </th></tr><tr><td>  Partilha de acesso </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  SELECT </td></tr><tr><td>  Compartilhamento de linha </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  SELECIONE PARA ATUALIZA√á√ÉO / COMPARTILHAR </td></tr><tr><td>  Linha exclusiva </td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  INSERIR, ATUALIZAR, EXCLUIR </td></tr><tr><td>  Compartilhar atualiza√ß√£o exclusiva </td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  V√ÅCUO, ALTER TABLE <sup>*</sup> , CRIAR √çNDICE DE FORMA CONCORRENTE </td></tr><tr><td>  Compartilhar </td><td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  CRIAR √çNDICE </td></tr><tr><td>  Compartilhar linha exclusiva </td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  CRIAR TRIGGER, ALTER TABLE <sup>*</sup> </td></tr><tr><td>  Exclusivo </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  REFRESH MAT.  VER CONCORRENTE </td></tr><tr><td>  Acesso exclusivo </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  QUEDA, TRUNCA√á√ÉO, V√ÅCUO CHEIO, MESA DE FECHAMENTO, ALTER TABLE <sup>*</sup> , MATERIAL DE REFRESH  VER </td></tr></tbody></table></div><br>  Alguns coment√°rios: <br><br><ul><li>  Os primeiros 4 modos permitem altera√ß√µes simult√¢neas de dados na tabela, e os pr√≥ximos 4 n√£o. </li><li>  O primeiro modo (acesso compartilhado) √© o mais fraco, √© compat√≠vel com outro que n√£o o anterior (acesso exclusivo).  Este √∫ltimo modo √© exclusivo, n√£o √© compat√≠vel com nenhum modo. </li><li>  O comando ALTER TABLE possui muitas op√ß√µes, diferentes das quais requerem diferentes n√≠veis de bloqueio.  Portanto, na matriz, esse comando aparece em linhas diferentes e √© marcado com um asterisco. </li></ul><br><h2>  Por exemplo, por exemplo </h2><br>  d√™ um exemplo.  O que acontece se eu executar o comando CREATE INDEX? <br><br>  Encontramos na documenta√ß√£o que este comando define o bloqueio no modo Compartilhar.  De acordo com a matriz, determinamos que o comando √© compat√≠vel consigo mesmo (ou seja, voc√™ pode criar v√°rios √≠ndices simultaneamente) e com os comandos de leitura.  Portanto, os comandos SELECT continuar√£o funcionando, mas os comandos UPDATE, DELETE, INSERT ser√£o bloqueados. <br><br>  E vice-versa - transa√ß√µes incompletas que modificam dados na tabela bloquear√£o a opera√ß√£o do comando CREATE INDEX.  Portanto, h√° uma variante do comando - CREATE INDEX CONCURRENTLY.  Ele funciona por mais tempo (e pode at√© cair com um erro), mas permite altera√ß√µes simult√¢neas de dados. <br><br>  Isso pode ser visto na pr√°tica.  Para experimentos, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a</a> tabela de contas "banc√°rias" conhecidas desde o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro ciclo</a> , na qual armazenaremos o n√∫mero e o valor da conta. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>);</code> </pre> <br>  Na segunda sess√£o, inicie a transa√ß√£o.  Precisamos de um n√∫mero de processo de servi√ßo. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 4746 | (1 row)</code> </pre><br>  Quais bloqueios mant√©m a transa√ß√£o rec√©m-iniciada?  N√≥s olhamos em pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4746</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 5/15 | | ExclusiveLock | t (1 row)</code> </pre><br>  Como eu j√° disse, uma transa√ß√£o sempre mant√©m um bloqueio exclusivo (ExclusiveLock) de seu pr√≥prio n√∫mero, nesse caso, um virtual.  N√£o h√° outros bloqueios nesse processo. <br><br>  Agora atualize a linha da tabela.  Como a situa√ß√£o mudar√°? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ---------------+---------------+---------+--------+------------------+--------- relation | accounts_pkey | | | RowExclusiveLock | t relation | accounts | | | RowExclusiveLock | t virtualxid | | 5/15 | | ExclusiveLock | t transactionid | | | 529404 | ExclusiveLock | t (4 rows)</code> </pre><br>  Agora, existem bloqueios na tabela e no √≠ndice mut√°veis ‚Äã‚Äã(criados para a chave prim√°ria), que s√£o usados ‚Äã‚Äãpelo comando UPDATE.  Ambos os bloqueios s√£o obtidos no modo RowExclusiveLock.  Al√©m disso, foi adicionado um bloqueio exclusivo do n√∫mero real da transa√ß√£o (que apareceu assim que a transa√ß√£o come√ßou a alterar os dados). <br><br>  Agora, em outra sess√£o, tentaremos criar um √≠ndice em uma tabela. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| pg_backend_pid || ---------------- || 4782 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(acc_no);</code> </pre><br>  O comando congela em antecipa√ß√£o √† libera√ß√£o do recurso.  Que tipo de bloqueio ela est√° tentando capturar?  Verifique: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4782</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 6/15 | | ExclusiveLock | t relation | accounts | | | ShareLock | f (2 rows)</code> </pre><br>  Vemos que a transa√ß√£o est√° tentando obter o bloqueio da tabela no modo ShareLock, mas n√£o pode (concedido = f). <br><br>  √â conveniente encontrar o n√∫mero do processo de bloqueio e, em geral, v√°rios n√∫meros, usando a fun√ß√£o que apareceu na vers√£o 9.6 (antes disso eu tinha que tirar conclus√µes examinando cuidadosamente todo o conte√∫do de pg_locks): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_blocking_pids ------------------ {4746} (1 row)</code> </pre><br>  E ent√£o, para entender a situa√ß√£o, voc√™ pode obter informa√ß√µes sobre as sess√µes, incluindo os n√∫meros encontrados: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>(pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------------------------------------------------------------ datid | 16386 datname | test pid | 4746 usesysid | 16384 usename | student application_name | psql client_addr | client_hostname | client_port | -1 backend_start | 2019-08-07 15:02:53.811842+03 xact_start | 2019-08-07 15:02:54.090672+03 query_start | 2019-08-07 15:02:54.10621+03 state_change | 2019-08-07 15:02:54.106965+03 wait_event_type | Client wait_event | ClientRead state | idle in transaction backend_xid | 529404 backend_xmin | query | UPDATE accounts SET amount = amount + 100 WHERE acc_no = 1; backend_type | client backend</code> </pre><br>  Depois que a transa√ß√£o √© conclu√≠da, os bloqueios s√£o liberados e o √≠ndice √© criado. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| CREATE INDEX</code> </pre><br><h2>  Na fila! .. </h2><br>  Para melhor imaginar o que a apar√™ncia de um bloqueio incompat√≠vel leva, veremos o que acontece se o comando VACUUM FULL for executado durante a opera√ß√£o do sistema. <br><br>  Deixe o comando SELECT ser executado primeiro em nossa tabela.  Ela recebe um bloqueio no n√≠vel mais fraco do Access Share.  Para controlar o tempo de libera√ß√£o do bloqueio, executamos este comando dentro da transa√ß√£o - at√© que a transa√ß√£o termine, o bloqueio n√£o ser√° liberado.  Na realidade, v√°rios comandos podem ler (e modificar) a tabela e algumas das consultas podem demorar um pouco. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+--------- 2 | 2000.00 3 | 3000.00 1 | 1100.00 (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+-----------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} (1 row)</code> </pre><br>  Em seguida, o administrador executa o comando VACUUM FULL, que requer um bloqueio de n√≠vel exclusivo do Access, incompat√≠vel com qualquer coisa, mesmo com o compartilhamento de acesso.  (O comando LOCK TABLE tamb√©m requer o mesmo bloqueio.) As filas de transa√ß√µes. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  VACUUM FULL</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} (2 rows)</code> </pre><br>  Mas o aplicativo continua emitindo solicita√ß√µes e agora o comando SELECT aparece no sistema.  Teoricamente, ela poderia ter "escorregado" enquanto o VACUUM FULL est√° esperando, mas n√£o - ela honestamente ocupa um lugar na fila do VACUUM FULL. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} relation | AccessShareLock | f | 4782 | {4746} (3 rows)</code> </pre><br>  Depois que a primeira transa√ß√£o com o comando SELECT √© conclu√≠da e libera o bloqueio, o comando VACUUM FULL √© iniciado (que simulamos com o comando LOCK TABLE). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br><pre> <code class="plaintext hljs">| LOCK TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessExclusiveLock | t | 4746 | {} relation | AccessShareLock | f | 4782 | {4746} (2 rows)</code> </pre><br>  E somente ap√≥s o VACUUM FULL concluir seu trabalho e remover o bloqueio, todos os comandos acumulados na fila (SELECT em nosso exemplo) poder√£o capturar os bloqueios correspondentes (compartilhamento de acesso) e executar. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| acc_no | amount || --------+--------- || 2 | 2000.00 || 3 | 3000.00 || 1 | 1100.00 || (3 rows)</code> </pre><br>  Assim, um comando impreciso pode paralisar a opera√ß√£o do sistema por um tempo significativamente maior que o tempo de execu√ß√£o do pr√≥prio comando. <br><br><h1>  Ferramentas de monitoramento </h1><br>  Obviamente, os bloqueios s√£o necess√°rios para a opera√ß√£o correta, mas podem levar a expectativas indesej√°veis.  Tais expectativas podem ser monitoradas para entender sua causa e, se poss√≠vel, elimin√°-las (por exemplo, alterando o algoritmo do aplicativo). <br><br>  J√° nos familiarizamos com um m√©todo: no momento de um bloqueio longo, podemos executar uma solicita√ß√£o para a visualiza√ß√£o pg_locks, examinar as transa√ß√µes bloque√°veis ‚Äã‚Äãe de bloqueio (fun√ß√£o pg_blocking_pids) e descriptograf√°-las usando pg_stat_activity. <br><br>  Outra maneira √© ativar o par√¢metro <em>log_lock_waits</em> .  Nesse caso, as informa√ß√µes aparecer√£o no log de mensagens do servidor se a transa√ß√£o estiver aguardando mais do que <em>deadlock_timeout</em> (apesar do fato de o par√¢metro para deadlocks ser usado, estamos falando de expectativas normais). <br><br>  Vamos tentar. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_lock_waits = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  O valor padr√£o do par√¢metro <em>deadlock_timeout</em> √© de um segundo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> deadlock_timeout;</code> </pre><pre> <code class="plaintext hljs"> deadlock_timeout ------------------ 1s (1 row)</code> </pre><br>  Toque a fechadura. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  O segundo comando UPDATE espera um bloqueio.  Aguarde um segundo e conclua a primeira transa√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br>  Agora a segunda transa√ß√£o pode ser conclu√≠da. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br>  E toda a informa√ß√£o importante entrou no di√°rio: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.827 MSK [5898] student@test LOG: process 5898 still waiting for ShareLock on transaction 529427 after 1000.186 ms 2019-08-07 15:26:30.827 MSK [5898] student@test DETAIL: Process holding the lock: 5862. Wait queue: 5898. 2019-08-07 15:26:30.827 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.827 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.836 MSK [5898] student@test LOG: process 5898 acquired ShareLock on transaction 529427 after 1009.536 ms 2019-08-07 15:26:30.836 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.836 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462877/">https://habr.com/ru/post/pt462877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462859/index.html">Como uma empresa de √¥nibus europ√©ia opera na R√∫ssia: como os √¥nibus e os passageiros diferem</a></li>
<li><a href="../pt462863/index.html">21 de agosto transmitiu o Zabbix Moscow Meetup # 5</a></li>
<li><a href="../pt462867/index.html">Escolhendo um esquema de cores para seu aplicativo: como simplificar?</a></li>
<li><a href="../pt462869/index.html">Sistema Agilean de Gerenciamento de Projetos</a></li>
<li><a href="../pt462875/index.html">Como reduzir custos e fornecer suporte de TI ideal para o modelo de neg√≥cios. Estamos procurando o "caminho do meio da salva√ß√£o"</a></li>
<li><a href="../pt462879/index.html">Slurm DevOps: do Git ao SRE com todas as paradas</a></li>
<li><a href="../pt462881/index.html">Por que √© t√£o dif√≠cil escolher qual filme assistir (e o que poderia ser feito)</a></li>
<li><a href="../pt462883/index.html">Projetando uma loja on-line para SEO: (teoria + lista de verifica√ß√£o)</a></li>
<li><a href="../pt462885/index.html">Rede IPoE tolerante a falhas em m√£os</a></li>
<li><a href="../pt462887/index.html">A experi√™ncia de personalizar uma loja online usando o exemplo de uma recomenda√ß√£o din√¢mica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>