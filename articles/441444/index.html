<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÉ ‚ôèÔ∏è ‚ö´Ô∏è En los dedos: tipos asociados en Rust y cu√°l es su diferencia con los argumentos de tipo üéöÔ∏è üî™ üö≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øPor qu√© Rust tiene tipos asociados y cu√°l es la diferencia entre ellos y los argumentos de tipo, tambi√©n conocidos como gen√©ricos, porque son muy sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>En los dedos: tipos asociados en Rust y cu√°l es su diferencia con los argumentos de tipo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441444/"><p>  ¬øPor qu√© Rust tiene tipos asociados y cu√°l es la diferencia entre ellos y los argumentos de tipo, tambi√©n conocidos como gen√©ricos, porque son muy similares?  ¬øNo es suficiente lo √∫ltimo, como en todos los idiomas normales?  Para aquellos que reci√©n est√°n comenzando a aprender Rust, y especialmente para las personas que vienen de otros idiomas ("¬°Esto es gen√©rico!", Dir√° el javista, sabio durante a√±os), esta pregunta surge regularmente.  Vamos a hacerlo bien. </p><br><p>  TL; DR El primero controla el c√≥digo llamado, el segundo la persona que llama. </p><a name="habracut"></a><br><h3 id="dzheneriki-vs-associirovannye-tipy">  Gen√©ricos vs tipos asociados </h3><br><p>  Entonces, ya tenemos argumentos de tipo, o los gen√©ricos favoritos de todos.  Se parece a esto: </p><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: T); }</code> </pre> <br><p>  Aqu√≠ <code>T</code> es precisamente el argumento tipo.  Parece que esto deber√≠a ser suficiente para todos (como 640 kilobytes de memoria).  Pero en Rust, tambi√©n hay tipos asociados, algo como esto: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    fn bar(self, x: Self::Bar); }</span></span></code> </pre> <br><p>  A primera vista, los mismos huevos, pero desde un √°ngulo diferente.  ¬øPor qu√© necesitabas introducir otra entidad en el idioma?  (Que, por cierto, no estaba en las primeras versiones del lenguaje). </p><br><p>  Los argumentos de tipo son exactamente <strong><em>argumentos</em></strong> , esto significa que se pasan al rasgo en el lugar de la llamada, y el control sobre qu√© tipo se utilizar√° en lugar de <code>T</code> pertenece a la persona que llama.  Incluso si no especificamos expl√≠citamente <code>T</code> en la ubicaci√≥n de la llamada, el compilador lo har√° por nosotros mediante la inferencia de tipos.  Es decir, impl√≠citamente, de todos modos, este tipo se inferir√° en la persona que llama y se pasar√° como un argumento.  (Por supuesto, todo esto sucede durante la compilaci√≥n, no en tiempo de ejecuci√≥n). </p><br><p>  Considera un ejemplo.  La biblioteca est√°ndar tiene un <code>AsRef</code> AsRef, que permite que un tipo finja ser otro tipo por un tiempo, convirtiendo un enlace en s√≠ mismo en un enlace a otra cosa.  Simplificado, este rasgo se ve as√≠ (en realidad, es un poco m√°s complicado, intencionalmente elimin√© todo lo innecesario, dejando solo el m√≠nimo necesario para la comprensi√≥n): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsRef</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;T; }</code> </pre> <br><p>  Aqu√≠ el llamador pasa el tipo <code>T</code> como argumento, incluso si sucede impl√≠citamente (si el compilador le infiere este tipo).  En otras palabras, es la persona que llama quien decide qu√© nuevo tipo <code>T</code> pretender√° ser nuestro tipo el que implementa este rasgo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar: &amp;Bar = foo.as_ref();</code> </pre> <br><p>  Aqu√≠, el compilador, utilizando el conocimiento de <code>bar: &amp;Bar</code> , utilizar√° la <code>AsRef&lt;Bar&gt;</code> para llamar al m√©todo <code>as_ref()</code> , porque es el tipo de <code>Bar</code> que necesita el llamante.  No hace falta decir que el tipo <code>Foo</code> debe implementar el rasgo AsRef <code>AsRef&lt;Bar&gt;</code> , y adem√°s de esto, puede implementar tantas otras <code>AsRef&lt;T&gt;</code> , entre las cuales la persona que llama selecciona la deseada. </p><br><p>  En el caso del tipo asociado, todo es exactamente lo contrario.  El tipo asociado est√° completamente controlado por quienes implementan este rasgo, y no por la persona que llama. </p><br><p>  Un ejemplo com√∫n es un iterador.  Supongamos que tenemos una colecci√≥n y queremos obtener un iterador de ella.  ¬øQu√© tipo de valores debe devolver el iterador?  ¬°Exactamente el contenido en esta colecci√≥n!  No corresponde a la persona que llama decidir qu√© devolver√° el iterador, y el iterador mismo sabe mejor <em>qu√©</em> sabe <em>exactamente</em> c√≥mo devolver.  Aqu√≠ est√° el c√≥digo abreviado de la biblioteca est√°ndar: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;; }</code> </pre> <br><p>  Tenga en cuenta que el iterador no tiene un par√°metro de tipo que le permita a la persona que llama elegir qu√© debe devolver el iterador.  En cambio, el tipo del valor devuelto por el m√©todo <code>next()</code> lo determina el iterador mismo usando el tipo asociado, pero no est√° atascado con clavos, es decir.  cada implementaci√≥n de iterador puede elegir su tipo. </p><br><p>  Para  ¬øY qu√©?  De todos modos, no est√° claro por qu√© esto es mejor que un gen√©rico.  Imagine por un momento que usamos el gen√©rico habitual en lugar del tipo asociado.  El rasgo del iterador se ver√° as√≠: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericIterator</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;; }</code> </pre> <br><p>  Pero ahora, en primer lugar, el tipo <code>T</code> debe indicarse una y otra vez en cada lugar donde se menciona el iterador, y en segundo lugar, ahora es posible implementar este rasgo varias veces con diferentes tipos, lo que para el iterador parece algo extra√±o.  Aqu√≠ hay un ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIterator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIterator; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lolwhat: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;_&gt; = iter.next(); <span class="hljs-comment"><span class="hljs-comment">// Error! Which impl of GenericIterator to use? }</span></span></code> </pre> <br><p>  ¬øVes la captura?  No podemos simplemente tomarlo y llamarlo <code>iter.next()</code> sin sentadillas: debemos informar al compilador, expl√≠cita o impl√≠citamente, qu√© tipo se devolver√°.  Y parece inc√≥modo: ¬øpor qu√© deber√≠amos, en el lado de la llamada, saber (y decirle al compilador!) El tipo que devolver√° el iterador, mientras que este iterador deber√≠a saber mejor qu√© tipo devuelve.  Y todo porque pudimos implementar el <code>GenericIterator</code> GenericIterator dos veces con un par√°metro diferente para el mismo <code>MyIterator</code> , que desde el punto de vista de la sem√°ntica del iterador tambi√©n parece rid√≠culo: ¬øpor qu√© el mismo iterador puede devolver valores de diferentes tipos? </p><br><p>  Si volvemos a la variante con el tipo asociado, entonces se pueden evitar todos estos problemas: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIter</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIter { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIter; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = iter.next(); }</code> </pre> <br><p>  Aqu√≠, en primer lugar, el compilador generar√° correctamente el <code>value: Option&lt;String&gt;</code> tipo sin palabras innecesarias, y en segundo lugar, no funcionar√° para implementar el <code>MyIter</code> para <code>MyIter</code> por segunda vez con un tipo de retorno diferente, y as√≠ arruinar todo. </p><br><p>  Para la fijaci√≥n  Una colecci√≥n puede implementar dicho rasgo para poder convertirse en un iterador: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIter</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item=Self::Item&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into_iter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::IntoIter; }</code> </pre> <br><p>  Y de nuevo, aqu√≠ es la colecci√≥n la que decide qu√© iterador ser√°, a saber: un iterador cuyo tipo de retorno coincide con el tipo de elementos en la colecci√≥n en s√≠, y ning√∫n otro. </p><br><h3 id="eschyo-bolee-na-palcah">  M√°s en los dedos </h3><br><p>  Si los ejemplos anteriores siguen siendo incomprensibles, entonces aqu√≠ hay una explicaci√≥n a√∫n menos cient√≠fica pero m√°s inteligible.  Los argumentos de tipo se pueden considerar como informaci√≥n de "entrada" que proporcionamos para que el rasgo funcione.  Los tipos asociados se pueden considerar como informaci√≥n de "salida" que el rasgo nos proporciona para que podamos usar los resultados de su trabajo. </p><br><p>  La biblioteca est√°ndar tiene la capacidad de sobrecargar operadores matem√°ticos para sus tipos (suma, resta, multiplicaci√≥n, divisi√≥n y similares).  Para hacer esto, debe implementar uno de los rasgos correspondientes de la biblioteca est√°ndar.  Aqu√≠, por ejemplo, c√≥mo este rasgo busca la operaci√≥n de suma (nuevamente, simplificado): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span></span>&lt;RHS&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: RHS) -&gt; Self::Output; }</code> </pre> <br><p>  Aqu√≠ tenemos el argumento <code>RHS</code> "entrada": este es el tipo al que aplicaremos la operaci√≥n de suma con nuestro tipo.  Y hay un argumento de "salida" <code>Add::Output</code> : este es el tipo que resultar√° de la adici√≥n.  En el caso general, puede diferir del tipo de t√©rminos, que, a su vez, tambi√©n pueden ser de diferentes tipos (agregue sabroso al azul y se ablande, pero qu√©, hago esto todo el tiempo).  El primero se especifica usando el argumento type, el segundo se especifica usando el tipo asociado. </p><br><p>  Puede implementar cualquier cantidad de adiciones con diferentes tipos del segundo argumento, pero cada vez solo habr√° un tipo de resultado, y est√° determinado por la implementaci√≥n de esta adici√≥n. </p><br><p>  Intentemos implementar este rasgo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>); <span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Bar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; Bar { Bar(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, rhs) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = Foo(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      &lt;Foo as Add&gt;::add(42)  x assert_eq!(y, Bar("test", 42)); }</span></span></code> </pre> <br><p>  En este ejemplo, el tipo de la variable <code>y</code> est√° determinado por el algoritmo de adici√≥n, no por el c√≥digo de llamada.  Ser√≠a muy extra√±o si fuera posible escribir algo como <code>let y: Baz = x + 42</code> , es decir, forzar la operaci√≥n de suma para devolver un resultado de alg√∫n tipo extra√±o.  Es de tales cosas que el tipo asociado <code>Add::Output</code> nos asegura. </p><br><h3 id="itogo">  Total </h3><br><p>  Usamos gen√©ricos donde no nos importa tener implementaciones de rasgos m√∫ltiples para el mismo tipo, y donde es aceptable especificar una implementaci√≥n espec√≠fica en el lado de la llamada.  Usamos tipos asociados donde queremos tener una implementaci√≥n "can√≥nica", que controla los tipos.  Combina y mezcla en las proporciones correctas, como en el √∫ltimo ejemplo. </p><br><p>  ¬øFall√≥ la moneda?  M√°tame con comentarios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441444/">https://habr.com/ru/post/441444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441428/index.html">Conceptos b√°sicos de PowerShell: definici√≥n del final de una l√≠nea con un car√°cter espec√≠fico</a></li>
<li><a href="../441430/index.html">La primera vez que probamos App Center y contamos nuestra experiencia</a></li>
<li><a href="../441436/index.html">Los cient√≠ficos han cultivado c√©lulas madre universales utilizando ingenier√≠a CRISPR</a></li>
<li><a href="../441438/index.html">Servicios unificados goszakup.gov.kz - Versi√≥n 2</a></li>
<li><a href="../441442/index.html">YouTube ha deshabilitado los anuncios antivacunas</a></li>
<li><a href="../441446/index.html">Aprendiendo a la computadora: c√≥mo adquirir una nueva habilidad</a></li>
<li><a href="../441448/index.html">Imposible pan y otros azulejos de Penrose gana</a></li>
<li><a href="../441450/index.html">Pentesting Azure: pensamientos sobre seguridad en la computaci√≥n en la nube</a></li>
<li><a href="../441452/index.html">Tres extensiones reactivas zen</a></li>
<li><a href="../441454/index.html">NASA advierte a SpaceX y Boeing sobre fallas en naves espaciales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>