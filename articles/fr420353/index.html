<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕧 🎐 🎥 Nous rendons Shrimp encore plus utile: ajoutez le transcodage d'images à d'autres formats 🥉 👩‍💻 🎹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis début 2017, notre petite équipe développe la bibliothèque RESTinio OpenSource pour embarquer un serveur HTTP dans des applications C ++. À notr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous rendons Shrimp encore plus utile: ajoutez le transcodage d'images à d'autres formats</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420353/"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br>  Depuis début 2017, notre petite équipe développe la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque RESTinio OpenSource</a> pour embarquer un serveur HTTP dans des applications C ++.  À notre grande surprise, nous recevons de temps en temps des questions de la catégorie «Et pourquoi un serveur HTTP C ++ intégré pourrait-il être nécessaire?»  Malheureusement, les questions simples sont les plus difficiles à répondre.  Parfois, la meilleure réponse est un exemple de code. <br><br>  Il y a quelques mois, nous avons lancé un petit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet de démonstration, Shrimp</a> , qui illustre clairement un scénario typique, dans lequel notre bibliothèque est «affûtée».  Le projet de démonstration est un simple service Web qui reçoit des demandes de mise à l'échelle des images stockées sur le serveur et qui renvoie une image de la taille dont l'utilisateur a besoin. <br><br>  Ce projet de démonstration est bon dans la mesure où, premièrement, il nécessite une intégration avec du code écrit et fonctionnant correctement en C ou C ++ (dans ce cas, ImageMagick).  Par conséquent, il devrait être clair pourquoi il est judicieux d'incorporer le serveur HTTP dans une application C ++. <br><br>  Et deuxièmement, dans ce cas, le traitement des demandes asynchrones est nécessaire pour que le serveur HTTP ne se bloque pas pendant la mise à l'échelle de l'image (et cela peut prendre des centaines de millisecondes ou même des secondes).  Et nous avons commencé le développement de RESTinio précisément parce que nous ne pouvions pas trouver un serveur embarqué sain C ++ axé spécifiquement sur le traitement des demandes asynchrones. <br><br>  Nous avons construit le travail sur Shrimp de manière itérative: d'abord, la version la plus simple a été faite et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrite</a> , qui ne faisait que redimensionner les images.  Ensuite, nous avons corrigé un certain nombre de lacunes de la première version et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrit cela dans le deuxième article</a> .  Enfin, nous nous sommes déplacés pour étendre encore une fois la fonctionnalité de Shrimp: la conversion d'images d'un format à un autre a été ajoutée.  Comment cela a été fait et sera discuté dans cet article. <br><a name="habracut"></a><br><h1>  Prise en charge du format cible </h1><br>  Ainsi, dans la prochaine version de Shrimp, nous avons ajouté la possibilité de donner une image à l'échelle dans un format différent.  Donc, si vous émettez une demande de crevettes du formulaire: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  puis Shrimp rendra l'image au même format JPG que l'image originale. <br><br>  Mais si vous ajoutez le paramètre de format cible à l'URL, Shrimp convertit l'image au format cible spécifié.  Par exemple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br>  Dans ce cas, Shrimp rendra l'image au format webp. <br><br>  Shrimp mis à jour prend en charge cinq formats d'image: jpg, png, gif, webp et heic (également connu sous le nom de HEIF).  Vous pouvez expérimenter différents formats <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur une page Web spéciale</a> : <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  (sur cette page, il n'y a aucun moyen de sélectionner le format heic, car les navigateurs de bureau ordinaires ne prennent pas en charge ce format par défaut). <br><br>  Afin de prendre en charge le format cible dans Shrimp, il a été nécessaire de modifier légèrement le code Shrimp (ce qui nous a surpris nous-mêmes, car il y avait vraiment peu de changements).  Mais d'un autre côté, j'ai dû jouer avec l'assemblage d'ImageMagick, ce qui nous a encore plus surpris, comme  Plus tôt, nous avons dû composer avec cette cuisine, par un heureux hasard.  Mais parlons de tout dans l'ordre. <br><br><h2>  ImageMagick doit comprendre différents formats </h2><br>  ImageMagick utilise des bibliothèques externes pour encoder / décoder les images: libjpeg, libpng, libgif, etc.  Ces bibliothèques doivent être installées sur le système avant que ImageMagick ne soit configuré et construit. <br><br>  La même chose devrait se produire pour qu'ImageMagick prenne en charge les formats webp et heic: vous devez d'abord construire et installer libwebp et libheif, puis configurer et installer ImageMagick.  Et si tout est simple avec libwebp, alors autour de libheif j'ai du danser avec un tambourin.  Bien qu'après un certain temps, après que tout se soit enfin réuni et ait fonctionné, ce n'était déjà pas clair: pourquoi avez-vous dû recourir à un tambourin, tout semble être trivial?  ;) <br><br>  En général, si quelqu'un veut se lier d'amitié avec heic et ImageMagick, vous devrez installer: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">x265 de videolan.org</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libde265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libheif</a> </li></ul><br>  C'est dans cet ordre (vous devrez peut-être installer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nasm</a> pour que x265 fonctionne à la vitesse maximale).  Ensuite, lors de l' <i>exécution de la</i> commande <i>./configure</i> , ImageMagick pourra trouver tout ce dont il a besoin pour prendre en charge les fichiers .heic. <br><br><h2>  Prise en charge du format cible dans la chaîne de requête des demandes entrantes </h2><br>  Après avoir fait des amis ImageMagick avec les formats webp et heic, il est temps de modifier le code Shrimp.  Tout d'abord, nous devons apprendre à reconnaître l'argument de format cible dans les requêtes HTTP entrantes. <br><br>  Du point de vue de RESTinio, ce n'est pas du tout un problème.  Eh bien, un autre argument est apparu dans la chaîne de requête, alors quoi?  Mais du point de vue de Shrimp, la situation s'est avérée être un peu plus compliquée, donc le code de la fonction qui était responsable de l'analyse de la requête HTTP était compliqué. <br><br>  Le fait est qu'avant il fallait distinguer seulement deux situations: <br><br><ul><li>  est venu une demande de la forme "/filename.ext" sans aucun autre paramètre.  Il vous suffit donc de donner le fichier "filename.ext" tel quel; </li><li>  Une demande est arrivée sous la forme "/filename.ext?op=resize &amp; ...".  Dans ce cas, vous devez redimensionner l'image à partir du fichier "filename.ext". </li></ul><br>  Mais après avoir ajouté le format cible, nous devons distinguer quatre situations: <br><br><ul><li>  est venu une demande de la forme "/filename.ext" sans aucun autre paramètre.  Il vous suffit donc de donner le fichier "filename.ext" tel quel, sans mise à l'échelle et sans transcodage vers un autre format; </li><li>  est venu une demande du formulaire "/filename.ext?target-format=fmt" sans aucun autre paramètre.  Cela signifie prendre une image du fichier "filename.ext" et la transcoder au format "fmt" tout en conservant les tailles originales; </li><li>  une demande est venue de la forme "/filename.ext?op=resize &amp; ..." mais sans format cible.  Dans ce cas, vous devez redimensionner l'image à partir du fichier «filename.ext» et la donner au format d'origine; </li><li>  Une demande est venue du formulaire "/filename.ext?op=resize&amp;...&amp;target-format=fmt".  Dans ce cas, vous devez effectuer une mise à l'échelle, puis transcoder le résultat au format «fmt». </li></ul><br>  Par conséquent, la fonction de détermination des paramètres de requête a pris la <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">forme suivante</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Dans la version précédente de Shrimp, où vous n'aviez pas besoin de transcoder l'image, travailler avec les paramètres de requête <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">semblait un peu plus facile</a> . <br><br><h2>  File d'attente de demande et cache d'images adaptés au format cible </h2><br>  Le point suivant dans l'implémentation de la prise en charge du format cible a été le travail sur la file d'attente des demandes en attente et un cache d'images prêtes à l'emploi dans l'agent a_transform_manager.  Nous avons parlé de ces choses plus en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans l'article précédent</a> , mais rappelons-nous un peu de quoi il s'agissait. <br><br>  Lorsqu'une demande de conversion d'image arrive, il peut s'avérer que l'image finie avec de tels paramètres est déjà dans le cache.  Dans ce cas, vous n'avez rien à faire, envoyez simplement l'image du cache en réponse.  Si l'image doit être transformée, il peut s'avérer qu'il n'y a pas de travailleurs libres pour le moment et vous devez attendre qu'elle apparaisse.  Pour ce faire, les informations de demande doivent être mises en file d'attente.  Mais en même temps, il est nécessaire de vérifier l'unicité des demandes - si nous avons trois demandes identiques en attente de traitement (c'est-à-dire que nous devons convertir la même image de la même manière), nous ne devons traiter l'image qu'une seule fois et donner le résultat du traitement en réponse à ces trois demandes.  C'est-à-dire  Dans la file d'attente, des demandes identiques doivent être regroupées. <br><br>  Plus tôt dans Shrimp, nous avons utilisé une simple clé composite pour rechercher le cache d'image et la file d'attente: une <a href="">combinaison du nom de fichier d'origine + des options de redimensionnement de l'image</a> .  Maintenant, deux nouveaux facteurs devaient être pris en compte: <br><br><ul><li>  premièrement, le format d'image cible (c'est-à-dire que l'image originale peut être en jpg, et l'image résultante peut être en png); </li><li>  deuxièmement, le fait que la mise à l'échelle de l'image ne soit pas nécessairement nécessaire.  Cela se produit dans une situation où le client commande uniquement la conversion de l'image d'un format à un autre, mais avec la taille d'origine de l'image préservée. </li></ul><br>  Je dois dire qu'ici nous avons emprunté le chemin le plus simple, sans chercher à optimiser quoi que ce soit.  Par exemple, on pourrait essayer de créer deux caches: l'un stockerait les images au format d'origine, mais à l'échelle à la taille souhaitée, et dans le second, les images à l'échelle seraient converties au format cible. <br><br>  Pourquoi une telle double mise en cache serait-elle nécessaire?  Le fait est que lors de la transformation d'images, les deux opérations les plus coûteuses en temps sont le redimensionnement et la sérialisation de l'image au format cible.  Par conséquent, si nous recevions une demande de mise à l'échelle de l'image example.jpg à une taille de 1920 en largeur et de la transformer au format webp, nous pourrions stocker deux images dans notre mémoire: example_1920px_width.jpg et example_1920px_width.webp.  Nous donnerions une image example_1920px_width.webp lorsque nous recevions une deuxième demande.  Mais l'image example_1920px_width.jpg pourrait être utilisée lors de la réception de demandes de mise à l'échelle d'exemple.jpg à une taille de 1920 en largeur et de sa transformation au format heic.  Nous pourrions ignorer l'opération de redimensionnement et faire uniquement la conversion de format (c'est-à-dire que l'image finie example_1920px_width.jpg serait transcodée au format heic). <br><br>  Autre opportunité potentielle: lorsqu'une demande vient de transcoder une image dans un autre format sans redimensionnement, vous pouvez déterminer la taille réelle de l'image et utiliser cette taille à l'intérieur de la clé composite.  Par exemple, laissez example.jpg avoir une taille de 3000x2000 pixels.  Si nous recevons ensuite une demande de mise à l'échelle d'exemple.jpg à 2000 px de hauteur, nous pouvons immédiatement déterminer que nous avons déjà une image de cette taille. <br><br>  En théorie, toutes ces considérations méritent notre attention.  Mais d'un point de vue pratique, il n'est pas clair à quel point la probabilité d'une telle évolution des événements est élevée.  C'est-à-dire  à quelle fréquence recevrons-nous une demande de mise à l'échelle d'exemple.jpg en 1920px avec conversion en webp, puis une demande de mise à l'échelle de la même image, mais avec conversion en png?  Il est difficile de dire qu'il n'y a pas de statistiques réelles.  Par conséquent, nous avons décidé de ne pas compliquer nos vies dans notre projet de démonstration, mais de suivre d'abord le chemin le plus simple.  Dans l'espoir que si quelqu'un a besoin de schémas de mise en cache plus avancés, cela peut être ajouté plus tard, à partir de scénarios réels et non fictifs pour l'utilisation de Shrimp. <br><br>  En conséquence, dans la version mise à jour de Shrimp, nous avons légèrement développé la clé, en y ajoutant également un paramètre tel que le format cible: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br>  C'est-à-dire  demande de redimensionnement example.jpg jusqu'à 1920px avec conversion en png diffère du même redimensionnement, mais avec conversion en webp ou heic. <br><br>  Mais l'objectif principal se cache <a href="">dans la nouvelle implémentation de la classe resize_params_t</a> , qui détermine les nouvelles tailles de l'image mise à l'échelle.  <a href="">Auparavant, cette classe prend en</a> charge trois options: seule la largeur est définie, seule la hauteur est définie ou le côté long est défini (la hauteur ou la largeur est déterminée par la taille actuelle de l'image).  En conséquence, la <a href="">méthode resize_params_t :: value () a</a> toujours renvoyé une valeur réelle (quelle valeur a été déterminée par la <a href="">méthode resize_params_t :: mode ()</a> ). <br><br>  Mais dans le nouveau Shrimp, un autre mode a été ajouté - keep_original, ce qui signifie que la mise à l'échelle n'est pas effectuée et que l'image est rendue dans sa taille d'origine.  Pour prendre en charge ce mode, resize_params_t a dû apporter quelques modifications.  Tout d'abord, la <a href="">méthode resize_params_t :: make ()</a> détermine maintenant si le mode keep_original est utilisé (on considère que ce mode est utilisé si aucun des paramètres width, height et max dans la chaîne de requête de la requête entrante n'est spécifié).  Cela nous a permis de ne pas réécrire la fonction <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request ()</a> , qui pousse la demande de mise à l'échelle de l'image à exécuter. <br><br>  Deuxièmement, la <a href="">méthode resize_params_t :: value ()</a> peut désormais être appelée pas toujours, mais uniquement lorsque le mode de mise à l'échelle diffère de keep_original. <br><br>  Mais le plus important est que <a href="">resize_params_t :: operator &lt;() a</a> continué de fonctionner comme prévu. <br><br>  Grâce à toutes ces modifications dans a_transform_manager, le cache d'image mis à l'échelle et la file d'attente des demandes en attente sont restés les mêmes.  Mais maintenant, des informations sur diverses requêtes sont stockées dans ces structures de données.  Ainsi, la clé {"example.jpg", "jpg", keep_original} différera à la fois de la clé {"example.jpg", "png", keep_original} et de la clé {"example.jpg", "jpg", width = 1920 px}. <br><br>  Il s'est avéré qu'après avoir un peu gâché la définition de structures de données simples telles que resize_params_t et resize_params_key_t, nous avons évité de modifier des structures plus complexes telles que le cache des images résultantes et la file d'attente des demandes en attente. <br><br><h2>  Prise en charge du format cible dans a_transformer </h2><br>  Eh bien, la dernière étape de la prise en charge du format cible consiste à étendre la logique de l'agent a_transformer afin que l'image, éventuellement déjà mise à l'échelle, soit ensuite convertie au format cible. <br><br>  Cela s'est avéré être le plus facile à faire, tout ce qui était nécessaire était d'étendre le code de la <a href="">méthode a_transform_t :: handle_resize_request ()</a> : <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br>  Par rapport <a href="">à la version précédente,</a> il existe deux ajouts fondamentaux. <br><br>  Tout d'abord, appeler la méthode image.magick () vraiment magique après le redimensionnement.  Cette méthode indique à ImageMagick le format d'image résultant.  Dans le même temps, la représentation de l'image dans la mémoire ne change pas - ImageMagick continue de la stocker à sa guise.  Mais alors la valeur définie par la méthode magick () sera prise en compte lors de l'appel suivant à Image :: write (). <br><br>  Deuxièmement, la version mise à jour enregistre le temps nécessaire pour sérialiser l'image au format spécifié.  La nouvelle version de Shrimp fixe désormais séparément le temps consacré à la mise à l'échelle et le temps consacré à la conversion au format cible. <br><br>  Le reste de l'agent a_transformer_t n'a subi aucune modification. <br><br><h1>  Parallélisation d'ImageMagick </h1><br>  Par défaut, ImageMagic est construit avec le support OpenMP.  C'est-à-dire  il est possible de paralléliser les opérations sur les images qu'ImageMagick effectue.  Vous pouvez contrôler le nombre de workflows qu'ImageMagick utilise dans ce cas à l'aide de la variable d'environnement MAGICK_THREAD_LIMIT. <br><br>  Par exemple, sur ma machine de test avec la valeur MAGICK_THREAD_LIMIT = 1 (c'est-à-dire sans réelle parallélisation), j'obtiens les résultats suivants: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br>  Le temps consacré au redimensionnement est indiqué dans l'en-tête Shrimp-Resize-Time.  Dans ce cas, elle est de 1086,72 ms. <br><br>  Mais si vous définissez MAGICK_THREAD_LIMIT = 3 sur la même machine et exécutez Shrimp, alors nous obtenons des valeurs différentes: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br>  C'est-à-dire  le temps de redimensionnement a été réduit à 558,25 ms. <br><br>  Par conséquent, comme ImageMagick offre la possibilité de paralléliser les calculs, vous pouvez utiliser cette opportunité.  Mais en même temps, il est souhaitable de pouvoir contrôler le nombre de threads de travail que Shrimp prend pour lui-même.  Dans les versions précédentes de Shrimp, il n'était pas possible d'influencer le nombre de flux de travail créés par Shrimp.  Et dans la version mise à jour de Shrimp, cela peut être fait.  Ou via des variables d'environnement, par exemple: <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br>  Ou via des arguments de ligne de commande, par exemple: <br><br><pre> <code class="hljs powershell">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-literal"><span class="hljs-literal">-i</span></span> ... -<span class="hljs-literal"><span class="hljs-literal">-io</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-literal"><span class="hljs-literal">-worker</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Les valeurs spécifiées via la ligne de commande ont une priorité plus élevée. <br><br>  Il convient de souligner que MAGICK_THREAD_LIMIT affecte uniquement les opérations qu'ImageMagick effectue lui-même.  Par exemple, le redimensionnement est effectué par ImageMagick.  Mais la conversion d'un format à un autre ImageMagick délègue aux bibliothèques externes.  Et comment les opérations dans ces bibliothèques externes sont parallélisées est un problème distinct que nous n'avons pas compris. <br><br><h1>  Conclusion </h1><br>  Peut-être, dans cette version de Shrimp, nous avons amené notre projet de démonstration à un état acceptable.  Ceux qui veulent voir et expérimenter peuvent trouver les textes sources de Shrimp sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BitBucket</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Vous pouvez également y trouver le Dockerfile pour construire des crevettes pour vos expériences. <br><br>  En général, nous avons atteint nos objectifs que nous nous sommes fixés en démarrant ce projet de démonstration.  Un certain nombre d'idées sont apparues pour le développement ultérieur de RESTinio et de SObjectizer, et certaines d'entre elles ont déjà trouvé leur mode de réalisation.  Par conséquent, si les crevettes se développeront ailleurs, cela dépend complètement des questions et des souhaits.  S'il y en a, alors les crevettes peuvent se développer.  Sinon, Shrimp restera un projet de démonstration et un terrain d'entraînement pour expérimenter de nouvelles versions de RESTinio et SObjectizer. <br><br>  En conclusion, je voudrais remercier tout particulièrement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">aensidhe</a> pour leur aide et leurs conseils, sans lesquels nos danses au tambourin seraient bien plus longues et tristes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420353/">https://habr.com/ru/post/fr420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420343/index.html">Lampes LED OK</a></li>
<li><a href="../fr420345/index.html">Présentation du centre de données IXcellerate (la plus grande salle des machines de la Fédération de Russie)</a></li>
<li><a href="../fr420347/index.html">Apprenez à créer vos propres commandes bash en moins de 4 minutes</a></li>
<li><a href="../fr420349/index.html">Liste de contrôle pour l'externalisation informatique: travailler sans risques</a></li>
<li><a href="../fr420351/index.html">Comment faire des recherches d'utilisateurs sur GitHub en utilisant Vue</a></li>
<li><a href="../fr420355/index.html">Montre intelligente Pebble: comment devenir une rareté du jour au lendemain</a></li>
<li><a href="../fr420357/index.html">Vuex: structurer de grands projets et travailler avec des modules</a></li>
<li><a href="../fr420359/index.html">Var, let ou const? Problèmes de portée variable et ES6</a></li>
<li><a href="../fr420361/index.html">Bogue lors de l'exécution de TextBox.GetLineText dans .NET WPF</a></li>
<li><a href="../fr420363/index.html">Webinaires HPE en août-octobre: ​​nouveaux sujets (+ SHD, pratique de l'IA, stockage clé en main de pétaoctets)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>