<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ­ ğŸ¨ ğŸ¦‹ MIT-Kurs "Computer Systems Security". Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ, Teil 2 â™ï¸ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸ‘¨ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die VortrÃ¤ge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefÃ¤hrden, und Sicherheitstechniken, die auf jÃ¼ngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehÃ¶ren Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: â€EinfÃ¼hrung: Bedrohungsmodelleâ€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Wir haben also einen Puffer, Ã¼ber den wir den â€Kanarienvogelâ€œ legen.  DarÃ¼ber befindet sich der gespeicherte <b>EBP-</b> Wert des gespeicherten Haltepunktzeigers und die RÃ¼cksprungadresse wird darÃ¼ber platziert.  Wenn Sie sich erinnern, geht der Ãœberlauf von unten nach oben. Bevor Sie also zur Absenderadresse gelangen, wird zuerst der "Kanarienvogel" zerstÃ¶rt. <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>Teilnehmerin:</b> Warum wirkt sich das auf den "Kanarienvogel" aus? <br><br>  <b>Professor:</b> Weil angenommen wird, dass der Angreifer nicht weiÃŸ, wie er willkÃ¼rlich in das GedÃ¤chtnis â€springenâ€œ soll.  HerkÃ¶mmliche SpeicherÃ¼berlaufangriffe beginnen mit einem Hacker, der die PuffergrÃ¶ÃŸenbeschrÃ¤nkung untersucht. Danach beginnt der Ãœberlauf unter dem Strich.  Aber Sie haben Recht - wenn ein Angreifer direkt in die Absenderadressleiste gelangen kann, hilft uns kein â€Kanarienvogelâ€œ.  Bei einem herkÃ¶mmlichen PufferÃ¼berlaufangriff sollte jedoch alles genau so ablaufen - von unten nach oben. <br><br>  Die Hauptidee bei der Verwendung eines â€Kanarienvogelsâ€œ ist daher, dass ein bÃ¶swilliger Exploit den Speicherpuffer Ã¼berlaufen lÃ¤sst.  Wir haben einen Laufzeitcode, der bei der RÃ¼ckkehr von einer Funktion den "Kanarienvogel" Ã¼berprÃ¼ft, um sicherzustellen, dass er den richtigen Wert hat. <br><br>  <b>Zielgruppe:</b> Kann ein Angreifer die Absenderadresse umschreiben und den â€Kanarienvogelâ€œ Ã¤ndern?  Wie kann er Ã¼berprÃ¼fen, ob es geÃ¤ndert wurde, aber weiterhin seine Funktion erfÃ¼llt? <br><br>  <b>Professor:</b> Ja, vielleicht.  Daher sollten Sie einen Code haben, der dies tatsÃ¤chlich Ã¼berprÃ¼ft, bevor die Funktion zurÃ¼ckkehrt.  Das heiÃŸt, in diesem Fall ist die UnterstÃ¼tzung eines Compilers erforderlich, der die <b>Aufrufkonvention</b> tatsÃ¤chlich <b>aufruft</b> .  Dieser Teil der RÃ¼ckgabesequenz erfolgt also, bevor wir die GÃ¼ltigkeit dieses Werts prÃ¼fen, um sicherzustellen, dass der â€Kanarienvogelâ€œ nicht zerstÃ¶rt wurde.  Erst danach kÃ¶nnen wir Ã¼ber etwas anderes nachdenken. <br><br>  <b>Teilnehmerin:</b> Kann ein Angreifer nicht wissen oder erraten, was "Kanarienvogel" bedeutet? <br><br>  <b>Professor:</b> Genau darÃ¼ber werde ich sprechen!  Was ist das Problem mit dieser Schaltung?  Was ist, wenn wir zum Beispiel den Wert A in jedes Programm setzen?  Oder ein ganzer Zweig von 4 Werten von A?  NatÃ¼rlich kann jeder Hacker die GrÃ¶ÃŸe des Puffers und seine KapazitÃ¤t herausfinden und so die Position des "Kanarienvogels" in jedem System bestimmen.  Daher kÃ¶nnen wir verschiedene Arten von Mengen verwenden, die wir in unseren â€Kanarienvogelâ€œ geben, um dies zu verhindern. <br><br>  Eines kÃ¶nnen Sie mit unserem â€Kanarienvogelâ€œ tun.  Es wird eine sehr lustige Art von "Kanarienvogel" sein, die C-Programmfunktionen verwendet und Sonderzeichen verarbeitet, die sogenannte deterministische Art von "Kanarienvogel". <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Stellen Sie sich vor, Sie haben das Zeichen 0 fÃ¼r den â€Kanarienvogelâ€œ verwendet. Der BinÃ¤rwert Null ist das Nullbyte, das Nullzeichen in ASCII.  Ein Wert von -1 bedeutet eine RÃ¼ckkehr zur vorherigen Position und so weiter.  Viele Funktionen stoppen oder Ã¤ndern den Betrieb, wenn sie auf Zeichen oder Werte wie 0, CR, LF, -1 stoÃŸen.  Stellen Sie sich vor, Sie als Hacker verwenden eine String-Verwaltungsfunktion, um den Puffer zu erhÃ¶hen, treffen auf das Zeichen 0 im "Kanarienvogel" und der Prozess stoppt!  Wenn Sie die Funktion â€WagenrÃ¼cklaufâ€œ -1 verwenden, die hÃ¤ufig als Zeilenabschluss verwendet wird, wird der Vorgang ebenfalls gestoppt.  -1 ist also ein weiteres magisches Zeichen. <br><br>  Es gibt noch eine Sache, die im â€Kanarienvogelâ€œ verwendet werden kann - dies sind zufÃ¤llige Werte, die fÃ¼r den Angreifer schwer zu erraten sind.  Die StÃ¤rke des Zufallswerts hÃ¤ngt davon ab, wie schwierig es fÃ¼r einen Angreifer ist, ihn zu erraten.  Wenn ein Angreifer beispielsweise feststellt, dass Ihr System nur 3 Entropiebits enthÃ¤lt, kann er einen Brute-Force-Angriff ausfÃ¼hren.  Daher sind die MÃ¶glichkeiten, Zufallszahlen zum Schutz vor Angriffen zu verwenden, sehr begrenzt. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>Zielgruppe:</b> Normalerweise lese ich aus einem anderen Puffer und schreibe das, was ich gelesen habe, in diesen Puffer dieses Stapels.  In dieser Situation scheint der Zufallswert des "Kanarienvogels" nutzlos zu sein, da ich die Daten aus einem anderen Puffer lese und weiÃŸ, wo sich der "Kanarienvogel" befindet.  Ich habe einen anderen Puffer, den ich kontrolliere und den ich nie Ã¼berprÃ¼fe.  Und in diesen Puffer kann ich ziemlich viel von dem setzen, was ich setzen mÃ¶chte.  Ich brauche keinen zufÃ¤lligen "Kanarienvogel", weil ich ihn sicher umschreiben kann.  Ich sehe also nicht, wie es wirklich funktioniert - in dem von Ihnen vorgeschlagenen Szenario, wenn die Funktion beim Lesen von Daten aus dem Puffer stoppt. <br><br>  <b>Professor:</b> Ich verstehe Ihre Frage - Sie meinen, wir verwenden einen deterministischen "Kanarienvogel", verwenden jedoch keine der Funktionen der Standardbibliothek, die durch unsere Zeichen 0, CR, LF, -1 "getÃ¤uscht" werden kÃ¶nnen.  Dann ja, in der von Ihnen beschriebenen Situation wird kein â€Kanarienvogelâ€œ benÃ¶tigt. <br><br>  Die Idee ist, dass Sie diesen Puffer von Ã¼berall mit Bytes fÃ¼llen kÃ¶nnen, aber alles, was es Ihnen ermÃ¶glicht, diese Werte zu erraten oder sie zufÃ¤llig abzurufen, fÃ¼hrt zu einem Fehler. <br><br>  <b>Teilnehmerin:</b> Ist es mÃ¶glich, so etwas wie die Anzahl der Sekunden oder Millisekunden als Zufallszahlen zu verwenden und sie in einem â€Kanarienvogelâ€œ zu verwenden? <br><br>  <b>Professor:</b> Datenanrufe enthalten nicht so viele UnfÃ¤lle, wie Sie denken.  Weil das Programm Protokolle oder eine Funktion hat, die Sie aufrufen kÃ¶nnen, um herauszufinden, wann das Programm heruntergeladen wurde, und andere Ã¤hnliche Dinge.  Aber im Allgemeinen haben Sie Recht - in der Praxis kann dieser Ansatz funktionieren, wenn Sie ein HardwaregerÃ¤t verwenden kÃ¶nnen, das normalerweise auf einem niedrigen Niveau mit besseren Systemzeiten arbeitet. <br><br>  <b>Zielgruppe:</b> Auch wenn es uns gelingt, die Protokolle Ã¼ber den Beginn des PufferÃ¼berlaufs anzuzeigen, ist es immer noch wichtig, wann wir die Anforderung ablehnen.  Und wenn wir nicht kontrollieren kÃ¶nnen, wie lange die Anforderung eines Computers an den Server dauert, ist es zweifelhaft, ob die genaue Zeit deterministisch erraten werden kann. <br><br>  <b>Professor:</b> Ganz richtig, ich habe bereits gesagt, dass das BÃ¶se im Detail liegt, das ist genau so ein Fall.  Mit anderen Worten, wenn Sie beispielsweise den Typ des Zeitkanals bestimmen kÃ¶nnen, stellen Sie mÃ¶glicherweise fest, dass die Entropie oder die Anzahl der ZufÃ¤lligkeiten nicht einen ganzen Zeitstempel ausfÃ¼llt, sondern viel weniger.  Daher kann ein Angreifer die Stunde und Minute bestimmen, zu der Sie dies getan haben, jedoch keine Sekunde. <br><br>  <b>Teilnehmerin:</b> FÃ¼r den Rekord ist es eine schlechte Idee, die eigene ZufÃ¤lligkeit einzuschrÃ¤nken? <br><br>  <b>Professor:</b> absolut richtig! <br><br>  <b>Zielgruppe:</b> Das heiÃŸt, normalerweise mÃ¼ssen wir einfach alles verwenden, was unsere Systeme unterstÃ¼tzen, oder? <br><br>  <b>Professor:</b> Ja, das stimmt.  Dies ist wie die Erfindung unseres eigenen Kryptosystems, was eine weitere beliebte Sache ist, die unsere Absolventen manchmal tun mÃ¶chten.  Aber wir sind nicht die NSA, wir sind keine Mathematiker, also scheitert dies normalerweise.  Da haben Sie also absolut Recht. <br><br>  Aber selbst wenn Sie die ZufÃ¤lligkeit des Systems verwenden, kÃ¶nnen Sie immer noch weniger Entropiebits erhalten, als Sie erwarten.  Lassen Sie mich ein Beispiel fÃ¼r die Phasen-Randomisierung von Adressen geben.  Nach diesem Prinzip <b>funktioniert der</b> Ansatz der <b>Stapelkanarien</b> .  Da wir uns mit Computersicherheit beschÃ¤ftigen, fragen Sie sich wahrscheinlich, in welchen FÃ¤llen die "KanarienvÃ¶gel" ihre Aufgabe nicht bewÃ¤ltigen kÃ¶nnen und ob es MÃ¶glichkeiten gibt, den "Kanarienvogel" zu scheitern. <br><br>  Ein solcher Weg ist ein Angriff durch Umschreiben von Funktionszeigern.  Denn wenn ein Schlag auf den Funktionszeiger geschlagen wird, kann der â€Kanarienvogelâ€œ nichts tun. <br><br>  Angenommen, Sie haben einen Code der Form <b>int * ptr ... ..</b> , den <b>auslÃ¶senden</b> Zeiger, egal wie, dann haben Sie den <b>char buf-</b> Puffer <b>[128]</b> , die <b>get-</b> Funktion <b>(buf)</b> und ganz unten einen Zeiger, dem ein Wert zugewiesen ist : <b>* ptr = 5</b> . <br><br>  Ich stelle fest, dass wir nicht versucht haben, die RÃ¼cksprungadresse der Funktion anzugreifen, die diesen Code enthÃ¤lt.  Wie Sie sehen kÃ¶nnen, wird die darÃ¼ber liegende Zeigeradresse beschÃ¤digt, wenn der Puffer Ã¼berlÃ¤uft.  Wenn ein Angreifer diesen Zeiger beschÃ¤digen kann, kann er einer der von ihm kontrollierten Adressen 5 zuweisen.  Kann jeder sehen, dass der â€Kanarienvogelâ€œ hier nicht hilft?  Weil wir den Pfad, auf dem die Funktion zurÃ¼ckkehrt, nicht angreifen. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>Zielgruppe:</b> Kann sich der Zeiger unterhalb des Puffers befinden? <br><br>  <b>Professor: Das</b> kann es, aber die Reihenfolge bestimmter Variablen hÃ¤ngt von vielen verschiedenen Faktoren ab, von der Art und Weise, wie der Compiler den Inhalt anordnet, von der GrÃ¶ÃŸe der Hardware-Spalte usw.  Aber Sie haben Recht, wenn der PufferÃ¼berlauf steigt und sich der Zeiger unter dem Puffer befindet, kann der Ãœberlauf ihn nicht beschÃ¤digen. <br><br>  <b>Teilnehmerin:</b> Warum kÃ¶nnen Sie den "Kanarienvogel" nicht wie die Absenderadresse mit der Funktion "Kanarienvogel" verknÃ¼pfen? <br><br>  <b>Professor:</b> Das ist ein interessanter Moment!  Sie kÃ¶nnen solche Dinge tun.  In der Tat kÃ¶nnen Sie sich einen Compiler vorstellen, der immer dann, wenn er einen Zeiger hat, versucht, fÃ¼r einige Dinge ein Add-On hinzuzufÃ¼gen.  Das Auschecken all dieser Dinge wird jedoch zu teuer sein.  Da Sie jedes Mal, wenn Sie einen Zeiger verwenden oder eine Funktion aufrufen mÃ¶chten, einen Code benÃ¶tigen, der Ã¼berprÃ¼ft, ob dieser "Kanarienvogel" korrekt ist.  GrundsÃ¤tzlich kÃ¶nnten Sie etwas Ã„hnliches tun, aber macht das Sinn?  Wir sehen, dass die "KanarienvÃ¶gel" in dieser Situation nicht helfen. <br><br>  Und eine weitere Sache, die wir zuvor besprochen haben, ist, dass zufÃ¤llige â€KanarienvÃ¶gelâ€œ im Prinzip nicht funktionieren, wenn der Angreifer die ZufÃ¤lligkeit erraten kann.  Das Erstellen von Sicherheitsressourcen basierend auf ZufÃ¤lligkeit ist ein separates, sehr komplexes Thema, daher werden wir nicht darauf eingehen. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>Teilnehmerin:</b> Canary enthÃ¤lt also weniger Bits als eine Absenderadresse?  Weil Sie sich sonst nicht einfach an diese Adresse erinnern und prÃ¼fen kÃ¶nnten, ob sie sich geÃ¤ndert hat? <br><br>  <b>Professor: Mal</b> sehen.  Sie sprechen von diesem Schema, wenn sich der â€Kanarienvogelâ€œ Ã¼ber dem Puffer befindet, und Sie meinen, dass das System nicht sicher sein kann, wenn es unmÃ¶glich ist, die Absenderadresse zu Ã¼berprÃ¼fen und zu Ã¼berprÃ¼fen, ob sie geÃ¤ndert wurde. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Ja und nein.  Bitte beachten Sie, dass bei einem PufferÃ¼berlaufangriff alles darÃ¼ber Ã¼berschrieben wird, sodass dies weiterhin zu Problemen fÃ¼hren kann.  Aber wenn diese Dinge in gewisser Weise unverÃ¤nderlich wÃ¤ren, kÃ¶nnten Sie so etwas tun.  Das Problem ist jedoch, dass die Manipulation der Absenderadresse in vielen FÃ¤llen ziemlich kompliziert ist.  Weil Sie sich vorstellen kÃ¶nnen, dass eine spezielle Funktion von verschiedenen Orten aus aufgerufen werden kann, und so weiter.  In diesem Fall laufen wir ein wenig voraus, und wenn am Ende der Vorlesung noch Zeit ist, werden wir darauf zurÃ¼ckkommen. <br><br>  Dies sind Situationen, in denen ein â€Kanarienvogelâ€œ versagen kann.  Es gibt andere Stellen, an denen ein Fehler mÃ¶glich ist, beispielsweise beim Angriff auf das <b>Malloc</b> und die <b>freien</b> Funktionen.  Die Malloc-Funktion weist einen Speicherblock einer bestimmten GrÃ¶ÃŸe in Bytes zu und gibt einen Zeiger auf den Blockanfang zurÃ¼ck.  Der Inhalt des zugewiesenen Speicherblocks wird nicht initialisiert, sondern bleibt bei undefinierten Werten.  Und die <b>freie</b> Funktion gibt Speicher frei, der zuvor dynamisch zugewiesen wurde. <br><br>  Dies ist ein einzigartiger Angriff im Stil von C. Mal sehen, was hier passiert.  Stellen Sie sich vor, Sie haben hier zwei Zeiger, p und q, fÃ¼r die wir <b>malloc verwenden,</b> um jedem dieser Zeiger 1.024 Byte Speicher zuzuweisen.  Angenommen, wir machen die <b>strcpy-</b> Funktion fÃ¼r p aus einem Pufferfehler, der von einem Angreifer gesteuert wird.  Hier tritt ein Ãœberlauf auf.  Und dann fÃ¼hren wir den Befehl <b>free q</b> und <b>free p aus</b> .  Das ist ziemlich einfacher Code, oder? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Wir haben 2 Zeiger, denen wir Speicher zugewiesen haben, wir verwenden einen fÃ¼r eine bestimmte Funktion, es tritt ein PufferÃ¼berlauf auf und wir geben den Speicher beider Zeiger frei. <br><br>  Angenommen, die Speicherleitungen von p und q befinden sich nebeneinander im Speicherbereich.  In diesem Fall kÃ¶nnen schlimme Dinge passieren, oder?  Weil die <b>strcpy-</b> Funktion verwendet wird, um den Inhalt von <b>str2</b> nach <b>str1</b> zu <b>kopieren</b> .  <b>Str2</b> sollte ein Zeiger auf einen String sein, der mit Null endet, und <b>strcpy</b> gibt einen Zeiger auf <b>str1 zurÃ¼ck</b> .  Wenn sich die Linien <b>str1</b> und <b>str2</b> Ã¼berlappen, ist das Verhalten der Funktion <b>strcpy</b> undefiniert. <br><br>  Daher kann die <b>Strycpy-</b> Funktion, die den Speicher <b>p</b> verarbeitet, gleichzeitig den fÃ¼r <b>q</b> zugewiesenen Speicher beeinflussen.  Und das kann Probleme verursachen. <br><br>  Es ist mÃ¶glich, dass Sie so etwas versehentlich in Ihrem eigenen Code getan haben, als Sie eine seltsame Art von Zeigern verwendet haben.  Und alles scheint zu funktionieren, aber wenn Sie die <b>freie</b> Funktion aufrufen mÃ¼ssen, tritt ein solches Ã„rgernis auf.  Und ein Angreifer kann es ausnutzen, ich werde erklÃ¤ren, warum dies passiert. <br><br>  Stellen Sie sich vor, dass der hervorgehobene Block in der Implementierung der Funktionen <b>free</b> und <b>malloc folgendermaÃŸen</b> aussieht. <br><br>  Nehmen wir an, dass oben im Block sichtbare Anwendungsdaten vorhanden sind und unten die GrÃ¶ÃŸe der Variablen angegeben ist.  Diese GrÃ¶ÃŸe ist nicht das, was die Anwendung direkt sieht, sondern eine Art â€Abrechnungâ€œ, die von <b>Free</b> oder <b>Malloc durchgefÃ¼hrt wird</b> , sodass Sie die GrÃ¶ÃŸe des zugewiesenen Speicherpuffers kennen.  Ein freier Block befindet sich neben dem markierten Block.  Angenommen, ein freier Block enthÃ¤lt einige Metadaten, die folgendermaÃŸen aussehen: Wir haben die GrÃ¶ÃŸe des Blocks darÃ¼ber, darunter befindet sich freier Speicherplatz, der RÃ¼ckzeiger und der VorwÃ¤rtszeiger darunter.  Und ganz unten im Block wird die GrÃ¶ÃŸe erneut angezeigt. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  Warum haben wir hier 2 Zeiger?  Weil das Speicherzuweisungssystem in diesem Fall eine doppelt verknÃ¼pfte Liste verwendet, um zu verfolgen, wie freie BlÃ¶cke miteinander in Beziehung stehen.  Wenn Sie einen freien Block auswÃ¤hlen, schlieÃŸen Sie ihn daher von dieser doppelt verknÃ¼pften Liste aus.  Und dann, wenn Sie es freigeben, werden Sie eine Arithmetik fÃ¼r den Zeiger durchfÃ¼hren und diese Dinge in Ordnung bringen.  Danach fÃ¼gen Sie es dieser verknÃ¼pften Liste hinzu, richtig? <br><br>  Wann immer Sie von Zeigerarithmetik hÃ¶ren, sollten Sie denken, dass dies Ihr â€Kanarienvogelâ€œ ist.  Weil es viele Probleme geben wird.  Ich mÃ¶chte Sie daran erinnern, dass wir einen PufferÃ¼berlauf hatten.  Wenn wir annehmen, dass <b>p</b> und <b>q</b> nebeneinander oder sehr nahe am Speicherplatz liegen, kann es letztendlich vorkommen, dass dieser PufferÃ¼berlauf einige GrÃ¶ÃŸendaten fÃ¼r den zugewiesenen Zeiger <b>q</b> Ã¼berschreibt - dies ist der Boden unseres zugewiesenen Blocks.  Wenn Sie meinen Gedanken von Anfang an weiter folgen, wird Ihnen Ihre Vorstellungskraft sagen, wo alles schief geht.  TatsÃ¤chlich geschieht bei diesen Operationen im Wesentlichen das <b>freie q</b> und das <b>freie p</b> - sie betrachten diese Metadaten im ausgewÃ¤hlten Block, um alle erforderlichen Manipulationen mit dem Zeiger durchzufÃ¼hren. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Das heiÃŸt, irgendwann in der AusfÃ¼hrung erhalten die <b>freien</b> Funktionen einen bestimmten Zeiger basierend auf dem GrÃ¶ÃŸenwert: <b>p = get.free.block (GrÃ¶ÃŸe)</b> , und die GrÃ¶ÃŸe wird vom Angreifer <b>gesteuert</b> , da er einen PufferÃ¼berlauf korrekt ausgefÃ¼hrt hat ? <br><br>  Er hat eine Reihe von arithmetischen Berechnungen durchgefÃ¼hrt, sich die Funktion <b>back</b> und die Zeiger dieses Blocks angesehen und wird nun so etwas wie die Zeiger "back" und "forward" aktualisieren - dies sind die beiden unteren Zeilen. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Aber in Wirklichkeit sollte dich das nicht stÃ¶ren.  Dies ist nur ein Beispiel fÃ¼r den Code, der in diesem Fall stattfindet.  Tatsache ist jedoch, dass er aufgrund der vom Hacker neu geschriebenen GrÃ¶ÃŸe jetzt diesen Zeiger steuert, der die <b>freie</b> Funktion durchlÃ¤uft.  Aus diesem Grund sind die beiden ZustÃ¤nde hier in den unteren Zeilen tatsÃ¤chlich Zeigeraktualisierungen.  Und da der Angreifer dieses <b>p</b> steuern konnte, steuert er tatsÃ¤chlich diese beiden Zeiger.  Hier kann ein Angriff stattfinden. <br><br>  Wenn Sie also <b>frei</b> laufen und versuchen, diese beiden BlÃ¶cke zu kombinieren, haben Sie eine doppelt verknÃ¼pfte Liste.  Denn wenn Sie zwei BlÃ¶cke haben, die miteinander kollidieren und beide frei sind, mÃ¶chten Sie sie zu einem groÃŸen Block kombinieren. <br><br>  Wenn wir jedoch die GrÃ¶ÃŸe steuern, bedeutet dies, dass wir den gesamten Prozess Ã¼ber die vier obigen Zeilen steuern.  Das heiÃŸt, wenn wir verstehen, wie Ãœberlauf funktioniert, kÃ¶nnen wir Daten auf die von uns gewÃ¤hlte Weise in den Speicher schreiben.  Wie gesagt, solche Dinge passieren oft mit Ihrem eigenen Code, wenn Sie mit einem Zeiger nicht schlau sind.  Wenn Sie einen doppelten freien Fehler wie <b>free q</b> und <b>free p</b> oder etwas anderes machen, stÃ¼rzt Ihre Funktion ab.  Weil Sie die Metadaten, die in jedem dieser ausgewÃ¤hlten BlÃ¶cke vorhanden sind, durcheinander gebracht haben und diese Berechnung irgendwann eine Art "MÃ¼ll" -Wert anzeigt, nach dem Sie "tot" sind.  Wenn Sie jedoch ein Angreifer sind, kÃ¶nnen Sie diesen Wert auswÃ¤hlen und zu Ihrem Vorteil nutzen. <br><br>  Fahren wir mit einem anderen Ansatz fort, um PufferÃ¼berlaufangriffe zu verhindern.  Dieser Ansatz dient dazu, Grenzen zu Ã¼berprÃ¼fen.  Mit der BegrenzungsprÃ¼fung soll sichergestellt werden, dass bei Verwendung eines bestimmten Zeigers nur auf ein Speicherobjekt verwiesen wird.  Und dieser Zeiger befindet sich innerhalb der zulÃ¤ssigen Grenzen dieses Speicherobjekts.  Dies ist die Hauptidee der ÃœberprÃ¼fung.       â€”   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        â€“    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  Schwer zu sagen.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing â€“  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   Â«Â» â€”  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page â€“ !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> MIT Â«  Â».  2: Â«  Â»,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Vollversion des Kurses finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416047/">https://habr.com/ru/post/de416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416029/index.html">FlÃ¼ssiger Computer: Erfassung von Ionen in Graphen</a></li>
<li><a href="../de416035/index.html">Dental 3D Scanner Shining 3D Autoscan DS EX (Unboxing) von 3Dtool</a></li>
<li><a href="../de416037/index.html">Start des Tages (April-Juni 2018)</a></li>
<li><a href="../de416043/index.html">EntwicklungslÃ¤nder erforschen zunehmend den Weltraum.</a></li>
<li><a href="../de416045/index.html">APC Smart-UPS Online-SRC1KI-USV: ZuverlÃ¤ssigkeit vor allem</a></li>
<li><a href="../de416049/index.html">AV1 Next Generation Codec: CDEF-Richtungskorrekturfilter</a></li>
<li><a href="../de416051/index.html">Sommer Mitap Apache Ignite in Moskau</a></li>
<li><a href="../de416053/index.html">Amplitudenmodulation eines beliebigen Signals</a></li>
<li><a href="../de416055/index.html">Zuweisung und UnterstÃ¼tzung des FQDN des 3QX-Servers</a></li>
<li><a href="../de416059/index.html">Mobio spricht mit Daniil Shuleiko (Yandex.Taxi) Ã¼ber die Fusion mit Uber, den Taximarkt und den Wettbewerb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>