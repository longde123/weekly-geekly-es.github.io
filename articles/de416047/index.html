<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏭 🏨 🦋 MIT-Kurs "Computer Systems Security". Vorlesung 2: „Kontrolle von Hackerangriffen“, Teil 2 ♎️ 🧑🏿‍🤝‍🧑🏽 👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 2: „Kontrolle von Hackerangriffen“, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Wir haben also einen Puffer, über den wir den „Kanarienvogel“ legen.  Darüber befindet sich der gespeicherte <b>EBP-</b> Wert des gespeicherten Haltepunktzeigers und die Rücksprungadresse wird darüber platziert.  Wenn Sie sich erinnern, geht der Überlauf von unten nach oben. Bevor Sie also zur Absenderadresse gelangen, wird zuerst der "Kanarienvogel" zerstört. <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>Teilnehmerin:</b> Warum wirkt sich das auf den "Kanarienvogel" aus? <br><br>  <b>Professor:</b> Weil angenommen wird, dass der Angreifer nicht weiß, wie er willkürlich in das Gedächtnis „springen“ soll.  Herkömmliche Speicherüberlaufangriffe beginnen mit einem Hacker, der die Puffergrößenbeschränkung untersucht. Danach beginnt der Überlauf unter dem Strich.  Aber Sie haben Recht - wenn ein Angreifer direkt in die Absenderadressleiste gelangen kann, hilft uns kein „Kanarienvogel“.  Bei einem herkömmlichen Pufferüberlaufangriff sollte jedoch alles genau so ablaufen - von unten nach oben. <br><br>  Die Hauptidee bei der Verwendung eines „Kanarienvogels“ ist daher, dass ein böswilliger Exploit den Speicherpuffer überlaufen lässt.  Wir haben einen Laufzeitcode, der bei der Rückkehr von einer Funktion den "Kanarienvogel" überprüft, um sicherzustellen, dass er den richtigen Wert hat. <br><br>  <b>Zielgruppe:</b> Kann ein Angreifer die Absenderadresse umschreiben und den „Kanarienvogel“ ändern?  Wie kann er überprüfen, ob es geändert wurde, aber weiterhin seine Funktion erfüllt? <br><br>  <b>Professor:</b> Ja, vielleicht.  Daher sollten Sie einen Code haben, der dies tatsächlich überprüft, bevor die Funktion zurückkehrt.  Das heißt, in diesem Fall ist die Unterstützung eines Compilers erforderlich, der die <b>Aufrufkonvention</b> tatsächlich <b>aufruft</b> .  Dieser Teil der Rückgabesequenz erfolgt also, bevor wir die Gültigkeit dieses Werts prüfen, um sicherzustellen, dass der „Kanarienvogel“ nicht zerstört wurde.  Erst danach können wir über etwas anderes nachdenken. <br><br>  <b>Teilnehmerin:</b> Kann ein Angreifer nicht wissen oder erraten, was "Kanarienvogel" bedeutet? <br><br>  <b>Professor:</b> Genau darüber werde ich sprechen!  Was ist das Problem mit dieser Schaltung?  Was ist, wenn wir zum Beispiel den Wert A in jedes Programm setzen?  Oder ein ganzer Zweig von 4 Werten von A?  Natürlich kann jeder Hacker die Größe des Puffers und seine Kapazität herausfinden und so die Position des "Kanarienvogels" in jedem System bestimmen.  Daher können wir verschiedene Arten von Mengen verwenden, die wir in unseren „Kanarienvogel“ geben, um dies zu verhindern. <br><br>  Eines können Sie mit unserem „Kanarienvogel“ tun.  Es wird eine sehr lustige Art von "Kanarienvogel" sein, die C-Programmfunktionen verwendet und Sonderzeichen verarbeitet, die sogenannte deterministische Art von "Kanarienvogel". <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Stellen Sie sich vor, Sie haben das Zeichen 0 für den „Kanarienvogel“ verwendet. Der Binärwert Null ist das Nullbyte, das Nullzeichen in ASCII.  Ein Wert von -1 bedeutet eine Rückkehr zur vorherigen Position und so weiter.  Viele Funktionen stoppen oder ändern den Betrieb, wenn sie auf Zeichen oder Werte wie 0, CR, LF, -1 stoßen.  Stellen Sie sich vor, Sie als Hacker verwenden eine String-Verwaltungsfunktion, um den Puffer zu erhöhen, treffen auf das Zeichen 0 im "Kanarienvogel" und der Prozess stoppt!  Wenn Sie die Funktion „Wagenrücklauf“ -1 verwenden, die häufig als Zeilenabschluss verwendet wird, wird der Vorgang ebenfalls gestoppt.  -1 ist also ein weiteres magisches Zeichen. <br><br>  Es gibt noch eine Sache, die im „Kanarienvogel“ verwendet werden kann - dies sind zufällige Werte, die für den Angreifer schwer zu erraten sind.  Die Stärke des Zufallswerts hängt davon ab, wie schwierig es für einen Angreifer ist, ihn zu erraten.  Wenn ein Angreifer beispielsweise feststellt, dass Ihr System nur 3 Entropiebits enthält, kann er einen Brute-Force-Angriff ausführen.  Daher sind die Möglichkeiten, Zufallszahlen zum Schutz vor Angriffen zu verwenden, sehr begrenzt. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>Zielgruppe:</b> Normalerweise lese ich aus einem anderen Puffer und schreibe das, was ich gelesen habe, in diesen Puffer dieses Stapels.  In dieser Situation scheint der Zufallswert des "Kanarienvogels" nutzlos zu sein, da ich die Daten aus einem anderen Puffer lese und weiß, wo sich der "Kanarienvogel" befindet.  Ich habe einen anderen Puffer, den ich kontrolliere und den ich nie überprüfe.  Und in diesen Puffer kann ich ziemlich viel von dem setzen, was ich setzen möchte.  Ich brauche keinen zufälligen "Kanarienvogel", weil ich ihn sicher umschreiben kann.  Ich sehe also nicht, wie es wirklich funktioniert - in dem von Ihnen vorgeschlagenen Szenario, wenn die Funktion beim Lesen von Daten aus dem Puffer stoppt. <br><br>  <b>Professor:</b> Ich verstehe Ihre Frage - Sie meinen, wir verwenden einen deterministischen "Kanarienvogel", verwenden jedoch keine der Funktionen der Standardbibliothek, die durch unsere Zeichen 0, CR, LF, -1 "getäuscht" werden können.  Dann ja, in der von Ihnen beschriebenen Situation wird kein „Kanarienvogel“ benötigt. <br><br>  Die Idee ist, dass Sie diesen Puffer von überall mit Bytes füllen können, aber alles, was es Ihnen ermöglicht, diese Werte zu erraten oder sie zufällig abzurufen, führt zu einem Fehler. <br><br>  <b>Teilnehmerin:</b> Ist es möglich, so etwas wie die Anzahl der Sekunden oder Millisekunden als Zufallszahlen zu verwenden und sie in einem „Kanarienvogel“ zu verwenden? <br><br>  <b>Professor:</b> Datenanrufe enthalten nicht so viele Unfälle, wie Sie denken.  Weil das Programm Protokolle oder eine Funktion hat, die Sie aufrufen können, um herauszufinden, wann das Programm heruntergeladen wurde, und andere ähnliche Dinge.  Aber im Allgemeinen haben Sie Recht - in der Praxis kann dieser Ansatz funktionieren, wenn Sie ein Hardwaregerät verwenden können, das normalerweise auf einem niedrigen Niveau mit besseren Systemzeiten arbeitet. <br><br>  <b>Zielgruppe:</b> Auch wenn es uns gelingt, die Protokolle über den Beginn des Pufferüberlaufs anzuzeigen, ist es immer noch wichtig, wann wir die Anforderung ablehnen.  Und wenn wir nicht kontrollieren können, wie lange die Anforderung eines Computers an den Server dauert, ist es zweifelhaft, ob die genaue Zeit deterministisch erraten werden kann. <br><br>  <b>Professor:</b> Ganz richtig, ich habe bereits gesagt, dass das Böse im Detail liegt, das ist genau so ein Fall.  Mit anderen Worten, wenn Sie beispielsweise den Typ des Zeitkanals bestimmen können, stellen Sie möglicherweise fest, dass die Entropie oder die Anzahl der Zufälligkeiten nicht einen ganzen Zeitstempel ausfüllt, sondern viel weniger.  Daher kann ein Angreifer die Stunde und Minute bestimmen, zu der Sie dies getan haben, jedoch keine Sekunde. <br><br>  <b>Teilnehmerin:</b> Für den Rekord ist es eine schlechte Idee, die eigene Zufälligkeit einzuschränken? <br><br>  <b>Professor:</b> absolut richtig! <br><br>  <b>Zielgruppe:</b> Das heißt, normalerweise müssen wir einfach alles verwenden, was unsere Systeme unterstützen, oder? <br><br>  <b>Professor:</b> Ja, das stimmt.  Dies ist wie die Erfindung unseres eigenen Kryptosystems, was eine weitere beliebte Sache ist, die unsere Absolventen manchmal tun möchten.  Aber wir sind nicht die NSA, wir sind keine Mathematiker, also scheitert dies normalerweise.  Da haben Sie also absolut Recht. <br><br>  Aber selbst wenn Sie die Zufälligkeit des Systems verwenden, können Sie immer noch weniger Entropiebits erhalten, als Sie erwarten.  Lassen Sie mich ein Beispiel für die Phasen-Randomisierung von Adressen geben.  Nach diesem Prinzip <b>funktioniert der</b> Ansatz der <b>Stapelkanarien</b> .  Da wir uns mit Computersicherheit beschäftigen, fragen Sie sich wahrscheinlich, in welchen Fällen die "Kanarienvögel" ihre Aufgabe nicht bewältigen können und ob es Möglichkeiten gibt, den "Kanarienvogel" zu scheitern. <br><br>  Ein solcher Weg ist ein Angriff durch Umschreiben von Funktionszeigern.  Denn wenn ein Schlag auf den Funktionszeiger geschlagen wird, kann der „Kanarienvogel“ nichts tun. <br><br>  Angenommen, Sie haben einen Code der Form <b>int * ptr ... ..</b> , den <b>auslösenden</b> Zeiger, egal wie, dann haben Sie den <b>char buf-</b> Puffer <b>[128]</b> , die <b>get-</b> Funktion <b>(buf)</b> und ganz unten einen Zeiger, dem ein Wert zugewiesen ist : <b>* ptr = 5</b> . <br><br>  Ich stelle fest, dass wir nicht versucht haben, die Rücksprungadresse der Funktion anzugreifen, die diesen Code enthält.  Wie Sie sehen können, wird die darüber liegende Zeigeradresse beschädigt, wenn der Puffer überläuft.  Wenn ein Angreifer diesen Zeiger beschädigen kann, kann er einer der von ihm kontrollierten Adressen 5 zuweisen.  Kann jeder sehen, dass der „Kanarienvogel“ hier nicht hilft?  Weil wir den Pfad, auf dem die Funktion zurückkehrt, nicht angreifen. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>Zielgruppe:</b> Kann sich der Zeiger unterhalb des Puffers befinden? <br><br>  <b>Professor: Das</b> kann es, aber die Reihenfolge bestimmter Variablen hängt von vielen verschiedenen Faktoren ab, von der Art und Weise, wie der Compiler den Inhalt anordnet, von der Größe der Hardware-Spalte usw.  Aber Sie haben Recht, wenn der Pufferüberlauf steigt und sich der Zeiger unter dem Puffer befindet, kann der Überlauf ihn nicht beschädigen. <br><br>  <b>Teilnehmerin:</b> Warum können Sie den "Kanarienvogel" nicht wie die Absenderadresse mit der Funktion "Kanarienvogel" verknüpfen? <br><br>  <b>Professor:</b> Das ist ein interessanter Moment!  Sie können solche Dinge tun.  In der Tat können Sie sich einen Compiler vorstellen, der immer dann, wenn er einen Zeiger hat, versucht, für einige Dinge ein Add-On hinzuzufügen.  Das Auschecken all dieser Dinge wird jedoch zu teuer sein.  Da Sie jedes Mal, wenn Sie einen Zeiger verwenden oder eine Funktion aufrufen möchten, einen Code benötigen, der überprüft, ob dieser "Kanarienvogel" korrekt ist.  Grundsätzlich könnten Sie etwas Ähnliches tun, aber macht das Sinn?  Wir sehen, dass die "Kanarienvögel" in dieser Situation nicht helfen. <br><br>  Und eine weitere Sache, die wir zuvor besprochen haben, ist, dass zufällige „Kanarienvögel“ im Prinzip nicht funktionieren, wenn der Angreifer die Zufälligkeit erraten kann.  Das Erstellen von Sicherheitsressourcen basierend auf Zufälligkeit ist ein separates, sehr komplexes Thema, daher werden wir nicht darauf eingehen. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>Teilnehmerin:</b> Canary enthält also weniger Bits als eine Absenderadresse?  Weil Sie sich sonst nicht einfach an diese Adresse erinnern und prüfen könnten, ob sie sich geändert hat? <br><br>  <b>Professor: Mal</b> sehen.  Sie sprechen von diesem Schema, wenn sich der „Kanarienvogel“ über dem Puffer befindet, und Sie meinen, dass das System nicht sicher sein kann, wenn es unmöglich ist, die Absenderadresse zu überprüfen und zu überprüfen, ob sie geändert wurde. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Ja und nein.  Bitte beachten Sie, dass bei einem Pufferüberlaufangriff alles darüber überschrieben wird, sodass dies weiterhin zu Problemen führen kann.  Aber wenn diese Dinge in gewisser Weise unveränderlich wären, könnten Sie so etwas tun.  Das Problem ist jedoch, dass die Manipulation der Absenderadresse in vielen Fällen ziemlich kompliziert ist.  Weil Sie sich vorstellen können, dass eine spezielle Funktion von verschiedenen Orten aus aufgerufen werden kann, und so weiter.  In diesem Fall laufen wir ein wenig voraus, und wenn am Ende der Vorlesung noch Zeit ist, werden wir darauf zurückkommen. <br><br>  Dies sind Situationen, in denen ein „Kanarienvogel“ versagen kann.  Es gibt andere Stellen, an denen ein Fehler möglich ist, beispielsweise beim Angriff auf das <b>Malloc</b> und die <b>freien</b> Funktionen.  Die Malloc-Funktion weist einen Speicherblock einer bestimmten Größe in Bytes zu und gibt einen Zeiger auf den Blockanfang zurück.  Der Inhalt des zugewiesenen Speicherblocks wird nicht initialisiert, sondern bleibt bei undefinierten Werten.  Und die <b>freie</b> Funktion gibt Speicher frei, der zuvor dynamisch zugewiesen wurde. <br><br>  Dies ist ein einzigartiger Angriff im Stil von C. Mal sehen, was hier passiert.  Stellen Sie sich vor, Sie haben hier zwei Zeiger, p und q, für die wir <b>malloc verwenden,</b> um jedem dieser Zeiger 1.024 Byte Speicher zuzuweisen.  Angenommen, wir machen die <b>strcpy-</b> Funktion für p aus einem Pufferfehler, der von einem Angreifer gesteuert wird.  Hier tritt ein Überlauf auf.  Und dann führen wir den Befehl <b>free q</b> und <b>free p aus</b> .  Das ist ziemlich einfacher Code, oder? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Wir haben 2 Zeiger, denen wir Speicher zugewiesen haben, wir verwenden einen für eine bestimmte Funktion, es tritt ein Pufferüberlauf auf und wir geben den Speicher beider Zeiger frei. <br><br>  Angenommen, die Speicherleitungen von p und q befinden sich nebeneinander im Speicherbereich.  In diesem Fall können schlimme Dinge passieren, oder?  Weil die <b>strcpy-</b> Funktion verwendet wird, um den Inhalt von <b>str2</b> nach <b>str1</b> zu <b>kopieren</b> .  <b>Str2</b> sollte ein Zeiger auf einen String sein, der mit Null endet, und <b>strcpy</b> gibt einen Zeiger auf <b>str1 zurück</b> .  Wenn sich die Linien <b>str1</b> und <b>str2</b> überlappen, ist das Verhalten der Funktion <b>strcpy</b> undefiniert. <br><br>  Daher kann die <b>Strycpy-</b> Funktion, die den Speicher <b>p</b> verarbeitet, gleichzeitig den für <b>q</b> zugewiesenen Speicher beeinflussen.  Und das kann Probleme verursachen. <br><br>  Es ist möglich, dass Sie so etwas versehentlich in Ihrem eigenen Code getan haben, als Sie eine seltsame Art von Zeigern verwendet haben.  Und alles scheint zu funktionieren, aber wenn Sie die <b>freie</b> Funktion aufrufen müssen, tritt ein solches Ärgernis auf.  Und ein Angreifer kann es ausnutzen, ich werde erklären, warum dies passiert. <br><br>  Stellen Sie sich vor, dass der hervorgehobene Block in der Implementierung der Funktionen <b>free</b> und <b>malloc folgendermaßen</b> aussieht. <br><br>  Nehmen wir an, dass oben im Block sichtbare Anwendungsdaten vorhanden sind und unten die Größe der Variablen angegeben ist.  Diese Größe ist nicht das, was die Anwendung direkt sieht, sondern eine Art „Abrechnung“, die von <b>Free</b> oder <b>Malloc durchgeführt wird</b> , sodass Sie die Größe des zugewiesenen Speicherpuffers kennen.  Ein freier Block befindet sich neben dem markierten Block.  Angenommen, ein freier Block enthält einige Metadaten, die folgendermaßen aussehen: Wir haben die Größe des Blocks darüber, darunter befindet sich freier Speicherplatz, der Rückzeiger und der Vorwärtszeiger darunter.  Und ganz unten im Block wird die Größe erneut angezeigt. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  Warum haben wir hier 2 Zeiger?  Weil das Speicherzuweisungssystem in diesem Fall eine doppelt verknüpfte Liste verwendet, um zu verfolgen, wie freie Blöcke miteinander in Beziehung stehen.  Wenn Sie einen freien Block auswählen, schließen Sie ihn daher von dieser doppelt verknüpften Liste aus.  Und dann, wenn Sie es freigeben, werden Sie eine Arithmetik für den Zeiger durchführen und diese Dinge in Ordnung bringen.  Danach fügen Sie es dieser verknüpften Liste hinzu, richtig? <br><br>  Wann immer Sie von Zeigerarithmetik hören, sollten Sie denken, dass dies Ihr „Kanarienvogel“ ist.  Weil es viele Probleme geben wird.  Ich möchte Sie daran erinnern, dass wir einen Pufferüberlauf hatten.  Wenn wir annehmen, dass <b>p</b> und <b>q</b> nebeneinander oder sehr nahe am Speicherplatz liegen, kann es letztendlich vorkommen, dass dieser Pufferüberlauf einige Größendaten für den zugewiesenen Zeiger <b>q</b> überschreibt - dies ist der Boden unseres zugewiesenen Blocks.  Wenn Sie meinen Gedanken von Anfang an weiter folgen, wird Ihnen Ihre Vorstellungskraft sagen, wo alles schief geht.  Tatsächlich geschieht bei diesen Operationen im Wesentlichen das <b>freie q</b> und das <b>freie p</b> - sie betrachten diese Metadaten im ausgewählten Block, um alle erforderlichen Manipulationen mit dem Zeiger durchzuführen. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Das heißt, irgendwann in der Ausführung erhalten die <b>freien</b> Funktionen einen bestimmten Zeiger basierend auf dem Größenwert: <b>p = get.free.block (Größe)</b> , und die Größe wird vom Angreifer <b>gesteuert</b> , da er einen Pufferüberlauf korrekt ausgeführt hat ? <br><br>  Er hat eine Reihe von arithmetischen Berechnungen durchgeführt, sich die Funktion <b>back</b> und die Zeiger dieses Blocks angesehen und wird nun so etwas wie die Zeiger "back" und "forward" aktualisieren - dies sind die beiden unteren Zeilen. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Aber in Wirklichkeit sollte dich das nicht stören.  Dies ist nur ein Beispiel für den Code, der in diesem Fall stattfindet.  Tatsache ist jedoch, dass er aufgrund der vom Hacker neu geschriebenen Größe jetzt diesen Zeiger steuert, der die <b>freie</b> Funktion durchläuft.  Aus diesem Grund sind die beiden Zustände hier in den unteren Zeilen tatsächlich Zeigeraktualisierungen.  Und da der Angreifer dieses <b>p</b> steuern konnte, steuert er tatsächlich diese beiden Zeiger.  Hier kann ein Angriff stattfinden. <br><br>  Wenn Sie also <b>frei</b> laufen und versuchen, diese beiden Blöcke zu kombinieren, haben Sie eine doppelt verknüpfte Liste.  Denn wenn Sie zwei Blöcke haben, die miteinander kollidieren und beide frei sind, möchten Sie sie zu einem großen Block kombinieren. <br><br>  Wenn wir jedoch die Größe steuern, bedeutet dies, dass wir den gesamten Prozess über die vier obigen Zeilen steuern.  Das heißt, wenn wir verstehen, wie Überlauf funktioniert, können wir Daten auf die von uns gewählte Weise in den Speicher schreiben.  Wie gesagt, solche Dinge passieren oft mit Ihrem eigenen Code, wenn Sie mit einem Zeiger nicht schlau sind.  Wenn Sie einen doppelten freien Fehler wie <b>free q</b> und <b>free p</b> oder etwas anderes machen, stürzt Ihre Funktion ab.  Weil Sie die Metadaten, die in jedem dieser ausgewählten Blöcke vorhanden sind, durcheinander gebracht haben und diese Berechnung irgendwann eine Art "Müll" -Wert anzeigt, nach dem Sie "tot" sind.  Wenn Sie jedoch ein Angreifer sind, können Sie diesen Wert auswählen und zu Ihrem Vorteil nutzen. <br><br>  Fahren wir mit einem anderen Ansatz fort, um Pufferüberlaufangriffe zu verhindern.  Dieser Ansatz dient dazu, Grenzen zu überprüfen.  Mit der Begrenzungsprüfung soll sichergestellt werden, dass bei Verwendung eines bestimmten Zeigers nur auf ein Speicherobjekt verwiesen wird.  Und dieser Zeiger befindet sich innerhalb der zulässigen Grenzen dieses Speicherobjekts.  Dies ist die Hauptidee der Überprüfung.       —   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        –    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  Schwer zu sagen.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing –  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   «» —  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page – !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> MIT «  ».  2: «  »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Vollversion des Kurses finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416047/">https://habr.com/ru/post/de416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416029/index.html">Flüssiger Computer: Erfassung von Ionen in Graphen</a></li>
<li><a href="../de416035/index.html">Dental 3D Scanner Shining 3D Autoscan DS EX (Unboxing) von 3Dtool</a></li>
<li><a href="../de416037/index.html">Start des Tages (April-Juni 2018)</a></li>
<li><a href="../de416043/index.html">Entwicklungsländer erforschen zunehmend den Weltraum.</a></li>
<li><a href="../de416045/index.html">APC Smart-UPS Online-SRC1KI-USV: Zuverlässigkeit vor allem</a></li>
<li><a href="../de416049/index.html">AV1 Next Generation Codec: CDEF-Richtungskorrekturfilter</a></li>
<li><a href="../de416051/index.html">Sommer Mitap Apache Ignite in Moskau</a></li>
<li><a href="../de416053/index.html">Amplitudenmodulation eines beliebigen Signals</a></li>
<li><a href="../de416055/index.html">Zuweisung und Unterstützung des FQDN des 3QX-Servers</a></li>
<li><a href="../de416059/index.html">Mobio spricht mit Daniil Shuleiko (Yandex.Taxi) über die Fusion mit Uber, den Taximarkt und den Wettbewerb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>