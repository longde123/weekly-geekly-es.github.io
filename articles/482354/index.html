<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèø ü§µüèª ü§® ConfigureAwait: Preguntas frecuentes üÜë üôÜüèª üõåüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Le presento la traducci√≥n del art√≠culo de Preguntas frecuentes sobre ConfigureAwait de Stephen Taub. 



 Async / await agreg√≥ a .NET hace ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait: Preguntas frecuentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482354/"> Hola Habr!  Le presento la traducci√≥n del art√≠culo de <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">Preguntas frecuentes sobre ConfigureAwait</a> de Stephen Taub. <br><br><img src="https://habrastorage.org/webt/ps/pj/sm/pspjsmmgsimr2lachonj6idmnj8.png" alt="imagen"><br><br>  <code>Async</code> / <code>await</code> agreg√≥ a .NET hace m√°s de siete a√±os.  Esta decisi√≥n ha tenido un impacto significativo no solo en el ecosistema .NET, sino que tambi√©n se refleja en muchos otros lenguajes y marcos.  Actualmente, se han implementado muchas mejoras en .NET en t√©rminos de construcciones de lenguaje adicionales usando asincron√≠a, se han implementado API con soporte de asincron√≠a, se han realizado mejoras fundamentales en la infraestructura debido a que <code>async</code> / <code>await</code> funciona como un reloj (en particular, se han mejorado las capacidades de rendimiento y diagn√≥stico en .NET Core). <br><br>  <code>ConfigureAwait</code> es un aspecto de <code>async</code> / <code>await</code> que contin√∫a generando preguntas.  Espero poder responder a muchas de ellas.  Intentar√© que este art√≠culo sea legible de principio a fin y, al mismo tiempo, ejecutarlo al estilo de las respuestas a las preguntas frecuentes (FAQ) para que pueda ser referenciado en el futuro. <a name="habracut"></a><br><br>  Para tratar realmente con <code>ConfigureAwait</code> , volveremos un poco. <br><br><h3>  ¬øQu√© es un SynchronizationContext? </h3><br>  De acuerdo con la documentaci√≥n de <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext%3Fview%3Dnetframework-4.8" rel="nofollow">System.Threading.SynchronizationContext</a> "Proporciona funcionalidad b√°sica para distribuir el contexto de sincronizaci√≥n en varios modelos de sincronizaci√≥n".  Esta definici√≥n no es del todo obvia. <br><br>  En el 99.9% de los casos, el <code>SynchronizationContext</code> usa simplemente como un tipo con un m√©todo <code>Post</code> virtual que acepta un delegado para la ejecuci√≥n asincr√≥nica (hay otros miembros virtuales en el <code>SynchronizationContext</code> , pero son menos comunes y no se discutir√°n en este art√≠culo).  El m√©todo <code>Post</code> del tipo base literalmente <a href="" rel="nofollow">simplemente llama a</a> <code>ThreadPool.QueueUserWorkItem</code> para ejecutar asincr√≥nicamente el delegado proporcionado.  Los tipos derivados anulan <code>Post</code> para que el delegado pueda ejecutar en el lugar correcto en el momento correcto. <br><br>  Por ejemplo, Windows Forms tiene un <a href="" rel="nofollow">tipo</a> derivado de SynchronizationContext que redefine <code>Post</code> para hacer el equivalente de <code>Control.BeginInvoke</code> .  Esto significa que cualquier llamada a este m√©todo <code>Post</code> dar√° como resultado una llamada al delegado en una etapa posterior en el hilo asociado con el Control correspondiente, el llamado hilo de UI.  En el coraz√≥n de Windows Forms est√° el procesamiento de mensajes Win32.  El bucle de mensajes se ejecuta en un subproceso de interfaz de usuario que solo espera a que se procesen nuevos mensajes.  Estos mensajes se activan por el movimiento del mouse, los clics, la entrada del teclado, los eventos del sistema que est√°n disponibles para la ejecuci√≥n de los delegados, etc. Por lo tanto, si tiene una instancia de <code>SynchronizationContext</code> para un subproceso de interfaz de usuario en una aplicaci√≥n de formularios Windows Forms, debe pasar el delegado al m√©todo <code>Post</code> para realizar una operaci√≥n en √©l. <br><br>  Windows Presentation Foundation (WPF) tambi√©n tiene un <a href="" rel="nofollow">tipo</a> derivado de <code>SynchronizationContext</code> con un m√©todo de <code>Post</code> anulado que de manera similar "dirige" al delegado a la secuencia de la interfaz de usuario (usando <code>Dispatcher.BeginInvoke</code> ), con el control WPF Dispatcher, no Windows Forms Control. <br><br>  Y Windows RunTime (WinRT) tiene su propio <a href="" rel="nofollow">tipo</a> derivado de <code>SynchronizationContext</code> , que tambi√©n coloca al delegado en la <code>CoreDispatcher</code> subprocesos de la interfaz de usuario utilizando <code>CoreDispatcher</code> . <br><br>  Esto es lo que hay detr√°s de la frase "ejecutar delegado en el hilo de la interfaz de usuario".  Tambi√©n puede implementar su <code>SynchronizationContext</code> con el m√©todo <code>Post</code> y alguna implementaci√≥n.  Por ejemplo, no tengo que preocuparme por el hilo en el que se est√° ejecutando el delegado, pero quiero asegurarme de que cualquier m√©todo <code>Post</code> delegado en mi <code>SynchronizationContext</code> ejecute con cierto grado de paralelismo limitado.  Puede implementar un <code>SynchronizationContext</code> personalizado de esta manera: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _semaphore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxConcurrencyLevel</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(maxConcurrencyLevel); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore.WaitAsync().ContinueWith(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskContinuationOptions.None, TaskScheduler.Default); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { _semaphore.Wait(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } } }</code> </pre> <br>  El marco xUnit tiene una <a href="" rel="nofollow">implementaci√≥n</a> similar <a href="" rel="nofollow">de</a> SynchronizationContext.  Aqu√≠ se usa para reducir la cantidad de c√≥digo asociado con las pruebas paralelas. <br><br>  Las ventajas aqu√≠ son las mismas que con cualquier abstracci√≥n: se proporciona una √∫nica API que puede usarse para poner en cola al delegado para su ejecuci√≥n de la manera que el programador lo desee, sin la necesidad de conocer los detalles de implementaci√≥n.  Supongamos que escribo una biblioteca donde necesito hacer algo de trabajo y luego vuelvo a poner un delegado en el contexto original.  Para hacer esto, necesito capturar su <code>SynchronizationContext</code> , y cuando complete lo que se necesita, solo tendr√© que llamar al m√©todo <code>Post</code> de este contexto y pasarle un delegado para su ejecuci√≥n.  No necesito saber que para Windows Forms necesitas tomar <code>Control</code> y usar su <code>BeginInvoke</code> , para WPF usar <code>BeginInvoke</code> de <code>Dispatcher</code> , o de alguna manera obtener el contexto y su cola para xUnit.  Todo lo que necesito hacer es tomar el <code>SynchronizationContext</code> actual y usarlo m√°s tarde.  Para hacer esto, el <code>SynchronizationContext</code> tiene una propiedad <code>Current</code> .  Esto se puede implementar de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action worker, Action completion</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; ThreadPool.QueueUserWorkItem(_ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { worker(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { sc.Post(_ =&gt; completion(), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }); }</code> </pre> <br>  Puede establecer un contexto especial desde la propiedad <code>Current</code> utilizando el m√©todo <code>SynchronizationContext.SetSynchronizationContext</code> . <br><br><h3>  ¬øQu√© es un programador de tareas? </h3><br>  <code>SynchronizationContext</code> es una abstracci√≥n com√∫n para el "planificador".  Algunos marcos usan sus propias abstracciones para ello, y <code>System.Threading.Tasks</code> no <code>System.Threading.Tasks</code> una excepci√≥n.  Cuando hay delegados en la <code>Task</code> que se pueden poner en cola y ejecutar, est√°n asociados con <code>System.Threading.Tasks.TaskScheduler</code> .  Tambi√©n hay un m√©todo <code>Post</code> virtual para poner en cola a un delegado (una llamada de delegado se implementa utilizando mecanismos est√°ndar), <code>TaskScheduler</code> proporciona un m√©todo abstracto <code>QueueTask</code> (una llamada de tarea se implementa usando el m√©todo <code>ExecuteTask</code> ). <br><br>  El planificador predeterminado que devuelve <code>TaskScheduler.Default</code> es un grupo de subprocesos.  Desde <code>TaskScheduler</code> tambi√©n es posible obtener y anular m√©todos para configurar la hora y el lugar de la llamada de la <code>Task</code> .  Por ejemplo, las bibliotecas principales incluyen el tipo <code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code> .  Una instancia de esta clase proporciona dos propiedades de <code>TaskScheduler</code> : <code>ExclusiveScheduler</code> y <code>ConcurrentScheduler</code> .  Las tareas programadas en el <code>ConcurrentScheduler</code> se pueden realizar en paralelo, pero teniendo en cuenta la restricci√≥n establecida por el <code>ConcurrentExclusiveSchedulerPair</code> cuando se crea (similar a <code>MaxConcurrencySynchronizationContext</code> ).  No se ejecutar√° ninguna tarea <code>ConcurrentScheduler</code> si la tarea se ejecuta en <code>ExclusiveScheduler</code> y solo se permite ejecutar una tarea exclusiva a la vez.  Este comportamiento es muy similar a un bloqueo de lectura / escritura. <br><br>  Al igual que <code>SynchronizationContext</code> , <code>TaskScheduler</code> tiene una propiedad <code>Current</code> que devuelve el <code>TaskScheduler</code> actual.  Sin embargo, a diferencia de <code>SynchronizationContext</code> , carece de un m√©todo para configurar el planificador actual.  En cambio, el planificador est√° asociado con la tarea actual.  Entonces, por ejemplo, este programa mostrar√° <code>True</code> , ya que la lambda utilizada en <code>StartNew</code> se ejecuta en la instancia <code>ExclusiveScheduler</code> de <code>ConcurrentExclusiveSchedulerPair</code> , y <code>TaskScheduler.Current</code> instalado en este programador: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cesp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentExclusiveSchedulerPair(); Task.Factory.StartNew(() =&gt; { Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler); }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskCreationOptions.None, cesp.ExclusiveScheduler).Wait(); } }</code> </pre> <br>  Curiosamente, <code>TaskScheduler</code> proporciona un m√©todo est√°tico <code>FromCurrentSynchronizationContext</code> .  El m√©todo crea un nuevo <code>TaskScheduler</code> y <code>TaskScheduler</code> en <code>TaskScheduler</code> las tareas para su ejecuci√≥n en el contexto <code>SynchronizationContext.Current</code> devuelto utilizando el m√©todo <code>Post</code> . <br><br><h3>  ¬øC√≥mo se relacionan el SynchronizationContext y TaskScheduler con wait? </h3><br>  Digamos que necesita escribir una aplicaci√≥n de IU con un bot√≥n.  Al presionar el bot√≥n, se inicia la descarga de texto del sitio web y se establece en el bot√≥n <code>Content</code> .  Solo se debe poder acceder al bot√≥n desde la interfaz de usuario de la transmisi√≥n en la que se encuentra, por lo tanto, cuando cargamos con √©xito la fecha y la hora y queremos colocarlos en el <code>Content</code> del bot√≥n, debemos hacerlo desde la transmisi√≥n que tiene control sobre √©l.  Si no se cumple esta condici√≥n, obtendremos una excepci√≥n: <br><br><pre> <code class="cs hljs">System.InvalidOperationException: <span class="hljs-string"><span class="hljs-string">'        ,     .'</span></span></code> </pre><br>  Podemos usar manualmente <code>SynchronizationContext</code> para establecer el <code>Content</code> en el contexto de origen, por ejemplo a trav√©s de <code>TaskScheduler</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { downloadBtn.Content = downloadTask.Result; }, TaskScheduler.FromCurrentSynchronizationContext()); }</code> </pre> <br>  Y podemos usar el <code>SynchronizationContext</code> directamente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { sc.Post(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { downloadBtn.Content = downloadTask.Result; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }</code> </pre> <br>  Sin embargo, ambas opciones usan expl√≠citamente una devoluci√≥n de llamada.  En cambio, podemos usar <code>async</code> / <code>await</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  Todo esto "simplemente funciona" y configura con √©xito el <code>Content</code> en el hilo de la interfaz de usuario, ya que en el caso de la versi√≥n implementada manualmente anterior, por defecto, la espera de una tarea se refiere a <code>SynchronizationContext.Current</code> y <code>TaskScheduler.Current</code> .  Cuando "espera" algo en C #, el compilador convierte el c√≥digo para sondeo (llamando a <code>GetAwaiter</code> ) "esperado" (en este caso, Tarea) a "esperando" ( <code>TaskAwaiter</code> ).  La "espera" es responsable de adjuntar una devoluci√≥n de llamada (a menudo llamada "continuaci√≥n") que vuelve a llamar a la m√°quina de estado cuando se completa la espera.  Implementa esto usando el contexto / planificador que captur√≥ durante el registro de devoluci√≥n de llamada.  Optimizaremos y configuraremos un poco, es algo como esto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; }</code> </pre> <br>  Aqu√≠, primero se verifica si <code>SynchronizationContext</code> y, si no, si <code>TaskScheduler</code> no est√°ndar.  Si hay uno, entonces cuando la devoluci√≥n de llamada est√© lista para la llamada, se utilizar√° el planificador capturado;  si no, la devoluci√≥n de llamada se ejecutar√° como parte de la operaci√≥n que completa la tarea esperada. <br><br><h3>  ¬øQu√© hace ConfigureAwait (falso)? </h3><br>  El m√©todo <code>ConfigureAwait</code> no es especial: el compilador o el tiempo de ejecuci√≥n no lo reconocen de ninguna manera en particular.  Este es un m√©todo normal que devuelve una estructura ( <code>ConfiguredTaskAwaitable</code> - ajusta la tarea original) y toma un valor booleano.  Recuerde que <code>await</code> puede usarse con cualquier tipo que implemente el patr√≥n correcto.  Si se devuelve otro tipo, significa que cuando el compilador obtiene acceso al m√©todo <code>GetAwaiter</code> (parte del patr√≥n) de las instancias, pero lo hace desde el tipo devuelto por <code>ConfigureAwait</code> y no desde la tarea directamente.  Esto le permite cambiar el comportamiento de <code>await</code> para este camarero especial. <br><br>  Esperar el tipo devuelto por <code>ConfigureAwait(continueOnCapturedContext: false)</code> lugar de esperar <code>Task</code> afecta directamente la implementaci√≥n de captura de contexto / planificador discutida anteriormente.  La l√≥gica se convierte en algo como esto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (continueOnCapturedContext) { scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; } }</code> </pre> <br>  En otras palabras, especificar <code>false</code> , incluso si hay un contexto actual o un planificador para la devoluci√≥n de llamada, implica que est√° ausente. <br><br><h3>  ¬øPor qu√© necesito usar ConfigureAwait (falso)? </h3><br>  <code>ConfigureAwait(continueOnCapturedContext: false)</code> usa para evitar que la devoluci√≥n de llamada se vea obligada a llamar en el contexto de origen o el planificador.  Esto nos da varias ventajas: <br><br>  <b>Mejora de rendimiento.</b>  Hay una sobrecarga de poner en cola una devoluci√≥n de llamada, a diferencia de solo llamar, ya que esto requiere un trabajo adicional (y generalmente una asignaci√≥n adicional).  Adem√°s, no podemos usar la optimizaci√≥n en tiempo de ejecuci√≥n (podemos optimizar m√°s cuando sabemos exactamente c√≥mo se llamar√° la devoluci√≥n de llamada, pero si se pasa a una implementaci√≥n arbitraria de abstracci√≥n, a veces esto impone restricciones).  Para secciones muy cargadas, incluso los costos adicionales de verificar el <code>SynchronizationContext</code> actual y el <code>TaskScheduler</code> actual (que implican acceso a las estad√≠sticas de flujo) pueden aumentar significativamente la sobrecarga.  Si el c√≥digo despu√©s de <code>await</code> no requiere ejecuci√≥n en el contexto original, usando <code>ConfigureAwait(false)</code> , se pueden evitar todos estos gastos, ya que no es necesario ponerlo en cola innecesariamente, puede usar todas las optimizaciones disponibles y tambi√©n puede evitar el acceso innecesario a las estad√≠sticas de flujo. <br><br>  <b>Prevenci√≥n de punto muerto.</b>  Considere el m√©todo de biblioteca que <code>await</code> usar para descargar algo de la red.  Llama a este m√©todo y bloquea sincr√≥nicamente, esperando que la tarea se complete, por ejemplo, usando <code>.Wait()</code> o <code>.Result</code> o <code>.GetAwaiter()</code> <code>.GetResult()</code> .  Ahora considere lo que sucede si la llamada ocurre cuando el <code>SynchronizationContext</code> actual limita el n√∫mero de operaciones a 1 expl√≠citamente usando <code>MaxConcurrencySynchronizationContext</code> , o impl√≠citamente, si es un contexto con un solo subproceso para usar (por ejemplo, un subproceso de interfaz de usuario).  Por lo tanto, llama al m√©todo en un solo hilo y luego lo bloquea, esperando que se complete la operaci√≥n.  La descarga comienza a trav√©s de la red y espera su finalizaci√≥n.  Por defecto, esperar una <code>Task</code> capturar√° el <code>SynchronizationContext</code> actual (y en este caso), y cuando se complete la descarga de la red, se pondr√° en cola nuevamente en la devoluci√≥n de llamada <code>SynchronizationContext</code> , que llamar√° al resto de la operaci√≥n.  Pero el √∫nico hilo que puede manejar la devoluci√≥n de llamada en la cola est√° actualmente bloqueado mientras espera que se complete la operaci√≥n.  Y esta operaci√≥n no se completar√° hasta que se procese la devoluci√≥n de llamada.  Punto muerto!  Puede ocurrir incluso cuando el contexto no limita la concurrencia a 1, pero los recursos est√°n limitados de alguna manera.  Imagine la misma situaci√≥n, solo con un valor de 4 para <code>MaxConcurrencySynchronizationContext</code> .  En lugar de ejecutar la operaci√≥n una vez, ponemos en cola 4 llamadas al contexto.  Cada llamada se realiza y se bloquea antes de su finalizaci√≥n.  Todos los recursos ahora est√°n bloqueados esperando la finalizaci√≥n de los m√©todos asincr√≥nicos, y lo √∫nico que les permitir√° completar es si sus devoluciones de llamada son procesadas por este contexto.  Sin embargo, √©l ya est√° completamente ocupado.  Punto muerto de nuevo.  Si el m√©todo de la biblioteca utilizara <code>ConfigureAwait(false)</code> lugar, no pondr√≠a en cola la devoluci√≥n de llamada al contexto original, lo que evitar√≠a los scripts de punto muerto. <br><br><h3>  ¬øNecesito usar ConfigureAwait (verdadero)? </h3><br>  No, a menos que necesite indicar expl√≠citamente que no est√° utilizando <code>ConfigureAwait(false)</code> (por ejemplo, para ocultar advertencias de an√°lisis est√°tico, etc.).  <code>ConfigureAwait(true)</code> no hace nada significativo.  Si compara <code>await task</code> y <code>await task.ConfigureAwait(true)</code> , ser√°n funcionalmente id√©nticos.  Por lo tanto, si <code>ConfigureAwait(true)</code> presente en el c√≥digo, se puede eliminar sin consecuencias negativas. <br><br>  El m√©todo <code>ConfigureAwait</code> toma un valor booleano, ya que en algunas situaciones puede necesitar pasar una variable para controlar la configuraci√≥n.  Pero en el 99% de los casos, el valor se establece en falso, <code>ConfigureAwait(false)</code> . <br><br><h3>  ¬øCu√°ndo usar ConfigureAwait (falso)? </h3><br>  Depende de si implementa c√≥digo de nivel de aplicaci√≥n o c√≥digo de biblioteca de prop√≥sito general. <br><br>  Al escribir aplicaciones, generalmente se requiere alg√∫n comportamiento predeterminado.  Si el modelo / entorno de la aplicaci√≥n (por ejemplo, Windows Forms, WPF, ASP.NET Core) publica un <code>SynchronizationContext</code> especial, es casi seguro que hay una buena raz√≥n para esto: significa que el c√≥digo le permite cuidar el contexto de sincronizaci√≥n para una interacci√≥n adecuada con el modelo / entorno de la aplicaci√≥n.  Por ejemplo, si escribe un controlador de eventos en una aplicaci√≥n Windows Forms, una prueba en xUnit o un c√≥digo en un controlador ASP.NET MVC, independientemente de si el modelo de la aplicaci√≥n ha publicado un <code>SynchronizationContext</code> , debe usar <code>SynchronizationContext</code> si existe.  Esto significa que si <code>await</code> <code>ConfigureAwait(true)</code> y <code>await</code> , las devoluciones de llamada / continuaciones se env√≠an de vuelta al contexto original; todo sale como deber√≠a.  Desde aqu√≠ puede formular una regla general: <b>si escribe c√≥digo a nivel de aplicaci√≥n, <i>no use</i> <code>ConfigureAwait(false)</code></b> .  Volvamos al controlador de clics: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  <code>downloadBtn.Content = text</code> debe ejecutarse en el contexto original.  Si el c√≥digo viol√≥ esta regla y us√≥ <code>ConfigureAwait (false)</code> lugar, entonces no se usar√° en el contexto original: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  downloadBtn.Content = text; }</span></span></code> </pre> <br>  Esto conducir√° a un comportamiento inapropiado.  Lo mismo se aplica al c√≥digo en una aplicaci√≥n ASP.NET cl√°sica que depende de <code>HttpContext.Current</code> .  Cuando se utiliza <code>ConfigureAwait(false)</code> es probable que <code>ConfigureAwait(false)</code> intento posterior de utilizar la funci√≥n <code>Context.Current</code> problemas. <br><br>  Esto es lo que distingue a las bibliotecas de uso general.  Son universales en parte porque no les importa el entorno en el que se utilizan.  Puede usarlos desde una aplicaci√≥n web, desde una aplicaci√≥n cliente o desde una prueba, no importa, ya que el c√≥digo de la biblioteca es independiente del modelo de aplicaci√≥n en el que se puede usar.  Agn√≥stico tambi√©n significa que la biblioteca no har√° nada para interactuar con el modelo de aplicaci√≥n, por ejemplo, no obtendr√° acceso a los controles de la interfaz de usuario, porque la biblioteca de prop√≥sito general no sabe nada sobre ellos.  Dado que no hay necesidad de ejecutar el c√≥digo en ning√∫n entorno en particular, podemos evitar forzar las continuaciones / devoluciones de llamada para que se vean obligadas al contexto original, y lo hacemos utilizando <code>ConfigureAwait(false)</code> , que nos brinda ventajas de rendimiento y aumenta la confiabilidad.  Esto nos lleva a lo siguiente: <b>si est√° escribiendo un c√≥digo de biblioteca de uso general, use <code>ConfigureAwait(false)</code></b> .  Esta es la raz√≥n por la cual todos (o casi todos) esperan en las bibliotecas de tiempo de ejecuci√≥n de .NET Core usan ConfigureAwait (falso);  Con algunas excepciones, que probablemente sean errores, se corregir√°n.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, </font></font><a href="https://github.com/dotnet/corefx/pull/38610" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el PR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> corregido ninguna llamada </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>HttpClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esto no tiene sentido en todas partes. Por ejemplo, una de las grandes excepciones (o al menos casos en los que necesita pensarlo) en las bibliotecas de uso general es cuando estas bibliotecas tienen API que aceptan delegados a una llamada. En tales casos, la biblioteca acepta c√≥digo potencial de nivel de aplicaci√≥n de la persona que llama, lo que hace que estas suposiciones para la biblioteca de prop√≥sito general sean muy controvertidas. Imagine, por ejemplo, la versi√≥n asincr√≥nica del m√©todo Where LINQ: </font></font><code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øDeber√≠a </font></font><code>predicate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamarse en la fuente del c√≥digo de </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamada? </font></font><code>WhereAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y esta es la raz√≥n por la que puede decidir no usar </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso en casos especiales, siga la recomendaci√≥n general: util√≠cela </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si est√° escribiendo un c√≥digo agn√≥stico de biblioteca / aplicaci√≥n-modelo-prop√≥sito general.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øConfigureAwait (falso) garantiza que la devoluci√≥n de llamada no se ejecutar√° en el contexto original? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No, esto garantiza que no se colocar√° en la cola del contexto original. </font><font style="vertical-align: inherit;">Pero esto no significa que el c√≥digo posterior </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se ejecutar√° en el contexto original. </font><font style="vertical-align: inherit;">Esto se debe al hecho de que las operaciones ya completadas se devuelven sincr√≥nicamente y no se devuelven forzosamente a la cola. </font><font style="vertical-align: inherit;">Por lo tanto, si espera una tarea que ya se complet√≥ en el momento en que espera, independientemente de si la est√° utilizando </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el c√≥digo inmediatamente posterior continuar√° ejecut√°ndose en el hilo actual en un contexto que todav√≠a es v√°lido.</font></font><br><br><h3>    ConfigureAwait (false)       ,    ‚Äî ? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, no. Recuerda las preguntas frecuentes anteriores. Si </font></font><code>await task.ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incluye una tarea que ya se complet√≥ en el momento de la espera (que en realidad sucede con bastante frecuencia), el uso no </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tendr√° sentido, ya que el hilo contin√∫a ejecutando el siguiente c√≥digo en el m√©todo y todav√≠a est√° en el mismo contexto que antes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una excepci√≥n notable es que la primera </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre terminar√° de forma asincr√≥nica, y la operaci√≥n esperada lo devolver√° en un entorno libre de especiales </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por ejemplo, </font></font><code>CryptoStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en las bibliotecas de tiempo de ejecuci√≥n, .NET verifica que su c√≥digo potencialmente computacionalmente intensivo no se ejecute como parte de una invocaci√≥n s√≠ncrona del c√≥digo de llamada. Para hacer esto, usa un especial</font></font><code><a href="" rel="nofollow">awaiter</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para asegurarse de que el c√≥digo despu√©s de la primera espera se ejecute en el subproceso del grupo de subprocesos. </font><font style="vertical-align: inherit;">Sin embargo, incluso en este caso, notar√° que la pr√≥xima espera todav√≠a est√° en uso </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">T√©cnicamente, esto no es necesario, pero simplifica enormemente la revisi√≥n del c√≥digo, ya que no es necesario entender por qu√© no se us√≥ </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øEs posible usar Task.Run para evitar usar ConfigureAwait (falso)? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si, si escribes: </font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//     });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entonces </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>SomethingAsync()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° superfluo, ya que el delegado pasado </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se ejecutar√° en el subproceso del grupo de subprocesos, de modo que sin cambiar el c√≥digo anterior, </font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolver√° un valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Adem√°s, </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza impl√≠citamente </font></font><code>TaskScheduler.Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo tanto, </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro del delegado tambi√©n devolver√° un valor </font></font><code>Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto significa que </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tendr√° el mismo comportamiento independientemente de si se utiliz√≥ </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tampoco puede garantizar lo que puede hacer el c√≥digo dentro de este lambda. Si tienes un c√≥digo:</font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { SynchronizationContext.SetSynchronizationContext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeCoolSyncCtx()); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//    SomeCoolSyncCtx });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entonces el c√≥digo dentro </font></font><code>SomethingAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver√° realmente la </font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instancia </font></font><code>SomeCoolSyncCtx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. y esto </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y cualquier expectativa no configurada dentro de SomethingAsync se devolver√° a este contexto. Por lo tanto, para utilizar este enfoque, es necesario comprender qu√© puede hacer o no todo el c√≥digo que coloca en la cola, y si sus acciones pueden convertirse en un obst√°culo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este enfoque tambi√©n ocurre debido a la necesidad de crear / poner en cola un objeto de tarea adicional. Esto puede o no importar a la aplicaci√≥n / biblioteca, dependiendo de los requisitos de rendimiento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n tenga en cuenta que tales soluciones pueden causar m√°s problemas que beneficios y tener diferentes consecuencias no deseadas. </font><font style="vertical-align: inherit;">Por ejemplo, algunas herramientas de an√°lisis est√°tico </font></font><code>ConfigureAwait(false)</code> <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se√±alan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expectativas que no usan </font><a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow"><font style="vertical-align: inherit;">CA2007</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si enciende el analizador y luego usa un truco para evitar su uso </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, existe una alta probabilidad de que el analizador lo marque. </font><font style="vertical-align: inherit;">Esto puede implicar a√∫n m√°s trabajo, por ejemplo, es posible que desee deshabilitar el analizador debido a su importancia, y esto implicar√° omitir otros lugares en la base del c√≥digo donde realmente necesita usarlo </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øEs posible usar SynchronizationContext.SetSynchronizationContext para evitar usar ConfigureAwait (false)? </font></font></h3><br>  No<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque es posible. </font><font style="vertical-align: inherit;">Depende de la implementaci√≥n utilizada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos desarrolladores hacen esto:</font></font><br><br><pre> <code class="cs hljs">Task t; SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { t = CallCodeThatUsesAwaitAsync(); <span class="hljs-comment"><span class="hljs-comment">// await'      } finally { SynchronizationContext.SetSynchronizationContext(old); } await t; //  -    </span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con la esperanza de que esto obligue al c√≥digo interno a </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver el contexto actual como </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As√≠ ser√°. </font><font style="vertical-align: inherit;">Sin embargo, esta opci√≥n no afectar√° a cu√°l </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ve </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, si el c√≥digo se ejecuta en un especial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, su </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interior </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver√° y har√° cola para ese especial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que en las </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preguntas frecuentes, las mismas advertencias se aplican aqu√≠: hay ciertas consecuencias de este enfoque, y el c√≥digo dentro del bloque </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n puede interferir con estos intentos al establecer un contexto diferente (o llamar al c√≥digo usando un programador de tareas no est√°ndar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con esta plantilla, tambi√©n debe tener cuidado con los cambios menores:</font></font><br><br><pre> <code class="cs hljs">SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { SynchronizationContext.SetSynchronizationContext(old); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øVes cu√°l es el problema? </font><font style="vertical-align: inherit;">Un poco dif√≠cil de notar, pero es impresionante. </font><font style="vertical-align: inherit;">No hay garant√≠a de que la espera eventualmente cause una devoluci√≥n de llamada / contin√∫e en el hilo original. </font><font style="vertical-align: inherit;">Esto significa que el retorno </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al original puede no ocurrir en el hilo original, lo que puede llevar al hecho de que los elementos de trabajo posteriores en este hilo ver√°n el contexto incorrecto. </font><font style="vertical-align: inherit;">Para contrarrestar esto, los modelos de aplicaci√≥n bien escritos que especifican un contexto especial suelen agregar c√≥digo para restablecerlo manualmente antes de llamar a cualquier c√≥digo personalizado adicional. </font><font style="vertical-align: inherit;">E incluso si esto sucede en un subproceso, puede llevar un tiempo durante el cual el contexto puede no restaurarse correctamente. </font><font style="vertical-align: inherit;">Y si funciona en un hilo diferente, esto puede conducir a la instalaci√≥n del contexto incorrecto.</font></font> Y as√≠ sucesivamente.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bastante lejos del ideal. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øDebo usar ConfigureAwait (false) si uso GetAwaiter () .GetResult ()? </font></font></h3><br>  No <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afecta solo las devoluciones de llamada. </font><font style="vertical-align: inherit;">En particular, la plantilla </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere que </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proporcione la propiedad </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, los m√©todos </font></font><code>GetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(opcionalmente con el m√©todo UnsafeOnCompleted). </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo afecta el comportamiento </font></font><code>{Unsafe}OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que si llama directamente </font></font><code>GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, independientemente de si lo hace </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o no </font></font><code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay diferencia en el comportamiento. </font><font style="vertical-align: inherit;">Por lo tanto, si ve </font></font><code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que puede reemplazarlo con </font></font><code>task.GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(adem√°s, piense si realmente necesita dicha implementaci√≥n).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√© que el c√≥digo se ejecuta en un entorno en el que nunca habr√° un SynchronizationContext especial o un TaskScheduler especial. </font><font style="vertical-align: inherit;">¬øNo puedo usar ConfigureAwait (falso)?</font></font></h3><br>  Posiblemente<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depende de qu√© tan seguro est√© de "nunca". </font><font style="vertical-align: inherit;">Como se mencion√≥ en las preguntas anteriores, solo porque el modelo de la aplicaci√≥n en la que est√° trabajando no especifica uno especial </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no llama a su c√≥digo en </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno </font><font style="vertical-align: inherit;">especial </font><font style="vertical-align: inherit;">no significa que el c√≥digo de otro usuario o biblioteca no los use. </font><font style="vertical-align: inherit;">Por lo tanto, debe estar seguro de esto, o al menos reconocer el riesgo de que tal opci√≥n sea posible.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escuch√© que en .NET Core no hay necesidad de aplicar ConfigureAwait (falso). </font><font style="vertical-align: inherit;">Es asi?</font></font></h3><br>  No asi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es necesario cuando se trabaja en .NET Core por las mismas razones que cuando se trabaja en .NET Framework. Nada ha cambiado a este respecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ha cambiado si ciertos entornos publican los suyos </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En particular, mientras que ASP.NET cl√°sico en .NET Framework tiene el suyo </font></font><code><a href="" rel="nofollow">SynchronizationContext</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ASP.NET Core no lo tiene. Esto significa que el c√≥digo que se ejecuta en la aplicaci√≥n ASP.NET Core no ver√° un c√≥digo especial de forma predeterminada </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que reduce la necesidad </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de este entorno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esto no significa que nunca habr√° una costumbre </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si alg√∫n c√≥digo de usuario (u otro c√≥digo de biblioteca utilizado por la aplicaci√≥n) establece el contexto del usuario y llama a su c√≥digo o llama a su c√≥digo en la Tarea programada en el programador de tareas especial, entonces </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASP.NET Core ver√° un contexto o programador no est√°ndar, lo cual puede requerir uso </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por supuesto, en situaciones en las que evita los bloqueos sincr√≥nicos (lo que debe hacer en las aplicaciones web de todos modos) y si no est√° en contra de la peque√±a sobrecarga de rendimiento en algunos casos, puede hacerlo sin usar </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øPuedo usar ConfigureAwait cuando "espero a que foreach se complete" en IAsyncEnumerable? </font></font></h3><br>  Si<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consulte el </font></font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo de MSDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ver </font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;">un</font></a><font style="vertical-align: inherit;"> ejemplo </font><font style="vertical-align: inherit;">. </font></font><br><br> <code>Await foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coincide con el patr√≥n y, por lo tanto, se puede usar para enumerar </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambi√©n se puede usar para enumerar elementos que representan el alcance correcto de la API. </font><font style="vertical-align: inherit;">bibliotecas de ejecuci√≥n .NET incluyen un m√©todo </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de expansi√≥n</font></font></a> <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelve un tipo especial, que se envuelve </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se corresponde con la plantilla correcta. </font><font style="vertical-align: inherit;">Cuando el compilador genera llamadas </font></font><code>MoveNextAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y al </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enumerador. </font><font style="vertical-align: inherit;">Estas llamadas est√°n relacionadas con el tipo de estructura de enumerador configurado devuelto, que a su vez cumple las expectativas seg√∫n sea necesario.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øPuedo usar ConfigureAwait con 'await using' IAsyncDisposable? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√≠, aunque con una peque√±a complicaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, biblioteca .NET de tiempo de ejecuci√≥n proporciona un m√©todo de extensi√≥n </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y </font></font><code>await using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona muy bien, ya que implementa la plantilla adecuada (es decir, proporciona un m√©todo correspondiente </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema aqu√≠ es que el tipo </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora no lo es </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sino que es el </font></font><code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelve el m√©todo de extensi√≥n </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar esto, agregue la l√≠nea:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (c.ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el tipo es </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevamente deseado </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo que tambi√©n tiene el efecto de aumentar el alcance de </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">si es necesario, puede envolverlo todo entre llaves.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Us√© ConfigureAwait (falso), pero mi AsyncLocal todav√≠a flu√≠a en el c√≥digo despu√©s de esperar. </font><font style="vertical-align: inherit;">¬øEs esto un error?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No, esto es bastante esperado. </font><font style="vertical-align: inherit;">El flujo de datos </font></font><code>AsyncLocal&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una parte </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separada de </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si no lo hace de forma expl√≠cita corriente desconectada </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizando </font></font><code>ExecutionContext.SuppressFlow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(y por lo tanto los datos </font></font><code>AsyncLocal &lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) siempre va a pasar a trav√©s </font></font><code>awaits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, independientemente de si se utiliza </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el fin de evitar la captura de la fuente </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">M√°s detalles se discuten en este </font></font><a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øPueden las herramientas de lenguaje ayudarme a evitar la necesidad de usar expl√≠citamente ConfigureAwait (falso) en mi biblioteca? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los desarrolladores de bibliotecas a veces se quejan de la necesidad de usar </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y piden alternativas menos invasivas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualmente no lo son, al menos no est√°n integrados en el lenguaje / compilador / tiempo de ejecuci√≥n. </font><font style="vertical-align: inherit;">Sin embargo, hay muchas sugerencias sobre c√≥mo se puede implementar esto, por ejemplo: </font></font><a href="https://github.com/dotnet/csharplang/issues/645" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2542" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2649" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2746" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el tema que le interesa, si tiene ideas nuevas e interesantes, el autor del </font></font><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo original lo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> invita a una discusi√≥n.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482354/">https://habr.com/ru/post/482354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482336/index.html">Los comerciantes tienen acceso a conferencias de prensa del Banco Central de Inglaterra antes de su transmisi√≥n p√∫blica</a></li>
<li><a href="../482338/index.html">Visual Studio para Mac: controle su IDE con teclas</a></li>
<li><a href="../482340/index.html">De Junior'a a Middle'a: analizador</a></li>
<li><a href="../482344/index.html">Prep√°rese para la introducci√≥n de una calificaci√≥n social en Rusia</a></li>
<li><a href="../482348/index.html">Topolog√≠a y an√°lisis exhaustivo para un desarrollador de juegos desprevenido: comprimir vectores 3D √∫nicos</a></li>
<li><a href="../482356/index.html">Usar Windows Server sin explorador desde el punto de vista de un usuario normal de Windows</a></li>
<li><a href="../482360/index.html">Detective Habra: son amigos de los ovnis</a></li>
<li><a href="../482362/index.html">Casi anarqu√≠a: una breve historia de Fidonet, un proyecto que no le importa ganar en Internet</a></li>
<li><a href="../482364/index.html">Cosas que [tal vez] no sab√≠as sobre Java</a></li>
<li><a href="../482366/index.html">¬øQu√© piensan los expertos en autom√≥viles rob√≥ticos sobre el piloto autom√°tico Tesla?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>