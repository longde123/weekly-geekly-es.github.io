<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛅️ 👩🏻‍🌾 👰🏿 Sematkan analisis statis ke dalam proses, bukan cari bug dengan itu 👇🏽 🦑 🌕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya diminta untuk menulis artikel ini dengan sejumlah besar bahan tentang analisis statis, yang semakin sering menarik perhatian saya. Pertama, ini a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sematkan analisis statis ke dalam proses, bukan cari bug dengan itu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436868/"> Saya diminta untuk menulis artikel ini dengan sejumlah besar bahan tentang analisis statis, yang semakin sering menarik perhatian saya.  Pertama, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog PVS-studio</a> , yang secara aktif mempromosikan dirinya di Habré dengan bantuan ulasan kesalahan yang ditemukan oleh alat mereka dalam proyek-proyek open source.  Baru-baru ini, studio-PVS mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan untuk Java</a> , dan, tentu saja, para pengembang IntelliJ IDEA, yang penganalisis bawaannya mungkin yang paling canggih untuk Jawa saat ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak bisa menjauh</a> . <br><br>  Saat membaca ulasan semacam itu, ada perasaan bahwa kita berbicara tentang ramuan ajaib: klik tombolnya, dan ini dia - daftar cacat di depan mata Anda.  Tampaknya seiring dengan peningkatan analisis, semakin banyak bug akan secara otomatis ditemukan, dan produk yang dipindai oleh robot ini akan menjadi lebih baik dan lebih baik, tanpa upaya dari pihak kami. <br><br>  Tetapi tidak ada ramuan ajaib.  Saya ingin berbicara tentang sesuatu yang biasanya tidak disebutkan dalam posting seperti "ini adalah hal-hal yang dapat ditemukan robot kami": apa yang tidak dapat dilakukan oleh analis, apa peran dan tempat sebenarnya mereka dalam proses pengiriman perangkat lunak, dan bagaimana menerapkannya dengan benar. <br><br><img src="https://habrastorage.org/webt/ey/2o/ta/ey2otantl8aitotp4_lojjuscn4.png" width="500"><br>  <i>Ratchet (sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> ).</i> <br><a name="habracut"></a><br><h2>  Apa analisa statis tidak akan pernah bisa </h2><br>  Apa, dari sudut pandang praktis, analisis kode sumber?  Kami mengirimkan beberapa sumber ke input, dan pada output dalam waktu singkat (jauh lebih pendek daripada uji coba) kami mendapatkan beberapa informasi tentang sistem kami.  Keterbatasan mendasar dan matematis tidak dapat diatasi adalah bahwa kita hanya bisa mendapatkan kelas informasi yang agak sempit dengan cara ini. <br><br>  Contoh paling terkenal dari masalah yang tidak dapat diselesaikan dengan bantuan analisis statis adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah shutdown</a> : ini adalah teorema yang membuktikan bahwa tidak mungkin untuk mengembangkan algoritma umum yang akan ditentukan oleh kode sumber suatu program apakah akan berulang atau berakhir dalam waktu yang terbatas.  Perpanjangan teorema ini adalah teorema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rice,</a> yang menyatakan bahwa untuk properti non-sepele dari fungsi yang dapat dihitung, menentukan apakah program arbitrer menghitung fungsi dengan properti ini adalah masalah algoritmik yang tidak dapat dipecahkan.  Sebagai contoh, adalah mustahil untuk menulis analisa yang ditentukan oleh kode sumber apa saja apakah program yang dianalisis adalah implementasi dari algoritma yang menghitung, katakanlah, kuadrat dari sebuah integer. <br><br>  Dengan demikian, fungsi analisis statis memiliki keterbatasan yang tidak dapat diatasi.  Dalam semua kasus, penganalisa statis tidak akan pernah dapat menentukan hal-hal seperti, misalnya, terjadinya "pengecualian penunjuk nol" dalam bahasa yang dapat dibatalkan, atau dalam semua kasus, menentukan terjadinya "atribut tidak ditemukan" dalam bahasa yang diketik secara dinamis.  Yang dapat dilakukan oleh penganalisa statis paling canggih adalah menyoroti kasus-kasus tertentu, yang jumlah di antara semua masalah yang mungkin terjadi dengan kode sumber Anda adalah, tanpa berlebihan, setetes dalam ember. <br><br><h2>  Analisis statis bukanlah pencarian bug </h2><br>  Kesimpulannya mengikuti dari uraian di atas: analisis statis bukan cara mengurangi jumlah cacat dalam suatu program.  Saya akan menyatakan: ketika pertama kali diterapkan pada proyek Anda, ia akan menemukan tempat "sibuk" dalam kode, tetapi kemungkinan besar tidak akan menemukan cacat yang memengaruhi kualitas program Anda. <br><br>  Contoh-contoh cacat yang ditemukan secara otomatis oleh analisis sangat mengesankan, tetapi kita tidak boleh lupa bahwa contoh-contoh ini ditemukan dengan memindai sekumpulan basis kode besar.  Dengan prinsip yang sama, cracker dengan kemampuan untuk menyebutkan beberapa kata sandi sederhana pada sejumlah besar akun akhirnya menemukan akun-akun yang memiliki kata sandi sederhana. <br><br>  Apakah ini berarti bahwa analisis statis tidak perlu diterapkan?  Tentu tidak!  Dan untuk alasan yang sama persis, ada baiknya memeriksa setiap kata sandi baru untuk sampai ke daftar berhenti kata sandi "sederhana". <br><br><h2>  Analisis statis lebih dari pencarian bug </h2><br>  Faktanya, tugas-tugas yang secara praktis diselesaikan dengan analisis jauh lebih luas.  Memang, secara umum, analisis statis adalah setiap verifikasi sumber yang dilakukan sebelum diluncurkan.  Berikut beberapa hal yang dapat Anda lakukan: <br><br><ul><li>  Verifikasi gaya pengkodean dalam arti luas.  Ini termasuk memeriksa pemformatan, dan mencari penggunaan tanda kurung kosong / ekstra, menetapkan nilai ambang untuk metrik seperti jumlah baris / kompleksitas siklomatik dari metode, dll. - semua itu berpotensi menyebabkan kode sulit dibaca dan dipelihara.  Di Jawa alat seperti itu adalah Checkstyle, dengan Python - flake8.  Program kelas ini biasanya disebut linter. </li><li>  Tidak hanya kode yang dapat dieksekusi yang dapat dianalisis.  File sumber daya seperti JSON, YAML, XML, .properties dapat (dan seharusnya!) Secara otomatis diperiksa validitasnya.  Lagipula, lebih baik untuk mengetahui bahwa karena beberapa kutipan tidak berpasangan, struktur JSON dilanggar pada tahap awal pemeriksaan Permintaan Tarik otomatis daripada saat menjalankan tes atau dalam waktu Jalankan?  Alat yang relevan tersedia: misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YAMLlint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSONLint</a> . </li><li>  Kompilasi (atau parsing untuk bahasa pemrograman dinamis) juga merupakan bentuk analisis statis.  Sebagai aturan, kompiler dapat mengeluarkan peringatan masalah pensinyalan dengan kualitas kode sumber, dan mereka tidak boleh diabaikan. </li><li>  Terkadang kompilasi tidak hanya kompilasi kode yang dapat dieksekusi.  Misalnya, jika Anda memiliki dokumentasi dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AsciiDoctor</a> , maka pada saat mengubahnya menjadi HTML / PDF, pawang AsciiDoctor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin Maven</a> ) dapat memberikan peringatan, misalnya, tentang tautan internal yang terputus.  Dan ini adalah alasan bagus untuk tidak menerima Permintaan Tarik dengan perubahan pada dokumentasi. </li><li>  Pemeriksaan ejaan juga merupakan bentuk analisis statis.  Utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aspell</a> mampu memeriksa ejaan tidak hanya dalam dokumentasi, tetapi juga dalam kode sumber program (komentar dan literal) dalam berbagai bahasa pemrograman, termasuk C / C ++, Java dan Python.  Kesalahan pengejaan di antarmuka pengguna atau dokumentasi juga cacat! </li><li>  Tes konfigurasi (untuk apa - lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dan laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> ), meskipun dijalankan dalam lingkungan runtime untuk tes unit seperti pytest, sebenarnya juga merupakan semacam analisis statis, karena mereka tidak mengeksekusi kode sumber selama pelaksanaannya . </li></ul><br>  Seperti yang Anda lihat, pencarian bug dalam daftar ini mengambil peran paling tidak penting, dan semua yang lain tersedia melalui penggunaan alat open source gratis. <br><br>  Manakah dari jenis analisis statis yang harus digunakan dalam proyek Anda?  Tentu saja, semuanya, semakin banyak - semakin baik!  Hal utama adalah mengimplementasikannya dengan benar, yang akan dibahas lebih lanjut. <br><br><h2>  Jalur pengiriman sebagai filter multi-tahap dan analisis statis sebagai kaskade pertama </h2><br>  Metafora klasik untuk integrasi berkelanjutan adalah jalur pipa melalui mana perubahan mengalir - dari mengubah kode sumber hingga dikirim ke produksi.  Urutan standar langkah-langkah dalam pipa ini adalah sebagai berikut: <br><br><ol><li>  analisis statis </li><li>  kompilasi </li><li>  tes unit </li><li>  tes integrasi </li><li>  Tes UI </li><li>  cek manual </li></ol><br>  Perubahan yang ditolak pada tahap N konveyor tidak ditransfer ke tahap N +1. <br><br>  Kenapa begitu, dan bukan sebaliknya?  Di bagian pengujian pipa, penguji mengenali piramida pengujian yang terkenal. <br><br><img src="https://habrastorage.org/webt/hr/41/ut/hr41utwuuzfwoe_3pkr6xm7rcwo.png" width="400"><br>  <i>Tes piramida.</i>  <i>Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> Martin Fowler.</i> <br><br>  Di bagian bawah piramida ini terdapat tes yang lebih mudah ditulis, yang lebih cepat dieksekusi dan tidak memiliki kecenderungan positif palsu.  Karena itu, harus ada lebih banyak, mereka harus mencakup lebih banyak kode dan dieksekusi terlebih dahulu.  Di bagian atas piramida, semuanya adalah sebaliknya, sehingga jumlah tes integrasi dan UI harus dikurangi ke minimum yang diperlukan.  Orang dalam rantai ini adalah sumber daya yang paling mahal, lambat, dan tidak dapat diandalkan, sehingga ia berada di ujung dan melakukan pekerjaan hanya jika langkah sebelumnya tidak menunjukkan adanya cacat.  Namun, sesuai dengan prinsip yang sama, konveyor dibangun di bagian yang tidak terkait langsung dengan pengujian! <br><br>  Saya ingin menawarkan analogi dalam bentuk sistem penyaringan air multi-tahap.  Air kotor (perubahan dengan cacat) disuplai ke pintu masuk, di pintu keluar kita harus mendapatkan air bersih, di mana semua polusi yang tidak diinginkan dihilangkan. <br><br><img src="https://habrastorage.org/webt/nf/2n/gi/nf2ngidmm_2_aaiye4c52ol0fr0.jpeg" width="400"><br>  <i>Filter bertingkat.</i>  <i>Sumber: <a href="">Wikimedia Commons</a></i> <br><br>  Seperti yang Anda ketahui, filter pembersih dirancang sehingga setiap kaskade berikutnya dapat menyaring sebagian kecil kontaminan.  Pada saat yang sama, kaskade yang lebih kasar memiliki throughput yang lebih besar dan biaya yang lebih rendah.  Dalam analogi kami, ini berarti bahwa gerbang kualitas masukan memiliki kecepatan yang lebih besar, membutuhkan lebih sedikit usaha untuk memulai dan mereka sendiri lebih bersahaja dalam pekerjaan mereka - dan dalam urutan inilah mereka dibangun.  Peran analisis statis, yang, seperti yang sekarang kita pahami, mampu menyingkirkan hanya cacat paling kotor, adalah peran parut "perangkap tanah" di awal kaskade filter. <br><br>  Analisis statis saja tidak meningkatkan kualitas produk akhir, sama seperti pengumpul lumpur tidak membuat air minum.  Namun demikian, secara umum bersama dengan elemen konveyor lainnya, kepentingannya jelas.  Meskipun dalam filter multistage, tahap-tahap output berpotensi mampu menangkap segala sesuatu yang sama dengan yang input, jelas apa konsekuensi upaya untuk melakukan dengan tahap-tahap halus tanpa tahap-tahap input akan mengarah ke sana. <br><br>  Tujuan dari "pengumpul kotoran" adalah untuk membebaskan kaskade berikutnya dari menangkap cacat yang sangat kotor.  Misalnya, setidaknya orang yang membuat tinjauan kode tidak boleh terganggu oleh kode yang diformat secara salah dan pelanggaran standar pengkodean yang telah ditetapkan (seperti tanda kurung tambahan atau cabang yang terlalu dalam).  Bug seperti NPE harus ditangkap oleh unit test, tetapi jika bahkan sebelum pengujian, penganalisa memberi tahu kami bahwa bug itu pasti terjadi, ini akan secara signifikan mempercepat koreksi. <br><br>  Saya percaya sekarang jelas mengapa analisis statis tidak meningkatkan kualitas produk, jika diterapkan secara sporadis, dan harus digunakan terus menerus untuk menyaring perubahan dengan cacat kotor.  Pertanyaannya adalah apakah penggunaan analisa statis akan meningkatkan kualitas produk Anda, kira-kira setara dengan pertanyaan "apakah kualitas air minum yang diambil dari reservoir yang kotor akan meningkat jika dilewatkan melalui saringan?" <br><br><h2>  Implementasi dalam proyek warisan </h2><br>  Pertanyaan praktis yang penting: bagaimana mengintegrasikan analisis statis ke dalam proses integrasi berkesinambungan sebagai "gerbang kualitas"?  Dalam hal tes otomatis, semuanya jelas: ada serangkaian tes, jatuhnya salah satu dari mereka adalah alasan yang cukup untuk percaya bahwa perakitan tidak melewati gerbang kualitas.  Upaya menetapkan gerbang dengan cara yang sama berdasarkan hasil analisis statis gagal: ada terlalu banyak peringatan analisis pada kode lawas, Anda tidak ingin sepenuhnya mengabaikannya, tetapi tidak mungkin menghentikan pengiriman produk hanya karena mengandung peringatan penganalisa. <br><br>  Ketika diterapkan untuk pertama kalinya, alat analisis menghasilkan sejumlah besar peringatan pada proyek apa pun, yang sebagian besar tidak terkait dengan berfungsinya produk.  Tidak mungkin untuk mengoreksi semua pernyataan ini sekaligus, dan banyak yang tidak perlu.  Pada akhirnya, kita tahu bahwa produk kita secara keseluruhan berfungsi, dan sebelum diperkenalkannya analisis statis! <br><br>  Akibatnya, banyak yang terbatas pada penggunaan analisis statis episodik, atau menggunakannya hanya dalam mode informasi, ketika laporan analisis hanya dikeluarkan selama perakitan.  Ini setara dengan tidak adanya analisis, karena jika kita sudah memiliki banyak peringatan, maka kemunculan yang lain (semena-mena serius) ketika mengubah kode tidak diperhatikan. <br><br>  Metode pemberian gerbang kualitas berikut diketahui: <br><br><ul><li>  Menetapkan batas jumlah total peringatan atau jumlah peringatan dibagi dengan jumlah baris kode.  Ini bekerja buruk, karena gerbang seperti itu dengan bebas melewatkan perubahan dengan cacat baru sampai batas mereka terlampaui. </li><li>  Memperbaiki, pada saat tertentu, semua peringatan lama dalam kode sebagai diabaikan, dan menolak untuk membangun ketika peringatan baru terjadi.  Fungsionalitas ini disediakan oleh PVS-studio dan beberapa sumber daya online, misalnya, Codacy.  Saya tidak dapat bekerja di PVS-studio, karena pengalaman saya dengan Codacy, masalah utama mereka adalah menentukan apa yang "lama" dan apa yang "baru" adalah algoritma yang agak rumit dan tidak selalu bekerja, terutama jika file banyak dimodifikasi atau diganti namanya.  Dalam ingatan saya, Codacy dapat melewati peringatan baru dalam permintaan tarik, dan pada saat yang sama tidak melewatkan permintaan tarik karena peringatan yang tidak terkait dengan perubahan dalam kode PR ini. </li><li>  Menurut pendapat saya, solusi paling efektif dijelaskan dalam buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengiriman Berkelanjutan</a> "ratcheting" ("ratcheting").  Gagasan utamanya adalah bahwa properti dari setiap rilis adalah jumlah peringatan dari analisis statis, dan hanya perubahan yang diizinkan yang tidak menambah jumlah total peringatan. </li></ul><br><h2>  Ratchet </h2><br>  Cara kerjanya seperti ini: <br><br><ol><li>  Pada tahap awal, jumlah peringatan dalam kode yang ditemukan oleh analis dicatat dalam metadata tentang rilis.  Jadi, ketika membangun cabang utama, tidak hanya "rilis 7.0.2", tetapi "rilis 7.0.2, yang berisi 100.500 Checkstyle peringatan" ditulis ke manajer repositori Anda.  Jika Anda menggunakan manajer repositori tingkat lanjut (seperti Artifactory), menyimpan metadata tersebut tentang rilis Anda mudah. </li><li>  Sekarang, setiap permintaan penarikan selama pertemuan membandingkan jumlah peringatan yang diterima dengan nomor dalam rilis saat ini.  Jika PR mengarah ke peningkatan angka ini, maka kode tidak lulus gerbang kualitas untuk analisis statis.  Jika jumlah peringatan berkurang atau tidak berubah, maka itu berlalu. </li><li>  Pada rilis berikutnya, jumlah peringatan yang dihitung akan ditulis ulang ke metadata rilis. </li></ol><br>  Begitu sedikit demi sedikit, tetapi dengan mantap (seperti dengan ratchet), jumlah peringatan akan cenderung nol.  Tentu saja, sistem bisa dibodohi dengan memperkenalkan peringatan baru, tetapi mengoreksi orang lain.  Ini normal, karena dalam jarak yang jauh ia memberikan hasil: peringatan dikoreksi, sebagai suatu peraturan, tidak secara individu, tetapi segera oleh sekelompok jenis tertentu, dan semua peringatan yang mudah dihilangkan dengan cepat dihilangkan. <br><br>  Grafik ini menunjukkan jumlah total peringatan Checkstyle selama setengah tahun bekerja seperti ratchet di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu proyek OpenSource kami</a> .  Jumlah peringatan telah berkurang dengan urutan besarnya, dan ini terjadi secara alami, sejalan dengan pengembangan produk! <br><br><img src="https://habrastorage.org/webt/ye/wa/u5/yewau5w494aa0vpkaevdydizoqm.png" width="500"><br><br>  Saya menggunakan versi modifikasi dari metode ini, secara terpisah menghitung peringatan yang dipisahkan oleh modul proyek dan alat analisis, file YAML yang dihasilkan dengan metadata rakitan terlihat seperti ini: <br><br><pre><code class="plaintext hljs">celesta-sql: checkstyle: 434 spotbugs: 45 celesta-core: checkstyle: 206 spotbugs: 13 celesta-maven-plugin: checkstyle: 19 spotbugs: 0 celesta-unit: checkstyle: 0 spotbugs: 0</code> </pre> <br>  Dalam sistem CI canggih apa pun, "ratchet" dapat diterapkan untuk semua alat analisis statis, tanpa bergantung pada plugin dan alat pihak ketiga.  Setiap analisis menghasilkan laporannya dalam bentuk teks atau XML sederhana, yang mudah dianalisis.  Tetap hanya mendaftarkan logika yang diperlukan dalam skrip CI.  Anda dapat melihat bagaimana ini diterapkan dalam proyek sumber terbuka kami berdasarkan Jenkins dan Artifactory di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Kedua contoh bergantung pada pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ratchetlib</a> : metode <code>countWarnings()</code> menghitung tag xml dalam file yang dihasilkan oleh Checkstyle dan Spotbugs, dan <code>compareWarningMaps()</code> mengimplementasikan ratchet yang sama, melempar kesalahan ketika jumlah peringatan di salah satu kategori meningkat. <br><br>  Implementasi ratchet yang menarik dimungkinkan untuk menganalisis ejaan komentar, literal teks, dan dokumentasi menggunakan aspell.  Seperti yang Anda ketahui, saat memeriksa ejaan, tidak semua kata yang tidak dikenal ke kamus standar salah, mereka dapat ditambahkan ke kamus pengguna.  Jika Anda membuat kamus khusus bagian dari kode sumber proyek, maka gerbang kualitas untuk ejaan dapat dirumuskan sebagai berikut: menjalankan aspell dengan kamus standar dan kustom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak akan</a> menemukan kesalahan ejaan apa pun. <br><br><h2>  Tentang pentingnya memperbaiki versi penganalisis </h2><br>  Kesimpulannya, hal-hal berikut harus diperhatikan: tidak peduli bagaimana Anda mengintegrasikan analisis ke dalam pipa pengiriman Anda, versi penganalisa harus diperbaiki.  Jika Anda mengizinkan penganalisis untuk memperbarui secara spontan, maka ketika merakit permintaan tarikan berikutnya, cacat baru mungkin "muncul" yang tidak terkait dengan mengubah kode, tetapi terhubung dengan fakta bahwa penganalisis baru hanya dapat menemukan lebih banyak cacat - dan ini akan merusak proses menerima permintaan tarikan .  Pembaruan penganalisis harus merupakan tindakan sadar.  Namun, memperbaiki secara ketat versi setiap komponen majelis umumnya merupakan persyaratan yang diperlukan dan topik untuk percakapan terpisah. <br><br><h2>  Kesimpulan </h2><br><ul><li>  Analisis statis tidak akan menemukan Anda bug dan tidak akan meningkatkan kualitas produk Anda sebagai akibat dari satu aplikasi.  Efek positif pada kualitas hanya disediakan oleh penggunaannya yang konstan dalam proses pengiriman. </li><li>  Mencari bug sama sekali bukan tugas analisis utama, sebagian besar fungsi bermanfaat tersedia di perangkat opensource. </li><li>  Menerapkan gerbang mutu berdasarkan hasil analisis statis pada tahap pertama dari pipa pengiriman, menggunakan ratchet untuk kode lawas. </li></ul><br><h2>  Referensi </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengiriman terus menerus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A. Kudryavtsev: Analisis program: bagaimana memahami bahwa Anda adalah</a> laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">programmer yang baik</a> tentang berbagai metode analisis kode (tidak hanya statis!) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436868/">https://habr.com/ru/post/id436868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436858/index.html">Esperanto, Elven dan Klingon</a></li>
<li><a href="../id436860/index.html">Dell dan Alienware di CES 2019: panduan untuk semua inovasi besar</a></li>
<li><a href="../id436862/index.html">AMD Ryzen Matisse Generasi ke-3: Octa-Core Zen 2 dengan PCIe 4.0 untuk Desktop</a></li>
<li><a href="../id436864/index.html">Cara menguji distribusi OS Anda sendiri</a></li>
<li><a href="../id436866/index.html">Cara mengenali proyek Agile palsu</a></li>
<li><a href="../id436872/index.html">PGConf.Russia 2019 Segera Hadir</a></li>
<li><a href="../id436874/index.html">Tarian Tahun Baru di sekitar adaptor FC atau kisah tentang seberapa jauh penyebab masalah berasal dari gejala</a></li>
<li><a href="../id436876/index.html">[SAP] SAPUI5 untuk boneka bagian 1: Latihan selangkah demi selangkah yang lengkap</a></li>
<li><a href="../id436878/index.html">BERT adalah model bahasa tercanggih untuk 104 bahasa. Tutorial untuk meluncurkan BERT secara lokal dan di Google Colab</a></li>
<li><a href="../id436880/index.html">C ++ Dasar-dasar Templat: Templat Fungsi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>