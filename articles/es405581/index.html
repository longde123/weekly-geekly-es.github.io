<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé® üë©üèΩ üçõ Interruptor autom√°tico de antena con control MK üë®üèæ‚Äçü§ù‚Äçüë®üèª üéì üçÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la pr√°ctica de la radioafici√≥n, a veces es necesario hacer algo en el microcontrolador. Si no hace este tipo de manualidades todo el tiempo, debe b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interruptor autom√°tico de antena con control MK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/405581/"><div style="text-align:center;"><img src="https://habrastorage.org/web/263/1bc/d85/2631bcd85f59492fbe35cfccc226fb15.jpg" alt="imagen"></div><br>  En la pr√°ctica de la radioafici√≥n, a veces es necesario hacer algo en el microcontrolador.  Si no hace este tipo de manualidades todo el tiempo, debe buscar en Google durante mucho tiempo la soluci√≥n de circuito necesaria y las bibliotecas adecuadas para MK, lo que le permite resolver r√°pidamente el problema.  Recientemente quer√≠a hacer un cambio autom√°tico de antena.  En el proceso, tuve que usar muchas de las funciones de Atmega MK en un proyecto compacto.  Aquellos que comienzan a estudiar AVR, cambian de arduino u ocasionalmente programan MK pueden ser piezas √∫tiles de c√≥digo que utilic√© en el proyecto. <br><a name="habracut"></a><br>  Pens√© en el interruptor de antena como un dispositivo que conecta autom√°ticamente la antena al transceptor, que es el m√°s adecuado para el rango de trabajo de ondas cortas.  Tengo dos antenas: V invertida y plano de tierra, est√°n conectadas al sintonizador de antena MFJ, en el que se pueden conmutar de forma remota.  Hay un interruptor manual de marca MFJ, que quer√≠a reemplazar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b6e/63f/073/b6e63f07338f40babb1c1cfb06eed94f.gif" alt="imagen"></div><br>  Para la conmutaci√≥n operativa de antenas, un bot√≥n est√° conectado al MK.  Lo adapt√© para recordar la antena preferida para cada rango: cuando presiona el bot√≥n durante m√°s de 3 segundos, la antena seleccionada se recuerda y se selecciona correctamente autom√°ticamente despu√©s del siguiente encendido del dispositivo.  La informaci√≥n sobre el alcance actual, la antena seleccionada y el estado de su sintonizaci√≥n se muestra en una pantalla LCD de una sola l√≠nea. <br><br>  Puede averiguar en qu√© rango est√° trabajando actualmente el transceptor de diferentes maneras: puede medir la frecuencia de la se√±al, puede recibir datos a trav√©s de la interfaz CAT, pero lo m√°s simple para m√≠ es usar la interfaz del transceptor YAESU para conectar un amplificador externo.  Tiene 4 l√≠neas de se√±al, en c√≥digo binario, que indican el rango actual.  Dan una se√±al l√≥gica de 0 a 5 voltios y se pueden conectar a las patas del MK a trav√©s de un par de resistencias terminales. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/85f/6b9/ebf/85f6b9ebf2aa4fe496fc48501171675e.jpg" alt="imagen"></div><br>  Eso no es todo.  En el modo de transmisi√≥n, las se√±ales PTT y ALC se transmiten a trav√©s de la misma interfaz.  Esta es una se√±al l√≥gica acerca de encender el transmisor (tirado al suelo) y una se√±al anal√≥gica de 0 a -4 V sobre el funcionamiento del sistema de control autom√°tico de potencia del transmisor.  Tambi√©n decid√≠ medirlo y mostrarlo en la pantalla LCD en modo de transmisi√≥n. <br><br>  Adem√°s, el sintonizador MFJ puede transmitir se√±ales al control remoto que est√° sintonizando y que la antena est√° sintonizada.  Para hacer esto, el panel de control de la compa√±√≠a MFJ tiene dos LED de control.  En lugar de LED, conect√© los optoacopladores y envi√© una se√±al de ellos al MK, para poder ver toda la informaci√≥n en una pantalla.  El dispositivo terminado se ve as√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e33/38f/2f8/e3338f2f8fff4187b523c0adbdda2d23.jpg" alt="imagen"></div><br>  Brevemente sobre casero como todo.  Ahora sobre la parte del software.  El c√≥digo est√° escrito en Atmel Studio (descarga gratuita desde el sitio web de Atmel).  El proyecto para principiantes demuestra las siguientes caracter√≠sticas del uso del popular Atmega8 MK: <br><br><ol><li>  Bot√≥n de conexi√≥n </li><li>  Conecte la entrada de l√≠nea para la se√±al digital del transceptor y el sintonizador </li><li>  Conexi√≥n de la salida de control del rel√© de conmutaci√≥n de antena </li><li>  Conexi√≥n de una pantalla LCD de una sola l√≠nea </li><li>  Conexi√≥n de zumbador y salida de sonido. </li><li>  Conexi√≥n de l√≠nea de entrada anal√≥gica ADC y medici√≥n de voltaje </li><li>  Usando interrupciones </li><li>  Usar un temporizador para contar el tiempo que se presiona un bot√≥n </li><li>  Usando Watchdog </li><li>  Uso de memoria no vol√°til para almacenar antenas seleccionadas </li><li>  Uso de UART para la impresi√≥n de depuraci√≥n </li><li>  Ahorro de energ√≠a en inactivo MK </li></ol><br>  Entonces comencemos.  En el curso del texto, habr√° todo tipo de nombres de registros y constantes caracter√≠sticos de la MK aplicada.  Esto no es arduino, aqu√≠, desafortunadamente, tienes que leer la hoja de datos en MK.  De lo contrario, no comprende lo que significan todos estos registros y c√≥mo puede cambiar sus valores.  Pero la estructura del programa en su conjunto seguir√° siendo la misma. <br><br><h3>  Primero, conecte el bot√≥n al MK </h3><br>  Este es el m√°s simple.  Conectamos un contacto al pie MK, el segundo contacto del bot√≥n al suelo.  Para que el bot√≥n funcione, deber√° encender la resistencia pull-up en MK.  Conectar√° el bot√≥n a trav√©s de la resistencia al bus + 5V.  Hacer esto es bastante simple: <br><br><pre><code class="cpp hljs">PORTB |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB2); <span class="hljs-comment"><span class="hljs-comment">// pullup resistor  </span></span></code> </pre> <br>  Del mismo modo, todas las entradas digitales que est√°n controladas por una falla a tierra (optoacopladores, l√≠neas de se√±al desde el transceptor, se√±al PTT) se dirigen al bus + 5V.  A veces es mejor soldar f√≠sicamente una resistencia tan peque√±a (por ejemplo, 10k) entre la entrada del MK y el bus + 5V, pero la discusi√≥n de este tema est√° m√°s all√° del alcance del art√≠culo.  Dado que todas las se√±ales de entrada en el proyecto rara vez cambian de valor, son derivadas al suelo por condensadores de 10 nanofaradios para proteger contra interferencias. <br><br>  Ahora tenemos 1 l√≥gico en la entrada PB2, y cuando presiona el bot√≥n, ser√° l√≥gico 0. Cuando presiona \ deprimir, necesita rastrear el rebote de contacto del bot√≥n, verificando que el nivel de se√±al no ha cambiado con el tiempo, digamos 50 milisegundos.  Esto se hace en el programa as√≠: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; !timer_on) { <span class="hljs-comment"><span class="hljs-comment">//    _delay_ms(50); if( !(PINB&amp;(1&lt;&lt;PINB2)) ) { //        -   passed_secs = 0; timer_on = 1; } }</span></span></code> </pre><br><h3>  Ahora conecta el chirrido </h3><br>  Dar√° una se√±al de confirmaci√≥n de audio de que la antena est√° grabada en la memoria MK.  Un tweeter es solo un elemento piezoel√©ctrico.  Est√° conectado a trav√©s de una peque√±a resistencia al pie MK, y por un segundo contacto a + 5V.  Para que este zumbador funcione, primero debe configurar el pie MK para generar datos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_buzzer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB0); <span class="hljs-comment"><span class="hljs-comment">// buzzer DDRB |= (1 &lt;&lt; PB0); // output PORTB &amp;= ~(1 &lt;&lt; PB0); }</span></span></code> </pre><br>  Ahora se puede usar.  Para hacer esto, se escribe una peque√±a funci√≥n que utiliza retrasos de tiempo para cambiar las piernas MK de 0 a 1 y viceversa.  El cambio con los retrasos necesarios hace posible generar una se√±al de audio de 4 kHz con una duraci√≥n de aproximadamente un cuarto de segundo en la salida MK, que es el sonido del elemento piezoel√©ctrico. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buzz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    4 0,25  for(int i=0; i&lt;1000; i++) { wdt_reset(); //    PORTB |= (1 &lt;&lt; PB0); _delay_us(125); PORTB &amp;= ~(1 &lt;&lt; PB0); _delay_us(125); } }</span></span></code> </pre><br>  Para que las funciones de retraso funcionen, no olvide incluir el archivo de encabezado y establecer la velocidad constante del procesador.  Es igual a la frecuencia del resonador de cuarzo conectado al MK.  En mi caso, hab√≠a 16MHz de cuarzo. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> F_CPU # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000UL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;util/delay.h&gt;</span></span></span></span></code> </pre><br><h3>  Nos conectamos a las antenas de conmutaci√≥n de rel√© MK </h3><br>  Aqu√≠ solo necesita configurar el pie MK para que funcione al salir.  Un rel√© de l√°minas est√° conectado a esta pata a trav√©s de un transistor amplificador de manera est√°ndar. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_tuner_relay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB1); <span class="hljs-comment"><span class="hljs-comment">// relay DDRB |= (1 &lt;&lt; PB1); // output PORTB &amp;= ~(1 &lt;&lt; PB1); }</span></span></code> </pre><br><h3>  Conexi√≥n de pantalla </h3><br>  Utilic√© una pantalla LCD 1601 de 16 caracteres y una l√≠nea, extra√≠da del hardware antiguo.  Utiliza el conocido controlador HD44780, para cuya administraci√≥n hay muchas bibliotecas disponibles en la red.  Una persona amable escribi√≥ una biblioteca de control de pantalla ligera, que utilic√© en el proyecto.  La configuraci√≥n de la biblioteca se reduce a indicar en el archivo de encabezado HD44780_Config.h el n√∫mero de patas MK conectadas a los pines de pantalla deseados.  Apliqu√© una conexi√≥n de pantalla a trav√©s de 4 l√≠neas de datos. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Data_Length 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NumberOfLines 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Font 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_E PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_E 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_RS PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_RS 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_4 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_4 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_5 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_5 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_6 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_6 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_7 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_7 3</span></span></code> </pre><br>  Una caracter√≠stica de mi instancia de visualizaci√≥n fue que una l√≠nea en la pantalla se mostraba como dos l√≠neas de 8 caracteres, por lo que se cre√≥ un b√∫fer de pantalla intermedio en el programa para un trabajo m√°s conveniente con la pantalla. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTC &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PC0); <span class="hljs-comment"><span class="hljs-comment">// display DDRC |= (1 &lt;&lt; PC0); // output PORTC &amp;= ~(1 &lt;&lt; PC0); PORTC &amp;= ~(1 &lt;&lt; PC1); // display DDRC |= (1 &lt;&lt; PC1); // output PORTC &amp;= ~(1 &lt;&lt; PC1); PORTC &amp;= ~(1 &lt;&lt; PC2); // display DDRC |= (1 &lt;&lt; PC2); // output PORTC &amp;= ~(1 &lt;&lt; PC2); PORTC &amp;= ~(1 &lt;&lt; PC3); // display DDRC |= (1 &lt;&lt; PC3); // output PORTC &amp;= ~(1 &lt;&lt; PC3); PORTC &amp;= ~(1 &lt;&lt; PC4); // display DDRC |= (1 &lt;&lt; PC4); // output PORTC &amp;= ~(1 &lt;&lt; PC4); PORTC &amp;= ~(1 &lt;&lt; PC5); // display DDRC |= (1 &lt;&lt; PC5); // output PORTC &amp;= ~(1 &lt;&lt; PC5); LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); } /*   16  0-3   40M     4-8   A:GP  A:IV     9-15    : TUNING=, TUNED==, HI-SWR= */ uchar display_buffer[]={' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '}; // 16    void update_display() { LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); //   16      8         LCD for (uchar i=0; i&lt;8; i++){ LCD_Show(display_buffer[i],1,i); LCD_Show(display_buffer[i+8],2,i); } }</span></span></code> </pre><br>  La funci√≥n update_display () le permite mostrar el contenido del b√∫fer en la pantalla.  Los valores de bytes en el b√∫fer son los c√≥digos ASCII de los caracteres de salida. <br><br><h3>  Depurar la salida de impresi√≥n al puerto COM </h3><br>  MK tiene UART y lo us√© para depurar el programa.  Al conectar el MK a la computadora, solo necesita recordar que los niveles de se√±al en la salida MK est√°n en el est√°ndar TTL y no en el RS232, por lo que necesita un adaptador simple.  Utilic√© un adaptador de serie USB, completamente similar en aliexpress.  Cualquier programa de terminal, por ejemplo de arduino, es adecuado para leer datos.  C√≥digo de configuraci√≥n del puerto UART: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BAUD 9600 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;avr/io.h&gt; // UART      RS232 void uart_init( void ) { /* //   UBRRH = 0; UBRRL = 103; //9600   16  */ #include &lt;util/setbaud.h&gt; UBRRH = UBRRH_VALUE; UBRRL = UBRRL_VALUE; #if USE_2X UCSRA |= (1 &lt;&lt; U2X); #else UCSRA &amp;= ~(1 &lt;&lt; U2X); #endif //8  , 1  ,    UCSRC = ( 1 &lt;&lt; URSEL ) | ( 1 &lt;&lt; UCSZ1 ) | ( 1 &lt;&lt; UCSZ0 ); //     // UCSRB = ( 1 &lt;&lt; TXEN ) | ( 1 &lt;&lt;RXEN ); UCSRB = ( 1 &lt;&lt; TXEN ); } int uart_putc( char c, FILE *file ) { //     while( ( UCSRA &amp; ( 1 &lt;&lt; UDRE ) ) == 0 ); UDR = c; wdt_reset(); return 0; } FILE uart_stream = FDEV_SETUP_STREAM( uart_putc, NULL, _FDEV_SETUP_WRITE ); stdout = &amp;uart_stream;</span></span></span></span></code> </pre><br>  Despu√©s de configurar el flujo de salida, puede usar la impresi√≥n habitual para imprimir en el puerto: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"Start flag after reset = %u\r\n"</span></span>, mcusr_mirror );</code> </pre> <br>  El programa utiliza la impresi√≥n de n√∫meros reales.  Las bibliotecas normales no admiten este modo de salida, por lo que tuve que conectar una biblioteca completa al vincular un proyecto.  Es cierto que aumenta considerablemente la cantidad de c√≥digo, pero ten√≠a una gran cantidad de memoria, por lo que no fue cr√≠tico.  En las opciones del vinculador, debe especificar la l√≠nea: <br><br> <code>-Wl,-u,vfprintf -lprintf_flt</code> <br> <br><h3>  Trabaja con temporizador e interrupciones </h3><br>  Para contar los intervalos de tiempo en un programa, es importante tener un contador de tiempo.  Es necesario hacer un seguimiento de que el bot√≥n se presiona durante m√°s de 3 segundos y, por lo tanto, debe recordar las nuevas configuraciones en la memoria no vol√°til.  Para medir el tiempo en el estilo AVR, debe configurar el contador de pulsos del generador de reloj y la interrupci√≥n que se ejecutar√° cuando el contador alcance el valor establecido.  Configur√© el temporizador para que produzca una interrupci√≥n aproximadamente una vez por segundo.  El propio controlador de interrupciones cuenta el n√∫mero de segundos transcurridos.  La variable timer_on controla el encendido / apagado del temporizador.  Es importante no olvidar declarar todas las variables que se actualizan en el controlador de interrupciones como vol√°tiles, de lo contrario el compilador puede "optimizarlas" y el programa no funcionar√°. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1    -     void timer1_init( void ) { TCCR1A = 0; //    1 -   /* 16000000 / 1024 = 15625 ,     15625      1  */ //  CTC, ICP1 interrupt sense (falling)(not used) + prescale /1024 +    (not used) TCCR1B = (0 &lt;&lt; WGM13) | (1 &lt;&lt; WGM12) | (0 &lt;&lt; ICES1) | ((1 &lt;&lt; CS12) | (0 &lt;&lt; CS11) | (1 &lt;&lt; CS10)) | (0 &lt;&lt; ICNC1); OCR1A = 15625; //  TIMSK |= (1 &lt;&lt; OCIE1A); } uchar timer_on = 0; volatile uchar passed_secs = 0; //      e ISR(TIMER1_COMPA_vect) { if (timer_on) passed_secs++; }</span></span></code> </pre><br>  El valor de pass_secs se verifica en el bucle principal del programa.  Cuando se presiona el bot√≥n, el temporizador comienza y luego, en el ciclo del programa principal, se verifica el valor del temporizador mientras se presiona el bot√≥n.  Si este valor supera los 3 segundos, se escribe la EEPROM y el temporizador se detiene. <br><br>  Por √∫ltimo, pero no menos importante, despu√©s de todas las inicializaciones, debe habilitar las interrupciones con el comando sei (). <br><br><h3>  Medici√≥n de nivel de ALC </h3><br>  Se realiza utilizando el convertidor anal√≥gico a digital (ADC) incorporado.  Med√≠ el voltaje en la entrada del ADC7.  Debe recordarse que puede medir un valor de 0 a 2.5V.  y mi voltaje de entrada fue de -4V a 0V.  Por lo tanto, conect√© el MK a trav√©s del divisor de voltaje m√°s simple en las resistencias, de modo que el nivel de voltaje en la entrada MK estaba en un nivel dado.  Adem√°s, no necesitaba una alta precisi√≥n, por lo que apliqu√© una conversi√≥n de 8 bits (es suficiente para leer datos solo del registro ADCH).  Como fuente de referencia, utilic√© un ion interno a 2.56V, esto simplifica ligeramente los c√°lculos.  Para que funcione el ADC, aseg√∫rese de conectar un capacitor de 0.1 ¬µF al pie REF en el suelo. <br><br>  ADC en mi caso funciona continuamente, informando el final de la conversi√≥n llamando a la interrupci√≥n ADC_vect.  Es una buena pr√°ctica promediar los valores de varios ciclos de conversi√≥n para reducir el error.  En mi caso, infiero el promedio de 2500 transformaciones.  Todo el c√≥digo ADC se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ALC #define SAMPLES 2500 //    #define REFERENCEV 2.56 //       #define DIVIDER 2.0 double realV = 0; //     ALC double current_realV = 0; volatile int sampleCount = 0; volatile unsigned long tempVoltage = 0; //     volatile unsigned long sumVoltage = 0; //         void ADC_init() // ADC7 { //   2,56, 8 bit  -   ADCH ADMUX = (1 &lt;&lt; REFS0) | (1 &lt;&lt; REFS1) | (1 &lt;&lt; ADLAR) | (0 &lt;&lt; MUX3) | (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX1) | (1 &lt;&lt; MUX0); // ADC7 // , free running,   ADCSRA = (1 &lt;&lt; ADEN) | (1 &lt;&lt; ADFR) | (1 &lt;&lt; ADIE) | (1 &lt;&lt; ADPS2) | (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); //  128 ADCSRA |= (1 &lt;&lt; ADSC); // Start ADC Conversion } ISR(ADC_vect) //     2500  { if (sampleCount++) //    tempVoltage += ADCH; if (sampleCount &gt;= SAMPLES) { sampleCount = 0; sumVoltage = tempVoltage; tempVoltage = 0; } ADCSRA |=(1 &lt;&lt; ADIF); // Acknowledge the ADC Interrupt Flag } realV = -1.0*(DIVIDER * ((sumVoltage * REFERENCEV) / 256) / SAMPLES - 5.0); //   ALC if (realV &lt; 0.0) realV = 0.0; printf("ALC= -%4.2f\r\n", realV); //     </span></span></code> </pre><br><h3>  Usando EEPROM </h3><br>  Esta es una memoria no vol√°til en MK.  Es conveniente usarlo para almacenar todo tipo de configuraciones, valores de correcci√≥n, etc.  En nuestro caso, se usa solo para almacenar la antena seleccionada para el rango deseado.  Para este prop√≥sito, se asigna una matriz de 16 bytes en la EEPROM.  Pero puede acceder a √©l a trav√©s de funciones especiales definidas en el archivo de encabezado avr / eeprom.h.  Al inicio, el MK lee informaci√≥n sobre la configuraci√≥n guardada en la RAM y enciende la antena deseada, dependiendo del rango actual.  Cuando se presiona el bot√≥n durante mucho tiempo, se graba un nuevo valor en la memoria, acompa√±ado de una se√±al de sonido.  Al escribir en la EEPROM, las interrupciones se desactivan por si acaso.  C√≥digo de inicializaci√≥n de memoria: <br><br><pre> <code class="cpp hljs">EEMEM <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ee_bands[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//         unsigned char avr_bands[16]; void EEPROM_init(void) { for(int i=0; i&lt;16; i++) { avr_bands[i] = eeprom_read_byte(&amp;ee_bands[i]); if (avr_bands[i] &gt; 1) avr_bands[i] = ANT_IV; //    EEPROM   ,     FF } }</span></span></code> </pre><br>  Un fragmento del c√≥digo de procesamiento para presionar un bot√≥n durante 3 segundos y escribir en la memoria: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; passed_secs &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    3  timer_on = 0; //   read_ant = avr_bands[read_band]; //     cli(); EEPROM_init(); //          sei(); if (read_ant) { avr_bands[read_band] = ANT_GP; } else { avr_bands[read_band] = ANT_IV; } cli(); eeprom_write_byte(&amp;ee_bands[read_band], avr_bands[read_band]); //    EEPROM sei(); buzz(); }</span></span></code> </pre><br><h3>  Usando Watchdog </h3><br>  No es ning√∫n secreto que bajo condiciones de fuerte interferencia electromagn√©tica, el MK puede congelarse.  Cuando la radio est√° en funcionamiento, existe tal interferencia que "los hierros comienzan a hablar", por lo que debe asegurarse de reiniciar cuidadosamente el MK en caso de que se cuelgue.  Un temporizador de vigilancia sirve para este prop√≥sito.  Usarlo es muy simple.  Primero, incluya el archivo de encabezado avr / wdt.h en el proyecto.  Al comienzo del programa, despu√©s de completar todas las configuraciones, debe iniciar el temporizador llamando a la funci√≥n wdt_enable (WDTO_2S), y luego recordar restablecerlo peri√≥dicamente llamando a wdt_reset (), de lo contrario, reiniciar√° el MK.  Para la depuraci√≥n con el fin de descubrir por qu√© se reinici√≥ el MK, puede usar el valor del registro especial MCUSR, cuyo valor puede recordarse y luego imprimirse en la impresi√≥n de depuraci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        //     uint8_t mcusr_mirror __attribute__ ((section (".noinit"))); void get_mcusr(void) \ __attribute__((naked)) \ __attribute__((section(".init3"))); void get_mcusr(void) { mcusr_mirror = MCUSR; MCUSR = 0; wdt_disable(); } printf( "Start flag after reset = %u\r\n", mcusr_mirror );</span></span></code> </pre><br><h3>  Ahorro de energ√≠a para los amantes del medio ambiente. </h3><br>  Si bien MK no est√° ocupado con nada, puede quedarse dormido y esperar la pr√≥xima interrupci√≥n.  En este caso, se ahorra un poco de energ√≠a el√©ctrica.  Un poco, pero ¬øpor qu√© no usarlo en un proyecto?  Adem√°s, es muy simple.  Incluya el archivo de encabezado avr / sleep.h.  El cuerpo del programa consta de un bucle infinito en el que debe llamar a la funci√≥n sleep_cpu (), despu√©s de lo cual el MC se queda dormido un poco y el bucle principal se detiene hasta que se produce la siguiente interrupci√≥n.  Se producen durante el funcionamiento del temporizador y el ADC, por lo que MK no dormir√° durante mucho tiempo.  El modo de hibernaci√≥n se determina cuando MK se inicializa llamando a dos funciones: <br><br><pre> <code class="cpp hljs"> set_sleep_mode(SLEEP_MODE_IDLE); <span class="hljs-comment"><span class="hljs-comment">//     IDLE sleep_enable();</span></span></code> </pre><br>  Eso es todo por ahora.  Hice el cambio; funciona con √©xito en mi estaci√≥n de radio amateur sin fallas.  Espero que el material proporcionado sea √∫til para principiantes. <br><br>  73 de R2AJP </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es405581/">https://habr.com/ru/post/es405581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es405571/index.html">Elementos del Sistema Nacional de Innovaci√≥n de EE. UU., Parte 1: Entorno empresarial y pol√≠tica fiscal, comercial y econ√≥mica</a></li>
<li><a href="../es405573/index.html">Sistema autom√°tico de alerta de ataque policial</a></li>
<li><a href="../es405575/index.html">Revisi√≥n de tel√©fono inteligente ASUS ZenFone 4 Max</a></li>
<li><a href="../es405577/index.html">Sistema Nacional de Innovaci√≥n de EE. UU.</a></li>
<li><a href="../es405579/index.html">"¬°Buenos d√≠as Vietnam!": C√≥mo iniciar su radio por Internet</a></li>
<li><a href="../es405583/index.html">Altavoz port√°til Vibro PartyFon</a></li>
<li><a href="../es405585/index.html">Lockheed Martin construye un prototipo de m√≥dulo habitable para el espacio profundo</a></li>
<li><a href="../es405587/index.html">Entendemos la f√≠sica de part√≠culas: 4) ondas, la ecuaci√≥n cl√°sica del movimiento</a></li>
<li><a href="../es405589/index.html">Google ayuda a los reactores de fusi√≥n a calentar plasma en el reactor utilizando un software especial</a></li>
<li><a href="../es405591/index.html">Funcionarios de FAS seleccionan operador de impuestos para bienes comprados por rusos en el extranjero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>