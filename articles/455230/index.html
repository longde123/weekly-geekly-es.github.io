<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÜ üì± ü§õüèΩ Tipos de referencia anulables en C # 8.0 y an√°lisis est√°tico üíó ü¶è üë®üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No es ning√∫n secreto que Microsoft ha estado trabajando en el lanzamiento de la octava versi√≥n de C # durante bastante tiempo. En la versi√≥n reciente ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de referencia anulables en C # 8.0 y an√°lisis est√°tico</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455230/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Cuadro 9"></p><br>  No es ning√∫n secreto que Microsoft ha estado trabajando en el lanzamiento de la octava versi√≥n de C # durante bastante tiempo.  En la versi√≥n reciente de Visual Studio 2019, ya est√° disponible una nueva versi√≥n del lenguaje (C # 8.0), pero hasta ahora solo como versi√≥n beta.  Los planes para esta nueva versi√≥n tienen varias caracter√≠sticas, cuya implementaci√≥n puede no parecer bastante obvia, o m√°s bien, no del todo esperada.  Una de estas innovaciones es la capacidad de utilizar tipos de referencia anulables.  El significado declarado de esta innovaci√≥n es la lucha contra las Excepciones de Referencia Nula (NRE). <br><a name="habracut"></a><br>  Nos complace que el lenguaje se est√© desarrollando y que las nuevas funciones ayuden a los desarrolladores.  Casualmente, en nuestro analizador PVS-Studio para C #, las capacidades para detectar exactamente la misma NRE en el c√≥digo se han expandido relativamente recientemente.  Y nos preguntamos: ¬øhay alg√∫n sentido ahora para los analizadores est√°ticos en general, y para PVS-Studio en particular, para tratar de buscar una posible desreferenciaci√≥n de referencias nulas, si, al menos en el nuevo c√≥digo que usa la Referencia Nulable, dicha desreferencia ser√° "imposible" ?  Intentemos responder esta pregunta. <br><br><h2>  Pros y contras de la innovaci√≥n </h2><br>  Para comenzar, vale la pena recordar que en la √∫ltima versi√≥n beta de C # 8.0, disponible al momento de escribir este art√≠culo, la Referencia Nulable est√° desactivada de manera predeterminada, es decir.  El comportamiento de los tipos de referencia no cambiar√°. <br><br>  ¬øCu√°les son los tipos de referencia anulables en C # 8.0 si los incluye?  Este es el mismo tipo de referencia antiguo y bueno, con la diferencia de que las variables de este tipo ahora deben marcarse con '?'  (por ejemplo, <i>cadena?</i> ), similar a como ya se hace para <i>Nullable &lt;T&gt;</i> , es decir  tipos significativos anulables (por ejemplo, <i>int?</i> ).  Sin embargo, ahora la misma <i>cadena</i> sin '?'  ya comienza a interpretarse como una referencia no anulable, es decir  Este es un tipo de referencia cuya variable no puede contener valores <i>nulos</i> . <br><br>  La excepci√≥n de referencia nula es una de las excepciones m√°s molestas porque dice poco sobre el origen del problema, especialmente si hay varias desreferencias seguidas en el m√©todo que arroja la excepci√≥n.  La capacidad de prohibir pasar <i>nulo</i> a una variable de tipo de referencia se ve bien, pero si antes <i>se</i> pas√≥ <i>nulo</i> al m√©todo y alguna l√≥gica de ejecuci√≥n adicional estaba vinculada a esto, ¬øqu√© debo hacer ahora?  Por supuesto, puede pasar un valor literal, constante o simplemente "imposible" en lugar de <i>nulo</i> , que, seg√∫n la l√≥gica del programa, no puede asignarse a esta variable en ning√∫n otro lugar.  Sin embargo, la ca√≠da de todo el programa puede ser reemplazada por una ejecuci√≥n incorrecta "silenciosa" adicional.  No siempre ser√° mejor que ver el error de inmediato. <br><br>  ¬øY si en cambio arroja una excepci√≥n?  Una excepci√≥n significativa en un lugar donde algo sali√≥ mal siempre es mejor que una <i>NRE en</i> alg√∫n lugar m√°s alto o m√°s bajo en la pila.  Pero es bueno si estamos hablando de nuestro propio proyecto, donde podemos arreglar a los consumidores e insertar un <i>bloque try-catch,</i> y al desarrollar una biblioteca usando la referencia (no) Nullable, asumimos la responsabilidad de que alg√∫n m√©todo siempre devuelve un valor.  Y no siempre es, incluso en el c√≥digo nativo, que ser√° (al menos simple) sustituir el retorno <i>nulo</i> por lanzar una excepci√≥n (demasiado c√≥digo puede verse afectado). <br><br>  Puede habilitar Nullable Reference en todo el nivel del proyecto agregando la propiedad <i>NullableContextOptions</i> con el valor de <i>habilitaci√≥n</i> , o en el nivel de archivo utilizando la directiva de preprocesador: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Los tipos ahora ser√°n m√°s visuales.  Mediante la firma del m√©todo, es posible determinar su comportamiento, si contiene una comprobaci√≥n de <i>nulo</i> o no, puede devolver <i>nulo</i> o no.  Ahora, si intenta acceder a una variable de referencia anulable sin verificar, el compilador generar√° una advertencia. <br><br>  Muy conveniente cuando se usan bibliotecas de terceros, pero existe una situaci√≥n con posible informaci√≥n err√≥nea.  El hecho es que pasar <i>nulo</i> todav√≠a es posible, por ejemplo, utilizando el nuevo operador que perdona nulo (!).  Es decir  Es solo que con la ayuda de un solo signo de exclamaci√≥n, puede romper todos los supuestos adicionales que se har√°n sobre una interfaz que utiliza estas variables: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  S√≠, se puede decir que est√° mal escribir de esta manera, y nadie lo har√°, pero mientras permanezca esta oportunidad, ya no es posible confiar completamente en el contrato impuesto por la interfaz de este m√©todo (que no puede devolver nulo). <br><br>  ¬°Y, por cierto, puede escribir lo mismo con la ayuda de varios operadores !, porque C # ahora le permite escribir as√≠ (y este c√≥digo est√° completamente compilado): <br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Es decir  nos gustar√≠a enfatizar a√∫n m√°s: presta atenci√≥n, ¬°esto puede ser <i>nulo</i> !  (nosotros en el equipo llamamos a esto programaci√≥n "emocional").  De hecho, el compilador (de Roslyn), cuando construye un √°rbol de c√≥digo de sintaxis, ¬°interpreta al operador!  similar a los corchetes simples, por lo que su n√∫mero, como es el caso con los corchetes, es ilimitado.  Aunque, si escribe muchos de ellos, el compilador puede ser "volcado".  Quiz√°s esto cambie en la versi√≥n final de C # 8.0. <br><br>  De manera similar, puede omitir la advertencia del compilador al acceder a una variable de referencia anulable sin verificar: <br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Puedes escribir m√°s emocionalmente: <br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Esta sintaxis es realmente dif√≠cil de imaginar en un proyecto real, poniendo un operador <i>indulgente</i> que le decimos al compilador: aqu√≠ todo est√° bien, no se necesita verificaci√≥n.  A√±adiendo un operador de elvis decimos: pero en general puede no ser normal, verifiquemos. <br><br>  Y ahora surge una pregunta leg√≠tima: ¬øpor qu√©, si el concepto de un tipo de referencia no anulable implica que una variable de este tipo no puede contener <i>nulo</i> , podemos seguir escribi√©ndolo tan f√°cilmente all√≠?  El hecho es que "bajo el cap√≥", en el nivel del c√≥digo IL, nuestro tipo de referencia no anulable permanece ... todo el mismo tipo de referencia "ordinario".  Y toda la sintaxis de nulabilidad es en realidad solo una anotaci√≥n para el analizador est√°tico integrado en el compilador (y, en nuestra opini√≥n, no es el analizador m√°s conveniente, pero m√°s sobre eso m√°s adelante).  En nuestra opini√≥n, incluir la nueva sintaxis en el lenguaje solo como una anotaci√≥n para una herramienta de terceros (incluso si est√° integrada en el compilador) no es la soluci√≥n m√°s "hermosa", porque  para un programador que usa este lenguaje, esto es solo una anotaci√≥n puede no ser obvio en absoluto; despu√©s de todo, una sintaxis muy similar para estructuras anulables funciona de una manera completamente diferente. <br><br>  Volviendo a c√≥mo todav√≠a es posible "romper" los tipos de referencia anulables.  En el momento de la escritura, si hay varios proyectos en la soluci√≥n, al pasar de un m√©todo declarado en un proyecto una variable de referencia, por ejemplo de tipo <i>String,</i> a un m√©todo de otro proyecto donde <i>NullableContextOptions est√°</i> habilitado <i>, el</i> compilador decidir√° que ya es una String no anulable, Y no dar√° una advertencia.  Y esto a pesar de la gran cantidad de <i>atributos [Nullable (1)]</i> agregados a cada campo y m√©todo de clase en el c√≥digo IL cuando las referencias Nullable est√°n activadas <i>.</i>  Por cierto, estos atributos deben tenerse en cuenta si est√° trabajando con una lista de atributos a trav√©s de la reflexi√≥n, contando con la existencia de solo aquellos atributos que agreg√≥ usted mismo. <br><br>  Esta situaci√≥n puede crear problemas adicionales al convertir una base de c√≥digo grande en una referencia anulable.  Lo m√°s probable es que este proceso sea gradual, proyecto por proyecto.  Por supuesto, con un enfoque competente para el cambio, puede cambiar gradualmente a un nuevo funcional, pero si ya tiene un borrador funcional, cualquier cambio en √©l es peligroso e indeseable (funciona, ¬°no lo toque!).  Es por eso que cuando se usa el analizador PVS-Studio no hay necesidad de editar el c√≥digo fuente o de alguna manera marcarlo para detectar <i>NRE</i> potenciales.  Para verificar los lugares donde puede ocurrir una <i>NullReferenceException,</i> solo necesita iniciar el analizador y mirar las advertencias V3080.  No es necesario cambiar las propiedades del proyecto o el c√≥digo fuente.  No es necesario agregar directivas, atributos u operadores.  No es necesario cambiar su c√≥digo. <br><br>  Con el soporte de los tipos de referencia anulables en el analizador PVS-Studio, nos enfrentamos a una opci√≥n: ¬øel analizador debe interpretar las variables de referencia no anulables como valores siempre distintos de cero?  Despu√©s de estudiar el tema de las posibilidades de "romper" esta garant√≠a, llegamos a la conclusi√≥n de que no existe: el analizador no debe hacer tal suposici√≥n.  De hecho, incluso si se usan tipos de referencia no anulables en todas partes del proyecto, el analizador puede complementar su uso simplemente descubriendo situaciones en las que puede aparecer un valor <i>nulo</i> en dicha variable. <br><br><h2>  C√≥mo se ve PVS-Studio para excepciones de referencia nula </h2><br>  Los mecanismos de flujo de datos en el analizador C # PVS-Studio monitorean los posibles valores de las variables durante el an√°lisis.  En particular, PVS-Studio tambi√©n realiza an√°lisis interprocediales, es decir  Intenta determinar el posible valor devuelto por el m√©todo, as√≠ como los m√©todos invocados en este m√©todo, etc.  Entre otras cosas, el analizador recuerda variables que pueden ser potencialmente <i>nulas</i> .  Si en el futuro el analizador ve una desreferenciaci√≥n sin verificar dicha variable, nuevamente, ya sea en el c√≥digo actual que se est√° verificando o dentro del m√©todo llamado en este c√≥digo, se emitir√° una advertencia V3080 sobre una posible excepci√≥n de referencia nula. <br><br>  Al mismo tiempo, la idea principal que subyace a este diagn√≥stico es que el analizador solo jurar√° si vio en alg√∫n lugar la asignaci√≥n de <i>nulo</i> a una variable.  Esta es la principal diferencia entre el comportamiento de este diagn√≥stico y el analizador integrado en el compilador que funciona con tipos de referencia anulables.  ¬°El analizador integrado en el compilador jurar√° ante cualquier desreferencia de una variable de referencia anulable no verificada del tipo, a menos que, por supuesto, este analizador sea "enga√±ado" por el operador! de cualquier otra manera, se puede utilizar absolutamente cualquier analizador, especialmente si se establece ese objetivo, y PVS-Studio no es una excepci√≥n). <br><br>  PVS-Studio solo jura si ve <i>nulo</i> (en un contexto local o proviene de un m√©todo).  Al mismo tiempo, incluso si la variable es una variable de referencia no anulable, el comportamiento del analizador no cambiar√°, seguir√° jurando si ve que se le escribi√≥ nulo.  Este enfoque nos parece m√°s correcto (o, al menos, conveniente para el usuario del analizador), ya que  no requiere "cubrir" todo el c√≥digo con verificaciones <i>nulas</i> para encontrar posibles desreferencias; esto podr√≠a haberse hecho antes, sin una Referencia Anulable, por ejemplo, con los mismos contratos.  Adem√°s, el analizador ahora se puede usar para un control adicional sobre las mismas variables de referencia no anulables.  Si se usan "honestamente" y nunca se asignan nulos, el analizador permanecer√° en silencio.  Si se asigna un valor nulo y la variable se desreferencia sin verificar, el analizador lo advierte con el mensaje V3080: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br><br>  Consideremos algunos ejemplos de tal activaci√≥n de diagn√≥sticos V3080 en el c√≥digo de Roslyn.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Verificamos este proyecto</a> no hace mucho tiempo, pero esta vez consideraremos solo los posibles desencadenantes de excepci√≥n de referencia nula que no estaban en art√≠culos anteriores.  Veamos c√≥mo el analizador PVS-Studio puede encontrar la posible desreferenciaci√≥n de referencias nulas, y c√≥mo estos lugares se pueden arreglar utilizando la nueva sintaxis de referencia anulable. <br><br>  <i>V3080 [CWE-476] Posible desreferencia nula dentro del m√©todo.</i>  <i>Considere inspeccionar el segundo argumento: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Como puede ver, la variable <i>chainedTupleType</i> puede ser nula en una de las ramas de ejecuci√≥n de c√≥digo.  Luego, <i>chainedTupleType se</i> pasa dentro del m√©todo <i>ConstructTupleUnderlyingType,</i> y se usa all√≠ con la verificaci√≥n a trav√©s de <i>Debug.Assert</i> .  Esta situaci√≥n es muy com√∫n en Roslyn, sin embargo, vale la pena recordar que <i>Debug.Assert</i> se elimina en la versi√≥n de lanzamiento del ensamblado.  Por lo tanto, el analizador a√∫n considera que la desreferenciaci√≥n dentro del m√©todo <i>ConstructTupleUnderlyingType</i> es peligrosa.  A continuaci√≥n, damos el cuerpo de este m√©todo, donde ocurre la desreferenciaci√≥n: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Si el analizador debe tener en cuenta tal afirmaci√≥n es realmente un punto discutible (algunos de nuestros usuarios quieren que lo haga), porque los contratos de System.Diagnostics.Contracts, por ejemplo, el analizador ahora tiene en cuenta.  Le dir√© solo un peque√±o ejemplo de nuestro uso real de la misma Roslyn en nuestro analizador.  Recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">admitimos la nueva versi√≥n de Visual Studio</a> y, al mismo tiempo, actualizamos el analizador Roslyn a la versi√≥n 3.  Despu√©s de eso, el analizador comenz√≥ a caer al verificar un cierto c√≥digo en el que no se hab√≠a bloqueado previamente.  Al mismo tiempo, el analizador comenz√≥ a caer no dentro de nuestro c√≥digo, sino dentro del propio c√≥digo de Roslyn, para caer con una excepci√≥n de referencia nula.  Y una mayor depuraci√≥n mostr√≥ que en el lugar donde ahora cae Roslyn, exactamente un par de l√≠neas arriba, hay la misma verificaci√≥n <i>nula a</i> trav√©s de <i>Debug.Assert</i> .  Y ella, como vemos, no salv√≥. <br><br>  Este es un muy buen ejemplo de problemas con la referencia anulable <i>,</i> porque el compilador considera <i>Debug.Assert una</i> verificaci√≥n v√°lida en cualquier configuraci√≥n.  Es decir, si simplemente habilita <i>#nullable enable</i> y marca el argumento <i>chainedTupleTypeOpt</i> como referencia anulable <i>,</i> no habr√° advertencias del compilador en la ubicaci√≥n de desreferencia en el m√©todo <i>ConstructTupleUnderlyingType</i> . <br><br>  Considere el siguiente ejemplo de activaci√≥n de PVS-Studio. <br><br>  <i>V3080 Posible desreferencia nula.</i>  <i>Considere inspeccionar 'efectivoRuleset'.</i>  <i>RuleSet.cs 146</i> <br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Esta advertencia se√±ala que llamar al m√©todo <i>WithEffectiveAction</i> puede devolver un <i>valor nulo</i> , pero el resultado se usa sin verificar ( <i>efectivoRuleset.GeneralDiagnosticOption</i> ).  El cuerpo del m√©todo <i>WithEffectiveAction</i> , que puede devolver nulo, se escribe en la variable <i>efectivaRuleset</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br><br>  Si habilita el modo Nullable Reference para el m√©todo <i>GetEffectiveRuleSet</i> , tendremos dos lugares en los que debemos cambiar el comportamiento.  Dado que hay un lanzamiento de excepci√≥n en el m√©todo anterior, es l√≥gico suponer que la llamada al m√©todo est√° envuelta en un <i>bloque try-catch</i> y reescribir√° correctamente el m√©todo, arrojando una excepci√≥n en lugar de devolver nulo.  Pero al escalar los desaf√≠os, vemos que la intercepci√≥n es alta y las consecuencias pueden ser bastante impredecibles.  Veamos la variable de consumo <i>efectivoRuleset</i> - m√©todo <i>IsStricterThan</i> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Como puede ver, este es un cambio simple para dos enumeraciones con un posible valor de enumeraci√≥n de <i>ReportDiagnostic.Default</i> .  Por lo tanto, es mejor reescribir la llamada de la siguiente manera: <br><br>  La firma <i>WithEffectiveAction</i> cambiar√°: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  la llamada se ver√° as√≠: <br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  sabiendo que <i>IsStricterThan</i> solo realiza una comparaci√≥n; la condici√≥n puede reescribirse, por ejemplo, de esta manera: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Pasemos al siguiente mensaje del analizador. <br><br>  <i>V3080 Posible desreferencia nula.</i>  <i>Considere inspeccionar 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  El uso posterior de la variable <i>propertySymbol</i> debe tenerse en cuenta al corregir la advertencia del analizador. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  El m√©todo <i>GetMemberSymbol</i> tambi√©n puede devolver <i>nulo</i> en algunos casos. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Usando un tipo de referencia anulable, la llamada cambiar√° as√≠: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Bastante simple cuando sabes d√≥nde solucionarlo.  El an√°lisis est√°tico encuentra f√°cilmente este error potencial al obtener todos los valores de campo posibles en todas las cadenas de llamadas de procedimiento. <br><br>  <i>V3080 Posible desreferencia nula.</i>  <i>Considere inspeccionar 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  El problema est√° en la l√≠nea con la comprobaci√≥n de <i>simpleName.Length.</i>  <i>simpleName</i> es el resultado de una cadena completa de m√©todos y puede ser <i>nulo</i> .  Por cierto, por curiosidad, puede mirar el m√©todo <i>RemoveExtension</i> y encontrar diferencias de <i>Path.GetFileNameWithoutExtension.</i>  Aqu√≠ podr√≠amos limitarnos a verificar <i>simpleName! = Null</i> , pero en el contexto de enlaces distintos de cero, el c√≥digo se ver√° as√≠: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  La llamada se ver√° as√≠: <br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclusi√≥n </h2><br>  Los tipos de referencia anulables pueden ser de gran ayuda para planificar una arquitectura construida desde cero, pero la reelaboraci√≥n del c√≥digo existente puede requerir mucho tiempo y cuidado, ya que puede causar muchos errores sutiles.  En este art√≠culo, no ten√≠amos el objetivo de desalentar a nadie de usar tipos de referencia anulables en nuestros proyectos.  Creemos que esta innovaci√≥n es generalmente √∫til para el lenguaje, aunque la forma en que se implement√≥ puede generar dudas. <br><br>  Siempre debe recordar las limitaciones inherentes a este enfoque, y que el modo de referencia anulable activado no protege contra errores con la eliminaci√≥n de referencias de enlaces nulos, y si se usa incorrectamente, incluso puede conducir a ellos.  Vale la pena considerar el uso de un analizador est√°tico moderno, por ejemplo PVS-Studio, que admite el an√°lisis interprocedial, como una herramienta adicional que, junto con la Referencia anulable, puede protegerlo de la desreferenciaci√≥n de referencias nulas.  Cada uno de estos enfoques, tanto el an√°lisis interprocedural en profundidad como la anotaci√≥n de firmas de m√©todos (que esencialmente hace la Referencia Anulable), tiene sus ventajas y desventajas.  El analizador le permitir√° obtener una lista de lugares potencialmente peligrosos y, al cambiar un c√≥digo existente, ver todas las consecuencias de dichos cambios.  Si asigna <i>nulo</i> en cualquier caso, el analizador debe indicar inmediatamente a todos los consumidores la variable, donde no se verifica antes de desreferenciar. <br><br>  Puede buscar independientemente otros errores, tanto en el proyecto considerado como en el suyo.  Para hacer esto, solo necesita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargar</a> y probar el analizador PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Paul Eremeev, Alexander Senichkin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tipos de referencia anulables en C # 8.0 y an√°lisis est√°tico</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455230/">https://habr.com/ru/post/455230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455216/index.html">Medidor de velocidad Doppler</a></li>
<li><a href="../455218/index.html">Enfoque ecosist√©mico de la tecnolog√≠a empresarial</a></li>
<li><a href="../455224/index.html">Finger Music: Toca cualquier cosa con los SpecDrums de Sphero</a></li>
<li><a href="../455226/index.html">¬øPor qu√© aplicar un ling√ºista aplicado?</a></li>
<li><a href="../455228/index.html">El que resucit√≥ a Duke Nukem: Entrevista con Randy Pitchford, asistente de Gearbox</a></li>
<li><a href="../455234/index.html">Tipos de referencia anulables en C # 8.0 y an√°lisis est√°tico</a></li>
<li><a href="../455236/index.html">Comodo revoca certificados sin motivo</a></li>
<li><a href="../455240/index.html">Uso de la tasa de defectos rechazados para mejorar el informe de errores</a></li>
<li><a href="../455242/index.html">Menos o√≠dos o c√≥mo no estropear el sonido en el juego desde el principio</a></li>
<li><a href="../455244/index.html">Comic "Soldar es f√°cil" en la versi√≥n actualizada (2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>