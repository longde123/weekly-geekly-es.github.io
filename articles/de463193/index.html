<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèº üà∑Ô∏è ü•â Konvertieren Sie Schwarzwei√übilder mit nicht negativer Matrixzerlegung in ASCII-Grafiken üëÇüèΩ ‚ôæ üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Allgemeinen ist das Konvertieren eines Bildes in ASCII-Grafiken eine ziemlich zeitaufw√§ndige Aufgabe, aber es gibt Algorithmen, die diesen Prozess ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konvertieren Sie Schwarzwei√übilder mit nicht negativer Matrixzerlegung in ASCII-Grafiken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463193/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hq/s7/wl/hqs7wlxixfh79akhz1b_mtsqdby.png" width="500"></div><br>  Im Allgemeinen ist das Konvertieren eines Bildes in ASCII-Grafiken eine ziemlich zeitaufw√§ndige Aufgabe, aber es gibt Algorithmen, die diesen Prozess automatisieren.  Dieser Artikel beschreibt den von den Forschern Paul D. O'Grady und Scott T. Rickard vorgeschlagenen Ansatz in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Automatische ASCII-Kunstkonvertierung von Bin√§rbildern unter Verwendung nicht negativer Einschr√§nkungen".</a>  Die von ihnen beschriebene Methode beinhaltet die Darstellung des Bildkonvertierungsprozesses als Optimierungsproblem und die L√∂sung dieses Problems unter Verwendung einer nicht negativen Matrixzerlegung.  Nachfolgend finden Sie eine Beschreibung des betreffenden Algorithmus sowie dessen Implementierung: <br><a name="habracut"></a><br><h2>  Beschreibung des Algorithmus </h2><br>  Das Originalbild ist in Gr√∂√üenbl√∂cke unterteilt <img src="https://habrastorage.org/getpro/habr/post_images/8ff/59f/7d7/8ff59f7d770613863cd2c0483685db98.svg" alt="M \ mal N.">  wo <img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M.">  und <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N.">  - Breite und H√∂he eines Zeichens in Pixel.  Wenn die Breite \ H√∂he des Bildes nicht ein Vielfaches der Breite \ H√∂he des Zeichens ist, wird das Bild zugeschnitten oder durch wei√üe Bereiche der gew√ºnschten Gr√∂√üe erg√§nzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/se/qe/pu/seqepumqylvcdk6upn-dd9vi_4q.png" width="250"></div><br>  Jeder von <img src="https://habrastorage.org/getpro/habr/post_images/b95/4f4/3ce/b954f43ce67f65a92502a661914b76e4.svg" alt="K.">  Bl√∂cke, die nach der Partition erhalten werden, werden als Vektor der L√§nge dargestellt <img src="https://habrastorage.org/getpro/habr/post_images/840/ed3/a5a/840ed3a5a13dc397969bf6a205f84279.svg" alt="R = M * N.">  deren Werte sind die Farbintensit√§ten der Bildpixel (Werte von 0 bis 255, wobei das wei√üe Pixel dem Wert 0 und das schwarze Pixel 255 entspricht).  Die resultierenden Vektoren sollten unter Verwendung der Norm normalisiert werden <img src="https://habrastorage.org/getpro/habr/post_images/966/980/a89/966980a893368f21382de225cb386c40.svg" alt="l_2">  :: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9d/025/739/b9d025739593e0f7204d847a453696f6.svg" alt="v_i = \ frac {v_i} {\ sqrt {\ sum ^ R_ {k = 1} {v ^ 2_k}}}"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/yp/lz/dyyplzoz5tqb1lcykfkm-4imbm8.png" width="500"></div><br>  Die normalisierten Vektoren werden in Form von Spalten umgeschrieben, wodurch eine Matrix gebildet wird <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V.">  die Gr√∂√üe <img src="https://habrastorage.org/getpro/habr/post_images/083/983/d7b/083983d7b6c59f43192e4290078b5f25.svg" alt="R \ mal K.">  . <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/86/sx/hn/86sxhn1rqtrj8zgc4ggxdysimxa.png" width="550"></div><br>  Die resultierende Matrix <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V.">  m√ºssen als Produkt von Matrizen dargestellt werden <img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W.">  und <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H.">  Alle Elemente davon sind nicht negativ: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/bda/50f/47ebda50f4a5615da97271890fec3f87.svg" alt="V_ {R \ mal K} = W_ {R \ mal L} H_ {L \ mal K}"></div><br>  Matrix <img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W.">  im Voraus bekannt: Es ist √§hnlich wie die Matrix aufgebaut <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V.">  Anstelle von Abschnitten des Originalbilds werden jedoch Bilder aller Symbole verwendet, die bei der Erzeugung von ASCII-Grafiken verwendet werden.  Wenn das zutreffende Kit enth√§lt <img src="https://habrastorage.org/getpro/habr/post_images/899/a67/551/899a675510d28419769a9b42281f0c65.svg" alt="L.">  Zeichen dann die Matrix <img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W.">  wird eine Gr√∂√üe haben <img src="https://habrastorage.org/getpro/habr/post_images/a76/a5a/884/a76a5a884fe0da7d2cdfeeab7d895c8f.svg" alt="R \ mal L.">  . <br>  Es bleibt nur eine Matrix zu w√§hlen <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H.">  um den Wert einer Zielfunktion zu minimieren, die den Unterschied zwischen charakterisiert <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V.">  und arbeiten <img src="https://habrastorage.org/getpro/habr/post_images/606/4df/837/6064df837796bdcfd80eee8bf2cb5eba.svg" alt="WH">  .  Die folgende Abh√§ngigkeit wird als solche Funktion verwendet: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35d/fe5/834/35dfe58346bb38035eb7f9f1e5c0cc2d.svg" alt="D (V, W, H, \ beta) = \ sum_ {ik} \ bigg ({v_ {ik} \ frac {v_ {ik} ^ {\ beta-1} - [WH] ^ {\ beta-1} _ {ik}} {\ beta (\ beta-1)}} + [WH] ^ {\ beta-1} _ {ik} \ frac {[WH] _ {ik} -v_ {ik}} {\ beta } \ bigg)"></div><br>  Dieser Ausdruck kombiniert im Wesentlichen mehrere objektive Funktionen: wann <img src="https://habrastorage.org/getpro/habr/post_images/215/e6c/c96/215e6cc967c4f2092c353e52ef79ead5.svg" alt="\ beta = 2">  es wird in das Quadrat der euklidischen Entfernung (quadratische euklidische Entfernung) umgewandelt, wenn <img src="https://habrastorage.org/getpro/habr/post_images/e2b/8cc/041/e2b8cc04156c65f9868bf19291640ceb.svg" alt="\ beta \ rightarrow 1">  n√§hert sich der Kullback-Leibler-Divergenzstrecke und bei <img src="https://habrastorage.org/getpro/habr/post_images/419/9a1/7fa/4199a17fa752d575915ac78f256b3ca4.svg" alt="\ beta \ rightarrow 0">  - bis zur Entfernung von Itakura-Saito (Itakura-Saito-Divergenz). <br><br>  Direkte Matrixauswahl <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H.">  wie folgt hergestellt: <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H.">  Initialisiert mit zuf√§lligen Werten von 0 bis 1, wonach die Werte gem√§√ü der folgenden Regel iterativ aktualisiert werden (die Anzahl der Iterationen wird im Voraus festgelegt): <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/ab9/9ba/ce2ab99baf9cf808d44be37992988bd9.svg" alt="h_ {jk} = h_ {jk} \ frac {\ sum ^ R_ {i = 1} {w_ {ij} \ frac {v_ {ik}} {[WH] ^ {2- \ beta} _ {ik}} }} {\ sum ^ R_ {i = 1} {w_ {ij} [WH] ^ {\ beta-1} _ {ik}}}"></div><br>  Jeder Wert <img src="https://habrastorage.org/getpro/habr/post_images/40e/522/a20/40e522a2076658bdacea86b0879cbd0e.svg" alt="h_ {ij}">  entspricht dem √Ñhnlichkeitsgrad <img src="https://habrastorage.org/getpro/habr/post_images/75c/b01/aa8/75cb01aa8d9f97db4343ac0c5ef11b2d.svg" alt="ich">  Zeichen aus dem Set mit <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">  -th Abschnitt des Bildes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/jn/1m/pbjn1mivzxwizfdv4icdcxw-fam.png" width="380"></div><br>  So bestimmen Sie, welches Zeichen ersetzt werden soll <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">  Abschnitt reicht es aus, den Maximalwert in zu finden <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">  th Spalte der Matrix <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H.">  .  Die Zeilennummer, in der sich dieser Wert befindet, ist die Nummer des gew√ºnschten Zeichens im Satz.  Sie k√∂nnen auch einen Schwellenwert eingeben. <img src="https://habrastorage.org/getpro/habr/post_images/dfd/a20/501/dfda20501ea6a3b10420bbd24587e600.svg" alt="\ epsilon">  Wenn der gefundene Maximalwert unter diesem Schwellenwert liegt, wird der Bildabschnitt durch ein Leerzeichen ersetzt.  Die Verwendung eines Leerzeichens kann sich positiv auf das Erscheinungsbild des resultierenden Bildes auswirken, verglichen mit der Verwendung eines Symbols mit geringem √Ñhnlichkeitsgrad. <br><br><h2>  Implementierung </h2><br>  Der Algorithmus ist in C # implementiert.  ASCII-Grafiken werden mit 95 Zeichen (von 0x20 bis 0x7E) mit einer Gr√∂√üe von 11x23 Pixel generiert.  Die verwendete Schriftart ist Courier.  Unten finden Sie den Quellcode f√ºr die Funktion zum Konvertieren des Originalbilds in ASCII-Grafiken: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[,] ConvertImage( Bitmap image, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> beta, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> threshold, <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> iterationsCount, <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> threadsNumber, Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ProgressUpdated) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumHor = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Width / glyphWidth); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumVert = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Height / glyphHeight); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalCharactersNumber = charNumVert * charNumHor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> glyphSetSize = wNorm.ColumnCount; Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; v = SplitImage(image, charNumVert, charNumHor); Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; h = Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;.Build.Random( glyphSetSize, totalCharactersNumber, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContinuousUniform()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> progress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> step = (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>)(iterationsCount / <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iterationsCount; i++) { UpdateH(v, wNorm, h, beta, threadsNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % step == <span class="hljs-number"><span class="hljs-number">0</span></span>) { progress += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(progress &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { ProgressUpdated(progress); } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = GetAsciiRepresentation(h, charNumVert, charNumHor, threshold); ProgressUpdated(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Betrachten Sie jeden Schritt einzeln: <br><br>  1) Wir berechnen, wie viele Zeichen in die Breite und H√∂he des Bildes passen k√∂nnen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumHor = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Width / glyphWidth); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumVert = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Height / glyphHeight);</code> </pre><br>  Mit den berechneten Werten teilen wir das Originalbild in Bl√∂cke der erforderlichen Gr√∂√üe.  F√ºr jeden Block schreiben wir die Werte der Pixelfarbintensit√§t in die entsprechende Matrixspalte <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V.">  (Falls erforderlich, erweitern wir das Originalbild, indem wir der Matrix Nullwerte hinzuf√ºgen, die wei√üen Pixeln entsprechen.) Anschlie√üend normalisieren wir alle Spalten: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Matrix&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Bitmap image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> charNumVert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> charNumHor</span></span></span><span class="hljs-function">)</span></span> { Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; result = Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;.Build.Dense( glyphHeight * glyphWidth, charNumHor * charNumVert); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; charNumVert; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; charNumHor; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; glyphHeight; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; glyphWidth; i++) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x * glyphWidth + i &lt; image.Width) &amp;&amp; (y * glyphHeight + j &lt; image.Height)) { color = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> - image.GetPixel( x * glyphWidth + i, y * glyphHeight + j).R); } result[glyphWidth * j + i, charNumHor * y + x] = color; } } } } result = result.NormalizeColumns(<span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  2) F√ºllen Sie die Matrix <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H.">  Zufallswerte von 0 bis 1: <br><br><pre> <code class="cs hljs">Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; h = Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;.Build.Random( glyphSetSize, totalCharactersNumber, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContinuousUniform());</code> </pre><br>  Wir wenden die Aktualisierungsregel eine bestimmte Anzahl von Malen auf ihre Elemente an: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iterationsCount; i++) { UpdateH(v, wNorm, h, beta, threadsNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % step == <span class="hljs-number"><span class="hljs-number">0</span></span>) { progress += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(progress &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { ProgressUpdated(progress); } } }</code> </pre><br>  Die direkte Aktualisierung der Matrixelemente wird wie folgt implementiert (leider werden die mit der Division durch Null verbundenen Probleme mit einigen Kr√ºcken gel√∂st): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateH</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Matrix&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; v, Matrix&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; w, Matrix&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; h, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ushort</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsNumber</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> epsilon = <span class="hljs-number"><span class="hljs-number">1e-6</span></span>; Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; vApprox = w.Multiply(h); Parallel.For( <span class="hljs-number"><span class="hljs-number">0</span></span>, h.RowCount, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParallelOptions() { MaxDegreeOfParallelism = threadsNumber }, j =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; h.ColumnCount; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> numerator = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> denominator = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; w.RowCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(vApprox[i, k]) &gt; epsilon) { numerator += w[i, j] * v[i, k] / Math.Pow(vApprox[i, k], <span class="hljs-number"><span class="hljs-number">2.0</span></span> - beta); denominator += w[i, j] * Math.Pow(vApprox[i, k], beta - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { numerator += w[i, j] * v[i, k]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (beta - <span class="hljs-number"><span class="hljs-number">1.0</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { denominator += w[i, j] * Math.Pow(vApprox[i, k], beta - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { denominator += w[i, j]; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(denominator) &gt; epsilon) { h[j, k] = h[j, k] * numerator / denominator; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { h[j, k] = h[j, k] * numerator; } } }); }</code> </pre><br>  3) Der letzte Schritt besteht darin, ein geeignetes Symbol f√ºr jeden Bildabschnitt auszuw√§hlen, indem die Maximalwerte in den Matrixspalten ermittelt werden <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H.">  :: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[,] GetAsciiRepresentation( Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; h, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumVert, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumHor, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> threshold) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[,] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[charNumVert, charNumHor]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; h.ColumnCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; h.RowCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max &lt; h[i, j]) { max = h[i, j]; maxIndex = i; } } result[j / charNumHor, j % charNumHor] = (max &gt;= threshold) ? (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(firstGlyphCode + maxIndex) : <span class="hljs-string"><span class="hljs-string">' '</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Das resultierende Bild wird in die HTML-Datei geschrieben.  Den vollst√§ndigen Quellcode des Programms finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Beispiele f√ºr generierte Bilder </h2><br>  Nachfolgend finden Sie Beispiele f√ºr Bilder, die mit verschiedenen Parameterwerten erstellt wurden <img src="https://habrastorage.org/getpro/habr/post_images/818/11b/0b2/81811b0b26d4b7e534b439a41d4eb61f.svg" alt="\ beta">  und die Anzahl der Iterationen.  Das Originalbild hatte eine Gr√∂√üe von 407 x 500 Pixel, das resultierende Bild hatte eine Gr√∂√üe von 37 x 22 Zeichen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t-/ah/4s/t-ah4s39lekdubpaxzd_jj8zhte.png" width="600"></div><br><h2>  Fazit </h2><br>  In dem betrachteten Algorithmus k√∂nnen die folgenden Nachteile unterschieden werden: <br><br><ol><li>  Lange Bildverarbeitung: Abh√§ngig von der Gr√∂√üe des Bildes und der Anzahl der Iterationen kann die Verarbeitung mehrere zehn Sekunden bis einige zehn Minuten dauern. </li><li>  Verarbeitung von Detailbildern in schlechter Qualit√§t.  Ein Versuch, ein Bild eines menschlichen Gesichts zu konvertieren, f√ºhrt beispielsweise zu folgendem Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/mx/9c/uhmx9cl4ccuqhzhh1sydlp6ieai.png" width="600"></div></li></ol><br>  Gleichzeitig kann die Reduzierung der Anzahl der Teile durch Erh√∂hen der Helligkeit und des Kontrasts des Bildes das Erscheinungsbild des resultierenden Bildes erheblich verbessern: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/qs/qo/l4qsqozovwtwlkdw_ajn_wpbueq.png" width="600"></div><br>  Im Allgemeinen k√∂nnen wir trotz der obigen Nachteile den Schluss ziehen, dass der Algorithmus zufriedenstellende Ergebnisse liefert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463193/">https://habr.com/ru/post/de463193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463179/index.html">Big Data Big Billing: √úber BigData in der Telekommunikation</a></li>
<li><a href="../de463181/index.html">Figma - eine einfache L√∂sung f√ºr einen Designer, eine schwierige L√∂sung f√ºr einen Layoutdesigner</a></li>
<li><a href="../de463183/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 13. Konfigurieren Sie das VLAN</a></li>
<li><a href="../de463185/index.html">Wie starke bolivianische Erdbeben Berge in einer Tiefe von 660 Kilometern unter der Erde entdeckten</a></li>
<li><a href="../de463189/index.html">√úber Anonymit√§t im Internet, Leben und seine Relativit√§t</a></li>
<li><a href="../de463195/index.html">Was passiert mit dem Tele2 Internet?</a></li>
<li><a href="../de463197/index.html">Blazor + MVVM = Silverlight schl√§gt zur√ºck, weil das alte B√∂se unbesiegbar ist</a></li>
<li><a href="../de463203/index.html">Die schwere Zeitlast. Yandex berichtet √ºber h√§ufige Fehler bei der Arbeit mit der Zeit</a></li>
<li><a href="../de463205/index.html">Zun√§chst nicht funktionsf√§hig: Wie man mit einem Laptop unter Windows 10 und einem 32-Gigabyte-Laufwerk √ºberlebt</a></li>
<li><a href="../de463207/index.html">Chatbot-Entwicklung (Telegramm + Youtube)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>