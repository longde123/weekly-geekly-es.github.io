<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏽 🥨 🚲 Das Iterator-Architekturmuster im schnellen Universum 🙌 🤣 👠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="„Iterator“ ist eines der Entwurfsmuster, die Programmierer am häufigsten nicht bemerken, da seine Implementierung in der Regel direkt in die Standardw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Iterator-Architekturmuster im schnellen Universum</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437614/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Iterator“</a> ist eines der Entwurfsmuster, die Programmierer am häufigsten nicht bemerken, da seine Implementierung in der Regel direkt in die Standardwerkzeuge der Programmiersprache integriert ist.  Dies ist jedoch auch eines der Verhaltensmuster, die im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch „Gang of Four“, „GoF“, „Entwurfsmuster: Elemente wiederverwendbarer objektorientierter Software“ beschrieben</a> und verstanden werden Sein Gerät tut nie weh und manchmal kann es sogar bei etwas helfen. <br><a name="habracut"></a><br>  <i>Ein „Iterator“ ist eine Methode für den sequentiellen Zugriff auf alle Elemente eines zusammengesetzten Objekts (insbesondere auf Containertypen wie ein Array oder eine Menge).</i> <br><br><h3>  Standard-Sprachwerkzeuge </h3><br>  Erstellen Sie eine Art <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array</a> : <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbersArray = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre> <br>  ... und dann in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zyklus</a> durchgehen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbersArray { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(number) }</code> </pre><br>  ... scheint eine sehr natürliche Handlung zu sein, insbesondere für moderne Programmiersprachen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swift</a> .  Hinter den Kulissen dieser einfachen Aktion befindet sich jedoch Code, der die Prinzipien des Iteratormusters implementiert. <br><br>  In "Swift" muss der Variablentyp <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Sequence</code></a> implementieren, um eine Variable mit <code>for</code> -cycles "iterieren" zu können.  Für dieses Protokoll muss dem Typ unter anderem ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Iterator</code></a> vom Typ Typ <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">associatedtype</a></code> , der wiederum die Anforderungen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>IteratorProtocol</code></a> Protokolls implementieren muss, sowie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Factory-Methode</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>makeIterator()</code></a> , die einen bestimmten "Iterator" für diesen Typ zurückgibt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Iterator</span></span> : <span class="hljs-type"><span class="hljs-type">IteratorProtocol</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span> <span class="hljs-comment"><span class="hljs-comment">// Another requirements go here… }</span></span></code> </pre><br>  Das <code>IteratorProtocol</code> Protokoll enthält wiederum nur eine Methode - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>next()</code></a> , die das nächste Element in der Sequenz zurückgibt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Element</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span>.<span class="hljs-type"><span class="hljs-type">Element?</span></span> }</code> </pre><br>  Es klingt wie "viel komplizierter Code", ist es aber eigentlich nicht.  Unten werden wir das sehen. <br><br>  Der <code>Array</code> Typ implementiert das <code>Sequence</code> (allerdings nicht direkt, sondern über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Protokollvererbungskette</a> : Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MutableCollection</code></a> erbt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Collection</code></a> Anforderungen und letztere die <code>Sequence</code> Anforderungen), sodass insbesondere seine Instanzen mit <code>for</code> -cycles „iteriert“ werden können. <br><br><h3>  Benutzerdefinierte Typen </h3><br>  Was muss getan werden, um Ihren eigenen Typ iterieren zu können?  Wie so oft ist es am einfachsten, ein Beispiel zu zeigen. <br><br>  Angenommen, es gibt einen Typ, der ein Bücherregal darstellt, in dem bestimmte Instanzen einer Klasse gespeichert sind, die wiederum ein Buch darstellen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> author: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shelf</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>] }</code> </pre><br>  Um eine Instanz der <code>Shelf</code> Klasse "iterieren" zu können, muss diese Klasse die Anforderungen des <code>Sequence</code> erfüllen.  In diesem Beispiel reicht es aus, nur die Methode <code>makeIterator()</code> zu implementieren, zumal die anderen Protokollanforderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardimplementierungen</a> haben.  Diese Methode sollte eine Instanz eines Typs zurückgeben, der das <code>IteratorProtocol</code> Protokoll implementiert.  Glücklicherweise ist dies im Fall von Swift sehr wenig sehr einfacher Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShelfIterator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.books = books } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Book?</span></span> { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Return next underlying Book element. } } extension Shelf: Sequence { func makeIterator() -&gt; ShelfIterator { return ShelfIterator(books: books) } }</span></span></code> </pre><br>  Die <code>next()</code> -Methode vom Typ <code>ShelfIterator</code> als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>mutating</code></a> deklariert, da die <code>ShelfIterator</code> den <code>ShelfIterator</code> speichern muss, der der aktuellen Iteration entspricht: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Book?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !books.isEmpty { books.removeFirst() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.first }</code> </pre><br>  Diese Implementierungsoption gibt immer das erste Element in der Sequenz zurück oder <code>nil</code> wenn die Sequenz leer ist.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>defer</code></a> mit dem Code zum Ändern der iterierten Auflistung "umbrochen", wodurch das Element des letzten Iterationsschritts unmittelbar nach der Rückkehr der Methode entfernt wird. <br><br>  Anwendungsbeispiel: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book1 = <span class="hljs-type"><span class="hljs-type">Book</span></span>(author: <span class="hljs-string"><span class="hljs-string">". "</span></span>, title: <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book2 = <span class="hljs-type"><span class="hljs-type">Book</span></span>(author: <span class="hljs-string"><span class="hljs-string">". "</span></span>, title: <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book3 = <span class="hljs-type"><span class="hljs-type">Book</span></span>(author: <span class="hljs-string"><span class="hljs-string">". "</span></span>, title: <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shelf = <span class="hljs-type"><span class="hljs-type">Shelf</span></span>(books: [book1, book2, book3]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> book <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shelf { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(book.author) – \(book.title)"</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/* .  –  .  –   .  –   */</span></span></code> </pre><br>  Weil  Alle verwendeten Typen (einschließlich des <code>Array</code> zugrunde liegenden <code>Shelf</code> ) basieren auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semantik von Werten (im Gegensatz zu Referenzen)</a> . Sie müssen sich keine Sorgen machen, dass der Wert der ursprünglichen Variablen während der Iteration geändert wird.  Bei der Behandlung von Typen, die auf der Link-Semantik basieren, sollte dieser Punkt berücksichtigt und beim Erstellen eigener Iteratoren berücksichtigt werden. <br><br><h3>  Klassische Funktionalität </h3><br>  Der im Buch „Gangs of Four“ beschriebene klassische „Iterator“ kann neben der Rückgabe des nächsten Elements der iterierbaren Sequenz auch jederzeit das aktuelle Element im Iterationsprozess zurückgeben, wobei das erste Element der iterierbaren Sequenz und der Wert des „Flags“ angeben, ob noch vorhanden sind Elemente in einer iterierten Sequenz relativ zum aktuellen Iterationsschritt. <br><br>  Natürlich wäre es einfach, ein Protokoll zu deklarieren, wodurch die Funktionen des Standard- <code>IteratorProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassicIteratorProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentItem: <span class="hljs-type"><span class="hljs-type">Element?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Element?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDone: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre><br>  Das erste und das aktuelle Element werden seitdem optional zurückgegeben  Die Quellsequenz ist möglicherweise leer. <br><br>  Einfache Implementierungsoption: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShelfIterator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassicIteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentItem: <span class="hljs-type"><span class="hljs-type">Book?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Book?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDone: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.books = books first = books.first currentItem = books.first } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Book?</span></span> { currentItem = books.first books.removeFirst() isDone = books.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.first } }</code> </pre><br>  In der ursprünglichen Beschreibung des Musters ändert die <code>next()</code> -Methode den internen Status des Iterators, um zum nächsten Element zu wechseln, und ist vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Void</code></a> . Das aktuelle Element wird von der <code>currentElement()</code> -Methode zurückgegeben.  Im <code>IteratorProtocol</code> Protokoll sind diese beiden Funktionen so, als ob sie zu einer kombiniert würden. <br><br>  Die Notwendigkeit der <code>first()</code> -Methode ist ebenfalls zweifelhaft, weil  Der Iterator ändert die ursprüngliche Sequenz nicht und wir haben immer die Möglichkeit, auf sein erstes Element zuzugreifen (falls vorhanden, natürlich). <br><br>  Und da die <code>next()</code> -Methode nach Abschluss der Iteration <code>nil</code> zurückgibt, wird auch die <code>isDone()</code> -Methode unbrauchbar. <br><br>  Für akademische Zwecke ist es jedoch durchaus möglich, eine Funktion zu entwickeln, die die volle Funktionalität nutzen kann: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printShelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with iterator: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ShelfIterator)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bookIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> !iterator.isDone { bookIndex += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(bookIndex). \(iterator.currentItem!.author) – \(iterator.currentItem!.title)"</span></span>) <span class="hljs-number"><span class="hljs-number">_</span></span> = iterator.next() } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterator = <span class="hljs-type"><span class="hljs-type">ShelfIterator</span></span>(books: shelf.books) printShelf(with: &amp;iterator) <span class="hljs-comment"><span class="hljs-comment">/* 1. .  –  2. .  –   3. .  –   */</span></span></code> </pre><br>  Der <code>iterator</code> Parameter wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>inout</code></a> deklariert, weil  Sein interner Zustand ändert sich während der Ausführung der Funktion.  Und wenn die Funktion aufgerufen wird, wird die Iteratorinstanz nicht direkt durch ihren eigenen Wert übertragen, sondern als Referenz. <br><br>  Das Ergebnis des Aufrufs der <code>next()</code> -Methode wird nicht verwendet, wodurch das Fehlen des Rückgabewerts einer Lehrbuchimplementierung simuliert wird. <br><br><h3>  Anstelle einer Schlussfolgerung </h3><br>  Dies scheint alles zu sein, was ich diesmal sagen wollte.  Alles schöne Code und absichtliches Schreiben! <br><br>  <b>Meine anderen Artikel zu Designmustern:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Architekturvorlage" Besucher "(" Besucher ") im Universum von" iOS "und" Swift "</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Factory-Methode und Abstract Factory im Swift- und iOS-Universum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Architekturmuster" Builder "im Universum von" Swift "und" iOS "/" macOS "</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437614/">https://habr.com/ru/post/de437614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437602/index.html">Profilieren Sie ein Unity-Projekt mit Android Studio</a></li>
<li><a href="../de437604/index.html">Wellenfunktionskollaps: Ein von der Quantenmechanik inspirierter Algorithmus</a></li>
<li><a href="../de437606/index.html">Wer isst die Erinnerung an unser iPhone? Äpfel schälen</a></li>
<li><a href="../de437610/index.html">[longrid] 20 Jahre Programmierkarriere in einer großen Kleinstadt</a></li>
<li><a href="../de437612/index.html">Der IT-Riese wird sich mit Siliziumphotonik befassen - wie sich dies auf den Markt für Netzwerkgeräte auswirken wird</a></li>
<li><a href="../de437616/index.html">Sechs Monate ohne Umsatzrückgang von CEO und iPhone: Warum Intel-Aktien fallen</a></li>
<li><a href="../de437618/index.html">42 Google Advanced Search Operators (vollständige Liste)</a></li>
<li><a href="../de437620/index.html">Wie die Cloud-Technologie unsere Behandlung verändert</a></li>
<li><a href="../de437622/index.html">Erste Schritte mit dem Azure Machine Learning-Dienst</a></li>
<li><a href="../de437624/index.html">OpenSceneGraph: Texturgrundlagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>