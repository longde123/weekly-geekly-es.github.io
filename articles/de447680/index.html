<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏻 🐵 👎 Emulationsübungen: Xbox 360 FMA-Handbuch 👨🏽‍🎨 🚜 ☝🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor vielen Jahren habe ich in der Microsoft Xbox 360-Abteilung gearbeitet. Wir haben über die Veröffentlichung einer neuen Konsole nachgedacht und bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Emulationsübungen: Xbox 360 FMA-Handbuch</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447680/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f1/67d/d5b/1f167dd5bb4c689b618efd55229627d8.jpg"></div><br>  Vor vielen Jahren habe ich in der Microsoft Xbox 360-Abteilung gearbeitet.  Wir haben über die Veröffentlichung einer neuen Konsole nachgedacht und beschlossen, dass es großartig wäre, wenn diese Konsole Spiele von der Konsole der vorherigen Generation ausführen könnte. <br><br>  Die Emulation ist immer schwierig, aber es stellt sich als noch schwieriger heraus, wenn Ihre Unternehmenschefs ständig die Arten von Zentralprozessoren ändern.  Die erste Xbox (nicht zu verwechseln mit der Xbox One) verwendete eine x86-CPU.  In der zweiten Xbox verwendete die Xbox <em>360</em> leider einen PowerPC-Prozessor.  Die dritte Xbox, d. H. Die Xbox <em>One</em> , verwendete die x86 / x64-CPU.  Solche Sprünge zwischen verschiedenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ISAs</a> haben unser Leben nicht vereinfacht. <br><br>  Ich nahm an der Arbeit eines Teams teil, das der Xbox 360 beigebracht hat, viele Spiele der ersten Xbox zu emulieren, dh x86 auf PowerPC zu emulieren, und für diese Arbeit erhielt ich den Titel <em>„Ninja-Emulation“</em> .  Dann wurde ich gebeten, das Problem der Emulation der Xbox 360 PowerPC-CPU auf einer x64-CPU zu untersuchen.  Ich werde im Voraus sagen, dass ich keine zufriedenstellende Lösung gefunden habe. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/4d3/c4e/3be4d3c4e413e240333deba0635d05cb.png"></div><br><h2>  FMA! = MMA </h2><br>  Eines der Dinge, die mich störten, war Fused Multiplly Add oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FMA-</a> Anweisungen.  Diese Anweisungen erhielten drei Parameter am Eingang, multiplizierten die ersten beiden und addierten dann den dritten.  Verschmolzen bedeutete, dass das Runden erst am Ende der Operation durchgeführt wurde.  Das heißt, die Multiplikation wird mit voller Genauigkeit durchgeführt, wonach die Addition durchgeführt wird, und erst dann wird das Ergebnis auf die endgültige Antwort gerundet. <br><br>  Um dies anhand eines konkreten Beispiels zu zeigen, stellen wir uns vor, wir verwenden dezimale Gleitkommazahlen und zwei Präzisionsziffern.  Stellen Sie sich diese Berechnung als Funktion vor: <br><br><blockquote><code>FMA(8.1e1, 2.9e1, 4.1e1),  8.1e1 * 2.9e1 + 4.1e1,  81 * 29 + 41</code> </blockquote> <br>  <code>81*29</code> ist gleich <code>2349</code> und nach dem Hinzufügen von 41 erhalten wir <code>2390</code> .  Auf zwei Ziffern <code>2.4e3</code> wir <code>2400</code> oder <code>2.4e3</code> . <br><br>  Wenn wir keine FMA haben, müssen wir zuerst die Multiplikation durchführen, <code>2349</code> , was auf zwei Stellen Genauigkeit <code>2300 (2.3e3)</code> und <code>2300 (2.3e3)</code> .  Dann addieren wir <code>41</code> und erhalten <code>2341</code> , das erneut gerundet <em>wird,</em> und wir erhalten das Endergebnis <code>2300 (2.3e3)</code> , das weniger genau ist als die FMA-Antwort. <br><br><blockquote>  Anmerkung 1: <code>FMA(a,b, -a*b)</code> berechnet den Fehler in <code>a*b</code> , der tatsächlich cool ist. <br><br>  Anmerkung 2: Eine der Nebenwirkungen von Anmerkung 1 ist, dass <code>x = a * b – a * b</code> möglicherweise nicht Null zurückgibt, wenn der Computer automatisch FMA-Anweisungen generiert. </blockquote><br>  Daher liefert die FMA offensichtlich genauere Ergebnisse als einzelne Multiplikations- und Additionsanweisungen.  Wir werden nicht tief gehen, aber wir werden uns einig sein, dass die FMA genauer ist als ihre Alternativen, wenn wir zwei Zahlen multiplizieren und dann die dritte addieren müssen.  Außerdem haben FMA-Befehle häufig eine geringere Latenz als der Multiplikationsbefehl, dem der Additionsbefehl folgt.  In der Xbox 360-CPU waren die Latenz und die FMA-Verarbeitungsgeschwindigkeit gleich denen von <em>fmul</em> oder <em>fadd</em> , sodass die Verwendung von FMA anstelle von <em>fmul</em> gefolgt von abhängigem <em>fadd</em> die Verzögerung um die Hälfte reduzieren konnte. <br><br><h2>  FMA-Emulation </h2><br>  Der Xbox 360-Compiler <i>hat immer</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FMA-Anweisungen</a> generiert, sowohl Vektor- als auch Skalaranweisungen.  Wir waren uns nicht sicher, ob die von uns ausgewählten x64-Prozessoren diese Anweisungen unterstützen würden. Daher war es wichtig, sie schnell und genau zu emulieren.  Es war notwendig, dass unsere Emulation dieser Anweisungen ideal wurde, da ich aus meiner früheren Erfahrung mit der Emulation von Gleitkommaberechnungen wusste, dass „ziemlich nahe“ Ergebnisse dazu führten, dass Charaktere durch den Boden fielen, Autos aus der Welt flogen und so weiter. <br><br>  Was wird also <em>benötigt</em> , um FMA-Anweisungen perfekt zu emulieren, wenn die x64-CPU sie nicht unterstützt? <br><br>  Glücklicherweise wird die überwiegende Mehrheit der Gleitkommaberechnungen in Spielen mit Gleitkomma-Genauigkeit (32 Bit) ausgeführt, und ich könnte gerne Anweisungen mit doppelter Genauigkeit (64 Bit) in der FMA-Emulation verwenden. <br><br>  Es scheint, dass das Emulieren von FMA-Anweisungen mit Float-Genauigkeit unter Verwendung von Berechnungen mit doppelter Genauigkeit einfach sein sollte ( <em>Sprecherstimme: aber nicht; Gleitkommaoperationen sind niemals einfach</em> ).  Float hat eine Genauigkeit von 24 Bit und Double eine Genauigkeit von 53 Bit.  Dies bedeutet, dass Sie die Multiplikation fehlerfrei durchführen können, wenn Sie den eingehenden Float in Precision Double (verlustfreie Konvertierung) konvertieren.  Das heißt, um vollständig genaue Ergebnisse zu speichern, reichen nur 48 Bit Genauigkeit aus, und wir haben mehr, das heißt, alles ist in Ordnung. <br><br>  Dann müssen wir den Zusatz machen.  Es reicht aus, nur den zweiten Term im Float-Format zu nehmen, ihn in Double zu konvertieren und ihn dann zum Ergebnis der Multiplikation hinzuzufügen.  Da beim Multiplizieren keine Rundung auftritt und erst nach der Addition durchgeführt wird, reicht dies vollständig aus, um die FMA zu emulieren.  Unsere Logik ist perfekt.  Sie können den Sieg erklären und nach Hause zurückkehren. <br><br><h2>  Der Sieg war so nah ... </h2><br>  Das geht aber nicht.  Oder zumindest schlägt es für einige der eingehenden Daten fehl.  Überlegen Sie, warum dies passieren kann. <br><br><blockquote>  Call Hold Musik klingt ... </blockquote><br>  Ein Fehler tritt auf, weil nach der Definition von FMA Multiplikation und Addition mit voller Genauigkeit durchgeführt werden, wonach das Ergebnis mit einem Präzisions-Float gerundet wird.  Das haben wir <em>fast</em> geschafft. <br><br>  Die Multiplikation erfolgt ohne Rundung, und nach der Addition wird eine Rundung durchgeführt.  Dies <em>ähnelt dem</em> , was wir versuchen zu tun.  Das Runden nach dem Hinzufügen erfolgt jedoch mit <em>doppelter</em> Präzision.  Danach müssen wir das Ergebnis mit Float-Präzision speichern, weshalb erneut gerundet wird. <br><br>  Pooh  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Doppelte Rundung</a> . <br><br>  Es wird schwierig sein, dies klar zu demonstrieren. Kehren wir also zu unseren Dezimal-Gleitkommaformaten zurück, bei denen die einfache Genauigkeit zwei Dezimalstellen und die doppelte Genauigkeit vier Stellen beträgt.  Stellen wir uns vor, wir berechnen <code>FMA(8.1e1, 2.9e1, 9.9e-1)</code> oder <code>81 * 29 + .99</code> . <br><br>  Die genaue Antwort auf diesen Ausdruck wäre <code>2349.99</code> oder <code>2.34999e3</code> .  <code>2.3e3</code> wir auf Präzision einfach (zwei Ziffern) <code>2.3e3</code> , erhalten wir <code>2.3e3</code> .  Mal sehen, was schief geht, wenn wir versuchen, diese Berechnungen zu emulieren. <br><br>  Wenn wir <code>81</code> und <code>29</code> mit einer Genauigkeit von doppelt multiplizieren, erhalten wir <code>2349</code> .  So weit so gut. <br><br>  Dann addieren wir <code>.99</code> und erhalten <code>2349.99</code> .  Alles ist noch gut. <br><br>  Dieses Ergebnis wird auf die Genauigkeit von double gerundet und wir erhalten <code>2350 (2.350e3)</code> .  Ups <br><br>  Wir runden es auf die Präzisions-Single und erhalten gemäß den IEEE- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rundungsregeln auf</a> <code>2400 (2.4e3)</code> .  Das ist die falsche Antwort.  Es hat einen etwas größeren Fehler als das korrekt gerundete Ergebnis, das von der FMA-Anweisung zurückgegeben wird. <br><br>  Sie können angeben, dass das Problem in der IEEE-Umgebungsregel liegt, bis die nächste gerade ist.  Unabhängig davon, für welche Rundungsregel Sie sich entscheiden, wird es immer einen Fall geben, in dem die doppelte Rundung ein Ergebnis liefert, das sich von der tatsächlichen FMA unterscheidet. <br><br><h2>  Wie ist das alles ausgegangen? </h2><br>  Ich konnte keine vollständig zufriedenstellende Lösung für dieses Problem finden. <br><br>  Ich habe das Xbox-Team lange vor der Veröffentlichung der Xbox One verlassen und seitdem habe ich der Konsole nicht viel Aufmerksamkeit geschenkt, sodass ich nicht weiß, welche Entscheidung sie getroffen haben.  Moderne x64-CPUs verfügen über FMA-Anweisungen, die solche Operationen perfekt emulieren können.  Sie können den mathematischen x87-Coprozessor auch irgendwie verwenden, um FMA zu emulieren. Ich kann mich nicht erinnern, zu welcher Schlussfolgerung ich gekommen bin, als ich diese Frage untersucht habe.  Oder vielleicht haben die Entwickler einfach entschieden, dass die Ergebnisse ziemlich nahe beieinander liegen und verwendet werden können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447680/">https://habr.com/ru/post/de447680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447670/index.html">Importsubstitution in der Praxis. Teil 2. Der Anfang. Hypervisor</a></li>
<li><a href="../de447672/index.html">Katalog der IT-Systeme des Unternehmens</a></li>
<li><a href="../de447674/index.html">Der Code ist lebendig und tot. Teil Zwei Aktionen und Eigenschaften</a></li>
<li><a href="../de447676/index.html">Neue Mail.ru Mail und was hat der Oktopus damit zu tun?</a></li>
<li><a href="../de447678/index.html">Das Konzept einer kurzen Enzyklopädie</a></li>
<li><a href="../de447682/index.html">Space Data Center: 24 Stunden vor dem Start</a></li>
<li><a href="../de447684/index.html">So zeigen Sie Unternehmenswerte in einem Büro (ohne Poster und Slogans)</a></li>
<li><a href="../de447686/index.html">Ein sehr wichtiger Parameter von LED-Lampen, den nur wenige kennen</a></li>
<li><a href="../de447688/index.html">Auf die Frage nach Bitset</a></li>
<li><a href="../de447690/index.html">Kompilierbare Konfiguration eines verteilten Systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>