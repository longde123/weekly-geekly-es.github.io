<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéûÔ∏è ü•ö ‚öõÔ∏è ASP.NET Core valide üßùüèΩ üë©üèª‚Äçüé§ üöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Surtout pour les amateurs de livres de la s√©rie "C ++ en 24 heures", j'ai d√©cid√© d'√©crire un article sur ASP.NET Core. 


 Si vous n'avez pas d√©velopp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ASP.NET Core valide</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437002/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="ASP.NET Core valide"></a> </p><br><p>  Surtout pour les amateurs de livres de la s√©rie "C ++ en 24 heures", j'ai d√©cid√© d'√©crire un article sur ASP.NET Core. </p><br><p>  Si vous n'avez pas d√©velopp√© sous .NET ou sous une plate-forme similaire auparavant, cela n'a aucun sens d'aller sous la coupe pour vous.  Mais si vous √™tes int√©ress√© √† apprendre ce que l'IoC, DI, DIP, Interseptors, Middleware, Filtres (c'est-√†-dire tout ce qui diff√®re du Core du .NET classique), alors vous devez certainement cliquer sur "En savoir plus", pendant que vous d√©veloppez Sans comprendre tout cela, ce n'est clairement pas correct. </p><a name="habracut"></a><br><h2 id="ioc-di-dip">  IoC, DI, DIP </h2><br><p>  Si un th√©√¢tre commence par un cintre, ASP.NET Core commence par une injection de d√©pendance.  Pour faire face √† l'ID, vous devez comprendre ce qu'est l'IoC. </p><br><p>  En parlant d'IoC, on rappelle souvent le principe hollywoodien de ¬´Ne nous appelez pas, nous vous appellerons¬ª.  Ce qui signifie "Pas besoin de nous appeler, nous vous appellerons nous-m√™mes". </p><br><p> Diff√©rentes sources donnent diff√©rents mod√®les auxquels l'IoC peut √™tre appliqu√©.  Et tr√®s probablement, ils vont bien et se compl√®tent simplement.  Voici certains de ces mod√®les: usine, localisateur de service, m√©thode de mod√®le, observateur, strat√©gie. </p><br><p>  Examinons l'IoC en utilisant une application console simple comme exemple. </p><br><p>  Supposons que nous ayons deux classes simples qui impl√©mentent une interface avec une seule m√©thode: </p><br><pre><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p>  Les deux d√©pendent de l'abstraction (dans ce cas, l'interface agit comme une abstraction). </p><br><p>  Et disons que nous avons un objet de niveau sup√©rieur utilisant ces classes: </p><br><pre> <code class="plaintext hljs"> class Logging : ILayer { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Selon le param√®tre constructeur, la variable _instance est initialis√©e par une classe sp√©cifique.  Eh bien et en outre, lors de l'appel √† Write, la sortie vers la console ou vers Debug sera termin√©e.  Tout semble √™tre assez bon et m√™me, semble-t-il, correspond √† la premi√®re partie du principe d'inversion de d√©pendance </p><br><blockquote>  Les objets de niveau sup√©rieur sont ind√©pendants des objets de niveau inf√©rieur.  Celles-ci et celles-ci d√©pendent d'abstractions. </blockquote><p>  Dans notre cas, ILayer agit comme une abstraction. </p><br><p>  Mais nous devons aussi avoir un objet d'un niveau encore plus √©lev√©.  Celui qui utilise la classe Logging </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  En initialisant Logging avec 1, nous obtenons dans la classe Logging une instance de la classe qui g√©n√®re des donn√©es vers la console.  Si nous initialisons la journalisation avec un autre num√©ro, log.Write affichera les donn√©es dans Debug.  Tout, semble-t-il, fonctionne, mais cela fonctionne mal.  Notre objet de niveau sup√©rieur Main d√©pend des d√©tails du code de l'objet de niveau inf√©rieur - la classe Logging.  Si nous changeons quelque chose dans cette classe, nous devrons changer le code de la classe Main.  Pour √©viter que cela ne se produise, nous allons faire une inversion de contr√¥le - Inversion de contr√¥le.  Faisons en sorte que la classe Main contr√¥le ce qui se passe dans la classe Logging.  La classe Logging recevra, en tant que param√®tre constructeur, une instance d'une classe qui impl√©mente l'interface ILayer </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Et maintenant, notre classe principale ressemblera √† ceci: </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  En fait, nous d√©corons notre objet Logging avec l'objet n√©cessaire pour nous. </p><br><p>  Maintenant, notre application est conforme √† la deuxi√®me partie du principe d'inversion de d√©pendance: </p><br><blockquote>  Les abstractions sont ind√©pendantes des d√©tails.  Les d√©tails d√©pendent des abstractions.  C'est-√†-dire  nous ne connaissons pas les d√©tails de ce qui se passe dans la classe Logging, nous passons simplement la classe qui impl√©mente l'abstraction n√©cessaire. </blockquote><p>  Il existe un tel terme couplage √©tanche - connexion √©tanche.  Plus la connexion entre les composants de l'application est faible, mieux c'est.  Je voudrais noter que cet exemple d'application simple n'atteint pas un peu l'id√©al.  Pourquoi?  Oui, car dans la classe de plus haut niveau de Main, nous utilisons deux fois la cr√©ation d'instances de classe √† l'aide de new.  Et il y a une telle phrase mn√©motechnique ¬´Nouveau est un indice¬ª - ce qui signifie que moins vous utilisez de nouvelles, moins les connexions des composants sont serr√©es dans l'application et mieux c'est.  Id√©alement, nous ne devrions pas utiliser le nouveau DebugLayer, mais devrions obtenir DebugLayer d'une autre mani√®re.  Lequel?  Par exemple, √† partir d'un conteneur IoC ou √† l'aide de la r√©flexion d'un param√®tre pass√© √† Main. </p><br><p>  Nous avons maintenant compris ce qu'est l'inversion de contr√¥le (IoC) et ce qu'est l'inversion de d√©pendance (DIP).  Reste √† comprendre ce qu'est l'Injection de D√©pendance (DI).  L'IoC est un paradigme de conception.  L'injection de d√©pendance est un mod√®le.  C'est ce que nous avons maintenant dans le constructeur de la classe Logging.  Nous obtenons une instance d'une d√©pendance sp√©cifique.  La classe Logging d√©pend d'une instance d'une classe qui impl√©mente ILayer.  Et cette instance est inject√©e via le constructeur. </p><br><h2 id="ioc-container">  Conteneur IoC </h2><br><p>  Un conteneur IoC est un tel objet qui contient de nombreuses d√©pendances sp√©cifiques (d√©pendance).  La d√©pendance peut √™tre autrement appel√©e un service - en r√®gle g√©n√©rale, c'est une classe avec une certaine fonctionnalit√©.  Si n√©cessaire, la d√©pendance du type requis peut √™tre obtenue √† partir du conteneur.  L'injection de d√©pendance dans un conteneur est Inject.  Extraire - R√©soudre.  Voici un exemple du conteneur IoC auto-√©crit le plus simple: </p><br><pre> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p>  Juste une douzaine de lignes de code, mais vous pouvez d√©j√† l'utiliser (pas pour la production, bien s√ªr, mais √† des fins √©ducatives). </p><br><p>  Vous pouvez enregistrer la d√©pendance (par exemple, ConsoleLayer ou DebugLayer que nous avons utilis√© dans l'exemple pr√©c√©dent) comme ceci: </p><br><pre> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p>  Et extrayez-le du conteneur √† la place n√©cessaire du programme comme ceci: </p><br><pre> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p>  Dans les vrais conteneurs, Dispose () est √©galement impl√©ment√©, ce qui vous permet de d√©truire les ressources devenues inutiles. </p><br><p>  Soit dit en passant, le nom IoC container ne donne pas exactement le sens, car le terme IoC est beaucoup plus large dans son application.  Par cons√©quent, r√©cemment, le terme conteneur DI a √©t√© utilis√© de plus en plus souvent (car l'injection de d√©pendance est toujours appliqu√©e). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root">  Dur√©e de vie des services + diverses m√©thodes d'extension dans Composition Root </h2><br><p>  Les applications ASP.NET Core contiennent le fichier Startup.cs, qui est le point de d√©part de l'application pour configurer DI.  Configure DI dans la m√©thode ConfigureServices. </p><br><pre> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p>  Ce code ajoutera la classe SomeRepository au conteneur DI, qui impl√©mente l'interface ISomeRepository.  Le fait que le service soit ajout√© au conteneur √† l'aide d'AddScoped signifie qu'une instance de la classe sera cr√©√©e chaque fois qu'une page est demand√©e. <br>  Vous pouvez ajouter un service √† un conteneur sans sp√©cifier d'interface. </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p>  Mais cette m√©thode n'est pas recommand√©e, car votre application perd sa flexibilit√© et des connexions √©troites apparaissent.  Il est recommand√© de toujours sp√©cifier une interface, car dans ce cas, √† tout moment, vous pouvez remplacer une impl√©mentation de l'interface par une autre.  Et si les impl√©mentations prennent en charge le principe de substitution Liskov, alors en changeant le nom de la classe d'impl√©mentation d'un simple coup de pouce, vous changerez la fonctionnalit√© de l'application enti√®re. </p><br><p>  Il existe 2 autres options pour ajouter un service - AddSingleton et AddTransient. <br>  Lorsque vous utilisez AddSingleton, le service est cr√©√© une fois et lorsque vous utilisez l'application, l'appel est dirig√© vers la m√™me instance.  Utilisez cette m√©thode particuli√®rement soigneusement, car des fuites de m√©moire et des probl√®mes de multithreading sont possibles. </p><br><p>  AddSingleton a une petite fonctionnalit√©.  Il peut √™tre initialis√© soit au premier acc√®s </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p>  soit imm√©diatement apr√®s l'ajout au constructeur </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p>  Dans la deuxi√®me mani√®re, vous pouvez m√™me ajouter un param√®tre au constructeur. <br>  Si vous souhaitez ajouter un param√®tre au constructeur d'un service ajout√© non seulement √† l'aide d'AddSingleton, mais √©galement √† l'aide d'AddTransient / AddScoped, vous pouvez utiliser l'expression lambda: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p>  Et enfin, lorsque vous utilisez AddTransient, un service est cr√©√© chaque fois que vous y acc√©dez.  Id√©al pour les services l√©gers qui ne consomment pas de m√©moire et de ressources. </p><br><p>  Si avec AddSingleton et AddScoped tout devrait √™tre plus ou moins clair, alors AddTransient a besoin de clarification.  La documentation officielle donne un exemple dans lequel un certain service est ajout√© au conteneur DI √† la fois comme param√®tre du constructeur d'un autre service et s√©par√©ment de mani√®re ind√©pendante.  Et dans le cas o√π il est ajout√© s√©par√©ment √† l'aide d'AddTransient, il cr√©e son instance 2 fois.  Je vais donner un exemple tr√®s, tr√®s simplifi√©.  Dans la vraie vie, son utilisation n'est pas recommand√©e, car  les classes de simplicit√© n'h√©ritent pas des interfaces.  Disons que nous avons une classe simple: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p>  Et il existe une deuxi√®me classe qui contient la premi√®re en tant que service d√©pendant et re√ßoit cette d√©pendance en tant que param√®tre constructeur: </p><br><pre> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p>  Maintenant, nous injectons deux services: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p>  Et dans certains contr√¥leurs en action, ajoutez la r√©ception de nos d√©pendances et affichez les valeurs dans la fen√™tre de d√©bogage. </p><br><pre> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p>  Par cons√©quent, nous obtenons 2 valeurs Guid diff√©rentes.  Mais si nous rempla√ßons AddTransient par AddScoped, alors nous obtenons 2 valeurs identiques. </p><br><p>  Le conteneur IoC de l'application ASP.NET Core contient certains services par d√©faut.  Par exemple, IConfiguration est un service avec lequel vous pouvez obtenir les param√®tres d'application √† partir des fichiers appsettings.json et appsettings.Development.json.  IHostingEnvironment et ILoggerFactory avec lesquels vous pouvez obtenir la configuration actuelle et une classe d'assistance qui permet la journalisation. </p><br><p>  Les classes sont extraites du conteneur en utilisant la construction typique suivante (l'exemple le plus courant): </p><br><pre> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p>  Une variable avec des modificateurs d'acc√®s en lecture seule priv√©s est cr√©√©e dans la port√©e du contr√¥leur.  La d√©pendance est obtenue √† partir du conteneur dans le constructeur de la classe et affect√©e √† une variable priv√©e.  De plus, cette variable peut √™tre utilis√©e dans n'importe quelle m√©thode ou contr√¥leur d'action. <br>  Parfois, vous ne voulez pas cr√©er de variable pour l‚Äôutiliser dans une seule action.  Ensuite, vous pouvez utiliser l'attribut [FromServices].  Un exemple: </p><br><pre> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = ¬´  " + dateTime.Now; return View(); }</code> </pre> <br><p>  Cela semble √©trange, mais afin de ne pas appeler la m√©thode de la classe statique DateTime.Now () dans le code, il est parfois fait pour que la valeur de temps soit obtenue du service en tant que param√®tre.  Ainsi, il devient possible de passer √† tout moment en tant que param√®tre, ce qui signifie qu'il devient plus facile d'√©crire des tests et, en r√®gle g√©n√©rale, il devient plus facile d'apporter des modifications √† l'application. <br>  Cela ne veut pas dire que l'√©lectricit√© statique est mauvaise.  Les m√©thodes statiques sont plus rapides.  Et le plus probablement statique peut √™tre utilis√© quelque part dans le conteneur IoC lui-m√™me.  Mais si nous sauvegardons notre application de tout ce qui est statique et nouveau, nous obtiendrons plus de flexibilit√©. </p><br><h2 id="storonnie-di-konteynery">  Conteneurs DI tiers </h2><br><p>  Ce que nous avons examin√© et ce que le conteneur DI ASP.NET Core impl√©mente r√©ellement par d√©faut est l'injection de constructeur.  Il existe toujours la possibilit√© d'injecter une d√©pendance dans une propri√©t√© √† l'aide de l'injection de propri√©t√©, mais cette fonctionnalit√© n'est pas disponible dans le conteneur int√©gr√© √† ASP.NET Core.  Par exemple, nous pouvons avoir une classe que vous impl√©mentez en tant que d√©pendance, et cette classe a une sorte de propri√©t√© publique.  Imaginez maintenant que pendant ou apr√®s avoir inject√© la d√©pendance, nous devons d√©finir la valeur de la propri√©t√©.  Revenons √† un exemple similaire √† l'exemple que nous avons r√©cemment examin√©. <br>  Si nous avons une telle classe: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p>  que nous pouvons introduire comme addiction, </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p>  puis en utilisant le conteneur standard, nous ne pouvons pas d√©finir la valeur de la propri√©t√©. <br>  Si vous souhaitez utiliser cette opportunit√© pour d√©finir une valeur pour la propri√©t√© OperationId, vous pouvez utiliser une sorte de conteneur DI tiers qui prend en charge l'injection de propri√©t√©.  Soit dit en passant, l'injection de propri√©t√© n'est pas particuli√®rement recommand√©e.  Cependant, il existe toujours des m√©thodes d'injection de m√©thode et d'injection de m√©thode Setter, qui pourraient bien vous √™tre utiles et qui ne sont pas non plus prises en charge par le conteneur standard. </p><br><p>  Les conteneurs tiers peuvent avoir d'autres fonctionnalit√©s tr√®s utiles.  Par exemple, en utilisant un conteneur tiers, vous pouvez uniquement ajouter une d√©pendance aux contr√¥leurs qui ont un mot sp√©cifique dans le nom.  Et cas assez souvent utilis√© - conteneurs DI, optimis√©s pour les performances. <br>  Voici une liste de certains conteneurs DI tiers pris en charge par ASP.NET Core: Autofac, Castle Windsor, LightInject, DryIoC, StructureMap, Unity </p><br><p>  Bien que vous utilisiez un conteneur DI standard, vous ne pouvez pas utiliser l'injection de propri√©t√© / m√©thode, mais vous pouvez impl√©menter un service d√©pendant en tant que param√®tre constructeur en impl√©mentant le mod√®le Factory comme suit: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p>  Dans ce cas, GetService renverra null si le service d√©pendant n'est pas trouv√©.  Il existe une variante de GetRequiredService qui l√®vera une exception si le service d√©pendant n'est pas trouv√©. <br>  Le processus d'obtention d'un service d√©pendant √† l'aide de GetService applique en fait le mod√®le de localisateur de service. </p><br><h2 id="autofac">  Autofac </h2><br><p>  Jetons un ≈ìil √† Autofac avec un exemple pratique.  De mani√®re pratique, les services du conteneur peuvent √™tre enregistr√©s et re√ßus, √† la fois par d√©faut et en utilisant Autofac. </p><br><p>  Installez le package NuGet Autofac.Extensions.DependencyInjection. <br>  Modifiez la valeur renvoy√©e par la m√©thode ConfigureServices de void √† IServiceProvider.  Et ajouter une propri√©t√© </p><br><pre> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p>  Apr√®s cela, il deviendra possible d'ajouter du code comme le suivant √† la fin de la m√©thode ConfigureServices de la classe Startup (ce n'est qu'une des options d'enregistrement des services): </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p>  Ici builder.Populate (services);  Ajoute des services de IServiceCollection au conteneur.  Eh bien, il est d√©j√† possible d'enregistrer des services aupr√®s de builder.RegisterType.  Ah oui.  J'ai presque oubli√©.  Vous devez remplacer void par IServiceProvider la valeur de retour de la m√©thode ConfigureServices. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors">  AOP avec ASP.NET Core - Autofac Interseptors </h2><br><p>  Parlant de programmation orient√©e vers les aspects, ils mentionnent un autre terme - des pr√©occupations transversales.  La pr√©occupation est une information qui affecte le code.  Dans la version russe, ils utilisent le mot responsabilit√©.  Eh bien, les pr√©occupations transversales sont des responsabilit√©s qui affectent d'autres responsabilit√©s.  Mais id√©alement, ils ne devraient pas s'influencer mutuellement, non?  Lorsqu'ils s'influencent mutuellement, il devient plus difficile de changer de programme.  C'est plus pratique lorsque nous avons toutes les op√©rations s√©par√©ment.  La journalisation, les transactions, la mise en cache et bien plus peuvent √™tre effectu√©es √† l'aide d'AOP sans changer le code des classes et des m√©thodes elles-m√™mes. </p><br><p>  Dans le monde .NET, une m√©thode est souvent utilis√©e lorsque le code AOP est incorpor√© √† l'aide d'un post-processeur dans un code d'application d√©j√† compil√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostSharp</a> ). Ou bien, vous pouvez utiliser des intercepteurs - ce sont des hooks d'√©v√©nements qui peuvent √™tre ajout√©s au code d'application.  Ces intercepteurs utilisent g√©n√©ralement le d√©corateur que nous avons d√©j√† examin√© pour leur travail. </p><br><p>  Cr√©ons votre propre intercepteur.  L'exemple le plus simple et le plus typique qui est le plus facile √† reproduire est la journalisation. <br>  En plus du package Autofac.Extensions.DependencyInjection, nous installerons √©galement le package Autofac.Extras.DynamicProxy <br>  Install√©?  Ajoutez une classe de journal simple qui sera appel√©e lors de l'acc√®s √† certains services. </p><br><pre> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p>  Ajouter √† notre inscription Enregistrement Autofac de l'intercepteur: </p><br><pre> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p>  Et maintenant, √† chaque appel √† la classe, la m√©thode Intercept de la classe Logger sera appel√©e. <br>  Ainsi, nous pouvons simplifier notre vie et ne pas √©crire une entr√©e de journal au d√©but de chaque m√©thode.  Nous l'aurons automatiquement.  Et si vous le souhaitez, il nous sera facile de le modifier ou de le d√©sactiver pour l'ensemble de l'application. </p><br><p>  Nous pouvons √©galement supprimer .InterceptedBy (typeof (Logger));  et ajouter l'interception d'appels uniquement pour des services d'application sp√©cifiques en utilisant l'attribut [Intercept (typeof (Logger))] - vous devez le sp√©cifier avant l'en-t√™te de classe. </p><br><h2 id="middleware">  Middleware </h2><br><p>  ASP.NET poss√®de une cha√Æne sp√©cifique d'appels de code qui se produit √† chaque demande.  M√™me avant le chargement de l'interface utilisateur / MVC, certaines actions sont effectu√©es. </p><br><p>  C'est, par exemple, si nous ajoutons au d√©but de la m√©thode Configure de la classe Startup.cs le code </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p>  alors nous pouvons voir dans la console de d√©bogage quels fichiers nos demandes d'application.  En fait, nous obtenons les capacit√©s de l'AOP ¬´out of box¬ª <br>  Un petit exemple inutile, mais clair et informatif d'utilisation de middleware, je vais vous montrer maintenant: </p><br><pre> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p>  A chaque demande, une cha√Æne d'appels d√©marre.  Depuis chaque application, apr√®s avoir appel√© next.invoke (), la transition vers l'appel suivant est effectu√©e.  Et tout se termine apr√®s que l'application fonctionne. <br>  Vous ne pouvez ex√©cuter du code que lors de l'acc√®s √† une route sp√©cifique. <br>  Vous pouvez le faire en utilisant app.Map: </p><br><pre> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p>  Maintenant, si vous allez simplement sur la page du site, vous pouvez voir le texte "Bonjour!", Et si vous ajoutez / Au revoir √† la barre d'adresse, vous verrez Au revoir. </p><br><p>  Outre Use and Map, vous pouvez utiliser UseWhen ou MapWhen pour ajouter du code √† la cha√Æne du middleware uniquement dans certaines conditions sp√©cifiques. </p><br><p>  Jusqu'√† pr√©sent, il y a encore des exemples inutiles, non?  Voici un exemple normal: </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p>  Ici, nous ajoutons des en-t√™tes √† chaque demande pour aider √† prot√©ger la page contre les attaques de pirates. </p><br><p>  Ou voici un exemple de localisation: </p><br><pre> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p>  Maintenant, si vous ajoutez le param√®tre? Culture = fr √† l'adresse de la page, vous pouvez basculer la langue de l'application sur le fran√ßais (si la localisation est ajout√©e √† votre application, alors tout fonctionnera) </p><br><h2 id="filters">  Filtres </h2><br><p>  Si la cha√Æne du middleware fait r√©f√©rence aux processus avant MVC, les filtres fonctionnent avec MVC. <br>  Le diagramme sch√©matique suivant montre le fonctionnement des filtres. </p><br><p><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="Filtres"></p><br><p>  Tout d'abord, les filtres d'autorisation sont √©labor√©s.  C'est-√†-dire  vous pouvez cr√©er une sorte de filtre ou plusieurs filtres et y entrer une sorte de code d'autorisation qui fonctionnera sur les demandes. </p><br><p>  Ils remplissent ensuite les filtres de ressources.  √Ä l'aide de ces filtres, vous pouvez, par exemple, renvoyer certaines informations du cache. </p><br><p>  Ensuite, la liaison de donn√©es se produit et des filtres d'action sont ex√©cut√©s.  Avec leur aide, vous pouvez manipuler les param√®tres pass√©s √† Action et le r√©sultat renvoy√©. </p><br><p>  Les filtres d'exception comme l'indique le nom vous permettent d'ajouter une sorte de gestion g√©n√©rale des erreurs pour l'application.  Il devrait √™tre assez pratique de g√©rer les erreurs partout de la m√™me mani√®re.  Une sorte de AOP-shny plus. </p><br><p>  Les filtres de r√©sultats vous permettent d'effectuer une action avant d'ex√©cuter le contr√¥leur d'action ou apr√®s.  Ils sont assez similaires aux filtres d'action, mais ne sont ex√©cut√©s qu'en l'absence d'erreurs.  Convient pour la logique li√©e √† View. </p><br><p>       .            : </p><br><pre> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // -    ,     ,    context.Result = new ContentResult() { Content = "        " }; } }</code> </pre> <br><p>     DI  (   Startup.cs) </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p>      -    Action    </p><br><pre> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p>   ‚Äì    middleware    - action   .              Configure </p><br><pre> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("  middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p>      Action-     </p><br><pre> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BRKPP1NYCu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437002/">https://habr.com/ru/post/fr437002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436992/index.html">Essai et erreur lors du choix du proxy inverse HTTP</a></li>
<li><a href="../fr436994/index.html">Liquibase et Maven</a></li>
<li><a href="../fr436996/index.html">Cours final de sp√©cialisation Python du groupe Mail.ru</a></li>
<li><a href="../fr436998/index.html">Protection des micropuces contre l'ing√©nierie inverse et l'entr√©e non autoris√©e</a></li>
<li><a href="../fr437000/index.html">Comment apprendre aux gens √† utiliser git</a></li>
<li><a href="../fr437004/index.html">Les programmeurs YML r√™vent-ils de tests ansibles?</a></li>
<li><a href="../fr437006/index.html">Test de l'imprimante 3D Wanhao Duplicator 10</a></li>
<li><a href="../fr437008/index.html">PNL. Les bases. Techniques. D√©veloppement personnel. Partie 1</a></li>
<li><a href="../fr437010/index.html">√âchos du pass√©: l'exp√©rience de Young √† la base de la nouvelle m√©thode de spectroscopie aux rayons X</a></li>
<li><a href="../fr437014/index.html">La t√¢che de N corps ou comment faire sauter une galaxie sans quitter la cuisine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>