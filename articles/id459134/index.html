<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš§ ğŸ‘‡ğŸ½ ğŸŒš Pengalaman menggunakan BDD ğŸ•´ğŸ» ğŸ€ ğŸ•´ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekitar tujuh tahun yang lalu, Dan North dalam artikelnya menggambarkan aplikasi praktis dari pendekatan BDD, yang memungkinkan Anda membuat proses pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman menggunakan BDD</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/459134/"><p><img src="https://habrastorage.org/webt/oo/ze/t3/oozet3hyz1ptfa9q11me-mgcgh4.jpeg"></p><br><p>  Sekitar tujuh tahun yang lalu, Dan North dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya</a> menggambarkan aplikasi praktis dari pendekatan BDD, yang memungkinkan Anda membuat proses pengembangan lebih mudah dipahami dan dikelola dengan membangun komunikasi internal.  Industri ini menunjukkan minat yang meningkat pada metodologi ini setiap hari, yang bertujuan untuk interaksi produktif dari tim standar seperti "analytics-development-testing". </p><br><p>  Namun, sekarang hanya sebagian kecil dari perusahaan yang memutuskan untuk menggunakan BDD.  Mengapa </p><a name="habracut"></a><br><p>  Jadi, mari kita cari tahu.  BDD (Behaviour Driven Development) adalah metodologi fleksibel yang terkait erat dengan TDD (Test Driven Development - â€œDevelopment through Testingâ€).  Dari pengalaman, bahkan penguji berpengalaman sering tidak melihat perbedaan antara metodologi ini.  Memang, pada pandangan pertama sulit untuk mengisolasi: kedua pendekatan melibatkan penulisan dokumentasi dan tes sebelum dimulainya fase pengembangan.  Dan perbedaannya adalah ini: dalam BDD, untuk menggambarkan tes, Anda perlu menggunakan bahasa alami yang dapat dimengerti oleh setiap peserta proyek untuk, pada kenyataannya, menggabungkan pernyataan masalah, tes dan dokumentasi bersama.  Dengan kata lain, DSL (bahasa berorientasi subjek tertentu) didefinisikan, kemudian dibuat seperangkat frasa standar terbatas yang menjelaskan perilaku elemen yang diperlukan.  Kemudian, dengan bantuan mereka, sebuah skenario dikembangkan menggunakan fungsi baru, yang akan jelas bagi semua orang. </p><br><p>  Mari kita lihat perbedaannya sekali, dan itu akan menjadi jelas: </p><br><p><img src="https://habrastorage.org/webt/fg/s3/_e/fgs3_e71mp3t_ynlkbvbh-d6olw.png"></p><br><p>  Kami akan menyentuh contoh ini, tetapi pertama-tama, mari kita lihat seluruh variasi metodologi yang saat ini tidak relevan. </p><br><h2 id="sravnim-neskolko-metodologiy">  Bandingkan beberapa metodologi </h2><br><p>  Diagram di bawah ini menunjukkan perbandingan tiga pendekatan: TDD, TLD (Test Last Development) dan BDD: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/xz/st/lvxzstichnozebdmzcfl7wncxt8.png"></div><br><ul><li> Ketika kami bekerja sesuai dengan metodologi BDD, spesifikasi autotesting dan drafting menyertai setiap tahap siklus pengembangan perangkat lunak, yang memastikan relevansi autotest dan dokumentasi yang konstan. </li><li>  Metodologi TDD dan ATDD (Acceptance Testing) digabungkan dalam diagram dalam satu blok, karena  ditulis pada tahap analitik.  Seperti disebutkan di atas, TDD didasarkan pada tes menulis sebelum mengembangkan fungsionalitas.  Pengembang harus menulis tes untuk menulis fungsionalitas untuk pengujian. </li><li>  TLD (Test Last Development) mencakup pengujian setelah penerapan fungsionalitas. </li><li>  BDD bersifat universal dan dapat dimasukkan pada setiap tahap perkembangan. </li></ul><br><p>  Diagram kedua menunjukkan keterlibatan peserta dalam proses pengembangan dalam penulisan skrip. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/b_/ao/uqb_aoyi3-7jdr651-sdk6nmmzc.png"></div><br><ul><li>  Dalam BDD, setiap anggota tim dapat terhubung ke tes pada tahap apa pun, misalnya, analis, pengguna bisnis, pengembang, dan penguji, karena tes tersebut jelas bagi semua peserta dalam proses. </li><li>  BDD juga berguna karena Anda tidak perlu menghabiskan banyak waktu untuk menulis berbagai jenis dokumentasi.  Skema pengembangan klasik mensyaratkan, sekurang-kurangnya, spesifikasi dan skrip uji yang biasanya ditulis oleh orang yang berbeda.  Dalam BDD, spesifikasi adalah test case, sementara itu juga autotest.  Penguji tidak perlu menulis dokumentasi uji terpisah - analis yang menulis spesifikasi dari konstruksi bahasa alami (yang dapat dibaca dan dimengerti oleh anggota tim) sudah melakukan ini untuk mereka. </li></ul><br><p>  Tidak diragukan lagi, BDD adalah alat yang baik untuk mencapai kualitas produk.  Tes dan dokumentasi ditulis lebih cepat.  Untuk bisnis, sebuah proyek menjadi lebih transparan, berkat konstruksi bahasa alami yang dapat dimengerti oleh siapa pun yang jauh dari pemrograman. </p><br><p>  Ini tentang pro.  Namun demikian, seperti yang telah dikatakan, meskipun ada banyak keuntungan, sedikit yang menerapkan metodologi ini. </p><br><h2 id="bdd-vsem-horosh-no-pochemu-ego-ne-ispolzuyut">  BDD baik untuk semua orang, tetapi mengapa tidak menggunakannya? </h2><br><p>  Jawabannya sederhana: panjang dan mahal.  Sebagian besar perusahaan IT akan setuju dengan pernyataan ini.  Dan pada awalnya kami tidak terkecuali.  BDD tidak nyaman bahkan jika memerlukan keterlibatan spesialis pengujian yang sudah pada tahap elaborasi persyaratan. </p><br><p>  BDD membalikkan pedoman pengembangan klasik (TLD) secara terbalik.  Ini diimplementasikan dengan buruk karena sulit.  Siklus pengembangan memanjang. </p><br><p>  BDD tidak diragukan lagi cara untuk mencapai kualitas.  Tetapi tidak semua orang bersedia membayar waktu dan spesialis untuk kualitas ini. </p><br><p>  Namun, apa yang harus saya lakukan jika saya masih ingin menerapkan BDD? </p><br><p>  Anda dapat mencoba menggunakan kerangka kerja yang sudah jadi.  Misalnya Mentimun, Squish, Yulup. </p><br><p>  Masalah utama dari kompleksitas BDD bukanlah dalam proses, tetapi dalam implementasi dan alat yang ada.  Ambil WEB sebagai contoh pengembangan sistem informasi perusahaan.  Memiliki implementasi web, kami menemukan WebDriver, yang saat ini menjadi standar untuk mengotomatisasi aplikasi yang berjalan di browser web.  Dia memiliki banyak peluang.  Untuk mempertimbangkan berbagai penyesuaian elemen halaman, Anda harus menemukan opsi untuk mengaksesnya.  Dan di sini, untuk memfasilitasi pengembangan tes, berbagai perpustakaan datang untuk menyelamatkan (Selenide, dll.), Yang menciptakan ekosistemnya sendiri yang perlu Anda ketahui.  Untuk bekerja dengan WebDriver, Anda memerlukan programmer atau otomatisasi tester  semuanya diimplementasikan menggunakan kode dan desain licik. </p><br><h2 id="nachalo-raboty-s-bdd-freymvorkom---slozhno-i-dolgo">  Memulai dengan kerangka BDD sulit dan memakan waktu. </h2><br><p>  Fokus kami adalah pada instrumen yang disebut Gauge.  Ini adalah kerangka kerja yang fleksibel dan ringan, didistribusikan di bawah lisensi gratis.  Terus terang, kami tidak benar-benar mempelajari alternatifnya, karena  Penggunaan Gauge telah ditentukan secara agresif oleh pelanggan kami. </p><br><p>  Dalam Gauge, pengujian ditulis dalam file spesifikasi (file dengan ekstensi .spec).  Spesifikasi tersebut berisi langkah-langkah tes yang ditulis dalam bahasa alami.  Langkah-langkah ini diimplementasikan dalam bahasa pemrograman (kami menggunakan bahasa pemrograman Java).  Saat menerapkan langkah-langkah, penting untuk mematuhi Konvensi Penamaan baik dalam nama skrip dan file implementasi, dan atas nama metode implementasi dan langkah skrip, mereka harus benar-benar identik.  Fleksibilitas tambahan untuk alat ini adalah bahwa langkah-langkah dapat memiliki parameter. </p><br><p>  Ukuran memungkinkan kami untuk menggunakan manfaat BDD.  Namun, kami masih mengalami masalah yang merupakan kompleksitas implementasi: masalah alat dan implementasi proses. </p><br><p>  Ternyata keterlibatan penguji pada tahap awal memiliki efek buruk pada hasil akhir.  Peningkatan waktu untuk mengembangkan tes.  Menggunakan kerangka kerja apa pun membutuhkan upaya besar dari penguji, yang, tidak diragukan lagi, harus memiliki perintah pemrograman yang baik.  Pada awalnya, proses bekerja dengan skrip adalah sebagai berikut: analis mengatakan tes kepada penguji, dan penulis teknis menuliskannya.  Sementara tester berurusan dengan implementasi perangkat lunak, arti dari fungsionalitas yang diuji berubah.  Ini mempengaruhi pemisahan titik masuk, dan itu harus menjadi satu, sebagai akibat dari proses dibagi dan berubah menjadi proses "normal", dari mana saya hanya ingin pergi.  Yaitu  titik masuk terbagi, komunikasi menyebar, tester langsung menuju pelaksanaan tes, penulis teknis mengerti dengan caranya sendiri, dan analis menulis ulang dok-doknya dan berubah pikiran, pengembang masuk ke "dunianya"). </p><br><p>  Penguji menghabiskan banyak waktu pada kode.  Tapi tetap saja tester yang sama harus memikirkan pencarian elemen pada halaman.  Situasi itu mengingatkan pada permainan anak-anak terkenal: "Telepon manja".  Runtuhnya terjadi.  Dan kami memutuskan: BDD hanya akan berfungsi jika analis dapat menulis tes.  Penting untuk mengurangi kerumitan tes menulis, untuk menyederhanakannya.  Tetapi untuk ini, Anda perlu menyederhanakan antarmuka pengujian secara signifikan.  Alat pengujian, implementasi proses bersama dengan semua pendekatan dan perpustakaan harus lebih sederhana. </p><br><p>  Karya penguji pada awalnya tampak seperti ini: </p><br><ol><li>  <em>Pemeriksaan dokumentasi, jika ada;</em> </li><li>  Menyusun daftar periksa; </li><li>  Pengujian ad-hoc </li><li>  Menyusun rencana uji; </li><li>  <em>Penyempurnaan dari pandangan dunia analis;</em> </li><li>  <em>Penyempurnaan gambar dunia oleh pengembang;</em> </li><li>  <em>Jika semuanya telah tumbuh bersama, tulislah dokumentasi pengujian, bersamaan dengan pengujian;</em> </li><li>  Menunggu bug diperbaiki, menguji bug; </li><li>  <em>Deskripsi halaman, kontrol, mencari elemen pada halaman menggunakan Web-Driver.</em>  <em>Cari apa yang sudah diterapkan dalam sistem pengujian;</em> </li><li>  Menulis tes logika; </li><li>  Lepaskan </li><li>  Bug dukungan / Bug pemulihan; </li><li>  <em>Pembaruan spesifikasi;</em> </li><li>  Perbaiki bug </li><li>  <em>Pembaruan autotest, memperbarui sejumlah besar kontrol yang diubah;</em> </li><li>  Lepaskan </li><li>  ... <br>  Item <em>dalam huruf miring</em> (1, 5, 6, 7, 9, 13, 15) menyebabkan biaya waktu.  Mereka dapat dan harus dioptimalkan. </li></ol><br><p>  Daftar ini diilustrasikan secara singkat dalam diagram proses pengembangan: </p><br><img src="https://habrastorage.org/webt/si/7y/m8/si7ym8xktulzmpgsvtsogu-5bfe.png"><br><p>  Perusahaan kami mengkhususkan diri dalam proyek-proyek dengan implementasi antarmuka web.  Berdasarkan ini, kami menggunakan alat Driver Web untuk berinteraksi dengan browser web. </p><br><p>  Secara de facto, Selenium Web Driver adalah standar, dan digunakan untuk menggambarkan objek web pada kerangka apa pun, termasuk Gauge, jUnit, perpustakaan Masquerade, dan lainnya.  Dia memiliki banyak fleksibilitas untuk tugas yang berbeda, yang menciptakan kesulitan yang berlebihan dalam masalah tipe lokal.  Kita perlu menemukan solusi untuk mengurangi kompleksitas. </p><br><p>  Sebagai contoh, mari kita tunjukkan dalam diagram bagaimana Selenium Web Driver, kerangka Gauge, perpustakaan Masquerade, dan bahasa pemrograman Java saling berhubungan. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ki/md/ib/kimdibdn1wmo8au4ubirnrbwsta.png"></div><br><p>  Dalam skema ini, alih-alih kerangka BDD, Anda dapat menempatkan jUnit, TestNG atau lainnya, bundel apa pun akan berfungsi, tergantung pada kebutuhan.  Selenium dan Masquerade akan tetap ada, bahasa pemrograman bisa diubah. </p><br><h2 id="uskorenie-processa-napisaniya-koda--podklyuchenie-masquerade">  Mempercepat Penulisan Kode - Menghubungkan Masquerade </h2><br><p>  Perusahaan kami berkembang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">platform CUBA</a> .  Dan khusus untuk platform ini, alat untuk autotest dikembangkan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masquerade</a> adalah perpustakaan yang menyediakan API ringkas dan nyaman untuk bekerja dengan kode ketika menerapkan tes menggunakan WebDriver.  Perpustakaan ini berfungsi pada Selenium Web Driver, berteman dengan selenide dan kerangka kerja apa pun. </p><br><p>  Dalam proyek CUBA, setiap elemen halaman web berisi cuba-id, yang tidak berubah.  CUBA menggunakan pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen</a> , dan perpustakaan Masquerade menyederhanakan interaksi dengan elemen halaman web.  Perpustakaan dapat melakukan tindakan dengan elemen halaman web yang diimplementasikan menggunakan CUBA dengan cara yang lebih sederhana.  Karena itu, ketika mencari elemen di halaman, Anda tidak perlu menggunakan konstruksi besar dengan XPath, seperti sebelumnya: </p><br><pre><code class="plaintext hljs">$(new By.ByXPath("//*/div/div[2]/div/div[2]/div/div/div[3]/div/div/div[3).click();</code> </pre> <br><p>  Atau konstruksi yang lebih ringkas di Jawa, yang, bagaimanapun, masih rumit: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String cssClass, String caption)</span></span></span><span class="hljs-function"> </span></span>{ $(By.cssSelector(cssClass) .$(byText(caption)) .closest(<span class="hljs-string"><span class="hljs-string">".v-button"</span></span>) .click(); }</code> </pre> <br><p>  Setelah menghubungkan perpustakaan Masquerade, deskripsi kontrol tertanam terlihat sederhana dan mudah diakses.  Anda bahkan tidak perlu mencari kontrol di halaman, karena  dia sudah memilikinya di proyek.  Berikut adalah contoh deskripsi tombol untuk formulir otorisasi dalam aplikasi: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7m/up/og/7mupog9cgkybpr5of9kctzreplg.png"></div><br><p>  Dalam kode halaman, kita melihat elemen <code>cuba-id=â€loginButtonâ€</code> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/8e/v-/ey8ev-vzpxdicfy1uohlen2eahg.png"></div><br><p>  Mari kita jelaskan tombol menggunakan perpustakaan Masquerade: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"WebHBoxLayout"</span></span>, <span class="hljs-string"><span class="hljs-string">"loginButton"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button loginButton;</code> </pre> <br><p>  Implementasi tes sederhana pada kerangka jUnit adalah blok otorisasi yang berjalan sebelum setiap tes: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginAdm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Tests loginTest = _$(Tests.class); loginTest.login(); }</code> </pre> <br><p>  Dan di tubuh metode login, kode berikut: </p><br><pre> <code class="java hljs">LoginWindow loginWindow = _$(LoginWindow.class); assertNotNull(loginWindow.getLoginField()); loginWindow.getLoginField() .shouldBe(EDITABLE) .shouldBe(ENABLED); loginWindow.loginField.setValue(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>); loginWindow.passwordField.setValue(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>); loginWindow.rememberMeCheckBox.setChecked(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); loginWindow.loginButton().click();</code> </pre> <br><p>  Yang paling penting adalah bagaimana kita menggambarkan halaman itu, bagaimana kita merujuk elemen.  Deskripsi halaman LoginWindow: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginWindow</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Composite</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginWindow</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"loginField"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TextField loginField; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"passwordField"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PasswordField passwordField; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"rememberMeCheckBox"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CheckBox rememberMeCheckBox; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"loginFormLayout"</span></span>, <span class="hljs-string"><span class="hljs-string">"loginButton"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button loginButton; }</code> </pre> <br><p>  Mencari barang hanyalah bagian dari perpustakaan Masquerade.  Mengakses elemen halaman web memungkinkan Anda untuk melakukan berbagai tindakan dengan elemen-elemen ini.  Misalnya, Anda dapat memilih item dari daftar drop-down: </p><br><pre> <code class="java hljs">getMaxResultsLayout().openOptionsPopup().select(<span class="hljs-string"><span class="hljs-string">"5000"</span></span>)</code> </pre> <br><p>  Atau urutkan tabel: </p><br><pre> <code class="java hljs">Table tb1 = client.getPaymentsTable(); tb1.sort(<span class="hljs-string"><span class="hljs-string">"column_year"</span></span>, Table.SortDirection.ASCENDING);</code> </pre> <br><p>  Lihat tangkapan layar di bawah ini untuk daftar beberapa tindakan tabel: </p><br><p><img src="https://habrastorage.org/webt/a_/yb/xi/a_ybxiqn6tnamitezd8ytoeu5tq.png"></p><br><p><img src="https://habrastorage.org/webt/zj/n8/0l/zjn80lwr-gurcycna9onk9bhgxk.png"></p><br><p><img src="https://habrastorage.org/webt/ui/gz/6i/uigz6imouut0epktbr8vsmunlj4.png"></p><br><p>  Menggunakan Masquerade telah sangat menyederhanakan penulisan tes, sekarang untuk menulis tes untuk fungsionalitas baru, Anda perlu: </p><br><ol><li>  Menggunakan Masquerade untuk menggambarkan halaman itu mudah dan tidak memerlukan keterampilan pemrograman khusus. </li><li>  Kumpulkan dalam satu kelas semua halaman yang digunakan saat memeriksa fungsionalitas. </li><li>  Dari konstruksi bahasa natural yang sudah jadi, kumpulkan skrip uji (ganti nama elemen yang diperlukan di sana), yaitu, tulis spesifikasi Gauge. </li></ol><br><h2 id="integriruem-masquerade-i-gauge">  Mengintegrasikan Masquerade dan Gauge </h2><br><p>  Sebelum menggunakan BDD, pendekatan TLD digunakan dan untuk bekerja dengannya kami juga mengoptimalkan proses penulisan kode tes.  Bundel jUnit / TestNG + WebDriver + Selenide + Masquerade yang digunakan. </p><br><p>  Sekarang, agar dapat bekerja dengan Gauge, kami menambahkan plug-in yang sesuai ke intellij IDEA.  Setelah itu, akan dimungkinkan untuk membuat jenis tes - Spesifikasi baru. </p><br><p>  Sekarang kita membuat spesifikasi (skrip) dan mengimplementasikan langkah-langkah menggunakan kemampuan WebDriver, Masquerade dan Java. </p><br><p><img src="https://habrastorage.org/webt/en/7c/sk/en7cskb3yo2k5cbwcnp_alqlfyq.png"></p><br><p>  Kami klik pada langkah skrip dan pergi ke implementasi: </p><br><p><img src="https://habrastorage.org/webt/lh/rx/zq/lhrxzqa-9gsnfzbson9w4hqndce.png"></p><br><p>  Dalam implementasinya, Anda dapat menggunakan metode login () yang ada. </p><br><h2 id="kak-zhe-vyglyadit-eto-sovershenstvo">  Seperti apakah kesempurnaan ini? </h2><br><p>  Ingat contoh yang kami periksa di awal artikel: </p><br><p><img src="https://habrastorage.org/webt/fg/s3/_e/fgs3_e71mp3t_ynlkbvbh-d6olw.png"></p><br><p>  <code>"Navigation.openMenu(menu)â€</code> berisi implementasi membuka menu menggunakan perpustakaan Masquerade. </p><br><p>  Perpustakaan kemudian diperluas dan langkah-langkah universal muncul yang dapat digunakan untuk aplikasi CUBA.  Ini adalah langkah-langkah yang memungkinkan Anda untuk bekerja dengan elemen-elemen program: tombol, bidang, tabel.  Langkah-langkah universal ini telah menjadi seperangkat frasa standar yang kami gunakan dalam BDD untuk menulis skrip. </p><br><p>  Berkat Masquerade + Gauge, kami secara signifikan mengurangi kerumitan pembuatan tes.  Sekarang tes dapat ditulis oleh orang-orang yang tidak memiliki keterampilan pemrograman khusus.  Sebuah tes dapat ditulis oleh satu orang (sebelumnya, sebuah skrip diciptakan oleh satu orang, tetapi diimplementasikan oleh orang lain, yang menyebabkan kebingungan).  Jadi, kami telah mencapai tujuan kami - antarmuka disederhanakan, dan tidak akan sulit bagi analis untuk menulis skrip pengujian. </p><br><p>  Perubahan proses ditunjukkan di bawah ini: </p><br><h6 id="bylo">  Itu: </h6><br><p><img src="https://habrastorage.org/webt/si/7y/m8/si7ym8xktulzmpgsvtsogu-5bfe.png" alt="Apakah"></p><br><h6 id="stalo">  Itu menjadi: </h6><br><p><img src="https://habrastorage.org/webt/7d/vv/-a/7dvv-awtowdnlwwhifgz7_njoac.png" alt="Telah menjadi"></p><br><p>  Sebagai perbandingan, terlihat bahwa persyaratan, spesifikasi, dan dokumentasi pengujian digabungkan dalam satu paragraf.  Dokumentasi pengujian juga merupakan autotest, dengan pengecualian implementasi langkah-langkah pengujian tertentu. </p><br><h2 id="itogi">  Ringkasan </h2><br><p>  Saat ini, kami berhasil mengembangkan sesuai dengan skema yang ditunjukkan di atas.  Dan kami berhasil menyingkirkan masalah utama BDD - peningkatan yang serius dalam hal kompleksitas implementasi, menambah dan menyelesaikan toolkit.  Namun, kualitas pengiriman produk telah meningkat. </p><br><p>  Waktu yang diperlukan untuk memelihara dokumentasi berkurang secara proporsional dengan jumlah spesifikasi yang diubah, karena  satu perubahan spesifikasi (logika sistem) secara otomatis mengarah ke perubahan autotest dalam satu iterasi.  Yaitu  tester tidak perlu masuk ke sistem dokumentasi (seperti Confluence, dll.) untuk pembaruan, dan ini juga berlaku untuk anggota tim lainnya. </p><br><p>  Waktu untuk mengimplementasikan dan mendukung tes di hadapan perpustakaan yang menyederhanakan bekerja dengan objek halaman telah dikurangi setengahnya dibandingkan dengan bekerja dengan driver web bersih yang biasa dan biaya pembuatan kembali tautan XP. </p><br><p>  Dalam pengembangan solusi bisnis dan manajemen mutu - biaya menghilangkan kesalahan dalam pengumpulan persyaratan dan analisis tumbuh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara eksponensial</a> .  Dengan demikian, kemungkinan masalah yang terkait dengan perubahan produk, sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> ada dan jadwal dalam pengembangan berulang, dengan deteksi dini masalah, yang merupakan studi yang baik tentang persyaratan, secara signifikan mengurangi biaya pengembangan, tergantung pada proyek.  Itu bisa 0% dan ~ 40%.  Peningkatan inilah yang dicapai melalui pengenalan BDD.  Ini dapat diimplementasikan tanpa menyebutnya kata BDD, tetapi itu ada di BDD.  Mampu mengatasi masalah adalah bagian penting dari jaminan kualitas. </p><br><p>  Sebagai kesimpulan, saya ingin mencatat bahwa skema pengembangan ini juga terintegrasi dengan Continuous Integration dan sistem manajemen uji QA Lens yang dikembangkan di perusahaan kami.  Di QA Lens, Anda dapat menulis skrip yang sama seperti di IDEA menggunakan bahasa berorientasi subjek.  Bahasa ini terdiri dari glosarium yang sebelumnya disusun dari tindakan yang tersedia yang sebelumnya dilaksanakan.  Saat melakukan autotest pada Gauge dari mesin pengembang atau CI, QA Lens secara otomatis mencatat langkah skrip mana yang selesai dan mana yang tidak.  Dengan demikian, setelah menjalankan autotest dari skrip yang ditulis oleh seorang analis, departemen pengujian segera menerima informasi terbaru yang lengkap tentang keadaan produk. </p><br><p>  Penulis: Sunagatov Ildar dan Yushkova Julia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Yushkova</a> ) <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459134/">https://habr.com/ru/post/id459134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459120/index.html">Komputer Tertanam Modular Seri UNO-1000/2000</a></li>
<li><a href="../id459122/index.html">Aleksey Savvateev: Hadiah Nobel Jean Tyrol untuk menganalisis pasar yang tidak sempurna (2014) dan reputasi kolektif</a></li>
<li><a href="../id459126/index.html">Raspberry Pi Robot Tank dengan Intel Neural Computer Stick 2</a></li>
<li><a href="../id459128/index.html">Antarmuka Jepang di dunia nyata</a></li>
<li><a href="../id459130/index.html">Penanganan kesalahan yang lembut di layanan microser</a></li>
<li><a href="../id459136/index.html">Pil Biru Palsu</a></li>
<li><a href="../id459138/index.html">Bagaimana kunci rahasia Huawei masuk ke firmware router Cisco</a></li>
<li><a href="../id459140/index.html">Penempatan implan: bagaimana hal ini dilakukan?</a></li>
<li><a href="../id459142/index.html">Membangun grafik garis rata-rata bergerak yang bergerak dalam R. Mengambil data melalui NBA API</a></li>
<li><a href="../id459144/index.html">Frontend Weekly Digest (1 - 7 Juli 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>