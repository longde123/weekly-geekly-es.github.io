<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßö üìø üßìüèΩ GLTF- und GLB-Grundlagen, Teil 2 üë©üèº‚Äç‚úàÔ∏è üéüÔ∏è ‚è≠Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine Fortsetzung der Grundlagen der Formate GLTF und GLB. Den ersten Teil des Artikels finden Sie hier . Im ersten Teil haben wir m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GLTF- und GLB-Grundlagen, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448298/"><p>  Dieser Artikel ist eine Fortsetzung der Grundlagen der Formate GLTF und GLB.  Den ersten Teil des Artikels finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Im ersten Teil haben wir mit Ihnen untersucht, warum das Format urspr√ºnglich geplant war, sowie Artefakte und deren Attribute des GLTF-Formats wie Szene, Knoten, Puffer, Pufferansicht, Accessor und Netz.  In diesem Artikel werden wir Material, Textur, Animationen, Haut, Kamera betrachten und die Erstellung einer minimal g√ºltigen GLTF-Datei abschlie√üen. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/f00/cb9/cd6f00cb95fe2f43b6a765ec8b216301.jpg" alt="Bild"><br><h2 id="material-i-texture">  Material und Textur </h2><br><p> Materialien und Texturen sind untrennbar mit dem Netz verbunden.  Bei Bedarf kann das Netz animiert werden.  Das Material speichert Informationen dar√ºber, wie das Modell von der Engine gerendert wird.  GLTF definiert Materialien mithilfe eines gemeinsamen Parametersatzes, der auf Physical-Based Rendering (PBR) basiert.  Mit dem PBR-Modell k√∂nnen Sie eine ‚Äûphysikalisch korrekte‚Äú Anzeige des Objekts unter verschiedenen Lichtbedingungen erstellen, da das Schattierungsmodell mit den ‚Äûphysikalischen‚Äú Oberfl√§cheneigenschaften arbeiten muss.  Es gibt verschiedene M√∂glichkeiten, PBR zu beschreiben.  Das gebr√§uchlichste Modell ist das Metallrauheitsmodell, das standardm√§√üig in GLTF verwendet wird.  Sie k√∂nnen auch das Spiegelglanzmodell verwenden, jedoch nur mit einer separaten Erweiterung (Erweiterung).  Die Hauptattribute des Materials sind wie folgt: </p><br><ol><li>  <strong>name</strong> ist der Name des Netzes. </li><li>  <strong>baseColorFactor / baseColorTexture</strong> - speichert Farbinformationen.  Im Fall des Faktorattributs werden Informationen in einem numerischen Wert f√ºr RGBA gespeichert, im Fall von Textur wird die Texturreferenz im Texturobjekt gespeichert. </li><li>  <strong>metallicFactor</strong> - speichert metallische Informationen </li><li>  <strong>roughnessFactor</strong> - speichert Informationen zur Rauheit </li><li>  <strong>doubleSided</strong> - true oder false (der Standardwert) und gibt an, ob das Netz auf beiden Seiten oder nur auf der "Vorderseite" gerendert wird. <a name="habracut"></a><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"materials"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"pbrMetallicRoughness"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"baseColorTexture"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"metallicFactor"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"roughnessFactor"</span></span>: <span class="hljs-number"><span class="hljs-number">0.800000011920929</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nightshade_MAT"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"doubleSided"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } ],</code> </pre> </li></ol><br><p>  Metallisch oder die Bedeutung von ‚ÄûMetallizit√§t‚Äú.  Dieser Parameter beschreibt, wie stark es √§hnlich wie echtes Metall reflektiert, d.h.  wie viel Licht von der Oberfl√§che reflektiert wird.  Der Wert wird von 0 bis 1 gemessen, wobei 0 ein Dielektrikum und 1 ein reines Metall ist. </p><br><p>  Rauheit oder "Rauheit".  Dieses Attribut zeigt an, wie ‚Äûrau‚Äú die Oberfl√§che ist, wodurch die Streuung von Licht von der Oberfl√§che beeinflusst wird.  Gemessen von 0 bis 1, wobei 0 vollkommen flach ist und 1 eine v√∂llig raue Oberfl√§che ist, die nur eine geringe Lichtmenge reflektiert. </p><br><p>  <strong>Textur</strong> - Ein Objekt, das Texturkarten (Texturkarten) speichert.  Solche Karten geben ein realistisches Modell.  Dank ihnen k√∂nnen Sie das Erscheinungsbild des Modells bestimmen, um verschiedene Eigenschaften wie Metallizit√§t, Rauheit, nat√ºrliche Verdunkelung der Umgebung und sogar die Eigenschaften des Gl√ºhens zu erhalten.  Texturen werden durch drei √ºbergeordnete Arrays beschrieben: Texturen, Sampler, Bilder.  Das Textures-Objekt verwendet Indizes, um auf Sampler- und Bildinstanzen zu verweisen.  Das wichtigste Objekt ist das Bild, weil  Er ist es, der die Standortinformationen der Karte speichert.  In Texturen wird es durch die Wortquelle beschrieben.  Das Bild befindet sich m√∂glicherweise irgendwo auf der Festplatte (z. B. "uri": "duckCM.png") oder ist in GLTF codiert ("bufferView": 14, "mimeType": "image / jpeg").  Sampler ist ein Objekt, das Filter- und Umbruchparameter definiert, die GL-Typen entsprechen. </p><br><p>  In unserem Dreiecksbeispiel gibt es keine Texturen, aber ich werde JSON von anderen Modellen geben, mit denen ich gearbeitet habe.  In diesem Beispiel wurden die Texturen in den Puffer geschrieben, sodass sie auch mit BufferView aus dem Puffer gelesen werden: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"textures"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-string"><span class="hljs-string">"images"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mimeType"</span></span>: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> } ],</code> </pre> <br><h2 id="animations">  Animationen </h2><br><p>  GLTF unterst√ºtzt artikulierte, geh√§utete und verwandelte Zielanimationen mithilfe von Keyframes.  Die Informationen dieser Frames werden in Puffern gespeichert und beziehen sich auf Animationen mit Accessoren.  GLTF 2.0 definiert nur den Animationsspeicher, definiert also kein bestimmtes Laufzeitverhalten wie Wiedergabereihenfolge, Autoplay, Loops, Timeline-Anzeige usw. Alle Animationen werden im Animations-Array gespeichert und als Set definiert Kan√§le (Kanalattribut) sowie eine Reihe von Abtastwerten, die von Accessoren bestimmt werden, die Informationen √ºber Schl√ºsselrahmen und die Interpolationsmethode (Abtastattribut) verarbeiten </p><br><p>  Die Hauptattribute des Animationsobjekts lauten wie folgt: </p><br><ol><li>  <strong>name</strong> - Name der Animation (falls vorhanden) </li><li>  <strong>channel</strong> - Ein Array, das die Ausgabewerte der Keyframes der Animation mit einem bestimmten Knoten in der Hierarchie verbindet. </li><li>  <strong>Sampler</strong> ist ein Attribut, das sich auf Accessor bezieht, das Schl√ºsselbilder aus dem Puffer verarbeitet. </li><li>  <strong>Ziel</strong> ist ein Objekt, das bestimmt, welcher Knoten (Knotenobjekt) mithilfe des Knotenattributs animiert werden muss und welche Eigenschaft des Knotens mithilfe des Pfadattributs animiert werden muss - √úbersetzung, Drehung, Skalierung, Gewichte usw.  Nicht animierte Attribute behalten ihre Werte w√§hrend der Animation bei.  Wenn der Knoten nicht definiert ist, sollte das Kanalattribut weggelassen werden. </li><li>  <strong>Sampler</strong> - Definiert Eingabe- und Ausgabepaare: Ein Satz skalarer Gleitkommawerte, die die lineare Zeit in Sekunden darstellen.  Alle Werte (Eingabe / Ausgabe) werden im Puffer gespeichert und sind √ºber Accessoren zug√§nglich.  Das Interpolationsattribut speichert den Interpolationswert zwischen Schl√ºsseln. </li></ol><br><p>  Im einfachsten GLTF gibt es keine Animationen.  Ein Beispiel stammt aus einer anderen Datei: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"animations"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Animate all properties of one node with different samplers"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"channels"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"rotation"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"scale"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"translation"</span></span> } } ], <span class="hljs-attr"><span class="hljs-attr">"samplers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span> } ] },</code> </pre> <br><h2 id="skin">  Haut </h2><br><p>  Skinning-Informationen, auch Skinning genannt, auch bekannt als Bone-Animation, werden im Skins-Array gespeichert.  Jeder Skin wird mithilfe des inverseBindMatrices-Attributs definiert, das sich auf den Accessor mit IBM-Daten (inverse bind matrix) bezieht.  Diese Daten werden verwendet, um die Koordinaten auf den gleichen Raum wie jedes Gelenk zu √ºbertragen, sowie das Attribut des Gelenkarrays, in dem die Knotenindizes aufgef√ºhrt sind, die als Gelenke f√ºr die Hautanimation verwendet werden.  Die Reihenfolge der Verbindungen wird im Array skin.joints festgelegt und muss mit der Datenreihenfolge von inverseBindMatrices √ºbereinstimmen.  Das Skelettattribut verweist auf ein Knotenobjekt, das die gemeinsame Wurzel der Gelenkhierarchie oder den direkten oder indirekten √ºbergeordneten Knoten einer gemeinsamen Wurzel darstellt. </p><br><p>  Ein Beispiel f√ºr die Verwendung des Skin-Objekts (nicht im Dreiecksbeispiel): </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"skins"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"skin_0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"inverseBindMatrices"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"joints"</span></span>: [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"skeleton"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> <br><p>  Die Hauptattribute: </p><br><ol><li>  <strong>Name</strong> - Hautname </li><li>  <strong>inverseBindMatrices</strong> - <strong>Gibt</strong> die <strong>Zugriffsnummer</strong> an, in der Informationen zur Inverse Bind Matrix <strong>gespeichert sind</strong> </li><li>  <strong>Gelenke</strong> - Gibt die Nummer des Accessors an, auf dem Informationen zu Gelenken gespeichert sind </li><li>  <strong>Skelett</strong> - Gibt die Nummer des Accessors an, der Informationen √ºber die "Wurzel" gespeichert hat. <br>  Gelenk / Gelenk, mit dem das Skelett des Modells beginnt </li></ol><br><h2 id="camera">  Kamera </h2><br><p>  Die Kamera bestimmt die Projektionsmatrix, die durch Transformieren der ‚ÄûAnsicht‚Äú in die Koordinaten des Clips erhalten wird.  Wenn es einfacher ist, bestimmen die Kameras das visuelle Erscheinungsbild (Betrachtungswinkel, Blickrichtung usw.), das der Benutzer beim Laden des Modells sieht. </p><br><p>  Die Projektion kann "Perspektive" und "Orthogonal" sein.  Kameras sind in Knoten enthalten und k√∂nnen Transformationen aufweisen.  Kameras sind in Knotenobjekten fixiert und k√∂nnen daher Transformationen aufweisen.  Die Kamera ist so definiert, dass die lokale + X-Achse nach rechts gerichtet ist, das Objektiv in Richtung der lokalen -Z-Achse schaut und die Oberseite der Kamera mit der lokalen + Y-Achse ausgerichtet ist.  Wenn die Transformation nicht angegeben ist, befindet sich die Kamera am Ursprung.  Die Kameras werden im Kamera-Array gespeichert.  Jeder von ihnen definiert ein Typattribut, das einen Projektionstyp (Perspektive oder Orthogonal) zuweist, sowie Attribute wie Perspektive oder Orthographie, in denen bereits detailliertere Informationen gespeichert sind.  Abh√§ngig vom Vorhandensein des zfar-Attributs k√∂nnen Kameras mit dem Perspektiventyp eine endliche oder unendliche Projektion verwenden. </p><br><p>  Eine Beispielkamera in JSON mit Typperspektive.  Nicht relevant f√ºr ein Beispiel einer minimal korrekten GLTF-Datei (Dreieck): </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"cameras"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Infinite perspective camera"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"perspective"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"perspective"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"aspectRatio"</span></span>: <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"yfov"</span></span>: <span class="hljs-number"><span class="hljs-number">0.660593</span></span>, <span class="hljs-attr"><span class="hljs-attr">"znear"</span></span>: <span class="hljs-number"><span class="hljs-number">0.01</span></span> } } ]</code> </pre> <br><p>  Die Hauptattribute des Kameraobjekts: </p><br><ol><li>  <strong>Name</strong> - Hautname </li><li>  <strong>Typ</strong> - Kameratyp, Perspektive oder orthografisch. </li><li>  <strong>Perspektive / Orthographie</strong> - Attribut, das Details des entsprechenden Typwerts enth√§lt </li><li>  <strong>Seitenverh√§ltnis</strong> - Seitenverh√§ltnis (fov). </li><li>  <strong>yfov</strong> - vertikaler Sichtfeldwinkel (fov) im Bogenma√ü </li><li>  <strong>zfar</strong> - Abstand zur entfernten Schnittebene </li><li>  <strong>znear</strong> - Abstand zur nahen Schnittebene </li><li>  <strong>Extras</strong> - anwendungsspezifische Daten </li></ol><br><h2 id="minimalnyy-validnyy-gltf-fayl">  Minimal g√ºltige GLTF-Datei </h2><br><p>  Am Anfang des Artikels schrieb ich, dass wir eine minimale GLTF-Datei sammeln werden, die 1 Dreieck enth√§lt.  Gepufferter JSON finden Sie unten.  Kopieren Sie es einfach in eine Textdatei und √§ndern Sie das Dateiformat in .gtlf.  Um ein 3D-Asset in einer Datei anzuzeigen, k√∂nnen Sie jeden Viewer verwenden, der GLTF unterst√ºtzt, aber ich pers√∂nlich verwende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies</a> </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"scenes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"mesh"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"meshes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"primitives"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"POSITION"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"indices"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ] } ], <span class="hljs-attr"><span class="hljs-attr">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA="</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">44</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"bufferViews"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34963</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34962</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"accessors"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"SCALAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] }, { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5126</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"VEC3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"asset"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-string"><span class="hljs-string">"2.0"</span></span> } }</code> </pre> <br><h2 id="chto-v-itoge">  Was ist das Ergebnis? </h2><br><p>  Abschlie√üend m√∂chte ich auf die wachsende Beliebtheit von GLTF- und GLB-Formaten hinweisen, die von vielen Unternehmen bereits aktiv genutzt werden und von denen einige bereits aktiv danach streben.  Die einfache Nutzung im sozialen Netzwerk Facebook (3D-Posts und in j√ºngerer Zeit 3D-Fotos), die aktive Nutzung von GLB in Oculus Home sowie eine Reihe von Innovationen, die auf der GDC 2019 angek√ºndigt wurden, tragen wesentlich zur Popularisierung des Formats bei. Leichtigkeit, schnelle Rendergeschwindigkeit, Benutzerfreundlichkeit, F√∂rderung der Khronos-Gruppe und Standardisierung des Formats - dies sind die Hauptvorteile, die, wie ich sicher bin, irgendwann dazu beitragen werden, das Format weiter zu f√∂rdern! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448298/">https://habr.com/ru/post/de448298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448288/index.html">Verwenden von C ++ und Vorlagen mit einer variablen Anzahl von Argumenten beim Programmieren von Mikrocontrollern</a></li>
<li><a href="../de448290/index.html">3D-Druck als Teil des revolution√§ren Konzepts Shipyard 4.0</a></li>
<li><a href="../de448292/index.html">√ñffnen Sie die API zum Akzeptieren von P2P-√úbertragungen</a></li>
<li><a href="../de448294/index.html">Das Gesetz zur Isolation der Runen wird von der Staatsduma in drei Lesungen verabschiedet</a></li>
<li><a href="../de448296/index.html">Freiberuflich und finanziell: 5 M√∂glichkeiten, sich zwischen einem Kunden und einem Freiberufler niederzulassen</a></li>
<li><a href="../de448300/index.html">Konferenz mailto: CLOUD - √ºber Wolken und Umgebung</a></li>
<li><a href="../de448302/index.html">Durch die Sicherheitsanf√§lligkeit in AdBlock- und uBlock-Filtern kann beliebiger Code auf der Benutzerseite ausgef√ºhrt werden</a></li>
<li><a href="../de448304/index.html">Das Buch "Vue.js in Aktion"</a></li>
<li><a href="../de448308/index.html">Data Science Digest (April 2019)</a></li>
<li><a href="../de448310/index.html">Schreiben eines Telegrammbots in Python mit der Telebot-Bibliothek Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>