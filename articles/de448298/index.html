<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚 📿 🧓🏽 GLTF- und GLB-Grundlagen, Teil 2 👩🏼‍✈️ 🎟️ ⏭️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine Fortsetzung der Grundlagen der Formate GLTF und GLB. Den ersten Teil des Artikels finden Sie hier . Im ersten Teil haben wir m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GLTF- und GLB-Grundlagen, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448298/"><p>  Dieser Artikel ist eine Fortsetzung der Grundlagen der Formate GLTF und GLB.  Den ersten Teil des Artikels finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Im ersten Teil haben wir mit Ihnen untersucht, warum das Format ursprünglich geplant war, sowie Artefakte und deren Attribute des GLTF-Formats wie Szene, Knoten, Puffer, Pufferansicht, Accessor und Netz.  In diesem Artikel werden wir Material, Textur, Animationen, Haut, Kamera betrachten und die Erstellung einer minimal gültigen GLTF-Datei abschließen. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/f00/cb9/cd6f00cb95fe2f43b6a765ec8b216301.jpg" alt="Bild"><br><h2 id="material-i-texture">  Material und Textur </h2><br><p> Materialien und Texturen sind untrennbar mit dem Netz verbunden.  Bei Bedarf kann das Netz animiert werden.  Das Material speichert Informationen darüber, wie das Modell von der Engine gerendert wird.  GLTF definiert Materialien mithilfe eines gemeinsamen Parametersatzes, der auf Physical-Based Rendering (PBR) basiert.  Mit dem PBR-Modell können Sie eine „physikalisch korrekte“ Anzeige des Objekts unter verschiedenen Lichtbedingungen erstellen, da das Schattierungsmodell mit den „physikalischen“ Oberflächeneigenschaften arbeiten muss.  Es gibt verschiedene Möglichkeiten, PBR zu beschreiben.  Das gebräuchlichste Modell ist das Metallrauheitsmodell, das standardmäßig in GLTF verwendet wird.  Sie können auch das Spiegelglanzmodell verwenden, jedoch nur mit einer separaten Erweiterung (Erweiterung).  Die Hauptattribute des Materials sind wie folgt: </p><br><ol><li>  <strong>name</strong> ist der Name des Netzes. </li><li>  <strong>baseColorFactor / baseColorTexture</strong> - speichert Farbinformationen.  Im Fall des Faktorattributs werden Informationen in einem numerischen Wert für RGBA gespeichert, im Fall von Textur wird die Texturreferenz im Texturobjekt gespeichert. </li><li>  <strong>metallicFactor</strong> - speichert metallische Informationen </li><li>  <strong>roughnessFactor</strong> - speichert Informationen zur Rauheit </li><li>  <strong>doubleSided</strong> - true oder false (der Standardwert) und gibt an, ob das Netz auf beiden Seiten oder nur auf der "Vorderseite" gerendert wird. <a name="habracut"></a><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"materials"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"pbrMetallicRoughness"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"baseColorTexture"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"metallicFactor"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"roughnessFactor"</span></span>: <span class="hljs-number"><span class="hljs-number">0.800000011920929</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nightshade_MAT"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"doubleSided"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } ],</code> </pre> </li></ol><br><p>  Metallisch oder die Bedeutung von „Metallizität“.  Dieser Parameter beschreibt, wie stark es ähnlich wie echtes Metall reflektiert, d.h.  wie viel Licht von der Oberfläche reflektiert wird.  Der Wert wird von 0 bis 1 gemessen, wobei 0 ein Dielektrikum und 1 ein reines Metall ist. </p><br><p>  Rauheit oder "Rauheit".  Dieses Attribut zeigt an, wie „rau“ die Oberfläche ist, wodurch die Streuung von Licht von der Oberfläche beeinflusst wird.  Gemessen von 0 bis 1, wobei 0 vollkommen flach ist und 1 eine völlig raue Oberfläche ist, die nur eine geringe Lichtmenge reflektiert. </p><br><p>  <strong>Textur</strong> - Ein Objekt, das Texturkarten (Texturkarten) speichert.  Solche Karten geben ein realistisches Modell.  Dank ihnen können Sie das Erscheinungsbild des Modells bestimmen, um verschiedene Eigenschaften wie Metallizität, Rauheit, natürliche Verdunkelung der Umgebung und sogar die Eigenschaften des Glühens zu erhalten.  Texturen werden durch drei übergeordnete Arrays beschrieben: Texturen, Sampler, Bilder.  Das Textures-Objekt verwendet Indizes, um auf Sampler- und Bildinstanzen zu verweisen.  Das wichtigste Objekt ist das Bild, weil  Er ist es, der die Standortinformationen der Karte speichert.  In Texturen wird es durch die Wortquelle beschrieben.  Das Bild befindet sich möglicherweise irgendwo auf der Festplatte (z. B. "uri": "duckCM.png") oder ist in GLTF codiert ("bufferView": 14, "mimeType": "image / jpeg").  Sampler ist ein Objekt, das Filter- und Umbruchparameter definiert, die GL-Typen entsprechen. </p><br><p>  In unserem Dreiecksbeispiel gibt es keine Texturen, aber ich werde JSON von anderen Modellen geben, mit denen ich gearbeitet habe.  In diesem Beispiel wurden die Texturen in den Puffer geschrieben, sodass sie auch mit BufferView aus dem Puffer gelesen werden: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"textures"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-string"><span class="hljs-string">"images"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mimeType"</span></span>: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> } ],</code> </pre> <br><h2 id="animations">  Animationen </h2><br><p>  GLTF unterstützt artikulierte, gehäutete und verwandelte Zielanimationen mithilfe von Keyframes.  Die Informationen dieser Frames werden in Puffern gespeichert und beziehen sich auf Animationen mit Accessoren.  GLTF 2.0 definiert nur den Animationsspeicher, definiert also kein bestimmtes Laufzeitverhalten wie Wiedergabereihenfolge, Autoplay, Loops, Timeline-Anzeige usw. Alle Animationen werden im Animations-Array gespeichert und als Set definiert Kanäle (Kanalattribut) sowie eine Reihe von Abtastwerten, die von Accessoren bestimmt werden, die Informationen über Schlüsselrahmen und die Interpolationsmethode (Abtastattribut) verarbeiten </p><br><p>  Die Hauptattribute des Animationsobjekts lauten wie folgt: </p><br><ol><li>  <strong>name</strong> - Name der Animation (falls vorhanden) </li><li>  <strong>channel</strong> - Ein Array, das die Ausgabewerte der Keyframes der Animation mit einem bestimmten Knoten in der Hierarchie verbindet. </li><li>  <strong>Sampler</strong> ist ein Attribut, das sich auf Accessor bezieht, das Schlüsselbilder aus dem Puffer verarbeitet. </li><li>  <strong>Ziel</strong> ist ein Objekt, das bestimmt, welcher Knoten (Knotenobjekt) mithilfe des Knotenattributs animiert werden muss und welche Eigenschaft des Knotens mithilfe des Pfadattributs animiert werden muss - Übersetzung, Drehung, Skalierung, Gewichte usw.  Nicht animierte Attribute behalten ihre Werte während der Animation bei.  Wenn der Knoten nicht definiert ist, sollte das Kanalattribut weggelassen werden. </li><li>  <strong>Sampler</strong> - Definiert Eingabe- und Ausgabepaare: Ein Satz skalarer Gleitkommawerte, die die lineare Zeit in Sekunden darstellen.  Alle Werte (Eingabe / Ausgabe) werden im Puffer gespeichert und sind über Accessoren zugänglich.  Das Interpolationsattribut speichert den Interpolationswert zwischen Schlüsseln. </li></ol><br><p>  Im einfachsten GLTF gibt es keine Animationen.  Ein Beispiel stammt aus einer anderen Datei: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"animations"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Animate all properties of one node with different samplers"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"channels"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"rotation"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"scale"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"translation"</span></span> } } ], <span class="hljs-attr"><span class="hljs-attr">"samplers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span> } ] },</code> </pre> <br><h2 id="skin">  Haut </h2><br><p>  Skinning-Informationen, auch Skinning genannt, auch bekannt als Bone-Animation, werden im Skins-Array gespeichert.  Jeder Skin wird mithilfe des inverseBindMatrices-Attributs definiert, das sich auf den Accessor mit IBM-Daten (inverse bind matrix) bezieht.  Diese Daten werden verwendet, um die Koordinaten auf den gleichen Raum wie jedes Gelenk zu übertragen, sowie das Attribut des Gelenkarrays, in dem die Knotenindizes aufgeführt sind, die als Gelenke für die Hautanimation verwendet werden.  Die Reihenfolge der Verbindungen wird im Array skin.joints festgelegt und muss mit der Datenreihenfolge von inverseBindMatrices übereinstimmen.  Das Skelettattribut verweist auf ein Knotenobjekt, das die gemeinsame Wurzel der Gelenkhierarchie oder den direkten oder indirekten übergeordneten Knoten einer gemeinsamen Wurzel darstellt. </p><br><p>  Ein Beispiel für die Verwendung des Skin-Objekts (nicht im Dreiecksbeispiel): </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"skins"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"skin_0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"inverseBindMatrices"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"joints"</span></span>: [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"skeleton"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> <br><p>  Die Hauptattribute: </p><br><ol><li>  <strong>Name</strong> - Hautname </li><li>  <strong>inverseBindMatrices</strong> - <strong>Gibt</strong> die <strong>Zugriffsnummer</strong> an, in der Informationen zur Inverse Bind Matrix <strong>gespeichert sind</strong> </li><li>  <strong>Gelenke</strong> - Gibt die Nummer des Accessors an, auf dem Informationen zu Gelenken gespeichert sind </li><li>  <strong>Skelett</strong> - Gibt die Nummer des Accessors an, der Informationen über die "Wurzel" gespeichert hat. <br>  Gelenk / Gelenk, mit dem das Skelett des Modells beginnt </li></ol><br><h2 id="camera">  Kamera </h2><br><p>  Die Kamera bestimmt die Projektionsmatrix, die durch Transformieren der „Ansicht“ in die Koordinaten des Clips erhalten wird.  Wenn es einfacher ist, bestimmen die Kameras das visuelle Erscheinungsbild (Betrachtungswinkel, Blickrichtung usw.), das der Benutzer beim Laden des Modells sieht. </p><br><p>  Die Projektion kann "Perspektive" und "Orthogonal" sein.  Kameras sind in Knoten enthalten und können Transformationen aufweisen.  Kameras sind in Knotenobjekten fixiert und können daher Transformationen aufweisen.  Die Kamera ist so definiert, dass die lokale + X-Achse nach rechts gerichtet ist, das Objektiv in Richtung der lokalen -Z-Achse schaut und die Oberseite der Kamera mit der lokalen + Y-Achse ausgerichtet ist.  Wenn die Transformation nicht angegeben ist, befindet sich die Kamera am Ursprung.  Die Kameras werden im Kamera-Array gespeichert.  Jeder von ihnen definiert ein Typattribut, das einen Projektionstyp (Perspektive oder Orthogonal) zuweist, sowie Attribute wie Perspektive oder Orthographie, in denen bereits detailliertere Informationen gespeichert sind.  Abhängig vom Vorhandensein des zfar-Attributs können Kameras mit dem Perspektiventyp eine endliche oder unendliche Projektion verwenden. </p><br><p>  Eine Beispielkamera in JSON mit Typperspektive.  Nicht relevant für ein Beispiel einer minimal korrekten GLTF-Datei (Dreieck): </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"cameras"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Infinite perspective camera"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"perspective"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"perspective"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"aspectRatio"</span></span>: <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"yfov"</span></span>: <span class="hljs-number"><span class="hljs-number">0.660593</span></span>, <span class="hljs-attr"><span class="hljs-attr">"znear"</span></span>: <span class="hljs-number"><span class="hljs-number">0.01</span></span> } } ]</code> </pre> <br><p>  Die Hauptattribute des Kameraobjekts: </p><br><ol><li>  <strong>Name</strong> - Hautname </li><li>  <strong>Typ</strong> - Kameratyp, Perspektive oder orthografisch. </li><li>  <strong>Perspektive / Orthographie</strong> - Attribut, das Details des entsprechenden Typwerts enthält </li><li>  <strong>Seitenverhältnis</strong> - Seitenverhältnis (fov). </li><li>  <strong>yfov</strong> - vertikaler Sichtfeldwinkel (fov) im Bogenmaß </li><li>  <strong>zfar</strong> - Abstand zur entfernten Schnittebene </li><li>  <strong>znear</strong> - Abstand zur nahen Schnittebene </li><li>  <strong>Extras</strong> - anwendungsspezifische Daten </li></ol><br><h2 id="minimalnyy-validnyy-gltf-fayl">  Minimal gültige GLTF-Datei </h2><br><p>  Am Anfang des Artikels schrieb ich, dass wir eine minimale GLTF-Datei sammeln werden, die 1 Dreieck enthält.  Gepufferter JSON finden Sie unten.  Kopieren Sie es einfach in eine Textdatei und ändern Sie das Dateiformat in .gtlf.  Um ein 3D-Asset in einer Datei anzuzeigen, können Sie jeden Viewer verwenden, der GLTF unterstützt, aber ich persönlich verwende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies</a> </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"scenes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"mesh"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"meshes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"primitives"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"POSITION"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"indices"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ] } ], <span class="hljs-attr"><span class="hljs-attr">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA="</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">44</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"bufferViews"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34963</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34962</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"accessors"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"SCALAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] }, { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5126</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"VEC3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"asset"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-string"><span class="hljs-string">"2.0"</span></span> } }</code> </pre> <br><h2 id="chto-v-itoge">  Was ist das Ergebnis? </h2><br><p>  Abschließend möchte ich auf die wachsende Beliebtheit von GLTF- und GLB-Formaten hinweisen, die von vielen Unternehmen bereits aktiv genutzt werden und von denen einige bereits aktiv danach streben.  Die einfache Nutzung im sozialen Netzwerk Facebook (3D-Posts und in jüngerer Zeit 3D-Fotos), die aktive Nutzung von GLB in Oculus Home sowie eine Reihe von Innovationen, die auf der GDC 2019 angekündigt wurden, tragen wesentlich zur Popularisierung des Formats bei. Leichtigkeit, schnelle Rendergeschwindigkeit, Benutzerfreundlichkeit, Förderung der Khronos-Gruppe und Standardisierung des Formats - dies sind die Hauptvorteile, die, wie ich sicher bin, irgendwann dazu beitragen werden, das Format weiter zu fördern! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448298/">https://habr.com/ru/post/de448298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448288/index.html">Verwenden von C ++ und Vorlagen mit einer variablen Anzahl von Argumenten beim Programmieren von Mikrocontrollern</a></li>
<li><a href="../de448290/index.html">3D-Druck als Teil des revolutionären Konzepts Shipyard 4.0</a></li>
<li><a href="../de448292/index.html">Öffnen Sie die API zum Akzeptieren von P2P-Übertragungen</a></li>
<li><a href="../de448294/index.html">Das Gesetz zur Isolation der Runen wird von der Staatsduma in drei Lesungen verabschiedet</a></li>
<li><a href="../de448296/index.html">Freiberuflich und finanziell: 5 Möglichkeiten, sich zwischen einem Kunden und einem Freiberufler niederzulassen</a></li>
<li><a href="../de448300/index.html">Konferenz mailto: CLOUD - über Wolken und Umgebung</a></li>
<li><a href="../de448302/index.html">Durch die Sicherheitsanfälligkeit in AdBlock- und uBlock-Filtern kann beliebiger Code auf der Benutzerseite ausgeführt werden</a></li>
<li><a href="../de448304/index.html">Das Buch "Vue.js in Aktion"</a></li>
<li><a href="../de448308/index.html">Data Science Digest (April 2019)</a></li>
<li><a href="../de448310/index.html">Schreiben eines Telegrammbots in Python mit der Telebot-Bibliothek Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>