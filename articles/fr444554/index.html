<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèæ üë∞üèø ü§πüèø L'API JSON RESTful la plus simple sur Elixir üêÆ ü§ûüèª üñïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment impl√©menter le point de terminaison de l'API JSON sur Elixir sans aucun framework? 


 Du traducteur: 
 L'article fournit un exemple d'une app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'API JSON RESTful la plus simple sur Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444554/"><p>  <strong>Comment impl√©menter le point de terminaison de l'API JSON sur Elixir sans aucun framework?</strong> </p><br><p>  <em>Du traducteur:</em> <em><br></em>  <em>L'article fournit un exemple d'une application Web tr√®s simple qui peut √™tre consid√©r√©e comme Hello, World!</em>  <em>dans la cr√©ation de l'API la plus simple sur Elixir.</em> <em><br></em>  <em>L'exemple de code est l√©g√®rement modifi√© afin de correspondre aux versions actuelles des biblioth√®ques.</em> <em><br></em>  <em>L'exemple de code complet avec les modifications peut √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/vheathen/elixir-">vu sur GitHub</a> .</em> </p><br><p><img src="https://habrastorage.org/webt/4u/ez/x7/4uezx7-azvbu2fk6bbbkj1veqdw.jpeg"></p><br><h2 id="problemy-novogo-yazyka">  Nouveaux d√©fis linguistiques </h2><br><p>  De nombreux d√©veloppeurs viennent √† Elixir du <strong>monde de Ruby.</strong>  <strong>Il s'agit d'un environnement tr√®s mature</strong> en termes de nombre de biblioth√®ques et de frameworks disponibles.  Et une telle maturit√© ne me suffit parfois pas dans Elixir.  Lorsque j'ai besoin d'un service tiers, le r√©sultat d'une recherche appropri√©e peut √™tre le suivant: </p><a name="habracut"></a><br><ul><li>  il y a une biblioth√®que officielle bien support√©e (tr√®s rare); </li><li>  il existe une biblioth√®que officielle, mais d√©pass√©e ou bogu√©e (cela arrive parfois); </li><li>  Il y a une biblioth√®que bien support√©e d√©velopp√©e par quelqu'un de la communaut√© (parfois de temps en temps); </li><li>  il y a une biblioth√®que d√©velopp√©e par quelqu'un de la communaut√©, mais qui n'est plus support√©e (un cas tr√®s courant); </li><li>  il existe plusieurs biblioth√®ques, dont chacune est √©crite par quelqu'un pour ses propres besoins, et il lui manque les fonctionnalit√©s n√©cessaires (l'option la plus populaire); </li><li>  il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma propre</a> biblioth√®que, combinant tout le meilleur de ce qui pr√©c√®de ... (trouv√© trop souvent). </li></ul><br><h2 id="prostoe-json-api-na-eliksire">  API JSON simple sur Elixir </h2><br><p><img src="https://habrastorage.org/webt/3k/3b/7u/3k3b7ugydkdw_7bcsz_hk3-ytdq.jpeg"></p><br><p>  Vous pourriez √™tre surpris, mais <strong>Ruby n'est pas toujours <em>sur les</em> rails</strong> ( <em>Ruby on Rails, souvenez-vous? - Note du traducteur</em> ).  La communication avec le Web n'est pas non plus toujours n√©cessaire pour participer.  Bien que dans ce cas particulier, parlons du Web. </p><br><p>  Lorsqu'il s'agit d'impl√©menter un seul point de terminaison RESTful, il existe g√©n√©ralement de nombreuses options: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rack-app</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hanami</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sinatra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Raisin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rails :: API</a> </li></ul><br><p>  Ce sont des exemples d'outils que j'ai personnellement utilis√©s.  Mes coll√®gues sont des utilisateurs satisfaits de Sinatra.  Ils ont r√©ussi √† essayer Hanami.  Je peux choisir n'importe quelle option qui me convient, m√™me en fonction de mon humeur actuelle. </p><br><p>  Mais quand je suis pass√© √† Elixir, il s'est av√©r√© que le choix √©tait limit√©.  Bien qu'il existe plusieurs ¬´frameworks¬ª alternatifs (dont je ne citerai pas les noms pour des raisons √©videntes), il est presque impossible de les utiliser! </p><br><p>  J'ai pass√© toute la journ√©e √† trier toutes les biblioth√®ques jamais mentionn√©es sur Internet.  Agissant en tant que bot Slack, j'ai essay√© de <strong>d√©ployer un simple serveur HTTP2 sur Heroku</strong> , mais √† la fin de la journ√©e, j'ai abandonn√©.  Litt√©ralement, aucune des options que j'ai trouv√©es n'a pu mettre en ≈ìuvre les exigences de base. </p><br><h2 id="ne-vsegda-reshenie---phoenix">  Pas toujours une solution - Phoenix </h2><br><p>  <strong>Phoenix est mon framework web pr√©f√©r√©, c'est juste que parfois c'est redondant.</strong>  Je ne voulais pas l'utiliser, tirant l'ensemble du cadre dans le projet exclusivement pour un seul point final;  et peu importe que ce soit tr√®s simple. </p><br><p>  Je ne pouvais pas non plus utiliser de biblioth√®ques pr√™tes √† l'emploi, car, comme je l'ai d√©j√† dit, toutes les biblioth√®ques que j'ai trouv√©es n'√©taient pas adapt√©es √† mes besoins (un routage de base et une prise en charge JSON √©taient n√©cessaires) ou n'√©taient pas assez pratiques pour un d√©ploiement facile et rapide sur Heroku.  Prenez du recul, pensai-je. </p><br><p><img src="https://habrastorage.org/webt/jf/qg/yl/jfqgylkj7urywy09ic2tqtmlnic.jpeg"></p><br><p>  Mais en fait, Phoenix lui-m√™me est construit sur la base <em>de quelque chose</em> , n'est-ce pas? </p><br><h2 id="plug--cowboy-prihodyat-na-pomosch">  Plug &amp; Cowboy vient √† la rescousse </h2><br><p> Si vous devez cr√©er un serveur vraiment minimaliste sur Ruby, vous pouvez simplement utiliser <code>rack</code> - une interface modulaire pour les serveurs Web Ruby. </p><br><p>  Heureusement, quelque chose de similaire est disponible dans Elixir.  Dans ce cas, nous utiliserons les √©l√©ments suivants: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cowboy</a> est un petit serveur HTTP rapide pour Erlang / OTP qui impl√©mente la pile HTTP compl√®te et le routage, optimis√© pour minimiser la latence et l'utilisation de la m√©moire; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plug</a> - un ensemble d'adaptateurs pour divers serveurs Web fonctionnant dans Erlang VM;  chaque adaptateur fournit une interface directe avec le serveur Web situ√© derri√®re lui; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poison</a> est une biblioth√®que de traitement de JSON sur Elixir. </li></ul><br><h1 id="realizaciya">  Impl√©mentation </h1><br><p>  Je veux impl√©menter des composants comme Endpoint (endpoint), Router (router) et JSON Parser (gestionnaire JSON).  Ensuite, je voudrais d√©ployer le r√©sultat sur Heroku et pouvoir traiter les demandes entrantes.  Voyons comment cela peut √™tre r√©alis√©. </p><br><h2 id="prilozhenie">  App </h2><br><p>  Assurez-vous que votre projet Elixir contient un superviseur.  Pour ce faire, cr√©ez un projet comme celui-ci: </p><br><pre> <code class="plaintext hljs">mix new minimal_server --sup</code> </pre> <br><p>  Assurez-vous que mix.exs contient: </p><br><pre> <code class="plaintext hljs">def application do [ extra_applications: [:logger], mod: {MinimalServer.Application, []} ] end</code> </pre> <br><p>  et cr√©ez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier</a> <code>lib/minimal_server/application.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do use Application def start(_type, _args), do: Supervisor.start_link(children(), opts()) defp children do [] end defp opts do [ strategy: :one_for_one, name: MinimalServer.Supervisor ] end end</code> </pre> <br><h2 id="biblioteki">  Biblioth√®ques </h2><br><p>  Les biblioth√®ques suivantes doivent √™tre sp√©cifi√©es dans <code>mix.exs</code> : </p><br><pre> <code class="plaintext hljs">defp deps do [ {:poison, "~&gt; 4.0"}, {:plug, "~&gt; 1.7"}, {:cowboy, "~&gt; 2.5"}, {:plug_cowboy, "~&gt; 2.0"} ] end</code> </pre> <br><p>  Ensuite, t√©l√©chargez et compilez les d√©pendances: </p><br><pre> <code class="plaintext hljs">mix do deps.get, deps.compile, compile</code> </pre> <br><h2 id="endpoint">  Endpoint </h2><br><p>  Maintenant, tout est pr√™t pour cr√©er un point d'entr√©e sur le serveur.  Cr√©ons un fichier <code>lib/minimal_server/endpoint.ex</code> avec le contenu suivant: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do use Plug.Router plug(:match) plug(Plug.Parsers, parsers: [:json], pass: ["application/json"], json_decoder: Poison ) plug(:dispatch) match _ do send_resp(conn, 404, "Requested page not found!") end end</code> </pre> <br><p>  Le module <code>Plug</code> contient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Plug.Router</code></a> pour rediriger les requ√™tes entrantes en fonction du chemin utilis√© et de la m√©thode HTTP.  D√®s r√©ception de la demande, le routeur appellera le module <code>:match</code> , repr√©sent√© par la fonction <code>match/2</code> , qui est responsable de trouver l'itin√©raire correspondant, puis le redirigera vers le module <code>:dispatch</code> , qui ex√©cutera le code correspondant. </p><br><p>  Puisque nous voulons que notre API soit compatible JSON, nous devons impl√©menter <code>Plug.Parsers</code> .  Puisqu'il traite les <code>application/json</code> avec le donn√© <code>:json_decoder</code> , nous l'utiliserons pour analyser le corps de la requ√™te. </p><br><p>  En cons√©quence, nous avons cr√©√© une route temporaire ¬´toute demande¬ª qui correspond √† toutes les demandes et r√©pond avec du code HTTP non trouv√© (404). </p><br><h2 id="marshrutizator">  Routeur </h2><br><p>  L'impl√©mentation d'un routeur sera la derni√®re √©tape de la cr√©ation de notre application.  C'est le dernier √©l√©ment de l'ensemble du pipeline que nous avons cr√©√©: en commen√ßant par recevoir une demande d'un navigateur Web et en terminant par la formation d'une r√©ponse. </p><br><p>  Le routeur traitera la demande entrante du client et renverra un message au format souhait√© ( <em>ajoutez le code donn√© dans le fichier <code>lib/minimal_server/router.ex</code> - note du traducteur</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Router do use Plug.Router plug(:match) plug(:dispatch) get "/" do conn |&gt; put_resp_content_type("application/json") |&gt; send_resp(200, Poison.encode!(message())) end defp message do %{ response_type: "in_channel", text: "Hello from BOT :)" } end end</code> </pre> <br><p>  Dans le module <code>Router</code> ci-dessus, la demande sera trait√©e uniquement si elle est envoy√©e par la m√©thode <code>GET</code> et envoy√©e le long de la route <code>/</code> .  Le module Router r√©pondra par un en <code>Content-Type</code> t√™te <code>Content-Type</code> contenant <code>application/json</code> et body: </p><br><pre> <code class="plaintext hljs">{ "response_type": "in_channel", "text": "Hello from BOT :)" }</code> </pre> <br><h2 id="soberyom-vsyo-vmeste">  Tout mettre ensemble </h2><br><p>  Il est maintenant temps de changer le module <code>Endpoint</code> pour transf√©rer les demandes au routeur et de modifier l' <code>Application</code> pour lancer le module <code>Endpoint</code> lui-m√™me. </p><br><p>  La premi√®re peut √™tre effectu√©e en ajoutant √† <code>MinimalServer.Endpoint</code> [ <em>avant la <code>match _ do ... end</code> r√®gle de <code>match _ do ... end</code> - env.</em>  <em>traducteur</em> ] cha√Æne </p><br><pre> <code class="plaintext hljs">forward("/bot", to: MinimalServer.Router)</code> </pre> <br><p>  Cela garantit que toutes les demandes √† <code>/bot</code> seront achemin√©es et trait√©es par le module <code>Router</code> . </p><br><p>  La seconde peut √™tre impl√©ment√©e en ajoutant les fonctions <code>child_spec/1</code> et <code>start_link/1</code> fichier <code>endpoint.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... def child_spec(opts) do %{ id: __MODULE__, start: {__MODULE__, :start_link, [opts]} } end def start_link(_opts), do: Plug.Cowboy.http(__MODULE__, []) end</code> </pre> <br><p>  Vous pouvez maintenant modifier <code>application.ex</code> en ajoutant <code>MinimalServer.Endpoint</code> √† la liste renvoy√©e par la fonction <code>children/0</code> . </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do # ... defp children do [ MinimalServer.Endpoint ] end end</code> </pre> <br><p>  Pour d√©marrer le serveur, faites simplement: </p><br><pre> <code class="plaintext hljs">mix run --no-halt</code> </pre> <br><p>  Enfin, vous pouvez visiter l'adresse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 4000 / bot</a> et voir notre message :) </p><br><h1 id="razvertyvanie">  D√©ploiement </h1><br><p><img src="https://habrastorage.org/webt/kf/8j/cb/kf8jcbh1srxmbcpbxl_9yhnkckg.jpeg"></p><br><h2 id="konfig">  Config </h2><br><p>  Le plus souvent, dans un environnement local et pour le fonctionnement, le serveur est configur√© diff√©remment.  Par cons√©quent, nous devons saisir des param√®tres distincts pour chacun de ces modes.  Tout d'abord, <code>config.exs</code> nos <code>config.exs</code> en ajoutant: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: 4000</code> </pre> <br><p>  Dans ce cas, lorsque l'application d√©marre en mode <code>test</code> , <code>prod</code> et <code>dev</code> , elle recevra le port 4000 si ces param√®tres ne sont pas modifi√©s. </p><br><div class="spoiler">  <b class="spoiler_title">Du traducteur</b> <div class="spoiler_text"><p>  √Ä ce stade, l'auteur du texte d'origine a oubli√© de mentionner comment modifier config.exs afin que vous puissiez utiliser diff√©rentes options pour diff√©rents modes.  Pour ce faire, ajoutez <code>import_config "#{Mix.env()}.exs"</code> ; dans la derni√®re ligne de <code>config/config.exs</code> ;  le r√©sultat est quelque chose comme: </p><br><pre> <code class="plaintext hljs">use Mix.Config config :minimal_server, MinimalServer.Endpoint, port: 4000 import_config "#{Mix.env()}.exs"</code> </pre> <br><p>  Apr√®s cela, cr√©ez les fichiers <code>prod.exs</code> , <code>test.exs</code> , <code>dev.exs</code> dans le r√©pertoire <code>config</code> en le pla√ßant sur chaque ligne: </p><br><pre> <code class="plaintext hljs">use Mix.Config</code> </pre> </div></div><br><p>  En production, nous ne voulons g√©n√©ralement pas d√©finir le num√©ro de port dur, mais nous comptons sur une variable d'environnement syst√®me, par exemple: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: "PORT" |&gt; System.get_env() |&gt; String.to_integer()</code> </pre> <br><p>  <em>Ajoutez le texte ci-dessus √† la fin de <code>config/prod.exs</code> - env.</em>  <em>traducteur</em> </p><br><p>  Apr√®s cela, une valeur fixe sera utilis√©e localement, et en fonctionnement op√©rationnel, une configuration de variables d'environnement. </p><br><p>  <em>Impl√©mentons</em> ce sch√©ma dans <code>endpoint.ex</code> , (en <em>rempla√ßant la fonction start_link / 1 - commentaire du traducteur</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... require Logger def start_link(_opts) do with {:ok, [port: port] = config} &lt;- Application.fetch_env(:minimal_server, __MODULE__) do Logger.info("Starting server at http://localhost:#{port}/") Plug.Adapters.Cowboy2.http(__MODULE__, [], config) end end end</code> </pre> <br><h2 id="heroku">  Heroku </h2><br><p>  Heroku offre le d√©ploiement en un clic le plus simple sans configuration compliqu√©e.  Pour d√©ployer notre projet, <strong>vous devez pr√©parer quelques fichiers simples et cr√©er une application distante</strong> . </p><br><p><img src="https://habrastorage.org/webt/ro/x_/dh/rox_dhu_pwqqvdetmn-hwtjasb0.png"></p><br><p>  Apr√®s avoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">install√© Heroku CLI,</a> vous pouvez cr√©er une nouvelle application comme suit: </p><br><pre> <code class="plaintext hljs">$ heroku create minimal-server-habr Creating ‚¨¢ minimal-server-habr... done https://minimal-server-habr.herokuapp.com/ | https://git.heroku.com/minimal-server-habr.git</code> </pre> <br><p>  Ajoutez maintenant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elixir Build Kit</a> √† votre application: </p><br><pre> <code class="plaintext hljs">heroku buildpacks:set \ https://github.com/HashNuke/heroku-buildpack-elixir.git</code> </pre> <br><p>  Au moment de cette traduction, les versions actuelles d'Elixir et d'Erlang sont (plus ou moins): </p><br><pre> <code class="plaintext hljs">erlang_version=21.1 elixir_version=1.8.1</code> </pre> <br><p>  Pour configurer le kit de construction lui-m√™me, ajoutez les lignes ci-dessus au fichier <code>elixir_buildpack.config</code> . </p><br><p>  La derni√®re √©tape consiste √† cr√©er un Procfile, et, encore une fois, c'est tr√®s simple: </p><br><pre> <code class="plaintext hljs">web: mix run --no-halt</code> </pre> <br><p>  <em>Note du traducteur: pour √©viter une erreur lors de la construction sur Heroku, vous devez d√©finir la valeur des variables d'environnement utilis√©es dans l'application:</em> </p><br><pre> <code class="plaintext hljs">$ heroku config:set PORT=4000 Setting PORT and restarting ‚¨¢ minimal-server-habr... done, v5 PORT: 4000</code> </pre> <br><p>  D√®s que vous validez de nouveaux fichiers [en <em>utilisant git - env.</em>  <em>traducteur</em> ], vous pouvez les t√©l√©charger sur Heroku: </p><br><pre> <code class="plaintext hljs">$ git push heroku master Initializing repository, done. updating 'refs/heads/master' ...</code> </pre> <br><p>  Et c'est tout!  L'application est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://minimal-server-habr.herokuapp.com</a> . </p><br><h1 id="rezyume">  R√©sum√© </h1><br><p>  √Ä ce stade, vous avez d√©j√† compris comment <strong>impl√©menter l'API JSON RESTful et le serveur HTTP les plus simples sur Elixir</strong> sans utiliser de frameworks, en utilisant seulement 3 ( <em>4 - environ Translator</em> ) biblioth√®ques. </p><br><p>  Lorsque vous devez fournir un acc√®s √† des points de terminaison simples, vous n'avez absolument pas besoin d'utiliser Phoenix √† chaque fois, quelle que soit sa fra√Æcheur, ainsi que tout autre framework. </p><br><p>  Curieux de savoir pourquoi il n'y a pas de frameworks fiables, bien test√©s et pris en charge quelque part entre <code>plug</code> + <code>cowboy</code> et Phoenix?  Peut-√™tre qu'il n'y a pas vraiment besoin d'impl√©menter des choses simples?  Peut-√™tre que chaque entreprise utilise sa propre biblioth√®que?  Ou peut-√™tre que tout le monde utilise Phoenix ou l'approche pr√©sent√©e? </p><br><p><img src="https://habrastorage.org/webt/lr/bb/w-/lrbbw-w-ulfd0eatm5yabyl-sma.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/KamilLelonek/elixir-">Le r√©f√©rentiel</a> , comme toujours, est disponible sur mon GitHub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444554/">https://habr.com/ru/post/fr444554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444544/index.html">Quelque chose au sujet des centres de donn√©es distribu√©s pour les entreprises</a></li>
<li><a href="../fr444546/index.html">Comment et pourquoi travailler plus lentement? La m√©thode de Sergey Korolev</a></li>
<li><a href="../fr444548/index.html">Exp√©rience personnelle: comment nous nous sommes engag√©s dans la promotion de startups hispaniques en Am√©rique latine</a></li>
<li><a href="../fr444550/index.html">√Ä la question de la division</a></li>
<li><a href="../fr444552/index.html">TDMS Fairway. Travailler avec expertise</a></li>
<li><a href="../fr444556/index.html">La couleur de la lune et du soleil de l'espace dans les valeurs de RVB et de temp√©rature de couleur</a></li>
<li><a href="../fr444558/index.html">Quoi de neuf dans CUBA 7</a></li>
<li><a href="../fr444560/index.html">Nous vous invitons √† la conf√©rence ¬´Clouds. Tendances de la mode ‚Äù26 mars 2019</a></li>
<li><a href="../fr444562/index.html">Modernisation de GHIDRA. Chargeur pour rhum Sega Mega Drive</a></li>
<li><a href="../fr444564/index.html">D√©veloppement de produits num√©riques avec des mod√®les mentaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>