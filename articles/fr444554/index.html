<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏾 👰🏿 🤹🏿 L'API JSON RESTful la plus simple sur Elixir 🐮 🤞🏻 🖕🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment implémenter le point de terminaison de l'API JSON sur Elixir sans aucun framework? 


 Du traducteur: 
 L'article fournit un exemple d'une app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'API JSON RESTful la plus simple sur Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444554/"><p>  <strong>Comment implémenter le point de terminaison de l'API JSON sur Elixir sans aucun framework?</strong> </p><br><p>  <em>Du traducteur:</em> <em><br></em>  <em>L'article fournit un exemple d'une application Web très simple qui peut être considérée comme Hello, World!</em>  <em>dans la création de l'API la plus simple sur Elixir.</em> <em><br></em>  <em>L'exemple de code est légèrement modifié afin de correspondre aux versions actuelles des bibliothèques.</em> <em><br></em>  <em>L'exemple de code complet avec les modifications peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/vheathen/elixir-">vu sur GitHub</a> .</em> </p><br><p><img src="https://habrastorage.org/webt/4u/ez/x7/4uezx7-azvbu2fk6bbbkj1veqdw.jpeg"></p><br><h2 id="problemy-novogo-yazyka">  Nouveaux défis linguistiques </h2><br><p>  De nombreux développeurs viennent à Elixir du <strong>monde de Ruby.</strong>  <strong>Il s'agit d'un environnement très mature</strong> en termes de nombre de bibliothèques et de frameworks disponibles.  Et une telle maturité ne me suffit parfois pas dans Elixir.  Lorsque j'ai besoin d'un service tiers, le résultat d'une recherche appropriée peut être le suivant: </p><a name="habracut"></a><br><ul><li>  il y a une bibliothèque officielle bien supportée (très rare); </li><li>  il existe une bibliothèque officielle, mais dépassée ou boguée (cela arrive parfois); </li><li>  Il y a une bibliothèque bien supportée développée par quelqu'un de la communauté (parfois de temps en temps); </li><li>  il y a une bibliothèque développée par quelqu'un de la communauté, mais qui n'est plus supportée (un cas très courant); </li><li>  il existe plusieurs bibliothèques, dont chacune est écrite par quelqu'un pour ses propres besoins, et il lui manque les fonctionnalités nécessaires (l'option la plus populaire); </li><li>  il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma propre</a> bibliothèque, combinant tout le meilleur de ce qui précède ... (trouvé trop souvent). </li></ul><br><h2 id="prostoe-json-api-na-eliksire">  API JSON simple sur Elixir </h2><br><p><img src="https://habrastorage.org/webt/3k/3b/7u/3k3b7ugydkdw_7bcsz_hk3-ytdq.jpeg"></p><br><p>  Vous pourriez être surpris, mais <strong>Ruby n'est pas toujours <em>sur les</em> rails</strong> ( <em>Ruby on Rails, souvenez-vous? - Note du traducteur</em> ).  La communication avec le Web n'est pas non plus toujours nécessaire pour participer.  Bien que dans ce cas particulier, parlons du Web. </p><br><p>  Lorsqu'il s'agit d'implémenter un seul point de terminaison RESTful, il existe généralement de nombreuses options: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rack-app</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hanami</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sinatra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Raisin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rails :: API</a> </li></ul><br><p>  Ce sont des exemples d'outils que j'ai personnellement utilisés.  Mes collègues sont des utilisateurs satisfaits de Sinatra.  Ils ont réussi à essayer Hanami.  Je peux choisir n'importe quelle option qui me convient, même en fonction de mon humeur actuelle. </p><br><p>  Mais quand je suis passé à Elixir, il s'est avéré que le choix était limité.  Bien qu'il existe plusieurs «frameworks» alternatifs (dont je ne citerai pas les noms pour des raisons évidentes), il est presque impossible de les utiliser! </p><br><p>  J'ai passé toute la journée à trier toutes les bibliothèques jamais mentionnées sur Internet.  Agissant en tant que bot Slack, j'ai essayé de <strong>déployer un simple serveur HTTP2 sur Heroku</strong> , mais à la fin de la journée, j'ai abandonné.  Littéralement, aucune des options que j'ai trouvées n'a pu mettre en œuvre les exigences de base. </p><br><h2 id="ne-vsegda-reshenie---phoenix">  Pas toujours une solution - Phoenix </h2><br><p>  <strong>Phoenix est mon framework web préféré, c'est juste que parfois c'est redondant.</strong>  Je ne voulais pas l'utiliser, tirant l'ensemble du cadre dans le projet exclusivement pour un seul point final;  et peu importe que ce soit très simple. </p><br><p>  Je ne pouvais pas non plus utiliser de bibliothèques prêtes à l'emploi, car, comme je l'ai déjà dit, toutes les bibliothèques que j'ai trouvées n'étaient pas adaptées à mes besoins (un routage de base et une prise en charge JSON étaient nécessaires) ou n'étaient pas assez pratiques pour un déploiement facile et rapide sur Heroku.  Prenez du recul, pensai-je. </p><br><p><img src="https://habrastorage.org/webt/jf/qg/yl/jfqgylkj7urywy09ic2tqtmlnic.jpeg"></p><br><p>  Mais en fait, Phoenix lui-même est construit sur la base <em>de quelque chose</em> , n'est-ce pas? </p><br><h2 id="plug--cowboy-prihodyat-na-pomosch">  Plug &amp; Cowboy vient à la rescousse </h2><br><p> Si vous devez créer un serveur vraiment minimaliste sur Ruby, vous pouvez simplement utiliser <code>rack</code> - une interface modulaire pour les serveurs Web Ruby. </p><br><p>  Heureusement, quelque chose de similaire est disponible dans Elixir.  Dans ce cas, nous utiliserons les éléments suivants: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cowboy</a> est un petit serveur HTTP rapide pour Erlang / OTP qui implémente la pile HTTP complète et le routage, optimisé pour minimiser la latence et l'utilisation de la mémoire; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plug</a> - un ensemble d'adaptateurs pour divers serveurs Web fonctionnant dans Erlang VM;  chaque adaptateur fournit une interface directe avec le serveur Web situé derrière lui; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poison</a> est une bibliothèque de traitement de JSON sur Elixir. </li></ul><br><h1 id="realizaciya">  Implémentation </h1><br><p>  Je veux implémenter des composants comme Endpoint (endpoint), Router (router) et JSON Parser (gestionnaire JSON).  Ensuite, je voudrais déployer le résultat sur Heroku et pouvoir traiter les demandes entrantes.  Voyons comment cela peut être réalisé. </p><br><h2 id="prilozhenie">  App </h2><br><p>  Assurez-vous que votre projet Elixir contient un superviseur.  Pour ce faire, créez un projet comme celui-ci: </p><br><pre> <code class="plaintext hljs">mix new minimal_server --sup</code> </pre> <br><p>  Assurez-vous que mix.exs contient: </p><br><pre> <code class="plaintext hljs">def application do [ extra_applications: [:logger], mod: {MinimalServer.Application, []} ] end</code> </pre> <br><p>  et créez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier</a> <code>lib/minimal_server/application.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do use Application def start(_type, _args), do: Supervisor.start_link(children(), opts()) defp children do [] end defp opts do [ strategy: :one_for_one, name: MinimalServer.Supervisor ] end end</code> </pre> <br><h2 id="biblioteki">  Bibliothèques </h2><br><p>  Les bibliothèques suivantes doivent être spécifiées dans <code>mix.exs</code> : </p><br><pre> <code class="plaintext hljs">defp deps do [ {:poison, "~&gt; 4.0"}, {:plug, "~&gt; 1.7"}, {:cowboy, "~&gt; 2.5"}, {:plug_cowboy, "~&gt; 2.0"} ] end</code> </pre> <br><p>  Ensuite, téléchargez et compilez les dépendances: </p><br><pre> <code class="plaintext hljs">mix do deps.get, deps.compile, compile</code> </pre> <br><h2 id="endpoint">  Endpoint </h2><br><p>  Maintenant, tout est prêt pour créer un point d'entrée sur le serveur.  Créons un fichier <code>lib/minimal_server/endpoint.ex</code> avec le contenu suivant: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do use Plug.Router plug(:match) plug(Plug.Parsers, parsers: [:json], pass: ["application/json"], json_decoder: Poison ) plug(:dispatch) match _ do send_resp(conn, 404, "Requested page not found!") end end</code> </pre> <br><p>  Le module <code>Plug</code> contient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Plug.Router</code></a> pour rediriger les requêtes entrantes en fonction du chemin utilisé et de la méthode HTTP.  Dès réception de la demande, le routeur appellera le module <code>:match</code> , représenté par la fonction <code>match/2</code> , qui est responsable de trouver l'itinéraire correspondant, puis le redirigera vers le module <code>:dispatch</code> , qui exécutera le code correspondant. </p><br><p>  Puisque nous voulons que notre API soit compatible JSON, nous devons implémenter <code>Plug.Parsers</code> .  Puisqu'il traite les <code>application/json</code> avec le donné <code>:json_decoder</code> , nous l'utiliserons pour analyser le corps de la requête. </p><br><p>  En conséquence, nous avons créé une route temporaire «toute demande» qui correspond à toutes les demandes et répond avec du code HTTP non trouvé (404). </p><br><h2 id="marshrutizator">  Routeur </h2><br><p>  L'implémentation d'un routeur sera la dernière étape de la création de notre application.  C'est le dernier élément de l'ensemble du pipeline que nous avons créé: en commençant par recevoir une demande d'un navigateur Web et en terminant par la formation d'une réponse. </p><br><p>  Le routeur traitera la demande entrante du client et renverra un message au format souhaité ( <em>ajoutez le code donné dans le fichier <code>lib/minimal_server/router.ex</code> - note du traducteur</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Router do use Plug.Router plug(:match) plug(:dispatch) get "/" do conn |&gt; put_resp_content_type("application/json") |&gt; send_resp(200, Poison.encode!(message())) end defp message do %{ response_type: "in_channel", text: "Hello from BOT :)" } end end</code> </pre> <br><p>  Dans le module <code>Router</code> ci-dessus, la demande sera traitée uniquement si elle est envoyée par la méthode <code>GET</code> et envoyée le long de la route <code>/</code> .  Le module Router répondra par un en <code>Content-Type</code> tête <code>Content-Type</code> contenant <code>application/json</code> et body: </p><br><pre> <code class="plaintext hljs">{ "response_type": "in_channel", "text": "Hello from BOT :)" }</code> </pre> <br><h2 id="soberyom-vsyo-vmeste">  Tout mettre ensemble </h2><br><p>  Il est maintenant temps de changer le module <code>Endpoint</code> pour transférer les demandes au routeur et de modifier l' <code>Application</code> pour lancer le module <code>Endpoint</code> lui-même. </p><br><p>  La première peut être effectuée en ajoutant à <code>MinimalServer.Endpoint</code> [ <em>avant la <code>match _ do ... end</code> règle de <code>match _ do ... end</code> - env.</em>  <em>traducteur</em> ] chaîne </p><br><pre> <code class="plaintext hljs">forward("/bot", to: MinimalServer.Router)</code> </pre> <br><p>  Cela garantit que toutes les demandes à <code>/bot</code> seront acheminées et traitées par le module <code>Router</code> . </p><br><p>  La seconde peut être implémentée en ajoutant les fonctions <code>child_spec/1</code> et <code>start_link/1</code> fichier <code>endpoint.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... def child_spec(opts) do %{ id: __MODULE__, start: {__MODULE__, :start_link, [opts]} } end def start_link(_opts), do: Plug.Cowboy.http(__MODULE__, []) end</code> </pre> <br><p>  Vous pouvez maintenant modifier <code>application.ex</code> en ajoutant <code>MinimalServer.Endpoint</code> à la liste renvoyée par la fonction <code>children/0</code> . </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do # ... defp children do [ MinimalServer.Endpoint ] end end</code> </pre> <br><p>  Pour démarrer le serveur, faites simplement: </p><br><pre> <code class="plaintext hljs">mix run --no-halt</code> </pre> <br><p>  Enfin, vous pouvez visiter l'adresse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 4000 / bot</a> et voir notre message :) </p><br><h1 id="razvertyvanie">  Déploiement </h1><br><p><img src="https://habrastorage.org/webt/kf/8j/cb/kf8jcbh1srxmbcpbxl_9yhnkckg.jpeg"></p><br><h2 id="konfig">  Config </h2><br><p>  Le plus souvent, dans un environnement local et pour le fonctionnement, le serveur est configuré différemment.  Par conséquent, nous devons saisir des paramètres distincts pour chacun de ces modes.  Tout d'abord, <code>config.exs</code> nos <code>config.exs</code> en ajoutant: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: 4000</code> </pre> <br><p>  Dans ce cas, lorsque l'application démarre en mode <code>test</code> , <code>prod</code> et <code>dev</code> , elle recevra le port 4000 si ces paramètres ne sont pas modifiés. </p><br><div class="spoiler">  <b class="spoiler_title">Du traducteur</b> <div class="spoiler_text"><p>  À ce stade, l'auteur du texte d'origine a oublié de mentionner comment modifier config.exs afin que vous puissiez utiliser différentes options pour différents modes.  Pour ce faire, ajoutez <code>import_config "#{Mix.env()}.exs"</code> ; dans la dernière ligne de <code>config/config.exs</code> ;  le résultat est quelque chose comme: </p><br><pre> <code class="plaintext hljs">use Mix.Config config :minimal_server, MinimalServer.Endpoint, port: 4000 import_config "#{Mix.env()}.exs"</code> </pre> <br><p>  Après cela, créez les fichiers <code>prod.exs</code> , <code>test.exs</code> , <code>dev.exs</code> dans le répertoire <code>config</code> en le plaçant sur chaque ligne: </p><br><pre> <code class="plaintext hljs">use Mix.Config</code> </pre> </div></div><br><p>  En production, nous ne voulons généralement pas définir le numéro de port dur, mais nous comptons sur une variable d'environnement système, par exemple: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: "PORT" |&gt; System.get_env() |&gt; String.to_integer()</code> </pre> <br><p>  <em>Ajoutez le texte ci-dessus à la fin de <code>config/prod.exs</code> - env.</em>  <em>traducteur</em> </p><br><p>  Après cela, une valeur fixe sera utilisée localement, et en fonctionnement opérationnel, une configuration de variables d'environnement. </p><br><p>  <em>Implémentons</em> ce schéma dans <code>endpoint.ex</code> , (en <em>remplaçant la fonction start_link / 1 - commentaire du traducteur</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... require Logger def start_link(_opts) do with {:ok, [port: port] = config} &lt;- Application.fetch_env(:minimal_server, __MODULE__) do Logger.info("Starting server at http://localhost:#{port}/") Plug.Adapters.Cowboy2.http(__MODULE__, [], config) end end end</code> </pre> <br><h2 id="heroku">  Heroku </h2><br><p>  Heroku offre le déploiement en un clic le plus simple sans configuration compliquée.  Pour déployer notre projet, <strong>vous devez préparer quelques fichiers simples et créer une application distante</strong> . </p><br><p><img src="https://habrastorage.org/webt/ro/x_/dh/rox_dhu_pwqqvdetmn-hwtjasb0.png"></p><br><p>  Après avoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installé Heroku CLI,</a> vous pouvez créer une nouvelle application comme suit: </p><br><pre> <code class="plaintext hljs">$ heroku create minimal-server-habr Creating ⬢ minimal-server-habr... done https://minimal-server-habr.herokuapp.com/ | https://git.heroku.com/minimal-server-habr.git</code> </pre> <br><p>  Ajoutez maintenant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elixir Build Kit</a> à votre application: </p><br><pre> <code class="plaintext hljs">heroku buildpacks:set \ https://github.com/HashNuke/heroku-buildpack-elixir.git</code> </pre> <br><p>  Au moment de cette traduction, les versions actuelles d'Elixir et d'Erlang sont (plus ou moins): </p><br><pre> <code class="plaintext hljs">erlang_version=21.1 elixir_version=1.8.1</code> </pre> <br><p>  Pour configurer le kit de construction lui-même, ajoutez les lignes ci-dessus au fichier <code>elixir_buildpack.config</code> . </p><br><p>  La dernière étape consiste à créer un Procfile, et, encore une fois, c'est très simple: </p><br><pre> <code class="plaintext hljs">web: mix run --no-halt</code> </pre> <br><p>  <em>Note du traducteur: pour éviter une erreur lors de la construction sur Heroku, vous devez définir la valeur des variables d'environnement utilisées dans l'application:</em> </p><br><pre> <code class="plaintext hljs">$ heroku config:set PORT=4000 Setting PORT and restarting ⬢ minimal-server-habr... done, v5 PORT: 4000</code> </pre> <br><p>  Dès que vous validez de nouveaux fichiers [en <em>utilisant git - env.</em>  <em>traducteur</em> ], vous pouvez les télécharger sur Heroku: </p><br><pre> <code class="plaintext hljs">$ git push heroku master Initializing repository, done. updating 'refs/heads/master' ...</code> </pre> <br><p>  Et c'est tout!  L'application est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://minimal-server-habr.herokuapp.com</a> . </p><br><h1 id="rezyume">  Résumé </h1><br><p>  À ce stade, vous avez déjà compris comment <strong>implémenter l'API JSON RESTful et le serveur HTTP les plus simples sur Elixir</strong> sans utiliser de frameworks, en utilisant seulement 3 ( <em>4 - environ Translator</em> ) bibliothèques. </p><br><p>  Lorsque vous devez fournir un accès à des points de terminaison simples, vous n'avez absolument pas besoin d'utiliser Phoenix à chaque fois, quelle que soit sa fraîcheur, ainsi que tout autre framework. </p><br><p>  Curieux de savoir pourquoi il n'y a pas de frameworks fiables, bien testés et pris en charge quelque part entre <code>plug</code> + <code>cowboy</code> et Phoenix?  Peut-être qu'il n'y a pas vraiment besoin d'implémenter des choses simples?  Peut-être que chaque entreprise utilise sa propre bibliothèque?  Ou peut-être que tout le monde utilise Phoenix ou l'approche présentée? </p><br><p><img src="https://habrastorage.org/webt/lr/bb/w-/lrbbw-w-ulfd0eatm5yabyl-sma.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/KamilLelonek/elixir-">Le référentiel</a> , comme toujours, est disponible sur mon GitHub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444554/">https://habr.com/ru/post/fr444554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444544/index.html">Quelque chose au sujet des centres de données distribués pour les entreprises</a></li>
<li><a href="../fr444546/index.html">Comment et pourquoi travailler plus lentement? La méthode de Sergey Korolev</a></li>
<li><a href="../fr444548/index.html">Expérience personnelle: comment nous nous sommes engagés dans la promotion de startups hispaniques en Amérique latine</a></li>
<li><a href="../fr444550/index.html">À la question de la division</a></li>
<li><a href="../fr444552/index.html">TDMS Fairway. Travailler avec expertise</a></li>
<li><a href="../fr444556/index.html">La couleur de la lune et du soleil de l'espace dans les valeurs de RVB et de température de couleur</a></li>
<li><a href="../fr444558/index.html">Quoi de neuf dans CUBA 7</a></li>
<li><a href="../fr444560/index.html">Nous vous invitons à la conférence «Clouds. Tendances de la mode ”26 mars 2019</a></li>
<li><a href="../fr444562/index.html">Modernisation de GHIDRA. Chargeur pour rhum Sega Mega Drive</a></li>
<li><a href="../fr444564/index.html">Développement de produits numériques avec des modèles mentaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>