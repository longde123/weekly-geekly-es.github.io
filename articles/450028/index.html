<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏼 🙋🏿 💪🏽 Construyendo una Arquitectura Orientada a Servicios en Rails + Kafka 🏂🏼 🧑🏿‍🤝‍🧑🏿 👨🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento el post, que es una adaptación de texto de la actuación de Stella Cotton en RailsConf 2018 y una traducción del artículo "Cons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construyendo una Arquitectura Orientada a Servicios en Rails + Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450028/">  Hola Habr!  Les presento el post, que es una adaptación de texto de la actuación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Stella Cotton en RailsConf 2018</a> y una traducción del artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Construyendo una arquitectura orientada al servicio con Rails y Kafka"</a> de Stella Cotton. <br><br>  Recientemente, la transición de la arquitectura monolítica a los microservicios es claramente visible.  En esta guía, aprenderemos los conceptos básicos de Kafka y cómo un enfoque basado en eventos puede mejorar su aplicación Rails.  También hablaremos sobre los problemas de monitoreo y escalabilidad de los servicios que funcionan a través de un enfoque orientado a eventos. <br><a name="habracut"></a><br><h2>  ¿Qué es kafka? </h2><br>  Estoy seguro de que le gustaría tener información sobre cómo llegaron sus usuarios a su plataforma o qué páginas visitan, en qué botones hacen clic, etc.  Una aplicación verdaderamente popular puede generar miles de millones de eventos y enviar una gran cantidad de datos a los servicios de análisis, lo que puede ser un gran desafío para su aplicación. <br><br>  Como regla, una parte integral de las aplicaciones web requiere el llamado <i>flujo de datos en tiempo real</i> .  Kafka proporciona una conexión tolerante a fallas entre <b>productores</b> , aquellos que generan eventos y <b>consumidores</b> , aquellos que reciben estos eventos.  Incluso puede haber varios productores y consumidores en una sola aplicación.  En Kafka, cada evento existe durante un tiempo determinado, por lo que varios consumidores pueden leer el mismo evento una y otra vez.  El grupo de Kafka incluye varios corredores que son instancias de Kafka. <br><br><img src="https://habrastorage.org/webt/ql/j1/uy/qlj1uyapeg_3fmswgflqauwmd7q.png"><br><br>  Una característica clave de Kafka es la alta velocidad de procesamiento de eventos.  Los sistemas de colas tradicionales, como AMQP, tienen una infraestructura que monitorea los eventos procesados ​​para cada consumidor.  Cuando el número de consumidores crece a un nivel decente, el sistema apenas comienza a hacer frente a la carga, ya que tiene que controlar un número creciente de condiciones.  Además, existen grandes problemas con la coherencia entre el consumidor y el procesamiento de eventos.  Por ejemplo, ¿vale la pena marcar inmediatamente un mensaje como enviado tan pronto como sea procesado por el sistema?  ¿Y si un consumidor cae en el otro extremo sin recibir un mensaje? <br><br>  Kafka también tiene una arquitectura a prueba de fallas.  El sistema se ejecuta como un clúster en uno o más servidores, que se pueden escalar horizontalmente agregando nuevas máquinas.  Todos los datos se escriben en el disco y se copian a varios corredores.  Para comprender las posibilidades de escalabilidad, vale la pena echar un vistazo a empresas como Netflix, LinkedIn, Microsoft.  ¡Todos ellos envían billones de mensajes por día a través de sus grupos de Kafka! <br><br><h2>  Configurar Kafka en Rails </h2><br>  Heroku proporciona un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento de clúster Kafka</a> que se puede usar para cualquier entorno.  Para aplicaciones de rubí, recomendamos usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gema ruby-kafka</a> .  La implementación mínima se parece a esto: <br><br><pre><code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># config/initializers/kafka_producer.rb require "kafka" # Configure the Kafka client with the broker hosts and the Rails # logger. $kafka = Kafka.new(["kafka1:9092", "kafka2:9092"], logger: Rails.logger) # Set up an asynchronous producer that delivers its buffered messages # every ten seconds: $kafka_producer = $kafka.async_producer( delivery_interval: 10, ) # Make sure to shut down the producer when exiting. at_exit { $kafka_producer.shutdown }</span></span></code> </pre> <br>  Después de configurar la configuración, puede usar la gema para enviar mensajes.  Gracias al envío asincrónico de eventos, podemos enviar mensajes desde cualquier lugar: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrdersController</span></span></span><span class="hljs-class"> &lt; ApplicationController </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">comment</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create!</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">) $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kafka_producer</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">produce</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">order</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_json</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">topic</span></span></span><span class="hljs-class">: "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_event</span></span></span><span class="hljs-class">", </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partition_key</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Hablaremos sobre los formatos de serialización a continuación, pero por ahora usaremos el viejo JSON.  El argumento del <code>topic</code> refiere al registro en el que Kafka escribe este evento.  Los temas se extienden en diferentes secciones, que le permiten dividir los datos de un tema en particular en diferentes corredores para una mejor escalabilidad y confiabilidad.  Y es realmente una buena idea tener dos o más secciones para cada tema, porque si una de las secciones cae, sus eventos se registrarán y procesarán de todos modos.  Kafka asegura que los eventos se entreguen en el orden de la cola dentro de la sección, pero no dentro del tema completo.  Si el orden de los eventos es importante, el envío de la partición_clave asegura que todos los eventos de un tipo particular se almacenen en la misma partición. <br><br><h2>  Kafka por tus servicios </h2><br>  Algunas de las características que hacen de Kafka una herramienta útil también lo convierten en un RPC de conmutación por error entre servicios.  Eche un vistazo a un ejemplo de una aplicación de comercio electrónico: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_order</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_order_record</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">charge_credit_card</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment"># call to Payments Service send_confirmation_email # call to Email Service end</span></span></span></span></code> </pre> <br>  Cuando el usuario <code>create_order</code> un pedido, se <code>create_order</code> función <code>create_order</code> .  Esto crea un pedido en el sistema, deduce dinero de la tarjeta y envía un correo electrónico con la confirmación.  Como puede ver, los dos últimos pasos se llevan a cabo en servicios separados. <br><br><img src="https://habrastorage.org/webt/i8/_y/tr/i8_ytruescd639f48vmelrmsfu4.png"><br><br>  Uno de los problemas con este enfoque es que el servicio superior en la jerarquía es responsable de monitorear la disponibilidad del servicio descendente.  Si el servicio para enviar cartas resultó ser un mal día, el servicio superior debe saberlo.  Y si el servicio de envío no está disponible, debe repetir un determinado conjunto de acciones.  ¿Cómo puede ayudar Kafka en esta situación? <br><br>  Por ejemplo: <br><br><img src="https://habrastorage.org/webt/i1/dh/a8/i1dha8zycj6ibxydaxja9y8bp10.png"><br><br>  En este enfoque basado en eventos, un servicio superior puede registrar un evento en Kafka en el que se ha creado un pedido.  Debido al llamado enfoque de <i>al menos una vez</i> , el evento se grabará en Kafka al menos una vez y estará disponible para la lectura de los consumidores intermedios.  Si el servicio de envío de cartas yace, el evento esperará en el disco hasta que el consumidor se levante y lo lea. <br><br>  Otro problema con la arquitectura orientada a RPC está en los sistemas de rápido crecimiento: agregar un nuevo servicio descendente implica cambios en el flujo ascendente.  Por ejemplo, le gustaría agregar un paso más después de crear un pedido.  En un mundo impulsado por eventos, deberá agregar otro consumidor para manejar un nuevo tipo de evento. <br><br><img src="https://habrastorage.org/webt/ox/ic/ka/oxickaiivr5j6hey5fahjkcvsxc.png"><br><br><h2>  Integración de eventos en la arquitectura orientada a servicios </h2><br>  Una publicación titulada " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué quieres decir con" Impulsado</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eventos</a> "por Martin Fowler discute la confusión en torno a las aplicaciones basadas en eventos.  Cuando los desarrolladores discuten tales sistemas, en realidad están hablando de una gran cantidad de aplicaciones diferentes.  Para dar una comprensión general de la naturaleza de tales sistemas, Fowler definió varios patrones arquitectónicos. <br><br>  Echemos un vistazo a cuáles son estos patrones.  Si quieres saber más, te aconsejo que leas su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> en GOTO Chicago 2017. <br><br><h3>  Notificación de evento </h3><br>  El primer patrón de Fowler se llama <i>Notificación de eventos</i> .  En este escenario, el servicio de productor notifica a los consumidores del evento con una cantidad mínima de información: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"event"</span></span>: <span class="hljs-string"><span class="hljs-string">"order_created"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"published_at"</span></span>: <span class="hljs-string"><span class="hljs-string">"2016-03-15T16:35:04Z"</span></span> }</code> </pre> <br>  Si los consumidores necesitan más información sobre el evento, hacen una solicitud al productor y obtienen más datos. <br><br><h3>  Transferencia de estado llevada por evento </h3><br>  La segunda plantilla se llama <i>Transferencia de estado llevada por evento</i> .  En este escenario, el productor proporciona información adicional sobre el evento y el consumidor puede almacenar una copia de estos datos sin hacer llamadas adicionales: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"event"</span></span>: <span class="hljs-string"><span class="hljs-string">"order_created"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"order"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"order_id"</span></span>: <span class="hljs-number"><span class="hljs-number">98765</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-string"><span class="hljs-string">"medium"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"color"</span></span>: <span class="hljs-string"><span class="hljs-string">"blue"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"published_at"</span></span>: <span class="hljs-string"><span class="hljs-string">"2016-03-15T16:35:04Z"</span></span> }</code> </pre> <br><h3>  De origen de eventos </h3><br>  Fowler llamó a la tercera plantilla <i>Event-Sourced</i> y es bastante arquitectónica.  El lanzamiento de la plantilla implica no solo la comunicación entre sus servicios, sino también la preservación de la presentación del evento.  Esto garantiza que, incluso si pierde la base de datos, puede restaurar el estado de la aplicación simplemente ejecutando la secuencia de eventos guardada.  En otras palabras, cada evento guarda un cierto estado de la aplicación en un momento determinado. <br><br>  El gran problema con este enfoque es que el código de la aplicación siempre cambia, y con él puede cambiar el formato o la cantidad de datos que proporciona el productor.  Esto hace que la restauración del estado de la aplicación sea problemática. <br><br><h3>  Segmentación de responsabilidad de consulta de comando </h3><br>  Y la última plantilla es <i>la segregación de responsabilidad de consulta de comando</i> , o CQRS.  La idea es que las acciones que aplique al objeto, por ejemplo: crear, leer, actualizar, se dividan en diferentes dominios.  Esto significa que un servicio debe ser responsable de la creación, otro de la actualización, etc.  En los sistemas orientados a objetos, todo se almacena a menudo en un solo servicio. <br><br><img src="https://habrastorage.org/webt/xb/5b/mx/xb5bmxasal6md3bq2xsdgnhfhgg.png"><br><br>  Un servicio que escribe en la base de datos leerá el flujo de eventos y los comandos de proceso.  Pero cualquier solicitud se produce solo en la base de datos de solo lectura.  Dividir la lógica de lectura y escritura en dos servicios diferentes aumenta la complejidad, pero le permite optimizar el rendimiento por separado para estos sistemas. <br><br><h2>  Los problemas </h2><br>  Hablemos sobre algunos de los problemas que puede encontrar al integrar Kafka en su aplicación orientada al servicio. <br><br>  El primer problema puede ser lento para los consumidores.  En un sistema orientado a eventos, sus servicios deberían poder procesar eventos instantáneamente cuando se reciben de un servicio superior.  De lo contrario, simplemente se colgarán sin alertas sobre el problema o los tiempos de espera.  El único lugar donde puede definir tiempos de espera es una conexión de socket con los corredores Kafka.  Si el servicio no procesa el evento lo suficientemente rápido, la conexión puede ser interrumpida por el tiempo de espera, pero la restauración del servicio requiere tiempo adicional, porque la creación de dichos sockets es costosa. <br><br>  Si el consumidor es lento, ¿cómo puede aumentar la velocidad del procesamiento de eventos?  En Kafka, puede aumentar el número de consumidores en un grupo, por lo que se pueden procesar más eventos en paralelo.  Pero se requerirán al menos 2 consumidores para un servicio: en caso de que uno caiga, las secciones dañadas pueden reasignarse. <br><br>  También es muy importante tener métricas y alertas para monitorear la velocidad del procesamiento de eventos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruby-kafka</a> puede funcionar con alertas ActiveSupport, también tiene módulos StatsD y Datadog, que están habilitados de forma predeterminada.  Además, la gema proporciona una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de</a> métricas recomendadas para el monitoreo. <br><br>  Otro aspecto importante de la construcción de sistemas con Kafka es el diseño de consumidores con la capacidad de manejar fallas.  Kafka tiene la garantía de enviar un evento al menos una vez;  excluyó el caso cuando el mensaje no se envió en absoluto.  Pero es importante que los consumidores estén preparados para manejar eventos recurrentes.  Una forma de hacerlo es utilizar siempre <code>UPSERT</code> para agregar nuevos registros a la base de datos.  Si el registro ya existe con los mismos atributos, la llamada estará esencialmente inactiva.  Además, puede agregar un identificador único a cada evento y simplemente omitir los eventos que ya se han procesado anteriormente. <br><br><h2>  Formatos de datos </h2><br>  Una de las sorpresas al trabajar con Kafka puede ser su simple actitud hacia el formato de datos.  Puede enviar cualquier cosa en bytes y los datos se enviarán al consumidor sin ninguna verificación.  Por un lado, brinda flexibilidad y le permite no preocuparse por el formato de datos.  Por otro lado, si el productor decide cambiar los datos que se envían, existe la posibilidad de que algún consumidor finalmente se rompa. <br><br>  Antes de construir una arquitectura orientada a eventos, seleccione un formato de datos y analice cómo ayudará en el futuro registrar y desarrollar esquemas. <br><br>  Uno de los formatos recomendados para su uso, por supuesto, es JSON.  Este formato es legible y compatible con todos los lenguajes de programación conocidos.  Pero hay dificultades.  Por ejemplo, el tamaño de los datos finales en JSON puede llegar a ser terriblemente grande.  Se requiere el formato para almacenar pares clave-valor, que es lo suficientemente flexible, pero los datos se duplican en cada evento.  Cambiar el esquema también es una tarea difícil porque no hay soporte incorporado para superponer una clave sobre otra si necesita cambiar el nombre del campo. <br><br>  El equipo que creó Kafka aconseja a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Avro</a> como un sistema de serialización.  Los datos se envían en forma binaria, y este no es el formato más legible para los humanos, pero en el interior hay un soporte más confiable para los circuitos.  La entidad final en Avro incluye tanto el esquema como los datos.  Avro también admite ambos tipos simples, como los números y los complejos: fechas, matrices, etc. Además, le permite incluir documentación dentro del esquema, lo que le permite comprender el propósito de un campo específico en el sistema y contiene muchas otras herramientas integradas para trabajar con el esquema. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">avro-builder</a> es una gema creada por Salsify que ofrece un DSL similar al rubí para crear esquemas.  Puedes leer más sobre Avro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este artículo</a> . <br><br><h2>  Información adicional </h2><br>  Si está interesado en cómo alojar Kafka o cómo se usa en Heroku, hay varios informes que pueden ser de su interés. <br><br>  Jeff Chao en DataEngConf SF '17 " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más allá de 50,000 particiones: cómo Heroku opera y empuja los límites de Kafka a escala</a> " <br><br>  Pavel Pravosud en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conferencia</a> Dreamforce '16 “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dogfooding Kafka: Cómo construimos la plataforma de eventos en tiempo real de la plataforma de Heroku</a> ” <br><br>  Que tengas una linda vista! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450028/">https://habr.com/ru/post/450028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450016/index.html">Creación de un sistema de verificación formal desde cero. Parte 1: máquina virtual de caracteres en PHP y Python</a></li>
<li><a href="../450018/index.html">Un dúo de matemáticas mapeó un territorio sin fin de superficies mínimas</a></li>
<li><a href="../450020/index.html">Silicon Valley llegó a los escolares de Kansas. Esto llevó a protestas.</a></li>
<li><a href="../450024/index.html">Acerca de las implementaciones de código abierto de la función hash GOST R 34.11-2012 y su impacto en la firma electrónica de GOST R 34.10-2012</a></li>
<li><a href="../450026/index.html">Cifrado de aceleración: estudiamos el acelerómetro de un dispositivo Android usando el ejemplo de la tarea NeoQUEST-2019</a></li>
<li><a href="../450030/index.html">No puedo usar Rift S y tampoco tendrás éxito</a></li>
<li><a href="../450032/index.html">Cómo crear un tema oscuro sin romper cosas: aprender con el equipo de Yandex Mail</a></li>
<li><a href="../450034/index.html">¿Por qué deberías participar en hackatones?</a></li>
<li><a href="../450036/index.html">Summ3r 0f h4ck: prácticas Digital Security 2019</a></li>
<li><a href="../450040/index.html">Nueva compañía apoyará OpenJDK 8 y 11 - entendemos la situación</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>