<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😀 🚣🏿 🧕🏽 清单：在产品中启动微服务之前必须做什么 👨🏻‍🏫 🚑 🛌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文简要介绍了我自己的经验以及我与同事们日夜不停地进行耙击事件的经验。 如果每个人都喜欢至少更准确地编写微服务，那么许多事件就永远不会发生。 


 不幸的是，一些低级的程序员认真地认为，内部带有某种命令的Dockerfile本身就是微服务，即使现在也可以部署。 码头工人在旋转，替补席上泥泞不堪。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>清单：在产品中启动微服务之前必须做什么</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438064/"><p><img src="https://habrastorage.org/webt/y7/-a/th/y7-ath7wga1jfx9issm1rhog2lg.jpeg" width="45%" align="right"> 本文简要介绍了我自己的经验以及我与同事们日夜不停地进行耙击事件的经验。 如果每个人都喜欢至少更准确地编写微服务，那么许多事件就永远不会发生。 </p><br><p> 不幸的是，一些<s>低级的</s>程序员认真地认为，内部带有某种命令的Dockerfile本身就是微服务，即使现在也可以部署。 码头工人在旋转，替补席上泥泞不堪。 这种方法充满了各种问题，包括性能下降，无法调试和拒绝服务，以及噩梦般的数据不一致。 </p><br><p> 如果您觉得是时候在Kubernetes / ECS /或其他任何版本中启动另一个应用程序了，那么我有一些反对意见。 </p><br><p> <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也提供</a>英文版本</strong> 。 </p><a name="habracut"></a><br><p> 我为自己制定了一套标准，以评估在生产中启动应用程序的准备情况。 此清单的某些要点不能应用于所有应用程序，而只能应用于特殊应用程序。 其他人通常适用于所有事物。 我确定您可以在评论中添加选项，也可以对其中的一些观点提出异议。 </p><br><p> 如果您的微服务不满足至少一项条件，我将不允许它在我理想的集群中，该集群建在地下2000米的地下掩体中，地下采暖和封闭的独立互联网供应系统。 </p><br><p> 走吧.... </p><br><p>  <i>注意：项目的顺序无关紧要。</i>  <i>无论如何，对我来说。</i> </p><br><h2 id="korotkoe-opisanie-v-readme"> 自述文件简短说明 </h2><br><blockquote> 它在其存储库中的Readme.md开头处包含对自身的简短说明。 </blockquote><p> 天哪，看起来很简单。 但是我发现该存储库没有多少丝毫解释为什么需要它，解决了什么任务等等。 无需谈论更复杂的事情，例如配置选项。 </p><br><h2 id="integraciya-s-sistemoy-monitoringa"> 与监控系统集成 </h2><br><blockquote> 将指标发送到DataDog，NewRelic，Prometheus等。 </blockquote><p> 分析资源消耗，内存泄漏，堆栈跟踪，服务相互依赖性，错误率-如果不了解所有这些（并且不仅是所有这些），就很难控制大型分布式应用程序中发生的事情。 </p><br><h2 id="opovescheniya-nastroeny"> 警报已配置 </h2><br><blockquote> 该服务包括涵盖所有标准情况以及已知独特情况的警报。 </blockquote><p> 指标不错，但是没有人会遵循。 因此，如果出现以下情况，我们将自动接听电话/推送/短信： </p><br><ul><li>  CPU /内存消耗已大大增加。 </li><li> 流量增加/急剧下降。 </li><li> 每秒处理的事务数在任何方向都发生了巨大变化。 </li><li> 组装后工件的大小发生了巨大变化（exe，app，jar，...）。 </li><li> 错误的百分比或其频率超过了允许的阈值。 </li><li> 服务已停止发送指标（通常被忽略）。 </li><li> 违反了某些预期事件的规律性（定时作业无效，并非所有事件都得到处理等） </li><li>  ... </li></ul><br><h2 id="runbooks-sozdany"> 运行手册已创建 </h2><br><blockquote> 已经为服务创建了描述已知或预期的意外事件的文档。 </blockquote><br><ul><li> 如何确保错误是内部的并且不依赖于第三方； </li><li> 是否取决于在哪里，写给谁和写什么； </li><li> 如何安全地重新启动它； </li><li> 如何从备份还原以及备份位于何处； </li><li> 创建了哪些特殊的仪表板/查询来监视此服务； </li><li> 该服务是否有自己的管理面板以及如何到达那里； </li><li> 是否有API / CLI，以及如何使用它来解决已知问题； </li><li> 等等。 </li></ul><br><p> 各个组织之间的列表差异很大，但是至少应该有一些基本的内容。 </p><br><h2 id="vse-logi-pishutsya-v-stdoutstderr"> 所有日志均以STDOUT / STDERR格式编写 </h2><br><blockquote> 该服务不会在生产模式下创建任何日志文件，不会将其发送到任何外部服务，不包含用于日志轮换的任何冗余抽象等。 </blockquote><p> 当应用程序创建日志文件时，这些日志是无用的。 您不会进入并行运行的5个容器中，希望捕获所需的错误（在这里，您正在<em>哭泣</em> ...）。 重新启动容器将导致这些日志完全丢失。 </p><br><p> 如果应用程序将其自己的日志写入第三方系统（例如Logstash），则会创建无用的冗余。 相邻服务不知道如何执行此操作，因为 它有不同的框架吗？ 你有动物园。 </p><br><p> 该应用程序将部分日志写入文件，将部分日志写入stdout，因为开发人员可以方便地在控制台中查看INFO，在文件中查看DEBUG？ 通常这是最糟糕的选择。 没有人需要您需要了解和维护的复杂性以及完全冗余的代码和配置。 </p><br><h2 id="logi---eto-json"> 日志是杰森 </h2><br><blockquote> 每条日志行均以Json格式编写，并包含一组一致的字段 </blockquote><p> 到目前为止，几乎每个人都以纯文本形式编写日志。 这是一场真正的灾难。 我很高兴永远不会知道<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Grok Patterns</a> 。 有时我梦见他们，我冻结，努力不动，以免引起他们的注意。 只需尝试解析一次日志中的Java异常。 </p><br><p> 杰森很好，那是天堂赐予的火。 只需添加： </p><br><ul><li> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 3339的</a> <strong>毫秒</strong>时间戳; </li><li> 级别：信息，警告，错误，调试 </li><li>  user_id; </li><li>  app_name </li><li> 和其他领域。 </li></ul><br><p> 下载到任何合适的系统（例如，正确配置的ElasticSearch）并享受。 连接许多微服务的日志，并再次感受到<em>什么</em>是好的整体应用程序。 </p><br><p>  <em>（并且您可以添加Request-Id并进行跟踪...）</em> </p><br><h2 id="logi-s-urovnyami-verbosity"> 详细级别的日志 </h2><br><blockquote> 应用程序必须支持至少具有两个操作模式的环境变量，例如LOG_LEVEL：ERRORS和DEBUG。 </blockquote><p> 希望同一生态系统中的所有服务都支持相同的环境变量。 不是配置选项，不是命令行上的选项（尽管这是可逆的），但默认情况下会从环境中立即获取。 如果出现问题，您应该能够获得尽可能多的日志，如果一切正常，则应该能够获得尽可能少的日志。 </p><br><h2 id="fiksirovannye-versii-zavisimostey"> 固定依赖版本 </h2><br><blockquote> 包管理器的依赖关系是固定的，包括次要版本（例如，cool_framework = 2.5.3）。 </blockquote><p> 当然，已经对此进行了很多讨论。 某些修复程序依赖于主要版本，希望只有次要的bug修复程序和安全修复程序将在次要版本中。 错了 <br> 每个依赖项中的每个更改都应反映在<em>单独的提交中</em> 。 以便在出现问题时可以将其取消。 用手很难控制吗？ 有一些有用的机器人（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如）</a> ，可以跟踪更新并为您每个人创建请求请求。 </p><br><h2 id="dockerized">  Dockerized </h2><br><blockquote> 存储库包含可用于生产的Dockerfile和docker-compose.yml </blockquote><p> 长期以来，Docker已成为许多公司的标准。 尽管有例外，但是即使您没有生产Docker，任何工程师也应该能够进行docker-compose，而不用考虑其他任何事情来获得用于本地验证的dev程序集。 并且系统管理员必须已使用必要版本的库，实用程序等使开发人员验证了程序集，在该程序中，应用程序<em>至少应以某种方式工作</em>以使其适合生产。 </p><br><h2 id="konfiguraciya-cherez-okruzhenie"> 环境配置 </h2><br><blockquote> 从环境中读取所有重要的配置选项，并且环境的优先级高于配置文件（但低于启动时的命令行参数）。 </blockquote><p> 没有人会想要阅读您的配置文件并研究其格式。 接受吧。 </p><br><p> 此处有更多详细信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//12factor.net/config</a> </p><br><h2 id="readiness-and-liveness-probes"> 准备和活力调查 </h2><br><blockquote> 包含适当的端点或cli命令，以测试是否准备在整个生命周期内启动和正常运行时服务于请求。 </blockquote><p> 如果应用程序处理HTTP请求，则默认情况下它应具有两个接口： </p><br><ol><li><p> 为了验证该应用程序是活动的而不是冻结的，使用了“活动性”测试。 如果应用程序没有响应，它可能会被诸如Kubernetes之类的协调器自动停止，“ <em>但这并不准确</em> 。” 实际上，杀死冻结的应用程序会导致多米诺骨牌效应，并永久性地影响您的服务。 但这不是开发人员的问题，只需执行此端点即可。 </p><br></li><li><p> 为了验证该应用程序不仅已启动，而且准备接受请求，将执行就绪测试。 如果应用程序已建立与数据库，排队系统等的连接，则应以200到400的状态响应（对于Kubernetes）。 </p><br></li></ol><br><h2 id="ogranicheniya-resursov"> 资源限制 </h2><br><blockquote> 以一致的格式包含对内存，CPU，磁盘空间和任何其他可用资源的消耗的限制。 </blockquote><p> 对于不同的组织和协调者，此项目的具体实施将有很大不同。 但是，必须对所有服务以单一格式设置这些限制，对于不同的环境（prod，dev，test等），这些限制必须不同，并且必须<em>与应用程序代码</em>一起<em>不在存储库中</em> 。 </p><br><h2 id="sborka-i-dostavka-avtomatizirovana"> 组装和交付是自动化的 </h2><br><blockquote> 已配置组织或项目中使用的CI / CD系统，并可以根据接受的工作流程将应用程序交付到所需的环境。 </blockquote><p>  <em>没有任何东西可以手动交付生产。</em> </p><br><p> 不管自动化项目的组装和交付有多么困难，都必须在该项目投入生产之前完成。 此项目包括Ansible / Chef食谱/ Salt / ...的组装和发布，移动设备应用程序的组装，操作系统的分支的组装，虚拟机映像的组装等。 <br> 无法自动化？ 因此，您无法将其投放世界。 在您之后，没有人会收集它。 </p><br><h2 id="graceful-shutdown--korrektnoe-vyklyuchenie"> 正常关机-正确关机 </h2><br><blockquote> 该应用程序可以处理SIGTERM和其他信号，并在处理完当前任务后系统地中断其工作。 </blockquote><p> 这是非常重要的一点。  Docker进程变得孤立，并在无人看到的后台运行了几个月。 非事务操作在执行过程中中断，从而导致服务和数据库之间的数据不一致。 这会导致无法预见的错误，并且可能会非常非常昂贵。 </p><br><p> 如果您不控制任何依赖项并且不能保证您的代码将正确处理SIGTERM，请使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dumb-init之</a>类的东西。 </p><br><p> 更多信息在这里： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://12factor.net/disposability</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods</a> </li></ul><br><h2 id="soedinenie-s-bazoy-dannyh-regulyarno-proveryaetsya"> 定期检查数据库连接 </h2><br><blockquote> 应用程序不断对数据库执行ping操作，并自动响应任何请求的“连接丢失”异常，尝试自行还原数据库或正确完成其工作 </blockquote><p> 我看到了很多情况（这不仅仅是言语转变），当为处理队列或事件而创建的服务因超时而失去连接并开始无休止地将错误倒入日志，将消息返回到队列，将它们发送到Dead Letter Queue或干脆不做它们的工作时。 </p><br><h2 id="masshtabiruetsya-gorizontalno"> 水平缩放 </h2><br><blockquote> 随着负载的增加，足以运行更多的应用程序实例以确保处理所有请求或任务。 </blockquote><p> 并非所有应用程序都可以水平扩展。 一个著名的例子是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">卡夫卡消费者</a> 。 这并不一定很糟糕，但是如果某个特定应用程序无法启动两次，则所有相关方都需要事先了解这一点。 这些信息应该引起人们的注意，并尽可能保留在自述文件中。 通常，某些应用程序在任何情况下都不能并行启动，这给其支持带来了严重困难。 </p><br><p> 如果应用程序本身控制这些情况，或者为其编写一个包装程序以有效地监视“竞争者”，并且仅允许该进程开始或开始工作，直到另一个进程完成其工作，或者直到某个外部配置允许N个进程同时工作，则更好。 </p><br><h2 id="dead-letter-queues-i-ustoychivost-k-plohim-soobscheniyam"> 死信队列和错误消息恢复能力 </h2><br><blockquote> 如果服务侦听队列或响应事件，则更改消息的格式或内容不会导致其崩溃。  N次重复处理任务的失败尝试，然后将消息发送到Dead Letter Queue。 </blockquote><p> 许多次，我看到无休止地重启消费者和生产线，这些消费者和生产线膨胀到如此之大的规模，以至于他们随后的处理花费了很多天。 任何队列侦听器都应准备好更改格式，消息本身的随机错误（例如，在json中键入数据）或由子代码处理消息时。 我什至遇到过这样的情况，一个非常流行的框架的标准RabbitMQ库不支持重试，尝试计数器等。 </p><br><p> 更糟的是，如果一条消息在失败的情况下被简单地销毁了。 </p><br><h2 id="ogranichenie-na-kolichestvo-obrabatyvaemyh-soobscheniy-i-zadach-odnim-processom"> 每个进程的已处理消息和任务数量的限制 </h2><br><blockquote> 它支持环境变量，可以强制使用该变量来限制已处理任务的最大数量，之后该服务将正确关闭。 </blockquote><p> 一切都在流动，一切都在变化，尤其是记忆。 内存消耗和OOM不断增长的图最终被杀死，这是现代kubernetic思维的常态。 原始测试的实现将为您省去检查所有这些内存泄漏的麻烦，这将使您的生活更加轻松。 我经常看到人们花费大量时间和精力（和金钱）来阻止这种流失，但是并不能保证您的同事的下一次提交不会使情况变得更糟。 如果应用程序可以在一周内存活-这是一个很好的指标。 然后让它自己结束并重新启动。 这比SIGKILL（关于SIGTERM，请参见上文）或“内存不足”异常要好。 几十年来，这个插头足以满足您的需求。 </p><br><h2 id="ne-ispolzuet-third-party-integracii-s-filtraciey-po-ip-adresam"> 不使用第三方集成和按IP地址过滤 </h2><br><blockquote> 如果应用程序向允许从有限IP地址访问的第三方服务发出请求，则该服务将通过反向代理间接执行这些调用。 </blockquote><p> 这是一种罕见的情况，但极为不愉快。 当一个微小的服务阻止更改集群或将整个基础架构移至另一个区域的可能性时，这非常不便。 如果您需要与不知道如何使用oAuth或VPN的人进行通信，请提前配置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反向代理</a> 。 不要在程序中实现此类外部集成的动态添加/删除，因为这样做会使您陷入唯一可用的运行时中。 最好立即自动执行这些过程来管理Nginx配置，并在您的应用程序中与他联系。 </p><br><h2 id="ochevidnyy-http-user-agent"> 明显的HTTP用户代理 </h2><br><blockquote> 该服务用对任何API的所有请求的自定义标题替换User-agent头，并且该头包含有关服务本身及其版本的足够信息。 </blockquote><p> 当您有100个不同的应用程序相互通信时，您会疯狂地在日志中看到诸如“ Go-http-client / 1.1”之类的内容以及Kubernetes容器的动态IP地址。 始终明确标识您的应用程序及其版本。 </p><br><h2 id="ne-narushaet-licenzii"> 不违反许可证 </h2><br><blockquote> 它不包含过度限制应用程序的依赖项，也不是其他人代码的副本，依此类推。 </blockquote><p> 这是不言而喻的案子，但碰巧看到即使是撰写NDA的律师也开始出现打ic。 </p><br><h2 id="ne-ispolzuet-nepodderzhivaemye-zavisimosti"> 不使用不受支持的依赖项 </h2><br><blockquote> 首次启动该服务时，它不包括已经过时的依赖项。 </blockquote><p> 如果您进入项目的库不再受任何人支持，请寻找另一种方法来实现目标或开发库本身。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 我的清单上有一些针对特定技术或情况的非常具体的检查，但我只是忘了添加一些内容。 我相信您还会发现一些需要记住的东西。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438064/">https://habr.com/ru/post/zh-CN438064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438046/index.html">如何快速在Spark上对百万点进行地理编码？</a></li>
<li><a href="../zh-CN438052/index.html">交互器，操作模式</a></li>
<li><a href="../zh-CN438058/index.html">“ Python中的数据分析”分为两部分</a></li>
<li><a href="../zh-CN438060/index.html">估计空间方向，或者如何不惧怕Mahoney和Majwik过滤器</a></li>
<li><a href="../zh-CN438062/index.html">我的地址不是房屋或街道，我的地址是苏联？</a></li>
<li><a href="../zh-CN438066/index.html">您从未听说过的10个英语教育YouTube频道</a></li>
<li><a href="../zh-CN438070/index.html">Y世代如何变成倦怠的世代？</a></li>
<li><a href="../zh-CN438074/index.html">[关于叶卡捷琳堡，新西伯利亚，圣彼得堡的公告] QAutomation测试会议：我们将通过测试涵盖从Neva到Ob的所有内容</a></li>
<li><a href="../zh-CN438078/index.html">Facebook每月为建立虚拟VPN支付20美元</a></li>
<li><a href="../zh-CN438080/index.html">由Wi-Fi信号供电的电子设备</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>