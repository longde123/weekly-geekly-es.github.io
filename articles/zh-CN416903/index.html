<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕯️ 💕 👨🏿‍🤝‍👨🏻 使用go-critic解析器为Go贡献力量 🥇 👆🏽 🔳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您可能还记得最近发布的Go的新静态分析器，称为go-critic 。 


 我用它检查了golang / go项目，并发送了一些补丁来修复那里发现的一些问题。 


 在本文中，我们将分析更正后的代码，并且还将激励我们将更多此类更改发送给Go。 


 最不耐烦的： 奖杯的更新列表 。 
 转到解...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用go-critic解析器为Go贡献力量</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416903/"><p><img src="https://habrastorage.org/webt/fp/k0/rn/fpk0rncwtlo5ozovjev4yi_gok8.png"></p><br><p> 您可能还记得最近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布的Go的新静态分析器，</a>称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">go-critic</a> 。 </p><br><p> 我用它检查了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">golang / go</a>项目，并发送了一些补丁来修复那里发现的一些问题。 </p><br><p> 在本文中，我们将分析更正后的代码，并且还将激励我们将更多此类更改发送给Go。 </p><br><p> 最不耐烦的： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">奖杯</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更新列表</a> 。 </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">转到解析列表</b> <div class="spoiler_text"><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">净：合并reverseaddr中的追加调用</a> <code>appendCombine</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cmd / link / internal / ld：避免在范围循环</a> <code>rangeValCopy</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定位副本</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cmd /编译/内部/ ssa：修复部件ByVarOffset.Less方法</a> <code>dupSubExpr</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运行时：在traceef.go</a> <code>underef</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">删除冗余的显式</a> <code>underef</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cmd / link / internal / sym：RelocName中的ELF案例的注释代码</a> <code>commentedOutCode</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运行时：简化切片表达式以使其本身</a> <code>unslice</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切片值</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">html /模板：使用命名的consts而不是它们的值</a> <code>namedConst</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cmd /内部/ obj / arm64：简化一些布尔表达式</a> <code>boolExprSimplify</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数学，净值：省略switch</a> <code>switchTrue</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">显式true tag expr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">归档文件/ tar：在类型表达式</a> <code>typeUnparen</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重新使用多余的parens</a> </li></ol></div></div><br><h1 id="dupsubexpr">  dupSubExpr </h1><br><p> 我们都会犯错，而且常常是疏忽大意。  Go语言是一种您有时不得不编写无聊的代码和样板代码的语言，有时会导致拼写错误和/或复制/粘贴错误。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL122776</a>包含针对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dupSubExpr</a>发现的错误的修复： </p><br><pre> <code class="diff hljs">func (a partsByVarOffset) Less(i, j int) bool { - return varOffset(a.slots[a.slotIDs[i]]) &lt; varOffset(a.slots[a.slotIDs[i]]) + return varOffset(a.slots[a.slotIDs[i]]) &lt; varOffset(a.slots[a.slotIDs[j]]) // ^__________________________________^ }</code> </pre> <br><p> 注意左右的索引。 在更正之前，运算符<code>&lt;</code>的LHS和RHS相同，并且<code>dupSubExpr</code>工作。 </p><br><h1 id="commentedoutcode">  commentedOutCode </h1><br><p> 如果您的项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">由版本控制系统</a>赞助，那么与其将其包装在注释中来禁用代码，不如将其完全删除是值得的。 有例外，但更多时候，这种“死”代码会干扰，混淆并可能隐藏错误。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">commentedOutCode</a>可以找到这样一个有趣的片段（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL122896</a> ）： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> arch.Family { <span class="hljs-comment"><span class="hljs-comment">// ...  case clause. case sys.I386: return elf.R_386(nr).String() case sys.MIPS, sys.MIPS64: // return elf.R_MIPS(nr).String() // &lt;- 1 case sys.PPC64: // return elf.R_PPC64(nr).String() // &lt;- 2 case sys.S390X: // return elf.R_390(nr).String() // &lt;- 3 default: panic("unreachable") }</span></span></code> </pre> <br><p> 还有一个更高的评论： </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// We didn't have some relocation types at Go1.4. // Uncomment code when we include those in bootstrap code.</span></span></code> </pre> <br><p> 如果切换到<code>go1.4</code>分支并从注释中删除了这3行，则代码将无法编译，但是，如果在向导中取消注释，则一切正常。 </p><br><p> 通常，隐藏在注释中的代码需要删除或反向激活。 </p><br><p> 有时，在代码中访问过去的回声非常有用。 </p><br><div class="spoiler">  <b class="spoiler_title">关于检测的困难</b> <div class="spoiler_text"><p> 这是我最喜欢的支票之一，但却是最“嘈杂”的支票之一。 </p><br><p> 对于在编译器内部使用<code>math/big</code>软件包，存在很多误报。 在第一种情况下，这些通常是对所执行操作的解释性注释，在第二种情况下，它们是描述AST片段的代码的描述。 将这样的注释与真实的“死”代码区分开而不引入假否定是不平凡的。 </p><br><p> 这引起了这样一个想法：如果我们同意以某种方式专门化注释内的代码，那该怎么办？ 然后将简化静态分析。 这可以是任何琐碎的事情，可以使定义这样的解释性注释变得容易，也可以使其变为无效的Go代码（例如，如果在行的开头添加井号，则<code>#</code> ）。 </p><br><p> 另一类是带有显式<code>TODO</code>注释。 如果删除了该代码以进行注释，但是有明确说明为什么这样做以及计划修复此代码的时间，则最好不要发出警告。 这已经实现，但是可以更可靠地工作。 </p></div></div><br><h1 id="boolexprsimplify">  boolExprSimplify </h1><br><p> 有时人们会写奇怪的代码。 也许在我看来，但是逻辑（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布尔</a> ）表达式有时看起来特别奇怪。 </p><br><p>  Go拥有出色的x86汇编程序后端（在这里落泪了），但是ARM确实做错了： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !(o1 != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br><p>  “如果不是o1不等于0” ...双重否定是经典。 如果您喜欢它，我邀请您熟悉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL123377</a> 。 在那里您可以看到更正的版本。 </p><br><div class="spoiler">  <b class="spoiler_title">更正的选项（适用于那些无法引诱进行审查的人）</b> <div class="spoiler_text"><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- if !(o1 != 0) { + if o1 == 0 {</span></span></code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">boolExprSimplify</a>旨在简化以提高可读性（如果没有它，Go优化器将可以解决性能问题）。 </p><br><h1 id="underef"> 不足 </h1><br><p> 如果使用早期版本的Go，您会记得强制分号，缺少指针的自动解引用以及其他新功能几乎无法在今天看到的功能。 </p><br><p> 在旧代码中，您仍然可以看到以下内容： </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// -    : buf := (*bufp).ptr() // ...     : buf := bufp.ptr()</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL122895中</a>修复了几个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不足的</a>分析仪触发器。 </p><br><h1 id="appendcombine">  appendCombine </h1><br><p> 您可能知道<code>append</code>可以将几个参数作为元素添加到目标切片中。 在某些情况下，这可以使您稍微提高代码的可读性，但是，这可能更有趣，它还可以加快程序的速度，因为编译器不会抑制兼容的<code>append</code>调用（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cmd / compile：combinate append调用</a> ）。 </p><br><p> 在Go中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">appendCombine</a>检查发现以下部分： </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- for i := len(ip) - 1; i &gt;= 0; i-- { - v := ip[i] - buf = append(buf, hexDigit[v&amp;0xF]) - buf = append(buf, '.') - buf = append(buf, hexDigit[v&gt;&gt;4]) - buf = append(buf, '.') - } + for i := len(ip) - 1; i &gt;= 0; i-- { + v := ip[i] + buf = append(buf, hexDigit[v&amp;0xF], + '.', + hexDigit[v&gt;&gt;4], + '.') + }</span></span></code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta ReverseAddress<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">4.10</span></span>µs ± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">3.94</span></span>µs ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">-3.81</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL117615中的</a>详细信息。 </p><br><h1 id="rangevalcopy">  rangeValCopy </h1><br><p> 复制在<code>range</code>循环中迭代的值并不是什么秘密。 对于小于64个字节的小对象，您甚至可能不会注意到这一点。 但是，如果这样的循环位于“热”路径上，或者您迭代遍历了许多元素，那么开销可能是明显的。 </p><br><p>  Go具有相当慢的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接器</a> （cmd / link），并且在其体系结构中没有进行重大更改的情况下，就无法实现强劲的性能提升。 但是，您可以借助微优化稍微降低其效率。 每百分之一或两个计数。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rangeValCopy</a>检查发现了几个周期，一次不需要复制数据。 这是其中最有趣的： </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- for _, r := range exports.R { - d.mark(r.Sym, nil) - } + for i := range exports.R { + d.mark(exports.R[i].Sym, nil) + }</span></span></code> </pre> <br><p> 除了只在每次迭代中复制<code>R[i]</code> ，我们仅求助于我们感兴趣的唯一成员<code>Sym</code> 。 </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta Linker<span class="hljs-number"><span class="hljs-number">-4</span></span> <span class="hljs-number"><span class="hljs-number">530</span></span>ms ± <span class="hljs-number"><span class="hljs-number">2</span></span>% <span class="hljs-number"><span class="hljs-number">521</span></span>ms ± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">-1.80</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">20</span></span>)</code> </pre> <br><p> 完整版本的修补程序可在以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">位置</a>获得： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL113636</a> 。 </p><br><h1 id="namedconst">  namedConst </h1><br><p> 不幸的是，在Go中，命名常量（即使组装成组）也不会相互连接，也不会形成枚举（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建议：spec：添加有类型的枚举支持</a> ）。 </p><br><p> 一个问题是将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无类型的常量</a>强制转换为您想用作枚举的类型。 </p><br><p> 假设您定义了一种<code>Color</code>类型，其值为<code>const ColDefault Color = 0</code> 。 <br> 您更喜欢以下两个代码片段中的哪一个？ </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// (A) if color == 0 { return colorBlack } // (B) if color == colorDefault { return colorBlack }</span></span></code> </pre> <br><p> 如果<code>(B)</code>更适合您，则检查<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">namedConst</a>将帮助您绕过命名常量本身来跟踪命名常量值的使用。 </p><br><p> 这就是<code>html/template</code>包中的<a href=""><code>context.mangle</code></a>方法的转换方式： </p><br><pre> <code class="diff hljs"> s := templateName + "$htmltemplate_" + c.state.String() - if c.delim != 0 { + if c.delim != delimNone { s += "_" + c.delim.String() } - if c.urlPart != 0 { + if c.urlPart != urlPartNone { s += "_" + c.urlPart.String() } - if c.jsCtx != 0 { + if c.jsCtx != jsCtxRegexp { s += "_" + c.jsCtx.String() } - if c.attr != 0 { + if c.attr != attrNone { s += "_" + c.attr.String() } - if c.element != 0 { + if c.element != elementNone { s += "_" + c.element.String() } return s</code> </pre> <br><p> 顺便说一句，有时在补丁的链接上您可以找到有趣的讨论... <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL123376</a>就是这样一种情况。 </p><br><h1 id="unslice"> 取消切片 </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切片表达式的</a>一个特征是，如果类型<code>x</code>是切片或字符串，则<code>x[:]</code>始终与<code>x</code>相同。 对于切片，这适用于任何类型的<code>[]T</code>元素。 </p><br><p> 下表中的所有内容都相同（ <code>x</code>切片）： </p><br><ul><li> <code>x</code> </li> <li> <code>x[:]</code> </li> <li> <code>x[:][:]</code> </li> <li>  ... </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解</a>切片找到类似的冗余切片表达式。 这些表达是有害的，首先，这会带来额外的认知负担。  <code>x[:]</code>在从数组中获取切片的情况下具有相当重要的语义。 具有默认范围的切片除了噪声以外不会执行任何操作。 </p><br><p> 我要求在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL123375</a>中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">打</a>补丁。 </p><br><h1 id="switchtrue">  switchTrue </h1><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL123378中</a> ，“ <code>switch true {...}</code> ”被“ <code>switch {...}</code> ”代替。 <br> 两种形式都是等效的，但第二种形式更惯用。 <br> 通过检查<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">switchTrue</a>发现。 </p><br><p> 大多数样式检查都精确地揭示了两种情况都可接受的情况，但其中一种更为常见，也为更多Go程序员所熟悉。 下次检查同一系列。 </p><br><h1 id="typeunparen">  typeUnparen </h1><br><p> 像许多其他编程语言一样，Go也喜欢括号。 如此之多，以至于我准备接受其中任何一个： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( t0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t1 (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) t2 ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// ... ,  . )</span></span></code> </pre> <br><p> 但是，如果您运行<code>gofmt</code>会发生什么？ </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( t0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t1 (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;- !   . t2 (int) // &lt;-    ... )</span></span></code> </pre> <br><p> 这就是为什么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">typeUnparen</a>存在。 他在程序中找到了所有类型表达式，您可以在其中减少方括号的数量。 我尝试发送<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL123379</a> ，让我们看看社区如何接受它。 </p><br><div class="spoiler">  <b class="spoiler_title">Lisp不喜欢大括号</b> <div class="spoiler_text"><p> 与类似C的语言不同，在Lisp中，在任何地方插入无用的括号并不容易。 因此，在语法基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">S表达式的语言中</a> ，编写一个除了括号以外不执行任何操作的程序比在某些其他语言中更困难。 </p></div></div><br><h1 id="go-critic-na-sluzhbe-go"> 随时随地批评 </h1><br><p> <a href="" title="点击放大"><img src="https://habrastorage.org/webt/bq/0a/ig/bq0aigrftmrocldewkgzuhiycdo.jpeg"></a> </p><br><p> 我们仅检查了已实施检查的一小部分。 同时，它们的数量和质量只会随着时间的推移而发展，这要感谢那些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参与开发的人</a> 。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">go-critic</a>绝对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是</a>免费的（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MIT许可证</a> ），并且对您参与该项目的开发也开放。 向我们发送检查建议，您可以立即进行实施，报告发现的错误和缺点，分享您的印象。 您还可以在Go代码审查中提出要审计或报告的项目，这种经验对我们来说是无价的。 </p><br><h2 id="tema-kontribyutinga-v-go"> 参与主题 </h2><br><p> 您看过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄罗斯的Go贡献研讨会</a>文章吗？ 今年秋天将是第二轮。 这次，除了更成功的格式和赞助商之外，我们还将拥有一个秘密武器-出色的静态分析器。 将会有足够的贡献！ </p><br><p> 但实际上，您可以立即开始（尽管更好-在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码冻结</a>之后<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">再过</a>一会儿）。 如果您设法在下一次研讨会之前感到舒适，那将非常酷，因为我们在俄罗斯缺少导师。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416903/">https://habr.com/ru/post/zh-CN416903/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416891/index.html">在美国，他们仍然被允许分发DIY武器的3D模型和数字制图。</a></li>
<li><a href="../zh-CN416893/index.html">Vaadin Flow-一只奇怪的鹿</a></li>
<li><a href="../zh-CN416897/index.html">如何建立自己动手的付款系统</a></li>
<li><a href="../zh-CN416899/index.html">我们告诉市长去哪里（使用开放式街道地图）</a></li>
<li><a href="../zh-CN416901/index.html">IT和安全专家如何保护自己：Cisco Connect，BlackHat，RSAC和MWC的真实案例</a></li>
<li><a href="../zh-CN416905/index.html">波士顿动力学SpotMini演示</a></li>
<li><a href="../zh-CN416907/index.html">幸福理论。 斑马定律和外星人排队</a></li>
<li><a href="../zh-CN416909/index.html">PostgreSQL活动会话历史记录-新的pgsentinel扩展</a></li>
<li><a href="../zh-CN416911/index.html">聊天机器人应该是下一个突破：出了什么问题？</a></li>
<li><a href="../zh-CN416913/index.html">管理员切换到云时应该忘记什么-学习什么</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>