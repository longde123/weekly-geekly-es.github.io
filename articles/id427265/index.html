<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍱 🔒 🔍 Protobuffer salah 🐢 🛌🏾 🤲🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk sebagian besar kehidupan profesional saya, saya menentang menggunakan Protokol Buffer. Mereka jelas ditulis oleh amatir, sangat sangat terspesia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protobuffer salah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427265/"> Untuk sebagian besar kehidupan profesional saya, saya menentang menggunakan Protokol Buffer.  Mereka jelas ditulis oleh amatir, sangat sangat terspesialisasi, menderita banyak jebakan, sulit untuk dikompilasi dan memecahkan masalah yang tidak dimiliki oleh siapa pun kecuali Google.  Jika masalah proto-buffer ini tetap berada di karantina abstraksi serialisasi, maka klaim saya akan berakhir di sana.  Namun sayangnya, desain Protobuffers yang buruk sangat mengganggu sehingga masalah ini dapat bocor ke dalam kode Anda. <br><br>  <b>Spesialisasi dan pengembangan sempit oleh para amatir</b> <br><br>  Berhenti  Tutup klien surel Anda, tempat Anda telah menulis surat kepada saya yang mengatakan bahwa "insinyur terbaik di dunia bekerja di Google", bahwa "desain mereka, menurut definisi, tidak dapat dibuat oleh amatir."  Saya tidak ingin mendengarnya. <br><br>  Mari kita tidak membahas topik ini.  Pengungkapan penuh: Saya dulu bekerja di Google.  Ini adalah tempat pertama (tapi sayangnya bukan yang terakhir) yang pernah saya gunakan Protobuffers.  Semua masalah yang ingin saya bicarakan ada di basis kode Google;  itu bukan hanya "penyalahgunaan protobuffers" dan sejenisnya. <br><a name="habracut"></a><br>  Sejauh ini, masalah terbesar dengan Protobuffers adalah sistem tipe yang mengerikan.  Penggemar Java seharusnya merasa betah di sini, tapi sayangnya secara harfiah tidak ada yang mengira Java adalah sistem tipe yang dirancang dengan baik.  Orang-orang dari kamp pengetikan dinamis mengeluh tentang batasan yang tidak perlu, sementara perwakilan dari kamp pengetikan statis, seperti saya, mengeluh tentang batasan yang tidak perlu dan kurangnya semua yang Anda inginkan dari sistem mengetik.  Kehilangan dalam kedua kasus. <br><br>  Spesialisasi dan pengembangan yang sempit oleh para amatir berjalan seiring.  Sebagian besar spesifikasinya tampaknya dibaut pada saat terakhir - dan itu jelas dibaut pada saat terakhir.  Beberapa batasan akan memaksa Anda untuk berhenti, menggaruk-garuk kepala dan bertanya: "Apa-apaan ini?"  Tapi ini hanya gejala dari masalah yang lebih dalam: <br><br>  Jelas, protobuffer dibuat oleh amatir karena mereka menawarkan solusi yang buruk untuk masalah terkenal dan sudah diselesaikan. <br><br><h1>  Kurang komposisi </h1><br>  Protobuffers menawarkan beberapa fitur yang tidak bekerja satu sama lain.  Misalnya, lihat daftar ortogonal, tetapi pada saat yang sama fungsi pengetikan terbatas yang saya temukan dalam dokumentasi. <br><br><ul><li> <code>oneof</code> bidang tidak dapat <code>repeated</code> . </li><li>  <code>map&lt;k,v&gt;</code> bidang <code>map&lt;k,v&gt;</code> memiliki sintaks khusus untuk kunci dan nilai, tetapi tidak digunakan dalam tipe lainnya. </li><li>  Meskipun bidang <code>map</code> dapat diparameterisasi, tidak ada tipe yang ditentukan pengguna yang diizinkan lagi.  Ini berarti bahwa Anda terjebak dengan menentukan spesialisasi Anda sendiri secara manual dalam struktur data umum. </li><li>  Bidang <code>map</code> tidak dapat <code>repeated</code> . </li><li>  Kunci <code>map</code> <i>bisa</i> berupa <code>string</code> , tetapi <i>bukan</i> <code>bytes</code> .  Enum juga dilarang, meskipun yang terakhir dianggap setara dengan bilangan bulat di semua bagian lain dari spesifikasi Protobuffers. </li><li>  Nilai <code>map</code> tidak boleh berupa <code>map</code> lain. </li></ul><br>  Daftar pembatasan gila ini adalah hasil dari pilihan desain dan fungsi pemasangan yang tidak berprinsip pada saat terakhir.  Misalnya, satu bidang tidak dapat <code>repeated</code> , karena alih-alih jenis samping, pembuat kode akan menghasilkan bidang opsional yang saling eksklusif.  Transformasi seperti itu hanya berlaku untuk bidang tunggal (dan, seperti yang akan kita lihat nanti, itu tidak bekerja bahkan untuk itu). <br><br>  Pembatasan bidang <code>map</code> , yang tidak dapat <code>repeated</code> , kira-kira dari opera yang sama, tetapi menunjukkan batasan yang berbeda dari sistem tipe.  Di belakang layar, <code>map&lt;k,v&gt;</code> berubah menjadi sesuatu yang mirip dengan <code>repeated Pair&lt;k,v&gt;</code> .  Dan karena <code>repeated</code> adalah kata kunci ajaib dari bahasa, dan bukan tipe normal, itu tidak bergabung dengan dirinya sendiri. <br><br>  Tebakan Anda tentang masalah <code>enum</code> sama benarnya dengan dugaan saya. <br><br>  Apa yang sangat membuat frustrasi tentang semua ini adalah pemahaman yang buruk tentang bagaimana sistem tipe modern bekerja.  Pemahaman ini <i>secara dramatis</i> akan <i>menyederhanakan</i> spesifikasi Protobuffers dan pada saat yang sama <i>menghapus semua pembatasan sewenang-wenang</i> . <br><br>  Solusinya adalah sebagai berikut: <br><br><ul><li>  Buat semua bidang dalam pesan yang <code>required</code> .  Ini membuat setiap pesan jenis produk. </li><li>  Naikkan nilai bidang <code>oneof</code> menjadi tipe data yang berdiri sendiri.  Ini akan menjadi jenis coproduct. </li><li>  Untuk mengaktifkan parameterisasi jenis produk dan produk tambahan jenis lainnya. </li></ul><br>  Itu saja!  Ketiga perubahan ini adalah semua yang Anda butuhkan untuk menentukan data yang memungkinkan.  Dengan sistem sederhana ini, Anda dapat mengulang semua spesifikasi Protobuffers lainnya. <br><br>  Misalnya, Anda dapat mengulangi bidang <code>optional</code> : <br><br><pre> <code class="hljs pgsql">product Unit { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> fields } coproduct Optional&lt;t&gt; { t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Unit unset = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Membuat bidang <code>repeated</code> juga sederhana: <br><br><pre> <code class="hljs php">coproduct <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt; { Unit <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Pair&lt;t, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt;&gt; cons = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Tentu saja, logika serialisasi sebenarnya memungkinkan Anda untuk melakukan sesuatu yang lebih pintar daripada mendorong daftar terkait melalui jaringan - lagipula, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi dan semantik tidak harus saling berhubungan</a> . <br><br><h1>  Pilihan yang meragukan </h1><br>  Protobuffers gaya Java membedakan antara tipe <i>skalar</i> dan <i>pesan</i> .  Skalars kurang lebih sesuai dengan primitif mesin - hal-hal seperti <code>int32</code> , <code>bool</code> dan <code>string</code> .  Jenis pesan, di sisi lain, adalah sisanya.  Semua perpustakaan dan tipe pengguna adalah pesan. <br><br>  Tentu saja, kedua jenis tipe ini memiliki semantik yang sama sekali berbeda. <br><br>  Bidang dengan tipe skalar selalu ada.  Bahkan jika Anda tidak menginstalnya.  Saya sudah mengatakan itu (setidaknya dalam proto3 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><sup>1</sup></a> <a name="1_1"></a>  ) apakah semua proto-buffer diinisialisasi ke nol, bahkan jika mereka sama sekali tidak memiliki data?  Bidang skalar mendapatkan nilai palsu: misalnya, <code>uint32</code> diinisialisasi ke <code>0</code> , dan <code>string</code> diinisialisasi ke <code>""</code> . <br><br>  Tidak mungkin membedakan bidang yang tidak ada di proto-buffer dari bidang yang diberi nilai default.  Agaknya, keputusan ini dibuat untuk optimasi agar tidak meneruskan standar skalar.  Ini hanya sebuah asumsi, karena dokumentasi tidak menyebutkan optimasi ini, jadi asumsi Anda tidak lebih buruk dari saya. <br><br>  Ketika kita membahas klaim Protobuffers tentang solusi ideal untuk kompatibilitas API ke belakang dan di masa depan, kita akan melihat bahwa ketidakmampuan untuk membedakan antara nilai-nilai yang tidak terdefinisi dan standar adalah mimpi buruk yang nyata.  Terutama jika itu benar-benar keputusan sadar untuk menyimpan satu bit (set atau tidak) untuk lapangan. <br><br>  Bandingkan perilaku ini dengan jenis pesan.  Sementara bidang skalar adalah "bodoh", perilaku bidang pesan benar-benar <i>gila</i> .  Secara internal, bidang pesan ada di sana atau tidak, tetapi perilakunya gila.  Kode pseudo kecil untuk pengakses mereka bernilai ribuan kata.  Bayangkan ini di Jawa atau di tempat lain: <br><br><pre> <code class="hljs pgsql">private Foo m_foo; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Foo foo { // <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an expression <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); } // <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an lvalue mutable <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) m_foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; } }</code> </pre> <br>  Secara teori, jika bidang <code>foo</code> tidak disetel, Anda akan melihat salinan awal yang diinisialisasi, apakah Anda memintanya atau tidak, tetapi Anda tidak dapat mengubah wadah.  Tetapi jika Anda mengubah <code>foo</code> , itu juga akan mengubah induknya!  Semua ini hanya untuk menghindari penggunaan tipe <code>Maybe Foo</code> dan "sakit kepala" terkait untuk mencari tahu apa arti nilai yang tidak terdefinisi. <br><br>  Perilaku seperti itu sangat mengerikan karena melanggar hukum!  Kami mengharapkan pekerjaan <code>msg.foo = msg.foo;</code>  tidak akan bekerja  Sebaliknya, implementasi sebenarnya diam-diam mengubah <code>msg</code> ke salinan <code>foo</code> dengan nol-inisialisasi jika tidak ada sebelumnya. <br><br>  Tidak seperti bidang skalar, setidaknya Anda dapat menentukan bahwa bidang pesan tidak disetel.  Binding bahasa untuk protobuffers menawarkan sesuatu seperti metode <code>bool has_foo()</code> dihasilkan.  Jika ada, maka dalam kasus sering menyalin bidang pesan dari satu protobuffer ke yang lain, Anda harus menulis kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src.has_foo(src)) { dst.set_foo(src.foo()); }</code> </pre> <br>  Harap dicatat bahwa, setidaknya dalam bahasa dengan pengetikan statis, templat <i>ini tidak dapat diabstraksi</i> karena hubungan nominal antara metode <code>foo()</code> , <code>set_foo()</code> dan <code>has_foo()</code> .  Karena semua fungsi ini adalah <i>pengidentifikasi</i> mereka sendiri, kami tidak memiliki sarana untuk membuatnya secara terprogram, dengan pengecualian makro preprosesor: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPY_IFF_SET(src, dst, field) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (src.has_##field(src)) { \ dst.set_##field(src.field()); \ }</span></span></code> </pre> <br>  (tapi macro preprosesor dilarang oleh panduan gaya Google). <br><br>  Jika alih-alih semua bidang tambahan diimplementasikan sebagai <code>Maybe</code> , Anda dapat dengan aman mengatur rekan panggilan abstrak. <br><br>  Untuk mengubah topik pembicaraan, mari kita bicara tentang keputusan meragukan lainnya.  Meskipun Anda dapat menentukan satu bidang dalam <code>oneof</code> , semantiknya <i>tidak cocok dengan</i> jenis produk bersama!  Kesalahan pemula, kawan!  Sebagai gantinya, Anda mendapatkan bidang opsional untuk setiap kotak dan kode ajaib di setter, yang akan dengan mudah membatalkan bidang lain jika disetel. <br><br>  Pada pandangan pertama, tampaknya ini harus secara semantik setara dengan jenis persatuan yang benar.  Tetapi sebaliknya, kita mendapatkan sumber kesalahan yang menjijikkan dan tak terlukiskan!  Ketika perilaku ini dikombinasikan dengan implementasi ilegal <code>msg.foo = msg.foo;</code>  , tugas yang tampaknya normal seperti itu secara diam-diam menghapus jumlah data yang sewenang-wenang! <br><br>  Akibatnya, ini berarti bahwa <code>oneof</code> bidang tidak membentuk <code>Prism</code> taat hukum, dan pesan tidak membentuk <code>Lens</code> taat hukum.  Jadi semoga sukses dengan upaya Anda untuk menulis manipulasi protobuffer nontrivial tanpa bug.  <i>Secara harfiah tidak mungkin untuk menulis kode polimorfik universal, bebas kesalahan, pada protobuffers</i> . <br><br>  Ini tidak terlalu menyenangkan untuk didengar, terutama bagi kita yang menyukai polimorfisme parametrik, yang <i>menjanjikan kebalikannya</i> . <br><br><h1>  Kebohongan kompatibilitas ke belakang dan ke depan </h1><br>  Salah satu "fitur mematikan" Protobuffers yang sering disebut adalah "kemampuan mereka yang bebas masalah untuk menulis mundur dan meneruskan API yang kompatibel."  Pernyataan ini digantung di depan mata Anda untuk mengaburkan kebenaran. <br><br>  Protobuffer itu <i>permisif</i> .  Mereka berhasil mengatasi pesan dari masa lalu atau masa depan, karena mereka sama sekali tidak menjanjikan tentang bagaimana data Anda akan terlihat.  Semuanya opsional!  Tetapi jika Anda membutuhkannya, Protobuffers akan dengan senang hati mempersiapkan dan memberi Anda sesuatu dengan pengecekan tipe, terlepas dari apakah itu masuk akal. <br><br>  Ini berarti bahwa Protobuffer menjalankan "perjalanan waktu" yang dijanjikan sambil secara <i>diam-diam melakukan hal yang salah secara default</i> .  Tentu saja, seorang programmer yang cermat dapat (dan seharusnya) menulis kode yang memeriksa kebenaran dari protobuffers yang diterima.  Tetapi jika Anda menulis pemeriksaan kebenaran perlindungan di setiap situs, mungkin itu hanya berarti bahwa langkah deserialisasi terlalu permisif.  Yang berhasil Anda lakukan adalah mendesentralisasikan logika validasi dari batas yang terdefinisi dengan baik dan coret di seluruh basis kode. <br><br>  Salah satu argumen yang mungkin adalah bahwa protobuffers akan menyimpan informasi apa pun yang mereka tidak mengerti dalam pesan.  Pada prinsipnya, ini berarti pengiriman pesan yang tidak merusak melalui perantara yang tidak memahami versi skema ini.  Ini kemenangan yang jelas, bukan? <br><br>  Tentu saja, di atas kertas ini adalah fitur keren.  Tapi saya belum pernah melihat aplikasi di mana properti ini benar-benar disimpan.  Dengan pengecualian perangkat lunak perutean, tidak ada program yang ingin memeriksa hanya sebagian kecil dari pesan dan kemudian meneruskannya tidak berubah.  Sebagian besar program protobuffer akan men-decode pesan, mengubahnya menjadi yang lain dan mengirimkannya ke tempat lain.  Sayangnya, konversi ini dibuat sesuai pesanan dan disandikan secara manual.  Dan konversi manual dari satu protobuffer ke yang lain tidak mempertahankan bidang yang tidak diketahui, karena secara harfiah tidak ada gunanya. <br><br>  Sikap di mana-mana terhadap protobuffer yang kompatibel secara universal juga dimanifestasikan dengan cara-cara jelek lainnya.  Panduan gaya untuk Protobuffer secara aktif menentang KERING dan menyarankan penyisipan definisi dalam kode bila memungkinkan.  Mereka berpendapat bahwa ini akan memungkinkan penggunaan pesan terpisah di masa depan jika definisi berbeda.  Saya menekankan bahwa mereka menawarkan untuk meninggalkan praktik pemrograman yang baik selama 60 tahun untuk <i>berjaga-jaga</i> , tiba-tiba, suatu saat di masa depan Anda perlu mengubah sesuatu. <br><br>  Akar masalahnya adalah bahwa Google menggabungkan makna data dengan representasi fisiknya.  Saat Anda menggunakan skala Google, itu masuk akal.  Pada akhirnya, mereka memiliki alat internal yang membandingkan pembayaran per jam programmer menggunakan jaringan, biaya penyimpanan X byte dan hal-hal lain.  Tidak seperti kebanyakan perusahaan teknologi, gaji programmer adalah salah satu item pengeluaran terkecil Google.  Secara finansial, masuk akal bagi mereka untuk menghabiskan waktu programmer untuk menghemat beberapa byte. <br><br>  Selain lima perusahaan teknologi terkemuka, tidak ada orang lain yang berada dalam lima urutan besarnya Google.  Startup Anda <i>tidak mampu</i> menghabiskan waktu rekayasa menghemat byte.  Tetapi menghemat byte dan membuang waktu programmer dalam proses adalah apa yang dioptimalkan untuk Protobuffers. <br><br>  Mari kita hadapi itu.  Anda tidak sesuai dengan skala Google, dan Anda tidak akan pernah cocok.  Berhentilah menggunakan kultus kargo teknologi hanya karena "Google menggunakannya," dan karena "ini adalah praktik terbaik industri." <br><br><h1>  Protobuffer mencemari basis kode </h1><br>  Jika mungkin untuk membatasi penggunaan Protobuffers hanya pada jaringan, saya tidak akan berbicara begitu keras tentang teknologi ini.  Sayangnya, meskipun pada prinsipnya ada beberapa solusi, tidak ada satupun yang cukup baik untuk digunakan dalam perangkat lunak nyata. <br><br>  Protobuffers berhubungan dengan data yang ingin Anda kirim melalui saluran komunikasi.  Mereka sering <i>konsisten</i> , tetapi tidak <i>identik</i> , dengan data aktual yang ingin dikerjakan oleh aplikasi.  Ini menempatkan kami pada posisi yang tidak nyaman, Anda harus memilih salah satu dari tiga opsi buruk: <br><br><ol><li>  Pertahankan jenis terpisah yang menggambarkan data yang benar-benar Anda butuhkan, dan pastikan kedua jenis didukung secara bersamaan. </li><li>  Kemas data lengkap dalam format untuk transmisi dan digunakan oleh aplikasi. </li><li>  Ambil data lengkap setiap kali dibutuhkan dari format pendek untuk transmisi. </li></ol><br>  Opsi 1 jelas merupakan solusi "benar", tetapi tidak cocok untuk Protobuffers.  Bahasa tidak cukup kuat untuk menyandikan tipe yang dapat melakukan pekerjaan ganda dalam dua format.  Ini berarti bahwa Anda harus menulis tipe data yang benar-benar terpisah, mengembangkannya secara sinkron dengan Protobuffers, dan <i>secara khusus menulis kode serialisasi untuk mereka</i> .  Tetapi karena kebanyakan orang tampaknya menggunakan Protobuffers untuk tidak menulis kode serialisasi, opsi ini jelas tidak pernah diterapkan. <br><br>  Sebaliknya, kode yang menggunakan protobuffers memungkinkan mereka untuk didistribusikan di seluruh basis kode.  Itu adalah kenyataan.  Proyek utama saya di Google adalah kompiler yang mengambil "program" yang ditulis dalam satu variasi Protobuffers dan menghasilkan "program" yang setara di yang lain.  Format input dan output sangat berbeda sehingga versi paralel yang benar dari C ++ tidak pernah bekerja.  Akibatnya, kode saya tidak dapat menggunakan salah satu teknik penulisan kompiler yang kaya, karena data Protobuffers (dan kode yang dihasilkan) terlalu sulit untuk melakukan sesuatu yang menarik dengan mereka. <br><br>  Akibatnya, alih-alih 50 garis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema rekursi</a> , 10.000 baris pengocokan penyangga khusus digunakan.  Kode yang ingin saya tulis secara harfiah tidak mungkin dilakukan dengan proto-buffer. <br><br>  Meskipun ini adalah satu kasus, itu tidak unik.  Karena sifat keras pembuatan kode, manifestasi proto-buffer dalam bahasa tidak akan pernah menjadi idiomatis, dan mereka tidak dapat dibuat demikian - kecuali Anda menulis ulang pembuat kode. <br><br>  Tetapi meskipun begitu, Anda masih memiliki masalah dengan menanamkan sistem tipe jelek di bahasa target Anda.  Karena sebagian besar fungsi Protobuffers tidak dipikirkan dengan baik, sifat meragukan ini bocor ke dalam basis kode kami.  Ini berarti bahwa kita dipaksa untuk tidak hanya mengimplementasikan, tetapi juga menggunakan ide-ide buruk ini dalam setiap proyek yang berharap untuk berinteraksi dengan Protobuffers. <br><br>  Pada dasar yang kuat, mudah untuk menyadari hal-hal yang tidak berarti, tetapi jika Anda pergi ke arah yang berbeda, paling baik Anda akan menghadapi kesulitan, dan paling buruk, dengan kengerian kuno yang nyata. <br><br>  Secara umum, berikan harapan kepada siapa pun yang mengimplementasikan Protobuffer dalam proyek mereka. <br><br><hr><br><a name="1"></a>  1. Sampai hari ini, ada diskusi hangat di Google tentang proto2 dan apakah bidang harus ditandai sebagaimana <code>required</code> .  Manifes " <code>optional</code> dianggap berbahaya" <i>dan</i> " <code>required</code> dianggap berbahaya" didistribusikan pada saat yang sama.  Semoga berhasil, kawan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427265/">https://habr.com/ru/post/id427265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427253/index.html">typeof Semuanya dan kesalahpahaman bebek</a></li>
<li><a href="../id427255/index.html">Cowon D2: Musical Long-Liver</a></li>
<li><a href="../id427257/index.html">Cameron Craig: Tujuh Pelajaran dari 10 Tahun Manajemen PR Apple</a></li>
<li><a href="../id427259/index.html">Apa yang benar-benar diperiksa oleh Tes Turing</a></li>
<li><a href="../id427263/index.html">Jadilah seorang ninja keamanan: rekaman webinar dan tingkat bonus</a></li>
<li><a href="../id427267/index.html">SNMP + Java - pengalaman pribadi. Menulis parser file MIB</a></li>
<li><a href="../id427269/index.html">Video Google OKR Lima Tahun Kemudian - Tinjauan Pengalaman Google Ventures dalam Menerapkan OKR (2012-2017)</a></li>
<li><a href="../id427271/index.html">Sejarah dan pengalaman menggunakan terjemahan mesin. Kuliah Yandex</a></li>
<li><a href="../id427273/index.html">Bisakah kecerdasan buatan meninggalkan bandar tanpa bekerja?</a></li>
<li><a href="../id427275/index.html">Arsitektur Informasi Internet Bagian 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>