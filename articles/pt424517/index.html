<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèª üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üë§ Implementa√ß√£o da minimiza√ß√£o de fun√ß√µes l√≥gicas pelo m√©todo Quine \ McCluskey com um conjunto de entradas incompleto üé∞ üëáüèæ üí∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √©, em certa medida, uma continua√ß√£o do meu artigo sobre a minimiza√ß√£o de fun√ß√µes l√≥gicas pelo m√©todo Quine-Mac'Klaski ( https://habr.com/p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementa√ß√£o da minimiza√ß√£o de fun√ß√µes l√≥gicas pelo m√©todo Quine \ McCluskey com um conjunto de entradas incompleto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424517/">  Este artigo √©, em certa medida, uma continua√ß√£o do meu artigo sobre a minimiza√ß√£o de fun√ß√µes l√≥gicas pelo m√©todo Quine-Mac'Klaski ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/post/328506</a> ).  Considerou um caso com fun√ß√µes l√≥gicas completamente definidas (embora isso n√£o tenha sido mencionado diretamente, mas apenas impl√≠cito).  Na realidade, esse caso √© bastante raro quando o n√∫mero de vari√°veis ‚Äã‚Äãde entrada √© pequeno.  Parcial ou incompletamente definidas, s√£o fun√ß√µes l√≥gicas cujos valores s√£o fornecidos apenas para a parte Q do conjunto completo P = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ N </script>  conjuntos poss√≠veis (termos) de seus argumentos (vari√°veis) do n√∫mero <i>N</i> , isto √©, Q &lt;P. Essa situa√ß√£o √© encontrada na pr√°tica na maioria dos casos de aplica√ß√£o de algoritmos para otimizar fun√ß√µes l√≥gicas.  De fato, por exemplo, se o n√∫mero de vari√°veis ‚Äã‚Äãde entrada for <i>N</i> = 30, que √© um caso comum, por exemplo, nos mercados financeiros, o volume da amostra de treinamento de entrada deve ser da ordem de <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>30</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>30</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {30} </script>  &gt; <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>10</mn><mn>9</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.379ex" height="2.419ex" viewBox="0 -935.7 1454.9 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-39" x="1415" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-3"> 10 ^ 9 </script>  termos √∫nicos √∫nicos.  Esse conjunto de dados n√£o √© encontrado em todas as grandes organiza√ß√µes, para n√£o mencionar indiv√≠duos, ou seja, essa j√° √© a esfera do BigData, o uso de data centers, etc. <br><br>  Portanto, na pr√°tica, na maioria das vezes, as fun√ß√µes l√≥gicas minimizadas n√£o ser√£o completamente determinadas simplesmente devido √† falta da quantidade necess√°ria de dados acumulados ou devido a v√°rias outras raz√µes objetivas (por exemplo, n√£o h√° espa√ßo suficiente para armazen√°-las).  Surge a pergunta sobre a possibilidade de "contornar" esse problema ao usar um algoritmo que funciona com um conjunto completamente definido de fun√ß√µes l√≥gicas de termos, como, por exemplo, no meu artigo anterior. <br><a name="habracut"></a><br><br>  A pr√°tica padr√£o neste caso √© determinar o conjunto de entrada incompleto de valores de vari√°vel (termo) para o valor completo, de modo a fornecer um resultado ideal para o conjunto de dados existente.  Mas, neste caso, h√° um problema na enumera√ß√£o de todas as variantes poss√≠veis de defini√ß√µes adicionais, cujo n√∫mero total √© V = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>P</mi><mo>&amp;#x2212;</mo><mi>Q</mi></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.207ex" height="2.539ex" viewBox="0 -987.6 2242 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMATHI-50" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-2212" x="751" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMATHI-51" x="1530" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mi>P</mi><mo>‚àí</mo><mi>Q</mi></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-4"> 2 ^ {P-Q} </script>  para selecionar a melhor op√ß√£o para defini√ß√£o adicional de acordo com um determinado crit√©rio.  Obviamente, para os valores realmente usados ‚Äã‚Äãde Q e P, o n√∫mero de op√ß√µes classificadas para defini√ß√µes adicionais √© astronomicamente grande e essa abordagem n√£o pode ser implementada na pr√°tica devido ao imenso custo computacional. <br><br>  Portanto, √© necess√°ria uma abordagem diferente que elimine a necessidade de enumerar v√°rias op√ß√µes para defini√ß√µes adicionais.  Portanto, √© necess√°rio modernizar o algoritmo original, que inicialmente funciona apenas com um conjunto de entradas totalmente definido, para que ele tamb√©m possa trabalhar com um conjunto truncado.  Essa implementa√ß√£o do algoritmo √© proposta neste artigo, com base no fato de que, no processo de minimiza√ß√£o, duas listas incompletas de termos s√£o processadas simultaneamente, nas quais a fun√ß√£o √© especificada como FALSE (0) e TRUE (1). <br><br>  Do ponto de vista do aprendizado de m√°quina, o algoritmo Quine-Mac'Klaski implementa o paradigma de aprendizado com o professor quando os valores de sa√≠da correspondentes da fun√ß√£o objetivo est√£o envolvidos no processo de aprendizado (neste caso, minimiza√ß√£o) simultaneamente.  Deixe-me lembr√°-lo que o princ√≠pio de opera√ß√£o do m√©todo b√°sico de Quine-Mac'Klaski, de acordo com a teoria, consiste em dois est√°gios principais: <br><ol><li>  Stage.  Localizando todos os termos LF simples usando regras de colagem (leis): <br>  a) (A e B)?  (A e B)?  A; <br>  b) (A? B) e (A ?! B)?  A; <br>  onde &amp; √© a opera√ß√£o l√≥gica AND;  - opera√ß√£o do "OR" l√≥gico;  - opera√ß√£o de nega√ß√£o l√≥gica "N√ÉO".  A partir dessas f√≥rmulas, segue-se que dois termos s√£o colados, se diferirem entre si apenas em uma das posi√ß√µes das vari√°veis.  Na posi√ß√£o em que os dois termos diferem entre si, o sinal "*" √© colocado.  Assim, o alfabeto em termos colados em compara√ß√£o com o original se expande para tr√™s valores: <br>  0 =&gt; falso; <br>  1 =&gt; verdadeiro; <br>  ‚Ä¢ 2 =&gt; vari√°vel colada (*). </li><li>  Stage.  Minimiza√ß√£o do n√∫mero de termos colados obtidos ap√≥s o primeiro est√°gio, como um problema de encontrar a cobertura ideal do conjunto inicial de termos com a quantidade Q. Ou seja, como cada termo de sa√≠da cobre apenas um determinado subconjunto dos termos iniciais, √© necess√°rio escolher um conjunto m√≠nimo de termos de sa√≠da que sejam identificados com com eles, subconjuntos de diferentes comprimentos no agregado cobriam completamente todos os termos de entrada iniciais.  O revestimento neste caso significa que a opera√ß√£o bit a bit da disjun√ß√£o do termo de sa√≠da sobre o termo de entrada deu um valor verdadeiro.  Digamos que o termo colado de sa√≠da tenha a seguinte forma: 10 * 0110 *. <br>  Em seguida, abrange o termo 10101100: <br>  10 * 0110 * e 10101100 = VERDADEIRO <br>  mas n√£o abrange o termo 00101100: <br>  10 * 0110 * &amp; 00101100 = FALSO <br>  Ou seja, o termo de entrada e a sa√≠da devem coincidir em todos os lugares, exceto nas posi√ß√µes em que existe um s√≠mbolo "*" - nessa posi√ß√£o, a vari√°vel do termo de entrada pode assumir qualquer valor, porque  nesta posi√ß√£o, a vari√°vel √© exclu√≠da da considera√ß√£o. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">O c√≥digo de implementa√ß√£o √© o seguinte (clique para visualizar):</b> <div class="spoiler_text"><pre><code class="plaintext hljs">using System; using System.Collections.Generic; using System.Linq; #region   /// &lt;summary&gt; ///      /// &lt;/summary&gt; public abstract class LogicFunction { // ""  public const byte cStarSymb = 2; //    public readonly ICollection&lt;byte[]&gt; Terms = new LinkedList&lt;byte[]&gt;(); //   public abstract bool Calculate(bool[] X); //   public abstract bool Calculate(char[] X); //   public abstract bool Calculate(byte[] X); } /// &lt;summary&gt; ///    /// &lt;/summary&gt; public class Dnf : LogicFunction { public static bool Calculate(byte[] X, byte[] term) { bool bResult = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] == cStarSymb) || (term[i] == X[i])) continue; bResult = false; break; } return bResult; } public override bool Calculate(byte[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(char[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == (byte)(X[i] == '0' ? 0 : 1))) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(bool[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || ((term[i] != 0) == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } } #endregion /// &lt;summary&gt; ///   /// &lt;/summary&gt; public class TreeFuncTerm { /// &lt;summary&gt; ///     /// &lt;/summary&gt; public class TreeNodeEnd { } //    private readonly TreeNodeEnd pCommonTreeNodeEnd = new TreeNodeEnd(); //  private readonly object[] rootNode = new object[3]; // ()  private int _rang = 0; public int Rang { get { return _rang; } } //    private int enumerationPos = 0; private object[][] enumerationBuf; //,     private byte[] enumerationTerm; public byte[] EnumerationTerm { get { return enumerationTerm; } } //     private UInt32 _count = 0; public UInt32 Count { get { return _count; } } // public TreeFuncTerm() { Clear(); } //  public void Clear() { _count = 0; _rang = 0; enumerationPos = 0; enumerationBuf = null; enumerationTerm = null; rootNode[0] = rootNode[1] = rootNode[2] = null; } //      public TreeNodeEnd EnumerationInit() { enumerationPos = 0; enumerationTerm = new byte[_rang]; enumerationTerm[0] = 0; enumerationBuf = new object[_rang][]; enumerationBuf[0] = rootNode; //    return EnumerationNextNode(); } //     public TreeNodeEnd EnumerationNextNode() { int iIsNext = (enumerationPos &gt; 0 ? 1 : 0); TreeNodeEnd pRetTreeNode = null; while ((pRetTreeNode == null) &amp;&amp; (enumerationPos &gt;= 0)) { object[] pCurrNodes = enumerationBuf[enumerationPos]; object pNextNode = null; int i = enumerationTerm[enumerationPos] + iIsNext; for (; i &lt; 3; i++) if ((pNextNode = pCurrNodes[i]) != null) break; if (pNextNode == null) { //    enumerationPos--; iIsNext = 1; } else { enumerationTerm[enumerationPos] = (byte)i; if (pNextNode is object[]) { //    enumerationPos++; enumerationBuf[enumerationPos] = (object[])pNextNode; enumerationTerm[enumerationPos] = 0; iIsNext = 0; } else //if (pNextNode is TreeNodeEnd) { //   pRetTreeNode = (TreeNodeEnd)pNextNode; } } } return pRetTreeNode; } //     public void AddTerm(byte[] term) { _rang = Math.Max(_rang, term.Length); object[] pCurrNode = rootNode; int iTermLength1 = term.Length - 1; for (int j = 0; j &lt; iTermLength1; j++) { byte cSymb = term[j]; object item = pCurrNode[cSymb]; if (item == null) { item = new object[3]; pCurrNode[cSymb] = item; } pCurrNode = (object[])item; } if (pCurrNode[term[iTermLength1]] == null) { //    pCurrNode[term[iTermLength1]] = pCommonTreeNodeEnd; _count++; } } //      public TreeNodeEnd Remove(byte[] term) { int iTermLength1 = term.Length - 1; object[] pCurrNode = rootNode; for (int i = 0; i &lt; iTermLength1; i++) { pCurrNode = (object[])pCurrNode[term[i]]; if (pCurrNode == null) break; } TreeNodeEnd pRemovedNode = null; if (pCurrNode != null) { //      pRemovedNode = (TreeNodeEnd)pCurrNode[term[iTermLength1]]; if (pRemovedNode != null) { //     pCurrNode[term[iTermLength1]] = null; // -  _count--; } } return pRemovedNode; } //     public bool Contains(byte[] term) { object pCurrNode = rootNode; foreach (byte cSymb in term) { pCurrNode = ((object[])pCurrNode)[cSymb]; if (pCurrNode == null) break; } return ((pCurrNode != null) &amp;&amp; (pCurrNode is TreeNodeEnd)); } } /// &lt;summary&gt; ///     ---- /// &lt;/summary&gt; public class Quine_McCluskey { //    private readonly Dnf _result = new Dnf(); public Dnf Result { get { return _result; } } //    private readonly Dnf _resultNeg = new Dnf(); public Dnf ResultNeg { get { return _resultNeg; } } //     private static void Skleivanie(TreeFuncTerm X1Tree, TreeFuncTerm X2Tree, TreeFuncTerm NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); for (TreeFuncTerm.TreeNodeEnd x1 = X1Tree.EnumerationInit(); x1 != null; x1 = X1Tree.EnumerationNextNode()) { bool bIsSkleiv = false; byte[] pCurrTerm = X1Tree.EnumerationTerm; for (int iPos = 0; iPos &lt; pCurrTerm.Length; iPos++) { byte cSymbSav = pCurrTerm[iPos]; if (cSymbSav == LogicFunction.cStarSymb) continue; //      pCurrTerm[iPos] = (byte)(1 - cSymbSav); if (X1Tree.Contains(pCurrTerm)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { pCurrTerm[iPos] = LogicFunction.cStarSymb; //  X2Tree.AddTerm(pCurrTerm); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(pCurrTerm)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.AddTerm(pCurrTerm); } } pCurrTerm[iPos] = cSymbSav; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //     private static UInt64 GetTermCode(byte[] pTerm) { UInt64 iMultip = 1, iCode = 0; for (int i = 0; i &lt; pTerm.Length; i++) { iCode += (iMultip * pTerm[i]); iMultip *= 3; } return iCode; } //     private static byte[] GetTermByCode(UInt64 iCode, int iTermLength, byte[] pTerm = null) { if (pTerm == null) pTerm = new byte[iTermLength]; int iCounter = 0; while (iCode != 0) { pTerm[iCounter++] = (byte)(iCode % 3); iCode /= 3; } while (iCounter &lt; iTermLength) pTerm[iCounter++] = 0; return pTerm; } //     private static void Skleivanie(ICollection&lt;UInt64&gt; X1Tree, ICollection&lt;UInt64&gt; X2Tree, ICollection&lt;UInt64&gt; NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel, int iTermLength) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); byte[] pCurrTerm = new byte[iTermLength]; bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); foreach (UInt64 x1 in X1Tree) { GetTermByCode(x1, iTermLength, pCurrTerm); bool bIsSkleiv = false; UInt64 iMultip = 1; for (int iPos = 0; iPos &lt; iTermLength; iPos++) { byte cSymbSav = pCurrTerm[iPos]; //(byte)((x1 / iMultip) % 3); if (cSymbSav != LogicFunction.cStarSymb) { UInt64 iCode = (cSymbSav == 0 ? x1 + iMultip : x1 - iMultip); //      if (X1Tree.Contains(iCode)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { X2Tree.Add(x1 + iMultip); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(iCode)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } pCurrTerm[iPos] = cSymbSav; if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.Add(x1 + (byte)(LogicFunction.cStarSymb - cSymbSav) * iMultip); } } } iMultip *= 3; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, ICollection&lt;UInt64&gt; OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) { UInt64 iCode = GetTermCode(x1); if (OutX2Tree.Contains(iCode)) continue; OutX2Tree.Add(iCode); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, TreeFuncTerm OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) OutX2Tree.AddTerm(x1); } //    private static bool IsEqualTerms(byte[] pTermC, byte[] pTermB) { if ((pTermC == null) || (pTermB == null) || (pTermC.Length != pTermB.Length)) return false; bool bIsEqual = false; int iLength = Math.Min(pTermC.Length, pTermB.Length); for ( int i = 0; i &lt; iLength; i++) { if (!(bIsEqual = (pTermB[i] == pTermC[i]))) break; } return bIsEqual; } //            private static void ReduceRedundancyTerms(LinkedList&lt;byte[]&gt; InpTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivTerms, ICollection&lt;byte[]&gt; ResultTerms) { if ((InpTerms == null) || (SkleivTerms == null) || (ResultTerms == null)) return; //   ResultTerms.Clear(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Outputs2Inputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Inputs2Outputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //    foreach (int iLevel in SkleivTerms.Keys.OrderByDescending(p =&gt; p).AsEnumerable()) { //       foreach (byte[] outTerm in SkleivTerms[iLevel]) { //  ,      term HashSet&lt;byte[]&gt; InpTermsLst = new HashSet&lt;byte[]&gt;(); //     foreach (byte[] inpTerm in InpTerms) { if (Dnf.Calculate(inpTerm, outTerm)) { InpTermsLst.Add(inpTerm); if (!Inputs2Outputs.ContainsKey(inpTerm)) Inputs2Outputs.Add(inpTerm, new HashSet&lt;byte[]&gt;()); Inputs2Outputs[inpTerm].Add(outTerm); } } Outputs2Inputs.Add(outTerm, InpTermsLst); } } //      -    Inputs2Outputs = Inputs2Outputs.OrderBy(p =&gt; p.Value.Count).ToDictionary(p =&gt; p.Key, v =&gt; v.Value); //   ,   -    while (Inputs2Outputs.Count &gt; 0) { byte[] outTerm = Inputs2Outputs.First().Value.OrderByDescending(q =&gt; Outputs2Inputs[q].Count()).First(); ResultTerms.Add(outTerm); foreach (byte[] inpTerm in Outputs2Inputs[outTerm].ToArray()) { foreach (byte[] outTerm2Del in Inputs2Outputs[inpTerm]) Outputs2Inputs[outTerm2Del].Remove(inpTerm); Inputs2Outputs.Remove(inpTerm); } } } //    public static void LogicFuncMinimize(IEnumerable&lt;byte[]&gt; PositivTerms, ICollection&lt;byte[]&gt; OutPos, IEnumerable&lt;byte[]&gt; NegativTerms, ICollection&lt;byte[]&gt; OutNeg) { int iTotalLevels = (PositivTerms.Count() &gt; 0 ? PositivTerms.First().Length : (NegativTerms != null &amp;&amp; NegativTerms.Count() &gt; 0 ? NegativTerms.First().Length : 0)); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivPosTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivNegTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); LinkedList&lt;byte[]&gt; InpPosTerms = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; InpNegTerms = new LinkedList&lt;byte[]&gt;(); if (iTotalLevels &lt; 40) { HashSet&lt;UInt64&gt; X1PositivTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); HashSet&lt;UInt64&gt; X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //        foreach(UInt64 iNumb in X1PositivTree.Intersect(X1NegativTree)) { // -    X1   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; GetTermCode(p) == iNumb); int iNeg_Count = NegativTerms.Count(p =&gt; GetTermCode(p) == iNumb); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(iNumb); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(iNumb); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(iNumb); X1NegativTree.Remove(iNumb); } } //           foreach (UInt64 code in X1NegativTree) { InpNegTerms.AddLast(GetTermByCode(code, iTotalLevels)); } } //          foreach (UInt64 code in X1PositivTree) { InpPosTerms.AddLast(GetTermByCode(code, iTotalLevels)); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { HashSet&lt;UInt64&gt; X2PositivTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter, iTotalLevels); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { HashSet&lt;UInt64&gt; X2NegativTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter, iTotalLevels); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } else { TreeFuncTerm X1PositivTree = new TreeFuncTerm(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); TreeFuncTerm X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new TreeFuncTerm(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //         for (TreeFuncTerm.TreeNodeEnd x1 = X1PositivTree.EnumerationInit(); x1 != null; x1 = X1PositivTree.EnumerationNextNode()) { if (!X1NegativTree.Contains(X1PositivTree.EnumerationTerm)) continue; // -    PositivTerms   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); int iNeg_Count = NegativTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } } //           for (TreeFuncTerm.TreeNodeEnd x1 = X1NegativTree.EnumerationInit(); x1 != null; x1 = X1NegativTree.EnumerationNextNode()) { InpNegTerms.AddLast((byte[])X1NegativTree.EnumerationTerm.Clone()); } } //          for (TreeFuncTerm.TreeNodeEnd X1Term = X1PositivTree.EnumerationInit(); X1Term != null; X1Term = X1PositivTree.EnumerationNextNode()) { InpPosTerms.AddLast((byte[])X1PositivTree.EnumerationTerm.Clone()); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { TreeFuncTerm X2PositivTree = new TreeFuncTerm(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { TreeFuncTerm X2NegativTree = new TreeFuncTerm(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } //       ReduceRedundancyTerms(InpPosTerms, SkleivPosTerms, OutPos); //       ReduceRedundancyTerms(InpNegTerms, SkleivNegTerms, OutNeg); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput) { LogicFuncMinimize(TermsInput, _result.Terms, null, null); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput, IEnumerable&lt;byte[]&gt; NegativTerms) { LogicFuncMinimize(TermsInput, _result.Terms, NegativTerms, _resultNeg.Terms); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput, IEnumerable&lt;char[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput, IEnumerable&lt;bool[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } public void PrintResult() { Console.WriteLine("--------Otvet-------"); char[] pTermSymbs = new char[] { '0', '1', '*' }; foreach (byte[] Term in _result.Terms) { for (int j = 0; j &lt; Term.Length; j++) { Console.Write(pTermSymbs[Term[j]].ToString() + " "); } Console.WriteLine(); } } }</code> </pre> <br></div></div><br><br>  A classe Quine_McCluskey √© uma implementa√ß√£o desse algoritmo que usa outras classes e interfaces: Dnf, TreeNodeBase, TreeNodeMiddle, TreeNodeEnd, TreeFuncTerm.  Para iniciar a otimiza√ß√£o, voc√™ precisa chamar um dos m√©todos Start sobrecarregados, que chama a fun√ß√£o LogicFuncMinimize, onde o algoritmo de minimiza√ß√£o √© implementado.  O mecanismo de minimiza√ß√£o √© implementado em duas vers√µes: <br>  ‚Ä¢ Usando o cont√™iner .NET SortedSet para armazenar e pesquisar termos. <br>  ‚Ä¢ sem usar cont√™ineres .NET com base na √°rvore tern√°ria do TreeFuncTerm. <br><br>  Em termos de velocidade, essas duas op√ß√µes s√£o aproximadamente iguais (com cont√™ineres .NET, talvez um pouco mais r√°pidos, mas nem sempre), mas a necessidade de implementar o TreeFuncTerm se deve a v√°rios fatores: <br>  ‚Ä¢ A primeira op√ß√£o, com base nos c√≥digos de n√∫mero inteiro de 64 bits e em uma pesquisa no dicion√°rio SortedSet .NET, funciona corretamente apenas com o n√∫mero de vari√°veis ‚Äã‚Äãde entrada em termos de at√© 40 e, com um n√∫mero maior, vai al√©m da grade de c√≥digo de n√∫mero inteiro de 64 bits, usado para opera√ß√£o de cont√™iner.  De fato, como a l√≥gica tern√°ria √© usada em termos colados dentro do algoritmo, com o n√∫mero de vari√°veis ‚Äã‚Äãde entrada igual a 41, o valor m√°ximo do c√≥digo hash <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>3</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>41</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,392)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-34"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-31" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>3</mn><mrow class="MJX-TeXAtom-ORD"><mn>41</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-5"> 3 ^ {41} </script>  j√° excede o valor m√°ximo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>64</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-36"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-34" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>64</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-6"> 2 ^ {64} </script>  -1, que pode ser gravado em uma vari√°vel de 64 bits.  Com mais vari√°veis, uma op√ß√£o √© usada com base na √°rvore de pesquisa tern√°ria do autor TreeFuncTerm. <br>  ‚Ä¢ √â necess√°rio verificar a opera√ß√£o da implementa√ß√£o em cont√™ineres .NET com outra implementa√ß√£o independente, livre deles. <br>  ‚Ä¢ Voc√™ s√≥ precisa de uma op√ß√£o livre de cont√™ineres .NET, que pode ser facilmente implementada em plataformas onde n√£o h√° plataforma .NET (por exemplo, em microcontroladores, FPGAs, etc.). <br>  A opera√ß√£o da √°rvore de pesquisa TreeFuncTerm √© baseada na configura√ß√£o de links para as classes TreeNodeMiddle e TreeNodeEnd, que s√£o implementa√ß√µes da interface TreeNodeBase.  A classe TreeNodeMiddle √© um n√≥ intermedi√°rio da √°rvore e a classe TreeNodeEnd √© o final da folha da √°rvore.  Usando as fun√ß√µes EnumerationInit () e EnumerationNextNode (), um mecanismo n√£o recursivo para enumerar todas as folhas de folhas de TreeNodeEnd √© implementado na √°rvore.  A fun√ß√£o EnumerationInit () inicializa a enumera√ß√£o e retorna a primeira folha na √°rvore.  A fun√ß√£o EnumerationNextNode () retorna a pr√≥xima folha da √°rvore ou NULL se n√£o houver mais folhas para a sele√ß√£o.  Al√©m disso, a estrutura interna auxiliar EnumerationTerm, que reflete a posi√ß√£o do ‚Äúcursor‚Äù de busca dentro da √°rvore, tamb√©m √© o c√≥digo de termo da planilha encontrada na l√≥gica tern√°ria {0,1,2}.  Note-se que a ordem de sele√ß√£o das folhas da √°rvore n√£o coincide com a ordem de adicion√°-las a ela. <br><br>  O algoritmo para fins funcionais pode ser dividido em tr√™s est√°gios. <br><ol><li>  <b>Prepara√ß√£o.</b>  Para resolver o problema acima de eliminar a enumera√ß√£o de op√ß√µes para defini√ß√µes adicionais na implementa√ß√£o em considera√ß√£o, a fun√ß√£o LogicFuncMinimize recebe dois conjuntos de dados iniciais PositivTerms e NegativTerms, nos quais a fun√ß√£o otimizada aceita valores true (TRUE, 1) e false (FALSE, 0), respectivamente.  Antes de tudo, essas listas s√£o verificadas quanto √† consist√™ncia dos dados de origem.  √â necess√°rio que seja garantido que cada um dos conjuntos de dados contenha apenas termos exclusivos presentes apenas em qualquer uma das listas.  Para garantir isso, cada termo de entrada exclusivo √© verificado e o n√∫mero de entradas em cada uma das listas de fontes √© encontrado.  Se o termo aparecer nas duas listas, ele permanecer√° apenas na lista em que aparece mais e ser√° exclu√≠do da outra.  Se o termo ocorrer em cada uma das listas com a mesma frequ√™ncia, ele ser√° removido das duas listas, o que garante exclusividade. </li><li>  <b>Liga√ß√£o.</b>  Em seguida, √© executado um ciclo iterativo para colar termos de entrada.  A cada itera√ß√£o, em termos colados, um sinal * da posi√ß√£o colada √© adicionado.  Portanto, o n√∫mero de itera√ß√µes n√£o pode ser maior que o n√∫mero de vari√°veis <i>N.</i>  Em contraste com a implementa√ß√£o anterior, a fun√ß√£o Skleivanie para colar termos de entrada tem a capacidade de colar n√£o apenas os termos de sua lista, mas tamb√©m na aus√™ncia de um termo com uma diferen√ßa, tamb√©m com os chamados termos "virtuais".  Por termos "virtuais", entendemos termos definidos artificialmente que n√£o s√£o encontrados em nenhuma das listas de termos de um conjunto do n√≠vel atual.  Por√©m, a colagem √© poss√≠vel apenas se o termo "virtual" n√£o cobrir um √∫nico termo do conjunto inicial da lista oposta. <br>  A fun√ß√£o Skleivanie √© chamada para processar listas em cada itera√ß√£o duas vezes, de modo que, na primeira chamada, o significado do uso das listas PositivTerms e NegativTerms coincida com seu conte√∫do real e, na segunda chamada, as listas PositivTerms e NegativTerms sejam trocadas em termos de uso, ou seja, considera-se que A lista PositivTerms cont√©m termos negativos e a lista NegativTerms cont√©m termos positivos: <br>  Skleivanie (X1PositivTree, ..., X1NegativTree, ..., SkleivTerms, ...); <br>  Skleivanie (X1NegativTree, ..., X1PositivTree, ..., null, ...); <br>  Assim, ocorre uma colagem interdependente simult√¢nea dos termos de duas listas. <br>  Se, para o termo, n√£o houver outro termo diferente em apenas uma posi√ß√£o, nem real nem virtual, ou seja, o termo n√£o se une a ningu√©m, √© considerado um dos resultados da etapa 1 do algoritmo, √© exclu√≠do de outros trabalhos e segue √† entrada do est√°gio 2 do algoritmo implementado no procedimento ReduceRedundancyTerms.  Termos n√£o colados s√£o enviados para a sa√≠da do algoritmo somente nessa chamada para a fun√ß√£o Skleivanie, para a qual o significado do uso das listas PositivTerms e NegativTerms coincide com o preenchimento real, ou seja, na primeira chamada. </li><li>  <b>Abrevia√ß√£o.</b>  Os termos colados redundantes s√£o descartados nos ReduceRedundancyTerms usando um algoritmo para resolver aproximadamente o problema de cobrir o conjunto original com subconjuntos de comprimento vari√°vel.  A cobertura, que √© a mais curta, √© fornecida pelo algoritmo para converter a tabela de cobertura (TP), com base no m√©todo "coluna m√≠nima - linha m√°xima" (que pode ser vista, por exemplo, aqui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.studfiles.ru/preview/5175815/page:4</a> ) . <br>  A l√≥gica aproximada de seu trabalho √© a seguinte: <br>  0. A tabela original √© considerada o TP transformado atual, o conjunto de linhas de cobertura est√° vazio; <br>  1. A coluna com menos unidades √© destacada na tabela atual.  Entre as linhas que cont√™m unidades nesta coluna, uma com o maior n√∫mero de unidades √© destacada.  Esta linha est√° inclu√≠da na cobertura; a tabela atual √© reduzida ao excluir todas as colunas nas quais a linha selecionada possui uma unidade. <br>  2. Se n√£o houver colunas riscadas na tabela, a etapa 1 ser√° executada; caso contr√°rio, a cobertura ser√° constru√≠da.  Nota: Ao calcular o n√∫mero de unidades em uma linha, as unidades nas colunas n√£o marcadas s√£o levadas em considera√ß√£o. <br>  Esse algoritmo funciona r√°pido o suficiente e fornece um resultado pr√≥ximo do ideal. <br>  Para testar a opera√ß√£o do algoritmo, prop√µe-se o uso da fun√ß√£o de teste TestQuineMcCluskeyRandomPart, que, do conjunto total de termos poss√≠veis, √© <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhh9CiW39FxsMDEDZO2CZd9BWMuFg#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-7"> 2 ^ N </script>  seleciona aleatoriamente apenas a parte especificada 0 &lt;dPart &lt;= 1 (√© um par√¢metro da fun√ß√£o), para a qual a otimiza√ß√£o √© realizada.  Com o par√¢metro dPart &lt;1, um conjunto truncado de termos de entrada ser√° obtido e, com dPart = 1, ser√° obtido um conjunto completo de dados de entrada. </li></ol><br><div class="spoiler">  <b class="spoiler_title">TestQuineMcCluskeyRandomPart (clique para visualizar)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">public static void TestQuineMcCluskeyRandomPart(int iVariableAmount, double dPart=1) { if (dPart &lt; 0) throw new ArgumentException(" dPart    0   1"); if (dPart &gt; 1) dPart = 1; //   ulong iTotalCombines = (ulong)1 &lt;&lt; iVariableAmount; LinkedList&lt;byte[]&gt; pTrueCol = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; pFalseCol = new LinkedList&lt;byte[]&gt;(); HashSet&lt;ulong&gt; pUsedTerms = new HashSet&lt;ulong&gt;(); Random rnd = new Random(); byte[] buf = new byte[8]; while (pUsedTerms.LongCount() &lt; (iTotalCombines * dPart)) { rnd.NextBytes(buf); ulong iCurValue = (ulong)BitConverter.ToInt64(buf, 0) % iTotalCombines; if (pUsedTerms.Contains(iCurValue)) { //  -     do { iCurValue = ++iCurValue % iTotalCombines; } while (pUsedTerms.Contains(iCurValue)); } pUsedTerms.Add(iCurValue); byte[] sLine = new byte[iVariableAmount]; for (int i = 0; i &lt; iVariableAmount; i++) { sLine[i] += (byte)(iCurValue % 2); iCurValue &gt;&gt;= 1; } if (rnd.Next(2) != 0) { pTrueCol.AddLast(sLine); } else { pFalseCol.AddLast(sLine); } } //   DateTime DtStart = DateTime.Now; Console.WriteLine(" - " + DtStart.ToLongTimeString()); Quine_McCluskey Logic = new Quine_McCluskey(); Logic.Start(pTrueCol, pFalseCol); DateTime DtEnd = DateTime.Now; Logic.PrintResult(); Console.WriteLine(" - " + DtStart.ToLongTimeString()); Console.WriteLine(" - " + DtEnd.ToLongTimeString()); TimeSpan Elapsed = DtEnd - DtStart; Console.WriteLine(" - " + String.Format("{0:00}:{1:00}:{2:00}", Elapsed.Hours, Elapsed.Minutes, Elapsed.Seconds)); //  int iErrorsCounter = 0; foreach (byte[] kvp in pTrueCol) { if (Logic.Result.Calculate(kvp) != true) iErrorsCounter++; } foreach (byte[] kvp in pFalseCol) { if (Logic.Result.Calculate(kvp) != false) iErrorsCounter++; } Console.WriteLine("-   = " + pUsedTerms.Count); Console.WriteLine("-   = " + Logic.Result.Terms.Count); Console.WriteLine("-  = " + iErrorsCounter); Console.ReadLine(); }</code> </pre><br></div></div><br><br>  Como resultado da fun√ß√£o de teste, s√£o calculados o n√∫mero de termos na forma normal disjuntiva m√≠nima e o n√∫mero de erros que o cobrem com o conjunto de termos original. <br><br>  Concluindo, gostaria de observar que, na pr√°tica, essa implementa√ß√£o do algoritmo provou ser um meio eficaz e confi√°vel de minimizar as fun√ß√µes l√≥gicas definidas por dois conjuntos incompletos de termos nos quais a fun√ß√£o l√≥gica assume valores TRUE e FALSE, respectivamente.  Obviamente, essa implementa√ß√£o tamb√©m pode ser usada de forma cl√°ssica no caso de uma fun√ß√£o l√≥gica de entrada completamente definida, quando apenas uma ou outra lista de termos √© inserida.  Como desvantagem, √© necess√°rio verificar na fun√ß√£o Skleivanie que n√£o h√° erros de cobertura para cada termo virtual de toda a lista de termos de origem em cada itera√ß√£o do algoritmo, o que leva a custos de tempo significativos com um grande n√∫mero de termos de entrada. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424517/">https://habr.com/ru/post/pt424517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424505/index.html">‚ÄúTemos ideias para o Maven 4 e at√© o Maven 5‚Äù - uma entrevista com Robert Scholte, um participante importante no projeto Maven</a></li>
<li><a href="../pt424507/index.html">VI Hackathon Anual da JetBrains: Shiftius Altius Ctrlius</a></li>
<li><a href="../pt424509/index.html">Trabalhando com a API KOMPAS-3D ‚Üí Li√ß√£o 12 ‚Üí Linhas compostas</a></li>
<li><a href="../pt424511/index.html">Ferramentas para localizar classes anotadas em Java</a></li>
<li><a href="../pt424513/index.html">Sobre data centers baratos, prote√ß√£o ILV e DDoS</a></li>
<li><a href="../pt424519/index.html">Beethoven pode enviar solicita√ß√µes de remo√ß√£o?</a></li>
<li><a href="../pt424525/index.html">Controle de velocidade de mini-furadeira</a></li>
<li><a href="../pt424531/index.html">Microsservi√ßos: o tamanho √© importante mesmo se voc√™ tiver o Kubernetes</a></li>
<li><a href="../pt424533/index.html">‚ÄúQualquer pessoa de TI que se preze se envolve em tecnologia em seu tempo livre‚Äù - 10 perguntas para o programador, edi√ß√£o 6</a></li>
<li><a href="../pt424537/index.html">Sberbank lan√ßou seu pr√≥prio operador, SberMobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>