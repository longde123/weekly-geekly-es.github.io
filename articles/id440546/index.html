<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏿 🚡 🧝🏿 Obrolan Terdistribusi di Node.JS dan Redis 🕘 📦 🦉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebuah pertanyaan / jawaban kecil: 


 Untuk siapa ini? Orang-orang yang memiliki sedikit atau tanpa pengalaman dengan sistem terdistribusi, dan yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Obrolan Terdistribusi di Node.JS dan Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="Menarik adalah gambar yang layak untuk dicuci &quot;surat merpati&quot;"></p><br><p>  Sebuah pertanyaan / jawaban kecil: </p><br><p> <em>Untuk siapa ini?</em>  Orang-orang yang memiliki sedikit atau tanpa pengalaman dengan sistem terdistribusi, dan yang tertarik melihat bagaimana mereka dapat dibangun, pola dan solusi apa yang ada. </p><br><p>  <em>Kenapa ini?</em>  Dirinya menjadi tertarik pada apa dan bagaimana.  Saya mengambil informasi dari berbagai sumber, saya memutuskan untuk mempostingnya dalam bentuk yang terkonsentrasi, karena pada suatu waktu saya sendiri ingin melihat karya seperti itu.  Sebenarnya, ini adalah pernyataan tekstual tentang pelemparan dan pemikiran pribadi saya.  Juga, mungkin akan ada banyak koreksi dalam komentar dari orang-orang yang berpengetahuan, dan ini sebagian tujuan menulis semua ini dalam bentuk artikel. </p><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Bagaimana cara ngobrol?  Ini seharusnya menjadi tugas yang sepele, mungkin setiap beckender detik menggergaji sendiri, sama seperti pengembang game membuat tetris / ular mereka, dll. Saya mengambil yang ini, tetapi untuk membuatnya lebih menarik, itu harus siap untuk mengambil alih dunia, sehingga bisa menahan ratusan miliar pengguna aktif dan secara umum sangat keren.  Kebutuhan yang jelas untuk arsitektur terdistribusi berasal dari ini, karena tidak realistis untuk memiliki kapasitas saat ini untuk memenuhi semua jumlah pelanggan imajiner pada satu mesin.  Alih-alih hanya duduk dan menunggu kemunculan komputer kuantum, saya mulai mempelajari topik sistem terdistribusi. </p><br><p>  Perlu dicatat bahwa respons cepat sangat penting, realtime terkenal, itu <strong>obrolan</strong> !  bukan pengiriman surat merpati. </p><br><p>  % <em>lelucon acak tentang pos Rusia</em> % </p><br><p>  Kami akan menggunakan Node.JS, ini sangat ideal untuk membuat prototipe.  Untuk soket, ambil Socket.IO.  Tulis di TypeScript. </p><br><p>  Jadi apa yang kita inginkan: </p><br><ol><li>  Sehingga pengguna bisa saling mengirim pesan </li><li>  Ketahui siapa yang online / offline </li></ol><br><p>  Bagaimana kita menginginkannya: </p><a name="habracut"></a><br><h2 id="singl-server">  Server tunggal </h2><br><p>  Tidak ada yang bisa dikatakan terutama, langsung ke kode.  Deklarasikan antarmuka pesan: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Di server: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  Pada klien, sesuatu seperti: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Anda dapat bekerja dengan status online seperti ini: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  Dan pada klien: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Catatan: kode tidak berjalan, saya hanya menulis dari memori misalnya </blockquote><p>  Sama seperti kayu bakar, kami memutar otorisasi nyata syudy, manajemen kamar (sejarah pesan, menambah / menghapus peserta) dan keuntungan. </p><br><p>  TAPI!  Tetapi kita akan mengambil alih perdamaian dunia, yang berarti ini bukan saatnya untuk berhenti, kita dengan cepat bergerak: </p><br><h2 id="nodejs-klaster">  Node.JS cluster </h2><br><p>  Contoh penggunaan Socket.IO pada banyak node tepat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web resmi</a> .  Termasuk juga ada cluster Node.JS asli, yang bagi saya kelihatannya tidak dapat diterapkan pada tugas saya: memungkinkan kita untuk memperluas aplikasi kita di seluruh mesin, TAPI tidak di luar cakupannya, jadi kita pasti melewatkannya.  Kita akhirnya perlu melampaui batas-batas sepotong besi! </p><br><h2 id="raspredelyay-i-velosiped">  Bagikan dan bersepeda </h2><br><p>  Bagaimana cara melakukannya?  Jelas, Anda harus menghubungkan contoh kami, entah bagaimana diluncurkan tidak hanya di rumah di ruang bawah tanah, tetapi juga di ruang bawah tanah tetangga.  Apa yang pertama kali terlintas dalam pikiran: kami membuat semacam tautan perantara yang akan berfungsi sebagai bus di antara semua simpul kami: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Ketika sebuah node ingin mengirim pesan ke yang lain, itu membuat permintaan ke Bus, dan sudah, pada gilirannya, meneruskannya ke tempat yang dibutuhkan, semuanya sederhana.  Jaringan kami siap! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... tapi tidak sesederhana itu?) </p><br><p>  Dengan pendekatan ini, kami mengalami kinerja tautan perantara ini, dan memang kami ingin langsung menghubungi node yang diperlukan, karena apa yang bisa lebih cepat daripada komunikasi langsung?  Jadi mari kita bergerak ke arah ini! </p><br><p>  Apa yang dibutuhkan terlebih dahulu?  Sebenarnya, sahkan satu contoh ke yang lain.  Tetapi bagaimana yang pertama belajar tentang keberadaan yang kedua?  Tetapi kami ingin memiliki jumlah yang tak terbatas dari mereka, secara acak menaikkan / menghapus!  Kami membutuhkan server master yang alamatnya diketahui diketahui, semua orang terhubung, karena yang mengetahui semua node yang ada dalam jaringan dan berbagi informasi ini dengan semua orang. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  Node naik, memberi tahu master tentang kebangkitannya, ia memberikan daftar node aktif lainnya, kami terhubung ke mereka dan hanya itu, jaringan sudah siap.  Master mungkin Konsul atau sesuatu seperti itu, tetapi karena kita bersepeda, master harus dibuat sendiri. </p><br><p>  Hebat, sekarang kita punya skynet kita sendiri!  Tetapi implementasi obrolan saat ini di dalamnya tidak lagi cocok.  Mari kita benar-benar datang dengan persyaratan: </p><br><ol><li>  Ketika seorang pengguna mengirim pesan, kita perlu tahu kepada siapa dia mengirimkannya, yaitu, memiliki akses ke para peserta di ruangan itu. </li><li>  Ketika kami menerima peserta, kami harus mengirimkan pesan kepada mereka. </li><li>  Kita perlu tahu pengguna mana yang sedang online sekarang. </li><li>  Untuk kenyamanan - beri pengguna kesempatan untuk berlangganan status online pengguna lain, sehingga secara real time mereka belajar tentang perubahannya </li></ol><br><p>  Mari kita berurusan dengan pengguna.  Misalnya, Anda bisa membuat master tahu simpul mana yang terhubung ke simpul mana.  Situasinya adalah sebagai berikut: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Dua pengguna terhubung ke node yang berbeda.  Tuan tahu ini, simpul tahu apa yang tuan tahu.  Ketika UserB masuk, Node2 memberitahu Master, yang "mengingat" bahwa UserB terhubung ke Node2.  Ketika UserA ingin mengirim pesan UserB, Anda mendapatkan gambar berikut: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  Pada prinsipnya, semuanya berfungsi, tetapi saya ingin menghindari putaran perjalanan tambahan dalam bentuk menginterogasi master, akan lebih ekonomis untuk segera menghubungi simpul yang tepat secara langsung, karena itu sebabnya semuanya dimulai.  Ini dapat dilakukan jika mereka memberi tahu semua orang di sekitar pengguna yang terhubung dengan mereka, masing-masing dari mereka menjadi analog mandiri dari wizard, dan wizard itu sendiri menjadi tidak perlu, karena daftar rasio "Pengguna =&gt; Node" diduplikasi untuk semua orang.  Pada awal node, cukup terhubung ke yang sudah berjalan, tarik daftarnya ke diri sendiri dan voila, itu juga siap untuk pertempuran. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Tetapi sebagai trade off, kami mendapatkan duplikat dari daftar, yang, meskipun merupakan rasio "id pengguna -&gt; [koneksi host]", tetapi dengan jumlah pengguna yang cukup itu akan berubah menjadi memori yang cukup besar.  Dan secara umum, memotongnya sendiri - itu jelas menampar industri sepeda.  Semakin banyak kode, semakin banyak kesalahan potensial.  Mungkin kami membekukan opsi ini dan melihat apa yang sudah siap: </p><br><h2 id="brokery-soobscheniy">  Pialang pesan </h2><br><p>  Entitas yang mengimplementasikan "Bus" yang sama, "tautan perantara" yang disebutkan di atas.  Tugasnya adalah menerima dan mengirim pesan.  Kami, sebagai pengguna, dapat berlangganan dan mengirim milik kami sendiri.  Semuanya sederhana. </p><br><p>  Ada RabbitMQ dan Kafka yang telah terbukti: mereka hanya melakukan apa yang mereka kirimkan pesan - ini adalah tujuan mereka, dijejali dengan semua fungsi yang diperlukan ke leher.  Di dunia mereka, sebuah pesan harus disampaikan apa pun yang terjadi. </p><br><p>  Pada saat yang sama, ada Redis dan pub / sub-nya - sama dengan orang-orang yang disebutkan di atas, tetapi lebih meragukan: ia hanya dengan bodohnya menerima pesan dan mengirimkannya ke pelanggan, tanpa ada antrian dan biaya tambahan lainnya.  Dia benar-benar tidak peduli dengan pesan itu sendiri, mereka akan menghilang, jika pelanggan hang - dia akan membuangnya dan mengambil yang baru, seolah-olah mereka akan melemparkan poker panas ke tangannya yang ingin Anda singkirkan lebih cepat.  Juga, jika dia tiba-tiba jatuh - semua pesan juga akan tenggelam bersamanya.  Dengan kata lain, tidak ada pertanyaan tentang jaminan pengiriman. </p><br><p>  ... dan inilah yang Anda butuhkan! </p><br><p>  Yah, sungguh, kami hanya mengobrol.  Bukan semacam layanan uang penting atau pusat kendali penerbangan luar angkasa, tapi ... hanya obrolan.  Risiko bahwa Pete bersyarat setahun sekali tidak akan menerima satu pesan dari seribu - itu dapat diabaikan jika sebagai imbalannya kita mendapatkan pertumbuhan produktivitas dan di tempat itu dengan jumlah pengguna untuk hari yang sama, menukarkan semua kejayaannya.  Selain itu, pada saat yang sama, Anda dapat menyimpan riwayat pesan dalam beberapa jenis repositori persisten, yang berarti bahwa Petya masih akan melihat pesan yang terlewat itu dengan memuat ulang halaman / aplikasi.  Itu sebabnya kami akan fokus pada Redis pub / sub, atau lebih tepatnya: lihat adaptor yang ada untuk SocketIO, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disebutkan dalam artikel di kantor.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> </p><br><p>  Jadi apa ini? </p><br><h2 id="redis-adapter">  Adaptor redis </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Dengan bantuannya, aplikasi biasa melalui beberapa baris dan jumlah gerakan minimum berubah menjadi obrolan yang nyata!  Tapi bagaimana caranya?  <a href="">Jika Anda melihat ke dalam</a> - ternyata hanya ada satu file per setengah ratus baris. </p><br><p>  Dalam kasus ketika kami mengeluarkan pesan </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  itu didorong ke lobak, ditransmisikan ke semua contoh lain dari obrolan kami, yang pada gilirannya mengeluarkannya secara lokal di soket </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  Pesan tersebut akan didistribusikan ke semua node bahkan jika kami mengeluarkan ke pengguna tertentu.  Artinya, setiap node menerima semua pesan dan sudah mengerti apakah perlu. </p><br><p>  Juga, ada rpc sederhana (memanggil prosedur jarak jauh), yang memungkinkan tidak hanya mengirim tetapi juga menerima jawaban.  Misalnya, Anda dapat mengontrol soket dari jarak jauh, seperti "siapa yang ada di ruangan yang ditentukan", "memesan soket untuk bergabung dengan ruangan", dll. </p><br><p>  Apa yang bisa dilakukan dengan ini?  Misalnya, gunakan ID pengguna sebagai nama kamar (id pengguna == id kamar).  Saat memberi otorisasi, untuk menghubungkan soket ke dalamnya, dan ketika kami ingin mengirim pesan ke pengguna - cukup helm ke dalamnya.  Juga, kita dapat mengetahui apakah pengguna sedang online, cukup melihat apakah ada soket di ruangan yang ditentukan. </p><br><p>  Pada prinsipnya, kita bisa berhenti di sini, tetapi seperti biasa, itu tidak cukup bagi kita: </p><br><ol><li>  Leher botol dalam satu contoh lobak </li><li>  Redundansi, saya ingin agar node hanya menerima pesan yang mereka butuhkan </li></ol><br><p>  Dengan mengorbankan paragraf satu, lihat hal seperti: </p><br><h2 id="redis-cluster">  Kelompok redis </h2><br><p>  Ini menghubungkan beberapa contoh lobak, setelah itu mereka bekerja secara keseluruhan.  Tetapi bagaimana dia melakukannya?  Ya seperti ini: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... dan kami melihat bahwa pesan tersebut digandakan ke semua anggota kluster.  Artinya, ini tidak dimaksudkan untuk meningkatkan produktivitas, tetapi untuk meningkatkan keandalan, yang tentu saja baik dan perlu, tetapi untuk kasus kami itu tidak memiliki nilai dan tidak menyelamatkan situasi dengan hambatan dengan cara apa pun, ditambah jumlah itu bahkan lebih banyak pemborosan sumber daya. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Saya seorang pemula, saya tidak tahu banyak, kadang-kadang saya harus kembali ke pitchforking, yang akan kita lakukan.  Tidak, biarkan lobak agar tidak tergelincir sama sekali, tetapi Anda perlu memikirkan sesuatu dengan arsitektur karena yang saat ini tidak baik. </p><br><h2 id="povorot-ne-tuda">  Berbelok ke arah yang salah </h2><br><p>  Apa yang kita butuhkan  Tingkatkan throughput keseluruhan.  Sebagai contoh, mari kita coba secara bodoh menelurkan contoh lain.  Bayangkan bahwa socket.io-redis dapat terhubung ke beberapa, ketika mendorong pesan, ia memilih secara acak, dan berlangganan semuanya.  Ternyata seperti ini: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  Secara umum, masalah terpecahkan, lobak tidak lagi menjadi hambatan, Anda dapat menelurkan jumlah salinan!  Tetapi mereka menjadi simpul.  Ya, ya, instance obrolan kami masih mencerna SEMUA pesan, kepada siapa pesan itu tidak dimaksudkan. </p><br><p>  Anda dapat sebaliknya: berlangganan satu secara acak, yang akan mengurangi beban pada node, dan mendorong semuanya: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Kita melihat bahwa itu telah menjadi sebaliknya: node merasa lebih tenang, tetapi beban pada contoh lobak telah meningkat.  Ini juga tidak baik.  Anda perlu sedikit bersepeda. </p><br><p>  Untuk memompa sistem kami, kami akan meninggalkan paket socket.io-redis sendiri, meskipun keren, kami membutuhkan lebih banyak kebebasan.  Jadi, kami menghubungkan lobak: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Siapkan sistem pengiriman pesan kami: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  Saat ini, ternyata seperti di socket.io-redis: kami mendengarkan semua pesan.  Sekarang kita akan memperbaikinya. </p><br><p>  Kami mengatur langganan sebagai berikut: ingat konsep dengan "id pengguna == id kamar", dan ketika pengguna muncul, kami berlangganan saluran dengan nama yang sama di lobak.  Dengan demikian, node kami hanya akan menerima pesan yang ditujukan untuk mereka, dan tidak mendengarkan "seluruh siaran". </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Luar biasa, sekarang kami yakin bahwa node hanya menerima pesan yang ditujukan untuk mereka, tidak lebih!  Perlu dicatat, bagaimanapun, bahwa langganan itu sendiri sekarang jauh, jauh lebih besar, yang berarti bahwa mereka akan memakan memori yoy yoy, + lebih banyak operasi berlangganan / berhenti berlangganan, yang relatif mahal.  Tetapi bagaimanapun juga, ini memberi kami beberapa fleksibilitas, Anda bahkan dapat berhenti pada saat ini dan mengunjungi kembali semua opsi sebelumnya, yang sudah memperhitungkan properti simpul baru kami dalam bentuk pesan penerimaan yang lebih selektif dan murni.  Misalnya, node dapat berlangganan ke salah satu dari beberapa contoh lobak, dan ketika mendorong, mengirim pesan ke semua contoh: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... tetapi, apa pun yang dikatakan orang, mereka masih tidak memberikan perpanjangan yang tak terbatas dengan overhead yang masuk akal, Anda harus melahirkan opsi lain.  Pada satu titik, skema berikut muncul di benak saya: bagaimana jika contoh lobak dibagi menjadi beberapa kelompok, katakanlah A dan B, dua contoh di masing-masing.  Saat berlangganan, node ditandatangani oleh satu instance dari setiap grup, dan ketika mendorong, mereka mengirim pesan ke semua instance dari satu grup acak. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  Dengan demikian, kita mendapatkan struktur operasi dengan potensi ekspansi yang tak terbatas dalam waktu nyata, beban pada simpul individu pada titik mana pun tidak bergantung pada ukuran sistem, karena: </p><br><ol><li>  Total bandwidth dibagi antara grup, yaitu, dengan peningkatan pengguna / aktivitas, kami cukup membandingkan grup tambahan. </li><li>  Manajemen pengguna (langganan) dibagi dalam grup itu sendiri, yaitu ketika meningkatkan pengguna / langganan, kami hanya menambah jumlah instance dalam grup. </li></ol><br><p>  ... dan seperti biasa ada satu "TETAPI": semakin banyak semuanya didapat, semakin banyak sumber daya yang dibutuhkan untuk keuntungan selanjutnya, bagi saya sepertinya trade off terlalu tinggi. </p><br><p>  Secara umum, jika Anda berpikir tentang hal itu, colokan yang disebutkan di atas berasal dari tidak mengetahui pengguna mana yang berada pada simpul mana.  Ya, memang, jika kami memiliki informasi ini, kami dapat mendorong pesan tepat di mana mereka perlu, tanpa duplikasi yang tidak perlu.  Apa yang telah kami coba lakukan selama ini?  Mereka mencoba membuat sistem ini dapat diskalakan tanpa batas, sementara tidak memiliki mekanisme pengalamatan yang jelas, yang pasti akan menemui jalan buntu atau redundansi yang tidak dapat dibenarkan.  Misalnya, Anda dapat mengingat wizard yang bertindak sebagai "buku alamat": </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Sesuatu yang mirip memberitahu pria ini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Untuk mendapatkan lokasi pengguna, kami melakukan perjalanan bolak-balik tambahan, yang pada prinsipnya OK, tetapi tidak dalam kasus kami.  Sepertinya kita menggali ke arah yang salah, kita membutuhkan sesuatu yang lain ... </p><br><h2 id="sila-hesha">  Kekuatan hash </h2><br><p>  Ada yang namanya hash.  Ini memiliki beberapa kisaran nilai yang terbatas.  Anda bisa mendapatkannya dari data apa pun.  Tetapi bagaimana jika Anda membagi rentang ini di antara contoh lobak?  Yah, kami mengambil ID pengguna, menghasilkan hash, dan tergantung pada kisaran di mana ia ternyata berlangganan / mendorong ke satu contoh spesifik.  Artinya, kami tidak tahu sebelumnya di mana pengguna itu ada, tetapi setelah menerimanya, kami dapat dengan yakin mengatakan bahwa itu ada dalam contoh, inf 100. Sekarang hal yang sama, tetapi dengan kode: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Sekarang kita tidak tergantung pada jumlah contoh kata secara umum, kita dapat skala sebanyak yang kita suka tanpa biaya tambahan!  Nah, serius, ini adalah opsi yang brilian, satu-satunya minus adalah kebutuhan untuk me-restart sistem ketika memperbarui jumlah contoh lobak.  Ada yang namanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dering Standar dan cincin Partisi</a> yang memungkinkan Anda untuk mengatasinya, tetapi itu tidak berlaku di sistem pesan.  Ya, Anda bisa membuat logika migrasi langganan di antara instance, tetapi masih membutuhkan tambahan kode dengan ukuran yang tidak bisa dipahami, dan seperti yang kita tahu - semakin banyak kode, semakin banyak bug, kita tidak membutuhkan ini, terima kasih.  Dan dalam kasus kami, downtime merupakan tradeoff yang cukup dapat diterima. </p><br><p>  Anda juga dapat melihat RabbitMQ dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin</a> -nya, yang memungkinkan Anda untuk melakukan hal yang sama seperti yang kami lakukan, dan + menyediakan migrasi langganan (seperti yang saya katakan di atas - itu terkait dengan fungsionalitas dari ujung kepala hingga ujung kaki).  Pada prinsipnya, Anda dapat mengambilnya dan tidur nyenyak, tetapi jika seseorang meraba-raba dalam penyetelannya untuk membawa mode ke waktu nyata, hanya menyisakan fitur dengan cincin hash. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membanjiri repositori di github.</a> </p><br><p>  Ini mengimplementasikan versi final yang telah kami datangi.  Selain itu, ada logika tambahan untuk bekerja dengan kamar (dialog). </p><br><p>  Secara umum, saya puas dan dapat dibulatkan. </p><br><h2 id="itogo">  Total </h2><br><p>  Anda dapat melakukan apa saja, tetapi ada yang namanya sumber daya, dan mereka terbatas, jadi Anda perlu menggeliat. </p><br><p>  Kami mulai dengan ketidaktahuan sepenuhnya tentang bagaimana sistem terdistribusi dapat bekerja pada pola beton yang kurang lebih nyata, dan itu bagus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440546/">https://habr.com/ru/post/id440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440534/index.html">Terjemahan dari kosa kata yang benar secara politis dari bahasa Inggris ke bahasa Rusia</a></li>
<li><a href="../id440536/index.html">Bagaimana Facebook Project Infer membantu menemukan bug dalam aplikasi seluler sebelum penyebaran</a></li>
<li><a href="../id440540/index.html">Kapitalisasi Reddit mencapai $ 3 miliar setelah menarik investasi $ 300 juta</a></li>
<li><a href="../id440542/index.html">Vuex - penggunaan berlebihan getter dalam aplikasi. Kesalahan saat menguraikan</a></li>
<li><a href="../id440544/index.html">Rilis eksperimental Blazor 0.8.0 sekarang tersedia</a></li>
<li><a href="../id440548/index.html">"Anda tidak bisa hanya mengambil dan memaralelkan sumber tegangan"</a></li>
<li><a href="../id440550/index.html">Segitiga warna tidak memiliki dua, tetapi satu sudut</a></li>
<li><a href="../id440552/index.html">Hentikan penutupan dan suntikkan Ketergantungan Injeksi dalam JavaScript</a></li>
<li><a href="../id440554/index.html">BEM yang nyaman</a></li>
<li><a href="../id440556/index.html">Mempelajari Desain Diagram Hubungan Entitas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>