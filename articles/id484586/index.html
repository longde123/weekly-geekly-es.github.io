<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ»â€ğŸ’» ğŸ¦ ğŸšˆ Bekerja dengan IPv6 di PHP ğŸ“ ğŸŒ” ğŸ™‹ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami baru-baru ini menerima status LIR dan / 29 blok IPv6. Dan kemudian ada kebutuhan untuk melacak subnet yang ditunjuk. Dan karena tagihan kami ditu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekerja dengan IPv6 di PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/484586/">  Kami baru-baru ini menerima status LIR dan / 29 blok IPv6.  Dan kemudian ada kebutuhan untuk melacak subnet yang ditunjuk.  Dan karena tagihan kami ditulis dalam PHP, saya harus sedikit terinspirasi oleh masalah ini dan menyadari bahwa bahasa ini bukan yang paling ramah dalam hal bekerja dengan IPv6.  Di bawah cut - solusi kami untuk masalah bekerja dengan alamat dan rentang.  Mungkin bukan yang paling elegan, tetapi melakukan tugas. <br><br><img src="https://habrastorage.org/webt/bk/on/p9/bkonp9-y-sxfdqvirte2ehjunr0.jpeg"><a name="habracut"></a><br><br><h3>  Sedikit teori </h3><br><blockquote>  <b>Penafian.</b>  Jika Anda terbiasa dengan apa itu IPv6 dan apa yang dimakannya, bagian ini mungkin membosankan bagi Anda.  Mungkin tidak. </blockquote><br>  Orang yang pertama kali melihat penjelasan IPv6 mungkin akan kecewa.  Setelah <i>64.233.177.101 yang</i> elegan <i>,</i> kami tiba-tiba menemukan <i>2607: f8b0: 4002: c08 :: 8b</i> dan dapat menjadi bingung.  Baik itu, dan yang lain - hanya representasi yang dapat dibaca manusia masing-masing 32 dan 128 bit.  Paket IP apa pun berisi tajuk dengan tugas terstandarisasi ketat dari setiap bit.  Tanpa masuk lebih jauh ke dalam struktur header, kita perlu mengeluarkan satu hal dari sini: untuk operasi dengan alamat dan rentang IP umumnya lebih mudah menggunakan matematika biner dan operasi bitwise.  Juga paling mudah untuk menyimpannya dalam database sebagai <i>BINARY (4)</i> untuk IPv4 dan <i>BINARY (16)</i> untuk IPv6. <br><br>  Aspek penting lain yang harus diatasi adalah topeng jaringan dan notasi CIDR.  CIDR adalah akronim untuk Routing Antar-Domain Tanpa Kelas.  Konsep ini menggantikan kelas satu dalam pertanyaan menentukan bagian mana dari alamat IP yang merupakan awalan jaringan dan bagian mana yang merupakan alamat antarmuka jaringan dalam jaringan ini.  Dalam prakteknya, n bit pertama yang sesuai dengan awalan akan diatur ke 1, sisanya ke 0. <br><br>  Dalam bentuk yang dapat dibaca manusia, ini ditulis sebagai <i>ip.add.re.ss. / cidr</i> .  Misalnya, <i>64.233.177.0/24</i> berarti 24 bit pertama merujuk pada awalan.  8 bit terakhir, mereka adalah angka terakhir dalam entri yang dapat dibaca manusia, merujuk ke alamat di dalam subnet.  Beberapa lagi latihan.  <i>64.233.177.101/32</i> dan <i>2607: f8b0: 4002: c08 :: 8b / 128</i> - satu alamat spesifik.  <i>2607: f8b0: 4002: c08 :: / 64</i> - 64 bit pertama (4 grup pertama) - awalan, 64 bit yang tersisa - bagian lokal.  Ngomong-ngomong, jika ada yang merasa malu dengan "::" dalam entri, usus besar ganda menggantikan sejumlah bagian yang berisi 0. Secara acak dapat terjadi dalam anotasi hanya 1 kali.  Dengan kata lain, <i>2607: f8b0: 4002: c08 :: 8b = 2607: f8b0: 4002: c08: 0: 0: 0: 8b</i> . <br><br>  Apa yang perlu kita pelajari dari semua ini?  Pertama, alamat subnet pertama dan terakhir dapat diperoleh dengan menggunakan biner AND dan OR, mengetahui mask dalam bentuk biner.  Kedua, subnet ukuran berikutnya (yaitu, dengan CIDR) <b>n</b> dapat dihitung dengan menambahkan 1 ke posisi ke- <b>n</b> dalam representasi biner.  Dengan tampilan biner, maksud saya adalah hasil dari menggunakan <i>paket</i> fungsi <i>()</i> dan <i>inet_pton ()</i> dan penggunaan lebih lanjut dari <a href="https://www.php.net/manual/ru/language.operators.bitwise.php">operator bitwise</a> , oleh biner - representasi dalam sistem biner, yang dapat diperoleh, katakanlah, menggunakan <i>base_convert ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Latar belakang sejarah</b> <div class="spoiler_text"> <s>Segregasi</s> tanpa kelas <s>untuk</s> menangani didahului tanpa kelas.  Pada tahun-tahun yang jauh itu, tidak ada yang mengira bahwa akan ada begitu banyak subnet, mereka didistribusikan ke kanan dan kiri dalam blok besar: kelas A - 8 bit pertama (mis., Angka pertama) diawali, dengan bit 0 terkemuka;  kelas B - 16 pertama (dua angka pertama), bit terkemuka 10;  kelas C - 24 bit pertama, bit terkemuka 110. Bit terkemuka yang sama ini menetapkan rentang di mana alamat kelas dikeluarkan: <i>0.0.0.0 - 127.255.255.255</i> untuk kelas A, <i>128.0.0.0 - 191.255.255.255</i> - kelas B, 192.0 .0.0 - 223.255.255.255 - kelas C. Ketika Internet menyebar ke seluruh planet ini, regulator menyadari bahwa mereka telah ketinggalan, dan pada awal 90-an mengembangkan konsep tanpa kelas, yang memungkinkan mereka untuk tidak terikat pada bit terkemuka.  Sedikit lebih banyak detail dapat ditemukan, katakanlah, dalam yang <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">agung dan maha tahu</a> . </div></div><br><br><h3>  Mari kita lanjutkan berlatih </h3><br>  Dalam praktiknya, kami mengimplementasikan tiga tugas yang paling mungkin, menurut saya, adalah: <br><br><ol><li>  mendapatkan alamat pertama dan terakhir rentang; </li><li>  mendapatkan rentang ukuran tertentu (CIDR) berikutnya; </li><li>  memeriksa apakah alamat tersebut termasuk dalam kisaran. </li></ol><br>  Implementasinya akan untuk IPv6, tetapi jika perlu, logikanya dapat dengan mudah diadaptasi.  Saya mendapat beberapa ide dari <a href="https://intsystem.org/coding/kak-rabotat-s-ipv6-v-php/">sini</a> , tetapi menerapkannya sedikit berbeda.  Juga dalam contoh tidak ada pemeriksaan untuk kesalahan input.  Jadi ayo pergi. <br><br>  Seperti yang saya sebutkan, alamat pertama dan terakhir dari suatu range dapat ditentukan menggunakan operasi bitwise, mengetahui awal dari range dan subnet mask biner.  Dengan demikian, hal pertama yang perlu kita lakukan adalah mengubah CIDR menjadi topeng biner.  Untuk melakukan ini, kumpulkan representasi hex-nya dan kemas dalam biner. <br><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cidrToMask</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cidr)</span></span></span><span class="hljs-function"> </span></span>{ $mask = str_repeat(<span class="hljs-string"><span class="hljs-string">'f'</span></span>, ceil($cidr / <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask .= dechex(<span class="hljs-number"><span class="hljs-number">4</span></span> * ($cidr % <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask = str_pad($mask, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $mask); }</code> </pre> <br>  <i>Paket</i> panggilan <i>('H *', $ mask)</i> mengemas representasi hex dengan cara yang sama seperti <i>inet_pton ()</i> .  Satu-satunya perbedaan adalah ketika <i>paket ()</i> dipanggil, semua 0 harus ada di tempatnya, dan seharusnya tidak ada titik dua dalam entri, tidak seperti entri yang dapat dibaca manusia. <br><br>  Langkah selanjutnya adalah menghitung awal dan akhir rentang.  Dan di sini ada nuansa.  Pengoperasian bitwise dibatasi oleh kapasitas prosesor.  Oleh karena itu, pada CubieTruck 32-bit saya, yang kadang-kadang saya gunakan untuk pengujian yang memanjakan, semua 128 bit alamat tidak dapat diproses dalam satu operasi.  Namun, tidak ada yang mencegah kita dari memecahnya menjadi kelompok 32 bit (untuk berjaga-jaga, siapa yang tahu prosesor apa yang akan kita jalankan). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeBoundary</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $cidr, $which, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ $mask = cidrToMask($cidr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ip = inet_pton($ip); } $ipParts = str_split($ip, <span class="hljs-number"><span class="hljs-number">4</span></span>); $maskParts = str_split($mask, <span class="hljs-number"><span class="hljs-number">4</span></span>); $rangeParts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; count($ipParts); $i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($which == <span class="hljs-string"><span class="hljs-string">'start'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  &amp;       . */</span></span> $rangeParts[$i] = $ipParts[$i] &amp; $maskParts[$i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*  |    (~)           1. */</span></span> $rangeParts[$i] = $ipParts[$i] | ~$maskParts[$i]; } } $rangeBoundary = implode($rangeParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rangeBoundary; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($rangeBoundary); } }</code> </pre> <br>  Untuk penggunaan di masa mendatang, kami akan memberikan kemampuan untuk mengirimkan IP dan mendapatkan hasilnya dalam bentuk biner dan dalam bentuk yang dapat dibaca manusia.  Parameter <i>$ which di</i> sini menetapkan apakah kita ingin mendapatkan awal atau akhir kisaran (nilainya masing-masing adalah <i>'mulai'</i> atau <i>'akhir'</i> ). <br><br>  Tugas selanjutnya (selain yang paling praktis untuk perusahaan kami) adalah menghitung rentang berikutnya.  Untuk tugas ini, tidak ada yang lebih baik terlintas dalam pikiran, kecuali bagaimana menguraikan alamat menjadi string biner dan menambahkan 1 pada posisi yang diinginkan, kemudian runtuhkan semuanya kembali.  Untuk mencegah artefak muncul di mana saja, saya memutuskan untuk membagi alamat dengan byte selama dekomposisi dan perakitan. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ipStart, $cidr, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ipStart = inet_pton($ipStart); } $ipParts = str_split($ipStart, <span class="hljs-number"><span class="hljs-number">1</span></span>); $ipBin = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $ipPart) { $ipBin .= str_pad(base_convert(unpack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $ipPart)[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT); } <span class="hljs-comment"><span class="hljs-comment">/*  1       "" :) */</span></span> $i = $cidr - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($ipBin[$i] == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'0'</span></span>; } $i--; } $ipBinParts = str_split($ipBin, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipBinParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $ipBinPart) { $ipParts[$key] = pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, str_pad(base_convert($ipBinPart, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT)); } $nextIp = implode($ipParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $nextIp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($nextIp); } }</code> </pre> <br>  Pada output, kita mendapatkan awalan kisaran ukuran berikutnya yang ditentukan dalam <i>$ cidr</i> .  Dengan fungsi ini, kami mengalokasikan blok alamat ke pelanggan kami. <br><br>  Terakhir, periksa apakah alamat tersebut termasuk dalam kisaran tersebut.  Sebagai contoh, kami mengalokasikan satu / 48 blok untuk distribusi / 64 blok kepada pelanggan, dan kami perlu memastikan bahwa selama penunjukan kami tidak melampaui blok yang dialokasikan (dalam praktiknya ini akan segera terjadi, tetapi masih ada peluang).  Semuanya sederhana di sini.  Kami mendapatkan awal dan akhir rentang dalam bentuk biner dan memeriksa apakah alamatnya ada di dalam. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ipInRange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $rangeStart, $cidr)</span></span></span><span class="hljs-function"> </span></span>{ $start = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'start'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $end = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'end'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $ipBin = inet_pton($ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($ipBin &gt;= $start &amp;&amp; $ipBin &lt;= $end); }</code> </pre> <br>  Semoga bermanfaat.  Apa fitur pengalamatan lain yang menurut Anda berguna?  Setiap penambahan, komentar, dan ulasan kode disambut dengan hangat di komentar. <br><br>  Jika Anda sudah menjadi klien kami atau hanya berpikir untuk menjadi satu, pada kesempatan rilis artikel ini, kami sarankan Anda mendapatkan blok / 64 secara gratis untuk semua layanan vps atau server khusus di pusat data Equinix Tier IV, Belanda, atas permintaan ke departemen penjualan, dengan memberikan tautan ke artikel ini di tiket.  Penawaran ini berlaku hingga Maret 2020. <br><br><h3>  Sedikit iklan :) </h3><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikan kepada teman Anda, <a href="https://ua-hosting.company/cloudvps/nl">VPS berbasis cloud untuk pengembang mulai $ 4,99</a> , <b>analog unik dari server entry-level yang diciptakan oleh kami untuk Anda:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">Seluruh kebenaran tentang VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps mulai dari $ 19 atau cara membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah di pusat data Equinix Tier IV di Amsterdam?</b>  Hanya kami yang memiliki <b><a href="https://ua-hosting.company/serversnl">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</a> di Belanda!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99!</b></b>  Baca tentang <a href="https://habr.com/company/ua-hosting/blog/329618/">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484586/">https://habr.com/ru/post/id484586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484574/index.html">Tidak ada kutu! Vektor Penyakit Tanaman vs Lyme</a></li>
<li><a href="../id484578/index.html">Tujuan Tingkat Layanan - Pengalaman Google (Terjemahan Bab Buku Google SRE)</a></li>
<li><a href="../id484580/index.html">Apa yang perlu Anda ketahui tentang simulator untuk memori</a></li>
<li><a href="../id484582/index.html">ASP.NET MVC - Kerangka Entitas, MySQL dan menggunakan Dependency Resolver untuk memilih repositori</a></li>
<li><a href="../id484584/index.html">Mengapa kita memerlukan manajer dalam proyek TI dan apa yang akan terjadi ketika tidak</a></li>
<li><a href="../id484588/index.html">Model manajemen program otomatis</a></li>
<li><a href="../id484590/index.html">Sehingga anak laki-laki tidak malu untuk menunjukkan</a></li>
<li><a href="../id484592/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 398 (13-19 Januari 2020)</a></li>
<li><a href="../id484596/index.html">Toko Online Sisi Klien Blazor: Bagian 1 - Oidc otorisasi (oauth2) + Server Identitas4</a></li>
<li><a href="../id484600/index.html">Microsoft Menyalakan Konferensi Teknis Tur Praha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>