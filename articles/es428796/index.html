<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì§ üóØÔ∏è üë®üèæ‚ÄçüöÄ Manipulaci√≥n en tiempo real de mallas en la unidad üë©üèº‚Äçüíª üë®üèø‚Äçüîß üëê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una de las ventajas de Unity como plataforma para el desarrollo de juegos es su potente motor 3D. En este tutorial, aprender√° sobre el mundo de los ob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manipulaci√≥n en tiempo real de mallas en la unidad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428796/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif" alt="imagen"></div><br>  Una de las ventajas de Unity como plataforma para el desarrollo de juegos es su potente motor 3D.  En este tutorial, aprender√° sobre el mundo de los objetos 3D y la manipulaci√≥n de mallas. <br><br>  Debido al crecimiento de las tecnolog√≠as de realidad virtual y aumentada (VR / AR), la mayor√≠a de los desarrolladores se enfrentan a conceptos complejos de gr√°ficos en 3D.  Deje que este tutorial sea el punto de partida para ellos.  No se preocupe, no habr√° matem√°ticas 3D complicadas, ¬°solo corazones, dibujos, flechas y muchas cosas interesantes! <br><a name="habracut"></a><br><blockquote>  <em>Nota:</em> este tutorial est√° dirigido a usuarios que est√°n familiarizados con Unity IDE y tienen experiencia en programaci√≥n en C #.  Si no tiene ese conocimiento, primero estudie los tutoriales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Introducci√≥n a la interfaz de usuario de Unity</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Introducci√≥n a las secuencias de comandos de Unity</a> . <br><br>  Necesitar√° una versi√≥n de Unity no inferior a 2017.3.1.  La √∫ltima versi√≥n de Unity se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">aqu√≠</a> .  Este tutorial utiliza un editor personalizado, y puede obtener m√°s informaci√≥n sobre ellos en el tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Extending the Unity Editor</a> . </blockquote><br><h2>  Llegar al trabajo </h2><br>  Para comenzar, familiar√≠cese con los t√©rminos b√°sicos de los gr√°ficos en 3D, que le permitir√°n comprender mejor el tutorial. <br><br>  T√©rminos t√©cnicos b√°sicos de gr√°ficos 3D: <br><br><ul><li>  <em>V√©rtices</em> : cada v√©rtice es un punto en el espacio 3D. </li><li>  <em>Malla</em> : contiene todos los v√©rtices, bordes, tri√°ngulos, normales y datos UV del modelo. </li><li>  <em>Filtro de malla</em> : almacena datos de malla del modelo. </li><li>  Renderizador de malla: renderiza los datos de malla en la escena. </li><li>  <em>Normales</em> : el vector de un v√©rtice o superficie.  Se dirige hacia afuera, perpendicular a la superficie de la malla. </li><li>  <em>L√≠neas / bordes</em> : l√≠neas invisibles que conectan v√©rtices entre s√≠. </li><li>  <em>Tri√°ngulos</em> : formados conectando tres picos. </li><li>  <em>Mapa UV</em> : adjunta material a un objeto, creando una textura y color para √©l. </li></ul><br>  La anatom√≠a de un objeto 3D comienza con su malla.  La creaci√≥n de esta malla comienza en su parte superior.  Las l√≠neas invisibles que conectan estos v√©rtices forman tri√°ngulos que definen la forma b√°sica del objeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/83a/4c2/5a783a4c2ed2c144ccd0d7eb97369370.gif"></div><br>  Luego, los datos normales y UV establecen el sombreado, el color y la textura.  Los datos de malla se almacenan en un filtro de malla, y el renderizador de malla usa estos datos para dibujar un objeto en la escena. <br><br>  Es decir, el pseudoc√≥digo para crear un modelo 3D se ve as√≠: <br><br><ul><li>  Cree una nueva malla llamada "myMesh". </li><li>  Agregue datos a las propiedades de los v√©rtices y tri√°ngulos myMesh. </li><li>  Cree un nuevo filtro de malla llamado "myMeshFilter". </li><li>  Establezca la propiedad de malla myMeshFilter en myMesh. </li></ul><br>  Una vez que haya dominado los conceptos b√°sicos, descargue el <a href="">proyecto</a> , descomprima los archivos y ejecute la pieza de trabajo del proyecto en Unity.  Mire la estructura de carpetas en la ventana <em>Proyecto</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/690/2d6/c2e/6902d6c2e14a98284c8af39055242bc7.png"></div><br>  Descripci√≥n de carpetas: <br><br><ul><li>  <em>Prefabricados</em> : contiene el prefabricado Esfera que se usar√° para guardar la malla 3D durante la ejecuci√≥n de la aplicaci√≥n. </li><li>  <em>Escenas</em> : contiene las tres escenas que usamos en este tutorial. </li><li>  <em>Editor</em> : los scripts dentro de esta carpeta nos brindan las s√∫per caracter√≠sticas en el editor que usamos en el desarrollo. </li><li>  <em>Scripts</em> : aqu√≠ est√°n los scripts en tiempo de ejecuci√≥n que se adjuntan al GameObject y se ejecutan al hacer clic en <em>Reproducir</em> . </li><li>  <em>Materiales</em> : esta carpeta contiene el material para la malla. </li></ul><br>  En la siguiente secci√≥n, crearemos un editor personalizado para visualizar la creaci√≥n de una malla 3D. <br><br><h2>  Cambiar mallas con el editor personalizado </h2><br>  Abra el <em>01 Mesh Study Demo</em> ubicado en la carpeta <em>Scenes</em> .  En la ventana <em>Escena</em> , ver√° un cubo 3D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/ed2/812/6d5ed28123a0c65bb083c67efab702c7.gif"></div><br>  Antes de entrar en la malla, echemos un vistazo al script del editor personalizado. <br><br><h3>  Editar un gui√≥n de editor </h3><br>  Seleccione la carpeta <em>Editor</em> en la ventana <em>Proyecto</em> .  Los scripts en esta carpeta agregan funcionalidad al editor (Editor) durante el desarrollo y no est√°n disponibles en el modo Build. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/442/653/b41/442653b41ca755b67d3a1ce42ae1ec5a.png"></div><br>  Abra <em>MeshInspector.cs</em> y vea el c√≥digo fuente.  Todos los scripts del Editor deben implementar la clase <code>Editor</code> , su atributo <code>CustomEditor</code> le dice a la clase <code>Editor</code> qu√© tipo de objeto es.  <code>OnSceneGUI()</code> es un m√©todo de evento que permite renderizar en la ventana de escena;  <code>OnInspectorGUI()</code> permite agregar elementos GUI adicionales al Inspector. <br><br>  En <em>MeshInspector.cs,</em> antes de iniciar la clase <code>MeshInspector</code> agregue lo siguiente: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(MeshStudy))</span></span>]</code> </pre> <br>  Explicaci√≥n del c√≥digo: El atributo <code>CustomEditor</code> le dice a Unity qu√© tipo de objeto puede modificar la clase del editor personalizado. <br><br>  En <code>OnSceneGUI()</code> antes de <code>EditMesh()</code> agregue lo siguiente: <br><br><pre> <code class="cs hljs">mesh = target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MeshStudy; Debug.Log(<span class="hljs-string"><span class="hljs-string">"Custom editor is running"</span></span>);</code> </pre> <br>  Explicaci√≥n del c√≥digo: la clase <code>Editor</code> tiene una variable <code>target</code> est√°ndar.  Aqu√≠, el <code>target</code> es una conversi√≥n a <code>MeshStudy</code> .  Ahora, el editor personalizado dibujar√° todos los GameObjects en la ventana Scene y <em>MeshStudy.cs</em> adjuntos.  Agregar mensajes de depuraci√≥n le permite verificar en la consola que el editor personalizado se est√° ejecutando realmente. <br><br>  Guarde el archivo y regrese a Unity.  Vaya a la carpeta <em>Scripts</em> y arrastre <em>MeshStudy.cs</em> al GameObject <em>Cube</em> en la <em>Jerarqu√≠a</em> para adjuntarlo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa6/b8a/ee4/aa6b8aee48eacb8421eff3c4e1ef4be3.png"></div><br>  Ahora deber√≠a aparecer el mensaje "El editor personalizado se est√° ejecutando" en la consola, ¬°y esto significa que hicimos todo bien!  Puede eliminar el mensaje de depuraci√≥n para que no nos moleste en la consola. <br><br><h3>  Clonando y tirando la malla </h3><br>  Cuando trabaje con una malla 3D en modo Edici√≥n usando el editor personalizado, tenga cuidado de no sobrescribir la malla predeterminada de Unity.  Si esto sucede, deber√° reiniciar Unity. <br><br>  Para clonar de forma segura la malla sin sobrescribir el formulario original, cree una copia de la malla desde la propiedad <code>MeshFilter.sharedmesh</code> y as√≠gnela nuevamente al filtro de malla. <br><br>  Para hacer esto, haga doble clic en <em>MeshStudy.cs</em> en la carpeta <em>Scripts</em> para abrir el archivo en el editor de c√≥digo.  Este script hereda de la clase <code>MonoBehaviour</code> , y su funci√≥n <code>Start()</code> no se ejecuta en modo Editar. <br><br>  En <em>MeshStudy.cs,</em> antes de iniciar la clase <code>MeshStudy</code> agregue lo siguiente: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>]</code> </pre> <br>  Explicaci√≥n del c√≥digo: despu√©s de agregar este atributo, la funci√≥n <code>Start()</code> se ejecutar√° tanto en modo Play como en modo Edit.  Ahora podemos primero instanciar el objeto de malla y clonarlo. <br><br>  En <code>InitMesh()</code> agregue el siguiente c√≥digo: <br><br><pre> <code class="cs hljs">oMeshFilter = GetComponent&lt;MeshFilter&gt;(); oMesh = oMeshFilter.sharedMesh; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh = new Mesh(); //2 cMesh.name = "clone"; cMesh.vertices = oMesh.vertices; cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; isCloned = true; Debug.Log("Init &amp; Cloned");</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Obtiene la malla <code>oMesh</code> original del componente <code>MeshFilter</code> . </li><li>  Copia <code>cMesh</code> a una nueva <code>cMesh</code> malla. </li><li>  Asigna el filtro de malla de malla copiado nuevamente. </li><li>  Actualiza variables locales. </li></ol><br>  Guarde el archivo y regrese a Unity.  El mensaje "Init &amp; Cloned" deber√≠a mostrarse en la consola de depuraci√≥n.  Seleccione el <code>Cube</code> GameObject en la <em>Jerarqu√≠a</em> y verifique sus propiedades en el <em>Inspector</em> .  <em>El filtro de malla</em> deber√≠a mostrar un elemento de malla llamado <em>clon</em> .  Genial  Esto significa que hemos clonado con √©xito la malla. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/2da/3e0/c6c2da3e0e29703888bad5e50bb608a6.png"></div><br>  En la carpeta Editor, navegue hasta <em>MeshInspector.cs</em> .  En <code>OnInspectorGUI()</code> , despu√©s de la segunda l√≠nea de c√≥digo, agregue lo siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Reset"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.Reset(); //2 }</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Este c√≥digo dibuja un bot√≥n Restablecer en el <em>Inspector</em> . </li><li>  Cuando se presiona, llama a la funci√≥n <code>Reset()</code> en <em>MeshStudy.cs</em> . </li></ol><br>  Guarde el archivo, abra <em>MeshStudy.cs</em> y agregue el siguiente c√≥digo a la funci√≥n <code>Reset()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; oMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1 { cMesh.vertices = oMesh.vertices; //2 cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; }</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Verificaci√≥n de la existencia de la fuente y la malla clonada. </li><li>  Restablezca <code>cMesh</code> a la malla original. </li><li>  Asignaci√≥n a <code>cMesh</code> <code>oMeshFilter</code> . </li><li>  Actualizaci√≥n de variables locales. </li></ol><br>  Guarde el archivo y regrese a Unity.  En el <em>Inspector,</em> haga clic en el bot√≥n <em>Editar prueba</em> para distorsionar la malla del cubo.  Luego, haga clic en el bot√≥n <em>Restablecer</em> ;  el cubo debe volver a su forma original. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c3/a8a/e22/0c3a8ae22c8f8382dd46ee652b4b6eea.gif"></div><br><h3>  Explicaci√≥n de v√©rtices y tri√°ngulos en Unity </h3><br>  Una malla consiste en v√©rtices conectados por bordes en tri√°ngulos.  Los tri√°ngulos definen la forma b√°sica del objeto. <br><br><blockquote>  <em>Clase de malla:</em> <br><br><ul><li>  Los v√©rtices se almacenan como una matriz de valores de <code>Vector3</code> . </li><li>  Los tri√°ngulos se almacenan como una matriz entera correspondiente a los √≠ndices de la matriz de v√©rtices. </li></ul><br>  Es decir, en una malla cu√°druple simple, que consta de cuatro v√©rtices y dos tri√°ngulos, los datos de la malla se ver√°n as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/56d/794/56c56d794628ff20592f801340308790.gif"></div></blockquote><br><h3>  Mapeo de v√©rtices </h3><br>  Aqu√≠ queremos mostrar los v√©rtices del cubo como puntos azules. <br><br>  En <em>MeshInspector.cs</em> entraremos en la funci√≥n <code>EditMesh()</code> y agregaremos lo siguiente: <br><br><pre> <code class="cs hljs">handleTransform = mesh.transform; <span class="hljs-comment"><span class="hljs-comment">//1 handleRotation = Tools.pivotRotation == PivotRotation.Local ? handleTransform.rotation : Quaternion.identity; //2 for (int i = 0; i &lt; mesh.vertices.Length; i++) //3 { ShowPoint(i); }</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  <code>handleTransform</code> obtiene valores de transformaci√≥n de la <code>mesh</code> . </li><li>  <code>handleRotation</code> obtiene el modo de rotaci√≥n de la uni√≥n actual. </li><li>  Atraviese los v√©rtices de la malla y dibuje los puntos con <code>ShowPoint()</code> . </li></ol><br>  En la funci√≥n <code>ShowPoint()</code> , inmediatamente despu√©s del comentario <code>//draw dot</code> , agregue lo siguiente: <br><br><pre> <code class="cs hljs">Vector3 point = handleTransform.TransformPoint(mesh.vertices[index]);</code> </pre> <br>  Explicaci√≥n del c√≥digo: esta l√≠nea convierte la posici√≥n local del v√©rtice en una coordenada en el espacio mundial. <br><br>  En la misma funci√≥n, en el bloque <code>if</code> , inmediatamente despu√©s de la l√≠nea de c√≥digo reci√©n agregada, agregue lo siguiente: <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; point = Handles.FreeMoveHandle(point, handleRotation, mesh.handleSize, Vector3.zero, Handles.DotHandleCap);</code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Establece el color, el tama√±o y la posici√≥n de un punto utilizando la clase de ayuda <code>Handles</code> . </li><li>  <code>Handles.FreeMoveHandle()</code> crea un manipulador de movimiento ilimitado que simplifica la operaci√≥n de arrastrar y soltar, lo cual es √∫til para nosotros en la siguiente secci√≥n. </li></ol><br>  Guarde el archivo y regrese a Unity.  Verifique la propiedad del cubo en el <em>Inspector</em> y aseg√∫rese de que la opci√≥n <em>Mover punto de v√©rtice</em> est√© habilitada.  Ahora deber√≠a ver que la malla en la pantalla est√° marcada con varios puntos azules.  Aqu√≠ est√°n: ¬°la parte superior de la malla del cubo!  Intente hacer esto con otros objetos 3D y observe los resultados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/3aa/205/d783aa2054dd9ca81ee7a6c948c7c00a.gif"></div><br><h3>  Mueve un solo v√©rtice </h3><br>  Comencemos con el paso m√°s simple de manipular la malla: mover un solo v√©rtice. <br><br>  Vaya a <em>MeshInspector.cs</em> .  Dentro de la funci√≥n <code>ShowPoint()</code> , inmediatamente despu√©s del comentario <code>//drag</code> y justo antes de los corchetes de cierre del bloque <code>if</code> , agregue lo siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUI.changed) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.DoAction(index, handleTransform.InverseTransformPoint(point)); //2 }</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  <code>GUI.changed</code> realiza un seguimiento de todos los cambios que ocurren con los puntos, y funciona bien junto con <code>Handles.FreeMoveHandle()</code> para reconocer una operaci√≥n de arrastrar y soltar. </li><li>  Para el v√©rtice arrastrable, la funci√≥n <code>mesh.DoAction()</code> recibe sus valores de √≠ndice y transformaci√≥n como par√°metros.  Dado que los valores de transformaci√≥n del v√©rtice est√°n en el espacio mundial, los convertimos al espacio local usando <code>InverseTransformPoint()</code> . </li></ol><br>  Guarde el archivo de script y vaya a <em>MeshStudy.cs</em> .  En <code>DoAction()</code> , despu√©s de los corchetes de apertura, agregue lo siguiente: <br><br><pre> <code class="cs hljs">PullOneVertex(index, localPos);</code> </pre> <br>  Luego agregue lo siguiente a la funci√≥n <code>PullOneVertex()</code> : <br><br><pre> <code class="cs hljs">vertices[index] = newPos; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh.vertices = vertices; //2 cMesh.RecalculateNormals(); //3</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Actualizamos el v√©rtice objetivo con el valor <code>newPos</code> . </li><li>  <code>cMesh.vertices</code> valores de v√©rtice actualizados nuevamente a <code>cMesh.vertices</code> . </li><li>  En <code>RecalculateNormals()</code> recalculamos y redibujamos la malla para que coincida con los cambios. </li></ol><br>  Guarde el archivo y regrese a Unity.  Intenta arrastrar puntos en el cubo;  viste una malla rota? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fca/ccf/c86/fcaccfc865e30b3c922e6cabcf9f79d7.gif"></div><br>  Parece que algunos de los v√©rtices tienen la misma posici√≥n, por lo que cuando arrastramos solo uno, los v√©rtices restantes permanecen detr√°s de √©l y la malla se rompe.  En la siguiente secci√≥n, solucionaremos este problema. <br><br><h3>  Encontrar todos los v√©rtices similares </h3><br>  Visualmente, una malla de cubo consta de ocho v√©rtices, seis lados y 12 tri√°ngulos.  Vamos a ver si esto es as√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/a30/b3f/253a30b3fcca7b0d9028d92b4c4149c2.gif"></div><br>  Abra <em>MeshStudy.cs</em> , eche un vistazo al frente de la funci√≥n <code>Start()</code> y encuentre la variable de <code>vertices</code> .  Veremos lo siguiente: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices;</code> </pre> <br>  Explicaci√≥n del c√≥digo: <code>[HideInInspector]</code> oculta una variable compartida de la ventana del <em>Inspector</em> . <br><br>  Comente este atributo: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//[HideInInspector] public Vector3[] vertices;</span></span></code> </pre> <br><blockquote>  <em>Nota:</em> ocultar valores de v√©rtice ayuda <code>[HideInInspector]</code> con mallas 3D m√°s complejas.  Dado que el tama√±o de la matriz de v√©rtices puede alcanzar miles de elementos, esto puede conducir a la inhibici√≥n de Unity al intentar ver el valor de la matriz en el Inspector. </blockquote><br>  Guarde el archivo y regrese a Unity.  Ve al <em>inspector</em> .  Ahora, bajo el componente de script <em>Mesh Study</em> , ha aparecido la propiedad de <em>v√©rtices</em> .  Haga clic en el √≠cono de flecha al lado;  entonces <code>Vector3</code> matriz de elementos <code>Vector3</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/feb/f83/fd0/febf83fd02d469734b73910b1769d670.gif"></div><br>  ¬°Puedes ver que el tama√±o de la matriz es 24, es decir, hay v√©rtices que tienen la misma posici√≥n!  Antes de continuar, aseg√∫rese de descomentar <code>[HideInInspector]</code> . <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© hay 24 v√©rtices?</b> <div class="spoiler_text">  Hay muchas teor√≠as sobre este tema.  Pero la respuesta m√°s simple es: el cubo tiene seis lados, y cada lado est√° compuesto por cuatro v√©rtices que forman un plano. <br><br>  Por lo tanto, el c√°lculo es el siguiente: 6 x 4 = 24 v√©rtices. <br><br>  Puedes buscar otras respuestas.  Pero por ahora, es lo suficientemente simple como para saber que algunas mallas tendr√°n v√©rtices que tienen la misma posici√≥n. </div></div><br>  En <em>MeshStudy.cs,</em> reemplace <em>todo el</em> c√≥digo dentro de la funci√≥n <code>DoAction()</code> con lo siguiente: <br><br><pre> <code class="cs hljs">PullSimilarVertices(index, localPos);</code> </pre> <br>  Vayamos a la funci√≥n <code>PullSimilarVertices()</code> y agreguemos lo siguiente: <br><br><pre> <code class="cs hljs">Vector3 targetVertexPos = vertices[index]; <span class="hljs-comment"><span class="hljs-comment">//1 List&lt;int&gt; relatedVertices = FindRelatedVertices(targetVertexPos, false); //2 foreach (int i in relatedVertices) //3 { vertices[i] = newPos; } cMesh.vertices = vertices; //4 cMesh.RecalculateNormals();</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  obtenemos la posici√≥n del v√©rtice objetivo, que se usar√° como argumento para el m√©todo <code>FindRelatedVertices()</code> . </li><li>  Este m√©todo devuelve una lista de √≠ndices (correspondientes a v√©rtices) que tienen la misma posici√≥n que el v√©rtice objetivo. </li><li>  El bucle atraviesa la lista completa y establece los v√©rtices correspondientes en <code>newPos</code> . </li><li>  <code>cMesh.vertices</code> <code>vertices</code> actualizados de nuevo a <code>cMesh.vertices</code> .  Luego llamamos a <code>RecalculateNormals()</code> para volver a dibujar la malla con los nuevos valores. </li></ol><br>  Guarde el archivo y regrese a Unity.  Arrastra cualquiera de los v√©rtices;  ahora la malla debe conservar su forma y no colapsar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/66d/bcc/b1b66dbccb73ac3a8ad8c56594611919.gif"></div><br>  Ahora que hemos completado el primer paso para manipular las mallas, guarde la escena y pase a la siguiente secci√≥n. <br><br><h2>  Manipulaci√≥n de malla </h2><br>  En esta secci√≥n, aprender√° a manipular mallas en tiempo real.  Hay muchas formas, pero en este tutorial veremos el tipo m√°s simple de manipulaci√≥n de malla, es decir, mover los v√©rtices de malla creados previamente. <br><br><h3>  Recopilar √≠ndices seleccionados </h3><br>  Comencemos seleccionando los v√©rtices que moveremos en tiempo real. <br><br>  Abra Scene <em>02 Create Heart Mesh</em> desde la carpeta <em>Scenes</em> .  En la ventana de escena, ver√° una esfera roja.  Seleccione <em>Esfera</em> en la <em>Jerarqu√≠a</em> y vaya al <em>Inspector</em> .  Ver√° que el componente de script <em>Heart Mesh</em> est√° conectado al objeto. <br><br>  Ahora necesitamos la secuencia de comandos del Editor para que este objeto muestre los v√©rtices de la malla en la ventana Escena.  Vaya a la carpeta <em>Editor</em> y haga doble clic en <em>HeartMeshInspector.cs</em> . <br><br>  En la funci√≥n <code>ShowHandle()</code> , dentro del bloque <code>if</code> , agregue lo siguiente: <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Handles.Button(point, handleRotation, mesh.pickSize, mesh.pickSize, Handles.DotHandleCap)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.selectedIndices.Add(index); //2 }</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Establece y muestra los v√©rtices de la malla como un tipo <code>Handles.Button</code> . </li><li>  Cuando se hace clic, agrega el √≠ndice seleccionado a la <code>mesh.selectedIndices</code> presionada, <code>mesh.selectedIndices</code> . </li></ol><br>  En <code>OnInspectorGUI()</code> , antes del corchete de cierre, agregue lo siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Clear Selected Vertices"</span></span>)) { mesh.ClearAllData(); }</code> </pre> <br>  Explicaci√≥n del c√≥digo: as√≠ es como agregamos un bot√≥n Restablecer al <em>Inspector</em> para llamar a <code>mesh.ClearAllData()</code> . <br><br>  Guarde el archivo y abra <em>HeartMesh.cs</em> desde la carpeta <em>Scripts</em> .  En la funci√≥n <code>ClearAllData()</code> , agregue lo siguiente: <br><br><pre> <code class="cs hljs">selectedIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); targetIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; targetVertex = Vector3.zero;</code> </pre> <br>  Explicaci√≥n del c√≥digo: el c√≥digo borra los valores en <code>selectedIndices</code> <code>targetIndex</code> <code>selectedIndices</code> y el <code>targetIndex</code> .  Tambi√©n restablece <code>targetVertex</code> . <br><br>  Guarde el archivo y regrese a Unity.  Seleccione <em>Esfera</em> y vaya al <em>Inspector</em> para el <em>componente de</em> script <em>HeartMesh</em> .  Expanda los <em>√çndices seleccionados</em> haciendo clic en el icono de flecha al lado.  Esto nos permitir√° rastrear cada v√©rtice agregado a la lista. <br><br>  Habilite el <em>modo de edici√≥n</em> con la casilla de verificaci√≥n junto a √©l.  Debido a esto, los v√©rtices de la malla se dibujar√°n en la ventana de escena.  Al hacer clic en los puntos azules en los <em>√çndices seleccionados</em> , los valores deber√≠an cambiar en consecuencia.  Pruebe tambi√©n el bot√≥n <em>Borrar v√©rtices seleccionados</em> para asegurarse de que borra todos los valores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17a/271/dea/17a271dea970e9c3ade451773b87eb65.gif"></div><br>  <em>Nota:</em> en el <em>Inspector</em> personalizado modificado, tenemos la opci√≥n de mostrar / ocultar el manipulador de transformaci√≥n utilizando <em>Mostrar controlador de transformaci√≥n</em> .  ¬°No se asuste si no encuentra el manipulador Transformar en otras escenas!  Enci√©ndelo antes de salir. <br><br><h3>  Convertir una esfera en un coraz√≥n </h3><br>  Cambiar los v√©rtices de malla en tiempo real consiste esencialmente en tres pasos: <br><br><ol><li>  Copie los v√©rtices de malla actuales (antes de la animaci√≥n) en <code>mVertices</code> . </li><li>  <code>mVertices</code> c√°lculos y cambiamos los valores en <code>mVertices</code> . </li><li>  Actualice los v√©rtices de malla actuales con <code>mVertices</code> cuando cambie en cada paso y permita que Unity calcule autom√°ticamente las normales. </li></ol><br>  Abra <em>HeartMesh.cs</em> y las siguientes variables antes de la funci√≥n <code>Start()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radiusofeffect = <span class="hljs-number"><span class="hljs-number">0.3f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 public float pullvalue = 0.3f; //2 public float duration = 1.2f; //3 int currentIndex = 0; //4 bool isAnimate = false; float starttime = 0f; float runtime = 0f;</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  El radio del √°rea afectada por el v√©rtice objetivo. </li><li>  Fuerza de arrastre </li><li>  La duraci√≥n de la animaci√≥n. </li><li>  El √≠ndice actual de la lista de <code>selectedIndices</code> . </li></ol><br>  En la funci√≥n <code>Init()</code> , antes del bloque <code>if</code> , agregue lo siguiente: <br><br><pre> <code class="cs hljs">currentIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Explicaci√≥n del c√≥digo: al comienzo del juego, <code>currentIndex</code> en 0, el primer √≠ndice de la lista de <code>currentIndex</code> <code>selectedIndices</code> . <br><br>  En la misma funci√≥n <code>Init()</code> , antes del corchete de cierre del bloque <code>else</code> , agregue lo siguiente: <br><br><pre> <code class="cs hljs">StartDisplacement();</code> </pre> <br>  Explicaci√≥n del c√≥digo: ejecute la funci√≥n <code>StartDisplacement()</code> si <code>isEditMode</code> es falso. <br><br>  Dentro de la funci√≥n <code>StartDisplacement()</code> , agregue lo siguiente: <br><br><pre> <code class="cs hljs">targetVertex = oVertices[selectedIndices[currentIndex]]; <span class="hljs-comment"><span class="hljs-comment">//1 starttime = Time.time; //2 isAnimate = true;</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Seleccione <code>targetVertex</code> para comenzar la animaci√≥n. </li><li>  Establezca la hora de inicio y cambie el valor de <code>isAnimate</code> a verdadero. </li></ol><br>  Despu√©s de la funci√≥n <code>StartDisplacement()</code> , cree la funci√≥n <code>FixedUpdate()</code> con el siguiente c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//1 { if (!isAnimate) //2 { return; } runtime = Time.time - starttime; //3 if (runtime &lt; duration) //4 { Vector3 targetVertexPos = oFilter.transform.InverseTransformPoint(targetVertex); DisplaceVertices(targetVertexPos, pullvalue, radiusofeffect); } else //5 { currentIndex++; if (currentIndex &lt; selectedIndices.Count) //6 { StartDisplacement(); } else //7 { oMesh = GetComponent&lt;MeshFilter&gt;().mesh; isAnimate = false; isMeshReady = true; } } }</span></span></span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  La funci√≥n <code>FixedUpdate()</code> se ejecuta en un bucle FPS fijo. </li><li>  Si <code>isAnimate</code> es falso, omita el siguiente c√≥digo. </li><li>  Cambiar animaciones de <code>runtime</code> . </li><li>  Si el <code>runtime</code> est√° dentro de la <code>duration</code> , obtenemos las coordenadas mundiales de <code>targetVertex</code> y <code>DisplaceVertices()</code> , cubriendo el v√©rtice objetivo con los <code>radiusofeffect</code> <code>pullvalue</code> y <code>radiusofeffect</code> . </li><li>  De lo contrario, se acab√≥ el tiempo.  Agregue uno a <code>currentIndex</code> . </li><li>  Compruebe si <code>currentIndex</code> entre los <code>currentIndex</code> <code>selectedIndices</code> .  Vaya al siguiente v√©rtice de la lista usando <code>StartDisplacement()</code> . </li><li>  De lo contrario, al final de la lista, cambie los datos de <code>oMesh</code> a la malla actual y <code>isAnimate</code> en false para detener la animaci√≥n. </li></ol><br>  En <code>DisplaceVertices()</code> agregue lo siguiente: <br><br><pre> <code class="cs hljs">Vector3 currentVertexPos = Vector3.zero; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sqrRadius = radius * radius; <span class="hljs-comment"><span class="hljs-comment">//1 for (int i = 0; i &lt; mVertices.Length; i++) //2 { currentVertexPos = mVertices[i]; float sqrMagnitute = (currentVertexPos - targetVertexPos).sqrMagnitude; //3 if (sqrMagnitute &gt; sqrRadius) { continue; //4 } float distance = Mathf.Sqrt(sqrMagnitute); //5 float falloff = GaussFalloff(distance, radius); Vector3 translate = (currentVertexPos * force) * falloff; //6 translate.z = 0f; Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(currentVertexPos); } oMesh.vertices = mVertices; //7 oMesh.RecalculateNormals();</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  El cuadrado del radio. </li><li>  Recorremos cada v√©rtice de la malla. </li><li>  <code>sqrMagnitude</code> entre <code>currentVertexPos</code> y <code>targetVertexPos</code> . </li><li>  Si <code>sqrMagnitude</code> excede <code>sqrRadius</code> , vaya al siguiente v√©rtice. </li><li>  De lo contrario, contin√∫e definiendo el valor de <code>falloff</code> , que depende de la <code>distance</code> v√©rtice actual desde el punto central del alcance. </li><li>  <code>Vector3</code> nueva posici√≥n de <code>Vector3</code> y aplique su Transformar al v√©rtice actual. </li><li>  Cuando sale del bucle, asignamos los valores cambiados de <code>mVertices</code> a los <code>mVertices</code> y <code>mVertices</code> a Unity a recalcular las normales. </li></ol><br><blockquote>  <em>Fuente de Falloff Technology</em> <br>  La f√≥rmula original se toma del archivo del paquete de activos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Ejemplos de procedimientos</a> , que se puede descargar de forma gratuita desde la Unidad de activos de Unity. </blockquote><br>  Guarde el archivo y regrese a Unity.  Seleccione <em>Esfera</em> , vaya al componente <em>HeartMesh</em> e intente agregar algunos v√©rtices a la propiedad <em>√çndices seleccionados</em> .  Desactive el <em>modo Is Edit</em> y haga clic en <em>Reproducir</em> para ver el resultado de su trabajo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1e/527/23b/e1e52723b08453591da6d10a28dbe13d.gif"></div><br>  Experimente con los <em>valores Radiusofeffect</em> , <em>Pullvalue</em> y <em>Duration</em> para obtener resultados diferentes.  Cuando est√© listo, cambie la configuraci√≥n de acuerdo con la siguiente captura de pantalla. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a63/c44/082/a63c44082183529e737f287cb746dfd6.png"></div><br>  Haz clic en <em>Jugar</em> .  ¬øTu esfera se ha convertido en un coraz√≥n? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif"></div><br>  Felicidades  En la siguiente secci√≥n, guardaremos la malla como prefabricada para uso futuro. <br><br><h3>  Guardar la malla en tiempo real </h3><br>  Para guardar una malla de procedimiento en forma de coraz√≥n en el modo Juego, debe preparar un prefabricado cuyo hijo ser√° un objeto 3D y luego reemplazar su activo de malla con uno nuevo usando un script. <br><br>  En la ventana <em>Proyecto,</em> busque <em>CustomHeart</em> en la carpeta <em>Prefabs</em> .  Haga clic en el icono de flecha para expandir su contenido y seleccione <em>Hijo</em> .  Ahora ver√° un objeto Esfera en la ventana de vista previa del <em>Inspector</em> .  Este es el prefabricado que almacenar√° los datos para la nueva malla. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a3/f07/048/9a3f070486f3a66ee56304dae5bd2b12.png"></div><br>  Abra <em>HeartMeshInspector.cs</em> .  Dentro de la funci√≥n <code>OnInspectorGUI()</code> , antes del corchete de cierre, agregue lo siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mesh.isEditMode &amp;&amp; mesh.isMeshReady) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Prefabs/CustomHeart.prefab"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 if (GUILayout.Button("Save Mesh")) { mesh.isMeshReady = false; Object pfObj = AssetDatabase.LoadAssetAtPath(path, typeof(GameObject)); //2 Object pfRef = AssetDatabase.LoadAssetAtPath (path, typeof(GameObject)); GameObject gameObj = (GameObject)PrefabUtility.InstantiatePrefab(pfObj); Mesh pfMesh = (Mesh)AssetDatabase.LoadAssetAtPath(path, typeof(Mesh)); //3 if (!pfMesh) { pfMesh = new Mesh(); } else { pfMesh.Clear(); } pfMesh = mesh.SaveMesh(); //4 AssetDatabase.AddObjectToAsset(pfMesh, path); gameObj.GetComponentInChildren&lt;MeshFilter&gt;().mesh = pfMesh; //5 PrefabUtility.ReplacePrefab(gameObj, pfRef, ReplacePrefabOptions.Default); //6 Object.DestroyImmediate(gameObj); //7 } }</span></span></code> </pre> <br>  Explicaci√≥n del c√≥digo: <br><br><ol><li>  Establece la <code>path</code> a la ruta al objeto <em>prefabricado</em> CustomHeart. </li><li>  Crea dos objetos a partir del <em>prefabricado</em> CustomHeart, uno para crear una instancia como GameObject ( <code>pfObj</code> ) y el segundo como enlaces ( <code>pfRef</code> ). </li><li>  Crea <em>una</em> instancia del <code>pfMesh</code> malla <code>pfMesh</code> .  Si no se encuentra, crea una nueva malla, de lo contrario, limpia los datos existentes. </li><li>  <code>pfMesh</code> con nuevos datos de malla y luego los agrega como un activo a <em>CustomHeart</em> . <br></li><li>  Rellena un activo de malla en <code>gameObj</code> valor <code>pfMesh</code> . </li><li>  Reemplaza <em>CustomHeart</em> con <code>gameObj</code> coincidir las conexiones preexistentes. </li><li>  Destruye instant√°neamente <code>gameObj</code> . </li></ol><br>  Guarde el archivo y vaya a <em>HeartMesh.cs</em> .  En el <code>SaveMesh()</code> general <code>SaveMesh()</code> , despu√©s de crear la instancia <code>nMesh</code> agregue lo siguiente: <br><br><pre> <code class="cs hljs">nMesh.name = <span class="hljs-string"><span class="hljs-string">"HeartMesh"</span></span>; nMesh.vertices = oMesh.vertices; nMesh.triangles = oMesh.triangles; nMesh.normals = oMesh.normals;</code> </pre> <br>  Explicaci√≥n del c√≥digo: devuelve un activo de malla con valores de una malla en forma de coraz√≥n. <br><br>  Guarde el archivo y regrese a Unity.  Haz clic en <em>Reproducir</em> .  Una vez completada la animaci√≥n, aparecer√° el bot√≥n <em>Guardar malla</em> en el <em>Inspector</em> .  Haga clic en el bot√≥n para guardar la nueva malla y luego detenga el reproductor. <br><br>  Vaya a la carpeta <em>Prefabs</em> y mire el prefab CustomHeart.  Deber√≠a ver que ahora en el objeto <em>prefabricado</em> CustomHeart hay una malla completamente nueva en forma de coraz√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/126/dee/103/126dee103ce798611d2dc2e94013c23c.png"></div><br>  <i>Gran trabajo!</i> <br><br><h2>  Poniendo todo junto </h2><br>  En la escena anterior, la funci√≥n <code>DisplaceVertices()</code> utiliz√≥ la f√≥rmula Falloff para determinar la fuerza de arrastre que se aplic√≥ a cada v√©rtice dentro de un radio determinado.  El punto de "ca√≠da", en el que la fuerza de arrastre comienza a disminuir, depende del tipo de ca√≠da utilizada: lineal, gaussiana o aguja.  Cada tipo produce resultados diferentes en la malla. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/284/9c0/9ff2849c0d0fe5f9d496d641c07e35d8.png"></div><br>  En esta secci√≥n, veremos otra forma de manipular v√©rtices: usando una curva dada.  Tomando la regla de que la velocidad es igual a la distancia dividida por el tiempo (d = (v / t)), podemos determinar la posici√≥n del vector, refiri√©ndonos a su distancia dividida por el tiempo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/2d6/13c/3b82d613cedaf85e12db66beb6349201.gif"></div><br><h3>  Usando el M√©todo de Curva </h3><br>  Guarde la escena actual y abra <em>03 Personalizar Heart Mesh</em> desde la carpeta <em>Escenas</em> .  Ver√° una instancia de jerarqu√≠a del <em>prefabricado</em> CustomHeart.  Haga clic en el icono de flecha al lado para expandir su contenido y seleccione <em>Hijo</em> . <br><br>  Ver sus propiedades en el <em>Inspector</em> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver√° el componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtro de malla</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con el activo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malla de coraz√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Adjunte </font><font style="vertical-align: inherit;">un script de </font><em><font style="vertical-align: inherit;">coraz√≥n personalizado</font></em><font style="vertical-align: inherit;"> a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Child</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como componente </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ahora el activo deber√≠a cambiar de </font><em><font style="vertical-align: inherit;">HeartMesh</font></em><font style="vertical-align: inherit;"> a </font><em><font style="vertical-align: inherit;">clonar</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/954/27f/89d/95427f89d17410e26893a0ec27dff51d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, abra </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desde la carpeta </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Antes de la funci√≥n, </font></font><code>Start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue lo siguiente:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CurveType { Curve1, Curve2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CurveType curveType; Curve curve;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicaci√≥n del c√≥digo: aqu√≠ se crea una enumeraci√≥n general bajo el nombre </font></font><code>CurveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, despu√©s de lo cual se pone a disposici√≥n del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspector</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vaya </font></font><code>CurveType1()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y agregue lo siguiente:</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 1, 0); curvepoints[1] = new Vector3(0.5f, 0.5f, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explicaci√≥n del c√≥digo: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una curva simple consta de tres puntos. </font><font style="vertical-align: inherit;">Establezca los puntos para la primera curva.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generamos la primera curva con la ayuda </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y asignamos sus valores </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La curva dibujada se puede mostrar en la vista previa si especifica true como √∫ltimo par√°metro.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vaya </font></font><code>CurveType2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y agregue lo siguiente:</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 0, 0); curvepoints[1] = new Vector3(0.5f, 1, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explicaci√≥n del c√≥digo: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Establezca los puntos para la segunda curva. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generamos la segunda curva con </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y asignamos sus valores </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La curva dibujada se puede mostrar en la vista previa si especifica true como √∫ltimo par√°metro.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>StartDisplacement()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, antes del corchete de cierre, agregue lo siguiente:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve1) { CurveType1(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve2) { CurveType2(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicaci√≥n del c√≥digo: aqu√≠ verificamos la opci√≥n seleccionada por el usuario </font></font><code>curveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la generamos en consecuencia </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>DisplaceVertices()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dentro de la instrucci√≥n de bucle </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de los corchetes de cierre, agregue lo siguiente:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> increment = curve.GetPoint(distance).y * force; <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 translate = (vert * increment) * Time.deltaTime; //2 Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(mVertices[i]);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explicaci√≥n del c√≥digo: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos </font><font style="vertical-align: inherit;">la </font><font style="vertical-align: inherit;">posici√≥n de la curva en la dada </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y multiplicamos su valor </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>force</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obtener </font></font><code>increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree un nuevo tipo de datos </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para almacenar la nueva posici√≥n del v√©rtice actual y aplique su Transformar en consecuencia.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guarde el archivo y regrese a Unity. </font><font style="vertical-align: inherit;">Compruebe las propiedades del componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objeto de juego </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ni√±os</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ver√° una lista desplegable donde puede seleccionar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de curva</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En la lista desplegable </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editar tipo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">seleccione </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar √≠ndices</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar √≠ndices</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para actualizar la lista de v√©rtices y experimentar con diferentes configuraciones.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/1a7/3b6/7921a73b676b205bd33ec1db076cd4a6.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para ver resultados detallados para diferentes tipos de curvas, ingrese los valores de acuerdo con la captura de pantalla: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/ab3/e5d/e06ab3e5d0bfc950be0c6dbc82d36f6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para la lista </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de curva</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">seleccione </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curva1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aseg√∫rese de que </font><em><font style="vertical-align: inherit;">Ninguno est√©</font></em><font style="vertical-align: inherit;"> seleccionado </font><font style="vertical-align: inherit;">para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editar tipo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y haga clic en </font><em><font style="vertical-align: inherit;">Reproducir</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deber√≠a ver que la malla diverge en el patr√≥n. </font><font style="vertical-align: inherit;">Gire el modelo para verlo en una vista lateral y compare los resultados para ambos tipos de curvas. </font><font style="vertical-align: inherit;">Aqu√≠ puede ver c√≥mo el </font><em><font style="vertical-align: inherit;">Tipo de curva</font></em><font style="vertical-align: inherit;"> seleccionado </font><font style="vertical-align: inherit;">afecta el desplazamiento de la malla.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/f90/4d5/8e1f904d50987247014011ac32261134.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da0/e1a/df4/da0e1adf49f8503188f47826c4079cf1.png"></div><br>  Eso es todo!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede hacer clic en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borrar v√©rtices seleccionados</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para restablecer los </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√≠ndices seleccionados</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y experimentar con sus propios patrones. </font><font style="vertical-align: inherit;">Pero no olvide que hay otros factores que afectar√°n el resultado final de la malla, a saber:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El valor del radio. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La distribuci√≥n de v√©rtices en el √°rea. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La posici√≥n del patr√≥n de los v√©rtices seleccionados. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El m√©todo seleccionado para el desplazamiento. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øA d√≥nde ir despu√©s? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los archivos del proyecto terminado est√°n en el </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo del proyecto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tutorial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°No te detengas ah√≠! </font><font style="vertical-align: inherit;">Pruebe las t√©cnicas m√°s sofisticadas que se utilizan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tutorial </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Unity Procedural Maze Generation</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que hayan disfrutado este tutorial y hayan encontrado √∫til la informaci√≥n. </font><font style="vertical-align: inherit;">Un agradecimiento especial que expreso </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jasper Flick</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catlike Codificaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por sus excelentes tutoriales que me ayudaron a armar un demo para mi proyecto.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/190/e37/362/190e3736241796c39eac74bbe3ddc86e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428796/">https://habr.com/ru/post/es428796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428786/index.html">Procesador cu√°ntico basado en resonancia de giro y manipulaciones con un sistema singlete-triplete</a></li>
<li><a href="../es428788/index.html">Bajo el cap√≥ de Bitfury Clarke: c√≥mo funciona nuestro nuevo chip de miner√≠a</a></li>
<li><a href="../es428790/index.html">Estamos escribiendo un chat bot para VKontakte en python usando longpoll. Segunda parte Dobles lazos, excepciones y otras herej√≠as</a></li>
<li><a href="../es428792/index.html">El nuevo chip Apple T2 hace que sea dif√≠cil escuchar a trav√©s del micr√≥fono incorporado de la computadora port√°til</a></li>
<li><a href="../es428794/index.html">Resumen de los m√©todos b√°sicos de optimizaci√≥n matem√°tica para problemas con restricciones</a></li>
<li><a href="../es428798/index.html">C√≥mo sobrevivir a un desarrollador independiente. Parte 2</a></li>
<li><a href="../es428800/index.html">Cocinar CSS perfecto</a></li>
<li><a href="../es428806/index.html">An√°lisis de verificaci√≥n del consumidor: lo que compran en Amazon</a></li>
<li><a href="../es428808/index.html">Poca conveniencia en la vida estudiantil.</a></li>
<li><a href="../es428810/index.html">18 materiales sobre tecnolog√≠a digital en audio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>