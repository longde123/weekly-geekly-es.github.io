<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏻 👃🏿 🤴🏼 Types de référence nullables dans C # 8.0 et analyse statique 📌 🙏 👳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce n'est un secret pour personne que Microsoft travaille depuis un certain temps à la sortie de la huitième version de C #. Dans la récente version de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types de référence nullables dans C # 8.0 et analyse statique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455230/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Image 9"></p><br>  Ce n'est un secret pour personne que Microsoft travaille depuis un certain temps à la sortie de la huitième version de C #.  Dans la récente version de Visual Studio 2019, une nouvelle version du langage (C # 8.0) est déjà disponible, mais jusqu'à présent uniquement en version bêta.  Les plans de cette nouvelle version ont plusieurs fonctionnalités, dont la mise en œuvre peut ne pas sembler assez évidente, ou plutôt, pas tout à fait attendue.  L'une de ces innovations est la possibilité d'utiliser des types de référence Nullable.  La signification déclarée de cette innovation est la lutte contre les exceptions de référence nulles (NRE). <br><a name="habracut"></a><br>  Nous sommes ravis que le langage se développe et que de nouvelles fonctionnalités devraient aider les développeurs.  Par coïncidence, dans notre analyseur PVS-Studio pour C #, les capacités de détecter exactement les mêmes NRE dans le code se sont relativement récemment étendues.  Et nous nous sommes demandé - est-ce que les analyseurs statiques en général, et pour PVS-Studio en particulier, ont un sens pour essayer de rechercher un déréférencement potentiel de références nulles, si, au moins dans le nouveau code utilisant la référence Nullable, un tel déréférencement deviendra "impossible" ?  Essayons de répondre à cette question. <br><br><h2>  Avantages et inconvénients de l'innovation </h2><br>  Pour commencer, il convient de rappeler que dans la dernière version bêta de C # 8.0, disponible au moment d'écrire ces lignes, Nullable Reference est désactivée par défaut, c'est-à-dire  le comportement des types de référence ne changera pas. <br><br>  Quels sont les types de référence annulables dans C # 8.0 si vous les incluez?  Il s'agit du même bon ancien type de référence, à la différence près que les variables de ce type doivent maintenant être marquées avec '?'  (par exemple <i>chaîne?</i> ), similaire à la façon dont cela est déjà fait pour <i>Nullable &lt;T&gt;</i> , c'est-à-dire  types significatifs nullables (par exemple <i>int?</i> ).  Cependant, maintenant la même <i>chaîne</i> sans '?'  commence déjà à être interprété comme une référence non nulle, c'est-à-dire  il s'agit d'un type de référence dont la variable ne peut pas contenir de valeurs <i>nulles</i> . <br><br>  L'exception de référence nulle est l'une des exceptions les plus gênantes car elle en dit peu sur la source du problème, surtout s'il y a plusieurs déréférences consécutives dans la méthode qui lève l'exception.  La possibilité d'interdire la transmission de <i>null</i> à une variable de référence de type semble correcte, mais si une valeur <i>null</i> antérieure a <i>été</i> transmise à la méthode et qu'une logique d'exécution supplémentaire y était liée, alors que dois-je faire maintenant?  Bien sûr, vous pouvez passer un littéral, une constante ou simplement une valeur «impossible» au lieu de <i>null</i> , qui, selon la logique du programme, ne peut être assigné à cette variable nulle part ailleurs.  Cependant, la chute de l'ensemble du programme peut être remplacée par une nouvelle exécution incorrecte «silencieuse».  Ce ne sera pas toujours mieux que de voir l'erreur tout de suite. <br><br>  Et si au lieu de cela, jetez une exception?  Une exception significative dans un endroit où quelque chose s'est mal passé est toujours meilleure qu'un <i>NRE</i> quelque part plus haut ou plus bas sur la pile.  Mais c'est bien si nous parlons de notre propre projet, où nous pouvons réparer les consommateurs et insérer un <i>bloc try-catch,</i> et lorsque nous développons une bibliothèque en utilisant la référence (non) nulle, nous prenons la responsabilité qu'une méthode retourne toujours une valeur.  Et ce n'est pas toujours même dans le code natif qu'il sera (au moins simple) de substituer le retour de <i>null</i> pour lever une exception (trop de code peut être affecté). <br><br>  Vous pouvez activer Nullable Reference au niveau du projet entier en ajoutant la propriété <i>NullableContextOptions</i> avec la valeur <i>enable</i> , ou au niveau du fichier à l'aide de la directive de préprocesseur: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Les types seront désormais plus visuels.  Par la signature de la méthode, il est possible de déterminer son comportement, qu'il contienne ou non une vérification de <i>null</i> , il peut retourner <i>null</i> ou pas.  Maintenant, si vous essayez d'accéder à une variable de référence nullable sans vérification, le compilateur générera un avertissement. <br><br>  Assez pratique lors de l'utilisation de bibliothèques tierces, mais il y a une situation avec une possible désinformation.  Le fait est que le passage de <i>null</i> est toujours possible, par exemple, en utilisant le nouvel opérateur de tolérance de null (!).  C'est-à-dire  c'est juste qu'à l'aide d'un seul point d'exclamation, vous pouvez casser toutes les autres hypothèses qui seront faites sur une interface en utilisant ces variables: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Oui, on peut dire qu'il est faux d'écrire de cette façon, et personne ne le fera jamais, mais tant que cette opportunité restera, il ne sera plus possible de s'appuyer entièrement uniquement sur le contrat imposé par l'interface de cette méthode (qu'elle ne peut pas retourner nulle). <br><br>  Et vous pouvez, en passant, écrire la même chose à l'aide de plusieurs opérateurs !, Parce que C # vous permet maintenant d'écrire comme ça (et ce code est complètement compilé): <br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  C'est-à-dire  nous tenons à souligner davantage: faites attention - cela peut être <i>nul</i> !!!  (nous, dans l'équipe, appelons cela une programmation «émotionnelle»).  En fait, le compilateur (de Roslyn), lors de la construction d'un arbre de syntaxe de code, interprète l'opérateur!  similaire aux crochets simples, leur nombre, comme c'est le cas avec les crochets, est donc illimité.  Bien que, si vous en écrivez beaucoup, le compilateur puisse être "vidé".  Peut-être que cela changera dans la version finale de C # 8.0. <br><br>  De la même manière, vous pouvez contourner l'avertissement du compilateur lors de l'accès à une variable de référence nullable sans vérifier: <br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Vous pouvez écrire plus émotionnellement: <br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Cette syntaxe est en fait difficile à imaginer dans un vrai projet, mettant un opérateur <i>pardonnant le</i> zéro que nous disons au compilateur: tout va bien ici, aucune vérification n'est nécessaire.  En ajoutant un opérateur elvis on dit: mais en général ce n'est peut-être pas normal, vérifions. <br><br>  Et maintenant une question légitime se pose - pourquoi, si le concept d'un type de référence non nullable implique qu'une variable de ce type ne peut pas contenir <i>null</i> , peut-on encore l'écrire si facilement là-bas?  Le fait est que «sous le capot», au niveau du code IL, notre type de référence non nul peut rester… tout de même le type de référence «ordinaire».  Et toute la syntaxe de nullité n'est en fait qu'une annotation pour l'analyseur statique intégré au compilateur (et, à notre avis, pas l'analyseur le plus pratique, mais plus à ce sujet plus tard).  À notre avis, inclure la nouvelle syntaxe dans le langage uniquement comme annotation pour un outil tiers (même s'il est intégré au compilateur) n'est pas la plus «belle» solution, car  pour un programmeur utilisant ce langage, ce n'est qu'une annotation peut ne pas être évident du tout - après tout, une syntaxe très similaire pour les structures nullables fonctionne d'une manière complètement différente. <br><br>  Revenons à la façon dont il est toujours possible de "casser" les types de référence Nullable.  Au moment de l'écriture, s'il y a plusieurs projets dans la solution, lors du passage d'une méthode déclarée dans un projet une variable de référence, par exemple de type <i>String,</i> à une méthode d'un autre projet où <i>NullableContextOptions est</i> activé <i>, le</i> compilateur décidera qu'il s'agit déjà d'une chaîne non nullable, et ne donnera pas d'avertissement.  Et cela malgré le grand nombre d' <i>attributs [Nullable (1)]</i> ajoutés à chaque champ et méthode de classe dans le code IL lorsque les références Nullable sont activées <i>.</i>  Soit dit en passant, ces attributs doivent être pris en compte si vous travaillez avec une liste d'attributs par réflexion, en comptant uniquement sur les attributs que vous avez ajoutés vous-même. <br><br>  Cette situation peut créer des problèmes supplémentaires lors de la conversion d'une grande base de code en une référence nullable.  Ce processus sera très probablement progressif, projet par projet.  Bien sûr, avec une approche compétente du changement, vous pouvez progressivement passer à une nouvelle fonctionnalité, mais si vous avez déjà un projet de travail, tout changement est dangereux et indésirable (cela fonctionne - ne le touchez pas!).  C'est pourquoi lors de l'utilisation de l'analyseur PVS-Studio, il n'est pas nécessaire de modifier le code source ou de le marquer d'une manière ou d'une autre pour détecter les <i>NRE</i> potentiels.  Pour vérifier les endroits où une <i>exception NullReferenceException</i> peut se produire <i>, il</i> vous suffit de démarrer l'analyseur et de consulter les avertissements du V3080.  Pas besoin de modifier les propriétés du projet ou le code source.  Pas besoin d'ajouter des directives, des attributs ou des opérateurs.  Pas besoin de changer votre code. <br><br>  Avec la prise en charge des types de référence Nullable dans l'analyseur PVS-Studio, nous avons fait face à un choix - l'analyseur doit-il interpréter les variables de référence non nulles comme des valeurs toujours non nulles?  Après avoir étudié la question des possibilités de «briser» cette garantie, nous sommes arrivés à la conclusion qu'il n'y en avait pas - l'analyseur ne devrait pas faire une telle hypothèse.  En effet, même si des types de référence non nullables sont utilisés partout dans le projet, l'analyseur peut compléter leur utilisation en découvrant simplement les situations dans lesquelles une valeur <i>nulle</i> peut apparaître dans une telle variable. <br><br><h2>  Comment PVS-Studio recherche les exceptions de référence nulles </h2><br>  Les mécanismes de flux de données dans l'analyseur C # PVS-Studio surveillent les valeurs possibles des variables pendant l'analyse.  En particulier, PVS-Studio effectue également une analyse interprocédurale, c'est-à-dire  Il essaie de déterminer la valeur possible retournée par la méthode, ainsi que les méthodes appelées dans cette méthode, etc.  Entre autres choses, l'analyseur se souvient des variables qui peuvent potentiellement être <i>nulles</i> .  Si à l'avenir l'analyseur voit un déréférencement sans vérifier une telle variable, encore une fois, soit dans le code actuel en cours de vérification, soit dans la méthode appelée dans ce code, un avertissement V3080 concernant une éventuelle exception de référence nulle sera émis. <br><br>  Dans le même temps, l'idée principale sous-jacente à ce diagnostic est que l'analyseur ne jure que s'il a vu quelque part l'affectation de <i>null</i> à une variable.  Il s'agit de la principale différence entre le comportement de ce diagnostic et l'analyseur intégré au compilateur qui fonctionne avec les types Nullable Reference.  L'analyseur intégré au compilateur ne jurera que par toute référence à une variable de référence nullable non vérifiée du type, à moins, bien sûr, que cet analyseur ne soit «trompé» par l'opérateur! de toute autre manière, absolument n'importe quel analyseur peut être utilisé, surtout si vous vous fixez un tel objectif, et PVS-Studio ne fait pas exception). <br><br>  PVS-Studio ne jure que s'il voit <i>null</i> (dans un contexte local, ou provenant d'une méthode).  Dans le même temps, même si la variable est une variable de référence non nulle, le comportement de l'analyseur ne changera pas - il jurera toujours s'il voit que null lui a été écrit.  Cette approche nous semble plus correcte (ou, du moins, pratique pour l'utilisateur de l'analyseur), car  cela ne nécessite pas de «couvrir» tout le code avec <i>des</i> vérifications <i>nulles</i> pour trouver des déréférences potentielles - cela aurait pu être fait auparavant, sans référence nulle, par exemple, avec les mêmes contrats.  De plus, l'analyseur peut désormais être utilisé pour un contrôle supplémentaire sur les mêmes variables de référence non nulles.  S'ils sont utilisés "honnêtement", et qu'ils ne sont jamais affectés à zéro - l'analyseur restera silencieux.  Si null est attribué et que la variable est déréférencée sans vérification, l'analyseur en avertit avec le message V3080: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br><br>  Considérons quelques exemples d'un tel déclenchement de diagnostics V3080 dans le code de Roslyn lui-même.  Nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vérifié ce projet il</a> n'y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> pas si longtemps, mais cette fois-ci, nous ne considérerons que les déclencheurs d'exception de référence Null potentiels qui n'étaient pas dans les articles précédents.  Voyons comment l'analyseur PVS-Studio peut trouver un déréférencement potentiel de références nulles et comment ces emplacements peuvent être corrigés à l'aide de la nouvelle syntaxe de référence nullable. <br><br>  <i>V3080 [CWE-476] Déréférence nulle possible à l'intérieur de la méthode.</i>  <i>Pensez à inspecter le deuxième argument: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Comme vous pouvez le voir, la variable <i>chainedTupleType</i> peut être nulle dans l'une des branches d'exécution de code.  Ensuite, <i>chainedTupleType est</i> transmis à l'intérieur de la méthode <i>ConstructTupleUnderlyingType</i> et y est utilisé avec vérification via <i>Debug.Assert</i> .  Cette situation est très courante à Roslyn, cependant, il convient de se rappeler que <i>Debug.Assert</i> est supprimé dans la version finale de l'assembly.  Par conséquent, l'analyseur considère toujours que le déréférencement à l'intérieur de la méthode <i>ConstructTupleUnderlyingType</i> est dangereux.  Ensuite, nous donnons le corps de cette méthode, où le déréférencement se produit: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  La question de savoir si l'analyseur doit prendre en compte une telle assertion est en réalité un point discutable (certains de nos utilisateurs le souhaitent), car les contrats de System.Diagnostics.Contracts, par exemple, l'analyseur prend désormais en compte.  Je vais vous donner seulement un petit exemple de notre utilisation réelle du même Roslyn dans notre analyseur.  Récemment, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons pris en charge la nouvelle version de Visual Studio</a> et en même temps mis à jour l'analyseur Roslyn vers la version 3.  Après cela, l'analyseur a commencé à tomber lors de la vérification d'un certain code sur lequel il ne s'était pas écrasé auparavant.  En même temps, l'analyseur a commencé à tomber non pas dans notre code, mais dans le code de Roslyn lui-même - pour tomber avec une exception de référence nulle.  Et un débogage supplémentaire a montré qu'à l'endroit où Roslyn tombe maintenant, exactement deux lignes au-dessus, il y a le même contrôle <i>nul</i> via <i>Debug.Assert</i> .  Et elle, comme on le voit, n'a pas sauvé. <br><br>  Ceci est un très bon exemple de problèmes avec la référence Nullable <i>,</i> car le compilateur considère <i>Debug.Assert</i> comme <i>une</i> vérification valide dans n'importe quelle configuration.  Autrement dit, si vous activez simplement <i>#nullable enable</i> et marquez l'argument <i>chainedTupleTypeOpt</i> comme référence nullable <i>,</i> il n'y aura aucun avertissement du compilateur à l'emplacement de déréférencement dans la méthode <i>ConstructTupleUnderlyingType</i> . <br><br>  Prenons l'exemple de déclenchement PVS-Studio suivant. <br><br>  <i>V3080 Déréférence nulle possible.</i>  <i>Pensez à inspecter «effectiveRuleset».</i>  <i>RuleSet.cs 146</i> <br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Cet avertissement note que l'appel de la méthode <i>WithEffectiveAction</i> peut retourner <i>null</i> , mais le résultat est utilisé sans vérification ( <i>effectiveRuleset.GeneralDiagnosticOption</i> ).  Le corps de la méthode <i>WithEffectiveAction</i> , qui peut retourner null, est écrit dans la variable <i>effectiveRuleset</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br><br>  Si vous activez le mode Nullable Reference pour la méthode <i>GetEffectiveRuleSet</i> , nous aurons deux emplacements dans lesquels nous devons changer le comportement.  Puisqu'il y a une levée d'exception dans la méthode ci-dessus, il est logique de supposer que l'appel de méthode est encapsulé dans un <i>bloc try-catch</i> et il réécrira correctement la méthode, lançant une exception au lieu de retourner null.  Mais en montant les défis, on voit que l'interception est élevée et les conséquences peuvent être assez imprévisibles.  Regardons la variable consumer <i>effectiveRuleset</i> - méthode <i>IsStricterThan</i> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Comme vous pouvez le voir, il s'agit d'un simple commutateur pour deux énumérations avec une valeur d'énumération possible de <i>ReportDiagnostic.Default</i> .  Il est donc préférable de réécrire l'appel comme suit: <br><br>  La signature <i>WithEffectiveAction</i> changera: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  l'appel ressemblera à ceci: <br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  sachant que <i>IsStricterThan</i> effectue uniquement une comparaison - la condition peut être réécrite, par exemple comme ceci: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Passons au message suivant de l'analyseur. <br><br>  <i>V3080 Déréférence nulle possible.</i>  <i>Pensez à inspecter «propertySymbol».</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  L'utilisation ultérieure de la variable <i>propertySymbol</i> doit être prise en compte lors de la correction de l'avertissement de l'analyseur. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  La méthode <i>GetMemberSymbol</i> peut également retourner <i>null</i> dans certains cas. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  En utilisant un type de référence nullable, l'appel changera comme ceci: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Assez simple quand vous savez où le réparer.  L'analyse statique trouve facilement cette erreur potentielle en obtenant toutes les valeurs de champ possibles sur toutes les chaînes d'appels de procédure. <br><br>  <i>V3080 Déréférence nulle possible.</i>  <i>Pensez à inspecter «simpleName».</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  Le problème vient de la vérification de <i>simpleName.Length.</i>  <i>simpleName</i> est le résultat de toute une chaîne de méthodes et peut être <i>nul</i> .  Par ailleurs, par curiosité, vous pouvez regarder la méthode <i>RemoveExtension</i> et trouver des différences avec <i>Path.GetFileNameWithoutExtension.</i>  Ici, nous pourrions nous limiter à vérifier <i>simpleName! = Null</i> , mais dans le contexte des liens non nuls, le code ressemblera à ceci: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  L'appel ressemblera à ceci: <br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclusion </h2><br>  Les types de référence Nullable peuvent être d'une grande aide dans la planification d'une architecture construite à partir de zéro, mais retravailler le code existant peut potentiellement nécessiter beaucoup de temps et de soin, car il peut provoquer de nombreuses erreurs subtiles.  Dans cet article, nous n'avons pas cherché à décourager quiconque d'utiliser les types de référence Nullable dans nos projets.  Nous pensons que cette innovation est généralement utile pour la langue, bien que la façon dont elle a été mise en œuvre puisse soulever des questions. <br><br>  Vous devez toujours vous rappeler les limitations inhérentes à cette approche, et le fait que le mode Nullable Reference activé ne protège pas contre les erreurs de déréférencement de liens NULL, et s'il est utilisé de manière incorrecte, il peut même y conduire.  Il vaut la peine d'envisager l'utilisation d'un analyseur statique moderne, par exemple PVS-Studio, qui prend en charge l'analyse interprocédurale, comme un outil supplémentaire qui, avec la référence nullable, peut vous protéger contre le déréférencement de références nulles.  Chacune de ces approches - à la fois l'analyse interprocédurale approfondie et l'annotation des signatures de méthode (qui fait essentiellement la référence nullable), a ses avantages et ses inconvénients.  L'analyseur vous permettra d'obtenir une liste des endroits potentiellement dangereux et aussi, lors du changement d'un code existant, de voir toutes les conséquences de tels changements.  Si vous attribuez <i>null</i> dans tous les cas, l'analyseur doit immédiatement indiquer à tous les consommateurs la variable, où elle n'est pas vérifiée avant le déréférencement. <br><br>  Vous pouvez rechercher indépendamment d'autres erreurs à la fois dans le projet considéré et dans le vôtre.  Pour ce faire, il vous suffit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télécharger</a> et d'essayer l'analyseur PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Paul Eremeev, Alexander Senichkin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de référence Nullable en C # 8.0 et analyse statique</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455230/">https://habr.com/ru/post/fr455230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455216/index.html">Compteur de vitesse Doppler</a></li>
<li><a href="../fr455218/index.html">Approche écosystémique de la technologie d'entreprise</a></li>
<li><a href="../fr455224/index.html">Finger Music: Jouez n'importe quoi avec les SpecDrums de Sphero</a></li>
<li><a href="../fr455226/index.html">Pourquoi appliquer un linguiste appliqué?</a></li>
<li><a href="../fr455228/index.html">Celui qui a ressuscité Duke Nukem: Entretien avec Randy Pitchford, Gearbox Wizard</a></li>
<li><a href="../fr455234/index.html">Types de référence Nullable en C # 8.0 et analyse statique</a></li>
<li><a href="../fr455236/index.html">Comodo révoque les certificats sans raison</a></li>
<li><a href="../fr455240/index.html">Utilisation du taux de défauts rejetés pour améliorer le rapport d'erreurs</a></li>
<li><a href="../fr455242/index.html">Moins d'oreilles ou comment ne pas gâcher le son du jeu dès le début</a></li>
<li><a href="../fr455244/index.html">Bande dessinée "Soldering is Easy" dans la version mise à jour (2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>