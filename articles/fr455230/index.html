<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèª üëÉüèø ü§¥üèº Types de r√©f√©rence nullables dans C # 8.0 et analyse statique üìå üôè üë≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce n'est un secret pour personne que Microsoft travaille depuis un certain temps √† la sortie de la huiti√®me version de C #. Dans la r√©cente version de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types de r√©f√©rence nullables dans C # 8.0 et analyse statique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455230/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Image 9"></p><br>  Ce n'est un secret pour personne que Microsoft travaille depuis un certain temps √† la sortie de la huiti√®me version de C #.  Dans la r√©cente version de Visual Studio 2019, une nouvelle version du langage (C # 8.0) est d√©j√† disponible, mais jusqu'√† pr√©sent uniquement en version b√™ta.  Les plans de cette nouvelle version ont plusieurs fonctionnalit√©s, dont la mise en ≈ìuvre peut ne pas sembler assez √©vidente, ou plut√¥t, pas tout √† fait attendue.  L'une de ces innovations est la possibilit√© d'utiliser des types de r√©f√©rence Nullable.  La signification d√©clar√©e de cette innovation est la lutte contre les exceptions de r√©f√©rence nulles (NRE). <br><a name="habracut"></a><br>  Nous sommes ravis que le langage se d√©veloppe et que de nouvelles fonctionnalit√©s devraient aider les d√©veloppeurs.  Par co√Øncidence, dans notre analyseur PVS-Studio pour C #, les capacit√©s de d√©tecter exactement les m√™mes NRE dans le code se sont relativement r√©cemment √©tendues.  Et nous nous sommes demand√© - est-ce que les analyseurs statiques en g√©n√©ral, et pour PVS-Studio en particulier, ont un sens pour essayer de rechercher un d√©r√©f√©rencement potentiel de r√©f√©rences nulles, si, au moins dans le nouveau code utilisant la r√©f√©rence Nullable, un tel d√©r√©f√©rencement deviendra "impossible" ?  Essayons de r√©pondre √† cette question. <br><br><h2>  Avantages et inconv√©nients de l'innovation </h2><br>  Pour commencer, il convient de rappeler que dans la derni√®re version b√™ta de C # 8.0, disponible au moment d'√©crire ces lignes, Nullable Reference est d√©sactiv√©e par d√©faut, c'est-√†-dire  le comportement des types de r√©f√©rence ne changera pas. <br><br>  Quels sont les types de r√©f√©rence annulables dans C # 8.0 si vous les incluez?  Il s'agit du m√™me bon ancien type de r√©f√©rence, √† la diff√©rence pr√®s que les variables de ce type doivent maintenant √™tre marqu√©es avec '?'  (par exemple <i>cha√Æne?</i> ), similaire √† la fa√ßon dont cela est d√©j√† fait pour <i>Nullable &lt;T&gt;</i> , c'est-√†-dire  types significatifs nullables (par exemple <i>int?</i> ).  Cependant, maintenant la m√™me <i>cha√Æne</i> sans '?'  commence d√©j√† √† √™tre interpr√©t√© comme une r√©f√©rence non nulle, c'est-√†-dire  il s'agit d'un type de r√©f√©rence dont la variable ne peut pas contenir de valeurs <i>nulles</i> . <br><br>  L'exception de r√©f√©rence nulle est l'une des exceptions les plus g√™nantes car elle en dit peu sur la source du probl√®me, surtout s'il y a plusieurs d√©r√©f√©rences cons√©cutives dans la m√©thode qui l√®ve l'exception.  La possibilit√© d'interdire la transmission de <i>null</i> √† une variable de r√©f√©rence de type semble correcte, mais si une valeur <i>null</i> ant√©rieure a <i>√©t√©</i> transmise √† la m√©thode et qu'une logique d'ex√©cution suppl√©mentaire y √©tait li√©e, alors que dois-je faire maintenant?  Bien s√ªr, vous pouvez passer un litt√©ral, une constante ou simplement une valeur ¬´impossible¬ª au lieu de <i>null</i> , qui, selon la logique du programme, ne peut √™tre assign√© √† cette variable nulle part ailleurs.  Cependant, la chute de l'ensemble du programme peut √™tre remplac√©e par une nouvelle ex√©cution incorrecte ¬´silencieuse¬ª.  Ce ne sera pas toujours mieux que de voir l'erreur tout de suite. <br><br>  Et si au lieu de cela, jetez une exception?  Une exception significative dans un endroit o√π quelque chose s'est mal pass√© est toujours meilleure qu'un <i>NRE</i> quelque part plus haut ou plus bas sur la pile.  Mais c'est bien si nous parlons de notre propre projet, o√π nous pouvons r√©parer les consommateurs et ins√©rer un <i>bloc try-catch,</i> et lorsque nous d√©veloppons une biblioth√®que en utilisant la r√©f√©rence (non) nulle, nous prenons la responsabilit√© qu'une m√©thode retourne toujours une valeur.  Et ce n'est pas toujours m√™me dans le code natif qu'il sera (au moins simple) de substituer le retour de <i>null</i> pour lever une exception (trop de code peut √™tre affect√©). <br><br>  Vous pouvez activer Nullable Reference au niveau du projet entier en ajoutant la propri√©t√© <i>NullableContextOptions</i> avec la valeur <i>enable</i> , ou au niveau du fichier √† l'aide de la directive de pr√©processeur: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Les types seront d√©sormais plus visuels.  Par la signature de la m√©thode, il est possible de d√©terminer son comportement, qu'il contienne ou non une v√©rification de <i>null</i> , il peut retourner <i>null</i> ou pas.  Maintenant, si vous essayez d'acc√©der √† une variable de r√©f√©rence nullable sans v√©rification, le compilateur g√©n√©rera un avertissement. <br><br>  Assez pratique lors de l'utilisation de biblioth√®ques tierces, mais il y a une situation avec une possible d√©sinformation.  Le fait est que le passage de <i>null</i> est toujours possible, par exemple, en utilisant le nouvel op√©rateur de tol√©rance de null (!).  C'est-√†-dire  c'est juste qu'√† l'aide d'un seul point d'exclamation, vous pouvez casser toutes les autres hypoth√®ses qui seront faites sur une interface en utilisant ces variables: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Oui, on peut dire qu'il est faux d'√©crire de cette fa√ßon, et personne ne le fera jamais, mais tant que cette opportunit√© restera, il ne sera plus possible de s'appuyer enti√®rement uniquement sur le contrat impos√© par l'interface de cette m√©thode (qu'elle ne peut pas retourner nulle). <br><br>  Et vous pouvez, en passant, √©crire la m√™me chose √† l'aide de plusieurs op√©rateurs !, Parce que C # vous permet maintenant d'√©crire comme √ßa (et ce code est compl√®tement compil√©): <br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  C'est-√†-dire  nous tenons √† souligner davantage: faites attention - cela peut √™tre <i>nul</i> !!!  (nous, dans l'√©quipe, appelons cela une programmation ¬´√©motionnelle¬ª).  En fait, le compilateur (de Roslyn), lors de la construction d'un arbre de syntaxe de code, interpr√®te l'op√©rateur!  similaire aux crochets simples, leur nombre, comme c'est le cas avec les crochets, est donc illimit√©.  Bien que, si vous en √©crivez beaucoup, le compilateur puisse √™tre "vid√©".  Peut-√™tre que cela changera dans la version finale de C # 8.0. <br><br>  De la m√™me mani√®re, vous pouvez contourner l'avertissement du compilateur lors de l'acc√®s √† une variable de r√©f√©rence nullable sans v√©rifier: <br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Vous pouvez √©crire plus √©motionnellement: <br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Cette syntaxe est en fait difficile √† imaginer dans un vrai projet, mettant un op√©rateur <i>pardonnant le</i> z√©ro que nous disons au compilateur: tout va bien ici, aucune v√©rification n'est n√©cessaire.  En ajoutant un op√©rateur elvis on dit: mais en g√©n√©ral ce n'est peut-√™tre pas normal, v√©rifions. <br><br>  Et maintenant une question l√©gitime se pose - pourquoi, si le concept d'un type de r√©f√©rence non nullable implique qu'une variable de ce type ne peut pas contenir <i>null</i> , peut-on encore l'√©crire si facilement l√†-bas?  Le fait est que ¬´sous le capot¬ª, au niveau du code IL, notre type de r√©f√©rence non nul peut rester‚Ä¶ tout de m√™me le type de r√©f√©rence ¬´ordinaire¬ª.  Et toute la syntaxe de nullit√© n'est en fait qu'une annotation pour l'analyseur statique int√©gr√© au compilateur (et, √† notre avis, pas l'analyseur le plus pratique, mais plus √† ce sujet plus tard).  √Ä notre avis, inclure la nouvelle syntaxe dans le langage uniquement comme annotation pour un outil tiers (m√™me s'il est int√©gr√© au compilateur) n'est pas la plus ¬´belle¬ª solution, car  pour un programmeur utilisant ce langage, ce n'est qu'une annotation peut ne pas √™tre √©vident du tout - apr√®s tout, une syntaxe tr√®s similaire pour les structures nullables fonctionne d'une mani√®re compl√®tement diff√©rente. <br><br>  Revenons √† la fa√ßon dont il est toujours possible de "casser" les types de r√©f√©rence Nullable.  Au moment de l'√©criture, s'il y a plusieurs projets dans la solution, lors du passage d'une m√©thode d√©clar√©e dans un projet une variable de r√©f√©rence, par exemple de type <i>String,</i> √† une m√©thode d'un autre projet o√π <i>NullableContextOptions est</i> activ√© <i>, le</i> compilateur d√©cidera qu'il s'agit d√©j√† d'une cha√Æne non nullable, et ne donnera pas d'avertissement.  Et cela malgr√© le grand nombre d' <i>attributs [Nullable (1)]</i> ajout√©s √† chaque champ et m√©thode de classe dans le code IL lorsque les r√©f√©rences Nullable sont activ√©es <i>.</i>  Soit dit en passant, ces attributs doivent √™tre pris en compte si vous travaillez avec une liste d'attributs par r√©flexion, en comptant uniquement sur les attributs que vous avez ajout√©s vous-m√™me. <br><br>  Cette situation peut cr√©er des probl√®mes suppl√©mentaires lors de la conversion d'une grande base de code en une r√©f√©rence nullable.  Ce processus sera tr√®s probablement progressif, projet par projet.  Bien s√ªr, avec une approche comp√©tente du changement, vous pouvez progressivement passer √† une nouvelle fonctionnalit√©, mais si vous avez d√©j√† un projet de travail, tout changement est dangereux et ind√©sirable (cela fonctionne - ne le touchez pas!).  C'est pourquoi lors de l'utilisation de l'analyseur PVS-Studio, il n'est pas n√©cessaire de modifier le code source ou de le marquer d'une mani√®re ou d'une autre pour d√©tecter les <i>NRE</i> potentiels.  Pour v√©rifier les endroits o√π une <i>exception NullReferenceException</i> peut se produire <i>, il</i> vous suffit de d√©marrer l'analyseur et de consulter les avertissements du V3080.  Pas besoin de modifier les propri√©t√©s du projet ou le code source.  Pas besoin d'ajouter des directives, des attributs ou des op√©rateurs.  Pas besoin de changer votre code. <br><br>  Avec la prise en charge des types de r√©f√©rence Nullable dans l'analyseur PVS-Studio, nous avons fait face √† un choix - l'analyseur doit-il interpr√©ter les variables de r√©f√©rence non nulles comme des valeurs toujours non nulles?  Apr√®s avoir √©tudi√© la question des possibilit√©s de ¬´briser¬ª cette garantie, nous sommes arriv√©s √† la conclusion qu'il n'y en avait pas - l'analyseur ne devrait pas faire une telle hypoth√®se.  En effet, m√™me si des types de r√©f√©rence non nullables sont utilis√©s partout dans le projet, l'analyseur peut compl√©ter leur utilisation en d√©couvrant simplement les situations dans lesquelles une valeur <i>nulle</i> peut appara√Ætre dans une telle variable. <br><br><h2>  Comment PVS-Studio recherche les exceptions de r√©f√©rence nulles </h2><br>  Les m√©canismes de flux de donn√©es dans l'analyseur C # PVS-Studio surveillent les valeurs possibles des variables pendant l'analyse.  En particulier, PVS-Studio effectue √©galement une analyse interproc√©durale, c'est-√†-dire  Il essaie de d√©terminer la valeur possible retourn√©e par la m√©thode, ainsi que les m√©thodes appel√©es dans cette m√©thode, etc.  Entre autres choses, l'analyseur se souvient des variables qui peuvent potentiellement √™tre <i>nulles</i> .  Si √† l'avenir l'analyseur voit un d√©r√©f√©rencement sans v√©rifier une telle variable, encore une fois, soit dans le code actuel en cours de v√©rification, soit dans la m√©thode appel√©e dans ce code, un avertissement V3080 concernant une √©ventuelle exception de r√©f√©rence nulle sera √©mis. <br><br>  Dans le m√™me temps, l'id√©e principale sous-jacente √† ce diagnostic est que l'analyseur ne jure que s'il a vu quelque part l'affectation de <i>null</i> √† une variable.  Il s'agit de la principale diff√©rence entre le comportement de ce diagnostic et l'analyseur int√©gr√© au compilateur qui fonctionne avec les types Nullable Reference.  L'analyseur int√©gr√© au compilateur ne jurera que par toute r√©f√©rence √† une variable de r√©f√©rence nullable non v√©rifi√©e du type, √† moins, bien s√ªr, que cet analyseur ne soit ¬´tromp√©¬ª par l'op√©rateur! de toute autre mani√®re, absolument n'importe quel analyseur peut √™tre utilis√©, surtout si vous vous fixez un tel objectif, et PVS-Studio ne fait pas exception). <br><br>  PVS-Studio ne jure que s'il voit <i>null</i> (dans un contexte local, ou provenant d'une m√©thode).  Dans le m√™me temps, m√™me si la variable est une variable de r√©f√©rence non nulle, le comportement de l'analyseur ne changera pas - il jurera toujours s'il voit que null lui a √©t√© √©crit.  Cette approche nous semble plus correcte (ou, du moins, pratique pour l'utilisateur de l'analyseur), car  cela ne n√©cessite pas de ¬´couvrir¬ª tout le code avec <i>des</i> v√©rifications <i>nulles</i> pour trouver des d√©r√©f√©rences potentielles - cela aurait pu √™tre fait auparavant, sans r√©f√©rence nulle, par exemple, avec les m√™mes contrats.  De plus, l'analyseur peut d√©sormais √™tre utilis√© pour un contr√¥le suppl√©mentaire sur les m√™mes variables de r√©f√©rence non nulles.  S'ils sont utilis√©s "honn√™tement", et qu'ils ne sont jamais affect√©s √† z√©ro - l'analyseur restera silencieux.  Si null est attribu√© et que la variable est d√©r√©f√©renc√©e sans v√©rification, l'analyseur en avertit avec le message V3080: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br><br>  Consid√©rons quelques exemples d'un tel d√©clenchement de diagnostics V3080 dans le code de Roslyn lui-m√™me.  Nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">v√©rifi√© ce projet il</a> n'y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> pas si longtemps, mais cette fois-ci, nous ne consid√©rerons que les d√©clencheurs d'exception de r√©f√©rence Null potentiels qui n'√©taient pas dans les articles pr√©c√©dents.  Voyons comment l'analyseur PVS-Studio peut trouver un d√©r√©f√©rencement potentiel de r√©f√©rences nulles et comment ces emplacements peuvent √™tre corrig√©s √† l'aide de la nouvelle syntaxe de r√©f√©rence nullable. <br><br>  <i>V3080 [CWE-476] D√©r√©f√©rence nulle possible √† l'int√©rieur de la m√©thode.</i>  <i>Pensez √† inspecter le deuxi√®me argument: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Comme vous pouvez le voir, la variable <i>chainedTupleType</i> peut √™tre nulle dans l'une des branches d'ex√©cution de code.  Ensuite, <i>chainedTupleType est</i> transmis √† l'int√©rieur de la m√©thode <i>ConstructTupleUnderlyingType</i> et y est utilis√© avec v√©rification via <i>Debug.Assert</i> .  Cette situation est tr√®s courante √† Roslyn, cependant, il convient de se rappeler que <i>Debug.Assert</i> est supprim√© dans la version finale de l'assembly.  Par cons√©quent, l'analyseur consid√®re toujours que le d√©r√©f√©rencement √† l'int√©rieur de la m√©thode <i>ConstructTupleUnderlyingType</i> est dangereux.  Ensuite, nous donnons le corps de cette m√©thode, o√π le d√©r√©f√©rencement se produit: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  La question de savoir si l'analyseur doit prendre en compte une telle assertion est en r√©alit√© un point discutable (certains de nos utilisateurs le souhaitent), car les contrats de System.Diagnostics.Contracts, par exemple, l'analyseur prend d√©sormais en compte.  Je vais vous donner seulement un petit exemple de notre utilisation r√©elle du m√™me Roslyn dans notre analyseur.  R√©cemment, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons pris en charge la nouvelle version de Visual Studio</a> et en m√™me temps mis √† jour l'analyseur Roslyn vers la version 3.  Apr√®s cela, l'analyseur a commenc√© √† tomber lors de la v√©rification d'un certain code sur lequel il ne s'√©tait pas √©cras√© auparavant.  En m√™me temps, l'analyseur a commenc√© √† tomber non pas dans notre code, mais dans le code de Roslyn lui-m√™me - pour tomber avec une exception de r√©f√©rence nulle.  Et un d√©bogage suppl√©mentaire a montr√© qu'√† l'endroit o√π Roslyn tombe maintenant, exactement deux lignes au-dessus, il y a le m√™me contr√¥le <i>nul</i> via <i>Debug.Assert</i> .  Et elle, comme on le voit, n'a pas sauv√©. <br><br>  Ceci est un tr√®s bon exemple de probl√®mes avec la r√©f√©rence Nullable <i>,</i> car le compilateur consid√®re <i>Debug.Assert</i> comme <i>une</i> v√©rification valide dans n'importe quelle configuration.  Autrement dit, si vous activez simplement <i>#nullable enable</i> et marquez l'argument <i>chainedTupleTypeOpt</i> comme r√©f√©rence nullable <i>,</i> il n'y aura aucun avertissement du compilateur √† l'emplacement de d√©r√©f√©rencement dans la m√©thode <i>ConstructTupleUnderlyingType</i> . <br><br>  Prenons l'exemple de d√©clenchement PVS-Studio suivant. <br><br>  <i>V3080 D√©r√©f√©rence nulle possible.</i>  <i>Pensez √† inspecter ¬´effectiveRuleset¬ª.</i>  <i>RuleSet.cs 146</i> <br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Cet avertissement note que l'appel de la m√©thode <i>WithEffectiveAction</i> peut retourner <i>null</i> , mais le r√©sultat est utilis√© sans v√©rification ( <i>effectiveRuleset.GeneralDiagnosticOption</i> ).  Le corps de la m√©thode <i>WithEffectiveAction</i> , qui peut retourner null, est √©crit dans la variable <i>effectiveRuleset</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br><br>  Si vous activez le mode Nullable Reference pour la m√©thode <i>GetEffectiveRuleSet</i> , nous aurons deux emplacements dans lesquels nous devons changer le comportement.  Puisqu'il y a une lev√©e d'exception dans la m√©thode ci-dessus, il est logique de supposer que l'appel de m√©thode est encapsul√© dans un <i>bloc try-catch</i> et il r√©√©crira correctement la m√©thode, lan√ßant une exception au lieu de retourner null.  Mais en montant les d√©fis, on voit que l'interception est √©lev√©e et les cons√©quences peuvent √™tre assez impr√©visibles.  Regardons la variable consumer <i>effectiveRuleset</i> - m√©thode <i>IsStricterThan</i> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Comme vous pouvez le voir, il s'agit d'un simple commutateur pour deux √©num√©rations avec une valeur d'√©num√©ration possible de <i>ReportDiagnostic.Default</i> .  Il est donc pr√©f√©rable de r√©√©crire l'appel comme suit: <br><br>  La signature <i>WithEffectiveAction</i> changera: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  l'appel ressemblera √† ceci: <br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  sachant que <i>IsStricterThan</i> effectue uniquement une comparaison - la condition peut √™tre r√©√©crite, par exemple comme ceci: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Passons au message suivant de l'analyseur. <br><br>  <i>V3080 D√©r√©f√©rence nulle possible.</i>  <i>Pensez √† inspecter ¬´propertySymbol¬ª.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  L'utilisation ult√©rieure de la variable <i>propertySymbol</i> doit √™tre prise en compte lors de la correction de l'avertissement de l'analyseur. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  La m√©thode <i>GetMemberSymbol</i> peut √©galement retourner <i>null</i> dans certains cas. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  En utilisant un type de r√©f√©rence nullable, l'appel changera comme ceci: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Assez simple quand vous savez o√π le r√©parer.  L'analyse statique trouve facilement cette erreur potentielle en obtenant toutes les valeurs de champ possibles sur toutes les cha√Ænes d'appels de proc√©dure. <br><br>  <i>V3080 D√©r√©f√©rence nulle possible.</i>  <i>Pensez √† inspecter ¬´simpleName¬ª.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  Le probl√®me vient de la v√©rification de <i>simpleName.Length.</i>  <i>simpleName</i> est le r√©sultat de toute une cha√Æne de m√©thodes et peut √™tre <i>nul</i> .  Par ailleurs, par curiosit√©, vous pouvez regarder la m√©thode <i>RemoveExtension</i> et trouver des diff√©rences avec <i>Path.GetFileNameWithoutExtension.</i>  Ici, nous pourrions nous limiter √† v√©rifier <i>simpleName! = Null</i> , mais dans le contexte des liens non nuls, le code ressemblera √† ceci: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  L'appel ressemblera √† ceci: <br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclusion </h2><br>  Les types de r√©f√©rence Nullable peuvent √™tre d'une grande aide dans la planification d'une architecture construite √† partir de z√©ro, mais retravailler le code existant peut potentiellement n√©cessiter beaucoup de temps et de soin, car il peut provoquer de nombreuses erreurs subtiles.  Dans cet article, nous n'avons pas cherch√© √† d√©courager quiconque d'utiliser les types de r√©f√©rence Nullable dans nos projets.  Nous pensons que cette innovation est g√©n√©ralement utile pour la langue, bien que la fa√ßon dont elle a √©t√© mise en ≈ìuvre puisse soulever des questions. <br><br>  Vous devez toujours vous rappeler les limitations inh√©rentes √† cette approche, et le fait que le mode Nullable Reference activ√© ne prot√®ge pas contre les erreurs de d√©r√©f√©rencement de liens NULL, et s'il est utilis√© de mani√®re incorrecte, il peut m√™me y conduire.  Il vaut la peine d'envisager l'utilisation d'un analyseur statique moderne, par exemple PVS-Studio, qui prend en charge l'analyse interproc√©durale, comme un outil suppl√©mentaire qui, avec la r√©f√©rence nullable, peut vous prot√©ger contre le d√©r√©f√©rencement de r√©f√©rences nulles.  Chacune de ces approches - √† la fois l'analyse interproc√©durale approfondie et l'annotation des signatures de m√©thode (qui fait essentiellement la r√©f√©rence nullable), a ses avantages et ses inconv√©nients.  L'analyseur vous permettra d'obtenir une liste des endroits potentiellement dangereux et aussi, lors du changement d'un code existant, de voir toutes les cons√©quences de tels changements.  Si vous attribuez <i>null</i> dans tous les cas, l'analyseur doit imm√©diatement indiquer √† tous les consommateurs la variable, o√π elle n'est pas v√©rifi√©e avant le d√©r√©f√©rencement. <br><br>  Vous pouvez rechercher ind√©pendamment d'autres erreurs √† la fois dans le projet consid√©r√© et dans le v√¥tre.  Pour ce faire, il vous suffit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©charger</a> et d'essayer l'analyseur PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Paul Eremeev, Alexander Senichkin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de r√©f√©rence Nullable en C # 8.0 et analyse statique</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455230/">https://habr.com/ru/post/fr455230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455216/index.html">Compteur de vitesse Doppler</a></li>
<li><a href="../fr455218/index.html">Approche √©cosyst√©mique de la technologie d'entreprise</a></li>
<li><a href="../fr455224/index.html">Finger Music: Jouez n'importe quoi avec les SpecDrums de Sphero</a></li>
<li><a href="../fr455226/index.html">Pourquoi appliquer un linguiste appliqu√©?</a></li>
<li><a href="../fr455228/index.html">Celui qui a ressuscit√© Duke Nukem: Entretien avec Randy Pitchford, Gearbox Wizard</a></li>
<li><a href="../fr455234/index.html">Types de r√©f√©rence Nullable en C # 8.0 et analyse statique</a></li>
<li><a href="../fr455236/index.html">Comodo r√©voque les certificats sans raison</a></li>
<li><a href="../fr455240/index.html">Utilisation du taux de d√©fauts rejet√©s pour am√©liorer le rapport d'erreurs</a></li>
<li><a href="../fr455242/index.html">Moins d'oreilles ou comment ne pas g√¢cher le son du jeu d√®s le d√©but</a></li>
<li><a href="../fr455244/index.html">Bande dessin√©e "Soldering is Easy" dans la version mise √† jour (2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>