<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèΩ üëêüèø üéôÔ∏è Perangkap HttpClient di .NET ‚ú°Ô∏è üî≤ üë©üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Melanjutkan serangkaian artikel tentang "jebakan" Saya tidak dapat mengabaikan System.Net.HttpClient, yang sangat sering digunakan dalam praktiknya, t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perangkap HttpClient di .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424873/">  Melanjutkan serangkaian artikel tentang "jebakan" Saya tidak dapat mengabaikan System.Net.HttpClient, yang sangat sering digunakan dalam praktiknya, tetapi memiliki beberapa masalah serius yang mungkin tidak dapat segera terlihat. <br><br>  Masalah yang cukup umum dalam pemrograman adalah bahwa pengembang hanya berfokus pada fungsionalitas komponen tertentu, sementara mengabaikan komponen non-fungsional yang sangat penting, yang dapat memengaruhi kinerja, skalabilitas, kemudahan pemulihan jika terjadi kegagalan, keamanan, dll.  Misalnya, HttpClient yang sama tampaknya merupakan komponen dasar, tetapi ada beberapa pertanyaan: berapa banyak ia membuat koneksi paralel ke server, berapa lama mereka hidup, bagaimana akan berperilaku jika nama DNS yang diakses sebelumnya dialihkan ke alamat IP yang berbeda ?  Mari kita coba jawab pertanyaan-pertanyaan ini di artikel. <br><a name="habracut"></a><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koneksi bocor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Batasi koneksi server bersamaan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koneksi berumur panjang dan caching DNS</a> </li></ol><br><a name="1"></a>  Masalah pertama dengan HttpClient adalah <b>kebocoran koneksi yang tidak</b> jelas.  Cukup sering, saya harus memenuhi kode di mana ia dibuat untuk mengeksekusi setiap permintaan: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid textId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">$"http://someservice.com/api/v1/some-text/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{textId}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br>  Sayangnya, pendekatan ini menyebabkan pemborosan sumber daya yang besar dan probabilitas tinggi untuk mendapatkan daftar koneksi terbuka yang melimpah.  Untuk menunjukkan masalah dengan jelas, cukup menjalankan kode berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); } } }</code> </pre><br>  Dan setelah selesai, lihat daftar koneksi terbuka via netstat: <br><br><pre> PS C: \ Development \ Exercises&gt; netstat -n |  select-string -pattern "178.248.237.68"<font></font>
<font></font>
   TCP 192.168.1.13:43684 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43685 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43686 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43687 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43689 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003690 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003691 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003692 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003693 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003695 178.248.237.68-00-0043 TIME_WAIT
</pre><br>  <i>Di sini, -n switch digunakan untuk mempercepat output, karena jika tidak netstat untuk setiap IP akan mencari nama domain, dan 178.248.237.68 akan mencari alamat IP habr.com pada saat penulisan ini.</i> <br><br>  Secara total, kita melihat bahwa meskipun menggunakan konstruk, dan meskipun program itu sepenuhnya selesai, koneksi ke server tetap "menggantung".  Dan mereka akan menggantung selama ditunjukkan dalam kunci registri HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Services \ Tcpip \ Parameters \ TcpTimedWaitDelay. <br><br>  Sebuah pertanyaan dapat segera muncul - bagaimana .NET Core berperilaku dalam kasus seperti itu?  Apa yang ada di Windows, apa yang ada di Linux - persis sama, karena retensi koneksi seperti itu terjadi di tingkat sistem, dan bukan di tingkat aplikasi.  Status TIME_WAIT adalah keadaan khusus soket setelah ditutup oleh aplikasi, dan ini diperlukan untuk memproses paket yang masih dapat melewati jaringan.  Untuk Linux, durasi status ini ditentukan dalam detik di / proc / sys / net / ipv4 / tcp_fin_timeout, dan tentu saja itu dapat diubah jika perlu. <br><br><a name="2"></a>  Masalah kedua HttpClient adalah <b>batas koneksi konkuren yang</b> tidak jelas <b>ke server</b> .  Misalkan Anda menggunakan .NET Framework 4.7 yang dikenal, dengan bantuan yang Anda kembangkan layanan yang sangat dimuat, di mana ada panggilan ke layanan lain melalui HTTP.  Masalah potensial dengan kebocoran koneksi telah diatasi, sehingga instance HttpClient yang sama digunakan untuk semua permintaan.  Apa yang salah? <br><br>  Masalahnya dapat dengan mudah dilihat dengan menjalankan kode berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  <i>Sumber daya yang ditentukan dalam tautan memungkinkan Anda untuk menunda respons server untuk waktu yang ditentukan, dalam hal ini - 5 detik.</i> <br><br>  Karena mudah diketahui setelah mengeksekusi kode di atas - setiap 5 detik hanya 2 tanggapan yang tiba, meskipun 10 permintaan simultan dibuat.  Hal ini disebabkan oleh kenyataan bahwa interaksi dengan HTTP dalam kerangka .NET reguler, antara lain, melewati System.Net.ServicePointManager kelas khusus yang mengontrol berbagai aspek koneksi HTTP.  Kelas ini memiliki properti DefaultConnectionLimit yang menunjukkan berapa banyak koneksi konkuren yang dapat dibuat untuk setiap domain.  Dan secara historis, nilai default sebuah properti adalah 2. <br><br>  Jika Anda menambahkan contoh kode di atas di awal <br><br><pre> <code class="cs hljs">ServicePointManager.DefaultConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  maka eksekusi contoh akan terasa lebih cepat, karena permintaan akan dieksekusi dalam batch 5. <br><br>  Dan sebelum beralih ke cara kerjanya di .NET Core, sedikit lagi harus dikatakan tentang ServicePointManager.  Properti yang dibahas di atas menunjukkan jumlah koneksi default yang akan digunakan untuk koneksi berikutnya ke domain apa pun.  Namun seiring dengan ini, dimungkinkan untuk mengontrol parameter untuk setiap nama domain secara individual dan ini dilakukan melalui kelas ServicePoint: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk"</span></span>)); delayServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Setelah mengeksekusi kode ini, setiap interaksi dengan Habr melalui instance HttpClient yang sama akan menggunakan 5 koneksi simultan, dan 3 koneksi dengan situs "lambat". <br><br>  Ada nuansa lain yang menarik di sini - batas jumlah koneksi untuk alamat lokal (localhost) adalah int.MaxValue secara default.  Lihat saja hasil dari mengeksekusi kode ini tanpa terlebih dahulu menetapkan DefaultConnectionLimit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); Console.WriteLine(habrServicePoint.ConnectionLimit); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>)); Console.WriteLine(localServicePoint.ConnectionLimit);</code> </pre><br>  Sekarang mari kita beralih ke .NET Core.  Meskipun ServicePointManager masih ada di namespace System.Net, itu tidak mempengaruhi perilaku HttpClient di .NET Core.  Sebagai gantinya, parameter koneksi HTTP dapat dikontrol menggunakan HttpClientHandler (atau SocketsHttpHandler, yang akan kita bicarakan nanti): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler(); handler.MaxConnectionsPerServer = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  Contoh di atas akan berperilaku sama persis dengan contoh awal untuk .NET Framework biasa - untuk membuat hanya 2 koneksi pada suatu waktu.  Tetapi jika Anda menghapus baris dengan set properti MaxConnectionsPerServer, jumlah koneksi simultan akan jauh lebih tinggi, karena secara default di .NET Core nilai properti ini adalah int.MaxValue. <br><br><a name="3"></a>  Dan sekarang mari kita lihat masalah ketiga yang tidak jelas dengan pengaturan default, yang tidak kalah penting dari dua sebelumnya - <b>koneksi berumur panjang dan caching DNS</b> .  Ketika membuat koneksi dengan server jarak jauh, nama domain pertama kali diselesaikan ke alamat IP yang sesuai, kemudian alamat yang diterima dimasukkan ke dalam cache selama beberapa waktu untuk mempercepat koneksi berikutnya.  Selain itu, untuk menghemat sumber daya, paling sering koneksi tidak ditutup setelah setiap permintaan, tetapi tetap terbuka untuk waktu yang lama. <br><br>  Bayangkan bahwa sistem yang kami kembangkan harus bekerja secara normal tanpa memaksa restart jika server yang berinteraksi dengannya telah berubah ke alamat IP yang berbeda.  Misalnya, jika Anda beralih ke pusat data lain karena kegagalan yang sekarang.  Bahkan jika koneksi permanen terputus karena kegagalan pada pusat data pertama (yang juga dapat terjadi dengan cepat), cache DNS tidak akan memungkinkan sistem kami untuk dengan cepat menanggapi perubahan seperti itu.  Hal yang sama berlaku untuk panggilan ke alamat di mana penyeimbangan beban dilakukan melalui DNS round-robin. <br><br>  Dalam kasus kerangka kerja ‚Äúnormal‚Äù .NET, perilaku ini dapat dikontrol melalui ServicePointManager dan ServicePoint (semua parameter yang tercantum di bawah ini mengambil nilai dalam milidetik): <br><br><ul><li>  ServicePointManager.DnsRefreshTimeout - menunjukkan berapa lama alamat IP yang diterima untuk setiap nama domain akan di-cache, nilai standarnya adalah 2 menit (120000). </li><li>  ServicePoint.ConnectionLeaseTimeout - Menunjukkan berapa lama koneksi dapat tetap terbuka.  Secara default, tidak ada batasan waktu untuk koneksi, koneksi apa pun dapat ditahan untuk waktu yang lama, karena parameter ini -1.  Mengaturnya ke 0 akan menyebabkan setiap koneksi ditutup segera setelah permintaan selesai. </li><li>  ServicePoint.MaxIdleTime - Menunjukkan setelah berapa lama tidak aktif koneksi akan ditutup.  Kelambanan berarti tidak ada transfer data melalui koneksi.  Secara default, nilai parameter ini adalah 100 detik (100000). </li></ul><br>  Sekarang, untuk meningkatkan pemahaman tentang parameter-parameter ini, kami akan menggabungkan semuanya dalam satu skenario.  Misalkan tidak ada yang mengubah DnsRefreshTimeout dan MaxIdleTime dan masing-masing 120 dan 100 detik.  Dengan ini, ConnectionLeaseTimeout diatur ke 60 detik.  Aplikasi hanya membangun satu koneksi, yang melaluinya mengirim permintaan setiap 10 detik. <br><br>  Dengan pengaturan ini, koneksi akan ditutup setiap 60 detik (ConnectionLeaseTimeout), meskipun secara berkala mentransfer data.  Penutupan dan penciptaan kembali akan dilakukan sedemikian rupa sehingga tidak mengganggu pelaksanaan permintaan yang benar - jika waktunya habis, dan saat ini permintaan masih dieksekusi, koneksi akan ditutup setelah permintaan selesai.  Setiap kali koneksi dibuat ulang, alamat IP yang sesuai akan diambil dari cache terlebih dahulu, dan hanya jika resolusinya telah berakhir (120 detik), sistem akan mengirim permintaan ke server DNS. <br><br>  Parameter MaxIdleTime tidak akan memainkan peran dalam skenario ini, karena koneksi belum menganggur selama lebih dari 10 detik. <br><br>  Rasio optimal dari parameter-parameter ini sangat tergantung pada situasi spesifik dan persyaratan non-fungsional: <br><br><ul><li>  Jika Anda tidak berniat untuk berpindah alamat IP secara transparan di belakang nama domain yang diakses aplikasi Anda, dan pada saat yang sama Anda perlu meminimalkan biaya koneksi jaringan, maka pengaturan default terlihat seperti pilihan yang baik. </li><li>  Jika ada kebutuhan untuk beralih antara alamat IP jika terjadi kegagalan, Anda dapat mengatur DnsRefreshTimeout ke 0, dan ConnectionLeaseTimeout ke nilai non-negatif yang cocok untuk Anda.  Yang mana secara spesifik tergantung pada seberapa cepat Anda perlu beralih ke IP lain.  Jelas, Anda ingin memiliki respons tercepat yang mungkin terhadap kegagalan, tetapi di sini Anda perlu menemukan nilai optimal, yang, di satu sisi, memberikan waktu switching yang dapat diterima, di sisi lain, tidak menurunkan throughput sistem dan waktu respons dengan menghubungkan kembali terlalu sering. <br></li><li>  Jika Anda memerlukan reaksi secepat mungkin untuk mengubah alamat IP, misalnya, seperti dalam hal menyeimbangkan melalui DNS round-robin, Anda dapat mencoba mengatur DnsRefreshTimeout dan ConnectionLeaseTimeout ke 0, tetapi ini akan sangat boros: untuk setiap permintaan, server DNS akan disurvei terlebih dahulu, setelah itu Koneksi ke node target akan dibangun kembali. <br></li><li>  Mungkin ada situasi di mana pengaturan ConnectionLeaseTimeout ke 0 dengan DnsRefreshTimeout yang tidak nol dapat berguna, tetapi saya tidak dapat segera membuat skrip yang sesuai.  Secara logis, ini berarti bahwa untuk setiap permintaan, koneksi akan dibuat lagi, tetapi alamat IP akan diambil dari cache bila memungkinkan. </li></ul><br>  Berikut ini adalah contoh kode yang dapat digunakan untuk mengamati perilaku parameter yang dijelaskan di atas: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); ServicePointManager.DnsRefreshTimeout = <span class="hljs-number"><span class="hljs-number">120000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.MaxIdleTime = <span class="hljs-number"><span class="hljs-number">100000</span></span>; habrServicePoint.ConnectionLeaseTimeout = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { client.GetAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>); }</code> </pre><br>  <i>Saat program pengujian sedang berjalan, Anda dapat menjalankan netstat melalui PowerShell dalam satu lingkaran untuk memantau koneksi yang dibuatnya.</i> <br><br>  Segera harus dikatakan bagaimana mengelola parameter yang dijelaskan dalam .NET Core.  Pengaturan dari ServicePointManager, seperti dalam kasus ConnectionLimit, tidak akan berfungsi.  Core memiliki tipe khusus HTTP handler yang mengimplementasikan dua dari tiga parameter yang dijelaskan di atas - SocketsHttpHandler: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketsHttpHandler(); handler.PooledConnectionLifetime = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">60</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ConnectionLeaseTimeout handler.PooledConnectionIdleTimeout = TimeSpan.FromSeconds(100); // MaxIdleTime var client = new HttpClient(handler);</span></span></code> </pre><br>  Tidak ada parameter yang mengontrol waktu caching catatan DNS di .NET Core.  Kasus uji menunjukkan bahwa caching tidak berfungsi - saat membuat koneksi DNS baru, resolusi dilakukan lagi, jadi untuk operasi normal dalam kondisi ketika nama domain yang diminta dapat beralih di antara alamat IP yang berbeda, cukup atur PooledConnectionLifetime ke nilai yang diinginkan. <br><br>  Selain semuanya, harus dikatakan bahwa semua masalah ini tidak dapat diketahui oleh pengembang dari Microsoft, dan oleh karena itu, dimulai dengan .NET Core 2.1, muncul pabrik klien HTTP yang memungkinkan penyelesaian beberapa di antaranya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-">https://docs.microsoft.com/en- us / dotnet / standard / microservices-architecture / implement-resilient-apps / use-httpclientfactory-factory-to-implement-resilient-http-request</a> .  Selain itu, selain mengelola masa pakai koneksi, komponen baru memberikan peluang untuk membuat klien yang diketik, serta beberapa hal berguna lainnya.  Dalam artikel ini dan tautan darinya terdapat cukup informasi dan contoh tentang penggunaan HttpClientFactory, oleh karena itu, saya tidak akan mempertimbangkan rincian yang terkait dengannya di artikel ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424873/">https://habr.com/ru/post/id424873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424861/index.html">Seekor ular di kotak surat dan apa F #</a></li>
<li><a href="../id424865/index.html">Partikel Desain Dasar Ditemukan</a></li>
<li><a href="../id424867/index.html">Pengembangan hexapod dari awal (bagian 1) - desain</a></li>
<li><a href="../id424869/index.html">Bagaimana fitur iOS 12 yang baru mengingatkan saya bahwa sudah waktunya untuk sembuh</a></li>
<li><a href="../id424871/index.html">Elon Musk dan Tesla menyelesaikan litigasi dengan Komisi Sekuritas dan Bursa AS</a></li>
<li><a href="../id424877/index.html">Sistem pendingin rem fluida</a></li>
<li><a href="../id424879/index.html">Ketersediaan Antarmuka Kuliah Yandex</a></li>
<li><a href="../id424881/index.html">Newtoo - mengembangkan mesin browser penuh dari awal pada tahun 2018?</a></li>
<li><a href="../id424887/index.html">Apa yang dibungkam Lida: awal karier seorang pengembang. Prinsip atau cara menjadi Middl</a></li>
<li><a href="../id424889/index.html">Melihat ke dalam coprocessor Intel 8087</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>