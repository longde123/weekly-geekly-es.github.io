<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¡ ğŸ”¤ ğŸ§˜ğŸ¼ Mengubah skrip menjadi alat pembelajaran mesin yang indah ğŸ˜ ğŸ§›ğŸ¿ ğŸ’£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami membuat mesin pencari semantik dengan pembelajaran mesin waktu nyata untuk 300 baris kode Python. 



 Pengalaman saya menunjukkan bahwa setiap p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengubah skrip menjadi alat pembelajaran mesin yang indah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473196/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93c/74d/5e2/93c74d5e21ef307e195441e5c1cbddd7.gif" width="640" height="360"></div>  <em>Kami membuat mesin pencari semantik dengan pembelajaran mesin waktu nyata untuk 300 baris kode Python.</em> <br><br><p>  Pengalaman saya menunjukkan bahwa setiap proyek pembelajaran mesin yang lebih atau kurang kompleks cepat atau lambat akan berubah menjadi seperangkat alat internal yang kompleks tidak didukung.  Alat-alat ini biasanya merupakan campuran skrip dari Jupyter Notebooks and Flask, yang sulit untuk digunakan dan diintegrasikan dengan solusi seperti sesi GPU Tensorflow. </p><br><p>  Saya pertama kali menemukan ini di Universitas Carnegie, kemudian di Berkeley, di Google X, dan akhirnya, ketika membuat robot mandiri di Zoox.  Alat-alat lahir dalam bentuk notebook Jupyter kecil: utilitas kalibrasi sensor, layanan simulasi, aplikasi LIDAR, utilitas scripting, dll. </p><br><p>  Dengan semakin pentingnya alat, manajer muncul.  Birokrasi tumbuh.  Persyaratan meningkat.  Proyek-proyek kecil berubah menjadi mimpi buruk yang aneh. </p><br><a name="habracut"></a><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3f/f43/ec4/b3ff43ec42afca678052b28289f4fb5c.png" width="2230" height="1256"></div>  <em>Siklus: <strong>1.</strong> Jelajahi di Jupyter <strong>2.</strong> Salin-tempel ke skrip Python <strong>3.</strong> Tulis aplikasi Flask dengan HTML, JS dan banyak lagi <strong>4.</strong> Tambahkan lebih banyak fungsi.</em>  <em><strong>//</strong> Masalah dukungan dimulai sejak langkah <strong>3</strong></em> <br><br><p>  Ketika alat menjadi kritis, kami <strong>melibatkan tim untuk membuat alat</strong> .  Mereka menggunakan Vue dan Bereaksi.  Laptop mereka ditutupi dengan stiker dari konferensi kerangka deklaratif.  Mereka memiliki proses debug sendiri: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/2e2/646/e7f2e26469b28af150220825d58ad34e.png" width="2228" height="1254"></div>  <em>Proses yang disederhanakan: <strong>1.</strong> Kumpulan persyaratan <strong>2.</strong> Templat untuk komponen reaktif <strong>3.</strong> Membuat aplikasi dalam HTML, CSS, Python, Bereaksi, dll.</em>  <em><strong>4.</strong> Sebulan kemudian: "Aplikasi sudah siap, kami dapat memperbaruinya dalam beberapa bulan."</em>  <em><strong>//</strong> Setelah langkah <strong>4,</strong> pekerjaan bergerak dengan kecepatan kura-kura</em> <br><br><p>  Prosesnya luar biasa.  Berikut adalah alat yang muncul setiap minggu.  Dan tim alat mendukung sepuluh proyek lainnya.  Menambahkan fungsi baru butuh waktu berbulan-bulan. </p><br><p>  Jadi kami kembali membuat alat sendiri, menyebarkan aplikasi Flask, menulis HTML, CSS dan JavaScript, dan mencoba untuk porting semua ini dari Jupyter sambil menjaga gaya.  Jadi teman lama Google X saya Thiago Teheheira dan saya mulai merenungkan pertanyaan: <strong>Bagaimana jika kita dapat membuat alat semudah kita menulis skrip dengan Python?</strong> </p><br><p>  Kami ingin spesialis pembelajaran mesin dapat membuat aplikasi yang elegan tanpa melibatkan tim untuk membuat alat.  Alat internal seharusnya tidak menjadi tujuan itu sendiri, tetapi produk sampingan dari bekerja dengan ML.  Menulis utilitas harus dirasakan sebagai bagian dari pekerjaan melatih jaringan saraf atau melakukan analisis di Jupyter!  Tetapi pada saat yang sama, kami ingin memiliki fleksibilitas dan kekuatan kerangka kerja web.  Sebenarnya, kami menginginkan sesuatu seperti ini: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d07/8fc/e8a/d078fce8af76aa09bdf9334264f8cfff.png" width="2050" height="1152"></div>  <em>Proses bekerja di Streamlit: <strong>1.</strong> Tambahkan beberapa panggilan ke API dalam skrip Anda <strong>2.</strong> Alat yang indah siap!</em> <br><br><p>  Dengan bantuan komunitas insinyur luar biasa dari Uber, Twitter, Stitch Fix, dan Dropbox, kami mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Streamlit</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sepanjang</a> tahun ini - kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open source gratis</a> untuk membantu pekerja pembelajaran mesin.  Dengan setiap iterasi berikutnya, prinsip-prinsip pada inti Streamlit menjadi lebih sederhana.  Inilah tujuan kami: </p><br><p>  <strong># 1: Gunakan pengetahuan Python.</strong>  Aplikasi Streamlit adalah skrip yang dijalankan dari atas ke bawah.  Tidak ada kondisi tersembunyi di dalamnya.  Jika Anda dapat menulis dengan Python, Anda dapat membuat aplikasi dalam Streamlit.  Begini cara layar ditampilkan: </p><br><pre><code class="plaintext hljs">import streamlit as st st.write('Hello, world!')</code> </pre> <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2df/ded/9d8/2dfded9d8aa35e0672169e19872cf1cf.png" width="1272" height="736"></div>  <em>Kenalan pertama.</em> <br><br><p>  <strong># 2: Pikirkan widget sebagai variabel.</strong>  Tidak ada callback di <em>Streamlit</em> !  Setiap perubahan cukup restart script dari atas ke bawah.  Pendekatan ini memungkinkan Anda untuk menulis pembersih kode: </p><br><pre> <code class="plaintext hljs">import streamlit as st x = st.slider('x') st.write(x, 'squared is', x * x)</code> </pre> <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/34e/f58/86f34ef58ebccefc2aa109a01db6aa91.png" width="1192" height="946"></div>  <em>Aplikasi interaktif dalam tiga baris kode.</em> <br><br><p>  <strong># 3: Gunakan data dan perhitungan berulang kali.</strong>  Bagaimana jika Anda mengunduh banyak data untuk melakukan perhitungan yang panjang?  Maka penting untuk menggunakannya kembali di antara restart.  Streamlit memiliki primitif untuk caching persisten kondisi default tidak berubah.  Jadi, misalnya, kode di bawah ini mengunduh data dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek Udacity</a> pada mobil yang dikelola sendiri, menghasilkan aplikasi yang sederhana dan indah: </p><br><pre> <code class="plaintext hljs">import streamlit as st import pandas as pd # Reuse this data across runs! read_and_cache_csv = st.cache(pd.read_csv) BUCKET = "https://streamlit-self-driving.s3-us-west-2.amazonaws.com/" data = read_and_cache_csv(BUCKET + "labels.csv.gz", nrows=1000) desired_label = st.selectbox('Filter to:', ['car', 'truck']) st.write(data[data.label == desired_label])</code> </pre> <br><p>  <em>Untuk menjalankan kode di atas, ikuti instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> .</em> </p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/820/a6f/5a8820a6fd9e42a2fea9927462cf2cf8.png" width="1476" height="1490"></div>  <em>Dan di sini adalah bagaimana hasilnya akan terlihat.</em> <br><br><p>  Singkatnya, Streamlit berfungsi seperti ini: </p><br><ol><li>  Script dijalankan kembali setiap waktu </li><li>  Streamlit memberikan setiap variabel nilai saat ini dari widget. </li><li>  Caching menghindari akses jaringan yang tidak perlu atau penghitungan ulang yang panjang. </li></ol><br><p>  Pekerjaan Streamlit dalam gambar: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/c00/bad/ea3c00bad7de1ac56628a95f7b78d9e6.png" width="2232" height="1254"></div>  <em>Input pengguna mulai ulang skrip.</em>  <em>Di antara restart, hanya cache yang disimpan.</em> <br><br><p>  Apakah Anda tertarik?  Kalau begitu cobalah sendiri!  Jalankan: </p><br><pre> <code class="plaintext hljs">$ pip install --upgrade streamlit $ streamlit hello     .  URL: http://localhost:8501  URL: http://10.0.1.29:8501</code> </pre> <br><p>  Kode ini akan membuka aplikasi Streamlit di browser.  Jika ini tidak terjadi, klik saja tautannya. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/e32/945/41de32945b70f463438626934c3e7049.png" width="2414" height="1978"></div>  <em>Untuk melihat lebih banyak contoh seperti animasi fraktal ini, jalankan saja <strong>streamlit hello</strong> dari baris perintah.</em> <br><br><hr><br><p>  Tidak cukup bermain dengan fraktal?  Hati-hati, fraktal dapat menempel dalam waktu yang lama. </p><br><p>  Kesederhanaan contoh tidak boleh menyesatkan: Anda dapat membuat aplikasi besar di Streamlit.  Bekerja di Zoox dan Google X, saya melihat bagaimana proyek otomobil mandiri meningkat hingga gigabytes data visual yang perlu ditemukan dan diproses, termasuk menguji berbagai model untuk membandingkan kinerja.  Setiap proyek kecil pada mesin self-driving cepat atau lambat tumbuh dengan ukuran membutuhkan tim pengembangan yang terpisah. </p><br><p>  Tetapi dengan Streamlit, membuat aplikasi seperti itu sepele.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut ini adalah demo di Streamlit</a> , di mana pencarian semantik penuh diimplementasikan di seluruh array data <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Udacity untuk mesin self-driving</a> , visualisasi label orang yang diberi catatan dan <strong>peluncuran jaringan saraf penuh (</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>YOLO</strong></a> <strong>) secara real-time</strong> di dalam aplikasi yang sama [1]. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/207/eac/f29/207eacf298f38250fc29565bed9d2bd7.gif" width="700" height="394"></div>  <em>Demo 300-line pada Streamlit ini menggabungkan pencarian semantik dengan hasil real-time dari jaringan saraf.</em> <br><br><p>  Aplikasi ini sepenuhnya mandiri, sebagian besar dari 300 baris adalah pembelajaran mesin.  Selain itu, API Streamlit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hanya</a> disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">23 kali</a> .  Coba sendiri! </p><br><pre> <code class="plaintext hljs">$ pip install --upgrade streamlit opencv-python $ streamlit run https://raw.githubusercontent.com/streamlit/demo-self-driving/master/app.py</code> </pre> <br><hr><br><p>  Dalam proses bekerja dengan tim pembelajaran mesin, kami menyadari bahwa beberapa ide sederhana berhasil dengan baik: </p><br><p>  <strong>Aplikasi Streamlit adalah file Python biasa.</strong>  Jadi, Anda dapat menggunakan editor favorit Anda untuk mengembangkan seluruh aplikasi. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0a/300/2ca/e0a3002caa1e4bfdd3512067d2bcb362.png" width="1600" height="1000"></div>  <em>Alur kerja saya dengan Streamlit mencakup VSCode di sebelah kiri dan Chrome di sebelah kanan.</em> <br><br><p>  <strong>Skrip bersih disimpan tanpa masalah di Git</strong> atau sistem kontrol versi lainnya.  Bekerja dengan python murni, Anda mendapatkan kumpulan besar alat yang siap pakai untuk pengembangan sebagai sebuah tim. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9b/80f/386/f9b80f38638733921e5d21821707c1d9.png" width="1600" height="1490"></div>  <em>Aplikasi Streamlit sepenuhnya dihosting di Git.</em> <br><br><p>  <strong>Streamlit adalah lingkungan pengkodean respons instan.</strong>  Cukup klik <em>Selalu jalankan kembali</em> ketika Streamlit melihat perubahan pada file sumber. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a9/db2/1bc/1a9db21bcd28f2b5ae8abf330ef7ad08.png" width="1220" height="680"></div>  <em>Klik "Selalu jalankan kembali" untuk pengkodean respons instan.</em> <br><br><p>  <strong>Caching sangat menyederhanakan pekerjaan dengan rantai perhitungan.</strong>  Menggabungkan beberapa hasil caching berfungsi dengan baik sebagai saluran pipa yang efisien untuk komputasi!  Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode ini yang</a> diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo Udacity</a> : </p><br><pre> <code class="plaintext hljs">import streamlit as st import pandas as pd @st.cache def load_metadata(): DATA_URL = "https://streamlit-self-driving.s3-us-west-2.amazonaws.com/labels.csv.gz" return pd.read_csv(DATA_URL, nrows=1000) @st.cache def create_summary(metadata, summary_type): one_hot_encoded = pd.get_dummies(metadata[["frame", "label"]], columns=["label"]) return getattr(one_hot_encoded.groupby(["frame"]), summary_type)() # Piping one st.cache function into another forms a computation DAG. summary_type = st.selectbox("Type of summary:", ["sum", "any"]) metadata = load_metadata() summary = create_summary(metadata, summary_type) st.write('## Metadata', metadata, '## Summary', summary)</code> </pre> <br><p>  <em>Pipeline untuk komputasi Streamlit.</em>  <em>Untuk menjalankan skrip, ikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> ini.</em> </p><br><br><p>  Faktanya, pipeline adalah load_metadata -&gt; create_summary.  Setiap kali skrip dijalankan, <strong>Streamlit hanya menceritakan apa yang dibutuhkan untuk hasil yang benar</strong> .  Keren! </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/0d3/893/ed90d389327556740d2dffc2ba425b96.png" width="2056" height="920"></div>  <em>Untuk kinerja maksimum, Streamlit hanya menceritakan apa yang benar-benar diperlukan untuk memperbarui UI.</em> <br><br><p>  <strong>Streamlit dirancang untuk bekerja dengan GPU.</strong>  Streamlit memungkinkan Anda untuk bekerja secara langsung dengan TensorFlow, PyTorch dan perpustakaan serupa lainnya.  Misalnya, dalam demo ini, cache Streamlit menyimpan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GAN selebritas dari NVIDIA</a> [2].  Ini memungkinkan Anda untuk mencapai respons yang hampir instan ketika mengubah nilai-nilai slider. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e1/4ad/510/4e14ad510088b54615cdb7cb20c2099c.gif" width="700" height="394"></div>  Aplikasi Streamlit menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GAN wajah selebriti dari NVIDIA</a> [2] menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TL-GAN Shaobo Guan</a> [3]. <br><p>  <strong>Streamlit adalah proyek sumber terbuka</strong> .  Anda dapat dengan bebas mendistribusikan aplikasi di Streamlit tanpa meminta izin kepada kami.  Anda bahkan dapat menjalankan aplikasi di Streamlit secara lokal tanpa koneksi internet!  Dan proyek yang ada dapat mengimplementasikan Streamlit secara bertahap. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/b16/fb4/a31b16fb4e11f0edfec0e6c336a68278.png" width="2060" height="1158"></div>  <em>Beberapa cara untuk menggunakan Streamlit.</em>  <em>(Ikon diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fullvector / Freepik</a> .)</em> <br><br><hr><br><p>  Dan ini hanya gambaran umum tentang fitur Streamlit.  Salah satu aspek paling keren dari perpustakaan adalah kemudahan menggabungkan primitif ke dalam aplikasi besar.  Kami memiliki banyak informasi tentang infrastruktur dan rencana Streamlit untuk masa depan, tetapi kami akan menyimpannya untuk publikasi di masa mendatang. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/637/945/75c/63794575c702631cdac92eb4cee92b6c.png" width="2228" height="1254"></div>  <em>Diagram komponen streamlit.</em>  <em>Tunggu publikasi selanjutnya!</em> <br><br><p>  Kami senang berbagi Streamlit dengan dunia dan kami berharap dengan itu skrip Python ML Anda akan berubah menjadi aplikasi lengkap yang indah. </p><br><hr><br><p>  <strong>Referensi:</strong> </p><br><p>  [1] J. Redmon dan A. Farhadi, <em>YOLOv3: An Incremental Improvement</em> (2018), arXiv. </p><br><p>  [2] T. Karras, T. Aila, S. Laine, dan J. Lehtinen, <em>Pertumbuhan Progresif GAN untuk Peningkatan Kualitas, Stabilitas, dan Variasi</em> (2018), ICLR. </p><br><p>  [3] S. Guan, <em>Controlled image synthesis and editing menggunakan novel TL-GAN model</em> (2018), Insight Data Science Blog. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473196/">https://habr.com/ru/post/id473196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473184/index.html">Docker + php-fpm + PhpStorm + Xdebug</a></li>
<li><a href="../id473186/index.html">Tata letak elemen yang tidak biasa pada flexbox tanpa permintaan media</a></li>
<li><a href="../id473190/index.html">Proyek metformin TAME: pendapat dibagi</a></li>
<li><a href="../id473192/index.html">Listrik dapat diperoleh dari salju.</a></li>
<li><a href="../id473194/index.html">Intisari telekomunikasi: tentang pembangunan jaringan operator, protokol Internet, dan keamanan informasi</a></li>
<li><a href="../id473198/index.html">Pengemudi motor stepper. Menguji chip L9110</a></li>
<li><a href="../id473200/index.html">Agresi permainan, atau bagaimana koperasi berubah menjadi pemandian darah dan apa yang harus dilakukan untuk mencegahnya terjadi</a></li>
<li><a href="../id473202/index.html">Menguji lokalisasi game mobile untuk boneka dari teko</a></li>
<li><a href="../id473206/index.html">Diskusi: bagaimana layanan streaming mengubah budaya musik dan pendekatan penulisan lagu</a></li>
<li><a href="../id473208/index.html">Bagaimana saya menyederhanakan proses pengerjaan proyek sumber terbuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>