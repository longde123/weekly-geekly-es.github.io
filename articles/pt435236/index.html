<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé§ üé® üà≥ Byte-machine para o forte (e n√£o apenas) no nativo americano (parte 3) üë®üèø‚Äçüè≠ üë©üèæ‚Äç‚öñÔ∏è üö∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chegou o ano de 2019. As f√©rias de ano novo est√£o chegando ao fim. √â hora de come√ßar a lembrar de bytes, comandos, vari√°veis, loops ... 

 Algo que eu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Byte-machine para o forte (e n√£o apenas) no nativo americano (parte 3)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435236/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="imagem"><br><br>  Chegou o ano de 2019. As f√©rias de ano novo est√£o chegando ao fim.  √â hora de come√ßar a lembrar de bytes, comandos, vari√°veis, loops ... <br><br>  Algo que eu j√° esqueci com essas f√©rias.  Tem que lembrar juntos! <br><br>  Hoje vamos criar um int√©rprete para nossa m√°quina de bytes.  Este √© o terceiro artigo, as primeiras partes est√£o aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte 2</a> . <br><br>  Feliz Ano Novo para todos, e bem-vindo ao corte! <br><a name="habracut"></a><br>  Para come√ßar, responderei √†s perguntas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">fpauk</a> .  Essas perguntas est√£o absolutamente corretas.  Agora a arquitetura desta m√°quina de bytes √© tal que trabalhamos com endere√ßos diretos do processador.  Mas no bytecode esses endere√ßos n√£o s√£o, eles s√£o formados ap√≥s o in√≠cio do sistema.  Ap√≥s o in√≠cio do sistema, podemos criar qualquer ponteiro, e esse c√≥digo funcionar√° corretamente em qualquer plataforma.  Por exemplo, o endere√ßo de uma vari√°vel ou matriz pode ser obtido com o comando var0.  Este comando funcionar√° em qualquer plataforma e retornar√° o endere√ßo correto espec√≠fico para esta plataforma.  Ent√£o voc√™ pode trabalhar com este endere√ßo como quiser. <br><br>  Mas ainda assim, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">fpauk est√°</a> certo.  O endere√ßo n√£o pode ser armazenado no bytecode.  Acontece que podemos escrever c√≥digo independente de plataforma, mas para isso precisamos fazer alguns esfor√ßos.  Em particular, verifique se os endere√ßos n√£o est√£o no bytecode.  E eles podem entrar, por exemplo, se voc√™ salvar o c√≥digo compilado em um arquivo.  Ele conter√° dados e pode ser endere√ßos.  Por exemplo, os valores das vari√°veis ‚Äã‚Äãaqui, contexto e outras. <br><br>  Para se livrar desse problema, voc√™ precisa tornar os endere√ßos virtuais.  O endere√ßamento do processador x86 √© bastante poderoso e, na maioria dos casos, nem adiciona comandos extras.  Mas ainda assim, continuarei na arquitetura atual, com endere√ßos absolutos.  E ent√£o, quando chegarmos aos testes, ser√° poss√≠vel refazer os endere√ßos em endere√ßos virtuais e ver como isso afetar√° o desempenho.  Isso √© interessante. <br><br><h4>  Aquecer </h4><br>  E agora um pouco de treino.  Vamos criar outra parte dos comandos de bytes pequenos, mas √∫teis.  Esses ser√£o os comandos nip, emit, 1+, +!, -!, Count, palavras de trabalho com a pilha de retorno r&gt;,&gt; r, r @, uma string literal (") e palavras constantes 1, 2, 3, 4, 8. N√£o esque√ßa de inclu√≠-los na tabela de comandos. <br><br><div class="spoiler">  <b class="spoiler_title">Aqui est√° o c√≥digo para esses comandos</b> <div class="spoiler_text"><pre><code class="cpp hljs">b_nip = <span class="hljs-number"><span class="hljs-number">0x39</span></span> bcmd_nip: pop rax mov [rsp], rax jmp _next b_emit = <span class="hljs-number"><span class="hljs-number">0x81</span></span> bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rdx, <span class="hljs-number"><span class="hljs-number">1</span></span> #   push r8 syscall #   pop r8 jmp _next b_wp = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_wp: incq [rsp] jmp _next b_setp = <span class="hljs-number"><span class="hljs-number">0x48</span></span> bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = <span class="hljs-number"><span class="hljs-number">0x49</span></span> bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = <span class="hljs-number"><span class="hljs-number">0x60</span></span> bcmd_2r: pop rax sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], rax jmp _next b_r2 = <span class="hljs-number"><span class="hljs-number">0x61</span></span> bcmd_r2: push [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next b_rget = <span class="hljs-number"><span class="hljs-number">0x62</span></span> bcmd_rget: push [rbp] jmp _next b_str = <span class="hljs-number"><span class="hljs-number">0x82</span></span> bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + <span class="hljs-number"><span class="hljs-number">1</span></span>] jmp _next b_count = <span class="hljs-number"><span class="hljs-number">0x84</span></span> bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_num1 = <span class="hljs-number"><span class="hljs-number">0x03</span></span> bcmd_num1: push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next b_num2 = <span class="hljs-number"><span class="hljs-number">0x04</span></span> bcmd_num2: push <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_num3 = <span class="hljs-number"><span class="hljs-number">0x05</span></span> bcmd_num3: push <span class="hljs-number"><span class="hljs-number">3</span></span> jmp _next b_num4 = <span class="hljs-number"><span class="hljs-number">0x06</span></span> bcmd_num4: push <span class="hljs-number"><span class="hljs-number">4</span></span> jmp _next b_num8 = <span class="hljs-number"><span class="hljs-number">0x07</span></span> bcmd_num8: push <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br></div></div><br>  O comando nip remove a palavra abaixo da parte superior da pilha.  √â equivalente a trocar comandos drop.  √Äs vezes, isso pode ser √∫til. <br><br>  O comando emit empurra um caractere da pilha.  Ele usa o mesmo n√∫mero de chamada do sistema 1, o caractere coloca em um buffer com o comprimento 1. <br><br>  O comando count √© muito simples - pega o endere√ßo da linha com o contador da pilha e o transforma em dois valores - o endere√ßo da linha sem o contador e o comprimento. <br><br>  Os comandos b_2r, b_r2, b_rget s√£o as palavras Fort r&gt;,&gt; r, r @.  O primeiro pega a palavra da pilha de retorno e a coloca na pilha aritm√©tica.  O segundo realiza a opera√ß√£o oposta.  O terceiro copia a palavra da pilha de retorno, coloca-a na aritm√©tica, a pilha de retorno n√£o muda. <br><br>  Os comandos b_setp e b_setm s√£o as palavras +!  e -! .. Eles pegam o valor e o endere√ßo da pilha e modificam a palavra no endere√ßo especificado, adicionando ou removendo o valor da pilha. <br><br>  O comando b_str possui um par√¢metro de comprimento arbitr√°rio - uma linha com um contador.  Essa linha est√° no bytecode ap√≥s o byte de comando e o comando simplesmente envia o endere√ßo dessa linha para a pilha.  De fato, esta √© uma string literal. <br><br>  O resto da equipe, acho, n√£o precisa de coment√°rios. <br><br>  Tamb√©m criaremos um comando para imprimir uma string constante (. "). Vamos implement√°-lo como um ponto de entrada para digitar, da seguinte maneira: <br><br><pre> <code class="cpp hljs">b_strp = <span class="hljs-number"><span class="hljs-number">0x83</span></span> bcmd_strp: movsx rax, byte ptr [r8] inc r8 push rax push r8 add r8, rax b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next</code> </pre><br>  Este comando est√° estruturado de forma semelhante ao b_str.  S√≥ que ela n√£o coloca nada na pilha.  A linha localizada atr√°s deste comando como par√¢metro √© simplesmente exibida ao usu√°rio. <br><br>  O aquecimento terminou, chegou a hora de algo mais s√©rio.  Vamos lidar com os geradores de palavras e outros comandos var. <br><br><h4>  Palavras geradoras </h4><br>  Lembre-se das vari√°veis.  Sabemos como eles s√£o organizados no n√≠vel do bytecode (comando var0).  Para criar uma nova vari√°vel, o forte usa a seguinte constru√ß√£o: <br><br><pre> <code class="cpp hljs">variable &lt; &gt;</code> </pre><br>  Ap√≥s executar esta sequ√™ncia, uma nova palavra &lt;nome da vari√°vel&gt; √© criada.  A execu√ß√£o dessa nova palavra pressiona o endere√ßo na pilha para armazenar o valor da vari√°vel.  Tamb√©m existem constantes no forte, elas s√£o criadas assim: <br><br><pre> <code class="cpp hljs">&lt;&gt; constant &lt; &gt;</code> </pre><br>  Depois de criar a constante, a execu√ß√£o da palavra &lt;nome da constante&gt; coloca na pilha &lt;valor&gt;. <br><br>  Portanto, tanto a vari√°vel de palavras quanto a constante de palavras s√£o palavras geradoras.  Eles s√£o projetados para criar novas palavras.  Em um forte, essas palavras s√£o descritas usando a constru√ß√£o create ... does&gt;. <br><br>  Vari√°veis ‚Äã‚Äãe constantes podem ser definidas da seguinte maneira: <br><br><pre> <code class="cpp hljs">: variable create <span class="hljs-number"><span class="hljs-number">0</span></span> , does&gt; ; : constant create , does&gt; @ ;</code> </pre><br>  O que tudo isso significa? <br><br>  A palavra criar, quando executada, cria uma nova palavra com o nome que ser√° usado quando executada a partir do fluxo de entrada.  Ap√≥s a cria√ß√£o, uma sequ√™ncia de palavras √© executada antes da palavra&gt;.  Mas no momento da execu√ß√£o desta palavra, o que √© escrito depois do&gt; √© executado.  Ao mesmo tempo, o endere√ßo de dados j√° estar√° na pilha (como se costuma dizer no forte, ‚Äúcampos de dados‚Äù). <br><br>  Assim, ao criar uma vari√°vel, a sequ√™ncia ‚Äú0‚Äù √© executada - esta √© a reserva de uma palavra de m√°quina com preenchimento zero.  E quando a palavra criada √© executada, nada √© feito (depois de&gt; n√£o h√° nada).  O endere√ßo de mem√≥ria onde o valor √© armazenado simplesmente permanece na pilha. <br><br>  Na defini√ß√£o de uma constante, uma palavra com um valor preenchido na pilha √© reservada.  Quando a palavra criada √© executada, "@" √© executado, que recupera o valor no endere√ßo especificado. <br><br>  Agora vamos pensar em como a palavra que criamos pode ser organizada.  Ele envia o endere√ßo de dados para a pilha (como var0) e transfere o controle para um endere√ßo espec√≠fico, bytecode.  O comando var0 retorna imediatamente.  Mas, neste caso, precisamos fazer n√£o um retorno, mas, de fato, uma transi√ß√£o. <br><br>  Mais uma vez vou formular o que precisa ser feito: <br><br><ul><li>  colocar endere√ßo de dados na pilha </li><li>  pule para um peda√ßo de c√≥digo depois do&gt; </li></ul><br>  Acontece que voc√™ s√≥ precisa transferir o controle para outro endere√ßo de bytecode, mas primeiro coloque o endere√ßo do pr√≥ximo byte (R8) na pilha. <br><br>  √â quase um comando de ramifica√ß√£o!  E aqui ela n√£o est√° sozinha.  J√° tem branch8 e branch16.  Vamos nomear os novos comandos var8 e var16 e deixar que esses sejam apenas os pontos de entrada para os comandos de ramifica√ß√£o.  Economizamos na transi√ß√£o para a equipe de transi√ß√£o :) Ent√£o, ser√° assim: <br><br><pre> <code class="cpp hljs">b_var8 = <span class="hljs-number"><span class="hljs-number">0x29</span></span> bcmd_var8: push r8 b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = <span class="hljs-number"><span class="hljs-number">0x30</span></span> bcmd_var16: push r8 b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre><br>  De uma maneira boa, o comando var32 ainda funcionar√° e o var64 tamb√©m.  N√£o temos transi√ß√µes t√£o longas, pois as transi√ß√µes comuns n√£o s√£o t√£o longas.  Mas para o comando var, este √© um caso muito realista.  Mas, por enquanto, n√£o faremos esses comandos.  Faremos mais tarde, se necess√°rio. <br><br>  Com as palavras-geradores resolvidas.  Foi a vez de decidir sobre o dicion√°rio. <br><br><h4>  Vocabul√°rio </h4><br>  Geralmente, quando eles falam de maneira simplista sobre o dicion√°rio forte, ele √© apresentado na forma de uma lista unidirecional de entradas do dicion√°rio.  De fato, tudo √© um pouco mais complicado, pois o forte suporta muitos dicion√°rios.  De fato, eles s√£o uma √°rvore.  A busca por uma palavra nessa √°rvore come√ßa com uma "folha" - esta √© a √∫ltima palavra no dicion√°rio atual.  O dicion√°rio atual √© definido pela vari√°vel de contexto e o endere√ßo da √∫ltima palavra est√° na palavra do dicion√°rio.  Outra vari√°vel √© usada para gerenciar dicion√°rios - ela define um dicion√°rio onde novas palavras ser√£o adicionadas.  Assim, um dicion√°rio pode ser instalado para uma pesquisa e outro para incluir novas palavras. <br><br>  Para o nosso caso simples, seria poss√≠vel n√£o dar suporte a muitos dicion√°rios, mas decidi n√£o simplificar nada.  De fato, para entender o c√≥digo de bytes, a m√°quina de bytes, n√£o √© necess√°rio saber o que est√° descrito nesta se√ß√£o.  Portanto, quem n√£o est√° interessado, pode simplesmente pular esta se√ß√£o.  Bem, quem quer saber os detalhes - v√° em frente! <br><br>  Inicialmente, h√° um dicion√°rio b√°sico nomeado adiante.  Isso significa que existe tal palavra - adiante.  Esta palavra tamb√©m √© chamada de "dicion√°rio", h√° alguma confus√£o.  Portanto, quando se trata de uma palavra, chamarei de palavra do dicion√°rio. <br><br>  Novos dicion√°rios s√£o criados usando esta constru√ß√£o: <br><br><pre> <code class="cpp hljs">vocabulary &lt;  &gt;</code> </pre><br>  Isso cria uma palavra com o nome &lt;nome do dicion√°rio criado&gt;.  Quando executada, essa palavra definir√° o dicion√°rio criado como o dicion√°rio inicial da pesquisa. <br><br>  De fato, na palavra do dicion√°rio, h√° um link para o √∫ltimo artigo deste dicion√°rio, com o qual a pesquisa come√ßa.  E no momento da execu√ß√£o, essa palavra do dicion√°rio grava um link para seu campo de dados na vari√°vel de contexto. <br><br>  Mais tarde, ser√° poss√≠vel fazer o vocabul√°rio da palavra, que no forte, na implementa√ß√£o atual, √© descrito de maneira bastante simples: <br><br><pre> <code class="cpp hljs">: vocabulary create context @ , does&gt; context ! ;</code> </pre><br>  Ent√£o, crie a palavra adiante.  Vamos usar o comando var8.  Bytecode "contexto!"  coloque logo ap√≥s o campo de dados: <br><br><pre> <code class="cpp hljs">forth: .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # &lt;--      .      ,    -    . does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  Agora, de volta √† cria√ß√£o do pr√≥prio dicion√°rio. <br><br>  Em geral, em um forte, a descri√ß√£o de uma palavra na mem√≥ria √© chamada de "entrada de dicion√°rio".  Em termos comuns, eu diria que existe um t√≠tulo para o artigo e seu c√≥digo.  Mas nem tudo √© muito usual em um forte: l√° √© chamado de "campo de nome", "campo de comunica√ß√£o", "campo de c√≥digo" e "campo de dados".  Vou tentar lhe dizer o que tudo isso significa em termos tradicionais. <br><br>  O campo de nome √© o nome da palavra "linha com um contador".  √â como no pascal antigo - byte do comprimento da string e depois na string.  O campo link √© um link para o artigo anterior.  Anteriormente, havia apenas um endere√ßo, mas teremos um c√≥digo independente de plataforma, e isso ser√° um deslocamento.  O campo de c√≥digo, tradicionalmente no forte, √© o c√≥digo da m√°quina (quando a implementa√ß√£o est√° em uma linha direta), para palavras fora do kernel havia a chamada _call.  Teremos apenas um bytecode.  E o campo de dados √© para palavras que cont√™m dados - por exemplo, para vari√°veis ‚Äã‚Äãou constantes.  A prop√≥sito, o dicion√°rio de palavras tamb√©m se refere a ele. <br><br>  Para o compilador, ainda precisamos de sinalizadores.  Geralmente, um forte precisa de apenas uma bandeira - imediata, e √© colocada em um byte longo (√†s vezes h√° outra - oculta).  Mas isso √© para c√≥digo costurado direto, onde o controle do processador √© transferido quando chamado para o campo de c√≥digo.  E temos palavras diferentes - bytecode e c√≥digo de m√°quina, e pelo menos dois ou mesmo tr√™s sinalizadores s√£o necess√°rios. <br><br>  Quanto √© necess√°rio para o campo da comunica√ß√£o?  No come√ßo, eu queria usar 16 bits.  Este √© um link para a palavra anterior, e a palavra √© definitivamente menor que 64 Kb.  Mas ent√£o lembrei que a palavra pode conter dados de quase qualquer tamanho.  Al√©m disso, na presen√ßa de v√°rios dicion√°rios, o link pode passar por muitas palavras.  Acontece que, na maioria dos casos, 8 bits s√£o suficientes, mas podem haver 16 e 32. E at√© 64 bits, se houver dados com mais de 4 GB.  Bem, vamos dar suporte a todas as op√ß√µes.  Qual op√ß√£o √© usada - coloque as bandeiras.  Acontece pelo menos 4 sinalizadores: o atributo imediato, o atributo da palavra principal e 2 bits por variante do campo de comunica√ß√£o usado.  √â necess√°rio usar um byte separado para sinalizadores, de nenhuma outra maneira. <br><br>  Definimos os sinalizadores da seguinte maneira: <br><br><pre> <code class="cpp hljs">f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span></code> </pre><br>  O sinalizador f_code ser√° para palavras do kernel escritas em assembler, o sinalizador f_immediate ser√° √∫til para o compilador, sobre isso no pr√≥ximo artigo.  E os dois bits menos significativos determinar√£o o comprimento do campo de comunica√ß√£o (1, 2, 4 ou 8 bytes). <br><br>  Portanto, o t√≠tulo do artigo ser√° assim: <br><br><ul><li>  sinalizadores (1 byte) </li><li>  campo de comunica√ß√£o (1-8 bytes) </li><li>  nome comprimento byte </li><li>  nome (1-255 bytes) </li></ul><br>  At√© o momento, n√£o usei os recursos do assembler "macro".  E agora precisamos deles.  √â assim que eu tenho uma macro com o item de nome para formar o t√≠tulo da palavra: <br><br><pre> <code class="cpp hljs">.macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = . - p_item <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad . - p_item .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br>  Essa macro usa o valor p_item - este √© o endere√ßo da entrada anterior do dicion√°rio.  Este valor no final √© atualizado para uso futuro: p_item = 9b.  Aqui 9b √© um r√≥tulo, n√£o um n√∫mero, n√£o confunda :) A macro possui dois par√¢metros - o nome da palavra e os sinalizadores (opcional).  No in√≠cio da macro, o deslocamento para a palavra anterior √© calculado.  Ent√£o, dependendo do tamanho do deslocamento, os sinalizadores e o campo de comunica√ß√£o do tamanho desejado s√£o compilados.  Em seguida, o byte do comprimento do nome e o pr√≥prio nome. <br><br>  Defina antes da primeira palavra p_item da seguinte maneira: <br><br><pre> <code class="cpp hljs">p_item = .</code> </pre><br>  O ponto √© o endere√ßo de compila√ß√£o atual no assembler.  Como resultado dessa defini√ß√£o, a primeira palavra se referir√° a si mesma (o campo de comunica√ß√£o ser√° 0).  Este √© um sinal do fim dos dicion√°rios. <br><br>  A prop√≥sito, o que haver√° no campo de c√≥digo das palavras do kernel?  No m√≠nimo, voc√™ deve salvar o c√≥digo de comando em algum lugar.  Eu decidi seguir o caminho mais simples.  Para palavras do kernel, tamb√©m haver√° um bytecode.  Para a maioria das equipes, este ser√° apenas um comando de byte, seguido de b_exit.  Portanto, para o int√©rprete, o sinalizador f_code n√£o precisa ser analisado e os comandos para ele n√£o ser√£o diferentes de forma alguma.  Voc√™ s√≥ precisa chamar o bytecode para todos. <br><br>  H√° outra vantagem nessa op√ß√£o.  Para comandos com par√¢metros, voc√™ pode especificar par√¢metros seguros.  Por exemplo, se voc√™ chamar o comando aceso nas implementa√ß√µes do Fort com c√≥digo de costura direta, o sistema falhar√°.  E aqui est√° escrito l√°, por exemplo, acende 0, e essa sequ√™ncia simplesmente coloca 0 na pilha.  Mesmo para o ramo pode ser feito com seguran√ßa! <br><br><pre> <code class="cpp hljs"> .byte branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit</code> </pre><br>  Com essa liga√ß√£o, haver√° alguma sobrecarga, mas para o int√©rprete, elas n√£o ser√£o significativas.  E o compilador analisar√° os sinalizadores e compilar√° o c√≥digo correto e r√°pido. <br><br>  A primeira palavra, √© claro, ser√° a palavra "adiante" - o vocabul√°rio b√°sico que estamos criando.  Aqui, apenas venha com o pr√°tico comando var com um link para o c√≥digo depois do&gt;.  Eu j√° citei esse c√≥digo na se√ß√£o anterior, mas vou repeti-lo novamente, com o t√≠tulo: <br><br><pre> <code class="cpp hljs">p_item = . item forth .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  E imediatamente criaremos as vari√°veis ‚Äã‚Äãde contexto e, precisamos delas para procurar palavras: <br><br><pre> <code class="cpp hljs"> item .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  E agora, voc√™ precisa ser paciente e escrever um t√≠tulo para cada palavra que escrevemos no assembler com o sinalizador f_code: <br><br><pre> <code class="cpp hljs"> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit ... item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit</code> </pre><br>  E assim por diante ... <br><br>  Com equipes escritas em bytecode √© ainda mais f√°cil.  Basta adicionar apenas um cabe√ßalho antes do bytecode, assim como a palavra adiante, por exemplo: <br><br><pre> <code class="cpp hljs"> item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint ...</span></span></code> </pre><br>  Para comandos com par√¢metros, criaremos par√¢metros seguros.  Por exemplo, deixe que os comandos lite retornem o n√∫mero Pi, se algu√©m os chamar de forma interativa, haver√° uma p√°scoa :) <br><br><pre> <code class="cpp hljs"> item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926535</span></span> .byte b_exit</code> </pre><br>  A √∫ltima palavra da lista far√° com que a palavra se adeque simbolicamente.  Mas ainda precisamos inicializar o endere√ßo dessa palavra no campo de dados adiante.  Para obter o endere√ßo dessa palavra, use o comando var0: <br><br><pre> <code class="cpp hljs">last_item: .byte b_var0 item bye, f_code .byte b_bye</code> </pre><br>  Nesse design, se chamarmos o endere√ßo last_item no bytecode, obteremos o endere√ßo da palavra bye.  Para escrev√™-lo nos campos de dados da palavra adiante, execute-o e o endere√ßo desejado estar√° em contexto.  Assim, o c√≥digo de inicializa√ß√£o do sistema ser√° assim: <br><br><pre> <code class="cpp hljs">forth last_item context @ !</code> </pre><br>  E agora vamos prosseguir diretamente para o int√©rprete.  Primeiro, precisamos trabalhar com o buffer de entrada e extrair palavras dele.  Deixe-me lembr√°-lo que o int√©rprete no forte √© muito simples.  Ele extrai as palavras do buffer de entrada em sequ√™ncia, tenta encontr√°-las.  Se a palavra for encontrada, o int√©rprete a inicia para execu√ß√£o. <br><br><h4>  Buffer de entrada e extra√ß√£o de palavras </h4><br>  Para ser sincero, n√£o quero gastar muito tempo estudando os padr√µes do forte.  Mas ainda vou tentar torn√°-lo o mais pr√≥ximo poss√≠vel deles, principalmente de mem√≥ria.  Se os especialistas do forte perceberem uma forte discrep√¢ncia aqui - escreva, eu corrigirei. <br><br>  O forte possui tr√™s vari√°veis ‚Äã‚Äãpara trabalhar com o buffer: tib, #tib e&gt; in.  A vari√°vel tib envia o endere√ßo do buffer de entrada na pilha.  A vari√°vel #tib envia o n√∫mero de caracteres que est√£o no buffer para a pilha.  E a vari√°vel&gt; in cont√©m o deslocamento no buffer de entrada, al√©m do qual o texto bruto est√° localizado.  Defina essas vari√°veis. <br><br><pre> <code class="cpp hljs"> item tib .byte b_var0 v_tib: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-meta"><span class="hljs-meta">#tib .byte b_var0 v_ntib: .quad 0 item &gt;in .byte b_var0 v_in: .quad 0</span></span></code> </pre><br>  Em seguida, fazemos a palavra blword.  Essa palavra, usando as vari√°veis ‚Äã‚Äãespecificadas, obt√©m a pr√≥xima palavra do fluxo de entrada.  Um espa√ßo √© usado como delimitadores e todos os caracteres com um c√≥digo menor que um espa√ßo.  Esta palavra estar√° em assembler.  Ap√≥s a depura√ß√£o, ficou assim: <br><br><pre> <code class="cpp hljs">b_blword = <span class="hljs-number"><span class="hljs-number">0xF0</span></span> bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    add rsi, rax #  RSI -      sub rcx, rax #     jz <span class="hljs-number"><span class="hljs-number">3f</span></span> word2: lodsb #   AL  RSI   cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> ja <span class="hljs-number"><span class="hljs-number">1f</span></span> #    (    ) dec rcx jnz word2 #    <span class="hljs-number"><span class="hljs-number">3</span></span>: sub rsi, rdx mov v_in, rsi push rcx jmp _next <span class="hljs-number"><span class="hljs-number">1</span></span>: lea rdi, [rsi - <span class="hljs-number"><span class="hljs-number">1</span></span>] # RDI = RSI - <span class="hljs-number"><span class="hljs-number">1</span></span> ( ) dec rcx word3: lodsb cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> jbe <span class="hljs-number"><span class="hljs-number">2f</span></span> dec rcx jnz word3 <span class="hljs-number"><span class="hljs-number">2</span></span>: mov rax, rsi sub rsi, rdx #        (   ) mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next</code> </pre><br>  Essa palavra √© semelhante √† palavra padr√£o, mas, diferentemente dela, leva em considera√ß√£o todos os delimitadores e n√£o copia a palavra no buffer.  Ele retorna apenas dois valores na pilha - endere√ßo e comprimento.  Se a palavra n√£o puder ser recuperada, retornar√° 0. Chegou a hora de come√ßar a escrever o int√©rprete. <br><br><h4>  Pesquisa de palavras e int√©rprete </h4><br>  Para come√ßar, vamos fazer a palavra interpretar.  Essa palavra seleciona uma nova palavra do buffer usando blworld, a procura no dicion√°rio e a executa.  E assim se repete at√© que o buffer esteja esgotado.  Ainda n√£o temos a capacidade de procurar uma palavra, portanto, escreveremos um esbo√ßo de teste que simplesmente imprimir√° a palavra no buffer usando o tipo  Isso nos dar√° a oportunidade de verificar e depurar o blworld: <br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> type repeat drop ; item interpret <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_type .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">1b</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br>  Agora fa√ßa a palavra sair.  Geralmente eles fazem isso ao implementar sistemas fortes: eles usam a palavra quit ou abort para entrar no modo int√©rprete.  A palavra sair libera pilhas e inicia um loop infinito de entrada e interpreta√ß√£o de buffer.  Conosco, ser√° apenas um chamado para interpretar.  O c√≥digo para esta palavra consistir√° em duas partes.  A primeira parte ser√° em assembler, a segunda parte ser√° em bytecode.  A primeira parte: <br><br><pre> <code class="cpp hljs">b_quit = <span class="hljs-number"><span class="hljs-number">0xF1</span></span> bcmd_quit: lea r8, quit mov sp, init_stack mov bp, init_rstack jmp _next</code> </pre><br>  A segunda parte: <br><br><pre> <code class="cpp hljs">quit: .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye</code> </pre><br>  Como de costume, o c√≥digo do assembler est√° localizado na se√ß√£o .text, o c√≥digo do byte est√° na se√ß√£o .data. <br><br>  E, finalmente, altere o bytecode inicial.  S√≥ haver√° inicializa√ß√£o do dicion√°rio, configurando um buffer na linha de partida e chamando quit. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! start_code tib ! </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;  &gt; #tib ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call8 .byte start_code - . - 1 .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .world 1f - 0f .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_quit start_code: .byte b_var0 0: .ascii "word1 word2 word3" 1:</span></span></span></span></code> </pre><br>  Compilar, vincular, executar! <br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth word1word2wordBye!</code> </pre><br>  √â um pouco como mingau, mas √© exatamente isso que deve ser o resultado.  N√≥s produzimos sem delimitadores.  By the way, coloque o feed de linha antes de comprar para o futuro, isso n√£o vai doer. <br><br>  Claro, eu tive que mexer na depura√ß√£o.  Al√©m da j√° mencionada ‚Äúfalha de segmenta√ß√£o (n√∫cleo despejado)‚Äù, algumas vezes foram obtidos resultados interessantes.  Por exemplo, isto: <br><br><pre> <code class="plaintext hljs">$ ./forth word1word2word3forth)%60Acurrent(context(%600lit8lit16zlit32v%5E%DF%80lit64v%5E%DF%80call8call16call32branch8branch16qbranch8qbranch16exit1-+!-%22*#/$mod%25/mod&amp;abs'dup0drop1swap2rot3-rot4over5pick6roll7depth8@@!Ac@Bc!Cw@Dw!Ei@Fi!G0=P0%3CQ0%3ER=S%3CT%3EU%3C=V%3E=Wvar8)var160base(holdbuf(Qholdpoint(hold@0U110ACp@&amp;20T0!?!%3CgF!A0@RF!5%220'%DE%A61Q-%DD%80:tib(%7F%60(%3Ein(%20%20%20%20%20%20%20interpret01('byeSegmentation%20fault%20(core%20dumped)</code> </pre><br>  Este parece ser o nosso dicion√°rio bin√°rio inteiro, com o texto cortado em delimitadores :) Aconteceu quando esqueci ‚Äúdec rcx‚Äù antes da palavra3 no comando b_blword. <br><br>  Podemos escolher palavras do fluxo de entrada, existe um dicion√°rio.  Agora voc√™ precisa implementar uma pesquisa no dicion√°rio e iniciar palavras para execu√ß√£o.  Isso exigir√° as palavras find, cfa e execute. <br><br>  A palavra localizar ter√° o endere√ßo da palavra e seu comprimento da pilha.  Esta palavra ser√° retornada pelo endere√ßo da entrada do dicion√°rio ou 0 se n√£o for encontrado. <br><br>  A palavra cfa no endere√ßo do artigo calcular√° o endere√ßo do bytecode execut√°vel. <br><br>  E a palavra executar executar√° o bytecode. <br><br>  Vamos come√ßar com o find.  Nos padr√µes do forte, √© preciso um endere√ßo - uma linha com um contador.  Mas eu n√£o quero copiar mais uma vez a string para o buffer, ent√£o vou desviar um pouco dos padr√µes.  A palavra find ter√° dois par√¢metros na pilha - o endere√ßo e o comprimento da string (de fato, que retorna a palavra blword).  Ap√≥s a depura√ß√£o, essa palavra assumiu a seguinte forma: <br><br><pre> <code class="cpp hljs">b_find = <span class="hljs-number"><span class="hljs-number">0xF2</span></span> bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz find_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz find_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz find_l32 mov r10, [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">64</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">32</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   jmp find1 find_l16: movsx r10, word ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">16</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">8</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez esta seja a palavra mais dif√≠cil para hoje. </font><font style="vertical-align: inherit;">Agora, modificamos a palavra interpretar, substituindo type por "find".</font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find . repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na linha de teste, voc√™ precisa colocar as palavras que est√£o no dicion√°rio, por exemplo, "0 1- dup +.". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est√° tudo pronto para o lan√ßamento!</font></font><br><br><pre> <code class="plaintext hljs">$ ld forth.o -o forth $ ./forth 6297733 6297898 6298375 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ìtimo, a pesquisa funciona. </font><font style="vertical-align: inherit;">Estes s√£o os endere√ßos das palavras (em decimal). </font><font style="vertical-align: inherit;">Agora a palavra cfa. </font><font style="vertical-align: inherit;">Seja tamb√©m em assembler, √© muito simples, trabalhar com flags √© semelhante a encontrar:</font></font><br><br><pre> <code class="cpp hljs">b_cfa = <span class="hljs-number"><span class="hljs-number">0xF3</span></span> bcmd_cfa: pop rdx #    mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz cfa_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz cfa_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz cfa_l32 lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   (<span class="hljs-number"><span class="hljs-number">64</span></span>  ) jmp cfa1 find_l32: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   (<span class="hljs-number"><span class="hljs-number">32</span></span>  ) jmp cfa1 find_l16: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   (<span class="hljs-number"><span class="hljs-number">16</span></span>  ) jmp cfa1 find_l8: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   (<span class="hljs-number"><span class="hljs-number">8</span></span>  ) xor rax, rax lodsb add rsi, rax push rsi jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E, finalmente, a palavra executar, √© ainda mais simples: </font></font><br><br><pre> <code class="cpp hljs">b_execute = <span class="hljs-number"><span class="hljs-number">0xF4</span></span> bcmd_execute: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 #       pop r8 #  - jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corrija a palavra interpretar e executar! </font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find cfa execute repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_cfa .byte b_execute .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lan√ßamento: </font></font><br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth -2 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urrra, ganhou! </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(C) Cat Matroskin</font></font></s> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De fato, se voc√™ subtrair 1 de 0 e adicionar o resultado a si mesmo, ser√° -2 :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© √≥timo, mas ainda quero digitar os comandos do teclado. E h√° mais um problema - nosso int√©rprete entende apenas os n√∫meros 0, 1, 2, 3, 4 e 8 (que s√£o definidos como constantes). O que ele aprenderia a entender qualquer n√∫mero, voc√™ precisa da palavra "n√∫mero?". Da mesma maneira que para a palavra find, n√£o usarei o buffer. A palavra "n√∫mero?" ter√° dois par√¢metros na pilha - o endere√ßo da string e o comprimento. Se for bem-sucedido, ele retornar√° o n√∫mero recebido e o sinalizador 1. Se a convers√£o n√£o for bem-sucedida, haver√° um n√∫mero na pilha: 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo acabou sendo longo, mas simples e linear:</font></font><br><br><pre> <code class="cpp hljs">b_number = <span class="hljs-number"><span class="hljs-number">0xF5</span></span> bcmd_number: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz num_false mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jnz <span class="hljs-number"><span class="hljs-number">1f</span></span> inc rsi dec rcx jz num_false jmp num0 <span class="hljs-number"><span class="hljs-number">1</span></span>: cmp bl, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jnz num0 mov r10, <span class="hljs-number"><span class="hljs-number">1</span></span> inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jae num_09 cmp bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'Z'</span></span> jae num_AZ cmp bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> ja num_false sub bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_AZ: sub bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_09: sub bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> num_check: cmp rbx, r9 jge num_false add rax, rbx mul r9 inc rsi dec rcx jnz num0 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 push rax push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next num_false: xor rcx, rcx push rcx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifique interpretar. </font><font style="vertical-align: inherit;">Se a palavra n√£o estiver no dicion√°rio, tentaremos interpret√°-la como um n√∫mero:</font></font><br><br><pre> <code class="cpp hljs"># : interpret <span class="hljs-meta"><span class="hljs-meta"># begin # blword dup # while # over over find dup # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> -rot drop drop cfa execute </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> number? drop then # repeat # drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_numberq .byte b_drop 2: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E aqui cheguei! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depure esse bytecode no assembler, sem pontos de interrup√ß√£o no bytecode, sem a capacidade de apenas "avan√ßar" ao longo do bytecode ... Al√©m disso, sem os movimentos mais f√°ceis da pilha e sem a simples capacidade de visualizar o conte√∫do da pilha ... E no GDB, onde apenas a linha de comando ... Eu vou te dizer - √© apenas uma explos√£o cerebral! </font><font style="vertical-align: inherit;">N√£o √© pior. </font><font style="vertical-align: inherit;">Esta √© uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explos√£o cerebral</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas ... somos √≠ndios, sempre encontraremos solu√ß√µes alternativas :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, encontrei esta solu√ß√£o: implementei um comando para exibir o conte√∫do da pilha - "s". </font><font style="vertical-align: inherit;">O comando n√£o √© o mais f√°cil, mas ainda mais f√°cil de interpretar. </font><font style="vertical-align: inherit;">E, como se viu, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ochchchen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √∫til. </font><font style="vertical-align: inherit;">Aqui est√°:</font></font><br><br><pre> <code class="cpp hljs"># : .s depth dup . c<span class="hljs-string"><span class="hljs-string">": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_lit8 .byte '(' .byte b_emit .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "</span></span>): <span class="hljs-string"><span class="hljs-string">" 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä direita, dei um exemplo do conte√∫do da pilha, ap√≥s a execu√ß√£o de cada comando. </font><font style="vertical-align: inherit;">Claro, h√° um ciclo, e esta √© apenas a primeira passagem. </font><font style="vertical-align: inherit;">Mas o resto √© muito parecido, apenas o valor no topo da pilha muda. </font><font style="vertical-align: inherit;">Ap√≥s esse "rastreio", a equipe ganhou imediatamente! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para depura√ß√£o, criei as seguintes macros:</font></font><br><br><pre> <code class="cpp hljs">.macro prs new_line = <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \new_line &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> .byte b_lit8, <span class="hljs-string"><span class="hljs-string">'\n'</span></span> .byte b_emit .endif .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usado inserindo nos lugares certos desta maneira: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword prs .byte b_dup prs .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over ......</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, o primeiro lan√ßamento produziu a seguinte sa√≠da: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth (2 ): 6297664 1 (3 ): 6297664 1 1 (3 ): 2 6297666 1 (4 ): 2 6297666 1 1 (4 ): 2 3 6297668 1 (5 ): 2 3 6297668 1 1 (3 ): 6 6297670 2 (4 ): 6 6297670 2 2 (4 ): 6 6297670 6297673 1 (5 ): 6 6297670 6297673 1 1 6297670 (2 ): 6 0 (3 ): 6 0 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada movimento na pilha pode ser visto claramente. </font><font style="vertical-align: inherit;">Era necess√°rio fazer isso mais cedo :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fui mais longe, fazendo outra macro de depura√ß√£o:</font></font><br><br><pre> <code class="cpp hljs">.macro pr <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - <span class="hljs-number"><span class="hljs-number">8f</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n\string"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, tornou-se poss√≠vel: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword pr blworld prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over prs .byte b_find pr find prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa pr execute prs .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_numberq pr numberq prs .byte b_drop <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E pegue isso: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth blworld(2 ): 6297664 2 (4 ): 6297664 2 6297664 2 find(3 ): 6297664 2 0 numberq(2 ): 6297664 0 blworld(3 ): 6297664 6297667 2 (5 ): 6297664 6297667 2 6297667 2 find(4 ): 6297664 6297667 2 0 numberq(3 ): 6297664 6297667 0 blworld(4 ): 6297664 6297667 6297670 1 (6 ): 6297664 6297667 6297670 1 6297670 1 find(5 ): 6297664 6297667 6297670 1 6297958 execute(3 ): 6297664 6297667 6297962 blworld(3 ): 39660590749888 6297672 1 (5 ): 39660590749888 6297672 1 6297672 1 find(4 ): 39660590749888 6297672 1 6298496 execute(2 ): 39660590749888 6298500 39660590749888 blworld(1 ): 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi uma tentativa de interpretar a sequ√™ncia "20 30 *.". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E voc√™ pode exibir os n√∫meros das linhas de origem ... ok, talvez ent√£o ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â claro que essa √© uma t√©cnica cl√°ssica de registro para depura√ß√£o, mas algo que n√£o me lembrei imediatamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, como resultado da depura√ß√£o, encontrei uma pilha no exterior. √â o oposto do estouro quando eles tentam levar mais do que colocam. Adicionado controle dela para ".s". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com a ajuda de novas macros, a depura√ß√£o foi r√°pida. A prop√≥sito, antes disso eu postei um bytecode por linha. Mas o assembler permite que voc√™ coloque v√°rios bytes em uma string, por que n√£o us√°-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos concluir a palavra interpretar adicionando duas verifica√ß√µes: que a palavra n√£o foi convertida em um n√∫mero e sair da pilha no exterior. Como resultado, interpretar √© o seguinte:</font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prop√≥sito, vale a pena notar que agora o comando quit libera pilhas e inicia a interpreta√ß√£o novamente sem alterar o estado do buffer. </font><font style="vertical-align: inherit;">Assim, a interpreta√ß√£o continua, mas com pilhas "novas". </font><font style="vertical-align: inherit;">Vamos corrigir isso um pouco mais tarde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫nica coisa que resta √© organizar a entrada do teclado.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entrada do teclado </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A entrada do teclado no forte √© simples. </font><font style="vertical-align: inherit;">Existe a palavra expect, s√£o necess√°rios dois par√¢metros - o endere√ßo do buffer e seu tamanho. </font><font style="vertical-align: inherit;">Esta palavra executa a entrada do teclado. </font><font style="vertical-align: inherit;">O n√∫mero real de caracteres digitados √© colocado na vari√°vel span. </font><font style="vertical-align: inherit;">Vamos fazer essas palavras. </font><font style="vertical-align: inherit;">Entraremos a partir da entrada padr√£o.</font></font><br><br><pre> <code class="cpp hljs">.data item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> .text b_expect = <span class="hljs-number"><span class="hljs-number">0x88</span></span> bcmd_expect: mov rax, <span class="hljs-number"><span class="hljs-number">0</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_read mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jge <span class="hljs-number"><span class="hljs-number">1f</span></span> xor rbx, rbx <span class="hljs-number"><span class="hljs-number">1</span></span>: mov v_span, rbx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos criar um buffer de entrada do teclado. </font><font style="vertical-align: inherit;">Que seja 256 caracteres. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos substitu√≠-lo na linha de teste anterior.</font></font><br><br><pre> <code class="cpp hljs">inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> inbuf: .byte b_var0 .space inbuf_size</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E n√≥s modificamos quit, assim como o c√≥digo de in√≠cio. </font><font style="vertical-align: inherit;">Defina a vari√°vel tib como o buffer de entrada inbuf, chame expect e copie o valor de span para #tib. </font><font style="vertical-align: inherit;">A vari√°vel&gt; in √© anulada; chamamos interpretar. </font><font style="vertical-align: inherit;">E assim repetimos em um ciclo. </font><font style="vertical-align: inherit;">Existem bugigangas - para adicionar um prompt de entrada e seria bom exibir o status da pilha (e j√° temos um comando pronto para isso!). </font><font style="vertical-align: inherit;">Ap√≥s v√°rias itera√ß√µes, obtivemos o seguinte c√≥digo (comando start e quit):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! 0 &gt;in ! interpret again quit: .byte b_strp, 1 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n"</span></span></span><span class="hljs-meta"> .byte b_call16 .word prstack - . - 2 .byte b_strp .byte 2 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt; "</span></span></span><span class="hljs-meta"> .byte b_call16 .word inbuf - . - 2 .byte b_dup .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - 2 .byte b_get .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_num0 .byte b_call16 .word bin - . - 2 .byte b_set .byte b_call16 .word interpret - . - 2 .byte b_branch8, quit - .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E aqui est√° o resultado: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 60 ( 1 ): 60 &gt; 60 24 ( 3 ): 60 60 24 &gt; rot ( 3 ): 60 24 60 &gt; -rot ( 3 ): 60 60 24 &gt; swap ( 3 ): 60 24 60 &gt; * * . 86400 ( 0 ): &gt; 200 30 /mod ( 2 ): 20 6 &gt; bye Bye! $</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo depois do s√≠mbolo "&gt;" √© minha entrada de teclado. </font><font style="vertical-align: inherit;">O resto √© a resposta do sistema. </font><font style="vertical-align: inherit;">Eu brinquei um pouco com os comandos, digitando no teclado. </font><font style="vertical-align: inherit;">Ele executou v√°rias opera√ß√µes de pilha, calculou o n√∫mero de segundos em dias.</font></font><br><br><h4>  Sum√°rio </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O int√©rprete est√° completo e funcionando. </font><font style="vertical-align: inherit;">E educadamente diz adeus - para ele ‚Äútchau‚Äù e ele ‚Äútchau‚Äù :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como convite - o conte√∫do da pilha aritm√©tica. </font><font style="vertical-align: inherit;">O primeiro n√∫mero entre colchetes √© o tamanho da pilha, o conte√∫do e o prompt para inserir "&gt;". </font><font style="vertical-align: inherit;">Voc√™ pode inserir qualquer comando implementado (contei 76 comandos). </font><font style="vertical-align: inherit;">√â verdade que muitos fazem sentido apenas para o compilador - por exemplo, literais, transi√ß√µes, comandos de chamada.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte completa (cerca de 1300 linhas)</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span> .macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = p_item - . <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad link .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm .section .data init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> emit_buf: .byte <span class="hljs-number"><span class="hljs-number">0</span></span> inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"\nBye!\n"</span></span> msg_bye_len = . - msg_bye bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_num1, bcmd_num2, bcmd_num3, bcmd_num4, bcmd_num8 # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_qnbranch8, bcmd_qnbranch16,bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_wp, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_add, bcmd_sub, bcmd_mul, bcmd_div, bcmd_mod, bcmd_divmod, bcmd_abs # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_var0, bcmd_var8, bcmd_var16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_dup, bcmd_drop, bcmd_swap, bcmd_rot, bcmd_mrot, bcmd_over, bcmd_pick, bcmd_roll # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_depth, bcmd_nip, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_get, bcmd_set, bcmd_get8, bcmd_set8, bcmd_get16, bcmd_set16, bcmd_get32, bcmd_set32 # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_setp, bcmd_setm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_zeq, bcmd_zlt, bcmd_zgt, bcmd_eq, bcmd_lt, bcmd_gt, bcmd_lteq, bcmd_gteq # <span class="hljs-number"><span class="hljs-number">0x50</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_2r, bcmd_r2, bcmd_rget, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_emit, bcmd_str, bcmd_strp, bcmd_count, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_expect, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x90</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_blword, bcmd_quit, bcmd_find, bcmd_cfa, bcmd_execute, bcmd_numberq, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0xF0</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # forth last_item context @ ! quit start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;in ! interpret again quit: .byte b_strp, <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\n"</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">2</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"&gt; "</span></span> .byte b_call16 .word inbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_num0 .byte b_call16 .word bin - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8, quit - . p_item = . item forth forth: .byte b_var8 .byte does_voc - . .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit item current .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 v_context: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit item <span class="hljs-number"><span class="hljs-number">2</span></span>, f_code .byte b_num2 .byte b_exit item <span class="hljs-number"><span class="hljs-number">3</span></span>, f_code .byte b_num3 .byte b_exit item <span class="hljs-number"><span class="hljs-number">4</span></span>, f_code .byte b_num4 .byte b_exit item <span class="hljs-number"><span class="hljs-number">8</span></span>, f_code .byte b_num8 .byte b_exit item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item call8, f_code .byte b_call8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call16, f_code .byte b_call16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call32, f_code .byte b_call32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch8, f_code .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch16, f_code .byte b_branch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch8, f_code .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch16, f_code .byte b_qbranch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>, f_code .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit item /, f_code .byte b_div .byte b_exit item mod, f_code .byte b_mod .byte b_exit item /mod, f_code .byte b_divmod .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>, f_code .byte b_abs .byte b_exit item dup, f_code .byte b_dup .byte b_exit item drop, f_code .byte b_drop .byte b_exit item swap, f_code .byte b_swap .byte b_exit item rot, f_code .byte b_rot .byte b_exit item -rot, f_code .byte b_mrot .byte b_exit item over, f_code .byte b_over .byte b_exit item pick, f_code .byte b_pick .byte b_exit item roll, f_code .byte b_roll .byte b_exit item depth, f_code .byte b_depth .byte b_exit item @, f_code .byte b_get .byte b_exit item !, f_code .byte b_set .byte b_exit item c@, f_code .byte b_get8 .byte b_exit item c!, f_code .byte b_set8 .byte b_exit item w@, f_code .byte b_get16 .byte b_exit item w!, f_code .byte b_set16 .byte b_exit item i@, f_code .byte b_get32 .byte b_exit item i!, f_code .byte b_set32 .byte b_exit item +!, f_code .byte b_setp .byte b_exit item -!, f_code .byte b_setm .byte b_exit item &gt;r, f_code .byte b_2r .byte b_exit item r&gt;, f_code .byte b_r2 .byte b_exit item r@, f_code .byte b_rget .byte b_exit item <span class="hljs-string"><span class="hljs-string">"0="</span></span>, f_code .byte b_zeq .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;, f_code .byte b_zlt .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, f_code .byte b_zgt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"="</span></span>, f_code .byte b_eq .byte b_exit item &lt;, f_code .byte b_lt .byte b_exit item &gt;, f_code .byte b_gt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span>, f_code .byte b_lteq .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span>, f_code .byte b_gteq .byte b_exit item type, f_code .byte b_type .byte b_exit item expect, f_code .byte b_expect .byte b_exit item emit, f_code .byte b_emit .byte b_exit item count, f_code .byte b_count .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(\")"</span></span>, f_code .byte b_str .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(.\")"</span></span>, f_code .byte b_strp .byte b_exit item var8, f_code .byte b_var8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item var16, f_code .byte b_var16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item base base: .byte b_var0 v_base: .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> item holdbuf holdbuf: .byte b_var0 .space holdbuf_len item holdpoint holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # : hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ; item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ; # : # base /mod swap dup 10 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; if c" 0 + else 10 - c" A + then hold ; item # conv: .byte b_call16 .word base - . - 2 # base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # if .byte 0f - . .byte b_lit8 .byte '0' # c" 0 .byte b_add # + .byte b_branch8 # else .byte 1f - . 0: .byte b_lit8 .byte '?' # c" A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ; # : &lt;# holdbuf 70 + holdpoint ! ; item &lt;# conv_start: .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - 2 .byte b_set .byte b_exit # : #s do # dup 0=until ; item #s conv_s: .byte b_call8 .byte conv - . - 1 .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit # : #&gt; holdpoint @ holdbuf 70 + over - ; item #&gt; conv_end: .byte b_call16 .word holdpoint - . - 2 .byte b_get .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit item . dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - 1 .byte b_lit8 .byte ' ' .byte b_call16 .word hold - . - 2 .byte b_call8 .byte conv_s - . - 1 .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte 1f - . .byte b_lit8 .byte '-' .byte b_call16 .word hold - . - 2 1: .byte b_call8 .byte conv_end - . - 1 .byte b_type .byte b_exit item tib tib: .byte b_var0 v_tib: .quad 0 item #tib ntib: .byte b_var0 v_ntib: .quad 0 item &gt;in bin: .byte b_var0 v_in: .quad 0 # : .s depth dup . c": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_strp .byte 2 .ascii "( " .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "): " .byte b_dup, b_zlt .byte b_qnbranch8, 1f - . .byte b_strp .byte 14 .ascii "\nStack fault!\n" .byte b_quit 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit .macro prs new_line = 1 .byte b_call16 .word prstack - . - 2 .if \new_line &gt; 0 .byte b_lit8, '\n' .byte b_emit .endif .endm .macro pr string .byte b_strp .byte 9f - 8f 8: .ascii "\n\string" 9: .endm item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, 3f - . #     0, ,      3 .byte b_type #    .byte b_strp #   .byte 19 #     .ascii " : word not found!\n" .byte b_quit #    3: .byte b_nip, b_nip #  ,     ( b_over, b_over) 2: #       .byte b_depth #    .byte b_zlt # ,   0 ( 0&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte 14 .ascii "\nstack fault!\n" .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_var0 = 0x28 bcmd_var0: push r8 b_exit = 0x17 bcmd_exit: mov r8, [rbp] add rbp, 8 _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*8] b_num0 = 0x02 bcmd_num0: push 0 jmp _next b_num1 = 0x03 bcmd_num1: push 1 jmp _next b_num2 = 0x04 bcmd_num2: push 2 jmp _next b_num3 = 0x05 bcmd_num3: push 3 jmp _next b_num4 = 0x06 bcmd_num4: push 4 jmp _next b_num8 = 0x07 bcmd_num8: push 8 jmp _next b_lit8 = 0x08 bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = 0x09 bcmd_lit16: movsx rax, word ptr [r8] add r8, 2 push rax jmp _next b_call8 = 0x0C bcmd_call8: movsx rax, byte ptr [r8] sub rbp, 8 inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = 0x0D bcmd_call16: movsx rax, word ptr [r8] sub rbp, 8 add r8, 2 mov [rbp], r8 add r8, rax jmp _next b_call32 = 0x0E bcmd_call32: movsx rax, dword ptr [r8] sub rbp, 8 add r8, 4 mov [rbp], r8 add r8, rax jmp _next b_lit32 = 0x0A bcmd_lit32: movsx rax, dword ptr [r8] add r8, 4 push rax jmp _next b_lit64 = 0x0B bcmd_lit64: mov rax, [r8] add r8, 8 push rax jmp _next b_dup = 0x30 bcmd_dup: push [rsp] jmp _next b_wm = 0x20 bcmd_wm: decq [rsp] jmp _next b_wp = 0x18 bcmd_wp: incq [rsp] jmp _next b_add = 0x21 bcmd_add: pop rax add [rsp], rax jmp _next b_sub = 0x22 bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = 0x23 bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = 0x24 bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = 0x25 bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = 0x26 bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = 0x27 bcmd_abs: mov rax, [rsp] or rax, rax jge _next neg rax mov [rsp], rax jmp _next b_drop = 0x31 bcmd_drop: add rsp, 8 jmp _next b_swap = 0x32 bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = 0x33 bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = 0x34 bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = 0x35 bcmd_over: push [rsp + 8] jmp _next b_pick = 0x36 bcmd_pick: pop rcx push [rsp + 8*rcx] jmp _next b_roll = 0x37 bcmd_roll: pop rcx mov rbx, [rsp + 8*rcx] roll1: mov rax, [rsp + 8*rcx - 8] mov [rsp + 8*rcx], rax dec rcx jnz roll1 push rbx jmp _next b_depth = 0x38 bcmd_depth: mov rax, init_stack sub rax, rsp sar rax, 3 push rax jmp _next b_nip = 0x39 bcmd_nip: pop rax mov [rsp], rax jmp _next b_get = 0x40 bcmd_get: pop rcx push [rcx] jmp _next b_set = 0x41 bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = 0x42 bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = 0x43 bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = 0x44 bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = 0x45 bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = 0x46 bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = 0x47 bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next b_setp = 0x48 bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = 0x49 bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = 0x60 bcmd_2r: pop rax sub rbp, 8 mov [rbp], rax jmp _next b_r2 = 0x61 bcmd_r2: push [rbp] add rbp, 8 jmp _next b_rget = 0x62 bcmd_rget: push [rbp] jmp _next # 0= b_zeq = 0x50 bcmd_zeq: pop rax or rax, rax jnz rfalse rtrue: push -1 jmp _next rfalse: push 0 jmp _next # 0&lt; b_zlt = 0x51 bcmd_zlt: pop rax or rax, rax jl rtrue push 0 jmp _next # 0&gt; b_zgt = 0x52 bcmd_zgt: pop rax or rax, rax jg rtrue push 0 jmp _next # = b_eq = 0x53 bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push 0 jmp _next # &lt; b_lt = 0x54 bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push 0 jmp _next # &gt; b_gt = 0x55 bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push 0 jmp _next # &lt;= b_lteq = 0x56 bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push 0 jmp _next # &gt;= b_gteq = 0x57 bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push 0 jmp _next b_var8 = 0x29 bcmd_var8: push r8 b_branch8 = 0x10 bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = 0x30 bcmd_var16: push r8 b_branch16 = 0x11 bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = 0x12 bcmd_qbranch8: pop rax or rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = 0x13 bcmd_qbranch16: pop rax or rax, rax jnz bcmd_branch16 add r8, 2 jmp _next b_qnbranch8 = 0x14 bcmd_qnbranch8: pop rax or rax, rax jz bcmd_branch8 inc r8 jmp _next b_qnbranch16 = 0x15 bcmd_qnbranch16:pop rax or rax, rax jz bcmd_branch16 add r8, 2 jmp _next b_bad = 0x00 bcmd_bad: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, 60 #    1 - sys_exit mov rbx, 1 #    1 syscall #   b_bye = 0x01 bcmd_bye: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, 60 #    60 - sys_exit mov rdi, 0 #    0 syscall #   b_strp = 0x83 bcmd_strp: movsx rax, byte ptr [r8] inc r8 push r8 add r8, rax push rax b_type = 0x80 bcmd_type: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next b_expect = 0x88 bcmd_expect: mov rax, 0 #    1 - sys_read mov rdi, 0 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax or rax, rax jge 1f xor rbx, rbx 1: mov v_span, rbx jmp _next b_str = 0x82 bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + 1] jmp _next b_count = 0x84 bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_emit = 0x81 bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout mov rdx, 1 #   push r8 syscall #   pop r8 jmp _next b_blword = 0xF0 bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    mov rbx, rcx add rsi, rax #  RSI -      sub rcx, rax #     jz 3f word2: lodsb #   AL  RSI   cmp al, ' ' ja 1f #    (    ) dec rcx jnz word2 #    3: sub rsi, rdx mov v_in, rsi push rcx jmp _next 1: lea rdi, [rsi - 1] # RDI = RSI - 1 ( ) dec rcx jz word9 word3: lodsb cmp al, ' ' jbe 2f dec rcx jnz word3 word9: inc rsi 2: mov rax, rsi sub rsi, rdx #        (   ) cmp rsi, rbx jle 4f mov rsi, rbx 4: mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next b_quit = 0xF1 bcmd_quit: lea r8, quit mov rsp, init_stack mov rbp, init_rstack jmp _next b_find = 0xF2 bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz find_l8 cmp al, 1 jz find_l16 cmp al, 2 jz find_l32 mov r10, [rdx + 1] #  64  lea rsi, [rdx + 9] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + 1] #  32  lea rsi, [rdx + 5] #   jmp find1 find_l16: movsx r10, word ptr [rdx + 1] #  16  lea rsi, [rdx + 3] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + 1] #  8  lea rsi, [rdx + 2] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: or r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next b_cfa = 0xF3 bcmd_cfa: pop rdx #    mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz cfa_l8 cmp al, 1 jz cfa_l16 cmp al, 2 jz cfa_l32 lea rsi, [rdx + 9] #   (64  ) jmp cfa1 cfa_l32: lea rsi, [rdx + 5] #   (32  ) jmp cfa1 cfa_l16: lea rsi, [rdx + 3] #   (16  ) jmp cfa1 cfa_l8: lea rsi, [rdx + 2] #   (8  ) cfa1: xor rax, rax lodsb add rsi, rax push rsi jmp _next b_execute = 0xF4 bcmd_execute: sub rbp, 8 mov [rbp], r8 #       pop r8 #  - jmp _next b_numberq = 0xF5 bcmd_numberq: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   or rcx, rcx jz num_false mov bl, [rsi] cmp bl, '+' jnz 1f inc rsi dec rcx jz num_false jmp num0 1: cmp bl, '-' jnz num0 mov r10, 1 inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, '0' jb num_false cmp bl, '9' jbe num_09 cmp bl, 'A' jb num_false cmp bl, 'Z' jbe num_AZ cmp bl, 'a' jb num_false cmp bl, 'z' ja num_false sub bl, 'a' - 10 jmp num_check num_AZ: sub bl, 'A' - 10 jmp num_check num_09: sub bl, '0' num_check: cmp rbx, r9 jge num_false mul r9 add rax, rbx inc rsi dec rcx jnz num0 or r10, r10 push rax push 1 jmp _next num_false: xor rcx, rcx push rcx jmp _next</span></span></span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo fonte est√° ficando maior, ent√£o eu o trago aqui pela √∫ltima vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, seu local de resid√™ncia estar√° no github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No mesmo local, na pasta bin, voc√™ pode encontrar a vers√£o j√° compilada para Linux x64. Quem tem Linux, voc√™ pode baixar e executar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E quem tem Windows - voc√™ pode instalar o WSL (Windows Subsystem for Linux). Eu estava saindo para as f√©rias e fiz exatamente isso. Acabou sendo muito simples, demorou cerca de 5 minutos, houve apenas um momento, n√£o foi iniciado imediatamente, o subsistema teve que ser "ativado" atrav√©s do comando PowerShell. Seguiu o link da mensagem de erro, executou o comando e funcionou. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas tamb√©m h√° uma maneira de os √≠ndios reais executarem tudo no Windows :) N√£o √© dif√≠cil fazer isso, basta refazer algumas palavras que interagem com o sistema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© tudo! </font><font style="vertical-align: inherit;">Da pr√≥xima vez, executaremos o compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haver√° uma oportunidade de compilar novas palavras, haver√° condi√ß√µes, ciclos. </font><font style="vertical-align: inherit;">Na verdade, ser√° poss√≠vel escrever em um forte mais ou menos padr√£o, compil√°-lo em c√≥digo de bytes e execut√°-lo. </font><font style="vertical-align: inherit;">Bem, ser√° poss√≠vel realizar testes mais s√©rios, verificar o desempenho da m√°quina de bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continua√ß√£o: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-machine para o forte (e n√£o apenas) no nativo americano (parte 4)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435236/">https://habr.com/ru/post/pt435236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435220/index.html">Kotlin Native: acompanhe os arquivos</a></li>
<li><a href="../pt435224/index.html">Como se comunicar em um escrit√≥rio em ingl√™s: 14 express√µes √∫teis</a></li>
<li><a href="../pt435226/index.html">Restaurar dados do zero</a></li>
<li><a href="../pt435228/index.html">Cluster Kubernetes por US $ 20 por m√™s</a></li>
<li><a href="../pt435234/index.html">Mais inteligente, al√©m disso, mais precisamente: como a IA transforma os voos no espa√ßo</a></li>
<li><a href="../pt435240/index.html">Unreal Engine4 - efeito de verifica√ß√£o p√≥s-processo</a></li>
<li><a href="../pt435242/index.html">Por que tenho medo de me tornar um "homem bombeado"</a></li>
<li><a href="../pt435244/index.html">Projeto ITER em 2018</a></li>
<li><a href="../pt435246/index.html">Tesla abriu pr√©-encomendas para o Modelo 3 na Europa e na China</a></li>
<li><a href="../pt435248/index.html">Navega√ß√£o dentro do aplicativo Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>