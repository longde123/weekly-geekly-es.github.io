<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸ³ ğŸ§šğŸ¼ ğŸ‘¼ğŸ¼ Pengetikan dinamis yang aman secara statis ala Python ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿ ğŸ™‹ğŸ¼ ğŸš¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, Habr. 


 Suatu hari, di salah satu proyek hobi saya, tugas muncul menulis repositori metrik. 


 Tugas itu sendiri diselesaikan dengan sangat se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengetikan dinamis yang aman secara statis ala Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457930/"><p>  Hai, Habr. </p><br><p>  Suatu hari, di salah satu proyek hobi saya, tugas muncul menulis repositori metrik. </p><br><p>  Tugas itu sendiri diselesaikan dengan sangat sederhana, tetapi masalah saya dengan Haskell (terutama dalam proyek untuk hiburan saya sendiri) adalah bahwa tidak mungkin untuk hanya mengambil dan menyelesaikan masalah.  Adalah perlu untuk memutuskan, memperluas, abstrak, abstrak dan kemudian memperluas lebih lanjut.  Oleh karena itu, saya ingin membuat penyimpanan metrik diperluas agar tidak menentukan sebelumnya apa yang akan ada di sana.  Ini sendiri merupakan topik untuk artikel terpisah, dan hari ini kami akan mempertimbangkan satu bahan kecil: menulis pembungkus yang aman untuk jenis yang sebelumnya tidak dikenal.  Sesuatu seperti mengetik dinamis, tetapi dengan jaminan statis bahwa kami tidak akan melakukan omong kosong. </p><br><p>  Artikel ini, saya pikir, tidak akan membuka sesuatu yang baru untuk Haskellists berpengalaman, tapi sekarang kita setidaknya akan meletakkan bahan ini di luar kotak dan tidak akan terganggu olehnya di artikel berikutnya.  Baik, atau Anda bisa tidak terlalu sederhana dan mengatakan bahwa saya sudah menemukan pola desain keseluruhan. </p><a name="habracut"></a><br><p>  Jadi, pertama kita rumuskan masalahnya.  Kita harus dapat mengaitkan beberapa objek dengan nilai dari tipe yang sebelumnya tidak diketahui.  Atau, dengan kata lain, perlu bahwa nilai dari tipe yang sebelumnya tidak diketahui bertindak sebagai kunci dalam beberapa jenis peta. </p><br><p> Secara alami, kami tidak gila dan kami tidak akan membutuhkan dukungan nilai dari jenis apa pun.  Kami mengharuskan jenis (bahkan jika tidak diketahui) mendukung perbandingan dalam arti pemesanan.  Dalam istilah Haskell, ini berarti bahwa kami mendukung tipe <code>a</code> yang mengimplementasikan kelas <code>Ord a</code> . </p><br><p>  Perhatikan bahwa kita dapat meminta dukungan untuk melakukan hash dan memeriksa kesetaraan, tetapi karena sejumlah alasan akan lebih mudah dan jelas untuk membatasi diri kita sebagai pembanding. </p><br><p>  Ketika datang untuk menyimpan nilai yang dikenal untuk mengimplementasikan beberapa jenis kelas, tipe eksistensial biasanya digunakan di Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkSomeOrd</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span></span></code> </pre> <br><p>  Jadi, jika kita diberi objek bertipe <code>SomeOrd</code> dan kita membuat pola yang cocok untuk itu: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bar</span></span> foo (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val) = ... (<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  kemudian pada titik <code>(1)</code> kita tidak tahu tipe <code>val</code> yang mana, tetapi kita tahu (dan, yang terpenting, timer juga tahu) bahwa <code>val</code> mengimplementasikan timeclass <code>Ord</code> . </p><br><p>  Namun, jika fungsi tipe kelas menyiratkan dua (atau lebih) argumen, maka penggunaan catatan semacam itu tidak banyak berguna: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tryCompare</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> tryCompare (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val1) (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val2) = ?</code> </pre> <br><p>  Untuk menggunakan metode <code>Ord</code> , perlu bahwa <code>val</code> dan <code>val2</code> jenis yang sama, tetapi ini tidak harus dilakukan sama sekali!  Ternyata <code>SomeOrd</code> kita <code>SomeOrd</code> berguna.  Apa yang harus dilakukan </p><br><p>  Terlepas dari kenyataan bahwa Haskell adalah bahasa yang dikompilasi dengan penghapusan tipe agresif (setelah kompilasi, mereka tidak ada di sana secara umum), kompilator masih dapat menghasilkan perwakilan tipe runtime jika ditanya tentang hal itu.  Perwakilan peran tipe <code>a</code> adalah nilai tipe <code>TypeRep a</code> , dan <del>  permintaan </del>  generasi dijawab oleh typeclass <code>Typeable</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Ngomong-ngomong</b> <div class="spoiler_text"><p>  By the way, <code>a</code> tidak harus menjadi tipe dalam arti biasa, yaitu, milik varietas <code>*</code> .  Ini bisa berupa jenis <code>k</code> , yang secara teoritis memungkinkan Anda untuk melakukan beberapa hal keren dengan menyimpan perwakilan runtime dari tipe yang dipelajari dan sejenisnya, tetapi saya belum menemukan apa sebenarnya. </p></div></div><br><p>  Selain itu, jika kita memiliki dua contoh berbeda dari <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> , maka kita dapat membandingkannya dan memeriksa apakah mereka mewakili jenis yang sama atau tidak.  Apalagi jika mereka benar-benar mewakili tipe yang sama, maka jelas bertepatan dengan <code>b</code> .  Dan, yang paling penting, fungsi memeriksa representasi tipe untuk kesetaraan menghasilkan hasil yang dapat meyakinkan juru ketik ini: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eqTypeRep</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> k1 k2 (a :: k1) (b :: k2). <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (a :~~: b)</code> </pre> <br><p>  Omong kosong apa yang tertulis di sini? </p><br><p>  Pertama, <code>eqTypeRep</code> adalah sebuah fungsi. </p><br><p>  Kedua, polimorfik, tetapi tidak hanya berdasarkan jenis, tetapi juga oleh varietas jenis ini.  Ini ditunjukkan oleh bagian <code>forall k1 k2 (a :: k1) (b :: k2)</code> - ini berarti bahwa <code>a</code> dan <code>b</code> tidak hanya tipe biasa seperti <code>Int</code> atau <code>[String]</code> , tetapi juga, misalnya, konstruktor terkenal (lihat DataKinds dan upaya lain untuk membuat Haskell tersertifikasi).  Tapi kami tidak membutuhkan semua ini. </p><br><p>  Ketiga, ia menerima dua representasi runtime dari tipe yang berpotensi berbeda, <code>TypeRep a</code> dan <code>TypeRep b</code> . </p><br><p>  Keempat, mengembalikan nilai tipe <code>Maybe (a :~~: b)</code> .  Hal paling menarik terjadi di sini. </p><br><p>  Jika jenisnya tidak cocok, maka fungsinya mengembalikan <code>Nothing</code> biasa, dan semuanya baik-baik saja.  Jika jenisnya cocok, maka fungsi mengembalikan <code>Just val</code> , di mana <code>val</code> bertipe <code>a :~~: b</code> .  Mari kita lihat apa itu: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Kind heterogeneous propositional equality. Like ':~:', @a :~~: b@ is -- inhabited by a terminating value if and only if @a@ is the same type as @b@. -- -- @since 4.10.0.0 data (a :: k1) :~~: (b :: k2) where HRefl :: a :~~: a</span></span></code> </pre> <br><p>  Sekarang mari kita bicara.  Misalkan kita mendapatkan nilai <code>val</code> dari tipe <code>a :~~: b</code> .  Bagaimana itu bisa dibangun?  Satu-satunya cara adalah dengan konstruktor <code>HRefl</code> , dan konstruktor ini mensyaratkan bahwa di kedua sisi ikon <code>:~~:</code> itu harus sama.  Karena itu, bertepatan dengan <code>b</code> .  Apalagi, jika kita zapternnom-match on <code>val</code> , maka taypcheker akan mengetahuinya juga.  Oleh karena itu, ya, fungsi <code>eqTypeRep</code> mengembalikan bukti bahwa dua tipe yang berpotensi berbeda adalah sama jika sebenarnya sama. </p><br><p>  Namun, dalam paragraf di atas, saya berbohong.  Tidak ada yang menghentikan kita <em>dari menulis di Haskell</em> </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = wrong <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre> <br><p>  atau </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = undefined</code> </pre> <br><p>  atau hancurkan sistem dengan banyak cara yang kurang jelas.  Ini adalah salah satu manifestasi yang terkenal di kalangan sempit yang mengatakan bahwa Haskell tidak konsisten sebagai logika.  Dalam bahasa dengan sistem tipe yang lebih kuat, definisi seperti itu tidak dicap. </p><br><p>  Itulah sebabnya dalam bagian dokumentasi yang dikutip di atas, nilai <em>terminating</em> disebutkan.  Kedua varian implementasi <code>wrong</code> atas tidak menghasilkan nilai yang sangat terminasi ini, yang memberi kita sedikit alasan dan kepercayaan: jika program kita di Haskell <em>dihentikan</em> (dan tidak mengalami <code>undefined</code> ), maka hasilnya sesuai dengan jenis yang ditulis.  Namun, di sini ada beberapa detail yang terkait dengan kemalasan, tetapi kami tidak akan membuka topik ini. </p><br><p>  Dan omong-omong, manifestasi kedua dari kelemahan Haskell dalam kode di atas adalah jenis fungsi <code>eqTypeRep</code> .  Dalam bahasa yang lebih kuat, itu akan mengembalikan nilai dari tipe yang lebih kuat, yang tidak hanya akan membuktikan kesetaraan jenis jika mereka benar-benar sama, tetapi juga akan membuktikan <em>ketidaksetaraan</em> mereka jika mereka sebenarnya tidak setara.  Namun, ketidakkonsistenan dari logika Haskell membuat fungsi-fungsi seperti itu menjadi sedikit tidak berguna: itu semua penting ketika Anda menggunakan bahasa sebagai pembuktian teorema, dan bukan sebagai bahasa pemrograman, dan tidak menggunakan Haskell sebagai pembanding. </p><br><p>  Oh well, cukup dari teori log dan ketik, mari kita kembali ke metrik kami. <del>  Sekarang hanya menggambar burung hantu </del>  Diskusi di atas mengisyaratkan bahwa itu cukup untuk menyimpan dalam tipe eksistensial kita juga ini adalah representasi paling runtime dari tipe tersebut, dan semuanya akan baik-baik saja. </p><br><p>  Ini membawa kita ke implementasi tipe pembungkus berikut: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val</span></span></code> </pre> <br><p>  Sekarang kita menulis fungsi yang mengambil yang berikut: </p><br><ol><li>  dua nilai tipe <code>Dyn</code> ; </li><li>  fungsi yang menghasilkan sesuatu untuk dua nilai dari <em>jenis apa pun</em> , <br>  hanya berdasarkan konstanta yang disebutkan saat membuat <code>Dyn</code> ( <code>forall</code> bertanggung jawab untuk ini), <br>  dan yang disebut jika kedua <code>Dyn</code> menyimpan nilai dari tipe yang sama; </li><li>  dan fungsi fallback, yang disebut bukan yang sebelumnya, jika jenisnya masih berbeda: </li></ol><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withDyns</span></span> :: (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Ord</span></span> a =&gt; a -&gt; a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; b withDyns f def (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty1 v1) (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty2 v2) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eqTypeRep ty1 ty2 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; def (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty1) (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty2) <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">HRefl</span></span> -&gt; f v1 v2</code> </pre> <br><p>  <code>SomeTypeRep</code> adalah pembungkus eksistensial atas <code>TypeRep a</code> untuk <code>a</code> . </p><br><p>  Sekarang kita dapat menerapkan, misalnya, pengecekan dan perbandingan kesetaraan: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  Di sini kami mengambil keuntungan dari fakta bahwa <code>SomeTypeRep</code> dapat dibandingkan satu sama lain, sehingga fungsi mundur untuk pemesanan juga <code>compare</code> . </p><br><p>  Selesai </p><br><p>  Hanya sekarang ini dosa untuk tidak menggeneralisasi: kami mencatat bahwa di dalam <code>Dyn</code> , <code>toDyn</code> , <code>withDyns</code> kami tidak menggunakan <code>Ord</code> secara khusus, dan ini bisa berupa rangkaian konstanta lain, sehingga kami dapat mengaktifkan ekstensi <code>ConstraintKinds</code> dan <em>menggeneralisasi</em> dengan parameterisasi <code>Dyn</code> serangkaian pembatasan tertentu yang kami dibutuhkan dalam tugas khusus kami: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: ctx a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val withDyns :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; b withDyns (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">) f def = case eqTypeRep ty1 ty2 of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> -&gt; def (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HRefl</span></span></span><span class="hljs-class"> -&gt; f v1 v2</span></span></code> </pre> <br><p>  Kemudian <code>Dyn Ord</code> akan menjadi tipe <code>Dyn Monoid</code> , dan, katakanlah, <code>Dyn Monoid</code> akan memungkinkan Anda untuk menyimpan monoid yang sewenang-wenang dan melakukan sesuatu yang monoidal dengannya. </p><br><p>  Mari kita menulis contoh yang kita butuhkan untuk <code>Dyn</code> baru kita: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  ... hanya ini yang tidak berfungsi.  Typecher tidak tahu bahwa <code>Dyn Ord</code> juga mengimplementasikan <code>Eq</code> , <br>  karena itu Anda harus menyalin seluruh hierarki: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns d1 d2 compare compare</code> </pre> <br><p>  Nah, sekarang sudah pasti. </p><br><p>  ... mungkin, dalam Haskell modern, Anda dapat membuatnya sehingga timer itu sendiri menampilkan contoh formulir </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_i</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_1</span></span></span><span class="hljs-class">, ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_n</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  karena ada sesuatu yang prologikal keluar, tetapi saya belum melakukannya, saya harus duduk memetiknya.  Tetap disini. </p><br><p>  Dan juga, jika Anda dengan hati-hati menyipitkan mata, Anda dapat melihat bahwa <code>Dyn</code> kami terlihat mencurigakan seperti pasangan jenis yang bergantung <code>(ty : Type ** val : ty)</code> dari bahasa samar.  Tetapi hanya dalam bahasa yang saya kenal tidak mungkin untuk mencocokkan jenisnya, karena parametrikitas (yang dalam hal ini, IMHO, ditafsirkan terlalu luas), tetapi di sini tampaknya mungkin. </p><br><p>  Tapi yang paling penting - sekarang Anda dapat dengan aman memiliki sesuatu seperti <code>Map (Dyn Ord) SomeValue</code> dan menggunakan nilai apa pun sebagai kunci, selama mereka sendiri mendukung perbandingan.  Misalnya, pengidentifikasi dengan deskripsi metrik dapat digunakan sebagai kunci, tetapi ini adalah topik untuk artikel selanjutnya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457930/">https://habr.com/ru/post/id457930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457910/index.html">WebFPGA - Pengembangan Verilog di browser</a></li>
<li><a href="../id457916/index.html">Solusi tugas WorldSkills dari modul Network dalam kompetensi "CCA". Bagian 2 - Pengaturan Dasar</a></li>
<li><a href="../id457920/index.html">Jet world: buka akses gratis ke laporan konferensi Joker 2018 + ulasan tentang sepuluh besar</a></li>
<li><a href="../id457926/index.html">Perbandingan Sertifikasi Agile, Bagian 1 - ICAgile, Scrum.org, ScrumAlliance dan PMI</a></li>
<li><a href="../id457928/index.html">Pemeringkatan mendalam untuk membandingkan dua gambar</a></li>
<li><a href="../id457932/index.html">Analisis kontes Bypass IDS di Positive Hack Days 9</a></li>
<li><a href="../id457936/index.html">Kami mengundang Anda ke konferensi Zabbix pertama di Rusia</a></li>
<li><a href="../id457940/index.html">Cara mengintip ke pihak lawan</a></li>
<li><a href="../id457942/index.html">Apa yang saya pelajari tentang pengoptimalan dengan Python</a></li>
<li><a href="../id457946/index.html">10 perpustakaan JavaScript terbaik untuk memvisualisasikan data pada grafik dan bagan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>