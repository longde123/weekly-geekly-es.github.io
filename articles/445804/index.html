<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üë©üèæ‚Äçü§ù‚Äçüë®üèº Encapsulaci√≥n para samurai real, o los matices asociados con la palabra clave interna en C # üí± ‚õ©Ô∏è üêÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo: interno es nuevo p√∫blico 


 Cada uno de nosotros so√±√≥ con un proyecto donde todo se har√≠a bien. Parece bastante natural. Tan pronto como se ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encapsulaci√≥n para samurai real, o los matices asociados con la palabra clave interna en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445804/"><h2>  Pr√≥logo: interno es nuevo p√∫blico </h2><br><p>  Cada uno de nosotros so√±√≥ con un proyecto donde todo se har√≠a bien.  Parece bastante natural.  Tan pronto como se entere de la posibilidad de escribir un buen c√≥digo, tan pronto como escuche leyendas sobre el mismo c√≥digo que puede leerse y modificarse f√°cilmente, inmediatamente se ilumina: "Bueno, ahora lo har√© bien, soy inteligente y leo McConnell". </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="imagen"><br><br><p>  Tal proyecto sucedi√≥ en mi vida.  Otro.  Y lo estoy haciendo bajo supervisi√≥n voluntaria, donde cada l√≠nea que sigo.  En consecuencia, no solo quer√≠a hacerlo, sino que ten√≠a que hacer todo bien.  Uno de los "correctos" fue "respetar la encapsulaci√≥n y acercarse al m√°ximo, porque siempre tienes tiempo para abrir, y entonces ser√° demasiado tarde para cerrar".  Y por lo tanto, donde pude, comenc√© a usar el modificador de acceso interno en lugar de p√∫blico para las clases.  Y, por supuesto, cuando comienzas a utilizar activamente una nueva funci√≥n de lenguaje para ti, surgen algunos matices.  Quiero hablar sobre ellos en orden. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Ayuda b√°sica ofensiva</b> <div class="spoiler_text"><p>  Solo para recordar y etiquetar. </p><br><ul><li>  Assembly es la unidad de implementaci√≥n m√°s peque√±a en .NET y una de las unidades de compilaci√≥n b√°sicas.  Tal como est√°, esto es .dll o .exe.  Dicen que se puede dividir en varios archivos llamados m√≥dulos. </li><li>  modificador de acceso p√∫blico, lo que significa que es accesible para todos los que est√©n marcados con √©l. </li><li>  modificador de acceso interno, lo que significa que est√° marcado solo disponible dentro del ensamblaje. </li><li>  protegido: un modificador de acceso que indica que est√° marcado solo disponible para los herederos de la clase en la que se encuentra el marcado. </li><li>  privado: un modificador de acceso que indica que est√° marcado solo disponible para la clase en la que se encuentra.  Y nadie mas. </li></ul><br></div></div><br><h2>  Pruebas unitarias y compilaciones amigables </h2><br><p>  En C ++, hab√≠a una caracter√≠stica tan extra√±a como las clases amistosas.  Las clases se pod√≠an asignar como amigos, y luego se borraba el l√≠mite de encapsulaci√≥n entre ellos.  Sospecho que esta no es la caracter√≠stica m√°s extra√±a en C ++.  Quiz√°s incluso los diez primeros m√°s extra√±os no est√°n incluidos.  Pero pegarse un tiro en el pie al vincular varias clases estrechamente, de alguna manera es demasiado f√°cil, y es muy dif√≠cil encontrar un caso adecuado para esta funci√≥n. </p><br><p>  Lo m√°s sorprendente fue aprender que en .NET hay ensamblajes amigables, una especie de replanteamiento.  Es decir, puede hacer que un ensamblaje vea lo que est√° oculto detr√°s del bloqueo interno en otro ensamblaje.  Cuando me enter√© de esto, me sorprendi√≥ un poco.  Bueno, ¬øc√≥mo lo har√≠a, por qu√©?  Cual es el punto?  ¬øQui√©n unir√° firmemente a las dos asambleas, comprometidas en su separaci√≥n?  Casos en que en cualquier situaci√≥n incomprensible moldean al p√∫blico, no lo consideramos en este art√≠culo. </p><br><p>  Y luego, en el mismo proyecto, comenc√© a aprender una de las ramas del camino de un verdadero samurai: las pruebas unitarias.  Y en las pruebas unitarias de Feng Shui deben realizarse en un ensamblaje separado.  Para el mismo Feng Shui, todo lo que se puede ocultar dentro del ensamblaje, debe esconderse dentro del ensamblaje.  Me enfrent√© a una elecci√≥n muy, muy desagradable.  O las pruebas se colocar√°n una al lado de la otra y se dirigir√°n al cliente junto con el c√≥digo √∫til para √©l, o todo estar√° cubierto por la palabra clave public, cu√°nto tiempo ha estado el pan en la humedad. </p><br><p>  Y aqu√≠, desde alg√∫n lugar en los contenedores de mi memoria, se obtuvo algo sobre asambleas amistosas.  Result√≥ que si tienes el ensamblado "YourAssemblyName", puedes escribir as√≠: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  Y el ensamblado "YourAssemblyName.Tests" ver√° lo que est√° marcado con la palabra clave interna en "YourAssemblyName".  Esta l√≠nea se puede ingresar, solo un poco, en AssemblyInfo.cs, que VS crea espec√≠ficamente para almacenar dichos atributos. </p><br><div class="spoiler">  <b class="spoiler_title">Volver abusivo a la ayuda b√°sica</b> <div class="spoiler_text">  En .NET, adem√°s de los atributos o palabras clave ya incorporados como abstracto, p√∫blico, interno, est√°tico, puede crear los suyos propios.  Y cu√©lguelos en lo que desee: campos, propiedades, clases, m√©todos, eventos y ensamblajes completos.  En C #, para esto simplemente escribe el nombre del atributo entre corchetes antes de lo que espera.  La excepci√≥n es el ensamblaje en s√≠, ya que no hay ninguna indicaci√≥n directa en ninguna parte del c√≥digo de que "El ensamblaje comienza aqu√≠".  All√≠, antes del nombre del atributo, debe agregar ensamblado: <br></div></div><br><p>  Por lo tanto, los lobos permanecen llenos, las ovejas est√°n a salvo, todo lo que es posible todav√≠a se esconde dentro de la asamblea, las pruebas unitarias viven en una asamblea separada, como deber√≠a ser, y una caracter√≠stica que apenas recordaba tiene una raz√≥n para usarla.  Quiz√°s la √∫nica raz√≥n existente. </p><br><p>  Casi olvido un punto importante.  La acci√≥n de atributo InternalsVisibleTo es unidireccional. </p><br><h2>  protegido &lt;interno? </h2><br><p>  Entonces la situaci√≥n: A y B estaban sentados en una tuber√≠a. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A fue destruido en el proceso de revisi√≥n del c√≥digo, ya que no se usa fuera del ensamblado, pero por alguna raz√≥n se permite tener un modificador de acceso p√∫blico, B caus√≥ un error de compilaci√≥n, lo que podr√≠a provocar un estupor en los primeros minutos. </p><br><p>  B√°sicamente, el mensaje de error es l√≥gico.  El descriptor de acceso a la propiedad no puede revelar m√°s que la propiedad misma.  Cualquiera reaccionar√° con comprensi√≥n si el compilador da un encabezado para esto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Pero las afirmaciones de esta l√≠nea rompen inmediatamente el cerebro: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Observo que no habr√° quejas sobre esta l√≠nea: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Si no piensa mucho, la siguiente jerarqu√≠a se construye en su cabeza: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  Y esta jerarqu√≠a parece funcionar incluso.  Excepto por un lugar.  Donde interno&gt; protegido.  Para comprender la esencia de las afirmaciones del compilador, recordemos qu√© restricciones imponen los internos y los protegidos.  interno: solo dentro del conjunto.  protegido - solo herederos.  Observe a los herederos.  Y si la clase B est√° marcada como p√∫blica, en otro ensamblaje puede definir sus descendientes.  Y luego el conjunto de acceso realmente obtiene acceso a donde toda la propiedad no lo tiene.  Como el compilador de C # es paranoico, ni siquiera puede permitir tal posibilidad. </p><br><p>  Gracias a √©l por esto, pero debemos darles a los herederos acceso al descriptor de acceso.  Y espec√≠ficamente para tales casos, hay un modificador de acceso interno protegido. </p><br><div class="spoiler">  <b class="spoiler_title">Esta ayuda no es tan ofensiva</b> <div class="spoiler_text"><ul><li>  interno protegido: un modificador de acceso que indica que el marcado est√° disponible dentro del ensamblaje <strong>o para los</strong> herederos de la clase en la que se encuentra el marcado. </li></ul><br></div></div><br><p>  Entonces, si queremos que el compilador nos permita usar esta propiedad y establecerla en los herederos, debemos hacer esto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  Y la jerarqu√≠a correcta de modificadores de acceso se ve as√≠: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Interfaces </h2><br><p>  Entonces, la situaci√≥n: A, I, B est√°bamos sentados en la tuber√≠a. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Nos sentamos exactamente y no nos entrometimos fuera de la asamblea.  Pero fueron rechazados por el compilador.  Aqu√≠ la esencia de las afirmaciones queda clara en el mensaje de error.  La implementaci√≥n de la interfaz debe estar abierta.  Incluso si la interfaz en s√≠ est√° cerrada.  Ser√≠a l√≥gico vincular el acceso a la implementaci√≥n de la interfaz con su disponibilidad, pero lo que no es, no lo es.  La implementaci√≥n de la interfaz debe ser p√∫blica. </p><br><p>  Y tenemos dos salidas.  Primero: a trav√©s del crujido y el crujir de dientes, cuelgue un modificador de acceso p√∫blico en la implementaci√≥n de la interfaz.  Segundo: implementaci√≥n expl√≠cita de la interfaz.  Se ve as√≠: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Tenga en cuenta que en el segundo caso no hay modificador de acceso.  ¬øPara qui√©n en este caso est√° disponible la implementaci√≥n del m√©todo?  Digamos que nadie.  Es m√°s f√°cil mostrar con un ejemplo: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  La implementaci√≥n expl√≠cita de la interfaz I significa que hasta que expulsamos expl√≠citamente la variable al tipo I, no hay m√©todos que implementen esta interfaz.  Escribir (b como I) .SomeMethod () cada vez puede ser una sobrecarga.  Como ((I) b) .SomeMethod ().  Y encontr√© dos formas de evitar esto.  Pens√© en uno, y honestamente busqu√© en Google el segundo. </p><br><p>  La primera forma es la f√°brica: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Bueno, o cualquier otro patr√≥n que te permita ocultar este matiz. </p><br><p>  M√©todo dos - m√©todos de extensi√≥n: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  Sorprendentemente, funciona.  Estas l√≠neas dejan de arrojar un error: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  Despu√©s de todo, la llamada llega, como IntelliSense nos dice en Visual Studio, no a los m√©todos para implementar expl√≠citamente la interfaz, sino a los m√©todos de extensi√≥n.  Y nadie proh√≠be recurrir a ellos.  Y pueden llamarse m√©todos de extensi√≥n de interfaz en todas sus implementaciones. </p><br><p>  Pero queda una advertencia.  Dentro de la propia clase, debe acceder a este m√©todo a trav√©s de la palabra clave this; de lo contrario, el compilador no comprender√° que queremos hacer referencia al m√©todo de extensi√≥n: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  Y as√≠, y as√≠, tenemos o p√∫blico, donde no deber√≠a estar, pero all√≠ <em>parece</em> no hacer da√±o, o un peque√±o c√≥digo adicional para cada interfaz interna.  Elige el mal menor a tu gusto. </p><br><h2>  Reflexion </h2><br><p>  Golpe√© esto dolorosamente cuando intent√© encontrar un constructor a trav√©s de la reflexi√≥n, que, por supuesto, estaba marcado como interno en la clase interna.  Y result√≥ que la reflexi√≥n no dar√° nada que no sea p√∫blico.  Y esto, en principio, es l√≥gico. </p><br><p>  En primer lugar, reflexi√≥n, si recuerdo correctamente lo que escribieron las personas inteligentes en los libros inteligentes, se trata de encontrar informaci√≥n en los metadatos del ensamblado.  Lo cual, en teor√≠a, no deber√≠a ceder demasiado (al menos eso pens√©).  En segundo lugar, el uso principal de la reflexi√≥n es hacer que su programa sea extensible.  Proporcionas alg√∫n tipo de interfaz a los extra√±os (tal vez incluso en forma de interfaces, ¬°fiy-ha!).  Y lo implementan y proporcionan complementos, modificaciones, extensiones en forma de un ensamblaje cargado sobre la marcha, desde el cual los obtiene la reflexi√≥n.  Y por s√≠ mismo, su API ser√° p√∫blica.  Es decir, mirar internamente a trav√©s de la reflexi√≥n no es t√©cnicamente ni tiene sentido desde un punto de vista pr√°ctico. </p><br><p>  <strong>Actualizaci√≥n</strong>  Aqu√≠, en los comentarios, result√≥ que la reflexi√≥n permite, si lo solicita expl√≠citamente, reflejar todo.  Ya sea interno, incluso privado.  Si no est√° escribiendo alg√∫n tipo de herramienta de an√°lisis de c√≥digo, intente no hacerlo, por favor.  El texto a continuaci√≥n sigue siendo relevante para los casos en los que estamos buscando tipos de miembros abiertos.  Y en general, no pase comentarios, hay muchas cosas interesantes. </p><br><p>  Esto podr√≠a terminar con la reflexi√≥n, pero volvamos al ejemplo anterior, donde A, I, B estaban sentados en una tuber√≠a: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  El autor de la clase A decidi√≥ que no pasar√≠a nada malo si el m√©todo de la clase interna se marcara como p√∫blico, de modo que el compilador no doliera y no hubiera necesidad de poner m√°s c√≥digo en √©l.  La interfaz est√° marcada como interna, la clase que la implementa est√° marcada como interna, desde el exterior parece que no hay forma de llegar al m√©todo marcado como p√∫blico. </p><br><p>  Y luego la puerta se abre y la reflexi√≥n se arrastra silenciosamente: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  Estudie este c√≥digo, ll√©velo al estudio, si as√≠ lo desea.  Aqu√≠ estamos tratando de usar la reflexi√≥n para encontrar todos los m√©todos de todos los tipos de nuestra tuber√≠a (tuber√≠a de espacio de nombres).  Y aqu√≠ est√°n los resultados que nos da: </p><br><blockquote>  En el tipo I encontramos Void SomeMethod () <br>  NULL!  No se puede encontrar el m√©todo SomeMethod en el tipo IExtensions <br>  En el tipo A encontramos Void SomeMethod () <br>  NULL!  No se puede encontrar el m√©todo OtherMethod en el tipo A <br>  NULL!  No se puede encontrar el m√©todo SomeMethod en el tipo B <br>  NULL!  No se puede encontrar el m√©todo OtherMethod en el tipo B <br></blockquote><br><p>  Debo decir de inmediato que usando un objeto de tipo MethodInfo, se puede llamar al m√©todo encontrado.  Es decir, si la reflexi√≥n encontr√≥ algo, entonces la encapsulaci√≥n puede violarse puramente te√≥ricamente.  Y hemos encontrado algo.  En primer lugar, el mismo vac√≠o p√∫blico SomeMethod () de la clase A. Se esperaba, qu√© m√°s decir.  Esta indulgencia a√∫n puede tener consecuencias.  En segundo lugar, anule SomeMethod () de la interfaz I. Esto ya es m√°s interesante.  No importa c√≥mo nos encerramos, los m√©todos abstractos ubicados en la interfaz (o lo que el CLR realmente coloca all√≠) est√°n realmente abiertos.  De ah√≠ la conclusi√≥n hecha en un p√°rrafo separado: </p><br><p>  <em>Mire cuidadosamente a qui√©n y qu√© tipo de sistema. Tipo de tipo que est√° regalando.</em> </p><br><p>  Pero hay un matiz m√°s con estos dos m√©todos encontrados, que me gustar√≠a considerar.  Los m√©todos de interfaz interna y los m√©todos p√∫blicos de clases internas se pueden encontrar utilizando la reflexi√≥n.  Como persona razonable, concluir√© que caen en los metadatos.  Como persona experimentada, verificar√© esta conclusi√≥n.  Y en este ILDasm nos ayudar√°. </p><br><div class="spoiler">  <b class="spoiler_title">Echa un vistazo al agujero del conejo en los metadatos de nuestra pipa</b> <div class="spoiler_text"><p>  El ensamblaje se ensambl√≥ en versi√≥n </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  Una mirada r√°pida muestra que <strong>todo</strong> entra en los metadatos, sin importar c√≥mo est√© marcado.  La reflexi√≥n a√∫n nos oculta cuidadosamente que se supone que los extra√±os no deben ver.  Por lo tanto, puede ser que las cinco l√≠neas de c√≥digo adicionales para cada m√©todo de la interfaz interna no sean un gran mal.  Sin embargo, la conclusi√≥n principal sigue siendo la misma: </p><br><p>  <em>Mire cuidadosamente a qui√©n y qu√© tipo de sistema. Tipo de tipo que est√° regalando.</em> </p><br><p>  Pero este es, por supuesto, el siguiente nivel, despu√©s de la adhesi√≥n de la palabra clave interna en todos los lugares donde no hay necesidad de p√∫blico. </p><br><h2>  PS </h2><br><p>  ¬øSabes que lo mejor de usar la palabra clave interna est√° en todas partes dentro del ensamblaje?  Cuando crece, debes dividirlo en dos o m√°s.  Y en el proceso, debes tomar un descanso para abrir algunos tipos.  Y tiene que pensar exactamente qu√© tipos son dignos de abrirse.  Al menos brevemente. </p><br><p>  Esto significa lo siguiente: <em>esta pr√°ctica de escribir c√≥digo lo har√° pensar nuevamente sobre qu√© forma tomar√° el l√≠mite arquitect√≥nico entre los conjuntos reci√©n nacidos.</em>  ¬øQu√© podr√≠a ser m√°s hermoso? </p><br><h2>  PPS </h2><br><p>  A partir de la versi√≥n C # 7.2, apareci√≥ un nuevo modificador de acceso, privado protegido.  Y todav√≠a no tengo idea de qu√© es y con qu√© se come.  Desde que no se encuentra en la pr√°ctica.  Pero me alegrar√° saber en los comentarios.  Pero no copie y pegue de la documentaci√≥n, sino casos reales en los que este modificador de acceso puede ser necesario. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445804/">https://habr.com/ru/post/445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445794/index.html">Gigantes de TI presentan una soluci√≥n de implementaci√≥n de nube h√≠brida h√≠brida</a></li>
<li><a href="../445796/index.html">Fintech Digest: Dorsey paga con bitcoins, la estrategia blockchain de Australia, la salida a bolsa de Levi, el alcalde de Chicago y la inevitabilidad de bitcoin</a></li>
<li><a href="../445798/index.html">Rhinoceros dentro del gato: ejecute el firmware en el emulador Kopycat</a></li>
<li><a href="../445800/index.html">M√≥nadas en 15 minutos</a></li>
<li><a href="../445802/index.html">5 cosas sobre las tendencias de Internet que todo el mundo deber√≠a saber</a></li>
<li><a href="../445806/index.html">C√≥mo la inteligencia artificial est√° cambiando la ciencia</a></li>
<li><a href="../445808/index.html">Odiamos y cazamos: la vida peligrosa de un virus que est√° haciendo enemigos poderosos</a></li>
<li><a href="../445814/index.html">C√≥mo un robot de entrega ha cambiado los h√°bitos culinarios de los estudiantes estadounidenses</a></li>
<li><a href="../445816/index.html">C√≥mo vimos la representaci√≥n del servidor y qu√© surgi√≥</a></li>
<li><a href="../445820/index.html">MVCC-3. Versiones de fila</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>