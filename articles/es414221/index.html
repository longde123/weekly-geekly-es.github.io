<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèø üòº üëë Analizando y trabajando con Codificable en Swift 4 üíº ‚úäüèΩ ü§òüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El formato JSON ha ganado gran popularidad, generalmente se usa para la transferencia de datos y la ejecuci√≥n de consultas en aplicaciones cliente-ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analizando y trabajando con Codificable en Swift 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414221/"><img src="https://habrastorage.org/webt/ps/2a/r0/ps2ar08o0byyxycknlktyhdafoq.jpeg"><br><br>  El formato JSON ha ganado gran popularidad, generalmente se usa para la transferencia de datos y la ejecuci√≥n de consultas en aplicaciones cliente-servidor.  El an√°lisis JSON requiere herramientas de codificaci√≥n / decodificaci√≥n de este formato, y Apple las actualiz√≥ recientemente.  En este art√≠culo, analizaremos los m√©todos de an√°lisis JSON utilizando el protocolo <i>Decodable</i> , compararemos el nuevo protocolo <i>Codable</i> con el predecesor <i>NSCoding</i> , evaluaremos las ventajas y desventajas, analizaremos todo con ejemplos espec√≠ficos y tambi√©n consideraremos algunas de las caracter√≠sticas encontradas al implementar los protocolos. <br><a name="habracut"></a><br><br>  <b>¬øQu√© es codificable?</b> <br><br>  En WWDC2017, junto con la nueva versi√≥n de Swift 4, Apple present√≥ nuevas herramientas de codificaci√≥n / decodificaci√≥n de datos implementadas por los siguientes tres protocolos: <br><br>  - <b>Codificable</b> <br>  - <b>Codificable</b> <br>  - <b>Decodificable</b> <br><br>  En la mayor√≠a de los casos, estos protocolos se usan para trabajar con JSON, pero adem√°s tambi√©n se usan para guardar datos en el disco, transferirlos a trav√©s de la red, etc.  Encodable se utiliza para convertir estructuras de datos Swift en objetos JSON, mientras que Decodable, por el contrario, ayuda a convertir objetos JSON en modelos de datos Swift.  El protocolo codificable combina los dos anteriores y es su tipo: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Codable</span></span> = <span class="hljs-type"><span class="hljs-type">Encodable</span></span> &amp; <span class="hljs-type"><span class="hljs-type">Decodable</span></span></code> </pre> <br><br>  Para cumplir con estos protocolos, los tipos de datos deben implementar los siguientes m√©todos: <br><br>  <i>Codificable</i> <br>  codificar (a :) - codifica el modelo de datos en el tipo de codificador dado <br><br>  <i>Decodificable</i> <br>  init (from :) - inicializa el modelo de datos del decodificador provisto <br><br>  <i>Codificable</i> <br>  codificar (a :) <br>  init (de :) <br><br>  <b>Un caso de uso simple</b> <br><br>  Ahora considere un ejemplo simple de uso de <i>Codificable</i> , ya que implementa <i>Codificable</i> y <i>Decodificable</i> , en este ejemplo puede ver de inmediato toda la funcionalidad del protocolo.  Digamos que tenemos la estructura de datos JSON m√°s simple: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nike shoes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><br>  El modelo de datos para trabajar con este JSON se ver√° as√≠: <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> price <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> quantity } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = encoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(title, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(price, forKey: .price) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(quantity, forKey: .quantity) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) price = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .price) quantity = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .quantity) } }</code> </pre><br><br>  Se implementan ambos m√©todos necesarios, la enumeraci√≥n tambi√©n se describe para determinar la lista de campos de codificaci√≥n / decodificaci√≥n.  De hecho, la escritura puede simplificarse enormemente porque <i>Codable</i> admite la <i>generaci√≥n</i> autom√°tica de los m√©todos codificar (a :) e init (desde :), as√≠ como la enumeraci√≥n necesaria.  Es decir, en este caso, puede escribir la estructura de la siguiente manera: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><br>  Extremadamente simple y minimalista.  Solo, no olvide que una grabaci√≥n tan concisa no funcionar√° si: <br><br>  - la <i>estructura de su modelo de datos es diferente de la que desea codificar / decodificar</i> <br><br>  - <i>es posible que deba codificar / decodificar propiedades adicionales adem√°s de las propiedades de su modelo de datos</i> <br><br>  - <i>Algunas propiedades de su modelo de datos pueden no ser compatibles con el protocolo Codificable.</i>  <i>En este caso, deber√° convertirlos del / al protocolo codificable</i> <br><br>  - <i>en caso de que los nombres de las variables en el modelo de datos y los nombres de los campos en el contenedor no coincidan</i> <br><br>  Como ya hemos considerado la definici√≥n m√°s simple de un modelo de datos, vale la pena dar un peque√±o ejemplo de su uso pr√°ctico: <br><br>  Entonces, en una l√≠nea, puede analizar la respuesta del servidor en formato JSON: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> product: <span class="hljs-type"><span class="hljs-type">Product</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">Product</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: data)</code> </pre> <br><br>  Y el siguiente c√≥digo, por el contrario, crear√° un objeto JSON a partir del modelo de datos: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productObject = <span class="hljs-type"><span class="hljs-type">Product</span></span>(title: <span class="hljs-string"><span class="hljs-string">"Cheese"</span></span>, price: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, quantity: <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> encodedData = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONEncoder</span></span>().encode(productObject)</code> </pre> <br><br>  Todo es muy conveniente y r√°pido.  <i>Una</i> vez descritos correctamente los modelos de datos y convertidos en <i>codificables</i> , literalmente puede codificar / decodificar datos en una l√≠nea.  Pero consideramos el modelo de datos m√°s simple que contiene una peque√±a cantidad de campos de un tipo simple.  Considere los posibles problemas: <br><br>  <b>No todos los campos en el modelo de datos son codificables.</b> <br><br>  Para que su modelo de datos implemente el protocolo <i>Codificable,</i> todos los campos del modelo deben ser compatibles con este protocolo.  De forma predeterminada, el protocolo <i>codificable</i> admite los siguientes tipos de datos: <i>Cadena, Int, Doble, Datos, URL</i> .  <i>Codificable</i> tambi√©n admite <i>Array, Diccionario, Opcional</i> , pero solo si contienen tipos <i>Codificables</i> .  Si algunas propiedades del modelo de datos no corresponden a <i>Codificables</i> , entonces deben ser llevadas a √©l. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type: <span class="hljs-type"><span class="hljs-type">PetType</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> age <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> type } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } }</code> </pre> <br><br>  Si en nuestro <i>modelo de</i> datos <i>codificables</i> usamos un tipo personalizado, por ejemplo, como <i>PetType</i> , y queremos codificarlo / decodificarlo, entonces tambi√©n debe implementar su init y codificar tambi√©n. <br><br>  <b>El modelo de datos no coincide con los campos JSON</b> <br><br>  Si se definen 3 campos en su modelo de datos, y 5 campos llegan a usted en el objeto JSON, 2 de los cuales son adicionales a 3, entonces nada cambiar√° en el an√°lisis, simplemente obtiene sus 3 campos de esos 5. Si sucede lo contrario situaci√≥n y en el objeto JSON habr√° al menos un campo del modelo de datos, se producir√° un error en tiempo de ejecuci√≥n. <br>  Si algunos campos pueden ser opcionales y ausentes peri√≥dicamente en un objeto JSON, entonces en este caso es necesario hacerlos opcionales: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productTypeId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currencyId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brand: <span class="hljs-type"><span class="hljs-type">Brand?</span></span> }</code> </pre> <br><br>  <b>Usando estructuras JSON m√°s complejas</b> <br><br>  A menudo, la respuesta del servidor es una matriz de entidades, es decir, solicita, por ejemplo, una lista de tiendas y obtiene una respuesta en el formulario: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=Myp6rSeCMUw"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1497868174</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/Myp6rSeCMUw/mqdefault.jpg"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"  2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=wsCEuNJmvd8"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1525952040</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/wsCEuNJmvd8/mqdefault.jpg"</span></span> } ] }</code> </pre><br>  En este caso, puede escribirlo y decodificarlo simplemente como una matriz de entidades <i>Shop</i> . <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShopListResponse</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> items } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> items: [<span class="hljs-type"><span class="hljs-type">Shop</span></span>] }</code> </pre> <br><br>  En este ejemplo, la funci√≥n autom√°tica <i>init</i> funcionar√°, pero si desea escribir la decodificaci√≥n usted mismo, deber√° especificar el tipo decodificado como una matriz: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.items = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode([<span class="hljs-type"><span class="hljs-type">Shop</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .items)</code> </pre> <br><br>  La estructura <i>Shop</i> tambi√©n debe implementar el protocolo <i>Decodable</i> , <i>respectivamente.</i> <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shop</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shortAddress: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdAt: <span class="hljs-type"><span class="hljs-type">Date?</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> shortAddress = <span class="hljs-string"><span class="hljs-string">"short_address"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> createdAt = <span class="hljs-string"><span class="hljs-string">"created_at"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.address = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .address) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.shortAddress = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .shortAddress) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.createdAt = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Date</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .createdAt) } }</code> </pre> <br><br>  Analizar esta matriz de elementos se ver√° as√≠: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsedResult: <span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data)</code> </pre> <br><br>  Por lo tanto, puede trabajar f√°cilmente con matrices de modelos de datos y usarlos dentro de otros modelos. <br><br>  <b>Formato de fecha</b> <br><br>  En este ejemplo, hay un matiz m√°s, aqu√≠ encontramos el uso del tipo <i>Fecha</i> .  Cuando se usa este tipo, puede haber problemas con la codificaci√≥n de la fecha y, por lo general, este problema es coherente con el back-end.  El formato predeterminado es <i>.deferToDate</i> : <br><br><pre> <code class="hljs vbscript">struct MyDate : Encodable { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myDate = MyDate(<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()) try! encoder.encode(foo)</code> </pre> <br><br>  <i>myDate</i> se ver√° as√≠: <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-number"><span class="hljs-number">519751611.12542897</span></span> }</code> </pre> <br><br>  Si necesitamos usar, por ejemplo, el formato <i>.iso8601</i> , entonces podemos cambiar f√°cilmente el formato usando la propiedad <i>dateEncodingStrategy</i> : <br><br><pre> <code class="hljs">encoder.dateEncodingStrategy = .iso8601</code> </pre> <br><br>  Ahora la fecha se ver√° as√≠: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-string"><span class="hljs-string">"2017-06-21T15:29:32Z"</span></span> }</code> </pre><br>  Tambi√©n puede usar un formato de fecha personalizado o incluso escribir su propio decodificador de fecha usando las siguientes opciones de formato: <br><br>  <i>.formatted (DateFormatter)</i> - su propio formato de decodificador de fecha <br>  <i>.custom ((Date, Encoder) throws -&gt; Void)</i> - crea tu propio formato de decodificaci√≥n de fecha por completo <br><br>  <b>Analizando objetos anidados</b> <br><br>  Ya hemos examinado c√≥mo puede usar modelos de datos dentro de otros modelos, pero a veces es necesario analizar los campos JSON incluidos en otros campos sin usar un modelo de datos separado.  El problema ser√° m√°s claro si lo consideramos con un ejemplo.  Tenemos el siguiente JSON: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-attr"><span class="hljs-attr">"art"</span></span>: <span class="hljs-string"><span class="hljs-string">"M0470500"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"- Vichy 50 "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ratings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"average_rating"</span></span>: <span class="hljs-number"><span class="hljs-number">4.1034</span></span>, <span class="hljs-attr"><span class="hljs-attr">"votes_count"</span></span>: <span class="hljs-number"><span class="hljs-number">29</span></span> } }</code> </pre> <br><br>  Necesitamos analizar los <i>campos</i> <i>"promedio"</i> y <i>"recuento de votos"</i> , esto se puede resolver de dos maneras, ya sea creando un modelo de datos de Calificaci√≥n con dos campos y <i>guardando</i> los datos en √©l, o puede usar <i>nestedContainer</i> .  Ya hemos discutido el primer caso, y el uso del segundo se ver√° as√≠: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> votesCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> averageRating: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> art <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ratings } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.art = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .art) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-comment"><span class="hljs-comment">// Nested ratings let ratingsContainer = try container.nestedContainer(keyedBy: RatingsCodingKeys.self, forKey: .ratings) self.votesCount = try ratingsContainer.decode(Int.self, forKey: .votesCount) self.averageRating = try ratingsContainer.decode(Double.self, forKey: .averageRating) } }</span></span></code> </pre> <br><br>  Es decir, este problema se resuelve creando otro contenedor adicional utilizando <i>nestedContainter</i> y su posterior an√°lisis.  Esta opci√≥n es conveniente si el n√∫mero de campos anidados no es tan grande; de ‚Äã‚Äãlo contrario, es mejor utilizar un modelo de datos adicional. <br><br>  <b>No coinciden los nombres de campo JSON y las propiedades del modelo de datos</b> <br><br>  Si presta atenci√≥n a c√≥mo se definen las enumeraciones en nuestros modelos de datos, puede ver que a los elementos de las enumeraciones a veces se les asigna una cadena que cambia el valor predeterminado, por ejemplo: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> }</code> </pre> <br><br>  Esto se hace para que los nombres de las variables del modelo y los campos JSON coincidan correctamente.  Esto generalmente se requiere para los campos cuyo nombre consta de varias palabras, y en JSON est√°n separados por guiones bajos.  En principio, tal redefinici√≥n de la enumeraci√≥n es la m√°s popular y parece simple, pero incluso entonces Apple ide√≥ una soluci√≥n m√°s elegante.  Este problema se puede resolver en una l√≠nea usando <i>keyDecodingStrategy</i> .  Esta caracter√≠stica apareci√≥ en Swift 4.1 <br><br>  Digamos que tiene un JSON de la forma: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonString = <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">" [ { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>MacBook Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 15, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 4 }, { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>iMac Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 27, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 18 } ] "</span></span><span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonData = Data(jsonString.utf8)</code> </pre> <br><br>  Vamos a crear un modelo de datos para ello: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mac</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> screenSize: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cpuCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre><br>  Las variables en el modelo se registran de acuerdo con el acuerdo, comienzan con una letra min√∫scula y luego cada palabra comienza con una letra may√∫scula (el llamado <i>camelCase</i> ).  Pero en JSON, los campos se escriben con guiones bajos (el llamado <i>snake_case</i> ).  Ahora, para que el an√°lisis tenga √©xito, necesitamos definir una enumeraci√≥n en el modelo de datos en el que estableceremos la correspondencia de los nombres de los campos JSON con los nombres de las variables, o obtendremos un error de tiempo de ejecuci√≥n.  Pero ahora es posible simplemente definir <i>keyDecodingStrategy</i> <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() decoder.keyDecodingStrategy = .convertFromSnakeCase <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> macs = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode([<span class="hljs-type"><span class="hljs-type">Mac</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: jsonData) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error.localizedDescription) }</code> </pre> <br><br>  Para la funci√≥n de <i>codificaci√≥n</i> , puede usar la transformaci√≥n inversa: <br><br><pre> <code class="hljs">encoder.keyEncodingStrategy = .convertToSnakeCase</code> </pre> <br><br>  Tambi√©n es posible personalizar <i>keyDecodingStrategy</i> utilizando el siguiente cierre: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonDecoder = JSONDecoder() jsonDecoder.keyDecodingStrategy = .custom { keys -&gt; CodingKey <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = keys.last!.stringValue.split(separator: <span class="hljs-string"><span class="hljs-string">"-"</span></span>).joined() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonKey(stringValue: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(key))! }</code> </pre> <br><br>  Esta entrada, por ejemplo, permite el uso del separador "-" para JSON.  Un ejemplo del JSON utilizado: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"first-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Taylor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Swift"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span> }</code> </pre><br>  Por lo tanto, a menudo se puede evitar una definici√≥n adicional de una enumeraci√≥n. <br><br>  <b>Manejo de errores</b> <br><br>  Al analizar JSON y convertir datos de un formato a otro, los errores son inevitables, as√≠ que veamos las opciones para manejar diferentes tipos de errores.  Al decodificar, son posibles los siguientes tipos de errores: <br><br><ul><li>  <i>DecodingError.dataCorrupted (DecodingError.Context)</i> : los datos est√°n da√±ados.  Por lo general, significa que los datos que intenta decodificar no coinciden con el formato esperado, por ejemplo, en lugar del JSON esperado, recibi√≥ un formato completamente diferente. </li><li>  <i>DecodingError.keyNotFound (CodingKey, DecodingError.Context)</i> : no se encontr√≥ el campo solicitado.  Significa que falta el campo que esperaba recibir </li><li>  <i>DecodingError.typeMismatch (Any.Type, DecodingError.Context)</i> : no coincide el tipo.  Cuando el tipo de datos en el modelo no coincide con el tipo del campo recibido </li><li>  <i>DecodingError.valueNotFound (Any.Type, DecodingError.Context)</i> : valor faltante para un campo espec√≠fico.  El campo que defini√≥ en el modelo de datos no se pudo inicializar, probablemente en los datos recibidos este campo es nulo.  Este error ocurre solo con campos no opcionales, si el campo no tiene que tener un valor, no olvide hacerlo opcional. </li></ul><br><br>  Al codificar datos, es posible un error: <br><br>  <i>EncodingError.invalidValue (Any.Type, DecodingError.Context)</i> : no se pudo convertir el modelo de datos a un formato espec√≠fico <br><br>  Un ejemplo de manejo de errores al analizar JSON: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() <span class="hljs-number"><span class="hljs-number">_</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode(businessReviewResponse.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(key,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(type,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(value,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error{ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) }</code> </pre> <br><br>  El procesamiento de errores es, por supuesto, mejor poner una funci√≥n separada, pero aqu√≠, para mayor claridad, el an√°lisis de errores se realiza junto con el an√°lisis.  Por ejemplo, la salida de error si no hay ning√∫n valor para el campo "producto" se ver√° as√≠: <br><br><img src="https://habrastorage.org/webt/vs/1k/ej/vs1kejm3b5lnxigx-aulilgvvqu.jpeg" alt="imagen"><br><br>  <b>Comparaci√≥n de codificables y NSCoding</b> <br><br>  Por supuesto, el protocolo codificable es un gran paso adelante en la codificaci√≥n / decodificaci√≥n de datos, pero el protocolo NSCoding exist√≠a antes.  Intentemos compararlos y ver qu√© beneficios tiene Codable: <br><br><ul><li>  Cuando se usa el protocolo <i>NSCoding</i> , el objeto debe ser una subclase de <i>NSObject</i> , lo que autom√°ticamente implica que nuestro modelo de datos debe ser una clase.  En <i>Codificable</i> , no hay necesidad de herencia, respectivamente, el modelo de datos puede ser tanto de <i>clase como de estructura y enumeraci√≥n</i> . </li><li>  Si necesita funciones de codificaci√≥n y decodificaci√≥n separadas, como, por ejemplo, en el caso de an√°lisis de datos JSON recibidos a trav√©s de la API, puede usar solo un protocolo <i>decodificable</i> .  Es decir, no hay necesidad de implementar los m√©todos de <i>codificaci√≥n</i> o <i>init a</i> veces innecesarios. </li><li>  Codable puede generar autom√°ticamente los m√©todos necesarios de <i>inicio</i> y <i>codificaci√≥n</i> , as√≠ como la enumeraci√≥n opcional de <i>CodingKeys</i> .  Esto, por supuesto, solo funciona si tiene campos simples en la estructura de datos, de lo contrario, se requerir√° personalizaci√≥n adicional.  En la mayor√≠a de los casos, especialmente para estructuras de datos b√°sicas, puede usar la generaci√≥n autom√°tica, especialmente si redefine <i>keyDecodingStrategy</i> , esto es conveniente y reduce algunos c√≥digos innecesarios. </li></ul><br><br>  Los <i>protocolos codificables, decodificables</i> y <i>codificables</i> nos permitieron dar un paso m√°s hacia la conveniencia de la conversi√≥n de datos, aparecieron nuevas herramientas de an√°lisis m√°s flexibles, se redujo la cantidad de c√≥digo y se automatiz√≥ parte de los procesos de conversi√≥n.  Los protocolos se implementan de forma nativa en Swift 4 y permiten reducir el uso de bibliotecas de terceros, como <i>SwiftyJSON</i> , mientras se mantiene la usabilidad.  Los protocolos tambi√©n permiten organizar adecuadamente la estructura del c√≥digo al separar los modelos de datos y los m√©todos para trabajar con ellos en m√≥dulos separados. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414221/">https://habr.com/ru/post/es414221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414211/index.html">Desarrollo de un servidor TELNET basado en W5500 y ATMEGA8</a></li>
<li><a href="../es414213/index.html">¬°Uno, dos, tres! Chatbot de Google Sheets usando el ejemplo de un juego PvP para Alice</a></li>
<li><a href="../es414215/index.html">Bloques personalizados en chips (Silicon IP): c√≥mo funciona</a></li>
<li><a href="../es414217/index.html">Smartphones locales Vertex: primero en calidad, primero en chips, primero en dise√±o</a></li>
<li><a href="../es414219/index.html">La experiencia del uso de la energ√≠a solar en la regi√≥n de Mosc√∫: a favor, en contra y qui√©n la necesita</a></li>
<li><a href="../es414223/index.html">C #: compatibilidad con versiones anteriores y sobrecarga</a></li>
<li><a href="../es414225/index.html">Crear su propia red de dispositivos caseros basados ‚Äã‚Äãen Arduino (Parte 1)</a></li>
<li><a href="../es414227/index.html">Un nuevo estudio de los indicadores de Telegram despu√©s del bloqueo: los suscriptores est√°n creciendo, la cobertura est√° cayendo</a></li>
<li><a href="../es414229/index.html">An√°lisis de varios m√©todos de capacitaci√≥n en TI.</a></li>
<li><a href="../es414231/index.html">C√≥mo hice una computadora completamente silenciosa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>