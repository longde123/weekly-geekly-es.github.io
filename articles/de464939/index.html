<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è üéä üîö Testen von @ NonNull / @ Nullable-Annotationen üë£ üë®üèæ‚Äçüîß üíî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anstelle von "Widmet sich ..." 
 Die unten beschriebene Aufgabe war nicht innovativ oder verdammt n√ºtzlich. Das Unternehmen, in dem ich arbeite, wird ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen von @ NonNull / @ Nullable-Annotationen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464939/"><h3>  Anstelle von "Widmet sich ..." </h3><br>  Die unten beschriebene Aufgabe war nicht innovativ oder verdammt n√ºtzlich. Das Unternehmen, in dem ich arbeite, wird keinen Gewinn daf√ºr erhalten, aber ich werde ein Bonus sein. <br><br>  Aber diese Aufgabe war, und deshalb musste sie gel√∂st werden. <br><br><h3>  Intro </h3><br>  In dem Artikel werden Sie oft das Wort Lombok treffen, ich bitte die Hasser, nicht zu Schlussfolgerungen zu eilen. <br>  Ich werde nicht f√ºr Lombok oder seine Abwesenheit "ertrinken", ich versuche, wie Geralt Sapkovsky, neutral zu sein, und ich kann Code mit oder ohne Lombok ruhig und ohne Zittern im Jahrhundert lesen. <br><br>  Aber beim aktuellen Projekt ist die erw√§hnte Bibliothek vorhanden, und etwas sagt mir, dass unser Projekt nicht das einzige ist. <br>  Also. <br><a name="habracut"></a><br>  Das letzte Mal in Java gibt es sicherlich einen Trend zu Annotashki.  Zum Ruhm des Fast-Fail-Konzepts werden die Parameter von Methoden h√§ufig mit der Annotation @NonNull kommentiert (sodass etwas schief geht, wenn etwas schief geht). <br><br>  Es gibt viele Importoptionen daf√ºr (oder Anmerkungen, die in der Ideologie √§hnlich sind), aber wie bereits klar geworden ist, werden wir uns auf die Version konzentrieren <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.NonNull;</code> </pre> <cut></cut><br>  Wenn Sie diese (oder eine √§hnliche) Anmerkung verwenden, haben Sie einen Vertrag, den Sie mit einem Test √ºberpr√ºfen m√ºssen, und jeder statische Code-Analysator wird Ihnen dies freundlicherweise mitteilen (Sonar sagt es Ihnen genau). <br><br>  Das Testen dieser Anmerkung mit einem Komponententest ist recht einfach. Das Problem besteht darin, dass sich solche Tests in Ihrem Projekt mit der Geschwindigkeit von Kaninchen im Fr√ºhjahr vermehren und Kaninchen, wie Sie wissen, gegen das DRY-Prinzip versto√üen. <br><br>  In dem Artikel werden wir ein kleines Test-Framework schreiben, um den Vertrag mit @ NonNull-Annotationen zu testen (und damit Sonar nicht mit einem b√∂sen roten Licht in Ihren Augen leuchtet). <br><br>  <b>PS</b> Der Name des Songs wurde von dem Song der PowerWolf-Band inspiriert, der (von Golly) gespielt wurde, als ich den Namen schrieb (im Original klingt der Name positiver). <br><br><h3>  Hauptteil </h3><br>  Zun√§chst haben wir die Anmerkung wie folgt getestet: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodNameWithNullArgumentThrowException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { instance.getAnyType(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); fail(<span class="hljs-string"><span class="hljs-string">"Exception not thrown"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> NullPointerException e) { assertNotNull(e); } }</code> </pre> <br>  Sie haben die Methode aufgerufen und null als Parameter √ºbergeben, der mit der Annotation @NonNull versehen ist. <br>  Sie bekamen NPE und waren zufrieden (Sonar war auch gl√ºcklich). <br><br>  Dann fingen sie an, dasselbe zu tun, aber mit einer modischeren Behauptung, die durch den Lieferanten funktioniert (wir lieben Lambdas): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TestUnitRepeatOnce</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodNameWithNullArgumentThrowException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertThrows(NullPointerException.class, () -&gt; instance.getAnyType(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)); }</code> </pre> <br>  Stilvoll.  Modisch.  Jugend <br><br>  Es scheint m√∂glich zu beenden, Anmerkungen werden getestet, also was mehr? <br><br>  Das Problem (nicht das Problem, aber immer noch) dieser Testmethode ist aufgetreten, als ich eines Tages einen Test f√ºr eine Methode schrieb. Es hat erfolgreich funktioniert, und dann habe ich festgestellt, dass der Parameter keine @ NonNull-Annotation enth√§lt. <br><br>  Es ist verst√§ndlich: Sie rufen die Testmethode auf, ohne das Verhalten der Moque-Klassen √ºber when () / then () zu beschreiben.  Der ausf√ºhrende Thread tritt sicher in die Methode ein, irgendwo darin f√§ngt er NPE auf einem entsperrten (oder gesperrten, aber ohne when () / then ()) Objekt ab und st√ºrzt jedoch mit NPE ab, wie Sie gewarnt haben, was bedeutet, dass der Test gr√ºn ist <br><br>  Es stellt sich heraus, dass wir in diesem Fall nicht die Anmerkung testen, aber es ist nicht klar, was.  Wenn der Test korrekt funktioniert, sollten wir nicht einmal tiefer in die Methode einsteigen m√ºssen (auf die Schwelle fallen). <cut></cut><br>  @NonNull-Annotationen von Lombok haben eine Funktion: Wenn wir von NPE zu Annotationen fallen, wird der Parametername in den Fehler geschrieben. <br><br>  Wir werden uns darauf einlassen, nachdem wir von NPE gefallen sind, werden wir zus√§tzlich den Text von Stacktrace wie folgt √ºberpr√ºfen: <br><br><pre> <code class="java hljs">exception.getCause().getMessage().equals(parameter.getName())</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Und wenn pl√∂tzlich ...</b> <div class="spoiler_text">  Falls Lombok pl√∂tzlich aktualisiert und aufh√∂rt, den Namen des Parameters zu schreiben, der im Stacktrace null erhalten hat, werden wir Andrei Pangins Vortrag √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JVM-TI</a> √ºberpr√ºfen und ein Plug-In f√ºr die JVM schreiben, in das wir den Parameternamen √ºbertragen. <br></div></div><br>  Alles scheint nichts zu sein, jetzt pr√ºfen wir wirklich, was ben√∂tigt wird, aber das Problem der ‚ÄûKaninchen‚Äú ist nicht gel√∂st. <br><br>  Ich h√§tte gerne ein Tool, das zum Beispiel so gesagt werden k√∂nnte: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TestUnitRepeatOnce</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonNullAnnotationTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertNonNullAnnotation(YourPerfectClass.class); }</code> </pre> <br>  und er selbst w√ºrde alle √∂ffentlichen Methoden der angegebenen Klasse scannen und alle ihre @ NoNull-Parameter mit einem Test √ºberpr√ºfen. <br><br>  Sie werden sagen, eine Reflexion erhalten und pr√ºfen, ob die Methode @NonNull aktiviert ist und ob ein Aufz√§hlungszeichen darin null ist. <br><br>  Alles w√§re nichts, aber RetentionPolicy ist nicht dasselbe. <br><br>  Alle Annotationen haben einen RetentionPolicy-Parameter, der drei Typen haben kann: SOURCE, CLASS und RUNTIME. Daher verf√ºgt Lombok standardm√§√üig √ºber RetentionPolicy.SOURCE. Dies bedeutet, dass diese Annotation in Runtime nicht sichtbar ist und Sie sie nicht durch Reflexion finden. <br><br>  In unserem Projekt werden alle Parameter √∂ffentlicher Methoden mit Anmerkungen versehen (ohne Grundelemente). Wenn verstanden wird, dass der Parameter nicht null sein kann, wenn das Gegenteil angenommen wird, wird der Parameter mit spring @Nullable mit Anmerkungen versehen.  Sie k√∂nnen sich daran beteiligen, wir werden nach allen √∂ffentlichen Methoden und allen darin enthaltenen Parametern suchen, die nicht mit @Nullable markiert sind und keine Grundelemente sind. <br>  Wir meinen, dass in allen anderen F√§llen die Annotation @NonNull auf den Parametern stehen sollte. <br><br>  Der Einfachheit halber werden wir, wann immer m√∂glich, die Logik durch private Methoden verbreiten. Zun√§chst werden wir alle √∂ffentlichen Methoden erhalten: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;Method&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPublicMethods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(clazz.getDeclaredMethods()) .filter(METHOD_FILTER) .collect(toList()); }</code> </pre> <br>  Dabei ist METHOD_FILTER ein regul√§res Pr√§dikat, in dem wir Folgendes sagen: <br><br><ul><li>  Die Methode muss √∂ffentlich sein </li><li>  Es sollte nicht syntetisch sein (und dies passiert, wenn Sie eine Methode mit einem Rohparameter haben) </li><li>  Es sollte nicht abstrakt sein (√ºber abstrakte Klassen separat und unten) </li><li>  Der Methodenname sollte nicht gleich sein (falls eine b√∂se Person beschlie√üt, eine Klasse mit √ºberschriebenen gleich () auf der Eingabe unseres POJO-Frameworks zu f√ºllen). </li></ul><br>  Nachdem wir alle ben√∂tigten Methoden erhalten haben, sortieren wir sie in einer Schleife aus. <br>  Wenn die Methode √ºberhaupt keine Parameter hat, ist dies nicht unser Kandidat: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getParameterCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Wenn es Parameter gibt, m√ºssen wir verstehen, ob sie mit @NonNull kommentiert sind (genauer gesagt, sollten sie laut sein <br><br><div class="spoiler">  <b class="spoiler_title">Logik</b> <div class="spoiler_text"><ul><li>  √∂ffentliche Methode </li><li>  nicht @Nullable </li><li>  nicht primitiv </li></ul><br></div></div><br>  Erstellen Sie dazu eine Karte und f√ºgen Sie unsere Parameter entsprechend der Reihenfolge in der Methode ein. Gegen√ºber setzen wir ein Flag, das angibt, ob die Annotation @NonNull √ºber oder nicht liegen soll: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nonNullAnnotationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; val parameterCurrentMethodArray = method.getParameters(); val notNullAnnotationParameterMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer, Boolean&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val parameter : parameterCurrentMethodArray) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); nonNullAnnotationCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Diese Zuordnung ist n√ºtzlich, um dann die Methode aufzurufen und sie mit der Annotation @NonNull an alle Parameter zu √ºbergeben, und nicht nur an die erste. <br><br>  Der Parameter nonNullAnnotationCount z√§hlt, wie viele Parameter in der Methode mit @NonNull kommentiert werden sollen. Er bestimmt die Anzahl der Aufrufintegrationsinteraktionen f√ºr jede Methode. <br><br>  √úbrigens, wenn es keine @ NoNull-Annotationen gibt (es gibt Parameter, aber alle sind primitiv oder @ Nullable), gibt es nichts zu besprechen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Wir haben eine Karte mit Parametern zur Hand.  Wir wissen, wie oft eine Methode aufgerufen werden muss und an welchen Positionen Null gesetzt werden soll. Die Angelegenheit ist klein (wie ich naiv ohne Verst√§ndnis dachte). Wir m√ºssen eine Instanz der Klasse erstellen und Methoden aufrufen. <br><br>  Probleme beginnen, wenn Sie erkennen, wie unterschiedlich eine Instanz ist: Es kann eine private Klasse sein, es kann eine Klasse mit einem Standardkonstruktor sein, mit einem Konstruktor mit Parametern, mit einem solchen und einem solchen Konstruktor, einer abstrakten Klasse, einer Schnittstelle (mit ihren Standardmethoden, die auch √∂ffentlich sind und die auch getestet werden m√ºssen). <br><br>  Und wenn wir die Instanz per Hook oder Crook erstellt haben, m√ºssen wir die Parameter an die Aufrufmethode √ºbergeben und auch hier erweitern: Wie erstelle ich eine Instanz der letzten Klasse?  und Enum?  und primitiv?  und ein Array von Grundelementen (das auch ein Objekt ist und auch mit Anmerkungen versehen werden kann). <br><br>  Nun, lass es uns in der richtigen Reihenfolge tun. <br><br>  Der erste Fall ist eine Klasse mit einem privaten Konstruktor: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(clazz, invokeMethodParameterArray); makeErrorMessage(method); }</code> </pre> <br>  Dann rufen wir einfach unsere Aufrufmethode auf, √ºbergeben den von au√üen kommenden Clazz an den Test und ein Array von Parametern, in denen null bereits an die erste Position mit dem Flag f√ºr die Annotation @NonNull geladen wird (denken Sie daran, oben haben wir die Map @ NonNulls erstellt), die wir beginnen F√ºhren Sie eine Schleife aus und erstellen Sie ein Array von Parametern. √Ñndern Sie abwechselnd die Position des Nullparameters und setzen Sie das Flag auf Null, bevor Sie die Methode aufrufen, sodass der andere Parameter bei der n√§chsten Integration null wird. <br><br>  Im Code sieht es so aus: <br><br><pre> <code class="java hljs">val invokeMethodParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[parameterCurrentMethodArray.length]; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentNullableIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invokeMethodParameterArray.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) { currentNullableIndex = i; invokeMethodParameterArray[i] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i); } }</code> </pre> <br>  Die erste Option der Instanziierung wurde aussortiert. <br><br>  Bei weiteren Schnittstellen ist es unm√∂glich, eine Instanz einer Schnittstelle zu erstellen (es gibt nicht einmal einen Konstruktor). <br><br>  Daher wird es mit der Schnittstelle folgenderma√üen aussehen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (INTERFACE_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray); makeErrorMessage(method); }</code> </pre> <br>  Mit createInstanceByDynamicProxy k√∂nnen wir eine Instanz f√ºr eine Klasse erstellen, wenn sie mindestens eine Schnittstelle implementiert oder selbst eine Schnittstelle ist <br><br><div class="spoiler">  <b class="spoiler_title">Nuance</b> <div class="spoiler_text">  Beachten Sie, dass es hier grunds√§tzlich darum geht, welche Schnittstellen die Klasse implementiert. Die Typschnittstelle ist wichtig (und nicht vergleichbar). Es gibt Methoden, die Sie in der Zielklasse implementieren. Andernfalls wird Sie die Instanz mit ihrem Typ √ºberraschen <br></div></div><br>  aber drinnen ist es so: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByDynamicProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newProxyInstance( currentThread().getContextClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, (proxy, method1, args) -&gt; { Constructor&lt;Lookup&gt; constructor = Lookup.class .getDeclaredConstructor(Class.class); constructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); constructor.newInstance(clazz) .in(clazz) .unreflectSpecial(method1, clazz) .bindTo(proxy) .invokeWithArguments(invokeMethodParameterArray); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Rechen</b> <div class="spoiler_text">  √úbrigens gab es hier auch einige Rechen, ich wei√ü nicht mehr, welche, es gab viele, aber Sie m√ºssen einen Proxy √ºber Lookup.class erstellen <br></div></div><br>  Die n√§chste Instanz (mein Favorit) ist eine abstrakte Klasse.  Und hier hilft uns der dynamische Proxy nicht mehr, denn wenn eine abstrakte Klasse eine Art Schnittstelle implementiert, ist dies eindeutig nicht der Typ, den wir m√∂chten.  Und einfach so k√∂nnen wir newInstance () nicht aus einer abstrakten Klasse nehmen und erstellen.  Hier hilft uns CGLIB, eine Spring Lib, die Proxys basierend auf Vererbung erstellt. Das Problem ist jedoch, dass die Zielklasse einen Standardkonstruktor (ohne Parameter) haben muss <br><br><div class="spoiler">  <b class="spoiler_title">Klatsch</b> <div class="spoiler_text">  Obwohl CGLIB seit dem 4. Fr√ºhjahr nach Klatsch im Internet urteilt, kann es ohne CGLIB funktionieren, und so: <b>Also funktioniert es nicht!</b> <br></div></div>  Die Option zum Instanziieren einer abstrakten Klasse w√§re folgende: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAbstract(clazz.getModifiers())) { createInstanceByCGLIB(clazz, method, invokeMethodParameterArray); makeErrorMessage(); }</code> </pre> <br>  makeErrorMessage (), das bereits in den Codebeispielen zu sehen war, l√∂scht den Test. Wenn wir die Methode mit dem mit Anmerkungen versehenen @ NonNull-Parameter aufgerufen haben, der null √ºbergeben hat und nicht gefallen ist, hat der Test nicht funktioniert. Sie m√ºssen ihn l√∂schen. <br><br>  F√ºr die Parameterzuordnung haben wir eine gemeinsame Methode, mit der sowohl Konstruktor- als auch Methodenparameter zugeordnet und gesperrt werden k√∂nnen. Sie sieht folgenderma√üen aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstantiationException, IllegalAccessException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinal(parameter.getType().getModifiers())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isEnum()) { methodParam[index] = Enum.valueOf( (Class&lt;Enum&gt;) (parameter.getType()), parameter.getType().getEnumConstants()[<span class="hljs-number"><span class="hljs-number">0</span></span>].toString() ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isPrimitive()) { mappingPrimitiveName(parameter, methodParam, index); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().getTypeName().equals(<span class="hljs-string"><span class="hljs-string">"byte[]"</span></span>)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = parameter.getType().newInstance(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = mock(parameter.getType()); } }</code> </pre> <br>  Achten Sie auf die Erstellung von Enum (Kirsche auf dem Kuchen). Im Allgemeinen k√∂nnen Sie Enum nicht einfach nehmen und erstellen. <br><br>  Hier f√ºr die endg√ºltigen Parameter Ihre eigene Zuordnung, f√ºr nicht endg√ºltige Ihre eigene und dann einfach im Text (Code). <br><br>  Nachdem wir die Parameter f√ºr den Konstruktor und f√ºr die Methode erstellt haben, bilden wir unsere Instanz: <br><br><pre> <code class="java hljs">val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParameterArray.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i); } notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray); makeErrorMessage(method);</code> </pre> <cut></cut><br>  Wir wissen bereits mit Sicherheit, dass wir, da wir diese Phase des Codes erreicht haben, mindestens einen Konstruktor haben. Wir k√∂nnen jeden zum Erstellen einer Instanz verwenden. Nehmen wir also den ersten, den wir sehen, pr√ºfen Sie, ob er Parameter im Konstruktor enth√§lt, und rufen Sie ihn auf, wenn nicht so: <br><br><pre> <code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray);</code> </pre> <br><br>  Nun, wenn es so etwas gibt: <br><pre> <code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray);</code> </pre> <cut></cut><br>  Dies ist die Logik, die in der Methode createAndInvoke () auftritt, die Sie etwas h√∂her gesehen haben. <br>  Die Vollversion der Testklasse unter dem Spoiler habe ich nicht auf git hochgeladen, wie ich in einem Arbeitsprojekt geschrieben habe, aber tats√§chlich ist es nur eine Klasse, die in Ihren Tests vererbt und verwendet werden kann. <br><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Method&gt; METHOD_FILTER = method -&gt; isPublic(method.getModifiers()) &amp;&amp; isFalse(method.isSynthetic()) &amp;&amp; isFalse(isAbstract(method.getModifiers())) &amp;&amp; isFalse(method.getName().equals(<span class="hljs-string"><span class="hljs-string">"equals"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Class&gt; ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER = clazz -&gt; clazz.getConstructors().length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; isFalse(clazz.isInterface()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Class&gt; INTERFACE_FILTER = clazz -&gt; clazz.getConstructors().length == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiPredicate&lt;Exception, Parameter&gt; LOMBOK_ERROR_FILTER = (exception, parameter) -&gt; isNull(exception.getCause().getMessage()) || isFalse(exception.getCause().getMessage().equals(parameter.getName())); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertNonNullAnnotation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val method : getPublicMethods(clazz)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getParameterCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nonNullAnnotationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; val parameterCurrentMethodArray = method.getParameters(); val notNullAnnotationParameterMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer, Boolean&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val parameter : parameterCurrentMethodArray) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); nonNullAnnotationCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; nonNullAnnotationCount; j++) { val invokeMethodParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[parameterCurrentMethodArray.length]; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentNullableIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invokeMethodParameterArray.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) { currentNullableIndex = i; invokeMethodParameterArray[i] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(clazz, invokeMethodParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (INTERFACE_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAbstract(clazz.getModifiers())) { createInstanceByCGLIB(clazz, method, invokeMethodParameterArray); makeErrorMessage(); } val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParameterArray.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i); } notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LOMBOK_ERROR_FILTER.test(e, parameterCurrentMethodArray[currentNullableIndex])) { makeErrorMessage(method); } } } } } <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndInvoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Constructor firstFindConstructor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] constructorParameterArray )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (firstFindConstructor.getParameters().length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance(constructorParameterArray)), invokeMethodParameterArray); } } <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByCGLIB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ MethodInterceptor handler = (obj, method1, args, proxy) -&gt; proxy.invoke(clazz, args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clazz.getConstructors().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParam.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParam, i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val constructor : clazz.getConstructors()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constructor.getParameters().length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { val proxy = Enhancer.create(clazz, handler); method.invoke(proxy.getClass().newInstance(), invokeMethodParameterArray); } } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByDynamicProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newProxyInstance( currentThread().getContextClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, (proxy, method1, args) -&gt; { Constructor&lt;Lookup&gt; constructor = Lookup.class .getDeclaredConstructor(Class.class); constructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); constructor.newInstance(clazz) .in(clazz) .unreflectSpecial(method1, clazz) .bindTo(proxy) .invokeWithArguments(invokeMethodParameterArray); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeErrorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fail(<span class="hljs-string"><span class="hljs-string">"  @NonNull     DefaultConstructor  "</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeErrorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method)</span></span></span><span class="hljs-function"> </span></span>{ fail(<span class="hljs-string"><span class="hljs-string">"    "</span></span> + method.getName() + <span class="hljs-string"><span class="hljs-string">"   @NonNull"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;Method&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPublicMethods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(clazz.getDeclaredMethods()) .filter(METHOD_FILTER) .collect(toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstantiationException, IllegalAccessException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinal(parameter.getType().getModifiers())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isEnum()) { methodParam[index] = Enum.valueOf( (Class&lt;Enum&gt;) (parameter.getType()), parameter.getType().getEnumConstants()[<span class="hljs-number"><span class="hljs-number">0</span></span>].toString() ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isPrimitive()) { mappingPrimitiveName(parameter, methodParam, index); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().getTypeName().equals(<span class="hljs-string"><span class="hljs-string">"byte[]"</span></span>)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = parameter.getType().newInstance(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = mock(parameter.getType()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingPrimitiveName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ val name = parameter.getType().getName(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"long"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"int"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"byte"</span></span>.equals(name)) { methodParam[index] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"short"</span></span>.equals(name)) { methodParam[index] = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"double"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>d; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"float"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"boolean"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"char"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-string"><span class="hljs-string">'A'</span></span>; } } }</code> </pre> <br></div></div><br><h3>  Fazit </h3><br>  Dieser Code funktioniert und testet Anmerkungen in einem realen Projekt. Derzeit ist nur eine Option m√∂glich, bei der alles Gesagte reduziert werden kann. <br><br>  Deklarieren Sie einen Lombock-Setter in der Klasse (wenn es einen Spezialisten gibt, der den Setter nicht in der Pojo-Klasse setzt, obwohl dies einfach nicht der Fall ist) und das Feld, auf dem der Setter deklariert wird, ist nicht endg√ºltig. <br><br>  Dann wird das Framework freundlicherweise sagen, dass es eine √∂ffentliche Methode gibt und es einen Parameter gibt, f√ºr den es keine @ NonNull-Annotation gibt. Die L√∂sung ist einfach: Deklarieren Sie den Setter explizit und kommentieren Sie seinen Parameter basierend auf dem Kontext der Logik @ NonNull / @ Nullable. <br><br>  Beachten Sie, dass Sie arg [0] und arg [1] usw. finden, wenn Sie m√∂chten, dass ich in Ihren Tests an den Namen des Methodenparameters in Ihren Tests gebunden bin (oder an etwas anderes). In Runtime sind die Namen von Variablen in Methoden standardm√§√üig nicht verf√ºgbar. . <br>  Verwenden Sie das Maven-Plugin, um die Anzeige von Methodennamen in Runtime zu aktivieren: <br><br><pre> <code class="java hljs">&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;${maven.compiler.plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;${compile.target.source}&lt;/source/&gt; &lt;target&gt;${compile.target.source}&lt;/target&gt; &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt; &lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt;</code> </pre><br>  und insbesondere diesen Schl√ºssel: <br><br><pre> <code class="java hljs">&lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt;</code> </pre> <br>  Ich hoffe du warst interessiert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464939/">https://habr.com/ru/post/de464939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464929/index.html">Faules Laden von Browserbildern (Ladeattribut)</a></li>
<li><a href="../de464931/index.html">Assembler-Einf√ºgungen ... in C #?</a></li>
<li><a href="../de464933/index.html">Anwendungen f√ºr E-Books auf dem Android-Betriebssystem. Teil 4. Spiele</a></li>
<li><a href="../de464935/index.html">Komfortable DevOpsSec: Nemesida WAF Kostenlos f√ºr NGINX mit API und pers√∂nlichem Konto</a></li>
<li><a href="../de464937/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 312 (vom 19. bis 25. August)</a></li>
<li><a href="../de464947/index.html">Digitale Veranstaltungen in Moskau vom 25. August bis 1. September</a></li>
<li><a href="../de464949/index.html">Noch einmal √ºber GCD, den euklidischen Algorithmus und ein wenig √ºber die Geschichte der Algorithmen im Allgemeinen. Nat√ºrlich mit Swift-Beispielen</a></li>
<li><a href="../de464951/index.html">Je einfacher die Aufgabe, desto √∂fter irre ich mich</a></li>
<li><a href="../de464955/index.html">Iron Mike Tyson und das Blockchain-Projekt Fight to Fame</a></li>
<li><a href="../de464959/index.html">Analyse des Satzes der russischen Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>