<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌬️ 🤛 📝 Wie wir Server-Rendering gesehen haben und was daraus wurde 🛩️ 👨🏻‍🏭 🌼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Im Laufe des Jahres haben wir zu React gewechselt und darüber nachgedacht, wie wir sicherstellen können, dass unsere Benutzer nicht ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir Server-Rendering gesehen haben und was daraus wurde</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/445816/"><p>  Hallo allerseits!  Im Laufe des Jahres haben wir zu React gewechselt und darüber nachgedacht, wie wir sicherstellen können, dass unsere Benutzer nicht auf die Client-Vorlage warten, sondern die Seite so schnell wie möglich sehen.  Zu diesem Zweck haben wir uns für das serverseitige Rendern (SSR - Server Side Rendering) und die Optimierung der Suchmaschinenoptimierung entschieden, da nicht alle Suchmaschinen JS ausführen können und diejenigen, die Zeit für die Ausführung aufwenden können, und die Crawling-Zeit jeder Site begrenzt ist. </p><br><p><img src="https://habrastorage.org/webt/ok/dw/-_/okdw-_ptimir1qc1vqmd9fcypyk.png"></p><a name="habracut"></a><br><p> Ich möchte Sie daran erinnern, dass beim Server-Rendering JavaScript-Code auf der Serverseite ausgeführt wird, um dem Client HTML-fähig zu machen.  Dies wirkt sich auf die vom Benutzer wahrgenommene Leistung aus, insbesondere auf langsameren Computern und im langsamen Internet.  Sie müssen nicht warten, bis JS heruntergeladen, analysiert und ausgeführt wurde.  Der Browser kann HTML nur sofort rendern, ohne auf JSa zu warten, der Benutzer kann den Inhalt bereits lesen. <br>  Dadurch wird die passive Wartephase reduziert.  Nach dem Rendern muss der Browser nur das fertige DOM durchlaufen und überprüfen, ob es mit dem gerenderten übereinstimmt <br>  auf dem Client und fügen Sie Ereignis-Listener hinzu.  Dieser Vorgang wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hydratation bezeichnet</a> .  Wenn während des Hydratationsprozesses eine Diskrepanz zwischen dem Inhalt des Servers und dem vom Browser generierten Inhalt besteht, erhalten wir eine Warnung in der Konsole und einen zusätzlichen Renderer auf dem Client.  Dies sollte nicht der Fall sein. Es muss sichergestellt werden, dass die Ergebnisse des Server- und Client-Renderings übereinstimmen.  Wenn sie voneinander abweichen, sollte dies als Fehler behandelt werden, da dies die Vorteile des Server-Renderings zunichte macht.  Wenn ein Element abweichen sollte, fügen Sie <code>suppressHydrationWarning={true}</code> . </p><br><p>  Darüber hinaus gibt es eine Einschränkung: Es gibt kein <code>window</code> auf dem Server.  Der Code, der darauf zugreift, muss in Lebenszyklusmethoden ausgeführt werden, die nicht auf der Serverseite aufgerufen werden.  Das heißt, Sie können das <code>window</code> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UNSAFE_componentWillMount ()</a> oder im Fall von Hooks in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uselayouteffect verwenden</a> . </p><br><p>  Im Wesentlichen läuft der serverseitige Renderprozess darauf hinaus, den initialState aus dem Backend abzurufen, ihn über <code>renderToString()</code> , den fertigen initialState und HTML an der Ausgabe abzurufen und an den Client zu senden. </p><br><p>  In hh.ru sind Wanderungen vom Client JS nur im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Gateway</a> in Python zulässig.  Dies dient der Sicherheit und dem Lastausgleich.  Python geht bereits zu den erforderlichen Backends für Daten, bereitet sie vor und gibt sie an den Browser weiter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js wird</a> nur zum Rendern von Servern verwendet.  Dementsprechend benötigt der Python nach dem Vorbereiten der Daten eine zusätzliche Fahrt zum Knoten, wartet auf das Ergebnis und sendet die Antwort an den Client. </p><br><p>  Zuerst mussten Sie einen Server auswählen, um mit HTTP zu arbeiten.  Wir hielten bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koa an</a> .  Gefiel die moderne Syntax mit <code>await</code> .  Modularität ist eine leichte Middleware, die bei Bedarf separat installiert oder einfach unabhängig geschrieben werden kann.  Der Server selbst ist leicht und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schnell</a> .  Ja, und von Koa von demselben Entwicklungsteam geschrieben, das sie Express schreiben, ist ihre Erfahrung faszinierend. </p><br><p>  Nachdem wir gelernt hatten, wie wir unseren Service einführen können, haben wir den einfachsten Code auf KOA geschrieben, der 200 geben konnte, und ihn auf das Produkt hochgeladen.  Es sah so aus: </p><br><pre> <code class="plaintext hljs">const Koa = require('koa'); const app = new Koa(); const SERVER_PORT = 9400; app.use(async (ctx) =&gt; { ctx.body = 'Hello World'; }); app.listen(SERVER_PORT);</code> </pre> <br><p>  In hh.ru befinden sich alle Dienste in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> Containern.  Vor der ersten Veröffentlichung müssen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ansible</a> Playbooks schreiben, mit deren Hilfe der Service in Produktionsumgebungen und auf Prüfständen eingeführt wird.  Jeder Entwickler und Tester hat seine eigene Testumgebung, die dem Produkt am ähnlichsten ist.  Wir haben die meiste Zeit und Energie damit verbracht, Spielbücher zu schreiben.  Dies geschah, weil zwei Front-End-Renderer dies taten und dies der erste Dienst auf einem Knoten in hh.ru ist.  Wir mussten herausfinden, wie der Dienst in den Entwicklungsmodus geschaltet werden kann, und zwar parallel zu dem Dienst, für den das Rendern stattfindet.  Liefern Sie Dateien in einen Container.  Starten Sie einen nackten Server, damit der Docker-Container gestartet wird, ohne auf den Build zu warten.  Erstellen und erstellen Sie den Server zusammen mit dem Dienst, der ihn verwendet, neu.  Bestimmen Sie, wie viel RAM wir benötigen. </p><br><p>  Im Entwicklungsmodus wurde die Möglichkeit einer automatischen Neuerstellung und eines anschließenden Neustarts des Dienstes beim Ändern der im endgültigen Build enthaltenen Dateien bereitgestellt.  Der Knoten muss neu gestartet werden, um ausführbaren Code zu laden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webpack</a> überwacht Änderungen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Builds</a> .  Webpack wird benötigt, um ESM in Common CommonJS zu konvertieren.  Für den Neustart nahmen sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nodemon</a> , das sich um die gesammelten Dateien kümmert. </p><br><p>  Dann haben wir den Routing-Server gelernt.  Für einen ordnungsgemäßen Ausgleich müssen Sie wissen, welche Serverinstanzen aktiv sind.  Um dies zu überprüfen, wechselt der betriebsbereite Herzschlag alle paar Sekunden in den <code>/status</code> und erwartet als Antwort 200.  Wenn der Server nicht mehr als die in der Konfiguration angegebene Anzahl von Malen antwortet, wird er aus dem Ausgleich entfernt.  Dies stellte sich als einfache Aufgabe heraus, ein paar Zeilen und ein fertiges Routing: </p><br><pre> <code class="plaintext hljs">export default async function(ctx, next) { if (routeMap[ctx.request.path]) { routeMap[ctx.request.path](ctx); } else { ctx.throw(NOT_FOUND, getStatusText(NOT_FOUND)); } next(); }</code> </pre> <br><p>  Und wir antworten 200 mit der richtigen URL: </p><br><pre> <code class="plaintext hljs">export default (ctx) =&gt; { ctx.status = 200; ctx.body = '200'; };</code> </pre> <br><p>  Danach haben wir einen primitiven Server erstellt, der den Status in <code>&lt;script&gt;</code> und bereitem HTML zurückgibt. </p><br><p>  Es musste gesteuert werden, wie der Server funktioniert.  Dazu müssen Sie die Protokollierung und Überwachung beschleunigen.  Protokolle werden nicht in JSON geschrieben, sondern um das Protokollformat unserer anderen Dienste, hauptsächlich Java, zu unterstützen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Log4js</a> wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach Benchmarks ausgewählt</a> - es ist schnell, einfach zu konfigurieren und schreibt in dem von uns benötigten Format.  Zur Vereinfachung der Überwachungsunterstützung ist ein gemeinsames Protokollformat erforderlich. Sie müssen keine zusätzlichen Stammdaten schreiben, um Protokolle zu analysieren.  Zusätzlich zu den Protokollen schreiben wir immer noch Fehler in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wachposten</a> .  Ich werde den Code der Logger nicht angeben, es ist sehr einfach, im Grunde gibt es Einstellungen. </p><br><p>  Dann musste für ein ordnungsgemäßes Herunterfahren gesorgt werden. Wenn der Server krank wird oder wenn die Freigabe erfolgt, akzeptiert der Server keine eingehenden Verbindungen mehr, sondern führt alle daran hängenden Anforderungen aus.  Es gibt viele vorgefertigte Lösungen für einen Knoten.  Sie nahmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/sebhildebrandt/">http-graceful-shutdown</a> , alles was getan werden musste, war den <code>gracefulShutdown(app.listen(SERVER_PORT))</code> Aufruf <code>gracefulShutdown(app.listen(SERVER_PORT))</code> </p><br><p>  Zu diesem Zeitpunkt haben wir eine produktionsreife Lösung erhalten.  Um zu überprüfen, wie es funktioniert, haben sie das Server-Rendering für 5% der Benutzer auf einer Seite aktiviert.  Wir haben uns die Metriken angesehen und festgestellt, dass sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FMP</a> für Mobiltelefone erheblich verbessert haben. Bei Desktops hat sich der Wert nicht geändert.  Sie begannen, die Leistung zu testen, und stellten fest, dass ein Server ~ 20 RPS enthält (diese Tatsache war für die Javisten sehr amüsant).  Finden Sie die Gründe heraus, warum dies so ist: </p><br><ul><li><p>  Eines der Hauptprobleme stellte sich heraus, dass sie ohne NODE_ENV = Produktion erstellt wurden (wir haben die ENV festgelegt, die wir für die Servererstellung benötigen).  In diesem Fall ergibt die Reaktion die Nichtproduktionsanordnung, die etwa 30% langsamer läuft. </p><br></li><li><p>  Wir haben die Version des Knotens von 8 auf 10 erhöht und weitere 20-25% der Leistung erzielt. </p><br></li><li><p>  Was wir zum letzten Mal verlassen haben, ist das Starten eines Knotens auf mehreren Kerneln.  Wir vermuteten, dass es sehr schwierig war, aber auch hier erwies sich alles als sehr prosaisch.  Der Knoten verfügt über einen integrierten Mechanismus - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cluster</a> .  Sie können die erforderliche Anzahl unabhängiger Prozesse ausführen, einschließlich eines Masterprozesses, der Aufgaben für sie streut. </p><br></li></ul><br><pre> <code class="plaintext hljs">if (cluster.isMaster) { cluster.on('exit', (worker, exitCode) =&gt; { if (exitCode !== SUCCESS) { cluster.fork(); } }); for (let i = 0; i &lt; serverConfig.cpuCores; i++) { cluster.fork(); } } else { runApp(); }</code> </pre> <br><p>  In diesem Code startet der Master-Prozess, die Prozesse starten entsprechend der Anzahl der für den Server zugewiesenen CPUs.  Wenn einer der untergeordneten Prozesse abstürzt - der Exit-Code ist nicht <code>0</code> (wir haben den Server selbst ausgeschaltet), wird er vom Master-Prozess neu gestartet. <br>  Die Leistung erhöht sich um etwa die Anzahl der für den Server zugewiesenen CPUs. </p><br><p>  Wie ich oben schrieb, verbrachte ich die meiste Zeit damit, die ursprünglichen Spielbücher zu schreiben - ungefähr 3 Wochen.  Es dauerte ungefähr 2 Wochen, um die gesamte SSR zu schreiben, und ungefähr einen Monat lang erinnerten wir uns langsam daran.  All dies wurde durch Kräfte von 2 Fronten ohne Unternehmenserfahrung von Knoten js getan.  Haben Sie vor allem keine Angst vor SSR - vergessen Sie nicht, <code>NODE_ENV=production</code> anzugeben, es ist nichts Kompliziertes daran.  Benutzer und SEO werden es Ihnen danken. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445816/">https://habr.com/ru/post/de445816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445802/index.html">5 Dinge, über die Internet-Trends jeder wissen sollte</a></li>
<li><a href="../de445804/index.html">Kapselung für echte Samurai oder die Nuancen, die mit dem internen Schlüsselwort in C # verbunden sind</a></li>
<li><a href="../de445806/index.html">Wie künstliche Intelligenz die Wissenschaft verändert</a></li>
<li><a href="../de445808/index.html">Wir hassen und jagen: das gefährliche Leben eines Virus-Crackers, der sich mächtige Feinde macht</a></li>
<li><a href="../de445814/index.html">Wie ein Lieferroboter die kulinarischen Gewohnheiten amerikanischer Studenten verändert hat</a></li>
<li><a href="../de445820/index.html">MVCC-3. Zeilenversionen</a></li>
<li><a href="../de445822/index.html">Warum Jaop? Warum Schläger?</a></li>
<li><a href="../de445824/index.html">Codegenerierung in Dart. Teil 1. Grundlagen</a></li>
<li><a href="../de445826/index.html">Wir gehen mit Bedacht durch die Stadt - 2: Gehen wir mit dem genetischen Algorithmus im Kreis durch die Stadt</a></li>
<li><a href="../de445828/index.html">Chinesisches Sonnenspektrum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>