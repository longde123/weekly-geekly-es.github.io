<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèø üêù üéÆ Aprendizaje autom√°tico con Node.js utilizando la biblioteca Tensorflow.js ü•â üòº üë®üèº‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos, colegas! 

 Quiz√°s los fan√°ticos de la biblioteca Tensorflow, que ya notaron este libro en nuestro pedido anticipado, tambi√©n observaron...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendizaje autom√°tico con Node.js utilizando la biblioteca Tensorflow.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432984/">  Hola a todos, colegas! <br><br>  Quiz√°s los fan√°ticos de la biblioteca Tensorflow, que ya notaron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este libro</a> en nuestro pedido anticipado, tambi√©n observaron de cerca las posibilidades de aprendizaje autom√°tico y profundo en el navegador, especialmente porque el propio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Francois Schollet</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no ignor√≥ el</a> tema.  Invitamos a los interesados ‚Äã‚Äãen el gato, que explica c√≥mo se reconocen las im√°genes utilizando la biblioteca Tensorflow.js. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TensorFlow.js</a> es una nueva versi√≥n de la popular biblioteca de c√≥digo abierto que enriquece JavaScript con capacidades de aprendizaje profundo.  Los desarrolladores ahora pueden definir, entrenar y ejecutar modelos utilizando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de biblioteca de alto nivel</a> . <br><br>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los modelos previamente entrenados, los</a> desarrolladores ahora pueden resolver f√°cilmente tareas complejas como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reconocimiento de patrones</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la generaci√≥n de m√∫sica</a> o la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">determinaci√≥n de posiciones humanas en</a> solo unas pocas l√≠neas de JavaScript. <br><br>  Tensorflow.js comenz√≥ como una biblioteca front-end para trabajar en un navegador, pero este a√±o se agreg√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte experimental para</a> Node.js.  Por lo tanto, TensorFlow.js tambi√©n se puede utilizar en aplicaciones de back-end de JavaScript, lo que nos evita por completo tener que recurrir a Python. <br><br>  <i>Al leer sobre esta biblioteca, decid√≠ probarla en una tarea simple ...</i> <br><blockquote>  Use TensorFlow.js para el reconocimiento visual de im√°genes en im√°genes cuando use JavaScript de Node.js </blockquote>  Desafortunadamente, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplos de c√≥digo</a> describen principalmente el uso de esta biblioteca en el navegador.  Tuve que pasar mucho tiempo para leer bien las fuentes de Script para esta biblioteca. <br><br>  Sin embargo, despu√©s de unos d√≠as de swotting, ¬°todav√≠a lo hice!  ¬°Hurra! <br><br>  <i>Antes de pasar a un an√°lisis detallado del c√≥digo, hablemos de otras implementaciones de la biblioteca TensorFlow.</i> <br><br>  <b>Tensorflow</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TensorFlow</a> es una biblioteca de software gratuita para aplicaciones de aprendizaje autom√°tico.  TensorFlow se puede usar para crear redes neuronales e implementar otros algoritmos de aprendizaje profundo. <br><br>  Esta es una biblioteca lanzada por Google en noviembre de 2015, originalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrita en Python</a> .  Para la capacitaci√≥n y evaluaci√≥n de modelos creados, utiliza c√°lculos en una CPU o GPU.  Inicialmente, esta biblioteca fue creada para trabajar en servidores de alto rendimiento utilizando GPU de uso intensivo de recursos. <br><br>  Las actualizaciones recientes han permitido optimizar esta biblioteca y usarla en entornos con recursos m√°s limitados, por ejemplo, en dispositivos m√≥viles y navegadores web. <br><br>  <b>TensorFlow Lite</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tensorflow Lite</a> , la versi√≥n lite de esta biblioteca para dispositivos m√≥viles y sistemas integrados, se lanz√≥ en mayo de 2017.  Junto con √©l, se proporciona un nuevo conjunto de modelos profundos previamente entrenados para tareas relacionadas con el reconocimiento de patrones;  Esta colecci√≥n se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MobileNet</a> .  Los modelos MobileNet se han dise√±ado espec√≠ficamente para un funcionamiento eficiente en entornos con una cantidad limitada de recursos, como dispositivos m√≥viles. <br><br>  TensorFlow.js <br><br>  Despu√©s de Tensorflow Lite, TensorFlow.js se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anunci√≥</a> en marzo de 2018.  Esta versi√≥n de la biblioteca est√° dise√±ada para funcionar en un navegador y se basa en un proyecto anterior llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deeplearn.js</a> .  WebGL proporciona acceso de GPU a la biblioteca.  Los desarrolladores usan la API de JavaScript para entrenar, cargar y ejecutar modelos. <br><br>  M√°s tarde, TensorFlow.js se expandi√≥ para trabajar con Node.js, para esto se utiliza el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento de biblioteca</a> <code>tfjs-node</code> . <br><br>  <b>Importe modelos existentes en TensorFlow.js</b> <br><br>  Los modelos de TensorFlow y Keras listos para usar se pueden ejecutar utilizando la biblioteca TensorFlow.js.  Antes de ejecutar el modelo, debe convertir a un nuevo formato con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta herramienta</a> .  Los modelos preformados y transformados para clasificar im√°genes, definir poses y detectar vecinos m√°s cercanos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°n disponibles en Github</a> . <br><br>  <b>Usando TensorFlow.js con Node.js</b> <br><br>  Instalar bibliotecas TensorFlow <br><br>  TensorFlow.js se puede instalar desde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro NPM</a> . <br><br><ul><li>  <code>@tensorflow/tfjs</code> - <code>@tensorflow/tfjs</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Core TensorFlow.js</a> </li><li>  <code>@tensorflow/tfjs-node</code> - extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TensorFlow.js Node.js</a> </li><li>  <code>@tensorflow/tfjs-node-gpu</code> - Extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TensorFlow.js Node.js con soporte inform√°tico GPU</a> </li></ul><br><pre> <code class="plaintext hljs">npm install @tensorflow/tfjs @tensorflow/tfjs-node // ... npm install @tensorflow/tfjs @tensorflow/tfjs-node-gpu</code> </pre> <br>  Ambas extensiones para Node.js usan dependencias nativas, que se compilar√°n a pedido. <br><br>  <b>Descargar TensorFlow Libraries</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La API de JavaScript</a> para Tensorflow se proporciona desde la biblioteca principal.  No se proporcionan API de extensi√≥n en los m√≥dulos de extensi√≥n que admiten Node.js. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ( CPU) require('@tensorflow/tfjs-node') //    ( GPU) require('@tensorflow/tfjs-node-gpu')</span></span></code> </pre> <br>  <b>Descargar modelos TensorFlow</b> <br><br>  TensorFlow.js proporciona una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca NPM</a> ( <code>tfjs-models</code> ) que simplifica la carga de <code>tfjs-models</code> pre-entrenados y transformados para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificar im√°genes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definir poses</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detectar vecinos k-m√°s cercanos</a> . <br><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo de</a> clasificaci√≥n de im√°genes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MobileNet</a> es una red neuronal profunda entrenada para distinguir entre <a href="">1000 clases diferentes de im√°genes</a> . <br><br>  En el archivo README para el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como ejemplo</a> , el siguiente c√≥digo se usa para cargar el modelo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mobilenet <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   const model = await mobilenet.load();</span></span></code> </pre> <br>  Uno de los primeros problemas que encontr√© es que este c√≥digo no funciona con Node.js. <br><br><pre> <code class="plaintext hljs">Error: browserHTTPRequest is not supported outside the web browser.</code> </pre> <br>  Despu√©s de examinar el <a href="">c√≥digo fuente</a> , vemos que la biblioteca mobilenet es un contenedor para la clase <code>tf.Model</code> .  Cuando se lo llama, el m√©todo <code>load()</code> descarga autom√°ticamente los archivos de modelo necesarios ubicados en una direcci√≥n HTTP externa y crea una instancia del modelo TensorFlow. <br><br>  La extensi√≥n Node.js en el momento de la escritura a√∫n no admit√≠a solicitudes HTTP para la recuperaci√≥n de modelos din√°micos.  Todo lo que quedaba era cargar manualmente los modelos en el sistema de archivos. <br><br>  <i>Sin embargo, despu√©s de leer el c√≥digo fuente de la biblioteca, encontr√© una soluci√≥n ...</i> <br><br>  <b>Descargar modelos del sistema de archivos</b> <br><br>  Si la clase MobileNet se crea manualmente, no puede llamar al m√©todo de <code>load</code> del m√≥dulo, sino reescribir la <code>path</code> variable generada autom√°ticamente <code>path</code> contiene la direcci√≥n HTTP del modelo, reemplazando esta direcci√≥n con la ruta local en el sistema de archivos.  Despu√©s de eso, cuando se llama al m√©todo de <code>load</code> en la instancia de clase, se disparar√° la clase del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargador del sistema de archivos</a> ;  en este caso, nos negamos a usar un descargador HTTP basado en navegador. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-string"><span class="hljs-string">"mobilenet/model.json"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load()</code> </pre> <br>  ¬°Genial, todo funciona! <br><br>  Pero, ¬øde d√≥nde vienen los archivos del modelo? <br><br>  <b>Modelos MobileNet</b> <br><br>  Los modelos para TensorFlow.js consisten en dos tipos de archivos: un archivo de configuraci√≥n de modelo almacenado en formato JSON y pesos de modelo almacenados en formato binario.  Los pesos del modelo a menudo se fragmentan en muchas partes para optimizar el almacenamiento en cach√© del navegador. <br><br>  Despu√©s de considerar el <a href="">c√≥digo de descarga autom√°tica</a> para los modelos MobileNet, vemos que los modelos, sus configuraciones y fragmentos de peso se extraen del contenedor p√∫blico en la siguiente direcci√≥n. <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/</code> </pre> <br>  Los par√°metros de la plantilla en la URL describen las versiones del modelo enumeradas <a href="">aqu√≠</a> .  La precisi√≥n de clasificaci√≥n resultante tambi√©n se muestra en la misma p√°gina. <br><br>  El c√≥digo fuente indica que solo los modelos de MobileNet v1 pueden descargarse usando la <code>tensorflow-models/mobilenet</code> . <br><br>  El c√≥digo de extracci√≥n HTTP descarga el archivo <code>model.json</code> desde la ubicaci√≥n de almacenamiento y luego selecciona recursivamente todos los fragmentos de los modelos con pesos referenciados.  Estos son archivos en el formato <code>groupX-shard1of1</code> . <br><br>  <b>Descarga manual de modelos</b> <br><br>  Si desea guardar todos los archivos de modelo en el sistema de archivos, puede hacer esto: extraer el archivo de configuraci√≥n del modelo, analizar la sintaxis de todos los archivos ponderados a los que se hace referencia en el archivo de configuraci√≥n y luego descargar cada archivo ponderado manualmente. <br>  <b>Iba a usar el m√≥dulo MobileNet V1 con un valor alfa de 1.0 y una imagen de 224 p√≠xeles</b> .  Entonces obtengo la <a href="">siguiente URL</a> para el archivo de configuraci√≥n del modelo. <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json</code> </pre> <br>  Una vez que este archivo se descarga localmente, puede usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta</a> <code>jq</code> para analizar los nombres de todos los archivos ponderados. <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> group1-shard1of1 group2-shard1of1 group3-shard1of1 ...</code> </pre> <br>  Con la herramienta <code>sed</code> , puede prefijar el nombre de cada elemento HTTP con una URL para generar una URL para cada archivo de peso. <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//'</span></span> https:<span class="hljs-comment"><span class="hljs-comment">//storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group1-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group2-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group3-shard1of1 ...</span></span></code> </pre><br>  Los comandos <code>parallel</code> y <code>curl</code> le permiten descargar todos estos archivos a mi directorio local. <br><br><pre> <code class="plaintext hljs">cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//' | parallel curl -O</code> </pre> <br>  <b>Clasificaci√≥n de la imagen</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Este c√≥digo de muestra</a> proporcionado con TensorFlow.js muestra c√≥mo devolver el resultado de la clasificaci√≥n de im√°genes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> img = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'img'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   const predictions = await model.classify(img);</span></span></code> </pre> <br>  Esto no funciona en Node.js debido a la falta de soporte DOM. <br><br>  <a href="">El m√©todo de</a> <code>classify</code> acepta varios elementos DOM ( <code>canvas</code> , <code>video</code> , <code>image</code> ) y extrae y convierte autom√°ticamente los bytes de "imagen" de estos elementos a la clase <code>tf.Tensor3D</code> , utilizada como entrada de modelo.  Alternativamente, la <code>tf.Tensor3D</code> se puede transmitir directamente. <br><br>  <b>Decid√≠ no intentar usar un paquete externo para simular un elemento DOM manualmente, pero descubr√≠ que <code>tf.Tensor3D</code> m√°s f√°cil de ensamblar manualmente</b> . <br><br>  <b>Generamos Tensor3D a partir de la imagen.</b> <br><br>  Al leer el <a href="">c√≥digo fuente del</a> m√©todo utilizado para convertir elementos DOM a clases Tensor3D, encontramos que los siguientes par√°metros de entrada se utilizan para generar la clase Tensor3D. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(image.height * image.width * numChannels); <span class="hljs-comment"><span class="hljs-comment">//     ,    const outShape = [image.height, image.width, numChannels]; const input = tf.tensor3d(values, outShape, 'int32');</span></span></code> </pre> <br>  <code>pixels</code> es una matriz de tipo <code>(Int32Array)</code> contiene una lista secuencial de valores de canal para cada p√≠xel.  <code>numChannels</code> es el n√∫mero de valores de canal por p√≠xel. <br><br>  <b>Crear valores de entrada para JPEG</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La biblioteca</a> <code>jpeg-js</code> es un codificador / decodificador JPEG para Node.js escrito en JavaScript puro.  Con esta biblioteca, puede extraer valores RGB para cada p√≠xel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buffer, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Como resultado, obtenemos un Uint8Array con cuatro valores de canal ( <code>RGBA</code> ) para cada p√≠xel ( <code>width * height</code> ).  El modelo MobileNet usa solo tres canales de color ( <code>RGB</code> ) para la clasificaci√≥n, el canal alfa se ignora.  Este c√≥digo convierte una matriz de cuatro canales en una verdadera versi√≥n de tres canales. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numChannels = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } }</code> </pre> <br>  <b>Requisitos de entrada para modelos MobileNet</b> <br><br>  El <a href="">modelo de MobileNet</a> utilizado aqu√≠ clasifica las im√°genes de 224 p√≠xeles de alto y ancho.  Los tensores de entrada deben contener valores de coma flotante en el rango de -1 a 1 para cada uno de los tres valores de canal de cada p√≠xel. <br><br>  Los valores de entrada para im√°genes con una dimensi√≥n diferente deben convertirse al tama√±o correcto antes de la clasificaci√≥n.  Adem√°s, los valores de p√≠xeles obtenidos del decodificador JPEG est√°n en el rango de 0 a 255, no de -1 a 1. Estos valores tambi√©n deben convertirse antes de la clasificaci√≥n. <br><br>  TensorFlow.js tiene m√©todos de biblioteca para simplificar este proceso, pero, a√∫n mejor, ¬°hay una <b><code>tfjs-models/mobilenet</code> especial <code>tfjs-models/mobilenet</code> que <a href="">resuelve autom√°ticamente este problema</a> !</b> <br><br>  El desarrollador puede pasar los Tensor3D de entrada de tipo <code>int32</code> , as√≠ como varias dimensiones al m√©todo de <code>classify</code> , que traduce los valores de entrada al formato correcto antes de la clasificaci√≥n.  Es decir, no tenemos nada que hacer aqu√≠.  Genial <br><br>  <b>Obteniendo predicciones</b> <br><br>  Los modelos MobileNet de Tensorflow aprenden a reconocer objetos de las <a href="">1000 clases m√°s importantes</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de</a> datos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageNet</a> .  En la salida del modelo, proporcione valores probabil√≠sticos que caractericen cu√°les son las posibilidades de encontrar estos objetos en la imagen clasificada. <br><br>  <i>En <a href="">este archivo se</a> encuentra una lista completa de clases capacitadas para el modelo utilizado</i> . <br><br>  La <code>tfjs-models/mobilenet</code> ofrece el m√©todo de <code>classify</code> en la clase <code>MobileNet</code> , que devuelve la X superior de las clases m√°s probables, seg√∫n lo que se muestra en la imagen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  <code>predictions</code> es una matriz de clases X y probabilidades en el siguiente formato. <br><br><pre> <code class="javascript hljs"> { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'panda'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> }</code> </pre> <br>  <b>Ejemplo</b> <br><br>  Entonces, hemos descubierto c√≥mo usar la biblioteca TensorFlow.js y los modelos MobileNet en Node.js, y ahora veamos c√≥mo este script clasifica la imagen especificada como un argumento de l√≠nea de comandos. <br><br>  <i>C√≥digo fuente</i> <br><br>  Guarde este archivo de script y el descriptor del paquete en archivos locales. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"tf-js"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"script.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@tensorflow-models/mobilenet"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.2.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.12.3"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs-node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.1.9"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpeg-js"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.3.4"</span></span> } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobilenet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs-node'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jpeg = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jpeg-js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NUMBER_OF_CHANNELS = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readImage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = fs.readFileSync(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pixels } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageByteArray = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = image.data <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageToInput = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = imageByteArray(image, numChannels) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> outShape = [image.height, image.width, numChannels]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = tf.tensor3d(values, outShape, <span class="hljs-string"><span class="hljs-string">'int32'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadModel = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> path =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mn } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classify = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (model, path) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = readImage(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = imageToInput(image, NUMBER_OF_CHANNELS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn_model = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loadModel(model) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'classification results:'</span></span>, predictions) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.argv.length !== <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'incorrect arguments: node script.js &lt;MODEL&gt; &lt;IMAGE_FILE&gt;'</span></span>) classify(process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>], process.argv[<span class="hljs-number"><span class="hljs-number">3</span></span>])</code> </pre> <br>  <b>Prueba</b> <br><br>  Descargue los archivos del modelo en el directorio de mobilenet siguiendo las instrucciones anteriores. <br>  Establecer dependencias del proyecto usando NPM <br><br> <code>npm install</code> <br> <br>  Descargue un archivo JPEG de muestra para clasificarlo <br><br> <code>wget http://bit.ly/2JYSal9 -O panda.jpg</code> <br> <br><img src="https://habrastorage.org/webt/vt/sm/-2/vtsm-2o5y-t3vhqx5-qaomhxnfw.jpeg"><br><br>  Ejecute el script, cuyos argumentos ser√°n el archivo del modelo y la imagen de entrada. <br><br> <code>node script.js mobilenet/model.json panda.jpg</code> <br> <br>  Si todo funcion√≥ correctamente, la siguiente salida deber√≠a aparecer en la consola. <br><br><pre> <code class="javascript hljs"> classification results: [ { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'giant panda, panda, panda bear, coon bear'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> } ]</code> </pre> <br>  ¬°La imagen est√° clasificada correctamente como que contiene un panda con una probabilidad del 99,93%! <br><br>  <b>Conclusi√≥n</b> <br><br>  La biblioteca TensorFlow.js abre oportunidades de aprendizaje profundo para los desarrolladores de JavaScript.  El uso de modelos previamente entrenados con la biblioteca TensorFlow.js le permite construir f√°cilmente en aplicaciones JavaScript nuevas funciones para resolver problemas complejos de aprendizaje autom√°tico, con un esfuerzo m√≠nimo y un c√≥digo conciso. <br><br>  La biblioteca TensorFlow.js se cre√≥ exclusivamente para trabajar en un navegador, pero ahora interact√∫a con Node.js, aunque no todas las herramientas y utilidades admiten este nuevo tiempo de ejecuci√≥n.  Despu√©s de jugar con la biblioteca durante varios d√≠as, aprend√≠ a usarla con los modelos MobileNet para el reconocimiento visual de im√°genes de un archivo local. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432984/">https://habr.com/ru/post/es432984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432972/index.html">Fuente: "Ley de Conway"</a></li>
<li><a href="../es432976/index.html">An√≥nimo Santa Claus 2018-2019: publicaci√≥n con regalos de A√±o Nuevo</a></li>
<li><a href="../es432978/index.html">John Romero: DOOM Reflexi√≥n</a></li>
<li><a href="../es432980/index.html">VMware NSX para los m√°s peque√±os. Parte 1</a></li>
<li><a href="../es432982/index.html">La introducci√≥n m√°s corta a la creaci√≥n del compilador</a></li>
<li><a href="../es432986/index.html">C vs Go bucles y matem√°tica simple</a></li>
<li><a href="../es432988/index.html">Octavo webmaster. Vive en Habr√©</a></li>
<li><a href="../es432990/index.html">Edison L√°mpara de madera activada por voz. Precio de emisi√≥n $ 5</a></li>
<li><a href="../es432992/index.html">Se puso los auriculares y muri√≥: lidiamos con la extra√±a muerte de un ni√±o en Rimbau.</a></li>
<li><a href="../es432994/index.html">Vivaldi 2.2 - Conversi√≥n de cantidad a calidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>