<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏿 👩🏿‍🏫 🕖 Introduction aux modules Go ✳️ 🌗 🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La prochaine version de la version 1.11 du langage de programmation Go apportera un support expérimental pour les modules - un nouveau système de gest...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction aux modules Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421411/"><p>  La prochaine version de la version 1.11 du langage de programmation Go apportera un support expérimental pour les <em>modules</em> - un nouveau système de gestion des dépendances pour Go.  (note traduction: la <a href="">libération a eu lieu</a> ) </p><br><p>  Récemment, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai déjà écrit un petit article à ce sujet</a> .  Depuis lors, quelque chose a légèrement changé et nous nous rapprochons de la sortie, il me semble donc que le moment est venu pour un nouvel article - ajoutons plus de pratique. </p><br><p>  Alors, voici ce que nous allons faire: créer un nouveau package puis faire quelques versions pour voir comment cela fonctionne. </p><a name="habracut"></a><br><h2 id="sozdanie-modulya">  Création de module </h2><br><p> Créez d'abord notre package.  Appelons cela testmod.  Détail important: <strong>le répertoire du package doit être placé en <em>dehors de</em> votre <code>$GOPATH</code> , car, à l'intérieur, le support du module est désactivé par défaut</strong> .  Les modules Go sont la première étape vers un abandon complet de <code>$GOPATH</code> à l'avenir. </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p>  Notre forfait est assez simple: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p>  Le package est prêt, mais ce n'est pas encore un <em>module</em> .  Corrigeons-le. </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p>  Nous avons un nouveau fichier appelé <code>go.mod</code> dans le répertoire du package avec le contenu suivant: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p>  Un peu, mais c'est ce qui transforme notre package en <em>module</em> . </p><br><p>  Maintenant, nous pouvons pousser ce code dans le référentiel: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git init <span class="hljs-variable"><span class="hljs-variable">$</span></span> git add * <span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-am</span></span> <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin master</code> </pre> <br><p>  Jusqu'à présent, toute personne souhaitant utiliser notre forfait postulerait: </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p>  Et cette commande apporterait le dernier code de la branche principale.  Cette option fonctionne toujours, mais il serait préférable que nous ne le fassions plus, car maintenant "il y a une meilleure façon".  Prendre du code directement de la branche <code>master</code> est, en fait, dangereux, car nous ne savons jamais avec certitude que les auteurs du package n'ont pas apporté de modifications qui «casseraient» notre code.  Pour résoudre ce problème, des modules Go ont été inventés. </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley">  Une petite digression sur les modules de version </h2><br><p>  Les modules Go sont versionnés, plus il y a une certaine spécificité des versions individuelles.  Vous devrez vous familiariser avec les concepts sous-jacents au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">versioning sémantique</a> . </p><br><p>  De plus, Go utilise des balises de référentiel lors de la recherche de versions, et certaines versions diffèrent des autres: par exemple, les versions 2 et plus doivent avoir un chemin d'importation différent de celui des versions 0 et 1 (nous y reviendrons). </p><br><p>  Par défaut, Go télécharge la dernière <em>version, qui a une balise</em> disponible dans le référentiel. <br>  Il s'agit d'une caractéristique importante, car elle peut être utilisée lorsque vous travaillez avec la branche principale. </p><br><p>  Pour nous maintenant, il est important que lors de la création de la version de notre package, nous devions mettre une étiquette avec la version dans le référentiel. </p><br><p>  Faisons-le. </p><br><h2 id="delaem-svoy-pervyy-reliz">  Faire votre première version </h2><br><p>  Notre package est prêt et nous pouvons le "déployer" dans le monde entier.  Nous le faisons en utilisant des étiquettes versionnées.  Soit le numéro de version 1.0.0: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span></code> </pre> <br><p>  Ces commandes créent une balise dans mon référentiel Github qui marque la validation actuelle comme version 1.0.0. </p><br><p>  Go n'insiste pas là-dessus, mais c'est une bonne idée de créer une nouvelle branche supplémentaire ("v1") à laquelle nous pouvons envoyer des patchs. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git checkout <span class="hljs-literal"><span class="hljs-literal">-b</span></span> v1 <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin v1</code> </pre> <br><p>  Maintenant, nous pouvons travailler dans la branche principale sans craindre de casser notre version. </p><br><h2 id="ispolzovanie-nashego-modulya">  Utiliser notre module </h2><br><p>  Utilisons le module créé.  Nous allons écrire un programme simple qui importe notre nouveau package: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p>  Jusqu'à présent, vous devez exécuter <code>go get github.com/robteix/testmod</code> pour télécharger le package, mais avec les modules, cela devient plus intéressant.  Tout d'abord, nous devons activer la prise en charge des modules dans notre nouveau programme. </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p>  Comme vous vous en <code>go.mod</code> probablement, sur la base de ce que vous avez lu précédemment, un nouveau fichier <code>go.mod</code> est apparu dans le répertoire avec le nom du module à l'intérieur: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p>  La situation devient encore plus intéressante lorsque nous essayons de préparer notre programme: </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Comme vous pouvez le voir, la commande <code>go</code> automatiquement trouvé et téléchargé le package importé par notre programme. <br>  Si nous vérifions notre fichier <code>go.mod</code> , nous verrons que quelque chose a changé: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Et nous avons obtenu un autre nouveau fichier appelé <code>go.sum</code> , qui contient les hachages des packages pour vérifier la version et les fichiers corrects. </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki">  Créer une version de correctif de bogue </h2><br><p>  Maintenant, disons que nous avons trouvé un problème dans notre colis: il n'y a pas de ponctuation dans le message d'accueil! <br>  Certaines personnes seront furieuses, car notre salut amical n'est plus aussi amical. <br>  Corrigeons cela et publions une nouvelle version: </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p>  Nous avons fait ce changement directement dans la branche <code>v1</code> , car cela n'a rien à voir avec ce que nous ferons ensuite dans la branche <code>v2</code> , mais dans la vraie vie, vous devriez peut-être apporter ces modifications à <code>master</code> et les rétroporter vers <code>v1</code> .  Dans tous les cas, le correctif devrait être dans la branche <code>v1</code> et nous devons le marquer comme une nouvelle version. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-m</span></span> <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go <span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span> origin v1</code> </pre> <br><h2 id="obnovlenie-moduley">  Mise à jour des modules </h2><br><p>  Par défaut, Go ne met pas à jour les modules sans demande.  «Et c'est bien», car nous souhaitons tous la prévisibilité de nos versions.  Si les modules Go étaient mis à jour automatiquement chaque fois qu'une nouvelle version est publiée, nous reviendrions aux "âges sombres avant-Go1.11".  Mais non, nous devons <em>dire à</em> Go de mettre à jour les modules pour nous. </p><br><p>  Et nous le ferons avec l'aide de notre vieil ami - <code>go get</code> : </p><br><ul><li><p>  lancez <code>go get -u</code> pour utiliser la dernière version <em>mineure ou corrective</em> (c'est-à-dire que la commande sera mise à jour de 1.0.0 vers, disons, 1.0.1 ou vers 1.1.0, si une telle version est disponible) </p><br></li><li><p>  exécutez <code>go get -u=patch</code> pour utiliser la dernière version du patch (c'est-à-dire que le package sera mis à jour vers 1.0.1, mais <em>pas</em> vers 1.1.0) </p><br></li><li><p>  exécutez <code>go get package@version</code> pour effectuer une mise à niveau vers une version spécifique (par exemple, <code>github.com/robteix/testmod@v1.0.1</code> ) </p><br></li></ul><br><p>  Il n'y a aucun moyen dans cette liste de passer à la dernière version <em>majeure</em> .  Il y a une bonne raison à cela, comme nous le verrons bientôt. </p><br><p>  Puisque notre programme a utilisé la version 1.0.0 de notre package et que nous venons de créer la version 1.0.1, l' <em>une</em> des commandes suivantes nous mettra à jour vers 1.0.1: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span>=patch <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get github.com/robteix/testmod@v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br><p>  Après le démarrage (disons <code>go get -u</code> ), notre <code>go.mod</code> a changé: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii">  Version majeure </h2><br><p>  Selon la spécification du versionnage sémantique, la version principale <em>diffère</em> de la version mineure.  Les versions majeures peuvent rompre la compatibilité descendante.  Du point de vue des modules Go, la version principale est un <em>package</em> complètement <em>différent</em> . </p><br><p>  Cela peut sembler sauvage au premier abord, mais cela a du sens: deux versions de la bibliothèque qui sont incompatibles sont deux bibliothèques différentes. </p><br><p>  Faisons un changement majeur dans notre package.  Supposons qu'au fil du temps, il soit devenu clair pour nous que notre API est trop simple, trop limitée pour les cas d'utilisation de nos utilisateurs, nous devons donc changer la fonction <code>Hi()</code> pour accepter la langue de bienvenue comme paramètre: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("¡Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p>  Les programmes existants utilisant notre API vont se casser car ils a) ne transmettent pas la langue en tant que paramètre et b) ne s'attendent pas à un retour d'erreur.  Notre nouvelle API n'est plus compatible avec la version 1.x, alors rencontrez la version 2.0.0. </p><br><p>  J'ai mentionné plus tôt que certaines versions ont des fonctionnalités, et maintenant c'est le cas. <br>  <strong>La version 2 <em>ou ultérieure</em> doit modifier le chemin d'importation.</strong>  Maintenant, ce sont des bibliothèques différentes. </p><br><p>  Nous le ferons en ajoutant un nouveau <em>chemin versionné</em> au nom de notre module. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p>  Tout le reste est le même: pousser, mettre une étiquette que c'est v2.0.0 (et éventuellement soder une branche v2) </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii">  Mise à jour de la version majeure </h2><br><p>  Même si nous avons publié une nouvelle version incompatible de notre bibliothèque, les programmes existants <em>ne se sont pas cassés</em> , car ils continuent d'utiliser la version 1.0.1. <br>  <code>go get -u</code> <em>ne</em> téléchargera <em>pas la</em> version 2.0.0. </p><br><p>  Mais à un moment donné, en tant qu'utilisateur de bibliothèque, je souhaiterai peut-être passer à la version 2.0.0, car, par exemple, je fais partie de ces utilisateurs qui ont besoin de la prise en charge de plusieurs langues. </p><br><p>  Pour mettre à jour, je dois modifier mon programme en conséquence: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Maintenant, quand je lance <code>go build</code> , il "se ferme" et télécharge la version 2.0.0 pour moi.  Notez que bien que le chemin d'importation se termine désormais par "v2", Go fait toujours référence au module par son vrai nom ("testmod"). </p><br><p>  Comme je l'ai dit, la version principale est à tous égards un package différent.  Ces deux modules Go ne sont en aucun cas connectés.  Cela signifie que nous pouvons avoir deux versions incompatibles dans un binaire: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Et cela élimine le problème commun avec la gestion des dépendances lorsque les dépendances dépendent de différentes versions de la même bibliothèque. </p><br><h2 id="navodim-poryadok">  Nous mettons les choses en ordre </h2><br><p>  Revenons à la version précédente, qui utilise uniquement testmod 2.0.0 - si nous vérifions le contenu de <code>go.mod</code> , nous remarquerons quelque chose: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Par défaut, Go ne supprime pas les dépendances de <code>go.mod</code> jusqu'à ce que vous le demandiez.  Si vous avez des dépendances qui ne sont plus nécessaires et que vous souhaitez les nettoyer, vous pouvez utiliser la nouvelle commande <code>tidy</code> : </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p>  Maintenant, nous n'avons que les dépendances que nous utilisons vraiment. </p><br><h2 id="vendoring">  Vente </h2><br><p>  Les modules Go par défaut ignorent le répertoire <code>vendor/</code> .  L'idée est de se débarrasser progressivement du vending <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a></sup> .  Mais si nous voulons toujours ajouter les dépendances "détachées" à notre contrôle de version, nous pouvons le faire: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  L'équipe créera le répertoire <code>vendor/</code> à la racine de notre projet, contenant le code source de toutes les dépendances. </p><br><p>  Cependant, <code>go build</code> par défaut ignore toujours le contenu de ce répertoire.  Si vous souhaitez collecter des dépendances à partir du répertoire <code>vendor/</code> , vous devez le demander explicitement. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go build <span class="hljs-literal"><span class="hljs-literal">-mod</span></span> vendor</code> </pre> <br><p>  Je suppose que de nombreux développeurs qui souhaitent utiliser la distribution s'exécuteront comme d'habitude sur leurs machines et utiliseront <code>-mod vendor</code> sur leur CI. </p><br><p>  Encore une fois, les modules Go s'éloignent de l'idée de vendre pour utiliser des proxys pour les modules pour ceux qui ne veulent pas dépendre directement des services de contrôle de version en amont. </p><br><p>  Il existe des moyens de garantir que <code>go</code> réseau n'est pas disponible (par exemple, en utilisant <code>GOPROXY=off</code> ), mais c'est le sujet du prochain article. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  L'article peut sembler compliqué à quelqu'un, mais c'est parce que j'ai essayé d'expliquer beaucoup de choses à la fois.  La réalité est que les modules Go sont généralement simples aujourd'hui - nous, comme d'habitude, importons le package dans notre code, et l'équipe <code>go</code> fait le reste pour nous.  Les dépendances sont automatiquement chargées lors de l'assemblage. </p><br><p>  Les modules éliminent également le besoin de <code>$GOPATH</code> , qui était une pierre d'achoppement pour les nouveaux développeurs Go qui avaient des problèmes à comprendre pourquoi ils devraient mettre quelque chose dans un répertoire spécifique. </p><br><p><del>  La vente (officieusement) a été dépréciée au profit de l'utilisation d'un proxy. </del>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a></sup> <br>  Je peux faire un article séparé sur les proxys pour les modules Go. </p><br><p>  Remarques: </p><br><p>  <sup>1</sup> Je pense que c'est une expression trop bruyante et certains peuvent avoir l'impression que la vente est supprimée en ce moment.  Ce n'est pas le cas.  La vente fonctionne toujours, quoique légèrement différemment qu'auparavant.  Apparemment, il y a un désir de remplacer la vente par quelque chose de mieux, par exemple, un proxy (pas un fait).  Jusqu'à présent, il s'agit simplement de rechercher une meilleure solution.  La vente ne disparaîtra pas jusqu'à ce qu'un bon remplacement soit trouvé (le cas échéant). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421411/">https://habr.com/ru/post/fr421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421399/index.html">Analyse de la porte dérobée de Turla Cybergroup Outlook</a></li>
<li><a href="../fr421401/index.html">Anatomie des systèmes de recommandation. Deuxième partie</a></li>
<li><a href="../fr421403/index.html">Semaine de la sécurité 32: drame Fortnite-Android</a></li>
<li><a href="../fr421407/index.html">Réunion technique à Saint-Pétersbourg le 13 septembre - Comment faire de grands changements sur le backend</a></li>
<li><a href="../fr421409/index.html">Espionner les choses: garder un secret</a></li>
<li><a href="../fr421413/index.html">Accès correct aux méthodes d'interface par défaut grâce à la réflexion dans Java 8, 9, 10</a></li>
<li><a href="../fr421415/index.html">Magic Leap - trash trash</a></li>
<li><a href="../fr421417/index.html">Machine à café pour les accros au café ou machine à café mobile Wacaco</a></li>
<li><a href="../fr421419/index.html">Ode au nickel «moussé», aux saphirs inexistants et au sous-ministre soviétique: l'OTTO SX-P1 emblématique au Japon, aux USA et en URSS</a></li>
<li><a href="../fr421421/index.html">LAppS: un demi-million de messages WebSocket de 1 Ko par seconde avec TLS sur un processeur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>