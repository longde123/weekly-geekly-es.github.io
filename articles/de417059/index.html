<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôìÔ∏è üèº üà∫ Verbesserung des Downloads von Inhalten ohne Siegel üìΩÔ∏è üçö üôãüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die schnelle und qualitativ hochwertige Bereitstellung von Inhalten f√ºr Benutzer ist die wichtigste Aufgabe, an der wir w√§hrend der Arbeit an der iFun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verbesserung des Downloads von Inhalten ohne Siegel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/417059/"><img src="https://habrastorage.org/webt/0v/on/2o/0von2ovek2gt2hkj_-rqefiia54.jpeg"><br><br>  Die schnelle und qualitativ hochwertige Bereitstellung von Inhalten f√ºr Benutzer ist die wichtigste Aufgabe, an der wir w√§hrend der Arbeit an der iFunny-Anwendung st√§ndig arbeiten.  Das Fehlen wartender Elemente auch bei einer schlechten Verbindung - das ist es, was jeder Dienst zum Anzeigen von Medieninhalten tun m√∂chte. <br><br>  Wir hatten mehrere Iterationen f√ºr die Arbeit mit dem Vorabrufen von Inhalten.  In jeder neuen Hauptversion haben wir etwas Neues erfunden und beobachtet, wie es f√ºr Benutzer funktioniert.  In der n√§chsten Iteration der Arbeit mit dem Prefetching wurde beschlossen, zuerst die Metriken zu debuggen, die sich auf den lokalen Stand auswirken, und erst dann das Ergebnis an die Benutzer weiterzugeben. <br><br>  In diesem Artikel werde ich dar√ºber sprechen, wie das Vorabrufen in iFunny jetzt aussieht und wie der Forschungsprozess automatisiert wurde, um seine Einstellungen weiter zu optimieren. <br><a name="habracut"></a><br><h3>  Standard-Prefetching </h3><br>  In iOS 10 bot Apple die M√∂glichkeit, das Prefetching sofort auszuf√ºhren.  Zu diesem Zweck verf√ºgt die UICollectionView-Klasse √ºber ein Feld: <br><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">UICollectionViewDataSourcePrefetching</span></span>&gt; prefetchDataSource; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">getter</span></span>=isPrefetchingEnabled) <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> prefetchingEnabled;</code> </pre> <br>  Um das native Prefetching zu aktivieren, weisen Sie dem Feld prefetchDataSource einfach ein Objekt zu, das das Protokoll UICollectionViewDatasourcePrefetching implementiert, und legen Sie das zweite Feld in YES fest. <br><br>  Um das Prefetching-Protokoll zu implementieren, m√ºssen zwei Methoden beschrieben werden: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)collectionView:(<span class="hljs-built_in"><span class="hljs-built_in">UICollectionView</span></span> *)collectionView prefetchItemsAtIndexPaths:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *&gt; *)indexPaths; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)collectionView:(<span class="hljs-built_in"><span class="hljs-built_in">UICollectionView</span></span> *)collectionView cancelPrefetchingForItemsAtIndexPaths:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *&gt; *)indexPaths;</code> </pre> <br>  In der ersten Methode k√∂nnen Sie n√ºtzliche Arbeiten zur Erstellung von Inhalten ausf√ºhren. <br><br>  Im Fall von iFunny sah es so aus: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *&gt; *urls = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> new]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *indexPath <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indexPaths) { <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>&lt;IFFeedItemProtocol&gt; *item = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model itemAtIndex:indexPath.row]; <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *downloadURL = item.downloadURL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (downloadURL) { [urls addObject:downloadURL]; } } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.downloadManager updateActiveURLs:urls]; [urls enumerateObjectsUsingBlock:^(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *_Nonnull url, <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> idx, <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> *_Nonnull stop) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.downloadManager downloadContentWithURL:url.absoluteString forView:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> withOptions:<span class="hljs-number"><span class="hljs-number">0</span></span>]; }];</code> </pre> <br>  Die zweite Methode ist optional, wurde jedoch beim iFunny-Band vom System √ºberhaupt nicht aufgerufen. <br><br>  Das Vorabrufen funktioniert, aber wir haben die Methode f√ºr Inhalte nur nach aktiven Inhalten aufgerufen. <br>  Im Allgemeinen h√§ngt die Arbeit des Standard-Prefetching f√ºr UICollectionView stark davon ab, wie die Sammlungsansicht implementiert ist.  Da wir die Implementierung des Standard-Prefetching √ºberhaupt nicht kennen, ist es au√üerdem unm√∂glich, seinen stabilen Betrieb zu gew√§hrleisten.  Deshalb haben wir unseren Prefetching-Mechanismus implementiert, der immer nach Bedarf funktioniert hat. <br><br><h3>  Unser Prefetching-Algorithmus </h3><br>  Vor der Entwicklung des Prefetching-Algorithmus haben wir alle Funktionen des iFunny-Feeds beschrieben: <br><br><ol><li>  Ein Feed kann aus verschiedenen Arten von Inhalten bestehen: Bilder, Videos, Webapps, native Werbung. </li><li>  Das Band arbeitet mit Paginierung. </li><li>  Die meisten Benutzer drehen den Feed nur vorw√§rts. </li><li>  In iFunny finden 20% der Benutzersitzungen √ºber LTE statt. </li></ol><br>  Basierend auf diesen Bedingungen haben wir einen einfachen Algorithmus erhalten: <br><br><ol><li>  Das Band enth√§lt 1 aktives Element, alle anderen sind inaktiv. </li><li>  Das aktive Element muss immer Inhalte bis zum Ende herunterladen. </li><li>  Jedes Inhaltselement im Feed hat sein eigenes Gewicht. </li><li>  √úber die aktuelle Internetverbindung k√∂nnen Sie Elemente in H√∂he von N laden. </li><li>  Jedes Mal, wenn Sie durch das Band scrollen, √§ndern wir das aktive Element, berechnen, welche Elemente geladen werden, und brechen den Rest des Ladens ab. </li></ol><br>  Die Architektur im Code dieses Algorithmus enth√§lt mehrere Basisklassen und ein Protokoll: <br><br><ul><li>  IFPrefetchedCollectionProtocol </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchedCollectionProtocol</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSUInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prefetchItemsCount</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFFeedItemProtocol</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">itemAtIndex</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSInteger</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Dieses Protokoll ist erforderlich, um die Parameter der Sammlung und des Inhalts in Klassenobjekten abzurufen: <br><br><ul><li>  IFContentPrefetcher </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFContentPrefetcher</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">weak</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchedCollectionProtocol</span></span></span><span class="hljs-class">&gt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">activeIndex</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Die Klasse implementiert die Logik des Algorithmus f√ºr das Vorabrufen von Inhalten: <br><br><ul><li>  IFPrefetchOperation </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchOperation</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSUInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cost</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchMinumumBuffer</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchEntireBuffer</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pause</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancel</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BOOL</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isEqualOperation</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchOperation</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Dies ist die Basisklasse einer atomaren Operation, die die n√ºtzliche Arbeit des Vorabrufens bestimmter Inhalte beschreibt und deren Parametergewicht angibt. <br><br>  Um den Algorithmus auszuf√ºhren, haben wir zwei Operationen beschrieben: <br><br><ol><li>  Das Bild.  Es hat ein Gewicht von 1. Immer voll beladen; </li><li>  Video  Es hat ein Gewicht von 2. Wird nur dann vollst√§ndig geladen, wenn es aktiv ist.  Im inaktiven Zustand werden die ersten 200 KB geladen. </li></ol><br>  Als Metrik zur Bewertung der Funktionsweise des Algorithmus haben wir die Anzahl der Treffer des Loader-UI-Elements pro 1000 angezeigten Inhaltselementen ausgew√§hlt. <br><br>  Beim Standard-Prefetching dieser Metrik hatten wir ungef√§hr 30 Impressionen / 1000 Elemente.  Nach der Einf√ºhrung des neuen Algorithmus fiel diese Metrik auf 25 Impressionen / 1000 Elemente. <br><br>  Dadurch verringerte sich die Anzahl der Loader-Impressionen um 20% und die Gesamtzahl der von den Benutzern angezeigten Inhalte nahm leicht zu. <br><br>  Dann gingen wir zur Auswahl der optimalen Parameter f√ºr Featured - das beliebteste Band in iFunny. <br><br><h3>  Auswahl der Parameter f√ºr das Prefetching </h3><br>  Der entwickelte Prefetching-Algorithmus verf√ºgt √ºber Eingabeparameter: <br><br><ol><li>  Die Gesamtkosten des Downloads. </li><li>  Die Kosten f√ºr das Laden jedes Artikels. </li></ol><br>  Wir werden weiterhin die Anzahl der Lader messen. <br><br>  Als Hilfsmittel zur Vereinfachung der Datenerfassung verwenden wir: <br><br><ol><li>  Grautests mit einer Reihe von KIF-Frameworks, OHHTTPStubs. </li><li>  sh-scripts und xcodebuild zum Ausf√ºhren von Tests mit unterschiedlichen Parametern. </li><li>  3G-Netzwerkprofil in der Einstellung Developer - Network Link Conditioner verf√ºgbar. </li></ol><br>  Mal sehen, wie uns jedes dieser Tools geholfen hat. <br><br><h4>  Tests </h4><br>  Um zu emulieren, wie Benutzer Inhalte anzeigen, haben wir uns f√ºr das KIF-Framework entschieden, das iOS-Entwicklern unter Objective-C vertraut ist. <br><br>  KIF eignet sich hervorragend f√ºr Objective-C und Swift, nachdem einige der in der KIF-Dokumentation beschriebenen einfachen Manipulationen vorgenommen wurden: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/kif-framework/KIF#use-with-swift</a> <br><br>  Zum Testen des Bandes haben wir uns f√ºr Objective-C entschieden, auch um die Methoden zu ersetzen, die wir im Analysedienst ben√∂tigen. <br><br>  Werfen wir einen Blick auf den Code eines einfachen Tests, den wir erhalten haben: <br><br><pre> <code class="objectivec hljs"> - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setUp { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> setUp]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> clearCache]; [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> sharedURLCache] removeAllCachedResponses]; [OHHTTPStubs stubRequestsPassingTest:^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span> *_Nonnull request) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [request.URL.absoluteString isEqualToString:<span class="hljs-string"><span class="hljs-string">@"http://fun.co/rp/?feed=featured&amp;limit=30"</span></span>]; } withStubResponse:^OHHTTPStubsResponse *_Nonnull(<span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span> *_Nonnull request) { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *path = OHPathForFile(<span class="hljs-string"><span class="hljs-string">@"featured.json"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.classForCoder); OHHTTPStubsResponse *response = [[OHHTTPStubsResponse alloc] initWithFileAtPath:path statusCode:<span class="hljs-number"><span class="hljs-number">200</span></span> headers:@{ <span class="hljs-string"><span class="hljs-string">@"Content-Type"</span></span> : <span class="hljs-string"><span class="hljs-string">@"application/json"</span></span> }]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; }]; }</code> </pre> <br>  Bei der Test-Setup-Methode m√ºssen wir den Cache leeren, damit bei jedem Start der Inhalt aus dem Netzwerk geladen wird, und den Caches-Ordner in der Anwendung vollst√§ndig l√∂schen. <br><br>  Um die Datenstabilit√§t in jedem der Tests sicherzustellen, haben wir die OHHTTPStubs-Bibliothek verwendet, mit der Antworten auf Netzwerkanforderungen in wenigen einfachen Schritten ersetzt werden k√∂nnen: <br><br><ol><li>  Abfrageparameter definieren.  F√ºr uns ist dies die URL der empfohlenen Feed-Anforderung an die API - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://fun.co/rp/?feed=featured&amp;limit=30</a> </li><li>  Notieren Sie die erforderliche Antwort, speichern Sie sie in einer Datei und h√§ngen Sie sie mit dem Test an das Ziel an. </li><li>  Antwortoptionen definieren.  Im obigen Code ist dies der Content-Type-Header und der Antwortcode. </li><li>  Lesen Sie die Anweisungen f√ºr OHHTTPStubs. </li></ol><br>  Weitere Informationen zur Arbeit mit OHHTTPStubs finden Sie in der Dokumentation: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://cocoadocs.org/docsets/OHHTTPSPSs/</a> <br><br>  Der Test selbst sieht folgenderma√üen aus: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)testFeed { KIFUIViewTestActor *feed = [viewTester usingLabel:<span class="hljs-string"><span class="hljs-string">@"ScrolledFeed"</span></span>]; [feed waitForView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setupCustomPrefetchParams]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { [feed waitForCellInCollectionViewAtIndexPath:[<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> indexPathForRow:i inSection:<span class="hljs-number"><span class="hljs-number">0</span></span>]]; [viewTester waitForTimeInterval:<span class="hljs-number"><span class="hljs-number">1.0</span></span>f]; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> appendStatisticLine]; }</code> </pre> <br>  Mit KIF erhalten wir einen Feed und scrollen dann mit einer Wartezeit von 1 Sekunde durch 1000 Inhaltselemente. <br><br>  Die Methode setupCustomPrefetchParams wird etwas sp√§ter erl√§utert. <br><br>  Um die Anzahl der angezeigten Lader zu bestimmen, verwenden wir die Objective-C-Laufzeit und ersetzen die Methode aus dem Analysedienst durch die Testmethode: <br><br><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)load { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swizzleSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(trackEventLoaderViewedVideo:) ofClass:[IFAnalyticService <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]]; } + (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)swizzleSelector:(SEL)originalSelector ofClass:(Class) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { Method originalMethod = class_getInstanceMethod(<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, originalSelector); Method swizzledMethod = class_getInstanceMethod([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>], originalSelector); <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> didAddMethod = class_addMethod(<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (didAddMethod) { class_replaceMethod(<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, originalSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { method_exchangeImplementations(originalMethod, swizzledMethod); } } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)trackEventLoaderViewedVideo : (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)onVideo { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onVideo) { [IFTestFeed trackLoaderOnVideo]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [IFTestFeed trackLoaderOnImage]; } }</code> </pre> <br>  Jetzt haben wir einen automatischen Test, bei dem die Anwendung immer den gleichen Inhalt erh√§lt und die gleiche Anzahl von Elementen scrollt.  Und entsprechend seinen Ergebnissen schreibt es eine Zeile mit Ausf√ºhrungsstatistiken in das Protokoll. <br><br>  Da die Internetverbindung haupts√§chlich das Herunterladen von Inhalten beeinflusst, muss der Test mit einem Parametersatz mehrmals wiederholt werden. <br><br><h4>  Startautomatisierung </h4><br>  Um die Tests zu automatisieren und zu parametrisieren, haben wir uns entschieden, den Start √ºber xcodebuild mit der √úbertragung der erforderlichen Parameter zu verwenden. <br><br>  Um Parameter an den Code zu √ºbergeben, m√ºssen Sie den Namen des Arguments in die Zieleinstellungen f√ºr die Tests in Prepocessor-Makros schreiben: <br><br><img src="https://habrastorage.org/webt/bu/hc/6z/buhc6zn1ff3hj_2m6bdccsg45ym.png"><br><br>  Um √ºber Objective-C-Code auf einen Parameter zuzugreifen, m√ºssen zwei Makros deklariert werden: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define STRINGIZE(x) #x #define BUILD_PARAM(x) STRINGIZE(x)</span></span></code> </pre> <br>  Wenn Sie jetzt mit xcodebuild vom Terminal aus starten: <br><br><pre> <code class="bash hljs">xcodebuild <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -workspace iFunny.xcworkspace -scheme iFunnyUITests -destination <span class="hljs-string"><span class="hljs-string">'platform=iOS,id=DEVICE_ID'</span></span> MAX_PREFETCH_COST=<span class="hljs-string"><span class="hljs-string">"5"</span></span> VIDEO_COST=<span class="hljs-string"><span class="hljs-string">"2"</span></span> IMAGE_COST=<span class="hljs-string"><span class="hljs-string">"2"</span></span></code> </pre> <br>  Im Code k√∂nnen Sie die √ºbergebenen Parameter lesen: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setupCustomPrefetchParams { <span class="hljs-built_in"><span class="hljs-built_in">NSNumberFormatter</span></span> *formatter = [[<span class="hljs-built_in"><span class="hljs-built_in">NSNumberFormatter</span></span> alloc] init]; formatter.numberStyle = <span class="hljs-built_in"><span class="hljs-built_in">NSNumberFormatterNoStyle</span></span>; [IFAppController instance].prefetchParams.goodNetMaxCost = [formatter numberFromString:@BUILD_PARAM(MAX_PREFETCH_COST)]; [IFAppController instance].prefetchParams.videoCost = [formatter numberFromString:@BUILD_PARAM(VIDEO_COST)]; [IFAppController instance].prefetchParams.imageCost = [formatter numberFromString:@BUILD_PARAM(IMAGE_COST)]; }</code> </pre> <br>  Jetzt ist alles bereit, um diese Tests mithilfe von Shell-Skripten offline auszuf√ºhren. <br><br>  Xcodebuild zehnmal hintereinander mit einer Reihe von Parametern ausf√ºhren: <br><br><pre> <code class="bash hljs">max=10 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 1 <span class="hljs-variable"><span class="hljs-variable">$max</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> xcodebuild <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -workspace iFunny.xcworkspace -scheme iFunnyUITests -destination <span class="hljs-string"><span class="hljs-string">'platform=iOS,id=DEVICE_ID'</span></span> MAX_PREFETCH_COST=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> VIDEO_COST=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$2</span></span></span><span class="hljs-string">"</span></span> IMAGE_COST=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$3</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Wir haben auch ein Skript mit dem Start verschiedener Parameters√§tze generiert.  Alle Tests dauerten mehrere Tage.  Die erhaltenen Daten wurden in einer einzigen Tabelle zusammengefasst und mit der aktuellen Arbeitsversion verglichen. <br><br>  Infolgedessen erwies sich das einfachste Vorabrufen von f√ºnf Elementen als das beste f√ºr Featured iFunny-B√§nder, unabh√§ngig vom Inhaltsformat (Video oder Bild). <br><br><h3>  Nach dem Ergebnis </h3><br>  Der Artikel beschreibt den Ansatz, mit dem Sie wichtige Teile der Anwendung untersuchen und √ºberwachen k√∂nnen, ohne den Hauptprojektcode zu √§ndern. <br><br>  Folgendes hilft bei der Durchf√ºhrung solcher Studien: <br><br><ul><li>  Verwendung von Test-Frameworks f√ºr monotone Aktionen. </li><li>  Automatisierung √ºber xcodebuild zur Parametrisierung von Starts. </li><li>  Laufzeitziel-C, um die erforderliche Logik nach M√∂glichkeit zu √§ndern. </li></ul><br>  Basierend auf diesem Ansatz zum Testen der Anwendung haben wir begonnen, die √úberwachung wichtiger Module am lokalen Stand hinzuzuf√ºgen, und haben bereits mehrere Tests vorbereitet, die wir regelm√§√üig durchf√ºhren, um die Qualit√§t der Anwendung zu √ºberpr√ºfen. <br><br>  PS: Nach den Ergebnissen unserer Tests haben die neuen Prefetching-Einstellungen in Bezug auf die Produktionsoption etwa 8% gewonnen. In Wirklichkeit wurde die Anzeige der Lader um 3% verringert, was bedeutet, dass wir iFunny 3% h√§ufiger zum L√§cheln gebracht haben :) <br><br>  PPS: Wir werden hier nicht aufh√∂ren, wir werden das Prefetching von Inhalten weiter verbessern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417059/">https://habr.com/ru/post/de417059/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417047/index.html">Python Creator: Ich bin m√ºde, ich gehe</a></li>
<li><a href="../de417049/index.html">In der Russischen F√∂deration ist ein vorl√§ufiger Standard f√ºr mobile Anwendungen mit 87 Anforderungen an deren Funktionalit√§t erschienen</a></li>
<li><a href="../de417051/index.html">Apple aktualisiert das MacBook Pro</a></li>
<li><a href="../de417053/index.html">Matrixdruck, Formen</a></li>
<li><a href="../de417055/index.html">SAP Leonardo TV Show - Live im Internet der Dinge, Blockchain, maschinelles Lernen und Big Data</a></li>
<li><a href="../de417063/index.html">Neuronale Netze f√ºr die Kleinsten</a></li>
<li><a href="../de417065/index.html">Splunk-Anleitung oder wie und wo man Splunk lernt</a></li>
<li><a href="../de417069/index.html">Nochmals zu OpenSSL</a></li>
<li><a href="../de417071/index.html">Freitag PHP: Kostenlose Skillbox-Webinare</a></li>
<li><a href="../de417073/index.html">Uber Mobile Developer Day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>