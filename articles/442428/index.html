<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∑Ô∏è ‚úãüèª üë®üèø‚Äçüíº La l√≠nea de comando m√°s simple en NASM y QEMU üóØÔ∏è üêå üëç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entonces, directo al grano. Escribiremos bajo Linux, en NASM y usando QEMU. Esto es f√°cil de instalar, as√≠ que omita este paso. 


 Se entiende que el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La l√≠nea de comando m√°s simple en NASM y QEMU</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442428/"><p><img src="https://habrastorage.org/webt/-m/3u/a3/-m3ua33_7vl-xeb4pg1o8qacclg.png" alt="imagen"></p><br><p>  Entonces, directo al grano.  Escribiremos bajo Linux, en NASM y usando QEMU.  Esto es f√°cil de instalar, as√≠ que omita este paso. </p><br><p>  Se entiende que el lector est√° familiarizado con la sintaxis de NASM al menos en el nivel b√°sico (sin embargo, no habr√° nada particularmente complicado aqu√≠) y entiende qu√© son los registros. </p><a name="habracut"></a><br><h2 id="bazovaya-teoriya">  Teor√≠a b√°sica </h2><br><p>  Lo primero que inicia el procesador cuando la computadora est√° encendida es el c√≥digo del BIOS (o UEFI, pero aqu√≠ solo hablar√© sobre el BIOS), que est√° "conectado" en la memoria de la placa base (espec√≠ficamente, en 0xFFFFFFF0). </p><br><p>  Inmediatamente despu√©s de encender el BIOS, se inicia la autoprueba de encendido (POST), autocomprobaci√≥n despu√©s de encender.  El BIOS verifica el estado de la memoria, detecta e inicializa los dispositivos conectados, verifica los registros, determina el tama√±o de la memoria, y as√≠ sucesivamente. </p><br><p>  El siguiente paso es identificar el disco de inicio desde el que puede iniciar el sistema operativo.  Un disco de arranque es un disco (o cualquier otra unidad) que tiene los √∫ltimos 2 bytes del primer sector (el primer sector significa los primeros 512 bytes de la unidad, porque 1 sector = 512 bytes) es 55 y AA (en formato hexadecimal).  Tan pronto como se encuentre un disco de arranque, el BIOS cargar√° sus primeros 512 bytes en la RAM en la direcci√≥n 0x7c00 y transferir√° el control al procesador en esta direcci√≥n. </p><br><p>  Por supuesto, en estos 512 bytes no funcionar√° para adaptarse a un sistema operativo completo.  Por lo tanto, generalmente en este sector coloque el cargador primario, que carga el c√≥digo del sistema operativo principal en la RAM y le transfiere el control. </p><br><p>  Desde el principio, el procesador ha estado funcionando en modo real (= modo de 16 bits).  Esto significa que solo puede funcionar con datos de 16 bits y utiliza direccionamiento de memoria segmentado, y tambi√©n solo puede direccionar 1 MB de memoria.  Pero no usaremos el segundo aqu√≠.  La siguiente imagen muestra el estado de la RAM al transferir el control a nuestro c√≥digo (la imagen se toma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> ). </p><br><p><img src="https://habrastorage.org/webt/qs/xb/jr/qsxbjr6em-78cr7d6xj7_nh86bg.png" alt="imagen"></p><br><p>  Lo √∫ltimo que hay que decir antes de la parte pr√°ctica son las interrupciones.  Una interrupci√≥n es una se√±al especial (por ejemplo, desde un dispositivo de entrada, como un teclado o mouse) a un procesador que dice que es necesario interrumpir inmediatamente la ejecuci√≥n del c√≥digo actual y ejecutar el c√≥digo del controlador de interrupci√≥n.  Todas las direcciones de los manejadores de interrupciones se encuentran en la Tabla de descriptores de interrupci√≥n (IDT) en la memoria principal.  Cada interrupci√≥n tiene su propio manejador de interrupciones.  Por ejemplo, cuando se presiona una tecla del teclado, se llama a una interrupci√≥n, el procesador se detiene, recuerda la direcci√≥n de la instrucci√≥n interrumpida, guarda todos los valores de sus registros (en la pila) y procede a ejecutar el controlador de interrupci√≥n.  Tan pronto como finaliza su ejecuci√≥n, el procesador restaura los valores de los registros y vuelve a la instrucci√≥n interrumpida y contin√∫a la ejecuci√≥n. </p><br><p>  Por ejemplo, para mostrar algo en la pantalla, el BIOS usa la interrupci√≥n 0x10 (formato hexadecimal), y la interrupci√≥n 0x16 se usa para esperar que se presione una tecla.  De hecho, estas son todas las interrupciones que necesitaremos aqu√≠. </p><br><p>  Adem√°s, cada interrupci√≥n tiene su propia subfunci√≥n que determina la peculiaridad de su comportamiento.  Para mostrar algo en el formato de texto (!), Debe ingresar el valor 0x0e en el registro AH.  Adem√°s, las interrupciones tienen sus propios par√°metros.  0x10 toma valores de ah (define una subfunci√≥n espec√≠fica) y al (el car√°cter a imprimir).  De esta manera </p><br><pre><code class="plaintext hljs">mov ah, 0x0e mov al, 'x' int 0x10</code> </pre> <br><p>  muestra el caracter 'x'.  0x16 toma el valor de ah (subfunci√≥n espec√≠fica) y carga el valor de la clave ingresada en el registro al.  Utilizaremos la funci√≥n 0x0. </p><br><h2 id="prakticheskaya-chast">  Parte pr√°ctica </h2><br><p>  Comencemos con el c√≥digo auxiliar.  Necesitaremos la funci√≥n de comparar dos l√≠neas y la funci√≥n de mostrar una l√≠nea en la pantalla.  Trat√© de describir el funcionamiento de estas funciones en los comentarios lo m√°s claramente posible. </p><br><p>  str_compare.asm: </p><br><pre> <code class="plaintext hljs">compare_strs_si_bx: push si ;         push bx push ax comp: mov ah, [bx] ;     , cmp [si], ah ;      ah jne not_equal ;    ,     cmp byte [si], 0 ;    ,    je first_zero ;    inc si ;     bx  si inc bx jmp comp ;   first_zero: cmp byte [bx], 0 ;    bx != 0,  ,   jne not_equal ;  ,    not_equal mov cx, 1 ;     ,  cx = 1 pop si ;     pop bx pop ax ret ;     not_equal: mov cx, 0 ;  ,  cx = 0 pop si ;    pop bx pop ax ret ;    </code> </pre> <br><p>  La funci√≥n acepta los registros SI y BX como par√°metros.  Si las l√≠neas son iguales, entonces CX se establece en 1, de lo contrario 0. </p><br><p>  Tambi√©n vale la pena se√±alar que los registros AX, BX, CX y DX se dividen en dos partes de un solo byte: AH, BH, CH y DH para el byte alto, y AL, BL, CL y DL para el byte bajo. </p><br><p>  Inicialmente, se supone que en bx y si hay punteros (!) (Es decir, almacena la direcci√≥n en la memoria) a alguna direcci√≥n en la memoria en la que se encuentra el comienzo de la l√≠nea.  La operaci√≥n [bx] tomar√° un puntero de bx, ir√° a esta direcci√≥n y tomar√° alg√∫n valor desde all√≠.  inc bx significa que ahora el puntero se referir√° a la direcci√≥n inmediatamente despu√©s de la direcci√≥n original. </p><br><p>  print_string.asm: </p><br><pre> <code class="plaintext hljs">print_string_si: push ax ;  ax   mov ah, 0x0e ;  ah  0x0e,    call print_next_char ;  pop ax ;  ax ret ;   print_next_char: mov al, [si] ;    cmp al, 0 ;  si  jz if_zero ;     int 0x10 ;     al inc si ;    jmp print_next_char ;   ... if_zero: ret</code> </pre> <br><p>  Como par√°metro, la funci√≥n toma el registro SI y byte a byte imprime una cadena. </p><br><p>  Ahora pasemos al c√≥digo principal.  Primero, definamos todas las variables (este c√≥digo estar√° al final del archivo): </p><br><pre> <code class="plaintext hljs">; 0x0d -   , 0xa -    wrong_command: db "Wrong command!", 0x0d, 0xa, 0 greetings: db "The OS is on. Type 'help' for commands", 0x0d, 0xa, 0xa, 0 help_desc: db "Here's nothing to show yet. But soon...", 0x0d, 0xa, 0 goodbye: db 0x0d, 0xa, "Goodbye!", 0x0d, 0xa, 0 prompt: db "&gt;", 0 new_line: db 0x0d, 0xa, 0 help_command: db "help", 0 input: times 64 db 0 ;   - 64  times 510 - ($-$$) db 0 dw 0xaa55</code> </pre> <br><p>  El car√°cter de retorno de carro mueve el carro al borde izquierdo de la pantalla, es decir, al comienzo de la l√≠nea. </p><br><pre> <code class="plaintext hljs">input: times 64 db 0</code> </pre> <br><p>  significa que asignamos 64 bytes bajo el b√∫fer para entrada y los llenamos con ceros. </p><br><p>  El resto de las variables son necesarias para mostrar cierta informaci√≥n, m√°s adelante en el c√≥digo comprender√° por qu√© son necesarias. </p><br><pre> <code class="plaintext hljs">times 510 - ($-$$) db 0 dw 0xaa55</code> </pre> <br><p>  significa que establecemos expl√≠citamente el tama√±o del archivo de salida (con la extensi√≥n .bin) en 512 bytes, llenamos los primeros 510 bytes con ceros (por supuesto, se llenan antes de que se ejecute el c√≥digo completo) y los dos √∫ltimos bytes con los mismos bytes 55 y AA "m√°gicos" .  $ significa la direcci√≥n de la instrucci√≥n actual, y $$ es la direcci√≥n de la primera instrucci√≥n de nuestro c√≥digo. </p><br><p>  Pasemos al c√≥digo real: </p><br><pre> <code class="plaintext hljs">org 0x7c00 ; (1) bits 16 ; (2) jmp start ;    start %include "print_string.asm" ;     %include "str_compare.asm" ; ==================================================== start: mov ah, 0x00 ;   (3) mov al, 0x03 int 0x10 mov sp, 0x7c00 ;   (4) mov si, greetings ;    call print_string_si ;      mainloop</code> </pre> <br><p>  (1)  Este comando deja en claro a NASM que estamos ejecutando c√≥digo a partir de 0x7c00.  Esto le permite sesgar autom√°ticamente todas las direcciones relativas a esa direcci√≥n para que no lo hagamos expl√≠citamente. <br>  (2)  Este comando le indica a NASM que estamos operando en modo de 16 bits. <br>  (3)  Cuando se inicia, QEMU imprime mucha informaci√≥n que no necesitamos.  Para hacer esto, configure ah 0x00, al 0x03 y llame a 0x10 para borrar la pantalla de todo. <br>  (4)  Para guardar registros en la pila, debe especificar en qu√© direcci√≥n se ubicar√° su v√©rtice utilizando el puntero de la pila SP.  SP indicar√° el √°rea en memoria en la que se escribir√° el siguiente valor.  Agregue el valor a la pila: SP baja la memoria en 2 bytes (ya que estamos en modo real, donde todos los operandos de registro son valores de 16 bits, es decir, de doble byte).  Especificamos 0x7c00, por lo que los valores en la pila se almacenar√°n justo al lado de nuestro c√≥digo en la memoria.  Una vez m√°s, la pila crece (!).  Esto significa que cuantos m√°s valores haya en la pila, menos memoria indicar√° el puntero de la pila SP. </p><br><pre> <code class="plaintext hljs">mainloop: mov si, prompt ;   call print_string_si call get_input ;     jmp mainloop ;  mainloop...</code> </pre> <br><p>  Bucle principal  Aqu√≠, con cada iteraci√≥n, imprimimos el s√≠mbolo "&gt;", despu√©s de lo cual llamamos a la funci√≥n get_input, que implementa el trabajo con interrupci√≥n del teclado. </p><br><pre> <code class="plaintext hljs">get_input: mov bx, 0 ;  bx      input_processing: mov ah, 0x0 ;    0x16 int 0x16 ;  ASCII  cmp al, 0x0d ;   enter je check_the_input ;   ,   ,  ;    cmp al, 0x8 ;   backspace je backspace_pressed cmp al, 0x3 ;   ctrl+c je stop_cpu mov ah, 0x0e ;     -   ;     int 0x10 mov [input+bx], al ;       inc bx ;   cmp bx, 64 ;  input  je check_the_input ;    ,    enter jmp input_processing ;   </code> </pre> <br><p>  (1) [input + bx] significa que tomamos la direcci√≥n del comienzo de la entrada del buffer de entrada y le agregamos bx, es decir, llegamos a bx + el primer elemento del buffer. </p><br><pre> <code class="plaintext hljs">stop_cpu: mov si, goodbye ;   call print_string_si jmp $ ;    ; $    </code> </pre> <br><p>  Aqu√≠ todo es simple: si presion√≥ Ctrl + C, la computadora realiza sin cesar la funci√≥n jmp $. </p><br><pre> <code class="plaintext hljs">backspace_pressed: cmp bx, 0 ;  backspace ,  input ,  je input_processing ;    mov ah, 0x0e ;  backspace.  ,   int 0x10 ;   ,      mov al, ' ' ;      ,  int 0x10 ;   mov al, 0x8 ;       int 0x10 ;     backspace dec bx mov byte [input+bx], 0 ;    input   jmp input_processing ;   </code> </pre> <br><p>  Para no borrar el car√°cter '&gt;' al presionar la tecla de retroceso, verificamos si la entrada est√° vac√≠a.  Si no, entonces no hagas nada. </p><br><pre> <code class="plaintext hljs">check_the_input: inc bx mov byte [input+bx], 0 ;     ,   ;  (  '\0'  ) mov si, new_line ;     call print_string_si mov si, help_command ;  si     help mov bx, input ;   bx -   call compare_strs_si_bx ;  si  bx (  help) cmp cx, 1 ; compare_strs_si_bx   cx 1,  ;     je equal_help ;  =&gt;    ;  help jmp equal_to_nothing ;   ,   "Wrong command!"</code> </pre> <br><p>  Aqu√≠, creo que todo est√° claro por los comentarios. </p><br><pre> <code class="plaintext hljs">equal_help: mov si, help_desc call print_string_si jmp done equal_to_nothing: mov si, wrong_command call print_string_si jmp done</code> </pre> <br><p>  Dependiendo de lo que se ingres√≥, mostramos el texto de la variable help_desc o el texto de la variable wrong_command. </p><br><pre> <code class="plaintext hljs">; done    input done: cmp bx, 0 ;     input   je exit ;   ,    mainloop dec bx ;  ,      mov byte [input+bx], 0 jmp done ;       exit: ret</code> </pre> <br><p>  En realidad, todo el c√≥digo es: </p><br><p>  prompt.asm: </p><br><pre> <code class="plaintext hljs">org 0x7c00 bits 16 jmp start ;    start %include "print_string.asm" %include "str_compare.asm" ; ==================================================== start: cli ;  ,    ;     mov ah, 0x00 ;   mov al, 0x03 int 0x10 mov sp, 0x7c00 ;   mov si, greetings ;    call print_string_si ;      mainloop mainloop: mov si, prompt ;   call print_string_si call get_input ;     jmp mainloop ;  mainloop... get_input: mov bx, 0 ;  bx      input_processing: mov ah, 0x0 ;    0x16 int 0x16 ;  ASCII  cmp al, 0x0d ;   enter je check_the_input ;   ,   ,  ;    cmp al, 0x8 ;   backspace je backspace_pressed cmp al, 0x3 ;   ctrl+c je stop_cpu mov ah, 0x0e ;     -   ;     int 0x10 mov [input+bx], al ;       inc bx ;   cmp bx, 64 ;  input  je check_the_input ;    ,    enter jmp input_processing ;    stop_cpu: mov si, goodbye ;   call print_string_si jmp $ ;    ; $     backspace_pressed: cmp bx, 0 ;  backspace ,  input ,  je input_processing ;    mov ah, 0x0e ;  backspace.  ,   int 0x10 ;   ,      mov al, ' ' ;      ,  int 0x10 ;   mov al, 0x8 ;       int 0x10 ;     backspace dec bx mov byte [input+bx], 0 ;    input   jmp input_processing ;    check_the_input: inc bx mov byte [input+bx], 0 ;     ,   ;  (  '\0'  ) mov si, new_line ;     call print_string_si mov si, help_command ;  si     help mov bx, input ;   bx -   call compare_strs_si_bx ;  si  bx (  help) cmp cx, 1 ; compare_strs_si_bx   cx 1,  ;     je equal_help ;  =&gt;    ;  help jmp equal_to_nothing ;   ,   "Wrong command!" equal_help: mov si, help_desc call print_string_si jmp done equal_to_nothing: mov si, wrong_command call print_string_si jmp done ; done    input done: cmp bx, 0 ;     input   je exit ;   ,    mainloop dec bx ;  ,      mov byte [input+bx], 0 jmp done ;       exit: ret ; 0x0d -   , 0xa -    wrong_command: db "Wrong command!", 0x0d, 0xa, 0 greetings: db "The OS is on. Type 'help' for commands", 0x0d, 0xa, 0xa, 0 help_desc: db "Here's nothing to show yet. But soon...", 0x0d, 0xa, 0 goodbye: db 0x0d, 0xa, "Goodbye!", 0x0d, 0xa, 0 prompt: db "&gt;", 0 new_line: db 0x0d, 0xa, 0 help_command: db "help", 0 input: times 64 db 0 ;   - 64  times 510 - ($-$$) db 0 dw 0xaa55</code> </pre><br><p>  Para compilar todo esto, ingrese el comando: </p><br><pre> <code class="plaintext hljs">nasm -f bin prompt.asm -o bootloader.bin</code> </pre> <br><p>  Y obtenemos el binario con nuestro c√≥digo en la salida.  Ahora ejecute el emulador QEMU con este archivo (-monitor stdio le permite mostrar el valor de registro en cualquier momento usando el comando print $ reg): </p><br><pre> <code class="plaintext hljs">qemu-system-i386 bootloader.bin -monitor stdio</code> </pre> <br><p>  Y obtenemos la salida: </p><br><p><img src="https://habrastorage.org/webt/fq/h2/_7/fqh2_7m_r8mnne4pfo7x4sqvc4k.png" alt="imagen"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442428/">https://habr.com/ru/post/442428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442406/index.html">Fintech digest: transferencias gratuitas en el sistema SBP, la vulnerabilidad de los bancos a los ataques y otras noticias</a></li>
<li><a href="../442408/index.html">La m√°quina universal para realizar pruebas de bricolaje, parte 1</a></li>
<li><a href="../442414/index.html">Estudiar en una universidad extranjera en primera persona</a></li>
<li><a href="../442416/index.html">ITMO University Research and Development Digest: debate sobre tendencias y nuevos logros de los cient√≠ficos</a></li>
<li><a href="../442422/index.html">Entusiasta recre√≥ la tarjeta de sonido Sound Blaster 1.0: cu√©ntenos cu√°n notable es el proyecto</a></li>
<li><a href="../442430/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 288 (24 de febrero - 3 de marzo)</a></li>
<li><a href="../442432/index.html">[Por los muelles] Aleteo. Parte 1. Para desarrolladores de Android</a></li>
<li><a href="../442434/index.html">7 recomendaciones para analizar los 70 principales par√°metros de crecimiento del sitio en 2019 en Yandex</a></li>
<li><a href="../442438/index.html">Una primera mirada a JavaScript a trav√©s de los ojos de un desarrollador de Java</a></li>
<li><a href="../442440/index.html">Creaci√≥n de una aplicaci√≥n de Android con dise√±os de Anko y corrinas de Anko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>