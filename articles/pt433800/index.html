<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ üë®üèø‚Äçüè´ üéπ Usando os controladores UDB PSoC da Cypress para reduzir as interrup√ß√µes em uma impressora 3D üåô üöÇ üëÉüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos coment√°rios sobre a tradu√ß√£o de documenta√ß√£o propriet√°ria na UDB, observou-se corretamente que fatos simples e secos n√£o contribuem para a compree...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando os controladores UDB PSoC da Cypress para reduzir as interrup√ß√µes em uma impressora 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433800/"><img src="https://habrastorage.org/webt/8h/et/xb/8hetxbp_jjuad07ws86ov24ch-c.jpeg"><br><br>  Nos coment√°rios sobre a tradu√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o propriet√°ria na UDB,</a> observou-se corretamente que fatos simples e secos n√£o contribuem para a compreens√£o do material.  Mas esse documento cont√©m precisamente os fatos secos.  Para dilu√≠-los com a pr√°tica, vamos fazer uma pausa na tradu√ß√£o.  Vamos virar esse bloco em nossas m√£os e ver o que e como ele pode ser alcan√ßado na pr√°tica. <br><a name="habracut"></a><br><h2>  Introdu√ß√£o longa </h2><br>  Este artigo √© a segunda parte da trilogia concebida.  A primeira parte est√° localizada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (controle LED RGB atrav√©s da unidade de microcontrolador Cypress UDB PSoC). <br><br>  Al√©m dos controladores UDB PSoC da Cypress, onde determinadas interfaces s√£o implementadas neles, seria interessante verificar como esses blocos podem facilitar a vida dos programadores, descarregando o processador central de determinadas tarefas que exigem muitos recursos.  Mas, para esclarecer o que vou fazer, preciso escrever um extenso pref√°cio. <br><br>  No outono de 2015, comprei uma impressora 3D MZ3D totalmente nova e, na primavera de 2016, estava cansada de como seus motores pisavam.  Os tempos eram selvagens, sobrevivemos da melhor maneira poss√≠vel; portanto, a √∫nica solu√ß√£o era mudar do microstep 1/16 para 1/32.  A correspond√™ncia com a f√°brica mostrou que isso n√£o √© poss√≠vel no Arduino.  Como se viu, houve uma restri√ß√£o no "firmware" daqueles anos, com uma frequ√™ncia de etapa superior a 10 KHz, n√£o foram realizadas etapas virtuais, mas duas etapas virtuais, caso contr√°rio o sistema simplesmente n√£o teve tempo suficiente para processar todas as interrup√ß√µes de "etapa".  S√≥ havia uma sa√≠da: arrastar tudo para a plataforma ARM.  Foi um arrastar e soltar, n√£o um download, pois tamb√©m n√£o havia solu√ß√µes ARM prontas para a √©poca.  Em algumas semanas, transferi tudo isso para o STM32F4, o som dos motores ficou mais agrad√°vel e o problema foi resolvido. <br><br>  Ent√£o, o desenvolvimento do sistema operacional come√ßou em nossa empresa e, nas reuni√µes, tive que provar por um longo tempo que a abordagem t√≠pica para processar interrup√ß√µes nem sempre √© aceit√°vel em termos de velocidade, apelando apenas para esse caso t√≠pico, mas muito glut√£o.  Discuss√µes sobre esse assunto est√£o publicadas no meu artigo sobre interrup√ß√µes no sistema operacional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (Vis√£o geral de um RTOS russo, parte 8. Trabalho com interrup√ß√µes).  Em geral, um problema se instala na minha cabe√ßa h√° muito tempo: interrup√ß√µes auxiliares freq√ºentes que atendem a um subsistema tornam mais lento o resto.  O simples refinamento do processador central, √© claro, elimina o problema, mas n√£o traz a profunda satisfa√ß√£o moral de que tudo √© feito corretamente. <br><br>  Periodicamente, voltei a essa quest√£o em um sentido puramente te√≥rico.  Por exemplo, um dia me ocorreu que, em vez de usar um controlador caro, voc√™ pode usar tr√™s STM32F103C8T6, nos quais uma placa de ensaio pronta custa 110 rublos, levando em considera√ß√£o a entrega, e o pr√≥prio chip √© ainda mais barato.  Em um deles, para executar apenas a fun√ß√£o de controle do motor.  Deixe que ele gaste todo seu poder computacional nessa fun√ß√£o.  Alguns outros (talvez at√© um) resolvem outras tarefas (processamento de comandos, trabalho com PWM, manuten√ß√£o da temperatura etc.) em um ambiente calmo.  Essa solu√ß√£o tamb√©m possui um lado positivo enorme - o n√∫mero total de pinos para v√°rios controladores √© simplesmente enorme.  Em um STM32, eu tive que colocar paci√™ncia por um longo tempo, qual perna atribuir.  Embora as pernas das sa√≠das do timer e as pernas ADC dos ARMs sejam atribu√≠das com mais flexibilidade do que os controladores antigos (uma sa√≠da da unidade de hardware pode ir para uma das v√°rias pernas f√≠sicas), mas ao dobrar o pr√≥prio solit√°rio, voc√™ entende que a flexibilidade pode n√£o ser suficiente.  Se houver muitos controladores, a escolha aumentar√°.  No que serve motores de passo, em geral, simplesmente atribu√≠mos todas as pernas como sa√≠das digitais.  Os outros tamb√©m t√™m para onde se virar. <br><br>  Um problema com essa abordagem √© como sincronizar esses controladores?  Em teoria, o MAX Max RTOS cont√©m tudo o que voc√™ precisa.  O manipulador de comandos gera uma lista de tarefas para mover cabe√ßas.  Periodicamente, ele as modifica (coordenando acelera√ß√µes com tarefas rec√©m-chegadas).  Portanto, a mem√≥ria do modelador e executante deve ser compartilhada.  O RTOS MAX cont√©m a funcionalidade para organizar essa mem√≥ria compartilhada.  Eu o descrevi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (vis√£o geral de um RTOS russo, parte 7. Meios de troca de dados entre tarefas).  Mas, na pr√°tica, uma nuance estraga tudo: a manuten√ß√£o de motores de passo √© um tipo de tarefa de tempo cr√≠tico.  O menor atraso, e obtemos fluxos de pl√°stico para uma impressora 3D, para outras m√°quinas CNC - bem, por exemplo, roscas incorretas.  Qualquer comunica√ß√£o via interfaces seriais n√£o √© a mais r√°pida.  Mais tempo para arbitragem e outras necessidades oficiais.  E acontece que todos os ganhos com a remo√ß√£o da funcionalidade do processador principal v√£o para cima.  Obviamente, aproveitei minha posi√ß√£o oficial: discuti esse assunto com os desenvolvedores deste subsistema.  Infelizmente.  Eles disseram que h√° sincroniza√ß√£o sem muita sobrecarga no sistema operacional, mas para equipamentos que suportem os barramentos correspondentes.  Agora, se eu tomar a arquitetura TigerShark como base, o sistema operacional organizar√° tudo para mim sem nenhuma sobrecarga.  Somente os controladores fabricados de acordo com essa arquitetura s√£o v√°rias vezes mais caros do que toda a impressora 3D que eu queria colocar nela.  Em geral, novamente inaceit√°vel. <br><br>  Abordamos o final de uma introdu√ß√£o prolongada.  Algu√©m dir√° que, por algum motivo, ainda estou procurando um pr√≠ncipe em um cavalo branco.  Voc√™ pode fazer tudo sem um sistema operacional, e aqui estou considerando todo tipo de op√ß√µes ... Voc√™ pode, mas pode, mas quando surgiu o problema pr√°tico ‚ÄúCansado de ouvir a falha da impressora‚Äù, ele foi rapidamente corrigido.  S√≥ isso.  Ela n√£o existe mais.  Al√©m disso, desde ent√£o, surgiram novos drivers de motor de passo que geralmente resolvem o problema de uma maneira completamente diferente (eles recebem um microstep 1/16 e fornecem 1/256).  E nesta introdu√ß√£o, descrevo precisamente que "n√£o h√° <b>uma</b> solu√ß√£o <b>bonita</b> para o problema de interrup√ß√µes frequentes".  Uma decis√£o feia j√° foi tomada.  N√£o queria perder tempo checando outras decis√µes feias.  Eles apenas rolaram na minha cabe√ßa. <br><br>  Mas, quando lidei com os blocos UDB, pareceu-me que o problema pode ser resolvido de maneira bela e dram√°tica.  Voc√™ pode simplesmente levar o processamento de interrup√ß√µes do software para o n√≠vel do firmware, deixando a parte da computa√ß√£o na consci√™ncia do processador principal.  N√£o s√£o necess√°rios controladores adicionais!  Tudo √© colocado no mesmo chip!  Ent√£o, vamos come√ßar. <br><br><h2>  Cavalo esf√©rico no v√°cuo </h2><br>  Neste artigo, trabalhar com o pr√≥prio UDB estar√° na vanguarda.  Se eu falasse sobre estar vinculado a um "firmware" espec√≠fico, eles poderiam apontar corretamente para mim que eu estava enganado com o hub.  O que √© isso para o GeekTimes.  Portanto, o UDB √© prim√°rio e os motores de passo s√£o apenas uma coisa bonita para ilustrar.  Nesta parte, geralmente farei um cavalo esf√©rico no v√°cuo.  Ele ter√° defici√™ncias pr√°ticas, que eliminarei na segunda parte.  Mas, repetindo minhas a√ß√µes, os leitores ser√£o capazes de dominar a metodologia de desenvolvimento de firmware para UDB. <br><br>  Ent√£o  Como funciona o mecanismo de controle do motor de passo?  H√° uma tarefa que alinha os segmentos que a cabe√ßa deve passar com velocidade linear.  At√© agora, vou fingir que n√£o me lembro da acelera√ß√£o no in√≠cio e no final do segmento.  Apenas a cabe√ßa deve passar.  Novos segmentos s√£o colocados na cauda da fila.  Com base na grava√ß√£o da cabe√ßa, uma tarefa separada envia sinais <b>STEP</b> para todos os mecanismos ativos. <br><br>  Deixe a impressora ter uma velocidade m√°xima da cabe√ßa de 200 mm / s.  S√£o necess√°rios 200 passos por 1 mil√≠metro de movimento (esta figura corresponde a uma impressora real MZ3D-256C com um microstep 1/32).  Em seguida, os pulsos devem ser fornecidos com uma frequ√™ncia de at√© 200 * 200 = 40.000 Hz = 40 KHz.  √â com tal frequ√™ncia que uma tarefa que envia pulsos de passo pode muito bem ser chamada.  Ele deve formar programaticamente os pr√≥prios pulsos e tamb√©m calcular quanto tempo ap√≥s o qual a pr√≥xima interrup√ß√£o ativando deve ser chamada. <br><br>  Lembro-me de uma piada sobre Kolobok e os Tr√™s Bogatyrs, onde Kolobok cumprimentou consistentemente os Bogatyrs, depois fez perguntas e recebeu respostas.  Ent√£o sucessivamente disse adeus a eles.  Bem, ent√£o ele se encontrou com os Trinta e Tr√™s Cavaleiros.  O processador est√° no papel de um coque, e os motores de passo est√£o no papel de Bogatyrs.  √â claro que, na presen√ßa de um grande n√∫mero de blocos UDB, √© poss√≠vel paralelizar o trabalho com os motores, tendo cada mecanismo atendido a seu bloco.  E como temos segmentos durante os quais os motores se mover√£o uniformemente, vamos tentar fazer o equipamento funcionar com essas transa√ß√µes, e n√£o a cada passo. <br><br>  Que informa√ß√µes s√£o necess√°rias para um cavalo esf√©rico atravessar uma se√ß√£o linear no v√°cuo? <br><br><ul><li>  N√∫mero de etapas. </li><li>  O per√≠odo entre as etapas. </li></ul><br>  Dois par√¢metros  O UDB possui apenas duas baterias e dois registros dos par√¢metros D0 e D1.  Parece que tudo √© realiz√°vel.  Apenas estimamos a profundidade de bits que esses registros devem ter. <br><br>  Primeiro, o n√∫mero de etapas.  Se houver 8 d√≠gitos, em uma opera√ß√£o UDB, a impressora poder√° mover a cabe√ßa da impressora cartesiana um pouco mais de 1 mm (200 micro etapas).  N√£o chega.  Se a capacidade for 16 bits, o n√∫mero de etapas ser√° 65536. Isso √© 65536/200 = 327 mil√≠metros.  Aceit√°vel para a maioria dos modelos.  Para Core, Delta e outros, √© necess√°rio estimar, mas como um todo - para um curso completo, o segmento pode ser dividido em v√°rias partes.  N√£o haver√° tantos (dois, no m√°ximo, tr√™s). <br><br>  Agora o per√≠odo.  Deixe a frequ√™ncia do rel√≥gio ser 48 MHz.  48000000/65536 = 732.  Ou seja, a frequ√™ncia m√≠nima permitida que pode ser obtida usando um divisor de 16 bits √© 732 Hz.  Demais.  No firmware do Marlin, o m√≠nimo √© 120 Hz (o que corresponde aproximadamente a 8 MHz dividido pela mesma constante 65536).  Teremos que fazer os registros 24 bits.  Ent√£o a frequ√™ncia m√≠nima ser√° igual a 48000000 / (2 ^ 24) = 48000000/16777216 = 2,861 Hz. <br><br>  Bom  Pare a teoria chata!  Vamos seguir em frente!  Inicie o PSoC Creator e selecione Arquivo-&gt; Novo-&gt; Projeto: <br><br><img src="https://habrastorage.org/webt/tk/9t/bj/tk9tbjfppfjemih3s-ydrk54lfc.png"><br><br>  Em seguida, selecionei a placa de ensaio que tenho, a partir da qual o ambiente obter√° informa√ß√µes b√°sicas sobre o controlador usado e suas configura√ß√µes: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  Eu j√° me sinto pronto para criar um projeto do zero, ent√£o seleciono <b>Esquema Vazio</b> : <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  D√™ ao ambiente de trabalho o nome <b>PSoC3DTest</b> : <br><br><img src="https://habrastorage.org/webt/rr/0u/pd/rr0updtyevaseusbwel37v76bgc.png"><br><br>  E aqui est√° ele, um projeto acabado! <br><br><img src="https://habrastorage.org/webt/fw/0s/xu/fw0sxucryznmujjsvr5ockarrjc.png"><br><br>  A primeira coisa que quero fazer √© criar meu pr√≥prio componente com base no UDB.  Portanto, como j√° observado no √∫ltimo artigo, preciso mudar para a guia <b>Componentes</b> : <br><br><img src="https://habrastorage.org/webt/oa/o8/s5/oao8s5whrsdn9xsnophfoaom_n4.png"><br><br>  Clique com o bot√£o direito do mouse no projeto e selecione <b>Adicionar item do componente</b> : <br><br><img src="https://habrastorage.org/webt/zq/kt/hu/zqkthur3pa19fpcrq4kcrmdac_y.png"><br><br>  Dizemos que precisamos adicionar um <b>documento UDB</b> , altere o nome para <b>StepperController</b> e clique em <b>Criar novo</b> : <br><br><img src="https://habrastorage.org/webt/tz/v8/qk/tzv8qkfqumypnq3ctjeh9moitpc.png"><br><br>  O componente apareceu na √°rvore, mais - o editor deste componente foi aberto: <br><br><img src="https://habrastorage.org/webt/yo/4g/np/yo4gnpvs5fuewpovam09lbq3zmw.png"><br><br>  Coloque o bloco Datapath no formul√°rio: <br><br><img src="https://habrastorage.org/webt/nx/1o/bl/nx1oblbig1eqyqat0yj-evlvwo0.png"><br><br>  Depois de selecionar este bloco, vamos √†s suas propriedades e alteramos a profundidade do bit de 8 para 24. Os demais par√¢metros podem permanecer inalterados. <br><br><img src="https://habrastorage.org/webt/1e/oq/rf/1eoqrfsjz5uh1fj2mopwtmf5vao.png"><br><br>  Para iniciar todos os blocos (para todos os motores) ao mesmo tempo, iniciarei o sinal de partida do lado de fora (adicione a entrada <b>Iniciar</b> ).  Sa√≠das: Vou fazer a sa√≠da do <b>Step</b> diretamente, para que eu possa envi√°-lo ao driver do motor de passo, bem como ao <b>Out_Idle</b> .  Com base nesse sinal, o processador poder√° determinar que, no momento em que a unidade terminou seu trabalho.  Os nomes dos circuitos correspondentes a essas entradas e sa√≠das s√£o vis√≠veis na figura. <br><br><img src="https://habrastorage.org/webt/sx/xq/gv/sxxqgvsyvpyr_jvzdblaf_l1soc.png"><br><br>  Antes de falar sobre a l√≥gica do aut√¥mato, descreverei outro problema puramente de engenharia: definir a dura√ß√£o do pulso <b>Etapa</b> .  A documenta√ß√£o do driver DRV8825 exige que a largura do pulso seja de pelo menos 1,9 Œºs.  Outros drivers s√£o menos exigentes em sua largura.  Como j√° observado na parte te√≥rica, os registros existentes j√° est√£o ocupados, definindo a dura√ß√£o e o n√∫mero de etapas.  Goste ou n√£o, um contador de sete bits deve ser colocado no circuito.  N√≥s chamamos isso de one-shot, que define o pulso do passo.  A uma frequ√™ncia de 48 MHz, para garantir uma dura√ß√£o de 1,9 Œºs, este contador deve contar pelo menos 91,2 etapas.  Arredonde para 92. Qualquer valor que exceda esse valor n√£o ser√° menor.  Acontece a seguinte configura√ß√£o: <br><br><img src="https://habrastorage.org/webt/6w/k9/em/6wk9emz-qedseywswmgk24bdjqe.png"><br><br>  Nome do contador <b>SingleVibrator</b> .  Ele nunca √© redefinido; portanto, a entrada <b>Redefinir</b> est√° sempre conectada a zero; considera que quando a m√°quina (descrita abaixo) est√° no estado Um, carrega em todos os outros estados (a princ√≠pio eu selecionei estados espec√≠ficos da m√°quina, mas verificamos que com um m√©todo t√£o complicado , s√£o necess√°rios muito menos recursos PLD, mas o resultado √© o mesmo).  O valor da carga √© decimal 92. √â verdade que um bom editor substituir√° imediatamente esse valor por hexadecimal: <br><br><img src="https://habrastorage.org/webt/qt/h0/nv/qth0nvcbb_8m7qty2mj1zpde2m4.png"><br><br>  Quando o contador √© contado como zero, ele informa isso √† cadeia com o nome <b>One_Finished</b> .  Com o balc√£o - √© isso. <br><br>  Que tipo de sinalizadores de status nossa m√°quina usar√°?  Entendi assim (lembre-se de clicar duas vezes na lista de sa√≠das no Datapath para defini-las): <br><br><img src="https://habrastorage.org/webt/mk/oo/z_/mkooz_ywbi5vnaenpgfqo98p580.png"><br><br><img src="https://habrastorage.org/webt/br/u9/rz/bru9rzw4kk4ja4j6ehutvm7od14.png"><br><br>  Usarei a bateria A0 como um contador para a dura√ß√£o do pulso, portanto, quando seu valor chegar a zero, a bandeira √† qual eu dei o nome <b>Pulse_Finished</b> ser√° armada.  A bateria A1 contar√° pulsos para mim.  Portanto, seu zeramento exibir√° o sinalizador <b>Process_Finished</b> . <br><br>  Constru√≠mos o gr√°fico de transi√ß√£o do aut√¥mato: <br><br><img src="https://habrastorage.org/webt/bv/rr/cv/bvrrcv0pgjs9fvadt08iyqaj92i.png"><br><br>  A vari√°vel que define seu estado √© chamada <b>State</b> .  Mapeie imediatamente essa vari√°vel para o registro de endere√ßo da instru√ß√£o ALU.  No come√ßo eu esqueci de fazer isso, ent√£o por um longo tempo eu n√£o conseguia entender por que minha m√°quina n√£o funciona.  Clique duas vezes no bloco de entradas no Datapath: <br><br><img src="https://habrastorage.org/webt/zl/z2/e0/zlz2e0tvkl11wc5ot0id4vsdnh4.png"><br><br>  E combinar: <br><br><img src="https://habrastorage.org/webt/1e/sp/q1/1espq1co36mt063kgyvig-kzhsw.png"><br><br>  Come√ßamos a lidar com o gr√°fico de transi√ß√£o e as instru√ß√µes da ALU associadas a ele. <br><br>  Vamos come√ßar com o estado <b>ocioso</b> .  √â bastante saturado em suas a√ß√µes. <br><br>  Em primeiro lugar, o valor dos registros de dados D0 e D1 √© constantemente colocado nas baterias A0 e A1, respectivamente: <br><br><img src="https://habrastorage.org/webt/hz/8p/c-/hz8pc-lydhvzq3cnvsg2jw2qcem.png"><br><br>  A partir dessa entrada, o olho treinado ver√° tudo o que voc√™ precisa.  Como nossos olhos ainda n√£o est√£o definidos, clicamos duas vezes na entrada e vemos a mesma coisa, mas com mais detalhes: <br><br><img src="https://habrastorage.org/webt/yu/yy/qe/yuyyqemtvqbcsp25mbud7y3y1mu.png"><br><br>  O principal valor aqui √© encher a bateria A1, o contador de pulsos.  Quando o programa digita o valor D1, ele imediatamente passa para A1.  O programa definitivamente n√£o ter√° tempo para iniciar o processo at√© a pr√≥xima medida.  Este valor √© verificado para formar uma condi√ß√£o para sair desse estado, ou seja, n√£o h√° outro lugar para preench√™-lo. <br><br>  Agora vamos ver o que √© feito no n√≠vel do gr√°fico de transi√ß√£o: <br><br><img src="https://habrastorage.org/webt/97/p-/2d/97p-2dwdvbxyb_tpi-xaqjdhuck.png"><br><br>  O gatilho auxiliar <b>Start_Prev</b> permite capturar uma <b>margem</b> positiva no <b>in√≠cio de</b> entrada, organizando uma linha de atraso por 1 ciclo.  Ele sempre conter√° o estado da entrada <b>Iniciar</b> , que estava na medida anterior.  Algu√©m est√° mais familiarizado com isso no Verilog: <br><br><img src="https://habrastorage.org/webt/mm/pc/vw/mmpcvwuturlr5nieqnkgieml_tm.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto</b> <div class="spoiler_text"><pre><code class="plaintext hljs">always @ (posedge clock) begin : Idle_state_logic case(State) Idle : begin Start_Prev &lt;= (Start); IsIdle &lt;= (1); if (( Start&amp;(!Start_Prev)&amp;(!Process_Finished) ) == 1'b1) begin State &lt;= One ; end end</code> </pre> <br></div></div><br>  Portanto, a <b>condi√ß√£o Start &amp; (! Start_Prev) √©</b> verdadeira somente quando <b>ocorre uma</b> diferen√ßa positiva na linha de <b>partida</b> <b>entre as medidas</b> . <br><br>  Al√©m disso, quando a m√°quina est√° nesse estado, a sa√≠da <b>IsIdle</b> √© <b>trazida</b> para um √∫nico estado, informando ao ambiente externo que o bloco √© passivo.  Com essa abordagem, menos recursos PLD s√£o gastos do que se a constru√ß√£o <b>State == Idle</b> fosse submetida √† sa√≠da. <br><br>  Quando a diferen√ßa do sinal de <b>partida</b> vier do ambiente externo e o acumulador A1 tiver um valor diferente de zero, a m√°quina sair√° do estado <b>ocioso</b> .  Se for inserido zero em A1, o mecanismo n√£o estar√° envolvido no desenvolvimento desse segmento, para que a diferen√ßa na linha de <b>partida</b> seja ignorada.  Isso se aplica a uma extrusora n√£o utilizada.  Para algumas impressoras, o mecanismo do eixo Z tamb√©m √© raramente usado.Lembre-se de como uma condi√ß√£o √© formada que revela um valor zero em A1 (e diferente de zero √© a invers√£o): <br><br><img src="https://habrastorage.org/webt/ez/kk/up/ezkkuprcmblrfjx22av9dlfu5bc.png"><br><br>  Em seguida, a m√°quina entra no estado <b>Um</b> : <br><br><img src="https://habrastorage.org/webt/zr/qc/cm/zrqccmzwghfncwcqyfekuhawmcg.png"><br><br>  Nesse estado, a sa√≠da da <b>etapa</b> √© definida como 1. Um pulso de etapa √© aplicado ao driver.  Al√©m disso, o valor do acionador <b>IsIdle</b> √© <b>redefinido</b> .  O ambiente externo √© informado de que a unidade est√° na fase ativa. <br><br>  Este estado √© <b>encerrado</b> pelo sinal <b>One_Finished</b> , que ser√° aumentado para um quando o contador de sete bits for zero.  Deixe-me lembr√°-lo de que o sinal <b>One_Finished √©</b> gerado por este contador espec√≠fico: <br><br><img src="https://habrastorage.org/webt/ls/yp/re/lsypreow8ydou_tqhrls8us-qem.png"><br><br>  Enquanto a m√°quina estiver nesse estado, a ALU carrega na bateria A0 (configurando a dura√ß√£o do pulso) o valor do registro D0.  Deixe-me mostrar apenas uma pequena nota dizendo o seguinte: <br><br><img src="https://habrastorage.org/webt/am/b_/fa/amb_faw1o-9vsgframn5iswseas.png"><br><br>  O valor carregado ser√° usado no seguinte estado.  Estando nela, a m√°quina gera um atraso que define a dura√ß√£o do pulso: <br><br><img src="https://habrastorage.org/webt/hh/eb/kf/hhebkfiwmsmnnrtkf17w2wqby8o.png"><br><br>  A sa√≠da da <b>etapa</b> √© redefinida para zero.  A bateria A0 diminui, conforme evidenciado pela seguinte entrada breve: <br><br><img src="https://habrastorage.org/webt/bb/63/dk/bb63dkglkjd8_7wn1s2by22_hym.png"><br><br>  E se voc√™ clicar duas vezes nele - uma entrada completa: <br><br><img src="https://habrastorage.org/webt/-8/6d/ry/-86dryefyslh1qsvlo4ggkdojhg.png"><br><br>  Quando o valor de A0 chegar a zero, a flag Pules_Finished ser√° aumentada e a m√°quina entrar√° no estado <b>Decrement</b> : <br><br><img src="https://habrastorage.org/webt/6k/sw/yv/6kswyvakmiszucfe1cx49pjcyig.png"><br><br>  Nesse estado, na ALU, o valor do acumulador A1 diminui, o que define o n√∫mero de pulsos: <br><br><img src="https://habrastorage.org/webt/ci/9r/1e/ci9r1ervyzj1gyma_tpj4uxnzfq.png"><br><br>  Vers√£o completa do registro: <br><br><img src="https://habrastorage.org/webt/l9/dk/hy/l9dkhy0a6bb2bqpzgmzgtox7clk.png"><br><br>  Dependendo do resultado, ocorre uma transi√ß√£o para o pr√≥ximo pulso ou para o estado <b>ocioso</b> .  Clique duas vezes no estado para ver as transi√ß√µes levando em considera√ß√£o as prioridades: <br><br><img src="https://habrastorage.org/webt/jm/r-/7n/jmr-7nle2advdfl95fn8hnkid0i.png"><br><br>  Na verdade, com tudo UDB.  Agora fazemos o s√≠mbolo correspondente.  Para fazer isso, clique com o bot√£o direito do mouse no editor e selecione <b>Gerar s√≠mbolo</b> : <br><br><img src="https://habrastorage.org/webt/j6/j3/qc/j6j3qcgoye9-2gac8fgowordfx8.png"><br><br>  Vamos ao diagrama do projeto: <br><br><img src="https://habrastorage.org/webt/ab/hb/l4/abhbl4ocjtfgw8r4vjfo8nfs05c.png"><br><br>  E n√≥s introduzimos um circuito no qual existe um certo n√∫mero desses controladores.  Eu escolhi cinco (tr√™s eixos mais duas extrusoras).  Impressoras com um grande n√∫mero de extrusoras n√£o ser√£o consideradas baratas.  Voc√™ pode colocar FPGA neles.  Ao longo do caminho, para ver a real complexidade, joguei um bloco USB-UART (para receber dados de um computador ou o mesmo Raspberry Pi) e um UART real (ele fornecer√° comunica√ß√£o com um m√≥dulo Wi-Fi barato ESP8266 ou, por exemplo, um monitor inteligente que pode envie GCODE via UART).  N√£o adicionei PWMs e assim por diante, pois a complexidade deles √© aproximadamente clara e o sistema real ainda est√° longe.  Aconteceu algo assim: <br><br><img src="https://habrastorage.org/webt/he/a6/ok/hea6okfr7irbrzjwm-bze2xlfxy.png"><br><br>  O registro de controle gera um sinal de disparo, que vai para todos os blocos simultaneamente.  Al√©m disso, deixe sair sinais, que s√£o est√°ticos durante a forma√ß√£o do segmento.  Eu coletei todas as sa√≠das <b>ociosas</b> por "And" e apliquei na entrada de interrup√ß√£o.  Marquei uma interrup√ß√£o em uma frente positiva.  Se pelo menos um motor der partida, a entrada de interrup√ß√£o ser√° redefinida.  No final do √∫ltimo mecanismo, ele ser√° engatilhado, o que informar√° o processador sobre a disponibilidade para a conclus√£o do pr√≥ximo segmento.  Agora ajuste as frequ√™ncias clicando duas vezes no elemento da √°rvore <b>Clocks</b> : <br><br><img src="https://habrastorage.org/webt/zy/yf/kl/zyyfklrmcfz5kmg-59qmzgdztug.png"><br><br>  Na tabela exibida, clique duas vezes no elemento <b>PLL_OUT</b> : <br><br><img src="https://habrastorage.org/webt/8z/m0/r1/8zm0r10tu28rjatkhmo1h0skp80.png"><br><br>  De alguma forma, preencheremos a tabela (n√£o entendi bem as regras para configurar essa tabela, e √© por isso que uso o termo "Algo assim"): <br><br><img src="https://habrastorage.org/webt/se/55/ps/se55ps9rti9fyvyguffgxdx0f0i.png"><br><br>  Agora clique duas vezes na linha <b>Clock_1</b> : <br><br><img src="https://habrastorage.org/webt/vn/py/px/vnpypxluipgeeme1fyf9icn9tu4.png"><br><br>  Defina a frequ√™ncia do rel√≥gio dos blocos UDB para 48 MHz: <br><br><img src="https://habrastorage.org/webt/8z/sk/ik/8zskik6rpyovzo7ryqrxjeptinm.png"><br><br>  Como o projeto √© experimental, n√£o faz sentido criar uma API para ele.  Mas, para consolidar o material estudado no artigo anterior, vamos novamente √† guia Componentes e, para o projeto StepperController, clique com o bot√£o direito do mouse no item Adicionar componente primeiro, adicione o arquivo de cabe√ßalho e, em seguida, o arquivo de c√≥digo-fonte C: <br><br><img src="https://habrastorage.org/webt/3i/bg/zk/3ibgzkq8nugwau5lszhe9ikudxi.png"><br><br><img src="https://habrastorage.org/webt/bm/k3/iw/bmk3iwh-aouvspv20g7_1bgi3wq.png"><br><br>  Mostrarei superficialmente as duas fun√ß√µes de inicializa√ß√£o e in√≠cio do segmento que adicionei.  O restante pode ser visto no exemplo do artigo. <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start } void `$INSTANCE_NAME`_PrepareStep(int nSteps,int duration) { CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D0_PTR, duration&gt;92?duration-92:0); CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D1_PTR, nSteps&gt;1?nSteps-1:0); }</code> </pre><br>  Substitu√≠ o nome de <b>main.c</b> por <b>main.cpp</b> para verificar se o ambiente de desenvolvimento responder√° normalmente ao C ++, porque o firmware do Marlin √© orientado a objetos.  Previsivelmente, erros que foram eliminados previsivelmente pela adi√ß√£o de uma coisa comum: <br><br><img src="https://habrastorage.org/webt/5m/mn/cd/5mmncdgxig9oxchcekaofuv1k9y.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "project.h" }</code> </pre><br></div></div><br>  Para o lan√ßamento global de motores, eu fiz essa fun√ß√£o (√© muito dif√≠cil, mas para experimentos com um cavalo esf√©rico no v√°cuo, √© o que acontece, em experimentos o tempo de desenvolvimento √© mais importante que a beleza): <br><pre> <code class="plaintext hljs">void StartSteppers() { Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (0); }</code> </pre><br>  Ela inicia o sinal de <b>in√≠cio</b> , por precau√ß√£o, imediatamente por tr√™s medidas e depois o solta novamente. <br><br>  Bem, vamos come√ßar os experimentos.  Primeiro, basta passar pelos mecanismos X e Y (no exemplo, o primeiro grupo de chamadas inicializa todos os controladores, o segundo define os controladores X e Y para o n√∫mero necess√°rio de etapas e inicia o processo): <br><br><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); StepperController_X_PrepareStep (10,1000); //    StepperController_Y_PrepareStep (50,500); StartSteppers(); //   for(;;) { } }</code> </pre><br>  N√≥s olhamos para o resultado: <br><br><img src="https://habrastorage.org/webt/6x/io/v7/6xiov7g15a-ksl1_6kw7vkko0dc.png"><br><br>  Verifique a dura√ß√£o do pulso positivo: <br><br><img src="https://habrastorage.org/webt/ay/hk/jy/ayhkjyjphl4-pearn7zi3hnnknc.png"><br><br>  Isso mesmo.  Por fim, verificamos qu√£o bem a interrup√ß√£o funciona.  Adicione uma vari√°vel global de contador: <br><br><pre> <code class="plaintext hljs">static int nStep=0;</code> </pre><br>  Essa vari√°vel √© atribu√≠da a uma na fun√ß√£o <b>principal</b> e aumenta a fun√ß√£o do manipulador de interrup√ß√µes.  O manipulador de interrup√ß√£o ser√° acionado apenas uma vez, apenas para verifica√ß√£o.  Eu fiz assim: <br><br><pre> <code class="plaintext hljs">extern "C" { CY_ISR(StepperFinished) { if (nStep == 1) { StepperController_X_PrepareStep (5,500); StartSteppers(); nStep += 1; } } }</code> </pre><br>  E na fun√ß√£o <b>principal</b> , adicionei literalmente duas linhas: a inclus√£o de interrup√ß√µes e a atribui√ß√£o dessa mesma vari√°vel.  E j√° atribuo quando as m√°quinas foram iniciadas.  Caso contr√°rio, veio uma solicita√ß√£o de interrup√ß√£o falsa.  N√£o h√° nenhuma raz√£o espec√≠fica para combat√™-lo agora.  O projeto √© experimental. <br><br><img src="https://habrastorage.org/webt/kb/v2/dm/kbv2dmk2s6cg9nzc9fjzypg5uyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); /* Place your initialization/startup code here (eg MyInst_Start()) */ StepperController_X_PrepareStep (10,1000); StepperController_Y_PrepareStep (20,500); StartSteppers(); nStep = 1; for(;;) { } }</code> </pre><br></div></div><br>  Verificamos o resultado (na segunda etapa, apenas o mecanismo X deve funcionar e as etapas devem ficar com a metade): <br><br><img src="https://habrastorage.org/webt/0q/vi/iq/0qviiqvpko6m9i7o9tub3gmnqhw.png"><br><br>  Isso mesmo. <br><br><h2>  Conclus√£o </h2><br>  Em geral, j√° est√° claro que os blocos UDB podem ser usados ‚Äã‚Äãn√£o apenas para definir fun√ß√µes r√°pidas de hardware, mas tamb√©m para mover a l√≥gica do software para o n√≠vel do firmware.  Infelizmente, o volume do artigo foi t√£o grande que parece imposs√≠vel concluir a revis√£o e obter uma resposta inequ√≠voca se os recursos do UDB s√£o suficientes para a solu√ß√£o final da tarefa.  At√© agora, apenas um cavalo esf√©rico est√° pronto no v√°cuo, cujas a√ß√µes, em princ√≠pio, s√£o muito semelhantes √†s necess√°rias, mas um leitor irritante familiarizado com a teoria do controle do motor de passo encontrar√° muitas defici√™ncias nele.  A unidade apresentada n√£o suporta acelera√ß√£o, sem a qual a opera√ß√£o de um motor de passo real √© imposs√≠vel.  Em vez disso, suporta, mas nesse est√°gio ser√° necess√°ria uma alta taxa de interrup√ß√£o, e tudo foi concebido para evitar isso. <br><br>  A precis√£o de definir a frequ√™ncia do bloco apresentado est√° longe de ser aceit√°vel.  Em particular, fornecer√° uma frequ√™ncia de pulso de 40.000 Hz com um divisor de 1200 e 39966 Hz com um divisor de 1201. As frequ√™ncias intermedi√°rias entre esses dois valores neste bloco s√£o inating√≠veis. <br><br>  Talvez haja outras defici√™ncias nele.  Mas vamos lidar com eles no pr√≥ximo artigo para verificar se existem recursos UDB suficientes. <br><br>  Enquanto isso, os leitores receberam, entre outras coisas, um exemplo real de cria√ß√£o de um bloco baseado em UDB do zero.  O projeto de teste obtido durante a reda√ß√£o deste artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode ser realizado aqui</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433800/">https://habr.com/ru/post/pt433800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433788/index.html">Neg√≥cio Seguro e Novas Revis√µes Freelancers</a></li>
<li><a href="../pt433790/index.html">Modelos avan√ßados de constru√ß√£o em v√°rios est√°gios</a></li>
<li><a href="../pt433792/index.html">Scripts de shell no Ansible</a></li>
<li><a href="../pt433796/index.html">Como o Homo Sapiens conquistou o mundo. Habilidades de comunica√ß√£o e negocia√ß√£o</a></li>
<li><a href="../pt433798/index.html">HomeKit e ioBroker Vamos fazer amigos em casa</a></li>
<li><a href="../pt433802/index.html">Como e por que vencemos a faixa de Big Data no Urban Tech Challenge Hackathon</a></li>
<li><a href="../pt433804/index.html">Redes de densidade de mistura</a></li>
<li><a href="../pt433806/index.html">Quando o arquivo online esquece</a></li>
<li><a href="../pt433808/index.html">5 erros mais comuns que os programadores cometem na entrevista</a></li>
<li><a href="../pt433810/index.html">Uma abordagem orientada a problemas para projetos de marketing na Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>