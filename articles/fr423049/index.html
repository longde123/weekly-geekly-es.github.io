<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚖️ ♻️ ✋🏽 Processus d'apprentissage sous Linux 🤬 🌲 🛅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je voudrais parler du chemin de vie des processus dans la famille Linux OS. En théorie et en exemples, je vais regarder comment les ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Processus d'apprentissage sous Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423049/"><img src="https://habrastorage.org/webt/w9/tj/yz/w9tjyz5nyynb4zwy2kiikc0ckec.png"><br>  Dans cet article, je voudrais parler du chemin de vie des processus dans la famille Linux OS.  En théorie et en exemples, je vais regarder comment les processus naissent et meurent, un petit discours sur la mécanique des appels et des signaux du système. <br><br>  Cet article est plus destiné aux débutants en programmation système et à ceux qui veulent simplement en savoir un peu plus sur le fonctionnement des processus sous Linux. <br><a name="habracut"></a><br>  Tout ce qui est écrit ci-dessous s'applique à Debian Linux avec le noyau 4.15.0. <br><br><h2>  Table des matières </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Attributs de processus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cycle de vie du processus</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Naissance de processus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">État prêt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le statut est «en cours d'exécution»</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Réincarnation dans un autre programme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">État en attente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Statut d'arrêt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Achèvement du processus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'état des "zombies"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oubli</a> </li></ol></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Remerciements</a> </li></ol><br><a name="intro"></a><h2>  Présentation </h2><br>  Le logiciel système interagit avec le cœur du système via des fonctions spéciales - les appels système.  Dans de rares cas, il existe une autre API, par exemple, procfs ou sysfs, réalisée sous la forme de systèmes de fichiers virtuels. <br><br><a name="definition"></a><h2>  Attributs de processus </h2><br>  Le processus dans le noyau est présenté simplement comme une structure avec de nombreux champs (la définition de la structure peut être lue <a href="" rel="nofollow">ici</a> ). <br>  Mais puisque l'article est consacré à la programmation système, et non au développement du noyau, nous sommes quelque peu abstraits et nous concentrons simplement sur les domaines importants du processus pour nous: <br><br><ul><li>  Identifiant du processus (pid) </li><li>  Descripteurs de fichiers ouverts (fd) </li><li>  Gestionnaires de signaux </li><li>  Répertoire de travail actuel (cwd) </li><li>  Variables d'environnement (environ) </li><li>  Code retour </li></ul><br><a name="lifecycle"></a><h2>  Cycle de vie du processus </h2><br><img src="https://habrastorage.org/webt/dw/ru/5n/dwru5nbeoag7imroc_ki1qa9gba.png"><br><br><a name="fork"></a><h3>  Naissance de processus </h3><br>  Un seul processus dans le système est né d'une manière spéciale - <code>init</code> - il est généré directement par le noyau.  Tous les autres processus apparaissent en dupliquant le processus en cours à l'aide de l'appel système <code>fork(2)</code> .  Après l'exécution de <code>fork(2)</code> , nous obtenons deux processus presque identiques, à l'exception des points suivants: <br><br><ol><li>  <code>fork(2)</code> renvoie le PID de l'enfant au parent, 0 est retourné à l'enfant; </li><li>  L'enfant modifie le PPID (Parent Process Id) en PID du parent. </li></ol><br>  Une fois <code>fork(2)</code> exécuté, toutes les ressources du processus enfant sont une copie des ressources du parent.  La copie d'un processus avec toutes les pages de mémoire allouées coûte cher, donc le noyau Linux utilise la technologie Copy-On-Write. <br>  Toutes les pages dans la mémoire du parent sont marquées en lecture seule et deviennent accessibles à la fois au parent et à l'enfant.  Dès que l'un des processus modifie les données sur une page particulière, cette page ne change pas, mais la copie est déjà copiée et modifiée.  Dans ce cas, l'original est «délié» de ce processus.  Dès que l'original en lecture seule reste «lié» à un seul processus, la page est réaffectée au statut de lecture-écriture. <br><br><div class="spoiler">  <b class="spoiler_title">Un exemple d'un simple programme inutile avec fork (2)</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child printf("my pid = %i, returned pid = %i\n", getpid(), pid); break; default: // Parent printf("my pid = %i, returned pid = %i\n", getpid(), pid); break; } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out my pid = 15594, returned pid = 15595 my pid = 15595, returned pid = 0</code> </pre><br></div></div><br><a name="ready"></a><h3>  État prêt </h3><br>  Immédiatement après l'exécution, <code>fork(2)</code> passe à l'état prêt. <br>  En fait, le processus met en file d'attente et attend que le planificateur dans le noyau laisse le processus s'exécuter sur le processeur. <br><br><a name="running"></a><h3>  Le statut est «en cours d'exécution» </h3><br>  Dès que le planificateur a mis le processus à exécution, l'état «en cours» a commencé.  Le processus peut exécuter toute la période proposée (quantique) de temps, ou il peut céder la place à d'autres processus à l'aide de l'exportation du système <code>sched_yield</code> . <br><br><a name="exec"></a><h3>  Réincarnation dans un autre programme </h3><br>  Certains programmes implémentent une logique dans laquelle le processus parent crée un enfant pour résoudre un problème.  Dans ce cas, l'enfant résout un problème spécifique et le parent délègue uniquement des tâches à ses enfants.  Par exemple, un serveur Web avec une connexion entrante crée un enfant et lui passe le traitement de connexion. <br>  Cependant, si vous devez exécuter un autre programme, vous devez recourir à l'appel système <code>execve(2)</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> envp[])</span></span></span></span>;</code> </pre><br>  ou la bibliothèque appelle <code>execl(3), execlp(3), execle(3), execv(3), execvp(3), execvpe(3)</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* (char *) NULL */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execlp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* (char *) NULL */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*, (char *) NULL, char * const envp[] */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execvp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execvpe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> envp[])</span></span></span></span>;</code> </pre><br>  Tous les appels ci-dessus exécutent le programme, dont le chemin d'accès est indiqué dans le premier argument.  En cas de succès, le contrôle est transféré au programme chargé et n'est pas retourné à celui d'origine.  Dans ce cas, le programme chargé possède tous les champs de la structure du processus, à l'exception des descripteurs de fichiers marqués <code>O_CLOEXEC</code> , ils seront fermés. <br><br>  Comment ne pas se perdre dans tous ces défis et choisir le bon?  Il suffit de comprendre la logique de nommage: <br><br><ul><li>  Tous les appels commencent par <code>exec</code> </li><li>  La cinquième lettre définit le type d'argument passant: <br><ul><li>  <b>l</b> signifie <b>liste</b> , tous les paramètres sont passés comme <code>arg1, arg2, ..., NULL</code> </li><li>  <b>v</b> signifie <b>vecteur</b> , tous les paramètres sont passés dans un tableau à terminaison nulle; </li></ul></li><li>  La lettre <b>p</b> , qui signifie <b>chemin</b> , peut suivre.  Si l'argument de <code>file</code> commence par un caractère autre que "/", le <code>file</code> spécifié est recherché dans les répertoires répertoriés dans la variable d'environnement PATH </li><li>  Le dernier peut être la lettre <b>e</b> , indiquant <b>environ</b> .  Dans de tels appels, le dernier argument est un tableau terminé par null de chaînes terminées par null de la forme <code>key=value</code> - variables d'environnement qui seront transmises au nouveau programme. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Exemple d'appel à / bin / cat --help via execve</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { char* args[] = { "/bin/cat", "--help", NULL }; execve("/bin/cat", args, environ); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out Usage: /bin/cat [OPTION]... [FILE]... Concatenate FILE(s) to standard output. * *</code> </pre><br></div></div><br>  La famille d'appels <code>exec*</code> vous permet d'exécuter des scripts avec des droits d'exécution et en commençant par une séquence de shebangs (#!). <br><br><div class="spoiler">  <b class="spoiler_title">Un exemple d'exécution d'un script avec un PATH usurpé à l'aide d'execle</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { char* e[] = {"PATH=/habr:/rulez", NULL}; execle("/tmp/test.sh", "test.sh", NULL, e); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash echo $0 echo $PATH $ gcc test.c &amp;&amp; ./a.out /tmp/test.sh /habr:/rulez</span></span></code> </pre><br></div></div><br>  Il existe une convention qui implique que argv [0] correspond aux arguments nuls des fonctions de la famille exec *.  Cependant, cela peut être violé. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple lorsque le chat devient chien en utilisant execlp</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { execlp("cat", "dog", "--help", NULL); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out Usage: dog [OPTION]... [FILE]... * *</code> </pre><br></div></div><br>  Un lecteur curieux peut remarquer qu'il y a un nombre dans la signature de la fonction <code>int main(int argc, char* argv[])</code> - le nombre d'arguments, mais rien de ce genre n'est transmis à la famille de fonctions <code>exec*</code> .  Pourquoi?  Parce que lorsque le programme démarre, le contrôle n'est pas immédiatement transféré au principal.  Avant cela, certaines actions définies par la glibc sont effectuées, y compris le comptage de l'argc. <br><br><a name="waiting"></a><h3>  État en attente </h3><br>  Certains appels système peuvent prendre du temps, comme les E / S.  Dans de tels cas, le processus passe dans un état «en attente».  Dès que l'appel système est terminé, le noyau mettra le processus à l'état «prêt». <br>  Sous Linux, il existe également un état «d'attente» dans lequel le processus ne répond pas aux signaux d'interruption.  Dans cet état, le processus devient "indestructible" et tous les signaux entrants restent en ligne jusqu'à ce que le processus quitte cet état. <br>  Le noyau lui-même choisit dans quel état transférer le processus.  Le plus souvent, les processus qui demandent des E / S sont à l'état "en attente (sans interruption)".  Cela est particulièrement visible lorsque vous utilisez un disque distant (NFS) avec un Internet peu rapide. <br><br><a name="stopped"></a><h3>  Statut d'arrêt </h3><br>  Vous pouvez suspendre un processus à tout moment en lui envoyant un signal SIGSTOP.  Le processus entrera dans un état «arrêté» et y restera jusqu'à ce qu'il reçoive un signal pour continuer à travailler (SIGCONT) ou mourir (SIGKILL).  Les signaux restants seront mis en file d'attente. <br><br><a name="exit"></a><h3>  Achèvement du processus </h3><br>  Aucun programme ne peut s'arrêter.  Ils ne peuvent demander cela au système qu'avec l' <code>_exit</code> système <code>_exit</code> ou être interrompus par le système en raison d'une erreur.  Même lorsque vous retournez un nombre à partir de <code>main()</code> , <code>_exit</code> est toujours implicitement appelé. <br>  Bien que l'argument de l'appel système soit int, seul l'octet de poids faible du numéro est pris comme code retour. <br><br><a name="zombie"></a><h3>  L'état des "zombies" </h3><br>  Immédiatement après la fin du processus (qu'il soit correct ou non), le noyau écrit des informations sur la fin du processus et le met dans l'état «zombie».  En d'autres termes, un zombie est un processus terminé, mais sa mémoire est toujours stockée dans le noyau. <br>  De plus, c'est le deuxième état dans lequel le processus peut ignorer en toute sécurité le signal SIGKILL, car il ne peut pas mourir à nouveau. <br><br><a name="wait"></a><h3>  Oubli </h3><br>  Le code retour et la raison de l'achèvement du processus sont toujours stockés dans le noyau et doivent être extraits de là.  Pour ce faire, vous pouvez utiliser les appels système appropriés: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> wait(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *wstatus); <span class="hljs-comment"><span class="hljs-comment">/*  waitpid(-1, wstatus, 0) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> waitpid(<span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> pid, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *wstatus, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> options);</code> </pre><br>  Toutes les informations sur la fin du processus s'inscrivent dans le type de données int.  Les macros décrites dans la page de <code>waitpid(2)</code> sont utilisées pour obtenir le code retour et la raison de l'arrêt du programme. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de bonne exécution et réception d'un code retour</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child return 13; default: { // Parent int status; waitpid(pid, &amp;status, 0); printf("exit normally? %s\n", (WIFEXITED(status) ? "true" : "false")); printf("child exitcode = %i\n", WEXITSTATUS(status)); break; } } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> normally? <span class="hljs-literal"><span class="hljs-literal">true</span></span> child exitcode = 13</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exemple d'achèvement incorrect</b> <div class="spoiler_text"><br>  Passer argv [0] comme NULL entraîne un plantage. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child execl("/bin/cat", NULL); return 13; default: { // Parent int status; waitpid(pid, &amp;status, 0); if(WIFEXITED(status)) { printf("Exit normally with code %i\n", WEXITSTATUS(status)); } if(WIFSIGNALED(status)) { printf("killed with signal %i\n", WTERMSIG(status)); } break; } } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out killed with signal 6</code> </pre><br></div></div><br>  Il y a des moments où un parent se termine plus tôt que l'enfant.  Dans de tels cas, <code>init</code> deviendra le parent de l'enfant et il utilisera l'appel <code>wait(2)</code> le moment venu. <br><br>  Une fois que le parent a pris des informations sur la mort de l’enfant, le noyau efface toutes les informations sur l’enfant afin qu’un autre processus prenne bientôt sa place. <br><br><a name="thanks"></a><h2>  Remerciements </h2><br>  Merci à Sasha «Al» pour l'édition et l'aide dans la conception; <br><br>  Merci à Sasha "Reisse" pour les réponses claires aux questions difficiles. <br><br>  Ils ont enduré l'inspiration qui m'a attaqué et le déluge de mes questions qui m'a attaqué. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423049/">https://habr.com/ru/post/fr423049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423039/index.html">Nous faisons l'authentification Web via la blockchain</a></li>
<li><a href="../fr423041/index.html">CD-ROM Bizarre Story Super NES</a></li>
<li><a href="../fr423043/index.html">En raison d'une vulnérabilité du système de protection des véhicules électriques Tesla, une voiture peut être volée en quelques secondes</a></li>
<li><a href="../fr423045/index.html">Quelle imprimante 3D choisir? Revue vidéo 3Dtool</a></li>
<li><a href="../fr423047/index.html">Nous réservons les systèmes informatiques à un prix raisonnable</a></li>
<li><a href="../fr423051/index.html">La lutte pour les ressources, partie 1: les bases des groupes de contrôle</a></li>
<li><a href="../fr423053/index.html">Structurer et lire uniquement: comment éviter la dégradation des performances</a></li>
<li><a href="../fr423055/index.html">Analystes de Wall Street: «Apple nous a fait manger nos chapeaux»</a></li>
<li><a href="../fr423057/index.html">Python refuse également partiellement les termes maître / esclave</a></li>
<li><a href="../fr423059/index.html">Mieux qu'ils ne le disent: trois éléments essentiels pour que le prochain MacBook devienne l'un des meilleurs ordinateurs portables d'Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>