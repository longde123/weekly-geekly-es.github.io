<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¸ğŸ¾ ğŸ‘¼ğŸ¼ ğŸ“‡ Cepat Fungsional ğŸš… ğŸ‘©â€ğŸ“ ğŸ”º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang menyatukan "currying", "monads", "tipe data aljabar"? Bukan hanya fakta bahwa beberapa pengembang berusaha mengelak dari kata-kata ini, tetap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cepat Fungsional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462121/">  <em>Apa yang menyatukan "currying", "monads", "tipe data aljabar"?</em>  <em>Bukan hanya fakta bahwa beberapa pengembang berusaha mengelak dari kata-kata ini, tetapi juga pemrograman fungsional.</em>  <em>Di bawah bimbingan Yevgeny Elchev yang cermat, kami terjun ke paradigma fungsional dan memahami hampir semua hal.</em>  <em>Jangan takut sebelumnya, jangan ragu untuk membaca transkrip podcast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsCast</a> edisi kesepuluh.</em> <br><br><img src="https://habrastorage.org/webt/hq/lv/vo/hqlvvoaeah9ruqamawgdcwrtwbk.png"><br><a name="habracut"></a><br>  <strong>Daniil Popov:</strong> Halo semuanya.  Hari ini, tamu kami adalah Evgeny Elchev dari Krasnoyarsk yang cerah.  Eugene, katakan padaku apa yang kamu lakukan dan bagaimana kamu sampai pada pemrograman fungsional? <br><br>  <strong>Evgeny Elchev:</strong> Halo semuanya.  Saya seorang pengembang iOS di Redmadrobot, seperti orang lain, saya melukis tombol, kadang-kadang saya menulis logika bisnis. <br><br>  Saya pertama kali berkenalan dengan pemrograman fungsional melalui artikel.  Saya, tidak mengerti maksudnya, berpikir itu semacam pemrograman prosedural, tanpa kelas.  Ketika saya membaca salah satu artikel lebih dekat, saya menyadari bahwa saya salah dan mulai menggali.  Ini bukan untuk mengatakan bahwa saya baru saja <strong>datang</strong> ke pemrograman fungsional, karena pengikut sejati akan meletakkan tulang mereka untuk itu dan menulis di Haskell, menggunakan monad sedapat mungkin.  Saya hanya terjun dan menggunakannya hanya dalam produksi. <br><br>  <strong>Daniil Popov:</strong> Jadi, monad sudah pergi. <br><br>  <strong>Evgeny Elchev:</strong> Sudah sulit? <br><br>  <strong>Daniil Popov:</strong> Saya mencoba untuk pergi dengan cara yang sama, tetapi saya membuka artikel, melihat kata-kata "currying", "monad" dan segera menutupnya, berpikir bahwa saya belum layak.  Apakah saya punya kesempatan? <br><br>  <strong>Evgeny Elchev:</strong> Tentu saja.  Anda mungkin tidak tahu ini sama sekali. <br><br><h2>  Dengan kata sederhana tentang fungsionalisme </h2><br>  <strong>Daniil Popov:</strong> Mari kita berikan definisi sederhana bagi mereka yang belum pernah mendengar tentang paradigma fungsional. <br><br>  <strong>Evgeny Elchev:</strong> Semua orang memahami paradigma dengan cara mereka sendiri.  Jika kita mengambil penjelasan dari Wikipedia, ini adalah penggunaan fungsi matematika, di mana seluruh program ditafsirkan sebagai fungsi matematika. <br><br><blockquote>  Pendekatan fungsional (FP) adalah ketika Anda menggunakan fungsi dalam pekerjaan Anda yang hanya memiliki argumen input dan nilai output.  Jika seluruh program terdiri dari fungsi-fungsi seperti itu, maka ini adalah program fungsional. </blockquote><br>  <strong>Daniil Popov:</strong> OOP adalah kelanjutan logis dari pemrograman prosedural yang biasa dan memecahkan masalah enkapsulasi data di kelas.  Masalah apa yang harus dipecahkan pemrograman fungsional? <br><br>  <strong>Evgeny Elchev:</strong> Matematikawan menemukan pemrograman fungsional.  Para lelaki berkumpul dan memutuskan untuk membuat paradigma di mana semuanya bisa dibuktikan.  Ada kode, belum diluncurkan, tapi kami akan buktikan semuanya.  Poin mana pun dari program ini dapat dihitung, dengan memahami di mana kita akan datang ketika kita mengizinkan beberapa tindakan. <br><br>  Kedengarannya abstrak, jadi mari kita lihat contoh fungsi murni.  Kami menulis fungsi penjumlahan yang membutuhkan dua argumen, meneruskan 2 dan 3 untuk itu, mendapatkan 5, dan kami dapat membuktikannya.  Itu selalu benar.  Jika seluruh program kami terdiri dari fungsi-fungsi seperti itu, maka itu semua bisa dibuktikan. <br><br>  Saat membuat bahasa, fungsi dasar mulai dilewatkan, dan fitur tambahan muncul: lambdas, fungsi tingkat tinggi, monad, monoids. <br><br><blockquote>  Paradigma fungsional tidak menyelesaikan satu masalah, itu adalah keinginan yang sama untuk menulis kode yang baik sesederhana mungkin sehingga program stabil dan mudah dipelihara. </blockquote><br>  Jika Anda melihat lebih dekat, banyak hal yang kami gunakan dalam OOP tercermin dalam pendekatan fungsional.  Ada kelas dalam OPP yang merangkum satu set bidang.  Dalam FP, ini juga bisa dilakukan menggunakan kelas tipe.  Seperti Vitaly Bragilevsky suka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> : "Jika Anda melihat tablet di mana data berjalan di sepanjang garis dan kolom fungsi, maka FI berjalan di sepanjang kolom, OOP berjalan di sepanjang garis."  Itu saja. <br><br>  <strong>Daniil Popov:</strong> Bagaimana kaitan FI dengan paradigma lain?  Bisakah saya menulis secara fungsional di OOP?  Bagaimana mencampuradukkan paradigma, dan apakah itu masuk akal? <br><br>  <strong>Evgeny Elchev:</strong> Paradigma ini terbatas pada fakta bahwa Anda menulis fungsi dengan data.  Salah satu fitur AF adalah tidak adanya status variabel.  Jika data Anda adalah kelas, maka tidak ada masalah.  Jika kelas sepenuhnya tidak dapat diubah, maka itu dapat digunakan.  Kelas hanyalah tipe, seperti string atau angka, hanya lebih kompleks, terdiri dari beberapa nilai. <br><br>  <strong>Daniil Popov:</strong> Anda mengatakan sebelumnya bahwa Anda dapat membuktikan kebenaran matematis suatu program jika Anda menulisnya secara fungsional secara eksklusif.  Kemudian lelucon "kompilasi - karya" untuk bahasa fungsional tidak lagi menjadi lelucon, bukan? <br><br>  <strong>Evgeny Elchev:</strong> Jika Anda melihat kesalahan I / O, maka ya.  Sebelumnya, pemrogram berjuang dengan masalah: terhubung ke jaringan, tidak ada jaringan, kembali nill, dan semuanya jatuh.  Untuk solusinya, cara termudah adalah memeriksa apa yang datang - tidak ada / tidak ada, tetapi karena ada risiko bahwa tidak semuanya diperhitungkan, program dapat dikompilasi dan macet. <br><br>  Dalam bahasa modern, ini diputuskan.  Di Haskell, Anda dapat menulis sebuah program yang akan bekerja dan tidak macet, tetapi tidak ada yang akan mengatakan seberapa benar kerjanya.  Tentu saja, ada tipe yang ketat, dan Anda tidak dapat membuat kesalahan dengan menambahkan nomor ke string, tetapi Anda selalu dapat meninggalkan bug dalam aplikasi, dan itu akan berhasil. <br><br><h2>  Tempat Pendekatan Fungsional di Swift </h2><br>  <strong>Alexei Kudryavtsev:</strong> Berapa banyak yang bisa Swift sebut sebagai bahasa fungsional? <br><br>  <strong>Evgeny Elchev:</strong> Itu mungkin.  Fungsionalitas diposisikan sebagai stateless, tetapi Anda dapat menulis di Swift menghindari status tersebut.  Pada saat yang sama, Swift tidak sama dengan menulis di bawah iOS, di mana ada status di mana-mana.  Tentu saja, di Swift tidak ada instruksi khusus seperti di Haskell, di mana semua fungsi bersih secara default dan kompiler tidak akan memungkinkan Anda untuk mengakses negara dan mengubahnya.  Jika Anda menandai fungsi sebagai "kotor", maka perubahan menjadi tersedia. <br><br>  <strong>Alexei Kudryavtsev:</strong> Ada pengubah murni di Swift kedua atau ketiga, tetapi hanya bertindak pada tingkat kompilasi sehingga nilai global tidak akan berubah.  Anda menulis sesuatu di dalamnya, tetapi kompiler memotong semuanya. <br><br>  <strong>Evgeny Elchev:</strong> Ya, di iOS kompiler tidak akan mengikuti ini.  Semuanya sepenuhnya berada di hati nurani kita: saat Anda menulis, itu akan terjadi. <br><br>  <strong>Alexei Kudryavtsev:</strong> Anda mengatakan bahwa ada banyak status dalam aplikasi iOS, tetapi di mana dan apa yang harus dilakukan dengan mereka jika Anda menulis dengan gaya fungsional? <br><br>  <strong>Evgeny Elchev:</strong> Keadaan paling penting adalah UI, misalnya, bidang masukan.  Praktis tidak ada yang bisa dilakukan dengan mereka.  Anda dapat mencoba abstrak dari mereka, mengumpulkan di satu tempat dan menulis kode sebanyak mungkin tanpa memperhitungkannya.  Misalnya, Anda menulis satu fungsi kotor yang mendapatkan semua data dari UI. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam artikel saya,</a> saya memberikan contoh formulir otorisasi, di mana penting bahwa pengguna memasukkan nama pengguna / kata sandi.  Kami menulis satu fungsi kotor yang mengembalikan struktur dengan data otorisasi, dan kemudian kami menulis kode bersih di atasnya.  Kami mendapat data ini, divalidasi, jika hasilnya valid, kirim permintaan ke server.  Permintaan server juga merupakan fungsi kotor, dan memprosesnya sepenuhnya mungkin bersih.  "Received, parsed" adalah fungsi linier: input ke data, output adalah struktur kita.  Kemudian mereka diubah, difilter dan dapat ditampilkan di layar lagi. <br><br>  <strong>Alexei Kudryavtsev</strong> : Di Haskell, kompiler sangat membantu.  Jika keadaan berasal dari suatu tempat, seluruh rantai panggilan akan dianggap kotor dan Anda harus membungkus semuanya dalam monad.  Jika fungsinya murni, maka caching hasil berhasil - output yang sama selalu merupakan output yang sama.  Di Swift, Anda harus mengimplementasikan peta sendiri dan mencoba mengembalikan hasilnya jika sudah di-cache. <br><br>  <strong>Daniil Popov:</strong> Sebagian besar bahasa modern dianggap multi-paradigmatik dan banyak memiliki fitur fungsional.  Misalnya, di Jawa ada penjelasan khusus untuk antarmuka - <code>@FunctionalInterface</code> , yang mewajibkan pengembang untuk mendefinisikan hanya satu metode di antarmuka, sehingga antarmuka ini dalam bentuk lambdas digunakan dalam seluruh kode.  Ketika Anda menambahkan metode kedua atau menghapus yang sudah ada, kompiler akan mulai bersumpah bahwa ia tidak lagi menjadi antarmuka fungsional.  Apakah Swift, terlepas dari platform iOS, memiliki fitur fungsional seperti itu? <br><br>  <strong>Evgeny Elchev:</strong> Sulit bagi saya untuk memahami apa yang dilakukan penjelasan seperti itu di Jawa.  Jika Anda bermaksud mengimplementasikan antarmuka ini ke kelas, dan kemudian Anda hanya menerapkan satu metode, maka tidak ada batasan seperti itu di Swift.  Anda bisa membuat typealias, beri nama dan menggunakannya sebagai tipe fungsi sebagai tipe argumen, tipe variabel untuk menetapkan penutupan.  Anda dapat mendefinisikan batasan - argumen penutupan input dan output.  Fungsi tingkat tinggi sendiri yang dapat ditutup adalah polimorfisme, dan di Swift Anda dapat membangun polimorfisme pada tipe, tidak terbatas pada objek. <br><br>  Tapi saya tidak tahu hal-hal fungsional spesifik.  Dulu ada kari di Swift pertama, tapi itu terputus.  Sekarang kita dapat menulis fungsi untuk menjelajah diri kita sendiri, atau menulis fungsi sehingga mengembalikan satu sama lain, tetapi ini tidak sepenuhnya benar. <br><br><blockquote>  Kami tidak memiliki functors atau monad kotak.  Mereka bahkan tidak bisa ditulis.  Fitur-fitur baru di Swift 5.1 akan membantu untuk melakukan ini, tetapi saya mencoba menulis kode seperti itu, dan xCode jatuh. </blockquote><br>  Pada prinsipnya, di Swift, jika Anda mau, mudah untuk melakukan semuanya sendiri.  Sudah ada monad opsional di luar kotak (di Haskell - mungkin).  Dia memiliki peta dan peta datar untuk membangun komputasi linier. <br><br>  Swift memiliki pencocokan pola yang kuat.  Switch, yang ada di hampir setiap bahasa dan dalam banyak kasus mengaitkan integer dengan unit, dapat memetakan variabel ke pola tertentu, rentang, jenis, ekstrak nilai dari tipe terkait.  Ada carthage - Anda membuat tipe baru, memasukkan beberapa lainnya ke dalamnya.  Berdasarkan mereka, Anda juga dapat melakukan pencocokan pola.  Ada enumerasi yang dapat membatasi jenis, mengikat jenis yang terkait dengannya. <br><br>  <strong>Alexei Kudryavtsev: Saya</strong> akan mengklarifikasi bahwa tipe terkait mirip dengan kelas yang disegel Kotlin.  Ini adalah enum di dalam case di mana Anda dapat menempatkan nilai terikat.  Sebagai gantinya, Anda dapat menulis: ini masalahnya, perluas, di dalam objek.  Misalnya, kasus pengguna dan perusahaan dengan objek yang sesuai dapat berupa enum dan dapat diaktifkan.  Hanya kelas yang disegel yang bisa diperluas, dan sakelar terbatas. <br><br><h3>  Mengapa seorang mobilis membutuhkan fungsionalisme? </h3><br>  <strong>Daniil Popov:</strong> Bagaimana pendekatan fungsional berguna untuk pengembangan ponsel?  Apakah ada masalah yang dia selesaikan? <br><br>  <strong>Evgeny Elchev:</strong> Tidak ada masalah khusus yang dapat diselesaikan dengan tepat dengan bantuan pemrograman fungsional. <br><br><blockquote>  Yang paling penting adalah bahwa mengikuti prinsip-prinsip ini, bahkan jika itu tidak berhasil, kita harus meninggalkan kondisinya, karena itu adalah rasa sakit utama. </blockquote><br>  Dengan mengabaikannya, Anda membuat kode Anda lebih mudah dimengerti.  Saya tidak mengatakan bahwa akan ada lebih sedikit kesalahan, karena ini setidaknya harus diukur.  Namun, ketika Anda mulai mengimplementasikan sesuatu, kode itu berubah.  Sering terjadi bahwa Anda melihat kode dan segala sesuatu di dalamnya adalah kasusnya, tetapi Anda mulai menulis ulang, bertukar, menghapus yang tidak perlu dan lebih mudah dibaca. <br><br><blockquote>  Mengikuti paradigma fungsional, Anda mendapatkan sumber inspirasi tambahan. </blockquote><br>  <strong>Daniil Popov:</strong> Jika saya mulai menulis kelas yang tidak dapat diubah dalam bahasa OOP dan menggunakan metode yang tidak dapat diubah, dapatkah saya mengatakan bahwa saya menulis secara fungsional? <br><br>  <strong>Evgeny Elchev:</strong> Ya, saat Anda mulai melihat pro.  Semakin mudah untuk menguji metode karena kurangnya negara global, lebih mudah untuk menyusun rantai perhitungan dari metode. <br><br>  <strong>Daniil Popov:</strong> Dalam artikel Anda, Anda menjelaskan apa fungsi murni dan efek sampingnya.  Anda memberi contoh dengan penjumlahan, di mana fungsinya juga memodifikasi keadaan eksternal.  Masalahnya adalah ketika Anda membaca kode seperti itu, sulit untuk mengingat semua perubahan: Anda perlu melihat variabel global ini, siapa lagi yang membacanya, siapa lagi yang menulis kepadanya apa yang bisa terjadi.  Tetapi pendekatan fungsional memungkinkan Anda untuk tetap berada di arus, tidak pergi ke kelas tetangga, Anda hanya membaca kode. <br><br>  <strong>Alexei Kudryavtsev:</strong> Jika Anda menggunakan bahasa fungsional, maka di satu sisi lebih mudah bagi Anda untuk menulis kode, tetapi di sisi lain, Anda harus memahami jenis monad Anda sekarang. <br><br>  <strong>Evgeny Elchev:</strong> Ya, tetapi ketika Anda mulai menulis semuanya pada fungsi murni, masalah lain muncul.  Misalnya, cara membangun rantai perhitungan yang panjang.  Dalam gaya yang biasa, tanpa memikirkannya, Anda dengan mudah membuang data yang sebelumnya tidak ada di sana.  Dalam pendekatan fungsional, ini tidak dapat dilakukan: Anda harus memutuskan rantai, hubungkan semua perhitungan yang digunakan dalam beberapa metode ke negara.  Anda harus terbiasa dengannya. <br><br>  Di sisi lain, tidak seperti kelas di OPP, yang membuat kode mengeras dan sulit untuk disusun, fungsi bisa lebih fleksibel.  Anda dapat menulis satu fungsi, menambah kebebasan dengan bantuan penutupan, membuang fungsi-fungsi tersebut dan menggabungkannya ke dalam rantai. <br><br>  <strong>Alexei Kudryavtsev:</strong> Ini mirip dengan ideologi Unix: ada bash, terminal dan Anda dapat mentransfer data dari program kecil yang melakukan satu tindakan kecil ke yang lain. <br><br>  <strong>Daniil Popov:</strong> Ini mengingatkan saya pada pendekatan Rx, di mana mereka menulis rantai raksasa. <br><br>  <strong>Evgeny Elchev:</strong> Anda berdua benar.  Dan Unix-way adalah tentang itu, dan Rx adalah perpaduan dari gagasan pengikatan dan reaktivitas.  Dalam FP, kami mengikat ke sumber acara dan dalam rantai perhitungan kami mengubahnya, mengikat hasilnya ke keadaan akhir. <br><br>  <strong>Daniil Popov:</strong> Apakah bahasa multi-paradigma bagus, betapa nyaman dan bermanfaatnya, bahwa bahasa dapat melakukan ini dan itu? <br><br>  <strong>Evgeny Elchev:</strong> Jika Anda benar-benar mengikuti semacam paradigma, akan selalu ada hal-hal yang tidak nyaman untuk dilakukan.  Ada hal-hal yang sulit dicapai dalam gaya fungsional, misalnya, menyimpan keadaan dan membuat cache. <br><br><blockquote>  Ketika dimungkinkan untuk memilih alat yang lebih cocok untuk tugas tertentu - ini keren. </blockquote><br>  Anda dapat membuat kelas, di dalamnya buat beberapa metode dengan gaya fungsional dan atur kode secara ringkas dalam rantai, atau tinggalkan kelas sepenuhnya, buat fungsi yang diperlukan, dan gunakan. <br><br>  The downside adalah bahwa ada dilema pilihan dan semakin banyak pilihan, semakin sulit untuk memilih.  Ini juga menjadi semakin sulit untuk dipahami: semakin banyak opsi, semakin sulit untuk membaca kode. <br><br><h3>  Tentang Monad Jam </h3><br>  <strong>Alexei Kudryavtsev:</strong> Kembali ke fungsionalisme, apa itu monad? <br><br>  <strong>Evgeny Elchev:</strong> Saya akan menyebutnya wadah tempat Anda dapat menggabungkan rantai perhitungan.  Cara paling sederhana adalah sebuah wadah tempat Anda dapat menerapkan fungsi dan mengubahnya menjadi wadah baru dengan nilai yang dimodifikasi. <br><br><blockquote>  Bayangkan kotak di mana stroberi berada, dan ada perangkat yang memungkinkan Anda membuat selai dari stroberi, tetapi Anda tidak bisa memasukkan sekotak stroberi di dalamnya, Anda harus menuangkannya.  Monads - ini adalah hal yang sangat memungkinkan Anda untuk memasukkan kotak ke perangkat. </blockquote><br>  Ini bukan keadaan dalam arti langsung, karena keadaan disimpan secara terpisah, tetapi di sini adalah konteks (kotak) dengan nilai dan Anda berpindah dari satu ke yang lain.  Ini adalah transfer informasi dari satu perhitungan ke perhitungan lainnya. <br><br>  <strong>Alexei Kudryavtsev:</strong> Ternyata dalam pendekatan fungsional, untuk membuat kemacetan, Anda harus masuk ke dalam kotak ... <br><br>  <strong>Evgeny Elchev:</strong> Keindahannya adalah Anda tidak harus naik ke dalam kotak.  Anda bisa melempar kotak. <br><br><h3>  Fungsionalitas untuk elit? </h3><br>  <strong>Daniil Popov:</strong> Ada pendapat bahwa pemrograman fungsional tidak dapat dipraktikkan tanpa gelar doktor dalam matematika.  Apakah ini benar? <br><br>  <strong>Evgeny Elchev:</strong> Ini tidak benar.  Pengetahuan matematika, tentu saja, membuat semuanya lebih baik, tetapi saya lupa matematika setelah lulus dan hidup secara normal.  Sebenarnya, semua ini adalah alat yang diwujudkan dalam bahasa dalam memecahkan masalah tertentu.  Mereka dapat digunakan tanpa mencoba membuktikan secara matematis.  Meskipun Anda akan menyusun persamaan dari sudut pandang matematika, akan lebih cepat dan lebih mudah untuk melemparkan beberapa baris kode dengan mengetik, dan mereka akan bekerja. <br><br>  <strong>Alexei Kudryavtsev:</strong> Seberapa besar hobi untuk pendekatan fungsional mengganggu pengembangan produk?  Jika bagian dari kode sudah ditulis secara fungsional, apakah ada kesulitan dalam bekerja dengannya? <br><br>  <strong>Evgeny Elchev:</strong> Tidak sama sekali.  Jika Anda bukan seorang maniak dan Anda tidak akan menulis ekosistem besar dengan dekorator, maka Anda dapat menggunakan pencocokan pola yang sama. <br><br>  Akan lebih sulit jika Anda ingin beralih ke elemen fungsionalisme baru.  Misalnya, Swift kelima dan hasil monad baru-baru ini muncul, Anda belum pernah menggunakannya sebelumnya, tetapi sekarang Anda memutuskan bahwa semuanya akan ada di sana.  Anda mengambil fungsi kueri ke jaringan dan menulis bahwa hasilnya sekarang adalah hasil (baik data atau kesalahan), dan Anda memutuskan untuk menggabungkan dengan permintaan berikutnya, dan di sana Anda memiliki penutupan terpisah dengan nilai dan kesalahan, dan Anda perlu menulis ulang.  Saya mulai menulis seperti ini di satu tempat, terbangun dua hari kemudian, ketika saya menulis ulang setengah kode, saya juga membuat pembungkus baru untuk perpustakaan untuk diintegrasikan dengan indah. <br><br><h3>  Di mana untuk memulai? </h3><br>  <strong>Daniil Popov:</strong> Apa yang harus dibaca pemula untuk memahami pemrograman fungsional? <br><br>  <strong>Evgeny Elchev:</strong> Kita perlu menggunakan bahasa yang murni fungsional, misalnya, Haskell dan mencobanya dalam praktik.  Anda mengambil buku teks dan melakukan contoh paling sederhana.  Di sini Anda memahami pendekatan - ketika tidak ada untuk, Anda tidak dapat membuat variabel di mana Anda dapat mengubah nilainya.  Secara pribadi, saya pernah mengambil buku "Pelajari Haskell atas nama kebaikan", di mana semuanya dijelaskan dalam bahasa yang sederhana.  Setelah itu, Anda dapat mulai membaca artikel di Internet: tentang bagaimana tampilan monads di Swift, tentang tipe data aljabar.  Beberapa artikel, dan menjadi jelas bahwa ini tidak perlu takut. <br><br>  <strong>Daniil Popov</strong> : Hal yang paling sulit adalah mematahkan paradigma di kepala Anda sendiri. <br><br>  <strong>Evgeny Elchev:</strong> Tidak perlu terjun secara tajam ke pemrograman fungsional.  Banyak orang berpikir bahwa mereka berdua akan duduk dan mulai menulis secara fungsional - ini salah. <br><br>  <strong>Alexei Kudryavtsev:</strong> Hal paling keren yang saya lihat adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://gate.sc/%3Furl%3D">kursus Stepic oleh Haskell dari Denis Moskvin</a> .  Anda mulai dengan menambahkan beberapa angka, dan berakhir dengan membungkus monad dalam monad.  Dan jika Anda ingin benar-benar menghancurkan pikiran Anda, yaitu, buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://gate.sc/%3Furl%3D">"Struktur interpretasi program komputer"</a> adalah kursus di Lisp dari contoh-contoh sederhana hingga apa yang Anda tulis sebagai interpreter Lisp dalam Lisp. <br><br><blockquote>  Jika ketakutan utama fungsionalisme telah berlalu, maka lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Vitaliy Bragilevsky</a> dari spring AppsConf.  Namun, di musim gugur AppsConf kami akan menyentuh topik yang tidak kalah menarik - komunitas iOS menantikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan oleh Daniil Goncharov tentang rekayasa balik Bluetooth</a> , dan pengembang android bersama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Smirnov akan membahas pendekatan saat ini untuk membangun animasi</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462121/">https://habr.com/ru/post/id462121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462111/index.html">Bagaimana kami menguji beberapa basis data time series</a></li>
<li><a href="../id462113/index.html">Lingkungan yang tidak tercela: tidak seorang pun boleh menulis kode kualitas</a></li>
<li><a href="../id462115/index.html">Pasang langit berbintang di WebGL dalam 1009 byte JavaScript</a></li>
<li><a href="../id462117/index.html">Bagaimana Memaksimalkan Nilai Penanganan Kesalahan Produk?</a></li>
<li><a href="../id462119/index.html">Delta Smart City Solutions: Pernahkah Anda bertanya-tanya seberapa hijau sebuah bioskop bisa?</a></li>
<li><a href="../id462125/index.html">10 langkah ke yaml zen</a></li>
<li><a href="../id462127/index.html">Seminar "Untuk dirinya sendiri seorang auditor: audit proyek pusat data dan tes penerimaan", 15 Agustus, Moskow</a></li>
<li><a href="../id462131/index.html">Melalui duri ke permainan mimpi</a></li>
<li><a href="../id462133/index.html">Sekali lagi tentang Siprus, nuansa kehidupan</a></li>
<li><a href="../id462135/index.html">Kemitraan Strategis: Mengapa ServiceNow Bekerja Sama Dengan Penyedia Awan Besar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>