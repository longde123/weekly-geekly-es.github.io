<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕎 👬 👨🏽‍💼 Implementasi ring ring saya di NOR flash 🎯 👨🏾 👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Latar belakang 


 Ada mesin penjual otomatis desain kami sendiri. Di dalam Raspberry Pi dan sedikit pengikat di papan terpisah. Akseptor koin, aksept...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi ring ring saya di NOR flash</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479044/"><h1 id="predystoriya">  Latar belakang </h1><br><p>  Ada mesin penjual otomatis desain kami sendiri.  Di dalam Raspberry Pi dan sedikit pengikat di papan terpisah.  Akseptor koin, akseptor tagihan, terminal bank terhubung ... Program yang ditulis sendiri mengatur semuanya.  Seluruh riwayat pekerjaan ditulis ke majalah pada USB flash drive (MicroSD), yang kemudian dikirim melalui Internet (menggunakan modem USB) ke server, di mana ia ditambahkan ke database.  Informasi penjualan dimuat dalam 1s, ada juga antarmuka web sederhana untuk pemantauan, dll. </p><br><p>  Artinya, majalah itu vital - untuk akuntansi (ada pendapatan, penjualan, dll.), Pemantauan (semua jenis kegagalan dan keadaan force majeure lainnya);  ini, bisa Anda katakan, semua informasi yang kami miliki tentang mesin ini. </p><br><h1 id="problema">  Masalah </h1><br><p>  Flash drive menunjukkan diri mereka sebagai perangkat yang sangat tidak bisa diandalkan.  Mereka gagal dengan keteraturan yang patut ditiru.  Hal ini menyebabkan downtime mesin dan (jika karena alasan tertentu jurnal tidak dapat dikirim secara online) ke kehilangan data. </p><br><p>  <em>Ini bukan pengalaman pertama menggunakan flash drive, sebelum itu ada proyek lain dengan lebih dari seratus perangkat di mana majalah disimpan di USB flash drive, ada juga masalah dengan keandalan, kadang-kadang jumlah kegagalan per bulan adalah puluhan.</em>  <em>Kami mencoba berbagai flash drive, termasuk yang bermerek pada memori SLC, dan beberapa model lebih andal daripada yang lain, tetapi mengganti flash drive tidak menyelesaikan masalah secara radikal.</em> </p><a name="habracut"></a><br><p>  <strong>Perhatian!</strong>  Longrid!  Jika Anda tidak tertarik pada "mengapa," tetapi hanya tertarik pada "bagaimana," Anda dapat langsung menuju <a href="https://habr.com/ru/post/479044/">ke akhir</a> artikel. </p><br><h1 id="reshenie">  Solusi </h1><br><p>  Hal pertama yang terlintas dalam pikiran: tinggalkan MicroSD, masukkan, misalnya, SSD, dan boot darinya.  Secara teori itu mungkin, mungkin, tetapi relatif mahal, dan tidak begitu dapat diandalkan (adaptor USB-SATA ditambahkan; pada SSD anggaran, statistik kegagalan juga tidak bahagia). </p><br><p>  HDD USB juga tidak terlihat solusi yang sangat menarik. </p><br><p>  Oleh karena itu, kami sampai pada opsi ini: tinggalkan unduhan dari MicroSD, tetapi gunakan dalam mode read-only, dan simpan log operasi (dan informasi lain yang unik untuk perangkat keras tertentu - nomor seri, kalibrasi sensor, dll) di tempat lain. </p><br><p>  Topik read-only FS untuk raspberry telah dipelajari terus-menerus, saya tidak akan membahas detail implementasi dalam artikel ini <em>(tetapi jika ada minat, mungkin saya akan menulis artikel mini tentang topik ini)</em> .  Satu-satunya hal yang ingin saya perhatikan: baik dari pengalaman pribadi maupun dari ulasan yang telah menerapkan peningkatan keandalan, adalah.  Ya, tidak mungkin untuk sepenuhnya menghilangkan kerusakan, tetapi sangat mungkin untuk mengurangi frekuensi mereka secara signifikan.  Ya, dan kartu menjadi satu, yang sangat menyederhanakan penggantian untuk staf pemeliharaan. </p><br><h2 id="apparatnaya-chast">  Perangkat keras </h2><br><p>  Tidak ada keraguan tentang pilihan jenis memori - NOR Flash. <br>  Argumen: </p><br><ul><li>  koneksi sederhana (paling sering SPI bus, pengalaman menggunakan yang sudah ada di sana, sehingga tidak ada masalah "besi" yang diharapkan); </li><li>  harga yang konyol; </li><li>  protokol operasi standar (implementasinya sudah ada di kernel Linux, jika Anda mau, Anda dapat mengambil pihak ketiga, yang juga hadir, atau bahkan menulis sendiri, manfaatnya sederhana); </li><li>  keandalan dan sumber daya: <br>  dari lembar data biasa: data disimpan selama 20 tahun, 100.000 siklus hapus untuk setiap blok; <br>  dari sumber pihak ketiga: BER sangat rendah, dipostulatkan bahwa tidak perlu kode koreksi kesalahan <em>(dalam beberapa makalah ECC untuk NOR dipertimbangkan, tetapi biasanya MLC NOR dimaksudkan di sana, itu terjadi)</em> . </li></ul><br><p>  Mari kita perkirakan persyaratan volume dan sumber daya. </p><br><p>  Saya ingin dijamin untuk menyimpan data selama beberapa hari.  Ini diperlukan agar jika terjadi masalah dengan koneksi, riwayat penjualan tidak hilang.  Kami akan fokus pada 5 hari, selama periode ini <em>(bahkan dengan memperhitungkan akhir pekan dan hari libur),</em> kami dapat menyelesaikan masalah. </p><br><p>  Kami sekarang mengetik sekitar 100kb majalah per hari (3-4 ribu catatan), tetapi lambat laun angka ini bertambah - perinciannya meningkat, acara-acara baru ditambahkan.  Plus, terkadang ada semburan (beberapa sensor mulai melakukan spam dengan positif palsu, misalnya).  Kami akan menghitung 10 ribu catatan 100 byte - megabita per hari. </p><br><p>  Sebanyak 5 MB data bersih (dapat dikompres dengan baik) keluar.  Mereka juga <em>(perkiraan kasar)</em> 1MB data layanan. </p><br><p>  Artinya, kita membutuhkan microchip 8MB jika Anda tidak menggunakan kompresi, atau 4MB jika Anda menggunakannya.  Angka nyata yang cukup untuk jenis memori ini. </p><br><p>  Adapun sumber daya: jika kami merencanakan bahwa seluruh memori akan ditulis ulang tidak lebih dari sekali setiap 5 hari, maka dalam 10 tahun layanan kami mendapatkan kurang dari seribu siklus menulis ulang. <br>  Saya ingat, pabrikan itu menjanjikan seratus ribu. </p><br><div class="spoiler">  <b class="spoiler_title">Sedikit tentang NOR vs NAND</b> <div class="spoiler_text"><p>  Hari ini, tentu saja, memori NAND jauh lebih populer, tetapi untuk proyek ini saya tidak akan menggunakannya: NAND, tidak seperti NOR, tentu memerlukan penggunaan kode koreksi kesalahan, tabel blok buruk, dll., Dan kaki-kaki chip NAND biasanya jauh lebih banyak. </p><br><p>  Kerugian dari NOR meliputi: </p><br><ul><li>  volume kecil (dan, karenanya, harga tinggi per megabyte); </li><li>  nilai tukar rendah (sebagian besar disebabkan oleh fakta bahwa antarmuka serial digunakan, biasanya SPI atau I2C); </li><li>  slow erase (tergantung pada ukuran blok, dibutuhkan dari fraksi detik hingga beberapa detik). </li></ul><br><p>  Sepertinya tidak ada yang penting bagi kami, jadi teruskan. </p></div></div><br><p>  Jika detailnya menarik, chip <a href="https://www.adestotech.com/wp-content/uploads/doc3686.pdf" rel="nofollow">at25df321a</a> dipilih <em>(namun, ini tidak signifikan, ada banyak analog di pasaran yang kompatibel dengan pinout dan sistem perintah; bahkan jika kita ingin meletakkan chip dari pabrikan lain dan / atau volume lainnya, semuanya akan bekerja tanpa mengubah kode)</em> . </p><br><p>  Saya menggunakan driver yang dibangun di kernel Linux, di Raspberry, berkat dukungan overlay pohon perangkat, semuanya sangat sederhana - Anda perlu meletakkan overlay yang dikompilasi di / boot / overlay dan memodifikasi sedikit / boot / config.txt. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh file dts</b> <div class="spoiler_text"><p>  Jujur, saya tidak yakin apa yang ditulis tanpa kesalahan, tetapi berhasil. </p><br><pre><code class="plaintext hljs">/* * Device tree overlay for at25 at spi0.1 */ /dts-v1/; /plugin/; / { compatible = "brcm,bcm2835", "brcm,bcm2836", "brcm,bcm2708", "brcm,bcm2709"; /* disable spi-dev for spi0.1 */ fragment@0 { target = &lt;&amp;spi0&gt;; __overlay__ { status = "okay"; spidev@1{ status = "disabled"; }; }; }; /* the spi config of the at25 */ fragment@1 { target = &lt;&amp;spi0&gt;; __overlay__ { #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; flash: m25p80@1 { compatible = "atmel,at25df321a"; reg = &lt;1&gt;; spi-max-frequency = &lt;50000000&gt;; /* default to false: m25p,fast-read ; */ }; }; }; __overrides__ { spimaxfrequency = &lt;&amp;flash&gt;,"spi-max-frequency:0"; fastread = &lt;&amp;flash&gt;,"m25p,fast-read?"; }; };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Dan baris lain di config.txt</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">dtoverlay=at25:spimaxfrequency=50000000</code> </pre> </div></div><br><p>  Saya akan menghilangkan deskripsi menghubungkan chip ke Raspberry Pi.  Di satu sisi, saya bukan ahli elektronik, di sisi lain, semuanya sepele bahkan bagi saya: microcircuit hanya memiliki 8 kaki, yang mana kami membutuhkan tanah, daya, SPI (CS, SI, SO, SCK);  level bertepatan dengan Raspberry Pi, tidak ada ikatan tambahan yang diperlukan - cukup sambungkan 6 kontak yang ditentukan. </p><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Seperti biasa, perumusan masalah melewati beberapa iterasi, bagi saya sepertinya sudah tiba saatnya berikutnya.  Jadi mari kita berhenti, menyusun apa yang sudah ditulis, dan mengklarifikasi detail yang tersisa di bayangan. </p><br><p>  Jadi, kami memutuskan bahwa log akan disimpan dalam SPI NOR Flash. </p><br><div class="spoiler">  <b class="spoiler_title">Apa itu NOR Flash untuk mereka yang tidak tahu</b> <div class="spoiler_text"><p>  Ini adalah memori non-volatile yang dengannya Anda dapat melakukan tiga operasi: </p><br><ol><li>  Membaca: <br>  Bacaan yang paling umum: kami mengirimkan alamat dan membaca byte yang kami butuhkan; </li><li>  Rekam: <br>  Menulis ke NOR flash terlihat seperti yang biasa, tetapi memiliki satu kekhasan: Anda hanya dapat mengubah 1 ke 0, tetapi tidak sebaliknya.  Misalnya, jika kita memiliki 0x55 di sel memori, maka setelah menulis 0x0f untuk itu, 0x05 sudah akan disimpan di sana <em>(lihat tabel di bawah)</em> ; </li><li>  Hapus: <br>  Tentu saja, kita harus dapat melakukan operasi mundur juga - ubah 0 ke 1, itulah sebabnya operasi hapus ada.  Berbeda dengan dua yang pertama, ia beroperasi bukan dalam byte, tetapi dalam blok (blok hapus minimum dalam rangkaian mikro yang dipilih adalah 4 kb).  Erase menghancurkan seluruh blok dan ini adalah satu-satunya cara untuk mengubah 0 ke 1. Oleh karena itu, ketika bekerja dengan memori flash, Anda sering harus menyelaraskan struktur data ke batas blok hapus. <br>  Rekam dalam NOR Flash: </li></ol><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Data biner </th></tr></thead><tbody><tr><td>  <strong>Apakah</strong> </td><td> <code>01010101</code> </td> </tr><tr><td>  <strong>Direkam</strong> </td><td> <code>00001111</code> </td> </tr><tr><td>  <strong>Telah menjadi</strong> </td><td> <code>00000101</code> </td> </tr></tbody></table></div></div></div><br><p>  Jurnal itu sendiri mewakili urutan catatan panjang variabel.  Panjang rekaman tipikal adalah sekitar 30 byte (walaupun kadang-kadang rekaman beberapa kilobyte kadang terjadi).  <em>Dalam hal ini, kami bekerja dengan mereka seperti seperangkat byte, tetapi, jika Anda tertarik, CBOR digunakan di dalam catatan.</em> </p><br><p>  Selain jurnal, kita perlu menyimpan beberapa informasi "tuning", apakah diperbarui atau tidak: ID perangkat tertentu, kalibrasi sensor, bendera "perangkat dinonaktifkan sementara", dll. <br>  Informasi ini adalah satu set catatan nilai kunci, juga disimpan dalam CBOR. Kami tidak memiliki banyak informasi ini (maksimum beberapa kilobyte), itu jarang diperbarui. <br>  Di masa depan, kita akan menyebutnya konteks. </p><br><p>  Jika Anda ingat di mana artikel ini dimulai, sangat penting untuk memastikan keandalan penyimpanan data dan, jika mungkin, operasi terus-menerus bahkan jika terjadi kegagalan perangkat keras / korupsi data. </p><br><p>  Sumber masalah apa yang bisa dipertimbangkan? </p><br><ul><li>  Matikan selama operasi penulisan / hapus.  Ini dari kategori "terhadap memo tidak ada penerimaan." <br>  Informasi dari <a href="https://electronics.stackexchange.com/questions/225956/what-would-happen-in-case-of-power-outage-during-nor-flash-erase-or-programming" rel="nofollow">diskusi</a> tentang stackexchange: ketika daya dimatikan saat bekerja dengan flash, penghapusan itu (pengaturan ke 1), penulisan itu (pengaturan ke 0) mengarah pada perilaku yang tidak terdefinisi: data dapat ditulis, ditulis sebagian (misalnya, kami mentransfer 10 byte / 80 bit , dan hanya 45 bit yang berhasil direkam), juga dimungkinkan bahwa beberapa bit akan berada dalam keadaan "menengah" (membaca dapat menghasilkan 0 atau 1); </li><li>  Kesalahan memori flash itu sendiri. <br>  BER, meskipun sangat rendah, tidak bisa sama dengan nol; </li><li>  Kesalahan bus <br>  Data yang dikirimkan melalui SPI tidak dilindungi dengan cara apa pun, itu dapat terjadi sebagai kesalahan bit tunggal atau kesalahan sinkronisasi - kehilangan atau penyisipan bit (yang menyebabkan distorsi data besar-besaran); </li><li>  Kesalahan / kegagalan lainnya <br>  Kesalahan dalam kode, Raspberry "gangguan", intervensi alien ... </li></ul><br><p>  Saya merumuskan persyaratan, yang pemenuhannya, menurut pendapat saya, diperlukan untuk memastikan keandalan: </p><br><ul><li>  catatan harus ditulis ke memori flash segera, rekaman tertunda tidak dipertimbangkan; - jika kesalahan telah terjadi, maka harus terdeteksi dan diproses sesegera mungkin; - sistem harus, jika mungkin, pulih dari kesalahan. <br>  <em>(contoh dari kehidupan "sebagaimana mestinya tidak," yang, saya pikir, semua orang bertemu: setelah restart darurat, sistem file "rusak" dan sistem operasi tidak bisa boot)</em> </li></ul><br><h2 id="idei-podhody-razmyshleniya">  Gagasan, Pendekatan, Pikiran </h2><br><p>  Ketika saya mulai memikirkan tugas ini, banyak ide muncul di benak saya, misalnya: </p><br><ul><li>  Gunakan kompresi data </li><li>  Gunakan struktur data yang rumit, misalnya, menyimpan header catatan secara terpisah dari catatan itu sendiri, sehingga jika kesalahan terjadi dalam catatan, Anda dapat membaca sisanya tanpa masalah; </li><li>  gunakan bidang bit untuk mengontrol kelengkapan rekaman saat daya dimatikan; </li><li>  toko checksum untuk semuanya dan segalanya; </li><li>  menggunakan semacam pengkodean koreksi kesalahan. </li></ul><br><p>  Beberapa ide ini digunakan, beberapa memutuskan untuk menolak.  Mari kita mulai. </p><br><h3 id="szhatie-dannyh">  Kompresi data </h3><br><p>  Peristiwa yang kami rekam dalam jurnal itu sendiri cukup sama dan berulang ("melempar koin 5 rubel," "mengklik tombol ubah pengiriman", ...).  Karena itu, kompresi harus cukup efektif. </p><br><p>  Overhead untuk kompresi tidak signifikan (prosesor yang kami miliki cukup kuat, bahkan pada Pi pertama ada satu inti dengan frekuensi 700 MHz, pada model saat ini ada beberapa core dengan frekuensi lebih dari satu gigahertz), kecepatan pertukaran dengan penyimpanan rendah (beberapa megabyte per detik), ukuran rekaman kecil.  Secara umum, jika kompresi akan memengaruhi kinerja, maka hanya positif <em>(sama sekali tidak kritis, hanya menyatakan)</em> .  Plus, kami tidak memiliki embedded yang nyata, tetapi Linux biasa - jadi implementasi seharusnya tidak membutuhkan banyak upaya (cukup tautkan perpustakaan dan gunakan beberapa fungsi darinya). </p><br><p>  Sepotong log diambil dari perangkat yang berfungsi (1,7 MB, 70 ribu catatan) dan untuk permulaannya diperiksa kompresibilitasnya menggunakan gzip, lz4, lzop, bzip2, xz, zstd yang tersedia di komputer. </p><br><ul><li>  gzip, xz, zstd menunjukkan hasil yang serupa (40Kb). <br>  Saya terkejut bahwa xz modis menunjukkan dirinya di sini di tingkat gzip atau zstd; </li><li>  lzip dengan pengaturan default memberikan hasil yang sedikit lebih buruk; </li><li>  lz4 dan lzop menunjukkan hasil yang tidak terlalu baik (150Kb); </li><li>  bzip2 menunjukkan hasil yang sangat baik (18Kb). </li></ul><br><p>  Jadi data terkompresi dengan sangat baik. <br>  Jadi (jika kita tidak menemukan kesalahan fatal) harus ada kompresi!  Hanya karena lebih banyak data akan masuk pada flash drive yang sama. </p><br><p>  Mari kita pikirkan kekurangannya. </p><br><p>  Masalah pertama: kita sudah sepakat bahwa setiap record harus segera di flash.  Biasanya, pengarsipan mengumpulkan data dari aliran input sampai memutuskan bahwa sudah saatnya untuk menulis ke output.  Kita perlu segera mendapatkan blok data terkompresi dan menyimpannya dalam memori non-volatile. </p><br><p>  Saya melihat tiga cara: </p><br><ol><li>  Kompres setiap entri menggunakan kompresi kamus alih-alih algoritma yang dibahas di atas. <br>  Ini adalah opsi yang berfungsi, tetapi saya tidak menyukainya.  Untuk memastikan tingkat kompresi yang lebih atau kurang layak, kamus harus “dipertajam” untuk data tertentu, setiap perubahan akan mengarah pada fakta bahwa tingkat kompresi turun drastis.  Ya, masalahnya diselesaikan dengan membuat versi baru kamus, tetapi ini sakit kepala - kita perlu menyimpan semua versi kamus;  di setiap entri kita perlu menunjukkan versi kamus mana yang dikompres ... </li><li>  Kompres setiap entri dengan algoritme "klasik", tetapi terlepas dari yang lainnya. <br>  Algoritma kompresi yang dipertimbangkan tidak dirancang untuk bekerja dengan catatan ukuran ini (puluhan byte), koefisien kompresi akan jelas kurang dari 1 (yaitu, peningkatan jumlah data, bukan kompresi); </li><li>  Lakukan FLUSH setelah setiap perekaman. <br>  Banyak pustaka kompresi memiliki dukungan untuk FLUSH.  Ini adalah perintah (atau parameter untuk prosedur kompresi), setelah menerima pengarsipan menghasilkan aliran terkompresi sehingga pada dasarnya <strong>semua</strong> data terkompresi yang telah diterima dapat dikembalikan.  Seperti analog <code>sync</code> dalam sistem file atau <code>commit</code> dalam sql. <br>  Yang penting, operasi kompresi selanjutnya akan dapat menggunakan kamus yang terakumulasi dan rasio kompresi tidak akan sebanyak seperti pada versi sebelumnya. </li></ol><br><p>  Saya pikir sudah jelas bahwa saya memilih opsi ketiga, mari kita bahas lebih detail. </p><br><p>  Ada <a href="https://www.bolet.org/~pornin/deflate-flush.html" rel="nofollow">artikel bagus</a> tentang FLUSH di zlib. </p><br><p>  Saya melakukan tes termotivasi berdasarkan artikel, mengambil 70 ribu entri jurnal dari perangkat nyata, dengan ukuran halaman 60Kb <em>(kami akan kembali ke ukuran halaman)</em> : </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Sumber data </th><th>  Kompresi Gzip -9 (tanpa FLUSH) </th><th>  zlib dengan Z_PARTIAL_FLUSH </th><th>  zlib dengan Z_SYNC_FLUSH </th></tr></thead><tbody><tr><td>  <strong>Volume, Kb</strong> </td><td>  1692 </td><td>  40 </td><td>  352 </td><td>  604 </td></tr></tbody></table></div><br><p>  Pada pandangan pertama, harga yang diperkenalkan oleh FLUSH sangat tinggi, tetapi pada kenyataannya kami memiliki pilihan yang buruk - baik untuk tidak mengompres sama sekali, atau untuk mengompres (dan sangat efisien) dengan FLUSH.  Jangan lupa bahwa kami memiliki 70 ribu catatan, redundansi yang diperkenalkan oleh Z_PARTIAL_FLUSH hanya 4-5 byte per rekaman.  Dan rasio kompresi ternyata hampir 5: 1, yang lebih dari hasil yang sangat baik. </p><br><div class="spoiler">  <b class="spoiler_title">Ini mungkin tampak tidak terduga, tetapi sebenarnya Z_SYNC_FLUSH adalah cara yang lebih efisien untuk melakukan FLUSH</b> <div class="spoiler_text"><p>  Dalam hal menggunakan Z_SYNC_FLUSH, 4 byte terakhir dari setiap record akan selalu 0x00, 0x00, 0xff, 0xff.  Dan jika kita mengenal mereka, maka kita tidak dapat menyimpannya, sehingga ukuran totalnya hanya 324Kb. </p><br><p>  Artikel yang saya maksudkan memiliki penjelasan: </p><br><blockquote>  Blok 0 tipe baru dengan konten kosong ditambahkan. <br><br>  Blok tipe 0 dengan konten kosong terdiri dari: <br><ul><li>  header blok tiga-bit; </li><li>  0 hingga 7 bit sama dengan nol, untuk mencapai perataan byte; </li><li>  urutan empat byte 00 00 FF FF. </li></ul><br></blockquote><p>  Seperti yang Anda lihat, di blok terakhir sebelum 4 byte ini berasal dari 3 hingga 10 bit nol.  Namun, praktik telah menunjukkan bahwa nol bit sebenarnya setidaknya 10. </p><br><p>  Ternyata blok data pendek seperti itu biasanya (selalu?) Di-encode menggunakan blok tipe 1 (blok tetap), yang seharusnya berakhir dengan 7 bit nol, jadi kami mendapatkan 10-17 bit nol yang dijamin (dan sisanya akan menjadi nol dengan probabilitas sekitar 50%). </p><br><p>  Jadi, pada data uji, dalam 100% kasus, sebelum 0x00, 0x00, 0xff, 0xff ada satu byte nol, dan lebih dari pada kasus ketiga ada dua nol byte <em>(mungkin faktanya saya menggunakan binari CBOR, dan saat menggunakan teks CBOR JSON akan lebih cenderung memenuhi blok tipe 2 - blok dinamis, masing-masing, blok akan terjadi tanpa tambahan nol byte sebelum 0x00, 0x00, 0xff, 0xff)</em> . </p><br><p>  Total pada data uji yang tersedia dapat memuat kurang dari 250Kb data terkompresi. </p><br><p>  Anda dapat menyimpan sedikit lebih banyak dengan melakukan juggling bits: sekarang kita mengabaikan keberadaan beberapa bit nol di ujung blok, beberapa bit di awal blok juga tidak berubah ... <br>  Tapi kemudian saya membuat keputusan yang kuat untuk berhenti, jika tidak pada kecepatan seperti itu Anda dapat mencapai pengembangan pengarsipan Anda. </p></div></div><br><p>  Secara total, saya mendapat 3-4 byte per catatan dari data pengujian saya, rasio kompresi lebih dari 6: 1.  Jujur, saya tidak mengandalkan hasil seperti itu, menurut saya segala sesuatu yang lebih baik dari 2: 1 sudah merupakan hasil yang membenarkan penggunaan kompresi. </p><br><p>  Semuanya baik-baik saja, tetapi zlib (deflate) masih <del>  kuno </del>  algoritma kompresi yang layak dan sedikit kuno.  Fakta bahwa 32Kb terakhir dari aliran data yang tidak dikompres digunakan sebagai kamus yang terlihat aneh hari ini (yaitu, jika beberapa blok data sangat mirip dengan apa yang ada di arus input 40Kb kembali, itu akan mulai diarsipkan lagi, tetapi tidak akan diarsipkan lagi, tetapi tidak akan lihat entri sebelumnya).  Masuk <del>  modis </del>  Kamus ukuran arsip modern sering diukur dalam megabita daripada kilobyte. </p><br><p>  Jadi kami melanjutkan studi kecil kami tentang arsip. </p><br><p>  Selanjutnya bzip2 diuji (ingat, tanpa FLUSH itu menunjukkan rasio kompresi yang fantastis, hampir 100: 1).  Sayangnya, dengan FLUSH itu menunjukkan dirinya sangat buruk, ukuran data yang dikompresi lebih besar daripada yang tidak terkompresi. </p><br><div class="spoiler">  <b class="spoiler_title">Asumsi saya tentang alasan kegagalan</b> <div class="spoiler_text"><p>  Libbz2 hanya menawarkan satu opsi flush, yang tampaknya membersihkan kamus (mirip dengan Z_FULL_FLUSH di zlib), tidak ada alasan untuk membicarakan semacam kompresi yang efisien. </p></div></div><br><p>  Dan zstd adalah yang terakhir diuji.  Bergantung pada parameternya, kompresnya berada pada level gzip, tetapi jauh lebih cepat, atau gzip lebih baik. </p><br><p>  Sayangnya, dengan FLUSH ia terbukti "tidak terlalu": ​​ukuran data yang dikompresi keluar sekitar 700Kb. </p><br><p>  Saya <a href="https://github.com/facebook/zstd/issues/900" rel="nofollow">mengajukan pertanyaan</a> pada halaman proyek di github, saya mendapat jawaban bahwa perlu menghitung hingga 10 byte data layanan untuk setiap blok data terkompresi, yang dekat dengan hasil, menangkap deflate tidak berfungsi. </p><br><p>  Saya memutuskan untuk menghentikan ini dalam percobaan dengan pengarsip (saya ingatkan Anda bahwa xz, lzip, lzo, lz4 tidak menunjukkan diri pada tahap pengujian tanpa FLUSH, tetapi saya tidak mempertimbangkan algoritma kompresi yang lebih eksotis). </p><br><p>  Kami kembali ke masalah pengarsipan. </p><br><p>  Masalah kedua (seperti yang mereka katakan secara berurutan, tetapi tidak dalam nilainya) - data terkompresi adalah aliran tunggal yang secara konstan mengirim ke bagian sebelumnya.  Jadi, ketika bagian dari data terkompresi rusak, kami tidak hanya kehilangan blok data yang tidak terkompresi yang terkait dengannya, tetapi juga semua yang berikutnya. </p><br><p>  Ada pendekatan untuk memecahkan masalah ini: </p><br><ol><li>  Cegah terjadinya masalah - tambahkan redundansi ke data yang dikompresi, yang akan memungkinkan untuk mengidentifikasi dan memperbaiki kesalahan;  kita akan membicarakan ini nanti; </li><li>  Minimalkan konsekuensi jika terjadi masalah <br>  Kami telah mengatakan sebelumnya bahwa adalah mungkin untuk mengompres setiap blok data secara independen, dan masalahnya akan hilang dengan sendirinya (korupsi data satu blok akan menyebabkan hilangnya data hanya blok ini).  Namun, ini adalah kasus ekstrem di mana kompresi data tidak efisien.  Ekstrem yang berlawanan: gunakan semua 4MB dari sirkuit mikro kami sebagai arsip tunggal, yang akan memberi kami kompresi yang sangat baik, tetapi konsekuensi yang sangat besar jika terjadi kerusakan data. <br>  <em>Ya, kompromi diperlukan dalam hal keandalan.</em>  <em>Tetapi kita harus ingat bahwa kita sedang mengembangkan format penyimpanan data untuk memori non-volatil dengan BER sangat rendah dan periode penyimpanan data yang dinyatakan 20 tahun.</em> </li></ol><br><p>  Dalam percobaan, saya menemukan bahwa kerugian yang terlihat pada tingkat kompresi dimulai pada blok data terkompresi dengan ukuran kurang dari 10Kb. <br>  Telah disebutkan sebelumnya bahwa memori yang digunakan memiliki organisasi halaman, saya tidak melihat alasan mengapa Anda tidak harus menggunakan korespondensi "satu halaman - satu blok data terkompresi". </p><br><p>  Artinya, ukuran halaman wajar minimum adalah 16Kb (dengan margin untuk informasi layanan).  Namun, ukuran halaman sekecil itu memberlakukan batasan signifikan pada ukuran perekaman maksimum. </p><br><p>  Meskipun saya masih tidak mengharapkan catatan unit kilobyte lebih banyak dalam bentuk terkompresi, saya memutuskan untuk menggunakan halaman 32KB (total 128 halaman per chip). </p><br><p>  <strong>Ringkasan:</strong> </p><br><ul><li>  Kami menyimpan data yang dikompres menggunakan zlib (deflate); </li><li>  Untuk setiap catatan, atur Z_SYNC_FLUSH; </li><li>  Untuk setiap catatan terkompresi, kami memotong byte terakhir <em>(misalnya, 0x00, 0x00, 0xff, 0xff)</em> ;  di header menunjukkan berapa banyak byte yang kami potong; </li><li>  Kami menyimpan data dalam halaman 32Kb;  di dalam halaman ada satu aliran data terkompresi;  pada setiap halaman, kami memulai kompresi lagi. </li></ul><br><p>  Dan, sebelum selesai dengan kompresi, saya ingin menarik perhatian pada fakta bahwa kami hanya mendapatkan beberapa byte data tulis, jadi sangat penting untuk tidak mengembang informasi layanan, setiap byte dihitung. </p><br><h3 id="hranenie-zagolovkov-dannyh">  Menyimpan Header Data </h3><br><p>  Karena kita memiliki catatan panjang variabel, kita perlu entah bagaimana menentukan lokasi / batas catatan. </p><br><p>  Saya tahu tiga pendekatan: </p><br><ol><li>  Semua catatan disimpan dalam aliran kontinu, pertama datang header catatan yang berisi panjang, dan kemudian catatan itu sendiri. <br>  Dalam perwujudan ini, header dan data mungkin memiliki panjang variabel. <br>  Bahkan, kami mendapatkan daftar tautan tunggal yang digunakan sepanjang waktu; </li><li>  Header dan catatan sendiri disimpan di aliran terpisah. <br>  Menggunakan header dengan panjang konstan, kami memastikan bahwa kerusakan pada satu header tidak mempengaruhi sisanya. <br>  Pendekatan serupa digunakan, misalnya, dalam banyak sistem file; </li><li>  Catatan disimpan dalam aliran berkelanjutan, batas catatan ditentukan oleh beberapa penanda (simbol / urutan karakter, yang / yang dilarang di dalam blok data).  Jika marker ditemukan di dalam rekaman, maka kami menggantinya dengan urutan tertentu (lepas darinya). <br>  Pendekatan serupa digunakan, misalnya, dalam protokol PPP. </li></ol><br><p>  Saya akan ilustrasikan. </p><br><p>  Opsi 1: <br><img src="https://habrastorage.org/webt/b3/yu/q8/b3yuq8z6elbufkrice2g_vjtuhe.png" alt="Opsi 1"><br>  Semuanya sangat sederhana di sini: mengetahui panjang catatan, kita dapat menghitung alamat header berikutnya.  Jadi kami bergerak melalui tajuk hingga kami bertemu wilayah yang diisi dengan 0xff (wilayah bebas) atau akhir halaman. </p><br><p>  Opsi 2: <br><img src="https://habrastorage.org/webt/kf/qy/_7/kfqy_7qzi7pzmk-g5cqa4r6s75q.png" alt="Opsi 2"><br>  Karena panjang variabel catatan, kami tidak dapat mengatakan sebelumnya berapa banyak catatan (dan karena itu tajuk) per halaman yang kami butuhkan.  Anda dapat menyebarkan tajuk dan data itu sendiri ke halaman yang berbeda, tetapi saya lebih suka pendekatan yang berbeda: kami menempatkan tajuk dan data pada halaman yang sama, namun, tajuk (ukuran konstan) berasal dari awal halaman, dan data (panjang variabel) dari akhir.  Begitu mereka "bertemu" (tidak ada cukup ruang kosong untuk catatan baru) - kami menganggap halaman ini penuh. </p><br><p>  Opsi 3: <br><img src="https://habrastorage.org/webt/-q/u1/qj/-qu1qjmqlcvfi570ovsdy_nzzny.png" alt="Opsi 3"><br>  Tidak perlu menyimpan di header panjang atau informasi lain tentang lokasi data, ada cukup penanda yang menunjukkan batas-batas catatan.  Namun, data harus diproses saat menulis / membaca. <br>  Sebagai penanda, saya akan menggunakan 0xff (yang halamannya diisi setelah dihapus), sehingga area bebas tidak akan diperlakukan sebagai data. </p><br><p>  Tabel perbandingan: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Opsi 1 </th><th>  Opsi 2 </th><th>  Opsi 3 </th></tr></thead><tbody><tr><td>  <strong>Toleransi kesalahan</strong> </td><td>  - </td><td>  + </td><td>  + </td></tr><tr><td>  <strong>Kekompakan</strong> </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  <strong>Kompleksitas implementasi</strong> </td><td>  * </td><td>  ** </td><td>  ** </td></tr></tbody></table></div><br><p>  Opsi 1 memiliki cacat fatal: jika salah satu header rusak, seluruh rantai kami selanjutnya dihancurkan.  Opsi lain memungkinkan Anda memulihkan sebagian data bahkan dengan kerusakan besar. <br>  Tetapi di sini pantas untuk diingat bahwa kami memutuskan untuk menyimpan data dalam bentuk terkompresi, jadi kami kehilangan semua data pada halaman setelah catatan "rusak", jadi meskipun tabelnya minus, kami tidak memperhitungkannya. </p><br><p>  Kekompakan: </p><br><ul><li>  pada versi pertama, kita hanya perlu menyimpan panjang di header, jika bilangan bulat dengan panjang variabel digunakan, maka dalam kebanyakan kasus kita dapat melakukannya dengan satu byte; </li><li>  pada opsi kedua, kita perlu menyimpan alamat awal dan panjangnya;  catatan harus berupa ukuran konstan, saya perkirakan 4 byte per record (dua byte per offset, dan dua byte per panjang); </li><li>          ,    -    1-2%.       . </li></ul><br><p>        (   ).      ,     . </p><br><p> <em>, -  -    . ,        ,      —     ,  , ...</em> </p><br><p>     :          ,      ,      .. , , ,      —     ,   . </p><br><p> <strong>:</strong>       "   —   " -    . </p><br><h3 id="ispolzovanie-bitovyh-poley-dlya-kontrolya-uspeshnosti-operaciy-zapisi">         </h3><br><p>    ,    ,     : <br>         . <br> <em>   ,  erase    1,     1  0,   .</em>    "  "  1,  " " — 0. </p><br><p>          flash: </p><br><ol><li>   “  ”; </li><li>  ; </li><li>   “  ”; </li><li>  ; </li><li>   “ ”. </li></ol><br><p>  ,     “ ”,  4  . </p><br><p>          “1111” —     “1000” —   ;         ,        . </p><br><p>  ,           , , , ,      (   )   . </p><br><p> <strong>:</strong>      . </p><br><h3 id="kontrolnye-summy">   </h3><br><p>       (  )     ,     . ,       ,   . </p><br><p>      ,     ,           <em>( , ,   —       )</em> . </p><br><p>  ,    ,   ,   —  . </p><br><p>         — CRC.   ,     100%    ,   —               <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>n</mi></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.659ex" height="2.298ex" viewBox="0 -883.9 1575.6 989.6" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-6E" x="778" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>−</mo><mi>n</mi></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1">2^{-n}</script>  .      ,      ,       :       ,      .  —      . </p><br><p>   : <a href="http://amsoftware.narod.ru/algo.html" rel="nofollow"> 1</a> , <a href="http://amsoftware.narod.ru/algo2.html" rel="nofollow"> 2</a> <em>(  narod.ru, )</em> . </p><br><p>       , CRC —     .    ,    . </p><br><p>        ,     . </p><br><p> : <br>         <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>10</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mn>3</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.658ex" height="2.419ex" viewBox="0 -935.7 2005.4 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-30" x="500" y="0"></use><g transform="translate(1001,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-33" x="778" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mrow class="MJX-TeXAtom-ORD"><mo>−</mo><mn>3</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2">10^{-3}</script>    ,       : </p><br><div class="scrollable-table"><table><thead><tr><th> ,  </th><th>  ,  </th><th>   </th><th>    </th><th>    </th></tr></thead><tbody><tr><td>  1 </td><td>  0 </td><td>  1000 </td><td>  0 </td><td>  1000 </td></tr><tr><td>  1 </td><td>  1 </td><td>  4 </td><td> 999 </td><td> 1003 </td></tr><tr><td>  1 </td><td>  2 </td><td> ≈0 </td><td> 1997 </td><td> 1997 </td></tr><tr><td>  1 </td><td>  4 </td><td> ≈0 </td><td> 3990 </td><td> 3990 </td></tr><tr><td>  10 </td><td>  0 </td><td> 9955 </td><td>  0 </td><td> 9955 </td></tr><tr><td>  10 </td><td>  1 </td><td>  39 </td><td> 990 </td><td> 1029 </td></tr><tr><td>  10 </td><td>  2 </td><td> ≈0 </td><td> 1979 </td><td> 1979 </td></tr><tr><td>  10 </td><td>  4 </td><td> ≈0 </td><td> 3954 </td><td> 3954 </td></tr><tr><td>  1000 </td><td>  0 </td><td> 632305 </td><td>  0 </td><td> 632305 </td></tr><tr><td>  1000 </td><td>  1 </td><td> 2470 </td><td> 368 </td><td> 2838 </td></tr><tr><td>  1000 </td><td>  2 </td><td>  10 </td><td> 735 </td><td> 745 </td></tr><tr><td>  1000 </td><td>  4 </td><td> ≈0 </td><td> 1469 </td><td> 1469 </td></tr></tbody></table></div><br><p>  ,   —               —    . </p><br><p> ,      : ,       ,           .     ,  <a href="https://habr.com/ru/post/428746/">   </a> . </p><br><p> ,        ,      32    <em>(   64     -)</em> . </p><br><p>   ,    ,      , -   32-   (16  ,    0.01%;  24 ,  ,     ). </p><br><p>    :          ,    4  ?           ?  ,   <em> </em> ,      . </p><br><p>       ,     CRC-32C. <br>    6      22  (,     c), 4      655  (    ), 2           . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><p> <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" rel="nofollow"> </a>  CRC. </p><br><p> <a href="https://users.ece.cmu.edu/~koopman/crc/c32/0x8f6e37a0_len.txt" rel="nofollow">  crc-32c</a>  <a href="http://users.ece.cmu.edu/~koopman/crc/notes.html" rel="nofollow"> </a> — ,    CRC  . </p><br><p>  <a href="http://users.ece.cmu.edu/~koopman/networks/dsn02/dsn02_koopman.pdf" rel="nofollow"> </a>  <a href="https://users.ece.cmu.edu/~koopman/crc/c32/0xfa567d89_len.txt" rel="nofollow">   </a> ,          ,      ,    ,         . </p></div></div><br><p> ,      ,  :       ? </p><br><p>  ""     : </p><br><ul><li>          —       (         /, ,     ..); </li><li>  deflate  zlib      <em> </em>   ""  ,  ,         ,      (        , zlib      ). </li></ul><br><p>  ""     : </p><br><ul><li> CRC ""     ,    - (          ,  ,  ,   "" ); </li><li>          , <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-72/product_id-1820/GNU-Zlib.html" rel="nofollow">  </a> ,   . </li></ul><br><p>              . </p><br><p> <strong>:</strong>  CRC-32C,        ,      flash ( ). </p><br><h3 id="izbytochnost">  </h3><br><p>     , ,   , ,    (   )     . </p><br><p>        ,   . <br>       ,  - ,           RAID-6         . <br>         ,   ,           ,     . </p><br><p>   ,       .        ? </p><br><ol><li>   ( -      ,  Raspberry, ...) <br> ,             ; </li><li>   ( -   flash-   ,  ) <br>      ,         ; </li><li>       ; </li><li>   <br>            . </li></ol><br><p>       (    )       . ,   -  . </p><br><p> <strong>:</strong>      , ,      ,      (     ,      ). </p><br><h3 id="prochee">  </h3><br><p> ,          <em>(      )</em> ,      ,   . </p><br><ul><li>     "" <br>     -    ,    ..,    ,      . <br>     ,    ,    ; </li><li>     . <br>       — ! <br>         Magic Number (),        <em>( ,       )</em> ; </li><li>    (  )   ,         1 ; </li><li>               . </li></ul><br><p>   <a href="https://planetcalc.com/2481/" rel="nofollow">-</a>  .          . </p><br><h1 id="anchorformatanchoropisanie-formata-hraneniya-dannyh"><a name="format"></a>     </h1><br><h2 id="byte-order"> Byte order </h2><br><p> ,    ,   big-endian  (network byte order),   0x1234   0x12, 0x34. </p><br><h2 id="delenie-na-stranicy">    </h2><br><p>  -     . </p><br><p>     32,   ,  1/4      (   4  128 ). </p><br><p>        (          ). </p><br><p>       (   ),    0 (     0,  —  32,  —  64  ..) </p><br><p>       (ring buffer),          0,    1, ...,     ,          . </p><br><h2 id="vnutri-stranicy">   </h2><br><p><img src="https://habrastorage.org/webt/7r/sr/fa/7rsrfafqrc263dsu8zd5ptceqga.png" alt="Halaman"><br>     4-  ,     (CRC-32C),      ", ,  ". </p><br><p>   (  -)  : </p><br><ul><li>   Magic Number (  —   ) <br>        <code>0xed00 ⊕  </code> ; </li><li>   " " (   ). </li></ul><br><p>        (  deflate).          (  ),       .              (   ). </p><br><p>      Z_SYNC_FLUSH,        4  0x00, 0x00, 0xff, 0xff, , ,      . <br>   ( 4, 5  6 )      -. </p><br><p>      1, 2  3 , : </p><br><ul><li>   (T),   : 0 — , 1 — ; </li><li>    (S)  1  7 ,     "",       ; </li><li>   (L). </li></ul><br><p>   S: </p><br><div class="scrollable-table"><table><thead><tr><th>  S </th><th>  ,  </th><th>   ,  </th></tr></thead><tbody><tr><td> <code>0</code> </td> <td>  1 </td><td> 5 ( <code>00 00 00 ff ff</code> ) </td></tr><tr><td> <code>10</code> </td> <td>  1 </td><td> 6 ( <code>00 00 00 00 ff ff</code> ) </td></tr><tr><td> <code>110</code> </td> <td>  2 </td><td> 4 ( <code>00 00 ff ff</code> ) </td></tr><tr><td> <code>1110</code> </td> <td>  2 </td><td> 5 ( <code>00 00 00 ff ff</code> ) </td></tr><tr><td> <code>11110</code> </td> <td>  2 </td><td> 6 ( <code>00 00 00 00 ff ff</code> ) </td></tr><tr><td> <code>1111100</code> </td> <td>  3 </td><td> 4 ( <code>00 00 ff ff</code> ) </td></tr><tr><td> <code>1111101</code> </td> <td>  3 </td><td> 5 ( <code>00 00 00 ff ff</code> ) </td></tr><tr><td> <code>1111110</code> </td> <td>  3 </td><td> 6 ( <code>00 00 00 00 ff ff</code> ) </td></tr></tbody></table></div><br><p>  ,  ,   : <br><img src="https://habrastorage.org/webt/iu/fu/bp/iufubpdgxnpv9czd45tomt-0vtc.png" alt="Entri Judul"><br>     T,  —  S,  L (    ),  —  ,  —    ,     -. </p><br><p>  ,      ( 63+5    )     . </p><br><p>       CRC-32C,       (init)      . </p><br><p> <em>CRC   "",  (-    )  :</em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>R</mi><mi>C</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mo>,</mo><mi>A</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>B</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>C</mi><mi>R</mi><mi>C</mi><mo stretchy=&quot;false&quot;>(</mo><mi>C</mi><mi>R</mi><mi>C</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mo>,</mo><mi>A</mi><mo stretchy=&quot;false&quot;>)</mo><mo>,</mo><mi>B</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="43.505ex" height="2.66ex" viewBox="0 -832 18731.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-52" x="760" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-43" x="1520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-28" x="2280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-69" x="2670" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-6E" x="3015" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-69" x="3616" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-74" x="3961" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-2C" x="4323" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-41" x="4768" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-7C" x="5518" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-7C" x="5797" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-42" x="6075" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-29" x="6835" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-3D" x="7502" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-43" x="8558" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-52" x="9319" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-43" x="10078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-28" x="10839" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-43" x="11228" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-52" x="11989" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-43" x="12748" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-28" x="13509" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-69" x="13898" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-6E" x="14244" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-69" x="14844" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-74" x="15190" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-2C" x="15551" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-41" x="15996" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-29" x="16747" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-2C" x="17136" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMATHI-42" x="17582" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/479044/&amp;xid=25657,15700022,15700186,15700191,15700259,15700271&amp;usg=ALkJrhizAYmnbeImN0h_Yq-7V_SmJ27ZUQ#MJMAIN-29" x="18341" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>R</mi><mi>C</mi><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mo>,</mo><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>R</mi><mi>C</mi><mo stretchy="false">(</mo><mi>C</mi><mi>R</mi><mi>C</mi><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-3">CRC(init, A || B) = CRC(CRC(init, A), B)</script></em>  <em>. <br>      CRC         .</em> </p><br><p>        . </p><br><p>    ,         0x00  0xff (       0xff,      ; 0x00    ). </p><br><h2 id="primernye-algoritmy">   </h2><br><h3 id="chtenie-iz-flesh-pamyati">   - </h3><br><p>       . <br>      —       -  . </p><br><p> <em>(  , Linux     NOR Flash, )</em> </p><br><h3 id="zapis-v-flesh-pamyat">   - </h3><br><p>  . <br>  . </p><br><p>        —       . </p><br><h3 id="podgotovka-novoy-mikroshemy-k-rabote">      </h3><br><p>     ( )      1. <br>         ( UUID    ). </p><br><p> , -   . </p><br><h3 id="zagruzka-avtomata">   </h3><br><p>     8    ( + CRC),    Magic Number   CRC . <br>  ""      ,    ,   . <br>   ,   CRC,   "".    —    .   —   ,    "" . <br>      , ,    "" . <br>   zlib (      ). </p><br><p> ,  ,  ,  . </p><br><h3 id="dobavlenie-zapisi-v-zhurnal">     </h3><br><p>     ,  Z_SYNC_FLUSH.,       . <br>    (     CRC) —    (. ). <br>    CRC.    —   . </p><br><h3 id="novaya-stranica">   </h3><br><p>       (              ).     —       ,     . <br>    erase.    0xff.  -   —    ,  .. <br>     ,     ,  —    (  ). </p><br><h1 id="primenimost-formata">   </h1><br><p>   ,       -    ( , JSON, MessagePack, CBOR, , protobuf)  NOR Flash. </p><br><p> ,  ""  SLC NOR Flash. </p><br><p>         BER,  NAND  MLC NOR <em>(      ?        )</em> . </p><br><p>  ,      ,   FTL: USB flash, SD, MicroSD, etc <em>(          512 ,          —   ""        )</em> . </p><br><p>             128 (16)  1 (128).         , , ,     <em>(      ,   NOR Flash    )</em> . </p><br><p>  -   ,         — ,   ,      github. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  ,      <em>  </em> . </p><br><p>        ,  :     - , ,         . ,  () -         . </p><br><p>    ,   ?  Ya tentu saja   , ,      .   -        . </p><br><p>        ?  ,       ,   .    . </p><br><p>    ,       ,   " ". </p><br><p>        ,       <em>()</em>   , ,    ""  (, ,     ;      ).        <em>(    —   )</em> . </p><br><p>          ,      . </p><br><h1 id="literatura">  Sastra </h1><br><p>        ,       . </p><br><p>      ,     ,        ,      : </p><br><ol><li>  <a href="https://github.com/madler/infgen/" rel="nofollow">infgen</a>   zlib.        deflate/zlib/gzip.         deflate ( gzip) —  . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479044/">https://habr.com/ru/post/id479044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479034/index.html">Bagaimana menghubungkan ke VPN perusahaan di Linux menggunakan openconnect dan vpn-slice</a></li>
<li><a href="../id479036/index.html">Intel tidak dapat mengatasi permintaan akan prosesor. Akibatnya, HP dan Dell menderita</a></li>
<li><a href="../id479038/index.html">Transformasi Digital Leroy Merlin: Merancang Antarmuka untuk Bekerja dengan Panggilan Pelanggan</a></li>
<li><a href="../id479040/index.html">Tes regresi visual. Mulai ulang</a></li>
<li><a href="../id479042/index.html">Metode Y adalah cara yang sangat mudah untuk membangun Rubik's Cube</a></li>
<li><a href="../id479048/index.html">Node.js Streaming untuk boneka atau cara bekerja dengan aliran</a></li>
<li><a href="../id479050/index.html">Penelitian paten di bidang TI. Kursus pejuang muda. Bagian II Sumber informasi untuk penelitian paten</a></li>
<li><a href="../id479052/index.html">[Superkomputer 2019]. Penyimpanan multi-cloud sebagai aplikasi untuk drive Kingston DC1000M baru</a></li>
<li><a href="../id479054/index.html">Polling Ponsel Jumat</a></li>
<li><a href="../id479056/index.html">Bicara tentang kehidupan? Tim DREAM tentang Tantangan Alexa Prize Socialbot 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>