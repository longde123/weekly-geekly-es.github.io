<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè´ üßùüèæ üëÇ Architecture EBA aka pleine r√©activit√© üï° üóìÔ∏è üöΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je suis venu √† Tinkoff il y a quelques ann√©es, sur un nouveau projet, Clients et Projets , qui venait juste de d√©marrer. 
 Maintenant, je ne me souvie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architecture EBA aka pleine r√©activit√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/474612/"><p>  Je suis venu √† Tinkoff il y a quelques ann√©es, sur un nouveau projet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Clients et Projets</a> , qui venait juste de d√©marrer. <br>  Maintenant, je ne me souviens plus de mes sentiments de cette nouvelle architecture pour moi.  Mais je me souviens avec certitude: il √©tait inhabituel que Rx soit utilis√© ailleurs, en dehors des trajets habituels vers le r√©seau et la base.  Maintenant que cette architecture a d√©j√† franchi une voie √©volutive de d√©veloppement, je veux enfin parler de ce qui s'est pass√© et de ce qui est arriv√©. </p><br><p><img src="https://habrastorage.org/webt/gk/ru/ve/gkruveswoxzhqfxjfasm_vaf2qq.png"></p><br><p>  √Ä mon avis, toutes les architectures actuellement populaires - MVP, MVVM et m√™me MVI - ont longtemps √©t√© dans l'ar√®ne et pas toujours bien m√©rit√©es.  N'ont-ils pas de d√©fauts?  J'en vois beaucoup.  Nous avons d√©cid√© chez nous qu‚Äôil suffisait de le supporter et (re) invent√© une nouvelle architecture asynchrone. </p><a name="habracut"></a><br><p>  Je d√©crirai bri√®vement ce que je n'aime pas dans les architectures actuelles.  Certains points peuvent √™tre controvers√©s.  Peut-√™tre que vous ne l'avez jamais rencontr√©, vous √©crivez une programmation parfaite et g√©n√©ralement Jedi.  Alors pardonne-moi, p√©cheur. <br>  Donc ma douleur est: </p><br><ul><li>  √ânorme pr√©sentateur / ViewModel. </li><li>  Une √©norme quantit√© de bo√Ætier de commutation dans MVI. </li><li>  Incapacit√© √† r√©utiliser des parties de Presenter / ViewModel et, par cons√©quent, la n√©cessit√© de dupliquer le code. </li><li>  Des tas de variables mutables qui peuvent √™tre modifi√©es de n'importe o√π.  En cons√©quence, un tel code est difficile √† maintenir et √† modifier. </li><li>  Mise √† jour de l'√©cran non d√©compos√©. </li><li>  Il est difficile d'√©crire des tests. </li></ul><br><h2 id="problematika">  <strong>Probl√®me</strong> </h2><br><blockquote>  √Ä chaque instant, l'application a un certain √©tat qui d√©finit son comportement et ce que voit l'utilisateur.  Cet √©tat inclut toutes les valeurs des variables - des simples drapeaux aux objets individuels.  Chacune de ces variables vit sa propre vie et est contr√¥l√©e par diff√©rentes parties du code.  Vous ne pouvez d√©terminer l'√©tat actuel de l'application qu'en les v√©rifiant toutes l'une apr√®s l'autre. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un article sur l'architecture moderne Kotlin MVI</a> <br><cut></cut><br></blockquote><br><h2 id="glava-1-evolyuciya--nashe-vsyo">  <strong>Chapitre 1. L'√©volution est notre tout</strong> </h2><br><p>  Au d√©part, nous avons √©crit sur MVP, mais un peu mut√©.  C'√©tait un m√©lange de MVP et MVI.  Il y avait des entit√©s de MVP sous la forme d'un pr√©sentateur et d'une interface View: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewTaskView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newTaskAction: Observable&lt;NewTaskAction&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> taskNameChangeAction: Observable&lt;String&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onChangeState: Consumer&lt;SomeViewState&gt; }</code> </pre> <br><p>  D√©j√† ici, vous pouvez remarquer le hic: Voir ici est tr√®s loin des canons de MVP.  Il y avait une m√©thode dans le pr√©sentateur: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeView</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Disposable</code> </pre> <br><p>  √Ä l'ext√©rieur, une impl√©mentation d'interface a √©t√© transmise qui s'est abonn√©e de mani√®re r√©active aux modifications de l'interface utilisateur.  Et √ßa sent d√©j√† le MVI! </p><br><p>  Plus c'est plus.  Dans Presenter, diff√©rents interacteurs ont √©t√© cr√©√©s et abonn√©s aux modifications de la vue, mais ils n'ont pas appel√© directement les m√©thodes d'interface utilisateur, mais ont renvoy√© un √©tat global, dans lequel tous les √©tats d'√©cran possibles √©taient: </p><br><pre> <code class="kotlin hljs">compositeDisposable.add( Observable.merge(firstAction, secondAction) .observeOn(AndroidSchedulers.mainThread()) .subscribe(view.onChangeState)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compositeDisposable</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewState</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> progress: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> error: Throwable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage: String? = error?.message, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result: TaskUi? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre><br><p>  L'activit√© √©tait le descendant de l'interface SomeViewStateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSuccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeUiModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toProgress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buttonEnabled: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Lorsque l'utilisateur a cliqu√© sur quelque chose √† l'√©cran, un √©v√©nement est entr√© dans le pr√©sentateur et il a cr√©√© un nouveau mod√®le, qui a √©t√© dessin√© par une classe sp√©ciale: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateResolver</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateMachine: SomeViewStateMachine) : Consumer&lt;SomeViewState&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stateUpdate: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeViewState</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.toSuccess(stateUpdate.result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.error != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { stateMachine.toError(stateUpdate.errorMessage) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { stateMachine.toProgress() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.someButtonEnabled != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.changeSomeButton(stateUpdate.someButtonEnabled) } } }</code> </pre> <br><p>  D'accord, un MVP √©trange, et m√™me loin de MVI.  √Ä la recherche d'inspiration. </p><br><h2 id="glava-2-redux">  <strong>Chapitre 2. Redux</strong> </h2><br><p><img src="https://habrastorage.org/webt/sw/bm/pf/swbmpfddkyjohcxemag4a0zdatm.jpeg"></p><br><p>  Parlant de ses probl√®mes avec d'autres d√©veloppeurs, notre (alors encore) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leader Sergey Boishtyan a d√©couvert</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Redux</a> . </p><br><p>  Apr√®s avoir regard√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dorfman parler de toutes les architectures</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avoir jou√©</a> avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Redux</a> , nous avons d√©cid√© de l'utiliser pour mettre √† niveau notre architecture. <br>  Mais d'abord, examinons de plus pr√®s l'architecture et examinons ses avantages et ses inconv√©nients. </p><br><p>  <strong>Action</strong> <br>  D√©crit l'action. </p><br><p>  <strong>Cr√©ateur d'action</strong> <br>  Il est comme un analyste de syst√®mes: formate, compl√®te les sp√©cifications des besoins des clients pour que les programmeurs le comprennent. <br>  Lorsque l'utilisateur clique sur l'√©cran, ActionsCreator forme une action qui va au middleware (une sorte de logique m√©tier).  La logique m√©tier nous donne de nouvelles donn√©es qu'un r√©ducteur particulier re√ßoit et tire. </p><br><p>  Si vous regardez √† nouveau l'image, vous remarquerez peut-√™tre un objet tel que Store.  Magasins de magasins R√©ducteurs.  Autrement dit, nous voyons que les fr√®res front-end - fr√®res malheureux - ont devin√© qu'un grand objet peut √™tre sci√© en plusieurs petits, dont chacun sera responsable de sa propre partie de l'√©cran.  Et c'est juste une merveilleuse pens√©e! </p><br><p>  Exemple de code pour des ActionCreators simples (attention, JavaScript!): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ADD_TODO, text } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggleTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: TOGGLE_TODO, index } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setVisibilityFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: SET_VISIBILITY_FILTER, filter } }</code> </pre> <br><p>  <strong>R√©ducteur</strong> </p><br><blockquote>  Actions d√©crit le fait que quelque chose s'est produit, mais n'indique pas comment l'√©tat de l'application doit changer en r√©ponse, cela fonctionne pour Reducer. </blockquote><p>  En bref, Reducer sait comment rafra√Æchir d√©compos√©e l'√©cran / view. </p><br><p>  Avantages: </p><br><ul><li>  Mise √† jour de l'√©cran d√©compos√©. </li><li>  Flux de donn√©es unidirectionnel. </li></ul><br><p>  Inconv√©nients: </p><br><ul><li>  Commutateur pr√©f√©r√© √† nouveau. <br><pre> <code class="kotlin hljs">function todoApp(state = initialState, action) { switch (action.type) { case SET_VISIBILITY_FILTER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { visibilityFilter: action.filter }) case ADD_TODO: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { todos: [ ...state.todos, { text: action.text, completed: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] }) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state }</code> </pre> </li><li>  Un tas d'objets d'√©tat. </li><li>  S√©paration de la logique en ActionCreator et Reducer. </li></ul><br><p>  Oui, il nous a sembl√© que la s√©paration d'ActionCreator et de Reducer n'est pas la meilleure option pour connecter le mod√®le et l'√©cran, car √©crire instanceof (is) est une mauvaise approche.  Et ici, nous avons invent√© NOTRE architecture! </p><br><h2 id="glava-3-eba">  <strong>Chapitre 3. EBA</strong> </h2><br><p><img src="https://habrastorage.org/webt/os/6w/7_/os6w7_sgmegw6nsh7lyebs_o9de.jpeg"></p><br><p>  Qu'est-ce qu'Action et ActionCreator dans le contexte de l'ABE: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionCreator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"></span></span><span class="hljs-class"><span class="hljs-type"></span></span>(T) -&gt; (Observable&lt;Action&gt;)</code> </pre> <br><p>  Oui, la moiti√© de l'architecture est constitu√©e de typealias et d'une interface.  La simplicit√© est synonyme d'√©l√©gance! </p><br><p>  Une action est n√©cessaire pour appeler quelque chose sans transmettre de donn√©es.  Depuis ActionCreator renvoie un observable, nous avons d√ª envelopper Action dans un autre lambda pour transmettre des donn√©es.  Et il s'est av√©r√© que ActionMapper - une action typ√©e √† travers laquelle nous pouvons passer ce dont nous avons besoin pour mettre √† jour l'√©cran / vue. <br><br>  <strong>Postulats de base:</strong> <br></p><div class="spoiler">  <b class="spoiler_title">Un ActionCreator - une partie de l'√©cran</b> <div class="spoiler_text"><p>  Avec le premier paragraphe, tout est clair: pour qu'il n'y ait pas d'enfer de mises √† jour crois√©es incompr√©hensibles, nous avons convenu qu'un ActionCreator ne peut mettre √† jour que sa partie de l'√©cran.  S'il s'agit d'une liste, il ne met √† jour que la liste, si le bouton seulement. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">La dague n'est pas n√©cessaire</b> <div class="spoiler_text"><p>  Mais, on se demande pourquoi Dagger ne nous a pas plu?  Je vous dis. <br>  Une histoire typique est quand un r√©sum√© Sergey aka ma√Ætre poignard aka "Que fait cet abstrait?" Est sur le projet. </p><br><p>  Il s'av√®re que si vous avez exp√©riment√© avec un poignard, vous devez expliquer √† chaque fois √† chaque nouveau (et pas seulement nouveau) d√©veloppeur.  Ou peut-√™tre vous-m√™me avez d√©j√† oubli√© ce que fait cette annotation, et vous allez sur Google. </p><br><p>  Tout cela complique grandement le processus de cr√©ation de fonctionnalit√©s sans introduire beaucoup de commodit√©.  Par cons√©quent, nous avons d√©cid√© de cr√©er les choses dont nous avons besoin avec nos mains, donc ce sera plus rapide √† assembler, car il n'y a pas de g√©n√©ration de code.  Oui, nous passerons cinq minutes suppl√©mentaires √† √©crire toutes les d√©pendances avec nos mains, mais nous √©conomiserons beaucoup de temps sur la compilation.  Oui, nous n'avons pas partout abandonn√© le poignard, il est utilis√© au niveau mondial, il cr√©e des choses communes, mais nous les √©crivons en Java pour une meilleure optimisation, afin de ne pas attirer kapt. </p></div></div><br><p>  <strong>Sch√©ma d'architecture</strong> : </p><br><p><img src="https://habrastorage.org/webt/1w/m6/1a/1wm61atrwg2dmy4hkzfherwsbqc.png"></p><br><p>  Le composant est un analogue du m√™me composant de Dagger, uniquement sans Dagger.  Sa t√¢che est de cr√©er un classeur.  Binder relie ActionCreators.  De la vue √† la reliure, les √©v√©nements se produisent et de la reliure √† la vue, des actions sont envoy√©es pour mettre √† jour l'√©cran. </p><br><p>  <strong>Cr√©ateur d'action</strong> </p><br><p><img src="https://habrastorage.org/webt/8v/nw/3p/8vnw3p52mcfzyyhegcxtkexgokm.png"></p><br><p>  Voyons maintenant de quel genre de chose il s'agit - ActionCreator.  Dans le cas le plus simple, il traite simplement l'action unidirectionnellement.  Supposons qu'il existe un tel sc√©nario: l'utilisateur a cliqu√© sur le bouton "Cr√©er une t√¢che".  Un autre √©cran devrait s'ouvrir, o√π nous le d√©crirons, sans aucune demande suppl√©mentaire. </p><br><p>  Pour ce faire, nous nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">abonnons</a> simplement au bouton √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RxBinding</a> de notre bien-aim√© Jake et attendons que l'utilisateur clique dessus.  D√®s qu'un clic se produit, Binder enverra l'√©v√©nement √† un ActionCreator sp√©cifique, qui appellera notre Action, ce qui nous ouvrira un nouvel √©cran.  Notez qu'il n'y avait pas de commutateurs.  Ensuite, je montrerai dans le code pourquoi il en est ainsi. <br>  Si nous avons soudainement besoin d'aller sur le r√©seau ou la base de donn√©es, nous faisons ces demandes l√†, mais via les interacteurs que nous avons transmis au constructeur ActionCreator via l'interface pour les appeler: </p><br><blockquote>  Avertissement: le formatage du code n'est pas tout √† fait correct ici, j'ai ses r√®gles pour l'article afin que le code soit bien lu. </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadItemsActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> getItems: () -&gt; Observable&lt;List&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> showLoadedItems: ActionMapper&lt;DiffResult&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diffCalculator: DiffCalculator&lt;ViewTyped&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorItem: ErrorView, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> emptyItem: ViewTyped? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) : ActionOnEvent</code> </pre> <br><p>  Par les mots "par l'interface de leur appel", je voulais dire exactement comment getItems est d√©clar√© (ici ViewTyped est notre interface pour travailler avec des listes).  Soit dit en passant, nous avons r√©utilis√© cet ActionCreator dans huit parties diff√©rentes de l'application, car il est √©crit aussi polyvalent que possible. </p><br><p>  √âtant donn√© que les √©v√©nements sont de nature r√©active, nous pouvons assembler une cha√Æne en y ajoutant d'autres op√©rateurs, par exemple, startWith (showLoadingAction) pour afficher le chargement et onErrorReturn (errorAction) pour afficher un √©tat d'√©cran avec une erreur. <br>  Et tout cela est r√©actif! </p><br><h2 id="primer-">  <strong>Exemple</strong> </h2><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompositionFragment</span></span></span></span>(R.layout.fragment_about) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.clicks(), openProcessingPersDataEvent = personalDataProtection.clicks(), unbindEvent = unBindEvent) component.binder().bind(events) }</code> </pre> <br><p>  Voyons enfin l'architecture en utilisant le code comme exemple.  Pour commencer, j'ai choisi l'un des √©crans les plus simples - sur l'application, car il s'agit d'un √©cran statique. <br>  Pensez √† cr√©er un composant: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } } )</code> </pre> <br><p>  Arguments du composant - Actions / ActionMappers - aide √† associer View √† ActionCreators.  Dans ActionMapper'e setVersionName, nous transmettons la version du projet et attribuons cette valeur au texte √† l'√©cran.  Dans openPdfAction, une paire de lien vers un document et un nom pour ouvrir l'√©cran suivant o√π l'utilisateur peut lire ce document. </p><br><p>  Voici le composant lui-m√™me: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionMapper&lt;String&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, someUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, anotherUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName = setVersionName.toSimpleActionCreator( moreComponent::currentVersionName ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AboutEventsBinder(setVersionName, openPolicyPrivacy, openProcessingPersonalData) } }</code> </pre> <br><p>  Permettez-moi de vous rappeler que: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action</code> </pre> <br><p>  OK, passons. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder</code> </pre> <br><p>  Jetons un ≈ìil √† AboutEventsBinder plus en d√©tail. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEventsBinder</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData: ActionOnEvent) : BaseEventsBinder&lt;AboutEvents&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AboutEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.merge( setVersionName(events.bindEvent), openPolicyPrivacy(events.openPolicyPrivacyEvent), openProcessingPersonalData(events.openProcessingPersDataEvent)) } }</code> </pre> <br><p>  ActionOnEvent est une autre typealias, afin de ne pas √©crire √† chaque fois. </p><br><pre> <code class="kotlin hljs">ActionCreator&lt;Observable&lt;*&gt;&gt;</code> </pre> <br><p>  Dans AboutEventsBinder, nous transmettons ActionCreators et, en les invoquant, nous nous lions √† un √©v√©nement sp√©cifique.  Mais pour comprendre comment tout cela se connecte, regardons la classe de base - BaseEventsBinder. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread() ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(events).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  Nous voyons la m√©thode famili√®re bindInternal, que nous avons red√©finie dans le successeur.  Consid√©rez maintenant la m√©thode de liaison.  Toute la magie est l√†.  Nous acceptons l'h√©ritier de l'interface BaseEvents, le transmettons √† bindInternal pour connecter les √©v√©nements et les actions.  Une fois que nous disons que quoi qu'il arrive, nous ex√©cutons sur le flux ui et nous abonnons.  Nous voyons √©galement un hack int√©ressant - takeUntil. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEvents</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable }</code> </pre> <br><p>  Apr√®s avoir d√©fini le champ unbindEvent dans BaseEvents pour contr√¥ler la d√©sinscription, nous devons l'impl√©menter dans tous les h√©ritiers.  Ce magnifique champ vous permet de vous d√©sinscrire automatiquement de la cha√Æne d√®s la fin de cet √©v√©nement.  C'est tout simplement g√©nial!  Maintenant, vous ne pouvez pas suivre et ne vous inqui√©tez pas du cycle de vie et dormir paisiblement. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, policyPrivacyUrl) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, personalDataUrl)</code> </pre> <br><p>  Retour au composant.  Et ici, vous pouvez d√©j√† voir la m√©thode de r√©utilisation.  Nous avons √©crit une classe qui peut ouvrir l'√©cran de visualisation PDF, et peu importe pour nous quelle est cette URL.  Pas de duplication de code. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenPdfActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pdfUrl: String) : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { openPdfAction(pdfUrl to pdfUrl.substringAfterLast(FILE_NAME_DELIMITER)) } } }</code> </pre> <br><p>  Le code ActionCreator est √©galement aussi simple que possible, ici nous effectuons juste quelques manipulations de cha√Ænes. </p><br><p>  Revenons au composant et consid√©rons le ActionCreator suivant: </p><br><pre> <code class="kotlin hljs">setVersionName.toSimpleActionCreator(moreComponent::currentVersionName)</code> </pre> <br><p>  Une fois que nous sommes devenus trop paresseux pour √©crire les m√™mes ActionCreators intrins√®quement simples.  Nous avons utilis√© le pouvoir de Kotlin et √©crit extension'y.  Par exemple, dans ce cas, nous avions juste besoin de passer une cha√Æne statique √† ActionMapper. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function"> ActionMapper</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSimpleActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( mapper: ()</span></span></span></span> -&gt; R): ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observable</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toSimpleActionCreator</span></span>(mapper()) } } } }</code> </pre> <br><p>  Il y a des moments o√π nous n'avons pas besoin de transmettre quoi que ce soit, mais appelons seulement une action - par exemple, pour ouvrir l'√©cran suivant: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Action.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toActionCreator</span></span> } } } }</code> </pre> <br><p>  Donc, avec le composant termin√©, revenez au fragment: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.throttleFirstClicks(), openProcessingPersDataEvent = personalDataProtection.throttleFirstClicks(), unbindEvent = unBindEvent)</code> </pre> <br><p>  Nous voyons ici la cr√©ation d'une classe charg√©e de recevoir les √©v√©nements de l'utilisateur.  Et d√©lier et lier ne sont que des √©v√©nements de cycle de vie d'√©cran que nous r√©cup√©rons √† l'aide de la biblioth√®que Navi de Trello. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;T&gt; NaviComponent.observe(event: Event&lt;T&gt;): Observable&lt;T&gt; = RxNavi.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this, event)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unBindEvent: Observable&lt;*&gt; = observe(Event.DESTROY_VIEW) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: Observable&lt;*&gt; = Observable.just(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)  <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent = observe(Event.POST_CREATE)</code> </pre> <br><p>  L'interface √âv√©nements d√©crit les √©v√©nements d'un √©cran particulier et doit h√©riter de BaseEvents.  Ce qui suit est toujours une impl√©mentation de l'interface.  Dans ce cas, les √©v√©nements se sont av√©r√©s √™tre un √† un avec ceux qui viennent de l'√©cran, mais il arrive que vous deviez garder deux √©v√©nements ensemble. </p><br><p>  Par exemple, les √©v√©nements de chargement d'√©cran √† l'ouverture et de rechargement en cas d'erreur doivent √™tre combin√©s en un seul - il suffit de charger l'√©cran. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseEvents { val bindEvent: EventObservable val openPolicyPrivacyEvent: EventObservable val openProcessingPersDataEvent: EventObservable } class AboutEventsImpl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacyEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersDataEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable) : AboutEvents</code> </pre> <br><p>  Nous retournons au fragment et combinons tout ensemble!  Nous demandons au composant de cr√©er et de nous renvoyer le classeur, puis nous appelons la m√©thode bind dessus, o√π nous passons l'objet qui surveille les √©v√©nements d'√©cran. </p><br><pre> <code class="kotlin hljs">component.binder().bind(events)</code> </pre> <br><p>  Nous √©crivons un projet sur cette architecture depuis environ deux ans maintenant.  Et il n'y a pas de limite au bonheur des managers dans la rapidit√© du partage des fonctionnalit√©s!  Ils n'ont pas le temps d'en trouver un nouveau, car nous finissons d√©j√† l'ancien.  L'architecture est tr√®s flexible et vous permet de r√©utiliser beaucoup de code. <br>  L'inconv√©nient de cette architecture peut √™tre appel√© non conservation de l'√©tat.  Nous n'avons pas de mod√®le complet d√©crivant l'√©tat de l'√©cran, comme dans MVI, mais nous pouvons le g√©rer.  Comme - voir ci-dessous. </p><br><h2 id="glava-4-bonus">  <strong>Chapitre 4. Bonus</strong> </h2><br><p>  Je pense que tout le monde conna√Æt le probl√®me de l'analytique: personne n'aime l'√©crire, car il parcourt toutes les couches et d√©figure les d√©fis.  Il y a quelque temps, et nous avons d√ª y faire face.  Mais gr√¢ce √† notre architecture, une tr√®s belle impl√©mentation a √©t√© obtenue. </p><br><p>  Alors, quelle √©tait mon id√©e: les analyses partent g√©n√©ralement en r√©ponse aux actions des utilisateurs.  Et nous avons juste une classe qui accumule les actions des utilisateurs.  Ok, commen√ßons. </p><br><p>  <strong>√âtape 1</strong>  Nous modifions l√©g√®rement la classe de base BaseEventsBinder en encapsulant les √©v√©nements dans trackAnalytics: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> trackAnalytics: TrackAnalytics&lt;EVENTS&gt; = EmptyAnalyticsTracker(), <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread()) { <span class="hljs-meta"><span class="hljs-meta">@SuppressLint(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CheckResult"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(trackAnalytics(events)).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  <strong>√âtape 2</strong>  Nous cr√©ons une impl√©mentation stable de la variable trackAnalytics afin de maintenir la compatibilit√© descendante et de ne pas casser les h√©ritiers qui n'ont pas encore besoin d'analyses: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyAnalyticsTracker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS = events }</code> </pre> <br><p>  <strong>√âtape 3</strong>  Nous √©crivons l'impl√©mentation de l'interface TrackAnalytics pour l'√©cran souhait√© - par exemple, pour l'√©cran de la liste des projets: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackProjectsEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ProjectsEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ProjectsEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ProjectsEvents { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ProjectsEvents <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> events { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boardClickEvent = events.boardClickEvent.trackTypedEvent { allProjectsProjectClick(it.title) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoardCreationEvent = events.openBoardCreationEvent.trackEvent { allProjectsAddProjectClick() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardsSearchEvent = events.openCardsSearchEvent.trackEvent { allProjectsSearchBarClick() } } } }</code> </pre> <br><p>  Ici, nous utilisons √† nouveau le pouvoir de Kotlin sous la forme de d√©l√©gu√©s.  Nous avons d√©j√† un h√©ritier d'interface cr√©√© par nous - dans ce cas, ProjectsEvents.  Mais pour certains √©v√©nements, vous devez red√©finir le d√©roulement des √©v√©nements et ajouter une liaison autour d'eux avec l'envoi d'analyses.  En fait, trackEvent est juste doOnNext: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec) } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackTypedEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec, it) }</code> </pre> <br><p>  <strong>√âtape 4</strong>  Reste √† le transf√©rer √† Binder.  Puisque nous le construisons dans un composant, nous avons la possibilit√©, si vous en avez soudainement besoin, d'ajouter des d√©pendances suppl√©mentaires au constructeur.  Maintenant, le constructeur ProjectsEventsBinder ressemblera √† ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectsEventsBinder</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loadItems: LoadItemsActionCreator, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshBoards: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoard: ActionCreator&lt;Observable&lt;BoardId&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openScreen: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardSearch: ActionOnEvent, trackAnalytics: TrackAnalytics&lt;ProjectsEvents&gt;) : BaseEventsBinder&lt;ProjectsEvents&gt;(trackAnalytics)</code> </pre> <br><p>  Vous pouvez consulter d'autres exemples sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>GitHub</strong></a> . </p><br><h2 id="voprosy-i-otvety">  <strong>Q &amp; A</strong> </h2><br><div class="spoiler">  <b class="spoiler_title">Comment gardez-vous l'√©tat de l'√©cran?</b> <div class="spoiler_text"><p>  Pas question.  Nous bloquons l'orientation.  Mais nous utilisons √©galement des arguments / intention et y enregistrons la variable OPENED_FROM_BACKSTACK.  Et lorsque nous concevons Binder, nous le regardons.  Si c'est faux - chargez les donn√©es du r√©seau.  Si vrai - √† partir du cache.  Cela vous permet de recr√©er rapidement l'√©cran. </p><br><p>  Pour tous ceux qui sont contre le blocage d'orientation: essayez de tester et de d√©poser des analyses sur la fr√©quence √† laquelle vos utilisateurs retournent le t√©l√©phone et combien sont dans une orientation diff√©rente.  Les r√©sultats peuvent surprendre. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Je ne veux pas √©crire de composants, comment puis-je me faire des amis avec le poignard?</b> <div class="spoiler_text"><p>  Je ne le conseille pas, mais si cela ne vous d√©range pas de compiler le temps, vous pouvez √©galement cr√©er un composant via un poignard.  Mais nous n'avons pas essay√©. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Je n'√©cris pas en kotlin, quelles sont les difficult√©s avec l'impl√©mentation en Java?</b> <div class="spoiler_text"><p>  Tout de m√™me peut √™tre √©crit en Java, mais √ßa n'aura pas l'air si beau. </p></div></div><br><p>  Si vous aimez l'article, la prochaine partie sera sur la fa√ßon d'√©crire des tests sur une telle architecture (alors il sera clair pourquoi il y a tant d'interfaces).  Spoiler - l'√©criture est facile et vous pouvez √©crire sur tous les calques √† l'exception du composant, mais vous n'avez pas besoin de le tester, cela cr√©e simplement un objet liant. </p><br><p>  Merci aux coll√®gues de l'√©quipe de d√©veloppement mobile de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tinkoff Business</a> pour leur aide dans la r√©daction de cet article. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474612/">https://habr.com/ru/post/fr474612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474596/index.html">Application sur TSD et communication avec 1C: Enterprise 8.3 via HTTP-Service. Partie 5 (Menu, objet compagnon)</a></li>
<li><a href="../fr474598/index.html">Comment obtenir un entretien avec un ing√©nieur QA sans exp√©rience de travail</a></li>
<li><a href="../fr474602/index.html">R√©soudre l'√©quation de la r√©gression lin√©aire simple</a></li>
<li><a href="../fr474606/index.html">Comment fonctionne Blogspam</a></li>
<li><a href="../fr474610/index.html">Syst√®me multim√©dia bas√© sur NUC - Exp√©rience √† domicile</a></li>
<li><a href="../fr474618/index.html">Cr√©er un configurateur 3D pour WooCommerce</a></li>
<li><a href="../fr474620/index.html">S√©curit√© des informations du centre de donn√©es</a></li>
<li><a href="../fr474622/index.html">34 biblioth√®ques Python open source (2019)</a></li>
<li><a href="../fr474626/index.html">Terminologie Google Analytics et Yandex.Metrica: comment ne pas se confondre dans toutes ces donn√©es</a></li>
<li><a href="../fr474628/index.html">Pr√©sentation des nouveaux Microsoft Edge et Bing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>