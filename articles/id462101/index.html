<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚕️ 🖨️ 📂 Laporan dari Java Virtual Machine Language Summit 2019 🖖🏿 👩🏼‍🏭 🚶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini mengakhiri KTT JVM keduabelas. Seperti biasa, itu adalah acara hardcore dengan presentasi teknis pada mesin virtual dan bahasa yang berjalan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laporan dari Java Virtual Machine Language Summit 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/462101/"><img src="https://habrastorage.org/webt/nh/xk/cf/nhxkcfgwiztaulvnbccwhxgcpwe.png" align="right" width="250"><br><p>  Hari ini mengakhiri KTT <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM</a> keduabelas.  Seperti biasa, itu adalah acara hardcore dengan presentasi teknis pada mesin virtual dan bahasa yang berjalan di atasnya.  Seperti biasa, KTT diadakan di Santa Clara, di kampus Oracle.  Seperti biasa, ada lebih banyak orang yang ingin ke sini daripada di tempat-tempat lain: jumlah pesertanya tidak melebihi 120. Seperti biasa, tidak ada pemasaran, hanya jeroan. </p><br><p>  KTT ini sudah yang ketiga bagi saya, dan setiap kali saya mengunjunginya dengan senang hati, terlepas dari jetlag yang mengerikan.  Di sini Anda tidak hanya dapat mendengarkan laporan, tetapi juga mengenal orang-orang yang lebih baik dari dunia JVM, mengambil bagian dalam percakapan informal, mengajukan pertanyaan di lokakarya dan umumnya merasa terlibat dalam pencapaian besar. </p><br><p>  Jika Anda tidak menghadiri KTT, itu tidak masalah.  Sebagian besar laporan diposting di YouTube segera setelah pertemuan puncak.  Sebenarnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mereka sudah tersedia</a> .  Untuk mempermudah navigasi, saya akan menjelaskan secara singkat di sini semua laporan dan lokakarya yang berhasil saya hadiri. </p><a name="habracut"></a><br><h1>  29 Juli </h1><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ghadi Shayban - Clojure Futures</a> </h1><br><p> Ini bukan tentang fitur kompilasi Masa Depan dalam bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clojure</a> , seperti yang dipikirkan banyak orang, tetapi hanya tentang pengembangan bahasa, seluk-beluk pembuatan kode dan masalah yang mereka hadapi.  Sebagai contoh, ternyata di Clojure penting untuk membatalkan variabel lokal setelah penggunaan terakhir, karena jika kepala daftar yang dihasilkan secara malas dalam variabel lokal, maka memintasnya, node yang telah dilewati mungkin tidak dikumpulkan oleh pengumpul sampah, dan program mungkin macet dengan OutOfMemory .  Secara umum, kompiler J2 CIT sendiri melepaskan variabel setelah penggunaan terakhir, tetapi standar tidak menjamin ini dan, katakanlah, penerjemah HotSpot tidak. </p><br><p>  Itu juga menarik untuk belajar tentang penerapan pengiriman fungsi panggilan dinamis.  Saya juga belajar bahwa sampai saat ini, Clojure menargetkan JVM 6 dan hanya baru-baru ini beralih ke JVM 8. Sekarang penulis kompiler melihat invokedynamic. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alan Bateman dan Rickard Bäckman - Pembaruan Proyek Tenun</a> </h1><br><p>  Proyek Loom adalah utas ringan untuk Java.  Setahun yang lalu, Alan dan Ron sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membicarakan</a> proyek ini, dan sepertinya semuanya berjalan dengan baik dan akan siap.  Namun, proyek ini belum secara resmi memasuki Jawa dan masih sedang dikembangkan di cabang repositori yang terpisah.  Tentu saja, ternyata perlu menyelesaikan banyak detail. </p><br><p>  Banyak API standar dari ReentrantLock.lock ke Socket.accept sudah disesuaikan untuk serat: jika panggilan seperti itu dilakukan di dalam serat, status eksekusi akan disimpan, tumpukan akan dibatalkan dan benang sistem operasi akan dibebaskan untuk tugas-tugas lain sampai suatu peristiwa membangkitkan serat (misalnya, ReentrantLock.unlock).  Namun, misalnya, blok lama yang disinkronkan masih tidak berfungsi dan, sepertinya, tidak akan ada tanpa refactoring serius semua dukungan sinkronisasi di JVM.  Pelonggaran tumpukan lainnya tidak akan berfungsi jika ada bingkai asli di tumpukan antara awal serat dan breakpoint.  Dalam kedua kasus ini, tidak ada yang akan meledak, tetapi serat tidak akan membebaskan aliran. </p><br><p>  Ada banyak pertanyaan mengenai bagaimana Fiber membandingkan dengan kelas java.lang.Thread lama.  Setahun yang lalu, ada ide untuk menjadikan Fiber sebagai subclass dari Thread.  Sekarang mereka telah menolaknya dan menjadikannya entitas yang independen, karena meniru dalam setiap serat semua perilaku aliran reguler cukup mahal.  Dalam hal ini, Thread.currentThread () di dalam fiber akan mengembalikan blende yang dihasilkan, dan bukan thread asli di mana semuanya dijalankan.  Namun halangan tersebut akan berperilaku cukup baik (meskipun dapat memperlambat pekerjaan).  Ide penting adalah untuk tidak memberikan aliran media aktual di mana serat berjalan di dalam serat.  Ini bisa berbahaya karena serat dapat dengan mudah dipindahkan ke utas lainnya.  Tipuan akan terus berlanjut. </p><br><p>  Sangat mengherankan bahwa para peserta proyek telah mendorong beberapa perubahan persiapan ke dalam repositori JDK utama untuk membuat hidup mereka lebih mudah.  Sebagai contoh, di Java 13, metode doPrivileged <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditulis ulang</a> dari kode asli seluruhnya di Jawa, memperoleh peningkatan kinerja sekitar 50 kali lipat.  Mengapa ini proyek Loom?  Faktanya adalah bahwa metode khusus ini sangat sering muncul di tengah tumpukan, dan meskipun asli, serat dengan tumpukan ini tidak berhenti.  Dengan satu atau lain cara, proyek ini sudah menguntungkan. </p><br><p>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman proyek,</a> Anda dapat membaca dokumentasi dan mengunduh source tree, dan ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rakitan biner</a> yang dapat Anda ambil dan mainkan hari ini.  Kami berharap di tahun-tahun mendatang semuanya akan terintegrasi. </p><br><h1>  Brian Goetz - Workshop "Project Amber" </h1><br><p> Secara paralel, sebuah lokakarya sedang berlangsung tentang proyek Loom, tetapi saya pergi ke Amber.  Di sini kita secara singkat membahas tujuan proyek dan JEP utama di mana pekerjaan sedang berlangsung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencocokan pola</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catatan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis-jenis yang disegel</a> .  Kemudian seluruh diskusi menjadi masalah pribadi pelingkupan.  Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membicarakan hal ini</a> di konferensi Joker tahun lalu, pada prinsipnya, tidak ada yang sangat baru yang dikatakan.  Saya mencoba untuk mendorong sebuah ide dengan tipe serikat implisit seperti <code>if(obj instanceof Integer x || obj instanceof Long x) use(x.longValue())</code> , tetapi saya tidak melihat antusiasme. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jean Christophe Beyler, Arthur Eubanks dan Man Cao - Thread Sanitizing for Java</a> </h1><br><p>  Dalam segala hal, proyek luar biasa dari Google untuk mencari balapan menggunakan data dalam bentuk membaca dan menulis bidang non-volatil yang sama atau elemen array dari aliran yang berbeda tanpa mengatur hubungan yang terjadi sebelumnya.  Proyek ini awalnya ditulis sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul LLVM</a> untuk kode asli, dan sekarang telah diadaptasi untuk HotSpot.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> OpenJDK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">resmi</a> dengan milis dan repositori. </p><br><p>  Menurut penulis, masalahnya sekarang cukup bekerja, Anda bisa berkumpul dan bermain.  Selain itu, ia menemukan balap tidak hanya dalam kode Java, tetapi juga dalam kode perpustakaan asli.  Ras dalam kode mesin virtual itu sendiri tidak dicari, karena di sana semua sinkronisasi primitif ditulis dengan cara mereka sendiri, dan TSan tidak dapat mendeteksi mereka.  Menurut penulis, TSan tidak memberikan positif palsu. </p><br><p>  Masalah utama adalah kinerja.  Sekarang hanya interpreter yang diinstrumentasi untuk kode Java, masing-masing, kompilasi JIT benar-benar dinonaktifkan, dan interpreter, yang sudah lambat, melambat beberapa kali.  Tetapi jika Anda memiliki sumber daya yang cukup (Google memiliki, tentu saja, cukup), Anda kadang-kadang dapat menjalankan suite pengujian menggunakan TSan.  Juga direncanakan untuk menambah instrumentasi ke dalam JIT, tetapi ini adalah intervensi yang jauh lebih serius dalam JVM. </p><br><p>  Seseorang bertanya apakah menonaktifkan kompilasi JIT tidak memengaruhi hasil, karena beberapa ras mungkin tidak muncul pada penerjemah.  Pembicara tidak mengesampingkan kemungkinan ini, tetapi mengatakan bahwa mereka telah menemukan sejumlah besar balapan yang akan memakan waktu sangat lama untuk dikerjakan.  Jadi berhati-hatilah saat menjalankan proyek Anda di bawah TSan: Anda mungkin menemukan kebenaran yang tidak menyenangkan. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brian Goetz - Pembaruan Valhalla</a> </h1><br><p>  Semua orang menunggu tipe nilai di Jawa, tetapi tidak ada yang tahu kapan mereka akan muncul.  Namun, gerakannya semakin serius.  Sudah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">majelis</a> uji <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biner</a> dengan tonggak L2 saat ini.  Dalam rencana saat ini, Valhalla penuh akan datang pada tonggak L100, tetapi penulis masih optimis dan percaya bahwa lebih dari dua persen telah dilakukan. </p><br><p>  Jadi, dari sudut pandang bahasa, kami memiliki kelas dengan pengubah inline, yang diproses secara khusus oleh mesin virtual.  Contoh kelas seperti itu dapat tertanam dalam objek lain, dan array datar yang mengandung instance kelas inline juga dimungkinkan.  Contoh tidak memiliki header, yang berarti tidak ada identitas, kode hash dianggap oleh bidang, <code>==</code> juga oleh bidang, upaya untuk menyinkronkan atau <code>Object.wait()</code> pada kelas seperti itu akan meningkatkan IllegalMonitorStateException.  Menulis <code>null</code> ke variabel jenis ini, tentu saja, tidak akan berfungsi.  Namun, penulis menawarkan alternatif: jika Anda telah mendeklarasikan <code>Point</code> inline-class, maka Anda dapat mendeklarasikan field atau variabel tipe (surprise-surprise!) <code>Point?</code>  , dan kemudian akan ada objek penuh pada heap (seperti tinju) dengan header, identitas, dan <code>null</code> muat di sana. </p><br><p>  Pertanyaan terbuka yang serius tetap menjadi spesialisasi generik dan migrasi kelas yang ada (misalnya, <code>Optional</code> ) ke kelas inline agar tidak memecah kode yang ada (ya, orang menulis <code>null</code> ke variabel tipe <code>Optional</code> ).  Meskipun demikian, gambar tampak, dan celahnya terlihat. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">David Wrighton dan Neal Gafter - Jenis Nilai di CLR</a> </h1><br><p>  Itu mengejutkan bagi saya bahwa Neil Gufter yang sama, co-author dari Java puzzlers asli, sekarang bekerja di Microsoft pada .Net runtime.  Itu juga mengejutkan untuk melihat laporan tentang CLR (yang disebut .Net runtime) pada JVM LS.  Tetapi untuk berkenalan dengan pengalaman rekan kerja dari dunia lain selalu bermanfaat.  Laporan ini berbicara tentang variasi referensi dan petunjuk dalam CLR, tentang instruksi bytecode yang digunakan untuk tipe nilai, dan tentang betapa indahnya fungsi umum seperti pengurangan.  Sangat menarik untuk mengetahui bahwa salah satu tujuan dari tipe nilai dalam. Net adalah interop dengan kode asli.  Karena itu, lokasi bidang dalam tipe nilai benar-benar diperbaiki dan dapat diproyeksikan ke struktur tanpa transformasi.  JVM tidak pernah memiliki tugas seperti itu, dan apa yang harus dilakukan dengan interop asli - lihat di bawah. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vladimir Ivanov dan John Rose - Vektor dan Numerik di JVM</a> </h1><br><p>  Sekali lagi perbarui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan tahun lalu</a> .  Sekali lagi, pertanyaannya adalah mengapa mereka masih belum merilis apa pun, jika setahun yang lalu semuanya terlihat cukup bagus. </p><br><p>  Vektor adalah kumpulan beberapa angka, yang dalam perangkat keras dapat diwakili oleh register vektor tunggal seperti zmm0 untuk AVX512.  Dalam vektor, Anda dapat memuat data dari array, melakukan operasi padanya seperti perkalian elemen-bijaksana, dan melemparkannya kembali.  Semua operasi yang terdapat instruksi prosesor diinstrusi oleh kompiler JIT ke dalam instruksi ini.  Jumlah operasi sangat besar.  Jika ada yang hilang, implementasi lambat alternatif digunakan.  Objek perantara vektor idealnya tidak dibuat, analisis pelarian berfungsi.  Semua algoritma komputasi standar di-vektor-kan dengan bang, menggunakan semua kekuatan prosesor Anda. </p><br><p>  Sayangnya, sulit bagi penulis untuk tidak memiliki valgalla: analisis pelarian rapuh dan mungkin tidak bekerja dengan mudah.  Vektor ini hanya harus kelas inline, maka semua masalah akan hilang.  Tidak jelas apakah API ini bahkan dapat dirilis sebelum versi pertama Valgalla.  Tampaknya jauh lebih siap.  Di antara masalah yang disebut kesulitan dengan dukungan kode.  Ada banyak potongan berulang untuk ukuran register yang berbeda dan tipe data yang berbeda, sehingga sebagian besar kode dihasilkan dari templat dan menyakitkan untuk mempertahankannya. </p><br><p>  Penggunaannya juga tidak sempurna.  Tidak ada operator kelebihan di Jawa, sehingga matematika terlihat jelek: bukannya <code>max(va-vb*42, 0)</code> Anda harus menulis <code>va.lanewise(SUB, vb.lanewise(MUL, 42)).lanewise(MAX, 0)</code> .  Akan menyenangkan untuk memiliki akses ke AST lambdas seperti di C #.  Maka akan mungkin untuk menghasilkan operasi lambda kustom seperti <code>MYOP = binOp((va, vb) -&gt; max(va-vb*42, 0))</code> dan menggunakannya. </p><br><h1>  30 Juli </h1><br><p>  Hari kedua berlalu di bawah bendera kompilasi. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mark Stoodley - Dari AOT ke JIT dan seterusnya!</a> </h1><br><p>  Seorang karyawan IBM, anggota proyek JVM OpenJ9, berbicara tentang pengalaman mereka dengan kompilasi JIT dan AOT.  Selalu ada masalah: JIT adalah startup yang lambat, karena sedang memanas;  Biaya CPU untuk kompilasi.  AOT - kinerja suboptimal karena kurangnya profil (dimungkinkan untuk profil, tetapi non-sepele dan tidak selalu profil selama kompilasi cocok dengan profil saat eksekusi), lebih sulit untuk digunakan, mengikat ke platform target, OS, pengumpul sampah.  Beberapa masalah dapat diselesaikan dengan menggabungkan pendekatan: mulai dengan kode yang dikompilasi AOT dan kemudian diakhiri dengan JIT.  Alternatif yang baik untuk semua ini adalah caching JIT.  Jika Anda memiliki banyak mesin virtual (halo, microservices), semuanya beralih ke layanan terpisah - kompiler JIT (ya, JITaaS), di mana semuanya seperti orang dewasa, orkestrasi, penyeimbangan beban.  Layanan ini mengkompilasi.  Cukup sering, ia dapat memberikan kode yang sudah jadi ke metode tertentu, karena metode ini sudah dikompilasi di JVM lain.  Ini sangat meningkatkan pemanasan, menghilangkan konsumsi sumber daya dari layanan JVM Anda, dan umumnya mengurangi total konsumsi sumber daya. </p><br><p>  Secara umum, JITaaS bisa menjadi kata kunci berikutnya di dunia JVM.  Sayangnya, saya tidak mengetahui apakah ini bisa dimainkan sekarang atau masih merupakan pengembangan tertutup. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Christian Wimmer - Meningkatkan Gambar Asli GraalVM</a> </h1><br><p>  GraalVM Native Image adalah aplikasi Java yang dikompilasi ke dalam kode asli yang berjalan tanpa JVM (tidak seperti modul yang dikompilasi menggunakan kompiler AOT seperti jaotc).  Lebih tepatnya, ini bukan aplikasi Java.  Untuk bekerja dengan benar, ia membutuhkan dunia tertutup, yaitu, semua kode harus terlihat pada tahap kompilasi, tanpa Class.forName.  Anda dapat refleksi dan menangani metode, tetapi ketika Anda mengkompilasi Anda harus secara khusus memberitahu kelas dan metode mana yang akan digunakan melalui refleksi. </p><br><p>  Hal lain yang menyenangkan adalah inisialisasi kelas.  Banyak kelas diinisialisasi selama kompilasi.  Yaitu, bidang statis Anda akan dihitung secara default oleh kompiler dan hasilnya akan ditulis ke gambar yang dikumpulkan, dan ketika Anda memulai aplikasi, itu hanya dibaca.  Ini diperlukan untuk mencapai kualitas kompilasi yang lebih baik: setiap pelipatan konstan dapat dilakukan jika nilai-nilai bidang statis diketahui oleh kompiler.  Semuanya baik-baik saja dengan JIT, penerjemah melakukan inisialisasi statis, dan kemudian mengetahui konstanta, Anda dapat mengkompilasi.  Dan ketika membangun aplikasi asli, Anda harus menipu.  Ini, tentu saja, mengarah pada efek psikedelik yang menyenangkan.  Jadi kelas biasanya diinisialisasi dalam urutan mereka diakses, dan selama kompilasi urutan ini tidak diketahui dan inisialisasi di tempat lain dimungkinkan.  Jika ada referensi melingkar antara inisialisasi kelas, Anda dapat melihat perbedaan dalam perilaku kode JVM dan pada gambar asli. </p><br><h1>  Workshop Schatzl - Hotspot GC. </h1><br><p>  Mengatasi semua rasa sakit yang terkait dengan pengumpul sampah.  Sayangnya, saya paling banyak mendengarkan.  Saya ingat bahwa memori memori OS telah dibahas, termasuk Xmx menjijikkan untuk semua orang.  Ada kabar baik: di Java 13 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi baru</a> -XX ditambahkan: SoftMaxHeapSize.  Sejauh ini, hanya didukung oleh kolektor ZGC, tetapi G1 juga dapat mengejar ketinggalan.  Ini menetapkan batas ukuran tumpukan, yang tidak boleh dilampaui kecuali dalam situasi darurat, ketika itu tidak berhasil secara berbeda.  Dengan demikian, Anda dapat mengatur Xmx besar (katakanlah, sama dengan ukuran seluruh RAM) dan beberapa SoftMaxHeapSize yang masuk akal.  Maka JVM akan menjaga dirinya sendiri dalam sebagian besar waktu, tetapi pada beban puncak itu masih tidak akan membuang OutOfMemoryError, tetapi akan mengambil lebih banyak memori dari OS.  Saat beban turun, memori akan kembali. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mei-Chin Tsai - JIT dan AOT di CLR</a> </h1><br><p>  Microsoft Mei-Chin Tsai berbicara tentang fitur kompilasi JIT dan AOT di CLR.  Kompilasi AOT telah berkembang untuk mereka untuk waktu yang lama, tetapi awalnya (ngen.exe) dilakukan pada platform target, semacam seperti pertama kali dimulai (jika Anda memiliki Windows, cari file * .ni.dll di folder Windows).  File diperoleh tergantung pada versi Windows lokal dan bahkan pada DLL-ek lainnya.  Dengan demikian, jika ketergantungan diperbarui, semua modul asli harus dikompilasi ulang.  Pada generasi kedua (crossgen), penulis mengkompilasi aplikasi dan modul yang relatif tidak tergantung pada versi dan dependensi perangkat keras dan OS.  Ini memperlambat kode karena panggilan ketergantungan sekarang harus dibuat secara virtual virtual.  Masalah ini diselesaikan dengan menghubungkan JIT dan mengkompilasi ulang kode panas selama aplikasi.  Kemudian kami berbicara tentang kompilasi multi-level (berjenjang) (sepertinya di CLR ini masih dalam masa pertumbuhan, sementara itu telah berkembang di Jawa selama setidaknya sepuluh tahun) dan tentang rencana masa depan untuk membuat AOT benar-benar lintas platform. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wei Kuai dan Xiaoming Gu - Mempercepat Kinerja JVM dengan JWarmUp</a> </h1><br><p>  Rekan-rekan Alibaba mempresentasikan pendekatan mereka terhadap masalah pemanasan JVM.  Mereka menggunakan JVM untuk banyak layanan web.  Pada prinsipnya, startup yang sangat cepat tidak begitu penting, karena penyeimbang selalu dapat menunggu sampai mesin dinyalakan dan baru kemudian mulai mengirim permintaan ke sana.  Namun, masalahnya adalah bahwa mesin tidak melakukan pemanasan tanpa permintaan: kode yang menjelaskan logika untuk memproses permintaan tidak dipanggil, yang berarti tidak dikompilasi.  Ini akan dikompilasi ketika permintaan pertama tiba, yaitu, tidak peduli berapa banyak penyeimbang menunggu, akan ada kegagalan kinerja pada permintaan pertama.  Sebelumnya, mereka mencoba menyelesaikan ini dengan melemparkan permintaan palsu ke layanan yang akan datang sebelum mengirim permintaan nyata ke sana.  Pendekatannya menarik, tetapi agak sulit untuk menghasilkan aliran palsu yang akan menyebabkan kompilasi semua kode yang diperlukan. </p><br><p>  Masalah yang terpisah adalah deoptimisasi.  Dalam ribuan kueri pertama, satu <code>if</code> selalu berjalan di sepanjang cabang pertama, kompiler JIT umumnya melemparkan yang kedua, memasukkan perangkap deoptimisasi di sana untuk mengurangi ukuran kode.  Tetapi permintaan 1001 pergi ke cabang kedua, deoptimisasi berhasil dan seluruh metode pergi ke penerjemah.  Sementara statistik sedang dikompilasi lagi, sementara metode ini dikompilasi oleh kompiler C1, kemudian oleh profil lengkap oleh kompiler C2, pengguna akan mengalami penurunan.  Dan kemudian dalam metode yang sama lain <code>if</code> dapat dioptimalkan, dan semuanya akan berjalan pada yang baru. </p><br><p>  JWarmUp memecahkan masalah sebagai berikut.  Selama menjalankan pertama dari layanan, log kompilasi ditulis selama beberapa menit: ia mencatat metode mana yang dikompilasi dan informasi profil yang diperlukan oleh cabang, jenis, dll. Jika layanan ini dimulai kembali, segera setelah startup, semua kelas dari log diinisialisasi dan metode log dikompilasi dengan mempertimbangkan profil sebelumnya.  Akibatnya, kompiler akan bekerja dengan baik pada saat startup, setelah itu penyeimbang akan mulai mengirim permintaan ke JVM ini.  Pada saat ini, semua kode panas dia sudah dikompilasi. </p><br><p>  Perlu dicatat bahwa masalah mulai cepat tidak diselesaikan di sini.  Peluncuran bahkan bisa lebih lambat karena banyak metode dikompilasi, beberapa di antaranya mungkin diperlukan hanya beberapa menit setelah peluncuran.  Tetapi log ternyata dapat digunakan kembali: tidak seperti AOT, Anda dapat meningkatkan layanan pada arsitektur yang berbeda atau dengan pengumpul sampah yang berbeda dan menggunakan kembali log sebelumnya. </p><br><p>  Penulis telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencoba</a> untuk waktu yang lama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk</a> mendorong JWarmUp ke OpenJDK.  Sejauh ini tidak berhasil, tetapi pekerjaan terus berjalan.  Masalah utamanya adalah tambalan lengkap cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mudah diakses</a> oleh Anda sendiri di server Code Review, sehingga Anda dapat dengan mudah menerapkannya ke sumber HotSpot dan membangun JVM sendiri dengan JWarmUp. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Juan Fumero - TornadoVM</a> </h1><br><p>  Ini adalah makalah penelitian dari Manchester, tetapi penulis mengklaim bahwa proyek tersebut telah dilaksanakan di beberapa tempat.  Ini juga merupakan add-on untuk OpenJDK, yang membuatnya cukup mudah untuk mentransfer kode Java tertentu ke GPU, iGPU, FPGA atau hanya memparalelkannya ke inti prosesornya.  Untuk mengkompilasi pada GPU, mereka menggunakan GraalVM di mana mereka membangun backend mereka - TornadoJIT.  Metode Java yang ditulis dengan benar pergi secara transparan ke perangkat yang sesuai.  Benar, mereka mengatakan kompilasi pada FPGA bisa memakan waktu beberapa jam, tetapi jika tugas Anda dianggap sebulan, mengapa tidak.  Beberapa tolok ukur (misalnya, transformasi Fourier diskrit) lebih dari seratus kali lebih cepat dari Jawa telanjang, yang pada prinsipnya diharapkan.  Proyek ini sepenuhnya diunggah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> , di mana Anda juga dapat menemukan publikasi ilmiah tentang topik tersebut. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Maurizio Cimadomore - Dekonstruksi Panama</a> </h1><br><p>  Semua lagu yang sama - proyek lama, setiap presentasi puncak, setahun yang lalu semuanya tampak cukup siap, tetapi masih belum ada rilis.  Ternyata sejak itu fokusnya telah bergeser. </p><br><p>  Gagasan proyek adalah peningkatan interope dengan kode asli.  Semua orang tahu betapa menyakitkannya menggunakan JNI.  Sangat menyakitkan.  Proyek Panama membatalkan rasa sakit ini: menggunakan kelas Java jextract dihasilkan dari file * .h perpustakaan asli, yang cukup nyaman untuk digunakan dengan memanggil metode asli.  Di sisi C / C ++, Anda tidak perlu menulis satu baris sama sekali.  Selain itu, semuanya menjadi jauh lebih cepat: overhead pada panggilan ke Jawa-&gt; asli dan asli-&gt; Jawa jatuh pada waktu.  Apa lagi yang Anda inginkan? </p><br><p>  Ada masalah yang telah ada selama beberapa waktu - mentransfer array data ke kode asli.  Hingga saat ini, metode yang direkomendasikan adalah DirectByteBuffer, yang memiliki banyak masalah.  Salah satu yang paling serius adalah seumur hidup yang tidak dikelola (buffer akan hilang ketika pemungut sampah mengambil objek Java yang sesuai).  Karena ini dan masalah lain, orang menggunakan Unsafe, yang, dengan uji tuntas, dapat dengan mudah menempatkan seluruh mesin virtual. </p><br><p>  Ini berarti Anda memerlukan akses memori normal baru di luar heap Java.  Alokasi, pengakses terstruktur, penghapusan eksplisit.  Accessors terstruktur - sehingga Anda tidak perlu menghitung sendiri offset jika Anda perlu menulis, misalnya, <code>struct { byte x; int y; }[5]</code> <code>struct { byte x; int y; }[5]</code>  <code>struct { byte x; int y; }[5]</code> .  Sebaliknya, Anda pernah menggambarkan tata letak struktur ini dan kemudian melakukan, misalnya, <code>VarHandle</code> , yang dapat membaca semua <code>x</code> dengan melompati <code>y</code> .  Dalam hal ini, tentu saja, harus selalu ada pemeriksaan perbatasan, seperti pada array Java biasa.  Selain itu, harus ada larangan akses ke area yang sudah ditutup.  Dan ini ternyata menjadi tugas yang tidak sepele jika kita ingin mempertahankan kinerja pada tingkat Tidak Aman dan memungkinkan akses dari banyak utas.  Singkatnya, tonton videonya, sangat menarik. </p><br><h1>  Workshop: Vladimir Kozlov - Proyek Metropolis </h1><br><p>  Proyek Metropolis menggabungkan semua upaya untuk menulis ulang bagian JVM di Jawa.  Bagian utamanya hari ini adalah kompiler Graal.  Dalam beberapa tahun terakhir, telah berkembang sangat baik dan sudah ada pembicaraan nyata tentang penggantian penuh untuk C2 yang menua.  Dulu ada masalah bootstrap: grail mulai perlahan, karena ia sendiri harus dikompilasi atau ditafsirkan JIT.  Kemudian kompilasi AOT muncul (ya, tujuan utama proyek kompilasi AOT adalah bootstrap dari grail itu sendiri).  Tetapi dengan AOT, grail memakan porsi yang cukup dari tumpukan aplikasi Java yang mungkin tidak benar-benar ingin berbagi tumpukannya.  Sekarang kita telah belajar bagaimana mengubah grail menjadi perpustakaan asli menggunakan Graal Native Image, yang pada akhirnya memungkinkan kita untuk mengisolasi kompiler dari tumpukan umum.  Dengan kinerja puncak dari kode yang disusun oleh grail, masih ada masalah pada beberapa tolok ukur.  Sebagai contoh, grail tertinggal C2 dalam intrinsik dan vektorisasi.  Namun, berkat analisis pembalikan dan pelarian yang sangat kuat, ia hanya memecah C2 pada kode fungsional, di mana banyak objek yang tidak dapat diubah dan banyak fungsi kecil dibuat.  Jika Anda menulis di Rock dan masih tidak menggunakan grail, jalankan untuk menggunakan.  Selain itu, dalam versi terbaru JDK cukup sepele untuk melakukan beberapa kunci, semuanya sudah ada dalam kit. </p><br><h1>  31 Juli </h1><br><h1>  Kevin Bourrillion - Anotasi Nullness untuk Java </h1><br><p>  Kevin mengumumkan proyek baru, tetapi meminta untuk tidak berbicara di depan umum dan tidak memposting rekaman pidatonya di YouTube.  Maaf sekali  ,        . </p><br><h1> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dmitry Petrashko — Gradual typing for Ruby at Scale with Sorbet</a> </h1><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sorbet</a>   (!) Ruby,       Ruby   .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stripe</a>         Ruby   , ,    .  ,     . </p><br><h1> Lightning Talks </h1><br><p> -     .   Remi Forax     ,       ,   .    ,      : </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1156627887165804544"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>      ,   -     ,   . </p><br><h1> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Erik Meijer — Differentiable Programming</a> </h1><br><p>             ML  AI      ,     .     ,    Facebook   —        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getafix</a> , --,       ,   .          . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,    .  ,    ,        . </p><br><p>    .   .    OpenJDK Committer Workshop. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462101/">https://habr.com/ru/post/id462101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462083/index.html">Struktur data cepat dengan contoh. Bagian satu: daftar tertaut</a></li>
<li><a href="../id462087/index.html">Menguji pembantu rumah tangga yang cerdas (vodka, kefir, foto orang lain)</a></li>
<li><a href="../id462091/index.html">Solusi tugas dengan pwnable.kr cmd1, cmd2, asm, blukat. Memotong penyaringan di Linux. Menulis shellcode dengan pwntools</a></li>
<li><a href="../id462095/index.html">Bekerja dengan cahaya dan optik: bagaimana memulai karir di universitas - pengalaman lulusan empat program master khusus</a></li>
<li><a href="../id462097/index.html">Tur hijau muda</a></li>
<li><a href="../id462107/index.html">Marathon Gratis “Data Besar dan Pahlawan Super: Pengalaman Analisis Data Pertama Anda”</a></li>
<li><a href="../id462109/index.html">Lihat hampir tidak terlihat, juga dalam warna: teknik untuk memvisualisasikan objek melalui diffuser</a></li>
<li><a href="../id462111/index.html">Bagaimana kami menguji beberapa basis data time series</a></li>
<li><a href="../id462113/index.html">Lingkungan yang tidak tercela: tidak seorang pun boleh menulis kode kualitas</a></li>
<li><a href="../id462115/index.html">Pasang langit berbintang di WebGL dalam 1009 byte JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>