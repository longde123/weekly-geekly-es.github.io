<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗜️ 🅿️ 🍑 JavaScript捆绑和性能：最佳实践 🤙🏿 👨🏻‍💼 🙇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现在，在本世纪之交的时候，该批判性地重新评估最近认为正确的事情，并找出它是否在今天已经失去意义。 昨天的最佳做法有时会成为今天的反模式。 

  

 这篇文章的作者（我们今天将发表其翻译）将以使用React创建的简单Hello World应用程序为例，探讨捆绑JavaScript项目的三种方法。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript捆绑和性能：最佳实践</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483682/"> 现在，在本世纪之交的时候，该批判性地重新评估最近认为正确的事情，并找出它是否在今天已经失去意义。 昨天的最佳做法有时会成为今天的反模式。 <br><br> <a href="https://habr.com/ru/company/ruvds/blog/483682/"><img src="https://habrastorage.org/webt/tp/h1/jh/tph1jh5adpkk21ojvgqsadxjga4.jpeg"></a> <br><br> 这篇文章的作者（我们今天将发表其翻译）将以使用React创建的简单Hello World应用程序为例，探讨捆绑JavaScript项目的三种方法。 他列举的一些示例包括阅读模块构建器的基础知识，例如<a href="https://webpack.js.org/">Webpack</a> ，它似乎是当今最受欢迎的工具。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">方法一：绝对将所有东西都捆绑在一起（看起来就像一个大球）</font> </h2><br> 主要思想：不要使用这种方法。 <br><br> 通过这种方法，模块构建器仅用于打包捆绑中的所有内容-依赖项和应用程序代码。 输出结果就像一个大毛线球。 在我的示例中，这包括<code>react</code> ， <code>react-dom</code>和应用程序本身的代码。 包含所有项目代码的单个捆绑包已连接到页面： <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"bundle.[hash].min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 在HTTP / 2发行之前，此模式可以某种方式被认为是可以接受的，因为它的使用减少了浏览器在加载页面资料时执行的HTTP请求的数量。 但是鉴于当今大多数站点都使用HTTP / 2，因此此模式已成为反模式。 <br><br> 怎么了 事实是，当使用HTTP / 2时，许多请求的执行不再像以前那样在系统上产生相同的负载。 结果，将代码打包到单个大包中不再给项目带来明显的优势。 <br><br> 使用这种方法，浏览器缓存的有效组织变得复杂。 例如，在一个简单的应用程序中仅更改一行代码将更改捆绑哈希，并使存储所有项目代码的缓存无效。 结果，所有回访者都必须再次下载整个站点代码，即使该代码与上次访问时下载的代码没有99％的差异。 在这里，由于相同数据从服务器到客户端的反复传输，我们正在处理网络资源的不合理使用。 <br><br> 如今， <a href="&amp;xid=25657,15700023,15700186,15700191,15700259,15700271&amp;usg=ALkJrhhHL_P2zIJV2-ml9AO59xWxFmUPiA#feat=">超过95％的客户端</a>都支持HTTP / 2。 在2019年， <a href="httparchive.org/reports/state-of-the-web">大多数</a>服务器都实现了该协议。 在此处了解有关在2019年使用HTTP / 2的更多信息。 <br><br><h2>  <font color="#3AC1EF">方法2：将项目代码和第三方库的代码分开包装（代码分离）</font> </h2><br> 主要思想：请使用这种方法。 <br><br> 让我们考虑上一节中讨论的内容，并通过将项目代码与依赖代码分开来改善浏览器缓存的情况。 这解决了上述情况下的问题，当我们稍微更改项目代码，然后将更新发布到生产环境中时。 现在，只有存储项目自己代码的<code>index</code>捆绑包的哈希值发生了变化，而<code>vendor</code>捆绑包的哈希值保持不变。 返回到更新站点的访问者将仅使用这种方法下载修改后的<code>index</code>文件，这将节省一些网络资源。 <br><br> 如果我们谈论Webpack，那么要实施此策略，您将需要有关代码分离的<a href="https://webpack.js.org/guides/code-splitting">其他设置</a> 。 在他们的帮助下，我们通知捆绑程序相关代码在哪里。 一种简单方便的检测此类代码的方法是，在对应文件的路径中存在<code>node_modules</code> ，因为所有依赖项代码都存储在此文件夹中。 <br><br> 脚本连接代码如下所示： <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"vendor.[hash].min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"index.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 这是使用HTTP / 2时的瀑布时间线，用于加载页面。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/d02/f85/bf5d02f8583eb58f1094dfaa592822e1.png"></div><br>  <i><font color="#999999">瀑布页面加载时间表</font></i> <br><br> 这是朝正确方向迈出的一步。 但是我们可以继续优化捆绑。 如果考虑到所有这些，您可以理解某些项目依赖项的更改频率要低于其他项目。 也许<code>react</code>和<code>react-dom</code>最不可能改变<code>react</code>并且当一个库被更新时，另一个库也被更新。 结果，我们可以得出结论，这两个库可以分组为一个逻辑片段，可以与其他依赖项分开，而其他依赖项的变化比<code>react</code>和<code>react-dom</code>更频繁。 意识到这个想法，我们得到以下几点： <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"vendor.react.[hash].min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"vendor.others.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"index.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 如果我们继续发展这个想法，我们可以决定网站访问者可能不需要下载所有项目代码即可仅查看一页。 在冬天，我们中的一些人倾向于增加体重-因此包含应用程序代码的<code>index</code>文件会随着时间增长。 在某些时候，可能会证明项目代码有理由进一步分离， <a href="https://reacttraining.com/react-router/web/guides/code-splitting">动态加载</a>各个组件，甚至组织各个模块的<a href="https://webpack.js.org/guides/code-splitting/">预加载</a> 。 <br><br> 在我看来，这种级别的代码分离仍然令人生畏。 它仍然看起来像实验技术（之类的东西，其中微妙的错误很可能会显现出来）。 但是对我来说很明显，强大的代码分离是Web开发行业前进的方向。 也许由于浏览器对JavaScript模块的支持，我们最终将能够完全放弃Webpack之类的捆绑软件，而仅将单个代码模块提供给客户端。 看到所有这些将我们引向何方将很有趣！ <br><br><h2>  <font color="#3AC1EF">方法3：将公共CDN用于某些依赖项的代码</font> </h2><br> 主要思想：不要使用这种方法。 <br><br> 如果您是那些在Web开发中有点过时的人（像我一样），那么您可能会有一种内在的感觉，我们可以连接<code>vendor.react</code>文件，这在“方法编号No. 2“，使用公共CDN资源： <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">crossorigin</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/react@16.12.0/umd/react.production.min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script crossorigin src=<span class="hljs-string"><span class="hljs-string">"https://unpkg.com/react-dom@16.12.0/umd/react-dom.production.min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"index.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 我注意到使用这种方法时，有必要<a href="https://webpack.js.org/configuration/externals/">告诉</a> Webpack项目收集者，他应该从捆绑中排除<code>react</code>和<code>react-dom</code>代码。 <br><br> 乍一看，所有这些看起来都很合理，但是这种方法存在一些我建议考虑的缺点。 <br><br><h3>  <font color="#3AC1EF">▍减号1：使用相同依赖文件的不同站点？</font>  <font color="#3AC1EF">不再...</font> </h3><br> 老派的开发人员一直希望，如果所有站点都链接到相同的CDN资源并使用与我们站点相同的React版本，那么如果浏览器的缓存中已经存在React代码，则访问我们站点的访问者会希望，不会浪费时间重新加载它。 这将严重提高在工作模式下显示我们网站页面的速度。 是的，关于此主题的React <a href="https://reactjs.org/docs/cdn-links.html">文档</a>看起来很有希望。 因此，可以肯定的是，一些开发人员使用此模式。 对不对 <br><br> 尽管这在早期可以很好地实现，但是最近在浏览器中，为了提高安全性，他们开始实现缓存共享机制。 我们正在谈论的一个事实是，即使在理想条件下，当两个站点使用通过相同CDN链接加载的同一库时，也会为每个域独立下载代码，并且出于隐私原因，缓存最终落入沙箱中分配给特定域。  <a href="https://andydavies.me/blog/2018/09/06/safari-caching-and-3rd-party-resources/">事实证明</a> ，该机制已经在Safari中实现（显然，自2013年以来就已经存在？！）。 如果我们谈论的是Chrome 77，那么现在要启用缓存分离，您需要使用一个特殊的<a href="https://chromestatus.com/feature/5730772021411840">标志</a> 。 <br><br> 可以合理地假设，随着在更多浏览器中实现缓存共享，公共可用CDN的使用将减少。 <br><br><h3>  <font color="#3AC1EF">▍减号2：浪费在辅助操作上的系统资源（每个域）</font> </h3><br>  <a href="https://habr.com/ru/company/ruvds/blog/481574/">这里的</a>想法是，使用CDN会增加系统的负载，因为即使在发送HTTP请求之前，浏览器也需要解决许多问题：DNS名称解析，TCP连接，SSL握手。 为了连接到该站点，浏览器在任何情况下都必须执行这些操作，但是如果它也被迫连接到CDN，则会增加其负担。 <br><br> 这是一个瀑布图，说明了使用公共CDN资源中的脚本加载页面的过程。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cd/3eb/c0a/7cd3ebc0aebe48e5819fc27993b016a0.png"></div><br>  <i><font color="#999999">使用公共CDN资源加载页面的瀑布时间线</font></i> <br><br> 红色椭圆形突出显示执行查询之前发生操作的区域。 对于一个简单的Hello World应用程序来说，这似乎有点过多。 <br><br> 随着我的简单示例的发展和壮大，有时会想在其中使用自己的字体。 例如-取自Google字体。 这意味着此类延迟的数量只会增加，因为您必须连接到相应的域才能下载字体。 在这里，将站点的所有资源托管在其自己的主域（当然，该主域位于基于Cloudflare或Cloudfront的项目自己的CDN资源的后面）的想法似乎很有吸引力。 <br><br> 如果在我们的示例中，我们切换到从站点的主域下载两个React依赖项，这将导致以下事实：页面加载的瀑布式时间表将变得更加准确。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/82a/12e/f3282a12e8626574f5a13e9a10540417.png"></div><br>  <i><font color="#999999">不使用公共CDN资源的页面的瀑布图加载计划</font></i> <br><br><h3>  <font color="#3AC1EF">▍负号3：不同站点使用不同版本的依赖关系</font> </h3><br> 我使用React <a href="https://docs.google.com/spreadsheets/d/12sNP1msbarCFw3v0tFyIpa8Nu0LDWGqDKjLRKkVb8gU/edit">对</a> 32个最大的站点进行了一些研究。 不幸的是，我发现其中只有10％的人使用公开可用的CDN资源来下载React。 然而，事实证明，考虑到所有研究站点都使用的React版本，这并不重要。 在理想情况下，浏览器缓存不会分离，并且所有站点都可以组织并使用来自相同公共CDN的相同脚本版本。 实际上，不同站点使用的React版本存在很大差异。 这破坏了共享浏览器缓存的想法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/fc9/4b0/876fc94b0752931da06e97f3132b3584.png"></div><br>  <i><font color="#999999">不同站点使用的React版本</font></i> <br><br> 如果您首先使用React打开一个受欢迎的站点，然后再使用另一个站点，那么事实证明这两个站点使用相同版本的React的机会很小。 <br><br> 在研究过程中，我发现了有关这些React网站的更多有趣信息。 也许它们对您来说也很有趣： <br><br><ul><li> 在2/3站点上，Webpack用于构建代码。 </li><li>  87％的网站使用HTTP / 2，这比58％的平均值还高。 </li><li> 大多数项目（约56％）都托管字体本身。 </li></ul><br>  <a href="https://docs.google.com/spreadsheets/d/12sNP1msbarCFw3v0tFyIpa8Nu0LDWGqDKjLRKkVb8gU/edit">这是</a>我的实验<a href="https://docs.google.com/spreadsheets/d/12sNP1msbarCFw3v0tFyIpa8Nu0LDWGqDKjLRKkVb8gU/edit">的</a>原始数据。 <br><br><h3>  <font color="#3AC1EF">▍减号4：不履行问题</font> </h3><br> 不幸的是，如今，那些使用公共可用CDN资源的用户不仅面临页面加载速度方面的问题，而且还面临其他一些麻烦： <br><br><ul><li> 安全问题。 除了那些旨在解决浏览器中的缓存共享问题之外，使用公开可用的CDN资源还存在一些安全问题。 例如，如果黑客入侵了可公开访问的CDN资源，则他们可以非常小心地将恶意JavaScript代码注入库中。 这样的代码将具有在客户端上执行的站点代码的所有特权，它将能够处理已登录站点的用户的数据。 </li><li> 隐私问题。 许多公司从第三方资源的请求中收集用户数据。 从理论上讲，如果在所有站点上都使用了公共CDN资源来下载依赖项代码或字体，则该CDN资源将能够跟踪用户会话及其在Internet上的工作特征。 类似的资源将能够对它们感兴趣的内容进行假设（例如，出于广告目的）。 而这一切-无需使用cookie！ </li><li> 单点故障。 在多个域中分配站点正常运行所需的材料会增加机会，由于这些域之一的问题，客户端将只能下载使页面恢复正常工作所需的部分材料。 坦白地说，可以使用JavaScript解决此类问题，但是为此，网站开发人员将不得不付出额外的努力。 </li></ul><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 很明显，未来取决于方法二。 <br><br> 使用HTTP / 2（例如Cloudflare或Cloudfront）将自己的CDN资源托管在服务器前面。 将代码分成小段，以便有效使用浏览器缓存。 将来，由于浏览器已开始实现对该技术的支持，因此将站点代码划分成的片段可能会变得更小，达到各个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript模块</a>的大小。 <br><br>  <b>亲爱的读者们！</b> 您是否在Web项目中使用代码分离技术？ <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483682/">https://habr.com/ru/post/zh-CN483682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483670/index.html">您想要了解的有关MAC地址的所有信息</a></li>
<li><a href="../zh-CN483674/index.html">二进制神经网络如何工作以及为什么它们将在2020年流行</a></li>
<li><a href="../zh-CN483676/index.html">评估实施端到端营销分析系统的有效性和成本</a></li>
<li><a href="../zh-CN483678/index.html">开发速度极快的Python程序</a></li>
<li><a href="../zh-CN483680/index.html">应避免的常见编程缺陷</a></li>
<li><a href="../zh-CN483684/index.html">PHP摘要171（2020年1月1日至13日）</a></li>
<li><a href="../zh-CN483686/index.html">想要在2020年超越自我的Web开发人员的32个技巧</a></li>
<li><a href="../zh-CN483688/index.html">Node.js中约30倍的并发加速</a></li>
<li><a href="../zh-CN483698/index.html">LoRaWAN如何帮助构建现代物联网</a></li>
<li><a href="../zh-CN483704/index.html">1月13日至19日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>