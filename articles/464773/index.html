<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ò üë®üèæ‚Äçüîß üèè Mecanografiado asincr√≥nico en una rica aplicaci√≥n de Internet y decoradores para combatirlo üôèüèæ üëÜ üíÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde el advenimiento de async / await , Typescript ha publicado muchos art√≠culos que ensalzan este enfoque de desarrollo ( hackernoon , blog.bitsrc.i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mecanografiado asincr√≥nico en una rica aplicaci√≥n de Internet y decoradores para combatirlo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464773/"><p> Desde el advenimiento de <code>async</code> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">await</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Typescript</a> ha publicado muchos art√≠culos que ensalzan este enfoque de desarrollo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hackernoon</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog.bitsrc.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com</a> ).  Los usamos desde el principio en el lado del cliente (cuando los generadores ES6 admit√≠an menos del 50% de los navegadores).  Y ahora quiero compartir mi experiencia, porque la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecuci√≥n paralela</a> no es todo lo que ser√≠a bueno saber en este camino. </p><a name="habracut"></a><br><p>  Realmente no me gusta el art√≠culo final: algo puede ser incomprensible.  En parte debido al hecho de que no puedo proporcionar c√≥digo propietario, solo para describir el enfoque general.  Por lo tanto: </p><br><ul><li>  no dudes en cerrar la pesta√±a sin leer </li><li>  si lo logra, solicite detalles poco claros </li><li>  Con mucho gusto aceptar√© consejos y cr√≠ticas de los m√°s persistentes y completamente descubiertos hasta el punto. </li></ul><br><p>  <strong>Lista de tecnolog√≠as centrales:</strong> </p><br><ul><li>  El proyecto est√° escrito principalmente en Typecript usando varias bibliotecas Javascript.  La biblioteca principal es ExtJS.  React es inferior en moda a la moda, pero es m√°s adecuado para un producto empresarial con una interfaz rica: muchos componentes listos para usar, tablas bien dise√±adas listas para usar, un rico ecosistema de productos relacionados para simplificar el desarrollo. </li><li>  Servidor multiproceso as√≠ncrono. </li><li>  RPC a trav√©s de Websocket se utiliza como transporte entre el cliente y el servidor.  La implementaci√≥n es similar a .NET WCF. <br><ul><li>  Cualquier objeto es un servicio. </li><li>  Cualquier objeto puede transmitirse tanto por valor como por referencia. </li></ul></li><li>  La interfaz de solicitud de datos se asemeja a GraphQL de Facebook, solo en Typecript. </li><li>  Comunicaci√≥n bidireccional: la inicializaci√≥n de la actualizaci√≥n de datos se puede iniciar tanto desde el cliente como desde el servidor. </li><li>  El c√≥digo asincr√≥nico se escribe secuencialmente mediante el uso de las funciones <code>async</code> / en <code>await</code> de Typercipt. </li><li>  La API del servidor se genera en Typecript: si cambia, la compilaci√≥n lo mostrar√° inmediatamente en caso de error. </li></ul><br><p>  <strong>Cual es la salida</strong> </p><br><p>  Le dir√© c√≥mo trabajamos con esto y qu√© hicimos para la ejecuci√≥n segura y no competitiva de c√≥digo asincr√≥nico: nuestros decoradores de Typercipt que implementan la funcionalidad de las colas.  Desde lo b√°sico hasta la soluci√≥n de la condici√≥n de carrera y otras dificultades que surgen durante el proceso de desarrollo. </p><br><h2 id="kak-strukturirovany-dannye-poluchaemye-s-servera">  C√≥mo se estructuran los datos recibidos del servidor </h2><br><p>  El servidor devuelve un objeto principal que contiene datos (otros objetos, colecciones de objetos, filas, etc.) en sus propiedades en forma de gr√°fico.  Esto se debe, entre otras cosas, a la aplicaci√≥n en s√≠: </p><br><ul><li>  convierte el an√°lisis de datos / ML en un gr√°fico dirigido de nodos manejadores. </li><li>  cada nodo a su vez puede contener su propio gr√°fico incrustado </li><li>  los gr√°ficos tienen dependencias: los nodos pueden ser "heredados" y los nuevos nodos son creados por su "clase". </li></ul><br><p>  Pero la estructura de consulta en forma de gr√°fico se puede aplicar en casi cualquier aplicaci√≥n, y GraphQL, hasta donde yo s√©, tambi√©n menciona esto en su especificaci√≥n. </p><br><p>  Estructura de datos de ejemplo: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   interface IParent { ServerId: string; Nodes: INodes; // INodes -     INode } //     interface INodes&lt;TNode extends INode&gt; extends ICollection { IndexOf(item: TNode): number; Item(index: number): TNode; // ...     } //    interface INode extends IItem { Guid: string; Name: string; DisplayName: string; Links: ILinks; // ILinks -    Info: INodeInfo; //    -  } //      interface ILink { Guid: string; DisplayName: string; SourceNode: INode; //   -  TargetNode: INode; //   ,   } interface INodeInfo { Component: IComponent; ConfigData: IData; }</span></span></code> </pre><br><h2 id="kak-klient-poluchaet-dannye">  ¬øC√≥mo recibe los datos un cliente? </h2><br><p>  Es simple: cuando solicita una propiedad de un objeto de un tipo no escalar, RPC devuelve <code>Promise</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Nodes = Parent.Nodes; <span class="hljs-comment"><span class="hljs-comment">// Nodes -&gt; Promise&lt;INodes&gt;</span></span></code> </pre><br><h3 id="asinhronnost-bez-callback-hell">  Asincron√≠a sin un "infierno de devoluci√≥n de llamada". </h3><br><p>  Para organizar un c√≥digo asincr√≥nico "secuencial", se utiliza la funcionalidad <code>async</code> / <code>await</code> <code>async</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent: IParent</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    let Nodes = await parent.Nodes; //       await Nodes.forEachParallel(async function(node): Promise&lt;void&gt; { await RenderNode(node); //          }); }</span></span></code> </pre><br><p>  No tiene sentido detenerse en √©l en detalle, en el centro ya hay suficiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">material detallado</a> .  Aparecieron en Typecript en 2016.  Hemos estado utilizando este enfoque desde que apareci√≥ en la rama de caracter√≠sticas del repositorio de ScriptScript, es por eso que hemos tenido problemas durante mucho tiempo y ahora estamos trabajando con placer.  Desde hace alg√∫n tiempo, y en producci√≥n. </p><br><p>  Brevemente, la esencia para aquellos que no est√°n familiarizados con el tema: </p><br><p>  Tan pronto como agregue la palabra clave <code>async</code> a la funci√≥n, devolver√° autom√°ticamente la <code>Promise&lt;_&gt;</code> .  Caracter√≠sticas de tales funciones: </p><br><ul><li>  Las expresiones dentro de las funciones <code>async</code> con <code>await</code> (que devuelven <code>Promise</code> ) detendr√°n la ejecuci√≥n de la funci√≥n y continuar√°n despu√©s de resolver la <code>Promise</code> esperada. </li><li>  Si se produce una excepci√≥n en la funci√≥n <code>async</code> , la <code>Promise</code> devuelta ser√° rechazada con esta excepci√≥n. </li><li>  Al compilar en c√≥digo Javascript, habr√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generadores</a> para el est√°ndar ES6 ( <code>function*</code> lugar de <code>async function</code> y <code>yield</code> lugar de <code>await</code> ) o c√≥digo aterrador con <code>switch</code> para ES5 (m√°quina de estado).  <code>await</code> es una palabra clave que espera el resultado de una promesa.  En el momento de la reuni√≥n, durante la ejecuci√≥n del c√≥digo, la funci√≥n <code>ShowNodes</code> detiene y, mientras espera datos, Javascript puede ejecutar alg√∫n otro c√≥digo. </li></ul><br><p>  En el c√≥digo anterior, la colecci√≥n tiene un m√©todo <code>forEachParallel</code> que llama a una devoluci√≥n de llamada as√≠ncrona para cada nodo en paralelo.  Al mismo tiempo, <code>await</code> antes de <code>Nodes.forEachParallel</code> esperar√° todas las devoluciones de llamada.  Dentro de la implementaci√≥n - <code>Promise.all</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *            * @param items  * @param callbackfn  * @param [thisArg]   ,      this  callbackfn */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachParallel</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: IItemArray&lt;T&gt;, callbackfn: (value: T, index: int, items: IItemArray&lt;T&gt;</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">&gt;, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thisArg</span></span></span><span class="hljs-function">?: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xCount = items ? <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> items.Count : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!xCount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xActions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> | any&gt;&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xCount</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">for</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">let</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; xCount; i++</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">let</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xItem</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Item</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xActions</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">] = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecuteCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xItem, callbackfn, i, items, thisArg</span></span></span><span class="hljs-function">); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">await</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Promise</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">all</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xActions</span></span></span><span class="hljs-function">); } /**   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callbackfn</span></span></span><span class="hljs-function"> */ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecuteCallback</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Promise</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; | T, callbackfn: (value: T, index: int, items: IItemArray&lt;T&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> | any&gt;, <span class="hljs-attr"><span class="hljs-attr">index</span></span>: int, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: IItemArray&lt;T&gt;, thisArg?: any): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xItem = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> item; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> callbackfn.call(thisArg, xItem, index, items); }</code> </pre><br><p>  Este es el az√∫car sint√°ctico: tales m√©todos deben usarse no solo para sus colecciones, sino tambi√©n para las matrices Javascript est√°ndar. </p><br><p>  La funci√≥n <code>ShowNodes</code> parece extremadamente no √≥ptima: cuando solicitamos otra entidad, la esperamos cada vez.  La conveniencia es que dicho c√≥digo se puede escribir r√°pidamente, por lo que este enfoque es bueno para la creaci√≥n r√°pida de prototipos.  En la versi√≥n final, debe usar el lenguaje de consulta para reducir la cantidad de llamadas al servidor. </p><br><h2 id="yazyk-zaprosov">  Lenguaje de consulta </h2><br><p>  Hay varias funciones que se utilizan para "construir" una solicitud de datos del servidor.  Ellos "le dicen" al servidor qu√© nodos del gr√°fico de datos deben devolver en la respuesta: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       item    Promise  , *      properties */</span></span> selectAsync&lt;T extends IItem&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: T, properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;T&gt;; <span class="hljs-comment"><span class="hljs-comment">/** *   items,       properties */</span></span> selectAsyncAll&lt;T extends ICollection&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: T[], properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;T[]&gt;; <span class="hljs-comment"><span class="hljs-comment">/**    selectAsync     */</span></span> select&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: T, properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): T; <span class="hljs-comment"><span class="hljs-comment">/**    selectAsync     */</span></span> selectAll&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: T[], properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): T[];</code> </pre><br><p>  Ahora veamos la aplicaci√≥n de estas funciones para solicitar los datos integrados necesarios con una llamada al servidor: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parentPoint: IParent</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       IParent -    selectAsync ( // Promise,  ). let Parent = await selectAsync(parentPoint, parent =&gt; [ //           selectAll(parent.Nodes, nodes =&gt; [node.Name, node.DisplayName]) // [node.Name, node.DisplayName] -        ]); //      Parent.Nodes ... }</span></span></code> </pre><br><p>  Un ejemplo de una consulta un poco m√°s compleja con informaci√≥n profundamente incrustada: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     parent.Nodes  selectAsyncAll,    let Parent = await selectAsyncAll(parent.Nodes, nodes =&gt; [ //    : select(node, node =&gt; [ node.Name, node.DisplayName, selectAll(node.Links, link =&gt; [ link.Guid, link.DisplayName, select(link.TargetNode, targetNode =&gt; [targetNode.Guid]) ]), select(node.Info, info =&gt; [info.Component]) //    IInfo    IComponent,   ,   ,        ]) ]);</span></span></code> </pre><br><p>  El lenguaje de consulta ayuda a evitar solicitudes innecesarias al servidor.  Pero el c√≥digo nunca es perfecto, y ciertamente contendr√° varias solicitudes competitivas y, como resultado, la condici√≥n de la carrera. </p><br><h2 id="race-condition-i-puti-resheniya">  Condici√≥n de carrera y soluciones </h2><br><p>  Como nos suscribimos a eventos del servidor y escribimos c√≥digo con una gran cantidad de solicitudes as√≠ncronas, puede ocurrir una condici√≥n de carrera cuando la funci√≥n <code>FuncOne</code> <code>async</code> <code>FuncOne</code> interrumpe, esperando <code>Promise</code> .  En este momento, puede venir un evento del servidor (o de la siguiente acci√≥n del usuario) y, despu√©s de ejecutarse competitivamente, cambiar el modelo en el cliente.  Entonces <code>FuncOne</code> despu√©s de resolver la promesa, puede recurrir, por ejemplo, a recursos ya eliminados. </p><br><p>  Imagine una situaci√≥n tan simplificada: el objeto <code>IParent</code> tiene un delegado de servidor <code>IParent</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> Parent.OnSynchronize.AddListener(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  .   ,  . });</span></span></code> </pre><br><p>  Se llama cuando se actualiza la lista de nodos <code>INodes</code> en el servidor.  Luego, en el siguiente escenario, es posible una condici√≥n de carrera: </p><br><ol><li>  Provocamos la eliminaci√≥n asincr√≥nica del nodo del cliente, esperando la finalizaci√≥n para eliminar el objeto del cliente <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClickRemoveNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node: INode</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> removedOnServer: boolean = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Parent.RemoveNode(node); <span class="hljs-comment"><span class="hljs-comment">//     if (removedOnServer) .... }</span></span></code> </pre> </li><li>  A trav√©s de <code>Parent.OnSynchronize</code> , se <code>Parent.OnSynchronize</code> una actualizaci√≥n del evento de la lista de nodos. </li><li>  <code>Parent.OnSynchronize</code> procesa y elimina el objeto del cliente. </li><li>  <code>async OnClickRemoveNode()</code> contin√∫a ejecut√°ndose despu√©s de la primera <code>await</code> y se intenta eliminar un objeto de cliente ya eliminado. </li></ol><br><p>  Puede verificar la existencia de un objeto de cliente en <code>OnClickRemoveNode</code> .  Este es un ejemplo simplificado y en √©l es normal una verificaci√≥n similar.  Pero, ¬øy si la cadena de llamadas es m√°s complicada?  Por lo tanto, usar un enfoque similar despu√©s de cada <code>await</code> es una mala pr√°ctica: </p><br><ul><li>  El c√≥digo tan hinchado es complicado de soportar y extender. </li><li>  El c√≥digo no funciona seg√∫n lo previsto: <code>OnClickRemoveNode</code> la eliminaci√≥n en <code>OnClickRemoveNode</code> y la eliminaci√≥n real del objeto del cliente se produce en otro lugar.  No debe haber una violaci√≥n de la secuencia definida por el desarrollador, de lo contrario habr√° errores de regresi√≥n. </li><li>  Esto no es lo suficientemente confiable: si olvida hacer una verificaci√≥n en alg√∫n lugar, entonces habr√° un error.  El peligro es, en primer lugar, que una verificaci√≥n olvidada no conduzca a un error local y en un entorno de prueba, y para los usuarios con un retraso de red m√°s largo, ocurrir√°. </li><li>  ¬øY si el controlador al que pertenecen estos controladores puede ser destruido?  Despu√©s de cada <code>await</code> para comprobar su destrucci√≥n? </li></ul><br><p>  Surge otra pregunta: ¬øqu√© pasa si hay muchos m√©todos competitivos similares?  Imagina que hay m√°s: </p><br><ul><li>  Agregar un nodo </li><li>  Actualizaci√≥n de nodo </li><li>  Agregar / quitar enlaces </li><li>  M√©todo de conversi√≥n de nodos m√∫ltiples </li><li>  Comportamiento complejo de la aplicaci√≥n: cambiamos el estado de un nodo y el servidor comienza a actualizar los nodos que dependen de √©l. </li></ul><br><p>  Se requiere una implementaci√≥n arquitect√≥nica, que en principio elimina la posibilidad de errores debido a condiciones de carrera, acciones paralelas del usuario, etc.  La soluci√≥n correcta para eliminar el cambio simult√°neo del modelo del cliente o servidor es implementar una secci√≥n cr√≠tica con una cola de llamadas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los decoradores mecanografiados</a> ser√°n √∫tiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> para etiquetar declarativamente tales funciones de controlador as√≠ncrono competitivas. </p><br><p>  <strong>Describimos los requisitos y caracter√≠sticas clave de tales decoradores:</strong> </p><br><ol><li>  En el interior, se debe implementar una cola de llamadas a funciones asincr√≥nicas.  Dependiendo del tipo de decorador, una llamada de funci√≥n puede ser puesta en cola o rechazada si hay otras llamadas en ella. </li><li>  Las funciones marcadas requerir√°n un contexto de ejecuci√≥n para unirse a la cola.  Debe crear expl√≠citamente una cola o hacerlo autom√°ticamente en funci√≥n de la Vista a la que pertenece el controlador. </li><li>  Se requiere informaci√≥n sobre la destrucci√≥n de la instancia del controlador (por ejemplo, la propiedad <code>IsDestroyed</code> ).  Para evitar que los decoradores realicen llamadas en cola despu√©s de que se destruya el controlador. </li><li>  Para el controlador de Vista, agregamos la funcionalidad de aplicar una m√°scara transl√∫cida para excluir acciones en el momento en que se ejecuta la cola e indicar visualmente el procesamiento en progreso. </li><li>  Todos los decoradores deben finalizar con una llamada a <code>Promise.done()</code> .  En este m√©todo, debe implementar el <code>handler</code> excepciones no controladas.  Una cosa muy √∫til: <br><ul><li>  Las excepciones que ocurrieron en <code>Promise</code> no son detectadas por el controlador de errores est√°ndar (que, por ejemplo, muestra una ventana con texto y un rastro fijo), por lo que es posible que no las note (si no supervisa la consola todo el tiempo durante el desarrollo).  Y el usuario no los ver√° en absoluto, esto dificultar√° el soporte.  Nota: es posible suscribirse para manejar el evento de <code>unhandledrejection</code> , pero solo Chrome y Edge lo admiten: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'unhandledrejection'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// handling... });</span></span></code> </pre> </li><li>  Como marcamos la funci√≥n de controlador de eventos <code>async</code> m√°s alta como decoradores, obtenemos el error de seguimiento de la pila completa. </li></ul></li></ol><br><p>  Ahora damos una lista aproximada de tales decoradores con una descripci√≥n y luego mostramos c√≥mo se pueden aplicar. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * : * 1.      * 2.      ,   . * *  ,  :   ,         */</span></span> @Lock <span class="hljs-comment"><span class="hljs-comment">/** * : *     ,     . * *  ,     :   ,   . */</span></span> @LockQueue <span class="hljs-comment"><span class="hljs-comment">/** *  LockQueue .  -         * *   ,       . ,   . */</span></span> @LockBetween <span class="hljs-comment"><span class="hljs-comment">/** * : *       ,   . *     . :     ,     300 .       . */</span></span> @LockDeferred(<span class="hljs-number"><span class="hljs-number">300</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,    ,     : interface ILockTarget { /** * ,   View,   .   ,        ,     ,        */ GetControllerView?(): IView; /**  true     */ IsDestroyed: boolean; }</span></span></code> </pre><br><p>  Las descripciones son bastante abstractas, pero tan pronto como vea un ejemplo de uso con explicaciones, todo se aclarar√°: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILockTarget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** ,      .      */</span></span> private View: IView; public GetControllerView(): IView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.View; } <span class="hljs-comment"><span class="hljs-comment">/**      . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickRemoveNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**     . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickRemoveLink(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**     */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickAddNewNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerUpdateNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerAddLink(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerAddNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -   */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerRemoveNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -       */</span></span> @LockBetween private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerSynchronize(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -    (/warning/error/...) */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerUpdateNodeStatus(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**       */</span></span> @LockDeferred(<span class="hljs-number"><span class="hljs-number">300</span></span>) private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnSearchFieldChange(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } }</code> </pre><br><p>  Ahora analizaremos un par de escenarios t√≠picos de posibles errores y su eliminaci√≥n por parte de los decoradores: </p><br><ol><li>  El usuario inicia una acci√≥n: <code>OnClickRemoveNode</code> , <code>OnClickRemoveLink</code> .  Para un procesamiento adecuado, es necesario que no haya otros controladores de ejecuci√≥n en la cola (ya sea cliente o servidor).  De lo contrario, por ejemplo, tal error es posible: <br><ul><li>  El modelo en el cliente todav√≠a se actualiza al estado actual del servidor </li><li>  Iniciamos la eliminaci√≥n del objeto antes de que se complete la actualizaci√≥n (hay un controlador <code>OnServerSynchronize</code> en <code>OnServerSynchronize</code> en la cola).  Pero este objeto ya no est√° all√≠, solo que la sincronizaci√≥n completa a√∫n no se ha completado y a√∫n se muestra en el cliente. <br>  Por lo tanto, todas las acciones iniciadas por el usuario, el decorador de <code>Lock</code> deben rechazar si hay otros controladores en la cola con el mismo contexto de cola.  Dado que el servidor es as√≠ncrono, esto es especialmente importante.  S√≠, Websocket env√≠a solicitudes secuencialmente, pero si el cliente rompe la secuencia, recibimos un error en el servidor. </li></ul></li><li>  Iniciamos la adici√≥n de un nodo: <code>OnClickAddNewNode</code> .  <code>OnServerSynchronize</code> , los eventos <code>OnServerAddNode</code> provienen del servidor. <br><ul><li>  <code>OnClickAddNewNode</code> tom√≥ la cola (si hubiera algo en ella, el decorador de <code>Lock</code> de este m√©todo rechazar√≠a la llamada) </li><li>  <code>OnServerSynchronize</code> , <code>OnServerAddNode</code> , ejecutado secuencialmente despu√©s de <code>OnClickAddNewNode</code> , no compitiendo con √©l. </li></ul></li><li>  La cola tiene <code>OnServerUpdateNode</code> <code>OnServerSynchronize</code> y <code>OnServerUpdateNode</code> .  Supongamos que durante la ejecuci√≥n del primero, el usuario cierra <code>GraphController</code> .  Luego, la segunda llamada a <code>OnServerUpdateNode</code> no se debe realizar autom√°ticamente para no tomar medidas en el controlador destruido, lo que garantiza un error.  Para esto, la interfaz <code>ILockTarget</code> tiene <code>IsDestroyed</code> : el decorador comprueba el indicador sin ejecutar el siguiente controlador desde la cola. <br>  Beneficio: no es necesario escribir <code>if (!this.IsDestroyed())</code> despu√©s de cada <code>await</code> . </li><li>  Se desencadenan cambios en m√∫ltiples nodos.  <code>OnServerSynchronize</code> , los eventos <code>OnServerUpdateNode</code> provienen del servidor.  Su ejecuci√≥n competitiva conducir√° a errores irreproducibles.  Pero desde  <code>LockQueue</code> est√°n marcados por los <code>LockBetween</code> <code>LockQueue</code> y <code>LockBetween</code> , se ejecutar√°n secuencialmente. </li><li>  Imagine que los nodos pueden tener gr√°ficos de nodos anidados dentro de ellos.  <code>GraphController #1</code> ,       ‚Äî   <code>GraphController #2</code> . , <code>GraphController</code> -    ,   (  ‚Äî         ), ..     .  : <br><ul><li>  </li><li>    </li><li>    <code>GraphController #2</code> ,     ,    . </li></ul></li><li> <code>OnSearchFieldChange</code>   ,       .         -  .  <code>@LockDeferred(300)</code>     300 :         ,     ,    300 .  ,       .  : <br><ul><li>   ,   500 ,         .     ‚Äî        <code>OnSearchFieldChange</code> ,     . </li><li>      <code>OnSearchFieldChange</code>    ‚Äî        ,   . </li></ul></li></ol><br><h2 id="chto-nuzhno-znat-pri-ispolzovanii-dekoratorov">       </h2><br><ol><li>  Deadlock:     <code>Handler1</code> ,    ,   <code>await</code>   <code>Handler2</code> ,  <code>LockQueue</code> ,    <code>Handler2</code> ‚Äî <code>Handler1</code>    . </li><li>  ,     View      . :            ,      ‚Äî                . </li></ol><br><h2 id="profilirovanie-zaprosov-k-serveru">     </h2><br><p>    ,     ,        .  : </p><br><ul><li>       - <code>&lt;Class&gt;</code> . <code>&lt;Method&gt;</code> =&gt; <code>&lt;Time&gt;</code> (  ). </li><li>       . </li><li>        . </li></ul><br><h2 id="desert">  </h2><br><p> ,    ,           ,    .        ?         ?  : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILockTarget</span></span></span><span class="hljs-class"> </span></span>{ private View: IView; public GetControllerView(): IView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.View; } <span class="hljs-comment"><span class="hljs-comment">/**     . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> RunBigDataCalculations(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Start(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UpdateSmth(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> End(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CleanUp(); } <span class="hljs-comment"><span class="hljs-comment">/**   . */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnChangeNodeState(node: INode): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetNodeData(node); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UpdateNode(node); } }</code> </pre><br><p>   : </p><br><ol><li>  <code>RunBigDataCalculations</code> . </li><li>  <code>await Start();</code> </li><li>   /  (  ) </li><li>   <code>await Start();</code> ,   <code>await UpdateSmth();</code>      . </li></ol><br><p> : </p><br><ol><li>  <code>RunBigDataCalculations</code> . </li><li>    <code>OnChangeNodeState</code> ,          (..  ). </li><li>   <code>await GetNodeData(node);</code> </li><li>   /  (  ) </li><li>   <code>await GetNodeData(node);</code> ,   <code>await UpdateNode(node);</code>      . </li></ol><br><p>      - .  : </p><br><ul><li>   : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IQueuedDisposableLockTarget extends ILockTarget { <span class="hljs-comment"><span class="hljs-comment">/**     . Lock          IsDisposing() === true */</span></span> IsDisposing(): boolean; SetDisposing(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre> <br><ul><li>        : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueuedDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller: IQueuedDisposableLockTarget</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      let xQueue = GetQueue(controller); // 1. ,     -,   -   if (xQueue.Empty) { controller.Dispose(); return; } // 2.  ,     " ",     ,   . controller.SetDisposing(); // 3.   finally   xQueue.finally(() =&gt; { debug.assert(!IsDisposed(controller), "-      ,  "); controller.Dispose(); }); }</span></span></code> </pre><br><p>  ,          .    <code>QueuedDispose</code>     : </p><br><ul><li>         .       . </li><li>   <code>QueuedDispose</code>     <code>controller</code> .         ‚Äî  ExtJS     . </li></ul><br><p> <strong></strong> </p><br><p>  ,          , ..         . ,      ?    ,  . </p><br><p>    ,      : </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    vk.com</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    Telegram</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464773/">https://habr.com/ru/post/464773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464759/index.html">Docenas de libros √°giles que el gerente del proyecto necesitar√° en 2020</a></li>
<li><a href="../464761/index.html">Un peque√±o mod convierte a Tesla en una estaci√≥n de video vigilancia</a></li>
<li><a href="../464763/index.html">Benchmarks para servidores en Linux: una selecci√≥n de herramientas abiertas</a></li>
<li><a href="../464765/index.html">Configurando FreePBX + GoIP</a></li>
<li><a href="../464769/index.html">C√≥mo Badoo hizo posible entregar 200k fotos por segundo</a></li>
<li><a href="../464775/index.html">21 de septiembre Badoo PHP Meetup # 3: Rendimiento</a></li>
<li><a href="../464777/index.html">¬øPor qu√© const no acelera el c√≥digo C / C ++?</a></li>
<li><a href="../464779/index.html">Sobre las abejas hedonistas, la forma en que las personas las hacen trabajar y los drones</a></li>
<li><a href="../464781/index.html">Televisores inteligentes: CRT a HDR</a></li>
<li><a href="../464785/index.html">Beneficios no competitivos de Beeline</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>