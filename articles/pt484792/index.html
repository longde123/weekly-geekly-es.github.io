<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçø üë∑üèª üöô Otimiza√ß√£o de modelos 3D para a cena do jogo üîÅ üòª üèúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo conclui uma s√©rie de publica√ß√µes do est√∫dio Krasnodar Plarium sobre v√°rios aspectos do trabalho com modelos 3D no Unity. Artigos anteriore...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otimiza√ß√£o de modelos 3D para a cena do jogo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/">  Este artigo conclui uma s√©rie de publica√ß√µes do est√∫dio Krasnodar Plarium sobre v√°rios aspectos do trabalho com modelos 3D no Unity.  Artigos anteriores: <a href="https://habr.com/ru/company/plarium/blog/440690/">‚ÄúRecursos de trabalho com o Mesh in Unity‚Äù</a> , <a href="https://habr.com/ru/company/plarium/blog/443870/">‚ÄúUnity: edi√ß√£o procedural do Mesh‚Äù</a> , <a href="https://habr.com/ru/company/plarium/blog/447820/">‚ÄúImporta√ß√£o de modelos 3D para o Unity e armadilhas‚Äù</a> , <a href="https://habr.com/ru/company/plarium/blog/451794/">‚ÄúRecuo de pixel na digitaliza√ß√£o de texturas‚Äù</a> . <br><br>  H√° quase dois anos, escrevemos <a href="https://habr.com/ru/company/plarium/blog/348494/">um artigo</a> no qual falamos sobre a op√ß√£o de otimizar a geometria 3D em uma cena com restri√ß√µes no √¢ngulo da c√¢mera e na rota√ß√£o dos objetos correspondentes.  N√£o houve muito fluxo desde ent√£o, mas a oportunidade de melhorar a solu√ß√£o, considerar diferentes abordagens e espionar os outros est√° assombrando as mentes dos desenvolvedores.  Neste artigo, descreveremos uma vers√£o aprimorada do algoritmo com base na pintura de pol√≠gonos e tamb√©m falaremos sobre tentativas de transferir parte deste trabalho para um pacote 3D. <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3>  Cortar em cena </h3><br>  J√° consideramos o princ√≠pio b√°sico desse algoritmo no artigo acima: extinguimos todos os efeitos e objetos transparentes, pintamos pol√≠gonos n√£o processados ‚Äã‚Äãcom uma cor e processados ‚Äã‚Äãcom diferentes cores, renderizamos e extra√≠mos o resultado.  Na vers√£o antiga, eles pintavam para que tudo fosse preto redundante e apenas um tri√¢ngulo fosse marcado em vermelho. <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">Nos coment√°rios</a> a esse artigo, um dos leitores apontou a possibilidade de otimizar o algoritmo estabelecendo uma correspond√™ncia individual entre o conjunto de pol√≠gonos e algum conjunto de n√∫meros √∫nicos.  Ent√£o ser√° poss√≠vel processar mais de um tri√¢ngulo da mesma maneira.  Considere esta op√ß√£o. <br><br>  Nesse caso, assim como na √∫ltima vez, √© suposto que algum pr√©-treinamento esteja conectado √† desativa√ß√£o de todos os objetos assobiados no palco e objetos que garantem n√£o afetar a visibilidade do modelo de destino.  As visualiza√ß√µes da c√¢mera s√£o processadas quase de forma independente; elas s√£o conectadas apenas por um buffer de √≠ndice comum de pol√≠gonos vis√≠veis.  Al√©m disso, √© realizado um pr√©-processamento de geometria para cada √¢ngulo, durante o qual os pol√≠gonos s√£o girados e voltados para a c√¢mera ( <b>face</b> posterior).  Isso √© feito porque, em um determinado est√°gio do algoritmo, uma malha tempor√°ria √© criada com um n√∫mero significativamente maior de v√©rtices que o original.  Esse n√∫mero pode facilmente exceder o limite de 65.535, o que exigir√° gestos adicionais nos c√°lculos e levar√° a um desempenho reduzido.  De qualquer forma, esses pol√≠gonos ser√£o exclu√≠dos, pois sua cor n√£o cair√° no quadro.  No entanto, devido ao fato de que cada tri√¢ngulo gera tr√™s v√©rtices de lixo, a elimina√ß√£o antecipada de pol√≠gonos desnecess√°rios facilita o est√°gio principal do algoritmo e reduz os custos de mem√≥ria. <br><br>  Haja algum modelo 3D, cuja geometria √© representada por uma malha.  Para pintar um pol√≠gono espec√≠fico em uma cor √∫nica, voc√™ precisa pintar todos os seus v√©rtices nessa cor.  Como no caso geral um v√©rtice pode pertencer a pol√≠gonos diferentes, n√£o ser√° poss√≠vel resolver o problema de frente.  N√£o importa como pintamos qualquer v√©rtice, ao renderizar, sua cor se espalhar√° por todos os tri√¢ngulos que o possuem, de acordo com o algoritmo de interpola√ß√£o na lateral da placa de v√≠deo. <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>Um exemplo de interpola√ß√£o de cores ao exibir pol√≠gonos com v√©rtices comuns</i> <br><br>  Portanto, √© necess√°rio, de alguma forma, dividir a malha em pol√≠gonos independentes separados, preservando a topologia e a geometria do objeto.  Dictum factum.  Transformamos as matrizes de tri√¢ngulos e v√©rtices de forma que, para cada tri√¢ngulo, sejam criados 3 v√©rtices √∫nicos, cuja posi√ß√£o √© determinada pelos v√©rtices correspondentes da malha original.  Vale a pena notar que, no caso geral, essa malha ter√° um n√∫mero significativamente maior de v√©rtices em compara√ß√£o com o original.  E se esse n√∫mero exceder 65 535, ao criar a malha, voc√™ dever√° especificar o formato de indexa√ß√£o apropriado. <br><br><div class="spoiler">  <b class="spoiler_title">Converter a malha original em uma malha com v√©rtices exclusivos para cada pol√≠gono</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br>  Agora voc√™ precisa designar os pol√≠gonos dessa malha para que, ap√≥s a opera√ß√£o de renderiza√ß√£o, seja poss√≠vel determinar qual deles apareceu na tela.  Como j√° mencionado, geramos cores exclusivas para pol√≠gonos e pintamos cada tr√™s v√©rtices na cor correspondente.  O resultado √© uma nova malha, que chamamos <b>de Malha colorida em bytes</b> . <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>Malha colorida em bytes</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Colora√ß√£o de malha na qual cada v√©rtice pertence a apenas um pol√≠gono</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br>  Lembre-se da colora√ß√£o.  √â hora de renderizar.  Realizamos renderiza√ß√£o em 3D para todos os √¢ngulos da c√¢mera e, ao processar cada um deles, reabastecemos o buffer de √≠ndices de pol√≠gonos exclusivos cujas cores foram detectadas no quadro.  Para os c√°lculos da c√¢mera, voc√™ precisa desativar o anti-aliasing para evitar o aparecimento de novas cores devido √† interpola√ß√£o dos pixels vizinhos. <br><br><div class="spoiler">  <b class="spoiler_title">Leitura e armazenamento de cores de diferentes √¢ngulos de c√¢mera</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform ‚Äî         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br>  Vale ressaltar que, devido √† discretiza√ß√£o, alguns tri√¢ngulos podem n√£o ser exibidos devido ao tamanho especialmente pequeno de sua proje√ß√£o na tela, e n√£o porque algo se sobreponha a eles ou eles estejam do lado errado.  Implementamos uma vers√£o conservadora do algoritmo.  Nesse caso, o <b>AABB da</b> proje√ß√£o do tri√¢ngulo na tela √© calculado e, se pelo menos um de seus lados for menor que o lado texel da imagem, esse pol√≠gono ser√° marcado como vis√≠vel.  Essa abordagem protege contra artefatos ao executar o algoritmo com uma resolu√ß√£o menor que a resolu√ß√£o da tela do dispositivo de destino.  Se voc√™ ignorar pol√≠gonos pequenos, o resultado tamb√©m ser√° aceit√°vel, desde que a resolu√ß√£o da textura de renderiza√ß√£o usada seja superior √† resolu√ß√£o das telas dos dispositivos pretendidos. <br><br>  Implementamos esse algoritmo de corte no <b>Unity</b> e o usamos para otimizar objetos est√°ticos cujos modelos s√£o encontrados na cena mais de uma vez em v√°rias posi√ß√µes.  Este √© principalmente o cen√°rio: pedras, √°rvores, est√°tuas, vasos, etc., que se refere √† pr√©-fabricada frequentemente usada.  Gostar√≠amos de otimizar esses objetos anteriormente, no est√°gio de cria√ß√£o em um pacote 3D, mas quem sabe em qual pose fantasmag√≥rica o designer de n√≠vel deseja colocar seus candelabros favoritos. <br><br>  Aparar o conjunto de objetos do mesmo tipo com essa ferramenta reduz o tamanho da cena, pois durante o <b>lote est√°tico, os</b> dados da malha <b>pr√©-fabricada</b> comum s√£o copiados de qualquer maneira no est√°gio de constru√ß√£o quantas vezes os objetos desenhados ativos com essa malha s√£o representados na cena.  Nosso m√©todo tamb√©m libera espa√ßo em atlas de textura, como o <b>lightmap</b> .  Usamos o espa√ßo economizado para aumentar os detalhes das partes dos modelos que sobreviveram √† limpeza. <br><br><h3>  Corte 3D </h3><br>  No entanto, √© melhor que o artista possa cortar tudo desnecess√°rio em seu editor, reduzindo assim o n√∫mero de etapas da prepara√ß√£o do conte√∫do.  Isso se justifica quando o modelo √© usado em uma cena com apenas uma rota√ß√£o predefinida em rela√ß√£o √† c√¢mera.  Anteriormente, os objetos que eram exatamente voltados para o usu√°rio por um lado eram frequentemente simplificados manualmente antes da integra√ß√£o no projeto.  √â importante observar que implementar essa simplifica√ß√£o programaticamente no <b>Unity √©</b> muito mais dif√≠cil devido √† complexidade do empacotamento do desenvolvimento <b>UV</b> ; portanto, a automa√ß√£o no est√°gio de um pacote 3D √†s vezes facilita a vida de um artista. <br><br>  Uma das ferramentas para trabalhar com modelos 3D em nossa empresa √© o <b>Blender</b> .  N√≥s subimos nele.  Parece que um software "adulto", como o <b>Blender</b> , deve ter uma funcionalidade semelhante.  No entanto, descobriu-se que ele n√£o deveria.  Eu tive que ver minha pr√≥pria bicicleta. <br><br>  A primeira id√©ia foi usar a ferramenta de sele√ß√£o familiar - essencialmente repita parte do trabalho manual do artista para um √¢ngulo de c√¢mera: selecione pol√≠gonos vis√≠veis, inverta a sele√ß√£o e exclua.  O plano era o seguinte: mover a c√¢mera, determinar a proje√ß√£o <b>AABB</b> do modelo em cada posi√ß√£o, solicitar o resultado da sele√ß√£o dos pol√≠gonos da √°rea correspondente √† <b>AABB</b> , obter a uni√£o do conjunto de pol√≠gonos da visualiza√ß√£o atual com os anteriores e excluir pol√≠gonos n√£o selecionados no final. <br><br>  No entanto, durante a implementa√ß√£o do script, foi encontrada uma desvantagem significativa em termos da tarefa.  As ferramentas de sele√ß√£o no <b>Blender (sele√ß√£o de ret√¢ngulo, sele√ß√£o de c√≠rculo)</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">perdem a precis√£o</a> com o aumento do n√∫mero de elementos selecionados por unidade de √°rea da tela (alguns pol√≠gonos permanecem desmarcados), o que torna imposs√≠vel o uso em nossas ferramentas de automa√ß√£o.  Fato interessante: no mesmo <b>3ds Max,</b> esse problema n√£o √© observado. <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>Destacando de longe no <b>Blender</b></i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>Resultado da sele√ß√£o</i> <br><br>  A pr√≥xima tentativa teve como objetivo resolver o problema de frente: enviamos raios da c√¢mera atrav√©s de cada pixel da janela de visualiza√ß√£o e observamos quais pol√≠gonos foram os primeiros a se cruzar com pelo menos um raio.  N√£o esper√°vamos resultados precisos com essa abordagem, mas valia a pena tentar.  O resultado √© √≥bvio: produtividade muito baixa ao processar na <b>CPU</b> ou os mesmos orif√≠cios com um pequeno n√∫mero de raios. <br><br>  No entanto, estabelecemos uma base para a implementa√ß√£o de uma abordagem mais avan√ßada.  A id√©ia era selecionar um certo n√∫mero de pontos aleat√≥rios em cada pol√≠gono e enviar raios da c√¢mera em sua dire√ß√£o.  Essa abordagem funcionou bem, mas tivemos alguns casos lim√≠trofes: os pol√≠gonos tamb√©m foram cortados, nos quais o √¢ngulo entre a viga e sua normalidade era aproximadamente igual a œÄ / 2.  Assim, quando a c√¢mera faz zoom devido a distor√ß√µes de perspectiva, √°reas de corte podem abrir. <br><br>  Na opini√£o dos artistas, esse m√©todo era muito agressivo, por isso decidimos focar em <b>cortar</b> apenas os <b>backfaces</b> . <br><br><h3>  Conclus√£o </h3><br>  N√£o √© segredo que uma atitude cuidadosa com os recursos do dispositivo ao criar jogos √© o fator mais importante que afeta a qualidade do produto final.  Isto √© especialmente verdade para plataformas m√≥veis, sombrias para o uso ativo da RAM.  Reduzir o n√∫mero de pol√≠gonos permite preencher com mais efici√™ncia o espa√ßo dos atlas de textura e reduzir um pouco a carga computacional. <br><br>  Al√©m disso, n√£o se esque√ßa do custo de horas de trabalho e do custo de erros ao usar as ferramentas descritas acima e similares.  A abordagem proposta pressup√µe um pipeline que funcione bem para o trabalho do departamento de arte, especialmente os funcion√°rios envolvidos na integra√ß√£o de modelos no projeto. <br><br>  Assim, tendo as condi√ß√µes e ferramentas discutidas neste artigo, aderimos √†s seguintes regras.  Se for assumido que o modelo criado sempre ser√° virado de um lado para o usu√°rio, e tamb√©m se, por esses √¢ngulos, a sobreposi√ß√£o de algumas partes do modelo por outras for muito pequena, o artista usar√° o <b>aparador de backface</b> em um editor 3D, verificar√° a corre√ß√£o e proceder√° ao desenvolvimento de <b>UV</b> .  Se o modelo for usado frequentemente em posi√ß√µes diferentes ou tiver uma geometria mais complexa, depois de importar para o projeto, executaremos o algoritmo descrito na primeira parte do artigo, processando todos os objetos est√°ticos na cena com ele. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484792/">https://habr.com/ru/post/pt484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484776/index.html">Eventos digitais em S√£o Petersburgo, de 21 a 26 de janeiro</a></li>
<li><a href="../pt484778/index.html">Intel Parallel Studio XE 2020: o melhor para desenvolvedores</a></li>
<li><a href="../pt484782/index.html">Loja Online Blazor do Lado do Cliente: Parte 2 - CI / CD</a></li>
<li><a href="../pt484788/index.html">Mais recursos para o seu sistema: integra√ß√£o de telefonia e CRM / ERP / Helpdesk. O que, como e por qu√™?</a></li>
<li><a href="../pt484790/index.html">A hist√≥ria de como, devido a uma op√ß√£o no servidor Windows, nossos sites diminu√≠ram a velocidade</a></li>
<li><a href="../pt484796/index.html">Como obtive a certifica√ß√£o OSWE?</a></li>
<li><a href="../pt484798/index.html">Por que a classifica√ß√£o r√°pida √© realmente lenta? Novo m√©todo de classifica√ß√£o de matriz</a></li>
<li><a href="../pt484800/index.html">Analisador de C√≥digo-Fonte do Microsoft Application Inspector</a></li>
<li><a href="../pt484802/index.html">Modo de autodestrui√ß√£o: decomposi√ß√£o da c√°psula endosc√≥pica devido √† luz</a></li>
<li><a href="../pt484804/index.html">O que criptografar em um sistema corporativo? E por que isso?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>