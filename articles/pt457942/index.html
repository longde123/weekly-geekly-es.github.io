<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¨ üê° üèì O que aprendi sobre otimiza√ß√£o em Python üòÜ ‚õëÔ∏è üëπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal. Hoje queremos compartilhar outra tradu√ß√£o preparada √†s v√©speras do lan√ßamento do curso Python Developer . Vamos l√°! 



 Eu usei o Python...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que aprendi sobre otimiza√ß√£o em Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457942/">  Ol√° pessoal.  Hoje queremos compartilhar outra tradu√ß√£o preparada √†s v√©speras do lan√ßamento do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python Developer</a> .  Vamos l√°! <br><br><img src="https://habrastorage.org/webt/0-/xf/qt/0-xfqtj4sbazxamoeq0lzuaeor4.png"><br><br>  Eu usei o Python com mais frequ√™ncia do que qualquer outra linguagem de programa√ß√£o nos √∫ltimos 4-5 anos.  Python √© a linguagem predominante para compila√ß√µes no Firefox, testing e a ferramenta CI.  Mercurial tamb√©m √© escrito principalmente em Python.  Tamb√©m escrevi muitos dos meus projetos de terceiros. <br><br>  Durante meu trabalho, adquiri um pouco de conhecimento sobre o desempenho do Python e suas ferramentas de otimiza√ß√£o.  Neste artigo, eu gostaria de compartilhar esse conhecimento. <br><br>  Minha experi√™ncia com Python est√° relacionada principalmente ao interpretador CPython, especialmente ao CPython 2.7.  Nem todas as minhas observa√ß√µes s√£o universais para todas as distribui√ß√µes do Python ou para aquelas que t√™m as mesmas caracter√≠sticas em vers√µes semelhantes do Python.  Vou tentar mencionar isso durante a narrativa.  Lembre-se de que este artigo n√£o √© uma vis√£o geral detalhada do desempenho do Python.  S√≥ vou falar sobre o que me deparei por conta pr√≥pria. <a name="habracut"></a><br><br><h2>  A carga devido √†s peculiaridades de iniciar e importar m√≥dulos </h2><br>  Iniciar o interpretador Python e importar os m√≥dulos √© um processo bastante longo quando se trata de milissegundos. <br><br>  Se voc√™ precisar iniciar centenas ou milhares de processos Python em qualquer um dos seus projetos, esse atraso em milissegundos se transformar√° em um atraso de v√°rios segundos. <br><br>  Se voc√™ usar o Python para fornecer ferramentas da CLI, a sobrecarga poder√° causar um congelamento percept√≠vel ao usu√°rio.  Se voc√™ precisar das ferramentas da CLI instantaneamente, a execu√ß√£o do interpretador Python a cada chamada tornar√° mais dif√≠cil obter essa ferramenta complexa. <br><br>  Eu j√° escrevi sobre esse problema.  Algumas das minhas anota√ß√µes anteriores falam sobre isso, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em 2014</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em maio de 2018</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outubro de 2018</a> . <br><br>  N√£o h√° muitas coisas que voc√™ pode fazer para reduzir o atraso na inicializa√ß√£o: corrigir esse caso refere-se √† manipula√ß√£o do interpretador Python, pois √© ele quem controla a execu√ß√£o do c√≥digo, o que leva muito tempo.  A melhor coisa que voc√™ pode fazer √© desativar a importa√ß√£o do m√≥dulo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site</a> nas chamadas para evitar a execu√ß√£o de c√≥digo Python extra na inicializa√ß√£o.  Por outro lado, muitos aplicativos usam a funcionalidade do m√≥dulo site.py, para que voc√™ possa us√°-lo por sua conta e risco. <br><br>  Tamb√©m devemos considerar o problema de importar m√≥dulos.  Qual a vantagem do interpretador Python se ele n√£o processar nenhum c√≥digo?  O fato √© que o c√≥digo √© disponibilizado ao int√©rprete com mais frequ√™ncia atrav√©s do uso de m√≥dulos. <br><br>  Para importar m√≥dulos, voc√™ precisa executar v√°rias etapas.  E em cada um deles existe uma fonte potencial de cargas e atrasos. <br><br>  Um certo atraso ocorre devido √† pesquisa de m√≥dulos e √† leitura de seus dados.  Como demonstrei com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyOxidizer</a> , substituindo a pesquisa e o carregamento de um m√≥dulo de um sistema de arquivos por uma solu√ß√£o arquitetonicamente mais simples, que consiste na leitura de dados do m√≥dulo de uma estrutura de dados na mem√≥ria, voc√™ pode importar a biblioteca padr√£o do Python para 70-80% do tempo inicial da solu√ß√£o para esta tarefa.  Ter um m√≥dulo por arquivo do sistema de arquivos aumenta a carga no sistema de arquivos e pode diminuir a velocidade de um aplicativo Python durante os primeiros milissegundos cr√≠ticos de execu√ß√£o.  Solu√ß√µes como o PyOxidizer podem ajudar a evitar isso.  Espero que a comunidade Python veja esses custos da abordagem atual e esteja considerando a transi√ß√£o para os mecanismos de distribui√ß√£o dos m√≥dulos, que n√£o dependem tanto dos arquivos individuais no m√≥dulo. <br><br>  Outra fonte de custos adicionais de importa√ß√£o para um m√≥dulo √© a execu√ß√£o de c√≥digo nesse m√≥dulo durante a importa√ß√£o.  Alguns m√≥dulos cont√™m partes do c√≥digo em uma √°rea fora das fun√ß√µes e classes do m√≥dulo, que s√£o executadas quando o m√≥dulo √© importado.  A execu√ß√£o desse c√≥digo aumenta o custo da importa√ß√£o.  Solu√ß√£o alternativa: n√£o execute todo o c√≥digo no momento da importa√ß√£o, apenas execute-o se necess√°rio.  O Python 3.7 suporta o m√≥dulo <code>__getattr__</code> , que ser√° chamado se o atributo de um m√≥dulo n√£o for encontrado.  Isso pode ser usado para preencher lentamente os atributos do m√≥dulo no primeiro acesso. <br><br>  Outra maneira de se livrar da desacelera√ß√£o da importa√ß√£o √© importar pregui√ßosamente o m√≥dulo.  Em vez de carregar o m√≥dulo diretamente durante a importa√ß√£o, voc√™ registra um m√≥dulo de importa√ß√£o personalizado que retorna um stub.  Quando voc√™ acessa esse stub pela primeira vez, ele carrega o m√≥dulo real e ‚Äúmuda‚Äù para se tornar este m√≥dulo. <br><br>  Voc√™ pode salvar dezenas de milissegundos com aplicativos que importam v√°rias dezenas de m√≥dulos se voc√™ ignorar o sistema de arquivos e evitar a execu√ß√£o de partes desnecess√°rias do m√≥dulo (os m√≥dulos geralmente s√£o importados globalmente, mas apenas determinadas fun√ß√µes do m√≥dulo s√£o usadas). <br><br>  A importa√ß√£o lenta de m√≥dulos √© uma coisa fr√°gil.  Muitos m√≥dulos possuem modelos com as seguintes coisas: <code>try: import foo</code> ;  <code>except ImportError:</code>  Um importador pregui√ßoso de m√≥dulo nunca pode lan√ßar um ImportError, porque, se o fizer, ter√° que procurar no sistema de arquivos por um m√≥dulo para descobrir se ele existe em princ√≠pio.  Isso adicionar√° carga extra e aumentar√° o tempo gasto, para que importadores pregui√ßosos n√£o fa√ßam isso em princ√≠pio!  Este problema √© bastante irritante.  Importador de m√≥dulos pregui√ßosos O Mercurial processa uma lista de m√≥dulos que n√£o podem ser importados pregui√ßosamente e deve ignor√°-los.  Outro problema √© a sintaxe <code>from foo import x, y</code> , que tamb√©m interrompe a importa√ß√£o do m√≥dulo lento, nos casos em que foo √© um m√≥dulo (em oposi√ß√£o a um pacote), pois o m√≥dulo ainda deve ser importado para retornar uma refer√™ncia a x e y. <br><br>  O PyOxidizer possui um conjunto fixo de m√≥dulos conectados ao bin√°rio, para que possa ser eficaz no aumento do ImportError.  O m√≥dulo __getattr__ do Python 3.7 fornece flexibilidade adicional para os importadores pregui√ßosos do m√≥dulo.  Espero integrar um importador lento e confi√°vel no PyOxidizer para automatizar alguns processos. <br><br>  A melhor solu√ß√£o para evitar o in√≠cio do int√©rprete e causar atrasos √© iniciar o processo em segundo plano no Python.  Se voc√™ iniciar o processo Python como um processo daemon, digamos para um servidor da Web, poder√° faz√™-lo.  A solu√ß√£o que a Mercurial oferece √© iniciar um processo em segundo plano que forne√ßa um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">protocolo de servidor de comando</a> .  hg √© o execut√°vel C (ou agora Rust), que se conecta a esse processo em segundo plano e envia um comando.  Para encontrar uma abordagem para o servidor de comando, voc√™ precisa fazer muito trabalho, √© extremamente inst√°vel e tem problemas de seguran√ßa.  Estou pensando na id√©ia de entregar um servidor de comando usando o PyOxidizer para que o arquivo execut√°vel tenha suas vantagens, e o problema do custo da solu√ß√£o de software foi resolvido com a cria√ß√£o do projeto do PyOxidizer. <br><br><h2>  Atraso na Chamada de Fun√ß√£o </h2><br>  Chamar fun√ß√µes no Python √© um processo relativamente lento.  (Essa observa√ß√£o √© menos aplic√°vel ao PyPy, que pode executar o c√≥digo JIT.) <br><br>  Vi dezenas de corre√ß√µes para o Mercurial, o que tornou poss√≠vel alinhar e combinar o c√≥digo de forma a evitar carga desnecess√°ria ao chamar fun√ß√µes.  No atual ciclo de desenvolvimento, foram feitos alguns esfor√ßos para reduzir o n√∫mero de fun√ß√µes chamadas ao atualizar a barra de progresso.  (Utilizamos barras de progresso para quaisquer opera√ß√µes que possam levar algum tempo, para que o usu√°rio entenda o que est√° acontecendo).  Obter os resultados da chamada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√µes</a> e evitar pesquisas simples entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√µes</a> economiza dezenas de centenas de milissegundos quando executado, quando falamos de um milh√£o de execu√ß√µes, por exemplo. <br><br>  Se voc√™ possui loops estreitos ou fun√ß√µes recursivas no Python, onde centenas de milhares ou mais chamadas de fun√ß√£o podem ocorrer, voc√™ deve estar ciente da sobrecarga de chamar uma fun√ß√£o individual, pois isso √© de grande import√¢ncia.  Lembre-se de fun√ß√µes simples incorporadas e da capacidade de combinar fun√ß√µes para evitar sobrecarga. <br><br><h2>  Sobrecarga de pesquisa de atributo </h2><br>  Esse problema √© semelhante ao overhead devido a uma chamada de fun√ß√£o, pois o significado √© quase o mesmo! <br><br>  A localiza√ß√£o de atributos de resolu√ß√£o no Python pode ser lenta.  (E, novamente, no PyPy, isso √© mais r√°pido).  No entanto, lidar com esse problema √© o que costumamos fazer no Mercurial. <br><br>  Digamos que voc√™ tenha o seguinte c√≥digo: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(obj.member): total += obj.member[i]</code> </pre> <br>  Omita que existem maneiras mais eficientes de escrever este exemplo (por exemplo, <code>total = sum(obj.member)</code> ) e observe que o loop precisa definir obj.member a cada itera√ß√£o.  O Python possui um mecanismo relativamente sofisticado para definir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atributos</a> .  Para tipos simples, pode ser r√°pido o suficiente.  Mas para tipos complexos, esse acesso ao atributo pode chamar automaticamente <code>__getattr__</code> , <code>__getattribute__</code> , v√°rios m√©todos <code>dunder</code> e at√© <code>@property</code> definidas pelo usu√°rio.  Isso √© semelhante a uma pesquisa r√°pida de um atributo que pode fazer v√°rias chamadas de fun√ß√£o, o que levar√° a uma carga extra.  E essa carga pode ser agravada se voc√™ usar coisas como <code>obj.member1.member2.member3</code> , etc. <br><br>  Cada defini√ß√£o de atributo causa uma carga extra.  E como quase tudo no Python √© um dicion√°rio, podemos dizer que toda pesquisa de atributo √© uma pesquisa de dicion√°rio.  A partir de conceitos gerais sobre estruturas b√°sicas de dados, sabemos que a pesquisa de dicion√°rio n√£o √© t√£o r√°pida quanto, digamos, a pesquisa de √≠ndice.  Sim, √© claro que existem alguns truques no CPython que podem se livrar da sobrecarga devido a pesquisas no dicion√°rio.  Mas o principal t√≥pico que quero abordar √© que qualquer pesquisa de atributo √© um poss√≠vel vazamento de desempenho. <br><br>  Para loops apertados, especialmente aqueles que potencialmente excedem centenas de milhares de itera√ß√µes, √© poss√≠vel evitar essas despesas gerais mensur√°veis ‚Äã‚Äãpara localizar atributos atribuindo um valor a uma vari√°vel local.  Vejamos o seguinte exemplo: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> member = obj.member <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(member): total += member[i]</code> </pre> <br>  Obviamente, isso s√≥ pode ser feito com seguran√ßa se n√£o for substitu√≠do em um ciclo.  Se isso acontecer, o iterador manter√° um link para o elemento antigo e tudo poder√° explodir. <br>  O mesmo truque pode ser realizado ao chamar o m√©todo do objeto.  Em vez disso <br><br><pre> <code class="python hljs">obj = MyObject() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>): obj.process(i)</code> </pre><br>  Voc√™ pode fazer o seguinte: <br><br><pre> <code class="python hljs">obj = MyObject() fn = obj.process <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>:) fn(i)</code> </pre> <br>  Tamb√©m √© importante notar que, no caso em que a pesquisa de atributo precisa chamar um m√©todo (como no exemplo anterior), o Python 3.7 √© relativamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais r√°pido</a> que nas vers√µes anteriores.  Mas tenho certeza de que aqui a carga excessiva est√° conectada, em primeiro lugar, √† chamada de fun√ß√£o e n√£o √† carga na pesquisa de atributo.  Portanto, tudo funcionar√° mais r√°pido se voc√™ abandonar a pesquisa extra por atributos. <br><br>  Finalmente, como uma pesquisa de atributo chama uma fun√ß√£o para isso, pode-se dizer que a pesquisa de atributo geralmente √© menos um problema do que uma carga devido a uma chamada de fun√ß√£o.  Normalmente, para observar mudan√ßas significativas na velocidade, √© necess√°rio eliminar muitas pesquisas de atributos.  Nesse caso, assim que voc√™ der acesso a todos os atributos dentro do loop, voc√™ poder√° falar sobre 10 ou 20 atributos apenas no loop antes de chamar a fun√ß√£o.  E loops com apenas milhares ou menos de dezenas de milhares de itera√ß√µes podem fornecer rapidamente centenas de milhares ou milh√µes de pesquisas de atributos.  Ent√£o tenha cuidado! <br><br><h2>  Carregamento de objeto </h2><br>  Do ponto de vista do interpretador Python, todos os valores s√£o objetos.  No CPython, cada elemento √© uma estrutura PyObject.  Cada objeto controlado pelo int√©rprete est√° no heap e possui sua pr√≥pria mem√≥ria contendo a contagem de refer√™ncia, o tipo de objeto e outros par√¢metros.  Cada objeto √© descartado pelo coletor de lixo.  Isso significa que cada novo objeto adiciona sobrecarga devido √† contagem de refer√™ncias, coleta de lixo, etc.  (E, novamente, o PyPy pode evitar esse fardo desnecess√°rio, pois ‚Äúse prende com mais cuidado‚Äù √† vida √∫til dos valores de curto prazo.) <br><br>  Geralmente, quanto mais valores √∫nicos e objetos Python voc√™ criar, mais lento o trabalho para voc√™. <br><br>  Digamos que voc√™ itere sobre uma cole√ß√£o de um milh√£o de objetos.  Voc√™ chama uma fun√ß√£o para coletar esse objeto em uma tupla: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> my_collection: a, b, c, d, e, f, g, h = process(x)</code> </pre> <br>  Neste exemplo, <code>process()</code> retornar√° uma tupla de 8 tuplas.  N√£o importa se destru√≠mos o valor de retorno ou n√£o: essa tupla exige a cria√ß√£o de pelo menos 9 valores em Python: 1 para a pr√≥pria tupla e 8 para seus membros internos.  Bem, na vida real, pode haver menos valores se <code>process()</code> retornar uma refer√™ncia a um objeto existente.  Ou, pelo contr√°rio, pode haver mais se seus tipos n√£o forem simples e exigirem muitos PyObjects para representar.  Eu s√≥ quero dizer que, sob o cap√¥ do int√©rprete, existe um verdadeiro malabarismo de objetos para a apresenta√ß√£o completa de certas constru√ß√µes. <br><br>  Pela minha pr√≥pria experi√™ncia, posso dizer que essas despesas gerais s√£o relevantes apenas para opera√ß√µes que proporcionam ganhos de velocidade quando implementadas em um idioma nativo, como C ou Rust.  O problema √© que o int√©rprete do CPython simplesmente n√£o consegue executar o bytecode t√£o r√°pido que a carga extra devido ao n√∫mero de objetos √© importante.  Em vez disso, √© mais prov√°vel que voc√™ reduza o desempenho chamando uma fun√ß√£o ou atrav√©s de c√°lculos pesados, etc.  antes que voc√™ possa perceber a carga extra devido a objetos.  Existem, √© claro, algumas exce√ß√µes, a saber, a constru√ß√£o de tuplas ou dicion√°rios de v√°rios valores. <br><br>  Como um exemplo concreto de sobrecarga, voc√™ pode citar o Mercurial com c√≥digo C que analisa estruturas de dados de baixo n√≠vel.  Para maior velocidade de an√°lise, o c√≥digo C executa uma ordem de magnitude mais r√°pido que o CPython.  Por√©m, assim que o c√≥digo C cria PyObject para representar o resultado, a velocidade cai v√°rias vezes.  Em outras palavras, a carga envolve a cria√ß√£o e o gerenciamento de elementos Python para que eles possam ser usados ‚Äã‚Äãno c√≥digo. <br><br>  Uma maneira de contornar esse problema √© produzir menos elementos em Python.  Se voc√™ precisar se referir a um √∫nico elemento, inicie a fun√ß√£o e retorne-a, e n√£o uma tupla ou um dicion√°rio de N elementos.  No entanto, n√£o pare de monitorar a poss√≠vel carga devido a chamadas de fun√ß√£o! <br><br>  Se voc√™ possui muito c√≥digo que funciona com rapidez suficiente usando a API CPython C e elementos que precisam ser distribu√≠dos entre m√≥dulos diferentes, sem tipos Python que representam dados diferentes como estruturas C e j√° tenha compilado c√≥digo para acessar essas estruturas em vez de passar pela API C do CPython.  Ao evitar a API CPython C para acessar dados, voc√™ se livra de muita carga extra. <br><br>  Tratar elementos como dados (em vez de ter fun√ß√µes para acessar tudo em uma linha) seria a melhor abordagem para um pythonist.  Outra solu√ß√£o alternativa para o c√≥digo j√° compilado √© instanciar pregui√ßosamente o PyObject.  Se voc√™ criar um tipo personalizado em Python (PyTypeObject) para representar elementos complexos, precisar√° definir os <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">campos tp_members</a></i> ou <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tp_getset</a></i> para criar fun√ß√µes C personalizadas para procurar o valor do atributo.  Se voc√™, por exemplo, escreve um analisador e sabe que os clientes s√≥ ter√£o acesso a um subconjunto dos campos analisados, √© poss√≠vel criar rapidamente um tipo que cont√©m dados brutos, retornar esse tipo e chamar uma fun√ß√£o C para procurar atributos do Python que processam o PyObject.  Voc√™ pode at√© atrasar a an√°lise at√© que a fun√ß√£o seja chamada para economizar recursos se a an√°lise nunca for necess√°ria!  Essa t√©cnica √© bastante rara, porque requer a cria√ß√£o de c√≥digo n√£o trivial, mas fornece um resultado positivo. <br><br><h2>  Determina√ß√£o preliminar do tamanho da cole√ß√£o </h2><br>  Isso se aplica √† CPython C API. <br><br>  Ao criar cole√ß√µes, como listas ou dicion√°rios, use <code>PyList_New()</code> + <code>PyList_SET_ITEM()</code> para preencher uma nova cole√ß√£o se seu tamanho j√° estiver definido no momento da cria√ß√£o.  Isso determinar√° previamente o tamanho da cole√ß√£o para poder conter um n√∫mero finito de elementos nela.  Isso ajuda a ignorar a verifica√ß√£o de um tamanho de cole√ß√£o suficiente ao inserir itens.  Ao criar uma cole√ß√£o de milhares de itens, voc√™ economiza alguns recursos! <br><br><h2>  Usando c√≥pia zero na API C </h2><br>  A API Python C realmente gosta de criar c√≥pias de objetos em vez de retornar refer√™ncias a eles.  Por exemplo, <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyBytes_FromStringAndSize ()</a></i> copia <code>char*</code> na mem√≥ria reservada pelo Python.  Se voc√™ fizer isso para um grande n√∫mero de valores ou grandes dados, poderemos falar sobre gigabytes de E / S de mem√≥ria e a carga associada no alocador. <br><br>  Se voc√™ precisar escrever c√≥digo de alto desempenho sem uma API C, familiarize-se com o <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">protocolo de buffer</a></i> e tipos relacionados, como <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memoryview</a> .</i> <br><br>  <code>Buffer protocol</code> √© incorporado aos tipos Python e permite que os int√©rpretes convertam o tipo de / para bytes.  Ele tamb√©m permite que o interpretador de c√≥digo C receba um descritor <code>void*</code> de um determinado tamanho.  Isso permite que voc√™ associe qualquer endere√ßo na mem√≥ria ao PyObject.  Muitas fun√ß√µes que trabalham com dados bin√°rios aceitam de forma transparente qualquer objeto que implemente o <code>buffer protocol</code> .  E se voc√™ quiser aceitar qualquer objeto que possa ser considerado como bytes, precisar√° usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">unidades do formato</a> <code>s*</code> , <code>y*</code> ou <code>w*</code> ao receber argumentos de fun√ß√£o. <br><br>  Usando o <code>buffer protocol</code> , voc√™ oferece ao int√©rprete a melhor oportunidade dispon√≠vel para usar opera√ß√µes de <code>zero-copy</code> e se recusa a copiar bytes extras na mem√≥ria. <br><br>  Ao usar tipos no Python do formul√°rio <code>memoryview</code> , voc√™ tamb√©m permitir√° que o Python acesse os n√≠veis de mem√≥ria por refer√™ncia, em vez de fazer c√≥pias. <br><br>  Se voc√™ tiver gigabytes de c√≥digo que passam pelo seu programa Python, o uso perspicaz dos tipos Python que suportam c√≥pia zero salvar√° voc√™ das diferen√ßas de desempenho.  Uma vez eu notei que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">python-zstandard</a> se mostrou mais r√°pido do que qualquer liga√ß√£o Python LZ4 (embora devesse ser o contr√°rio), pois usei muito o <code>buffer protocol</code> e evitei E / S de mem√≥ria excessiva no <code>python-zstandard</code> ! <br><br><h2>  Conclus√£o </h2><br>  Neste artigo, procurei falar sobre algumas das coisas que aprendi ao otimizar meus programas Python por v√°rios anos.  Repito e digo que n√£o √© de forma alguma uma vis√£o abrangente dos m√©todos de melhoria de desempenho do Python.  Admito que provavelmente uso o Python mais exigente que outros, e minhas recomenda√ß√µes n√£o podem ser aplicadas a todos os programas.  <b>Voc√™ n√£o deve, de maneira alguma, corrigir massivamente o seu c√≥digo Python e remover, por exemplo, a busca por atributos depois de ler este artigo</b> .  Como sempre, quando se trata de otimiza√ß√£o de desempenho, primeiro corrija onde o c√≥digo √© especialmente lento.    <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">py-spy</a></i>     Python.   ,     ,      Python,       .  ,        ,         ,     ! <br><br> ,          Python    . ,       ,  Python           -  .     Python   ‚Äì     PyPy,        .  Python      .    ,     Python  ,     .      ,          ¬´  ¬ª.   ,   ,     ,    Python,   ,    ,      . <br><br>       ;-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457942/">https://habr.com/ru/post/pt457942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457928/index.html">Classifica√ß√£o profunda para comparar duas imagens</a></li>
<li><a href="../pt457930/index.html">Digita√ß√£o din√¢mica estaticamente segura no Python</a></li>
<li><a href="../pt457932/index.html">An√°lise do concurso IDS Bypass no Positive Hack Days 9</a></li>
<li><a href="../pt457936/index.html">Convidamos voc√™ para a primeira confer√™ncia Zabbix na R√∫ssia</a></li>
<li><a href="../pt457940/index.html">Como examinar a contraparte</a></li>
<li><a href="../pt457946/index.html">As 10 melhores bibliotecas JavaScript para visualizar dados em gr√°ficos e tabelas</a></li>
<li><a href="../pt457948/index.html">Jogos de tabuleiro nos quais voc√™ precisa esmagar sua cabe√ßa</a></li>
<li><a href="../pt457952/index.html">Como os processadores s√£o projetados e fabricados: fabrica√ß√£o de chips</a></li>
<li><a href="../pt457954/index.html">Por que a Swift pode se tornar um grande evento em Deep Learning</a></li>
<li><a href="../pt457956/index.html">Como escolher armazenamento sem dar um tiro no pr√≥prio p√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>