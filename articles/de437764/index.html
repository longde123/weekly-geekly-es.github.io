<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∫ üßô üë®üèΩ‚Äçüî¨ OpenSceneGraph: Verwalten von Windows- und Anzeigemodi üêÉ üéÇ üíÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Wir haben bereits gesagt, dass die Klasse osg :: Camera den zugeh√∂rigen OpenGL-Grafikkontext verwaltet. Der Grafikkontext enth√§lt Informa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Verwalten von Windows- und Anzeigemodi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437764/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  Wir haben bereits gesagt, dass die Klasse osg :: Camera den zugeh√∂rigen OpenGL-Grafikkontext verwaltet.  Der Grafikkontext enth√§lt Informationen dar√ºber, wie und wo Objekte gezeichnet werden und welche Statusattribute auf sie angewendet werden.  Unter Kontext wird ein Grafikfenster bzw. ein Client-Bereich oder ein OpenGL-Pixelpuffer verstanden, in dem Pixeldaten gespeichert werden, ohne sie in den Bildspeicher zu √ºbertragen. <br><br>  OSG verwendet die Klasse osg :: GraphicsContext, um einen abstrakten Grafikkontext darzustellen, und die Klasse osg :: GraphicsWindow, um ein abstraktes Grafikfenster darzustellen.  Letzteres verf√ºgt √ºber eine getEventQueue () -Methode zum Verwalten von Ereignissen aus GUI-Elementen.  Im Allgemeinen ist ein grafischer Kontext ein plattformspezifisches Konzept, sodass OSG den gr√∂√üten Teil der Arbeit zum Erstellen eines Fensters und zum Verkn√ºpfen seines Kontexts mit dem OpenGL-Kontext √ºbernimmt.  Wenn Sie die Methode createGraphicsContext () der Klasse osg :: GraphicsContext () aufrufen, wird der erforderliche Code (und es gibt viele davon, glauben Sie mir!) Abh√§ngig von der Plattform automatisch vom Pr√§prozessor generiert.  Alles, was wir tun m√ºssen, ist ein Argument an diese Methode vom Typ osg :: GraphicsContex :: Traits zu √ºbergeben, die eine Beschreibung des Fensters enth√§lt, das wir erhalten m√∂chten. <br><a name="habracut"></a><br><h1>  1. Die osg-Klasse :: DisplaySettings </h1><br>  Mit OSG kann der Entwickler globale Anzeigeeinstellungen verwalten, auf deren Grundlage Kameras, Betrachter und Szenenelemente gerendert werden.  Hierzu wird das Singleton-Muster verwendet, dh ein eindeutiges Objekt, das diese Einstellungen enth√§lt und in Form der Klasse osg :: DisplaySettings implementiert ist, auf die von √ºberall im Programm zugegriffen werden kann.  Daher k√∂nnen wir diese Einstellungen in unserer Anwendung jederzeit √§ndern. <br><br><pre><code class="cpp hljs">osg::DisplaySettings *ds = osg::DisplaySettings::instance();</code> </pre> <br>  Singleton osg :: DisplaySettings enth√§lt die Einstellungen, die f√ºr neu erstellte Renderger√§te gelten, den OpenGL-Kontext des Grafikfensters.  Sie k√∂nnen die folgenden Parameter variieren: <br><br><ol><li>  setDoubleBuffer () - Aktiviert / deaktiviert die doppelte Pufferung.  Standardm√§√üig aktiviert. <br></li><li>  setDepthBuffer () - Tiefenpuffer aktivieren / deaktivieren.  Standardm√§√üig aktiviert. <br></li><li>  Stellen Sie die Breite des Alpha-Puffers, des Schablonenpuffers und des Akkumulationspuffers mit Methoden wie setMinimumNumAlphaBits () ein.  Standardm√§√üig sind alle Parameter 0. <br></li><li>  Berechtigung zur Verwendung von Anti-Aliasing und seiner Tiefe mit der Methode setNumMultiSamples ().  Der Standardwert ist 0. <br></li><li>  Schalten Sie den Stereomodus ein.  Standardm√§√üig deaktiviert. <br></li></ol><br>  Betrachten Sie die Verwendung dieses Singletons am Beispiel der Gl√§ttung <br><br><div class="spoiler">  <b class="spoiler_title">Osg Singleton Beispiel :: DisplaySettings</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::DisplaySettings::instance()-&gt;setNumMultiSamples(6); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osgViewer::Viewer viewer; viewer.setSceneData(model.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Wesentlich ist hier nur eine Herausforderung. <br><br><pre> <code class="cpp hljs">osg::DisplaySettings::instance()-&gt;setNumMultiSamples(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  - Einstellen des Gl√§ttungsparameters, der je nach verwendetem Grafikger√§t die Werte 2, 4 und 6 annehmen kann.  Achten Sie darauf, wie die Cessna-Schraubenklinge aussieht, ohne sie zu gl√§tten <br><br><img src="https://habrastorage.org/webt/4y/nr/1p/4ynr1p8ia9knpagauohb6_fe2-g.png"><br><br>  und nach seiner Anwendung <br><br><img src="https://habrastorage.org/webt/yq/4b/og/yq4bog1qdmngwxpsij7ujponxzk.png"><br><br><h1>  2. Wechseln Sie in den Fenstermodus </h1><br>  Die osgViewer :: Viewer-Klasse kann sehr schnell neu konfiguriert werden, um im Fenstermodus angezeigt zu werden.  Wie Sie bemerkt haben, wurden alle unsere vorherigen Beispiele im Vollbildmodus angezeigt.  Um den Viewer in den Fenstermodus zu schalten, gibt es eine setUpViewInWindow () -Methode, die die Koordinaten der oberen linken Ecke des Fensters, ihre Breite und H√∂he in Pixel als Parameter verwendet <br><br><pre> <code class="cpp hljs">viewer.setUpViewInWindow(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>);</code> </pre><br>  Optional akzeptiert diese Methode den f√ºnften Parameter - die Nummer des Bildschirms, auf dem das Fenster angezeigt werden soll, falls Sie mehr als einen Monitor haben.  Bei der Arbeit mit mehreren Monitoren in Windows haben Sie festgestellt, dass sich die Szene im Vollbildmodus auf alle Monitore ausbreitet (dies wird unter Linux nicht beobachtet). <br><br>  Au√üerdem k√∂nnen Sie in den Projekteinstellungen auf diese Weise die Umgebungsvariable OSG_WINDOW festlegen <br><br><img src="https://habrastorage.org/webt/-5/yg/ge/-5yggeqzivtjkymngxq3xk318qm.png"><br><br>  Dies entspricht dem Aufruf von setUpViewInWindow (), der in diesem Fall m√∂glicherweise nicht ausgef√ºhrt wird. <br><br><img src="https://habrastorage.org/webt/2z/z_/px/2zz_pxckvywsn1c3hpebbwwj77e.png"><br><br>  Um den Bildschirm, auf dem der Viewer im Vollbildmodus angezeigt werden soll, explizit anzugeben, k√∂nnen Sie die Methode setUpViewOnSingleScreen () verwenden, indem Sie die Bildschirmnummer als Parameter angeben (Standard 0). <br><br>  OSG unterst√ºtzt auch sph√§rische Demo-Displays.  Sie k√∂nnen die Methode setUpViewFor3DSphericalDisplay () verwenden, um die Anzeige auf einer solchen Anzeige anzupassen. <br><br><h1>  3. Composite Viewer </h1><br>  Die Klasse osgViewer :: Viewer steuert eine einzelne Ansicht, in der ein einzelnes Szenendiagramm angezeigt wird.  Dar√ºber hinaus gibt es eine Klasse osgViewer :: CompositeViewer, die mehrere Ansichten und mehrere Szenen unterst√ºtzt.  Es verf√ºgt √ºber dieselben Methoden run (), frame () und done () zur Steuerung des Renderprozesses, erm√∂glicht jedoch das Hinzuf√ºgen und Entfernen unabh√§ngiger Ansichten mithilfe der Methoden addView () und removeView () sowie das Abrufen von Ansichten anhand ihres Index mithilfe der Methode getView ().  Das Ansichtsobjekt wird von der Klasse osgViewer :: View beschrieben. <br><br>  Die Klasse osgViewer :: View ist die Basisklasse f√ºr die Klasse osgViewer :: Viewer.  Sie k√∂nnen einen Stammknoten mit Szenendaten, einen Kameramanipulator und Ereignishandler hinzuf√ºgen.  Der Hauptunterschied zwischen dieser Klasse (Ansicht) und der Viewer-Klasse besteht darin, dass das Rendern der Szene mit run () - oder frame () -Aufrufen nicht m√∂glich ist.  Ein typisches Szenario zum Hinzuf√ºgen von Ansichten sieht folgenderma√üen aus <br><br><pre> <code class="cpp hljs">osgViewer::CompositeViewer multiviewer; multiviewer.addView( view );</code> </pre><br>  Mit Composite Viewer k√∂nnen Sie eine Szene in verschiedenen Winkeln anzeigen und diese Winkel in verschiedenen Fenstern anzeigen.  Au√üerdem k√∂nnen Sie unabh√§ngige Szenen in verschiedenen Fenstern anzeigen.  Schreiben wir ein einfaches Beispiel f√ºr die Verwendung eines zusammengesetzten Viewers <br><br><div class="spoiler">  <b class="spoiler_title">Zusammengesetztes Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/CompositeViewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgViewer::View *createView(int x, int y, int w, int h, osg::Node *scene) { osg::ref_ptr&lt;osgViewer::View&gt; view = new osgViewer::View; view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h); return view.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Node&gt; model3 = osgDB::readNodeFile("../data/glider.osg"); osgViewer::View *view1 = createView(50, 50, 320, 240, model1); osgViewer::View *view2 = createView(380, 50, 320, 240, model2); osgViewer::View *view3 = createView(185, 330, 320, 240, model3); osgViewer::CompositeViewer viewer; viewer.addView(view1); viewer.addView(view2); viewer.addView(view3); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Wir werden die Erstellung einer separaten Ansicht in eine Funktion einf√ºgen, die die Position und Gr√∂√üe des Fensters sowie die Szene als Zeiger auf ihren Wurzelknoten als Parameter verwendet <br><br><pre> <code class="cpp hljs">osgViewer::<span class="hljs-function"><span class="hljs-function">View *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h, osg::Node *scene)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osgViewer::View&gt; view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::View; view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view.release(); }</code> </pre><br>  Hier erstellen wir eine Ansicht, die von einem intelligenten Zeiger auf ein osgViewer :: View-Objekt gesteuert wird <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osgViewer::View&gt; view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::View;</code> </pre><br>  Stellen Sie die Daten der angezeigten Szene und den Fensteranzeigemodus im Fenster mit der angegebenen Position und Gr√∂√üe ein <br><br><pre> <code class="cpp hljs">view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h);</code> </pre><br>  Wir geben die Ansicht von der Funktion gem√§√ü den Regeln f√ºr die R√ºckgabe von intelligenten Zeigern zur√ºck <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view.release();</code> </pre><br>  Jetzt laden wir im Hauptprogramm drei verschiedene Modelle <br><br><pre> <code class="cpp hljs">osgViewer::View *view1 = createView(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model1); osgViewer::View *view2 = createView(<span class="hljs-number"><span class="hljs-number">380</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model2); osgViewer::View *view3 = createView(<span class="hljs-number"><span class="hljs-number">185</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model3);</code> </pre><br>  Erstellen Sie drei verschiedene Typen <br><br><pre> <code class="cpp hljs">osgViewer::View *view1 = createView(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model1); osgViewer::View *view2 = createView(<span class="hljs-number"><span class="hljs-number">380</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model2); osgViewer::View *view3 = createView(<span class="hljs-number"><span class="hljs-number">185</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model3);</code> </pre><br>  Erstellen Sie einen zusammengesetzten Viewer und f√ºgen Sie zuvor erstellte Ansichten hinzu <br><br><pre> <code class="cpp hljs">osgViewer::CompositeViewer viewer; viewer.addView(view1); viewer.addView(view2); viewer.addView(view3);</code> </pre><br>  und f√ºhren Sie das Rendering genauso aus wie bei einer Szene <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Das ist alles!  Wenn das Programm startet, erhalten wir drei verschiedene Fenster.  Der Inhalt jedes Fensters kann unabh√§ngig gesteuert werden.  Jedes der Fenster kann wie gewohnt geschlossen werden und die Anwendung durch Dr√ºcken von Esc vollst√§ndig beenden. <br><br><img src="https://habrastorage.org/webt/dh/na/kl/dhnaklox5z-apbaynehnea_okss.png"><br><br><h1>  3. Die Klasse osg :: GraphicsContext :: Traits </h1><br>  Das Wort "Merkmale" in der √úbersetzung aus dem Englischen bedeutet "Merkmale".  Die oben genannte Klasse beschreibt also die Funktionen des zuk√ºnftigen Fensters und enth√§lt alle Eigenschaften zur Beschreibung des grafischen Kontexts.  Es unterscheidet sich von der Klasse osg :: DisplaySettings, die die Eigenschaften aller Grafikkontexte f√ºr neu erstellte Kameras steuert.  Die wichtigsten √∂ffentlichen Eigenschaften dieser Klasse sind in der folgenden Tabelle aufgef√ºhrt. <br><br><table><thead><tr><th>  Klassenattribut </th><th>  Typ </th><th>  Standardwert </th><th>  Beschreibung </th></tr></thead><tbody><tr><td>  x </td><td>  int </td><td>  0 </td><td>  Die anf√§ngliche horizontale Position des Fensters </td></tr><tr><td>  y </td><td>  int </td><td>  0 </td><td>  Die anf√§ngliche vertikale Position des Fensters </td></tr><tr><td>  Breite </td><td>  int </td><td>  0 </td><td>  Fensterbreite </td></tr><tr><td>  H√∂he </td><td>  int </td><td>  0 </td><td>  Fensterh√∂he </td></tr><tr><td>  Fenstername </td><td>  std :: string </td><td>  "" </td><td>  Fenstertitel </td></tr><tr><td>  Fensterdekoration </td><td>  Bool </td><td>  falsch </td><td>  Fenstertitel-Anzeigeflag </td></tr><tr><td>  rot </td><td>  unsigned int </td><td>  8 </td><td>  Die Anzahl der roten Bits im OpenGL-Farbpuffer </td></tr><tr><td>  gr√ºn </td><td>  unsigned int </td><td>  8 </td><td>  Die Anzahl der gr√ºnen Bits im OpenGL-Farbpuffer </td></tr><tr><td>  blau </td><td>  unsigned int </td><td>  8 </td><td>  Die Anzahl der blauen Bits im OpenGL-Farbpuffer </td></tr><tr><td>  Alpha </td><td>  unsigned int </td><td>  8 </td><td>  Die Anzahl der Bits im OpenGL-Alpha-Puffer </td></tr><tr><td>  Tiefe </td><td>  unsigned int </td><td>  24 </td><td>  Die Anzahl der Bits im OpenGL-Tiefenpuffer </td></tr><tr><td>  Schablone </td><td>  unsigned int </td><td>  0 </td><td>  Die Anzahl der Bits im OpenGL-Schablonenpuffer </td></tr><tr><td>  doubleBuffer </td><td>  Bool </td><td>  falsch </td><td>  Verwenden Sie einen doppelten Puffer </td></tr><tr><td>  Proben </td><td>  unsigned int </td><td>  0 </td><td>  Primitive Gl√§ttungszahl </td></tr><tr><td>  quadBufferStereo </td><td>  Bool </td><td>  falsch </td><td>  Verwenden Sie einen Quad-Stereopuffer (f√ºr NVidia-Ger√§te). </td></tr><tr><td>  geerbte Windows-Daten </td><td>  osg :: ref_ptr </td><td>  Null </td><td>  Fenster zugeordneter Datendeskriptor </td></tr></tbody></table><br>  F√ºhren Sie den folgenden Code aus, um das Traits-Objekt zu initialisieren <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;x = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;y = <span class="hljs-number"><span class="hljs-number">100</span></span>; ...</code> </pre><br><h1>  4. Richten Sie das OSG-Anwendungsfenster ein </h1><br>  Um ein Fenster mit den angegebenen Merkmalen zu erstellen, m√ºssen Sie die folgenden Schritte ausf√ºhren: <br><br><ol><li>  Konfigurieren Sie ein Objekt vom Typ osg :: GraphicsContext :: Traits <br></li><li>  Erstellen Sie einen grafischen Fensterkontext <br></li><li>  Verkn√ºpfen Sie diesen Grafikkontext mit der Kamera <br></li><li>  Machen Sie die Kamera zum Hauptbetrachter <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr Eigenschaften</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/GraphicsContext&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::GraphicsContext::Traits&gt; traits = new osg::GraphicsContext::Traits; traits-&gt;x = 50; traits-&gt;y = 50; traits-&gt;width = 800; traits-&gt;height = 600; traits-&gt;windowName = "OSG application"; traits-&gt;windowDecoration = true; traits-&gt;doubleBuffer = true; traits-&gt;samples = 4; osg::ref_ptr&lt;osg::GraphicsContext&gt; gc = osg::GraphicsContext::createGraphicsContext(traits.get()); osg::ref_ptr&lt;osg::Camera&gt; camera = new osg::Camera; camera-&gt;setGraphicsContext(gc); camera-&gt;setViewport( new osg::Viewport(0, 0, traits-&gt;width, traits-&gt;height) ); camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); camera-&gt;setClearColor( osg::Vec4(0.2f, 0.2f, 0.4f, 1.0f) ); double aspect = static_cast&lt;double&gt;(traits-&gt;width) / static_cast&lt;double&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(30.0, aspect, 1.0, 1000.0); camera-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile("../data/cessna.osg"); osgViewer::Viewer viewer; viewer.setCamera(camera.get()); viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Erstellen Sie zum Festlegen der Fenstereinstellungen eine Instanz der Klasse osg :: GraphicsContext :: Traits und initialisieren Sie sie mit den erforderlichen Parametern <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;x = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;y = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;width = <span class="hljs-number"><span class="hljs-number">800</span></span>; traits-&gt;height = <span class="hljs-number"><span class="hljs-number">600</span></span>; traits-&gt;windowName = <span class="hljs-string"><span class="hljs-string">"OSG application"</span></span>; traits-&gt;windowDecoration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;doubleBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;samples = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Danach erstellen wir einen grafischen Kontext, indem wir einen Zeiger auf Merkmale als Einstellungen √ºbergeben <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext&gt; gc = osg::GraphicsContext::createGraphicsContext(traits.get());</code> </pre><br>  Erstellen Sie eine Kamera <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Camera&gt; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Camera;</code> </pre><br>  Wir verkn√ºpfen die Kamera mit dem erstellten grafischen Kontext <br><br><pre> <code class="cpp hljs">camera-&gt;setGraphicsContext(gc);</code> </pre><br>  Richten Sie das Ansichtsfenster ein, legen Sie die Pufferreinigungsmaske und die Reinigungsfarbe fest <br><br><pre> <code class="cpp hljs">camera-&gt;setViewport( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Viewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, traits-&gt;width, traits-&gt;height) ); camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); camera-&gt;setClearColor( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) );</code> </pre><br>  Richten Sie eine perspektivische Projektionsmatrix ein <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> aspect = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;width) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, aspect, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  Vergessen Sie nicht, den Tiefentest f√ºr die korrekte Anzeige von Gesichtern zu aktivieren <br><br><pre> <code class="cpp hljs">camera-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON);</code> </pre><br>  Laden des Flugzeugmodells <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Wir konfigurieren und starten den Viewer und geben die Kamera an, die wir in der Qualit√§t der Hauptkamera konfiguriert haben <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setCamera(camera.get()); viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Am Ausgang haben wir ein Fenster mit den erforderlichen Parametern <br><br><img src="https://habrastorage.org/webt/rs/av/d-/rsavd-z8aawrwpykioblv1kxsni.png"><br><br>  Der Fenstertitel wird nicht angezeigt, da diese Funktion in den Einstellungen meines Fenstermanagers deaktiviert ist.  Wenn Sie das Beispiel unter Windows oder Linux mit unterschiedlichen Einstellungen ausf√ºhren, wird der Header an seiner Stelle platziert. <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437764/">https://habr.com/ru/post/de437764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437752/index.html">PHP Digest Nr. 148 (14. - 28. Januar 2019)</a></li>
<li><a href="../de437754/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 349 (21. - 27. Januar 2019)</a></li>
<li><a href="../de437756/index.html">Frontend Weekly Digest (21. bis 27. Januar 2019)</a></li>
<li><a href="../de437758/index.html">Interessante Statistiken von 100.000 Profilen mit Stapel√ºberlauf f√ºr 2018 (und Habraopros)</a></li>
<li><a href="../de437760/index.html">Konfigurieren von VSCODE f√ºr die Entwicklung f√ºr ARM am Beispiel der Debug-Karte stm32f429i-disco</a></li>
<li><a href="../de437766/index.html">28. Januar: Internationaler Tag zum Schutz personenbezogener Daten</a></li>
<li><a href="../de437768/index.html">KnowledgeConf: Es ist Zeit, Wissen zu teilen</a></li>
<li><a href="../de437772/index.html">Hier leben Drachen: die Kompetenzmatrix als Werkzeug des Timlid</a></li>
<li><a href="../de437774/index.html">Gitpab Freut mich, dich kennenzulernen</a></li>
<li><a href="../de437778/index.html">Die Geschichte der Rosenlegierung und der gefallenen Krenka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>