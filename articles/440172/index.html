<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶 🙏 📰 CQRS: el principio de "divide y vencerás" al servicio de un programador 🏂 🐚 🛕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La arquitectura Puff es la salvación en el mundo del desarrollo empresarial. Con su ayuda, puede descargar hierro, paralelizar procesos y restaurar el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CQRS: el principio de "divide y vencerás" al servicio de un programador</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/psb/blog/440172/"> La arquitectura Puff es la salvación en el mundo del desarrollo empresarial.  Con su ayuda, puede descargar hierro, paralelizar procesos y restaurar el orden en el código.  Intentamos usar el patrón CQRS al desarrollar un proyecto corporativo.  Todo se ha vuelto más lógico y ... más complicado.  Recientemente, hablé sobre lo que tuve que enfrentar en la reunión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Panda-Meetup C # .Net</a> , y ahora estoy compartiendo con ustedes. <br><br><img src="https://habrastorage.org/webt/dx/rt/hg/dxrthgzb-ad0b1hfie06jz_3x-m.jpeg"><br><a name="habracut"></a><br>  ¿Alguna vez has notado cómo se ve tu aplicación corporativa?  ¿Por qué no puede ser como Apple y Google?  Sí, porque tenemos una falta constante de tiempo.  Los requisitos cambian con frecuencia, el término para sus cambios suele ser "ayer".  Y lo que es más desagradable, al negocio realmente no le gustan los errores. <br><br><img src="https://habrastorage.org/webt/nw/cm/6a/nwcm6aby-nd9z5rchxienijheqk.png"><br><br>  Para vivir de alguna manera con esto, los desarrolladores comenzaron a dividir sus aplicaciones en partes.  Todo comenzó simple, con datos.  Muchos están familiarizados con el esquema cuando los datos están separados, el cliente está separado, mientras que la lógica se almacena en el mismo lugar que los datos. <br><br><img src="https://habrastorage.org/webt/5d/yg/xa/5dygxacluuk_6axv8ttxi0moahi.png"><br><br>  Buen esquema  Los DBMS más grandes tienen extensiones de procedimiento completamente funcionales para SQL.  Hay un proverbio sobre Oracle: "Donde hay Oracle, hay lógica".  Es difícil discutir sobre la conveniencia y la velocidad de tal configuración. <br><br>  Pero tenemos una aplicación corporativa, y hay un problema: la lógica es difícil de escalar.  Y no es razonable cargar la capacidad de DBMS, que ya sufre problemas con la extracción y actualización de datos, y también tareas empresariales triviales. <br><br>  Bueno, para ser honesto, las herramientas de programación de lógica de negocios integradas en el DBMS son débiles para crear aplicaciones corporativas normales.  Mantener la lógica empresarial en T-SQL / PL-SQL es una molestia.  No sin razón, los lenguajes OOP están tan extendidos entre las aplicaciones corporativas: C #, Java, no tiene que ir muy lejos como ejemplo. <br><br><img src="https://habrastorage.org/webt/0l/bf/7o/0lbf7oxhdqiob8np3x2oagupxv4.png"><br><br>  Parecería una solución lógica: destacamos la lógica empresarial.  Vivirá en su servidor, la base por su cuenta, el cliente por su cuenta. <br><br>  ¿Qué se puede mejorar en esta arquitectura de tres niveles?  La arquitectura está involucrada en la capa de lógica empresarial, me gustaría evitar esto.  La lógica empresarial no quiere saber nada sobre el almacenamiento de datos.  La interfaz de usuario también es un mundo separado en el que hay entidades que no son específicas de la lógica empresarial. <br><br>  Aumentar capas ayudará.  Esta solución se ve casi perfecta, tiene algún tipo de belleza interior. <br><br><img src="https://habrastorage.org/webt/zw/lv/he/zwlvhelbpekiq63iyifzvuldvna.png"><br><br>  Tenemos un DAL (Data Access Layer): los datos se separan de la lógica, generalmente un repositorio CRUD que usa ORM, más procedimientos almacenados para consultas complejas.  Esta opción le permite desarrollarse lo suficientemente rápido y tener un rendimiento aceptable. <br><br>  La lógica empresarial puede ir como parte de los servicios o ser una capa separada.  La interacción entre capas se puede llevar a cabo a través de objetos de transporte (DTO). <br><br>  La solicitud de la interfaz de usuario va al servicio, se comunica con la lógica de negocios, sube al DAL para acceder a los datos.  Este enfoque se llama N-tier y tiene claras ventajas. <br><br>  Cada capa tiene sus propias metas y objetivos obvios, que a nosotros, como programadores, nos gusta mucho.  Cada capa de concreto se dedica solo a su propio negocio.  Los servicios se pueden escalar horizontalmente.  El enfoque es claro incluso para un desarrollador novato, una persona comprende rápidamente cómo funciona el sistema.  Es muy fácil rastrear todas las interacciones a medida que la solicitud va de principio a fin. <br><br>  Otra coherencia: todos los subsistemas del proyecto funcionan con los mismos datos, no tiene que preocuparse de que hayamos registrado datos en un lugar y que el usuario no los vea en otra parte. <br><br><h3>  Pastel de capas 1. N-Tier </h3><br>  A continuación se muestra un ejemplo de un fragmento típico de una aplicación basada en estos principios.  Tenemos un requisito monetario, aquí examiné el modelo anémico.  Y hay un repositorio clásico, trabajo con el que pasa ORM. <br><br><img src="https://habrastorage.org/webt/uj/bw/wa/ujbwwazglo6mvhy9x5dzt0qei4g.png"><br><br>  Este es un servicio típico, también se les llama gerentes.  Trabaja con el repositorio, recibe solicitudes y da respuestas a los clientes.  En este servicio vemos cierta confusión: tenemos un proceso de procesamiento, un proceso para trabajar con UI y un proceso para algunas unidades de control interno, están débilmente interconectados. <br><br>  Así es como se ve un método típico de este servicio.  Por ejemplo, el registro de un reclamo monetario. <br><br><img src="https://habrastorage.org/webt/g5/ux/lv/g5uxlv_eu-2xmky8lwlyk4-agvc.png"><br><br>  Recibimos datos, realizamos algunos controles comerciales.  Luego hay una actualización, y después algunas acciones posteriores, por ejemplo, enviar una notificación o escribir en el registro de usuario. <br><br>  En este enfoque, a pesar de toda su belleza, hay problemas.  Muy a menudo en aplicaciones corporativas, la carga es asimétrica: las operaciones de lectura son una orden o dos más que las escritas.  Ya existe un problema al escalar la base de datos en sí.  Por supuesto, esto se hace, e incluso por medio de un DBMS en una escala de base de datos, se llama partición.  Pero es dificil.  Si esto se hace con las calificaciones incorrectas o antes de lo necesario, la partición fallará. <br><br>  Por ejemplo, en uno de nuestros sistemas el volumen de datos alcanzó los 25 TB, aparecieron problemas.  Nosotros mismos intentamos escalar, invitamos a tipos duros de una empresa conocida.  Miraron y dijeron: necesitamos 14 horas de tiempo de inactividad completo de la base.  Pensamos y dijimos: muchachos, no funcionará, el negocio no lo aceptará. <br><br>  Además del volumen de la base de datos, el número de métodos en servicios y repositorios está creciendo.  Por ejemplo, en un servicio de reclamos monetarios hay más de cien métodos.  Es difícil de mantener, existen conflictos constantes cuando se fusiona la solicitud, la revisión del código es más difícil de realizar.  Y si tiene en cuenta que los procesos son diferentes, diferentes grupos de desarrolladores trabajan en ellos, entonces la tarea de rastrear todos los cambios asociados con un problema se convierte en un verdadero dolor de cabeza. <br><br><h3>  Hojaldre 2. CQRS </h3><br>  Entonces que hacer?  Hay una solución que se inventó en la antigua Roma: dividir y gobernar. <br><br><img src="https://habrastorage.org/webt/1s/wf/un/1swfunmbkv6_g1gevmg-be1qsoo.png"><br><br>  Como dicen, todo lo nuevo está bien olvidado, viejo.  En 1988, Bertrand Meyer formuló el principio de la programación imperativa de CQS (separación de consulta de comandos) para trabajar con objetos.  Todos los métodos están claramente divididos en dos tipos.  La primera - Consulta - consultas que devuelven el resultado sin cambiar el estado del objeto.  Es decir, cuando observa los requisitos monetarios del cliente, nadie debe escribir en la base de datos que el cliente se haya visto tal o cual, no debería haber efectos secundarios en la solicitud. <br><br>  El segundo - Comandos - comandos que cambian el estado de un objeto sin devolver datos.  Es decir, ordenó que se cambiara algo y, a cambio, no espere un informe de 10 mil líneas. <br><br><img src="https://habrastorage.org/webt/sz/tj/cn/sztjcny-m7hn7pnx4zn-37_dkly.png"><br><br>  Aquí, el modelo de datos de lectura está claramente separado del modelo de escritura.  La mayor parte de la lógica de negocios funciona en operaciones de escritura.  La lectura puede funcionar en representaciones materializadas o, en general, de manera diferente.  Se pueden dividir y sincronizar a través de eventos o algunos servicios internos.  Hay muchas opciones <br><br>  CQRS no es complicado.  Debemos distinguir claramente los equipos que cambian el estado del sistema, pero no devuelven nada.  Aquí el enfoque puede ser más equilibrado.  No es particularmente aterrador si el comando devuelve el resultado de la ejecución: un error o, por ejemplo, el identificador de la entidad creada, entonces no hay delito en esto.  Es importante que el equipo no trabaje con la solicitud, no debe buscar datos y devolver entidades comerciales. <br><br>  Solicitudes: todo es simple allí.  No cambia la condición para que no haya efectos secundarios.  Esto significa que si llamamos a la solicitud dos veces seguidas, y no hubo otros comandos, el estado del objeto en ambos casos debería permanecer idéntico.  Esto le permite paralelizar consultas.  Curiosamente, un modelo separado para consultas no es necesario para el trabajo, porque  no tiene sentido extraer lógica de negocios de un modelo de dominio para esto. <br><br><h3>  Nuestro proyecto CQRS </h3><br>  Esto es lo que queríamos hacer en nuestro proyecto: <br><br><img src="https://habrastorage.org/webt/rc/jt/d_/rcjtd_xtvea4sppjzzpi1jumbzy.png"><br><br>  Nuestra aplicación existente ha estado operando desde 2006, tiene una arquitectura clásica en capas.  Pasado de moda pero sigue funcionando.  Nadie quiere cambiarlo y ni siquiera sabe con qué reemplazarlo.  Llegó el momento en que era necesario desarrollar algo nuevo, prácticamente desde cero.  En 2011-2012, Event Sourcing y CQRS fueron un tema muy de moda.  Pensamos que era genial, para poder almacenar el estado original del objeto y los eventos que lo condujeron. <br><br>  Es decir, no estamos, por así decirlo, actualizando el objeto.  Hay un estado original y al lado está lo que se le aplicó.  En este caso, hay una gran ventaja: podemos restaurar el estado de un objeto en cualquier momento de la historia.  De hecho, la revista ya no es necesaria.  A medida que almacenamos eventos, entendemos qué sucedió exactamente.  Es decir, no solo se actualizó el valor del cliente en la celda de "dirección", sino que registraremos el evento exacto, por ejemplo, el movimiento del cliente. <br><br>  Está claro que dicho esquema funciona lentamente cuando se reciben datos, por lo que tenemos una base de datos separada con representaciones de materiales para la selección.  Bueno, y sincronización de eventos: con cada llegada de eventos en un cambio de estado, se produce una publicación.  En teoría, todo parece estar bien, pero ... Nunca conocí a personas que se dieran cuenta de esto en la producción, en grandes cargas con una consistencia comercial aceptable. <br><br><img src="https://habrastorage.org/webt/a_/gb/l4/a_gbl4c68c45lor9e9it0tptgsw.png"><br><br>  El esquema puede desarrollarse aún más si los controladores y comandos / solicitudes están separados.  Aquí, como ejemplo, tenemos un equipo: un reclamo monetario registrado: hay una fecha, monto, cliente y otros campos. <br><br>  Ponemos una restricción al procesador de registro del reclamo monetario de que solo puede aceptar a nuestro equipo (donde TCommand: ICommand).  Podemos escribir controladores sin cambiar los antiguos, simplemente agregando requisitos complejos.  Por ejemplo, primero actualice la fecha, luego escriba el valor, y aquí envía una notificación al cliente: todo esto se escribe en diferentes controladores por comando. <br><br>  ¿Cómo causamos todo esto?  Hay un despachador que sabe dónde tiene almacenados todos estos controladores. <br><br><img src="https://habrastorage.org/webt/x5/ru/oy/x5ruoyjo7opvudu_ee7o72oa1dy.png"><br><br>  El despachador se pasa (por ejemplo, a través de un contenedor DI) a la API.  Y cuando llega el comando, solo se ejecuta.  Él sabe dónde está el contenedor, dónde están los equipos y los ejecuta.  Con solicitudes, de manera similar. <br><br>  ¿Cuál es el problema con este esquema? Todas las interacciones se vuelven menos obvias.  Construimos una jerarquía sobre tipos que están registrados en contenedores y luego respondemos a nuestros comandos / solicitudes.  Requiere un diseño muy claro de la arquitectura.  Cualquier acción con un método con un parámetro ya no está limitada.  Escribe un comando, escribe un controlador, se registra en un contenedor.  La cantidad de gastos generales está aumentando.  En un proyecto grande, surgen problemas con la navegación primaria.  Decidimos ir de una manera más clásica. <br><br>  Para la comunicación asincrónica, se utilizó el bus de servicio Rebus. <br><br><img src="https://habrastorage.org/webt/yw/nj/qw/ywnjqwtw7grnr-vh790ed2vthqs.png"><br><br>  Para tareas simples, es más que suficiente. <br><br>  CQRS te hace enfocar el código un poco diferente, concentrarte en el proceso, porque todas las acciones nacen como parte del proceso.  Asignamos un repositorio para solicitudes, procesamos comandos relacionados por separado y procesamos solicitudes relacionadas por separado.  Para leer, no utilizamos un repositorio separado, solo trabajamos con ORM en equipos. <br><br><img src="https://habrastorage.org/webt/wh/6n/yt/wh6nytrv98oixsxcnwxxrtculis.png"><br><br>  Aquí, por ejemplo, hay un método desde el cual se tira todo lo superfluo.  En el equipo de registro de reclamo de dinero, registramos la demanda y publicamos el evento en el autobús en el que se registra el reclamo de dinero. <br><br><img src="https://habrastorage.org/webt/wh/6n/yt/wh6nytrv98oixsxcnwxxrtculis.png"><br><br>  Cualquier persona interesada en esto reaccionará a ella.  Por ejemplo, la autenticación y el registro de usuarios funcionarán allí. <br><br>  Aquí hay una solicitud de ejemplo.  Todo se volvió simple también: leemos y entregamos al repositorio. <br><br><img src="https://habrastorage.org/webt/od/2g/wj/od2gwj9ud2gzo_61i9tcw6d0keu.png"><br><br>  Quiero quedarme por separado en Rebus.Saga.  Este es un patrón que le permite dividir una transacción comercial en acciones atómicas.  Esto le permite bloquear no todos a la vez, sino gradualmente y a su vez. <br><br><img src="https://habrastorage.org/webt/d_/t9/t5/d_t9t5foqvuzu3gkpp8nmvqhmfa.jpeg"><br><br>  El primer elemento toma medidas y envía un mensaje, el segundo suscriptor reacciona, lo cumple, envía su mensaje, al que la tercera parte del sistema ya está respondiendo.  Si todo terminó bien, Saga genera su propio mensaje del tipo especificado, al que otros suscriptores ya responderán. <br><br>  Veamos cómo se ve la clase para procesar un reclamo de dinero en este caso.  Todo está claro: hay comandos, hay solicitudes relacionadas con el proceso de registro, bueno, un bus con registros. <br><br><img src="https://habrastorage.org/webt/bl/nm/7m/blnm7mchtolurp463y6_m_o6biq.png"><br><br>  En este caso, hay un controlador.  Cuando ocurre un evento y llega un equipo para registrar reclamos monetarios, él responde.  En el interior, todo es igual que antes, pero la peculiaridad es que hay una agrupación por proceso. <br><br><img src="https://habrastorage.org/webt/ns/wi/iz/nswiizzxxzxajbkardg73qvtmq0.png"><br><br>  Debido a esto, se hizo un poco más fácil, menos cambios en cada archivo. <br><br><h3>  Conclusiones </h3><br>  ¿Qué debe recordar al trabajar con CQRS?  Necesita un mejor enfoque para el diseño, porque reescribir el proceso es un poco más complicado.  Hay una pequeña sobrecarga, se han convertido en un poco más de clases, pero esto no es crítico.  El código se ha vuelto menos conectado, sin embargo, no es tanto por CQRS, sino por la transición al bus.  Pero fue CQRS lo que nos impulsó a usar esta interacción de eventos.  El código se ha agregado más a menudo que cambiado.  Hay más clases, pero ahora son más especializadas. <br><br>  ¿Todos necesitan dejar todo y cambiar masivamente a CQRS?  No, debe observar qué escenario funciona mejor para un proyecto en particular.  Por ejemplo, si su subsistema funciona con directorios, no se necesita CQRS, el enfoque clásico en capas brinda un resultado más simple y conveniente. <br><br>  La versión completa del rendimiento en Panda Meetup está disponible a continuación. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J9U0svFKX9A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Si desea profundizar en el tema, tiene sentido estudiar estos recursos: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estilo de arquitectura CQRS - de Microsoft</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog de Alexander Bendyu</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de la Universidad de Contoso con CQRS, MediatR, AutoMapper y más - por Jimmy Bogard</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CQRS - por Martin Fowler</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rebus</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440172/">https://habr.com/ru/post/440172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440162/index.html">Un ejemplo de una red neuronal simple en C / C ++</a></li>
<li><a href="../440164/index.html">¿La monetización de los datos del usuario se convertirá en una tendencia en 2019?</a></li>
<li><a href="../440166/index.html">Compresión de puntero Java</a></li>
<li><a href="../440168/index.html">Informes en video de FunTech ML-meetup</a></li>
<li><a href="../440170/index.html">Análisis de incidentes relacionados con ciberataques en proyectos de blockchain</a></li>
<li><a href="../440174/index.html">Concurso de codificación Microsoft Q # - Invierno 2019</a></li>
<li><a href="../440176/index.html">Siete tendencias de ciberseguridad para 2019</a></li>
<li><a href="../440178/index.html">Eliminar la recursividad en Python</a></li>
<li><a href="../440180/index.html">Concurso de programación Q #: Concurso de codificación Q # de Microsoft</a></li>
<li><a href="../440182/index.html">IBM Watson Studio: una plataforma de desarrollo de aplicaciones de IA basada en la nube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>