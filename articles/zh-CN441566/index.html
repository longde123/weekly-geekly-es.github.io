<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏠 ♥️ 🛌🏽 要了解的12个JavaScript概念 🔄 🚶🏽 👨🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript是一种复杂的语言。 如果您从事任何级别的JavaScript开发，那么这对于您理解该语言的基本概念至关重要。 我们今天出版的翻译材料涵盖了12个关键的JavaScript概念。 当然，JavaScript开发人员需要了解更多，但是如果没有我们今天要谈论的内容，他绝对做不到。 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>要了解的12个JavaScript概念</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441566/">  JavaScript是一种复杂的语言。 如果您从事任何级别的JavaScript开发，那么这对于您理解该语言的基本概念至关重要。 我们今天出版的翻译材料涵盖了12个关键的JavaScript概念。 当然，JavaScript开发人员需要了解更多，但是如果没有我们今天要谈论的内容，他绝对做不到。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/xo/jx/x6/xojxx6etipvx2akmizisxctdubg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1.存储值和引用的变量</font> </h2><br> 对于希望正确编写工作代码的人来说，了解JavaScript中变量值的确切分配方式非常重要。 对这种机制的误解导致编​​写程序，其中变量的值可能会意外更改。 <br><br> 如果实体具有原始类型之一（特别是<code>Boolean</code> ， <code>null</code> ， <code>undefined</code> ， <code>String</code>和<code>Number</code>类型），则JavaScript始终使用该实体的值。 即，将值写入相应的变量。 如果我们在谈论一个对象（例如， <code>Object</code> ， <code>Array</code> ， <code>Function</code>类型），则在将其分配给变量时，将对该<code>Object</code>的引用写入该对象在内存中的地址。 <br><br> 考虑一个例子。 在以下代码片段中，一个字符串被写入<code>var1</code> 。 之后，将<code>var2</code>的值写入<code>var2</code>变量。 由于<code>var1</code>变量具有原始类型（ <code>String</code> ），因此<code>var1</code>可用字符串的副本<code>var2</code>被写入<code>var1</code> 。 这使我们可以将<code>var2</code>视为完全独立于<code>var1</code>的变量，尽管它存储的值与<code>var1</code>相同。 将新值写入<code>var1</code>不会影响<code>var1</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = <span class="hljs-string"><span class="hljs-string">'My string'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2 = <span class="hljs-string"><span class="hljs-string">'My new string'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// 'My string' console.log(var2); // 'My new string'</span></span></code> </pre> <br> 现在考虑使用对象的示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jim'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2.name = <span class="hljs-string"><span class="hljs-string">'John'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// { name: 'John' } console.log(var2); // { name: 'John' }</span></span></code> </pre> <br> 如您所见，这里我们正在使用<code>var2</code>变量，当它们存储对同一对象的引用时，在<code>var1</code>变量中会反映出它发生了什么。 很难想象如果有人决定存储对象的变量的行为与存储基元类型的变量的行为相同，那么这将在实际代码中导致什么。 例如，当它们创建旨在与传递给它的对象值一起使用的函数而该函数无意间更改了该值时，这尤其令人不快。 <br><br><h2>  <font color="#3AC1EF">2.短路</font> </h2><br> 结束语是JavaScript中的一种重要设计模式，允许您使用变量来组织受保护的工作。 在下面的示例中， <code>createGreeter()</code>函数返回一个匿名函数，该函数可以访问带有<code>greeting</code>参数的提供的参数，该参数包含字符串<code>Hello</code> 。 对该匿名函数的引用将写入<code>sayHello</code>变量。 之后，无论我们调用<code>sayHello()</code>函数多少次，它始终可以访问<code>greeting</code>值。 在这种情况下，对<code>greeting</code>访问将仅是一个匿名函数，该链接的链接记录在<code>sayHello</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGreeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">greeting</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + name); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sayHello = createGreeter(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>); sayHello(<span class="hljs-string"><span class="hljs-string">'Joe'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Hello, Joe</span></span></code> </pre> <br> 这是一个非常简单的例子。 如果我们看一些更接近真实世界的东西，我们可以想象，例如，一个用于连接到某个API的函数（我们称其为<code>apiConnect()</code> ），该函数在首次调用时会被传递一个API访问密钥。 反过来，此函数返回一个对象，该对象包含使用传递给<code>apiConnect()</code>的API访问密钥的几种方法。 在这种情况下，密钥存储在闭包中，当您调用这些方法时，不再需要提及它。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">apiKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${route}</span></span></span><span class="hljs-string">?key=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route, params</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(route, {     <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>,     <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(params),       <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: {         <span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>       }     }) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get, post } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> api = apiConnect(<span class="hljs-string"><span class="hljs-string">'my-secret-key'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     API     api.get('http://www.example.com/get-endpoint'); api.post('http://www.example.com/post-endpoint', { name: 'Joe' });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">3.破坏性分配</font> </h2><br> 如果您尚未在JavaScript中使用破坏性分配，那么现在该修复它了。 破坏性分配是使用整洁的句法语言构造检索对象属性的常用方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, food } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, food); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br> 如果您需要分配与对象中提取的属性名称不同的提取属性名称，则可以执行以下操作： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: myName, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: myFood } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myName, myFood); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br> 在下面的示例中，使用解构将存储在<code>person</code>对象的属性中的值准确地传递给<code>introduce()</code>函数。 这是在声明一个函数以将参数传递给对象的情况下从对象检索数据时如何使用此构造的示例。 顺便说一句，如果您熟悉React，那么您可能已经看到了。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Eddie'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">introduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, age }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${age}</span></span></span><span class="hljs-string"> years old!`</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(introduce(person)); <span class="hljs-comment"><span class="hljs-comment">// "I'm Eddie and I'm 24 years old!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">4.点差算子</font> </h2><br> 传播算子是一个相当简单的构造，对于没有准备的人来说似乎难以理解。 以下示例具有一个数值数组，这是我们需要在其中找到的最大值。 我们想为此使用<code>Math.max()</code>方法，但是它不知道如何使用数组。 作为参数，他假设独立的数值。 为了从数组中提取其元素，我们使用了散布运算符，它看起来像三点。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> max = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(...arr); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(max); <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">5.其余声明</font> </h2><br>  rest运算符允许您将传递给函数的任意数量的参数转换为数组。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(args[<span class="hljs-number"><span class="hljs-number">0</span></span>] + args[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } myFunc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">6.数组方法</font> </h2><br> 数组方法通常为开发人员提供方便的工具，以精美地解决各种数据转换任务。 我有时会在StackOverflow上回答问题。 其中，通常有一些专门用于处理对象数组的方法或其他方法。 在这种情况下，数组方法特别有用。 <br><br> 在这里，我们将考虑几种这样的方法，将它们彼此相似的原理结合在一起。 应当指出，这里我不会告诉您所有数组方法。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MDN</a>上找到其完整列表（顺便说一下，这是我最喜欢的JavaScript参考）。 <br><br><h3>  <font color="#3AC1EF">▍Map（），filter（）和reduce（）方法</font> </h3><br>  <code>map()</code> ， <code>filter()</code>和<code>reduce()</code>数组方法允许您将数组转换或将数组缩小为单个值（可以是一个对象）。 <br><br>  <code>map()</code>方法返回一个新数组，其中包含已处理数组的转换值。 在传递给此方法的函数中指定如何精确转换它们。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapped = arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el + <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(mapped); <span class="hljs-comment"><span class="hljs-comment">// [21, 22, 23, 24, 25, 26]</span></span></code> </pre> <br>  <code>filter()</code>方法返回一个元素数组，检查传递给此方法的函数返回<code>true</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filtered = arr.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-number"><span class="hljs-number">2</span></span> || el === <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filtered); <span class="hljs-comment"><span class="hljs-comment">// [2, 4]</span></span></code> </pre> <br>  <code>reduce()</code>方法返回某个值，该值是处理数组中所有元素的结果。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduced = arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total, current</span></span></span><span class="hljs-function">) =&gt;</span></span> total + current); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduced); <span class="hljs-comment"><span class="hljs-comment">// 21</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍方法find（），findIndex（）和indexOf（）</font> </h3><br> 数组方法<code>find()</code> ， <code>findIndex()</code>和<code>indexOf()</code>容易相互混淆。 以下是帮助您了解其功能的说明。 <br><br>  <code>find()</code>方法返回与指定条件匹配的数组的第一个元素。 找到第一个合适的元素的此方法不会继续在数组中搜索。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> found = arr.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(found); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br> 请注意，在我们的示例中，给定的条件对应于数组中包含数字5的所有元素，但仅返回第一个合适的元素。 在使用for循环枚举和分析数组的情况下，当使用<code>break</code>语句在数组中找到所需的元素时，此类循环会中断，这种方法非常有用。 <br><br>  <code>findIndex()</code>方法与<code>find()</code>非常相似，但是它不返回数组中的第一个合适元素，而是返回该元素的索引。 为了更好地理解此方法，请看以下示例，该示例使用字符串值数组。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  <code>indexOf()</code>方法与<code>findIndex()</code>方法非常相似，但是它不是函数而是正常值作为参数。 如果在搜索所需的数组元素时不需要复杂的逻辑，则可以使用它。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.indexOf(<span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Push（），pop（），shift（）和unshift（）方法</font> </h3><br>  <code>push()</code> ， <code>pop()</code> ， <code>shift()</code>和<code>unshift()</code>用于向数组添加新元素，并从数组中提取数组中已经存在的元素。 在这种情况下，将使用位于数组开头或结尾的元素执行工作。 <br><br>  <code>push()</code>方法允许您将元素添加到数组的末尾。 它修改数组，并在完成后返回添加到数组中的元素。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pushed = arr.push(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5] console.log(pushed); // 5</span></span></code> </pre> <br>  <code>pop()</code>方法从数组中删除最后一个元素。 它修改数组并返回从数组中删除的元素。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> popped = arr.pop(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] console.log(popped); // 4</span></span></code> </pre> <br>  <code>shift()</code>方法从数组中删除第一个元素并返回它。 它还修改了为其调用的数组。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shifted = arr.shift(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4] console.log(shifted); // 1</span></span></code> </pre> <br>  <code>unshift()</code>方法将一个或多个元素添加到数组的开头。 他再次修改了数组。 同时，与这里讨论的其他三种方法不同，它返回数组的新长度。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unshifted = arr.unshift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [5, 6, 7, 1, 2, 3, 4] console.log(unshifted); // 7</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">liceSlice（）和splice（）方法</font> </h3><br> 这些方法用于修改数组或返回数组的某些部分。 <br><br>  <code>splice()</code>方法通过删除现有元素或将其替换为其他元素来更改数组的内容。 他能够向数组添加新元素。 此方法修改数组。 <br><br> 下面的示例，如果用普通语言描述，则如下所示：您需要在数组位置<code>1</code>删除<code>0</code>元素并添加一个包含<code>b</code>的元素。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; arr.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>)</code> </pre> <br>  <code>slice()</code>方法返回包含其元素的数组的浅表副本，从给定的起始位置开始，以给定的终止位置之前的位置结束。 如果在调用它时仅指定了初始位置，则它将从该位置开始返回整个数组。 此方法不修改数组。 它仅返回此数组在调用时描述的部分。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sliced = arr.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sliced); <span class="hljs-comment"><span class="hljs-comment">// ['c', 'd'] console.log(arr); // ['a', 'b', 'c', 'd', 'e']</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍方法排序（）</font> </h3><br>  <code>sort()</code>方法根据传递给它的函数指定的条件对数组进行排序。 此函数接受数组的两个元素（例如，可以将它们表示为参数<code>a</code>和<code>b</code> ），并与它们进行比较，如果不需要交换元素，则返回；如果将<code>a</code>放在比其低的索引处，则返回0。 <code>b</code>是负数，并且如果<code>b</code>需要以比<code>a</code>低的索引放置，则<code>a</code>是正数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sorter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstEl, secondEl</span></span></span><span class="hljs-function">) =&gt;</span></span> firstEl - secondEl; arr.sort(sorter); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [-1, 1, 2, 3, 5, 7, 7]</span></span></code> </pre> <br> 如果您第一次不记得这些方法，可以记住它们。 最重要的是，您现在知道标准数组方法可以做什么。 因此，如果您不能立即回忆特定方法的功能，那么您所了解的内容将使您能够快速找到文档中所需的内容。 <br><br><h2>  <font color="#3AC1EF">7.发电机</font> </h2><br>  JavaScript生成器使用星号字符声明。 它们允许您指定<code>next()</code>调用<code>next()</code>方法时将返回什么值。 可以将生成器设计为返回有限数量的值。 如果此类生成器返回了所有此类值，则对<code>next()</code>的下一次调用将返回<code>undefined</code> 。 您还可以创建旨在使用循环返回无限数量的值的生成器。 <br><br> 这是一个旨在返回有限数量的值的生成器： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'How are you?'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Bye'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greet = greeter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greet.next().value); <span class="hljs-comment"><span class="hljs-comment">// 'Hi' console.log(greet.next().value); // 'How are you?' console.log(greet.next().value); // 'Bye' console.log(greet.next().value); // undefined</span></span></code> </pre> <br> 这是一个生成器，旨在通过循环返回无限数量的值。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idCreator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i++; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ids = idCreator(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ids.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(ids.next().value); // 1 console.log(ids.next().value); // 2 //   ...</span></span></code> </pre><br><h2>  <font color="#3AC1EF">8.用于检查值的相等性（==）和严格相等性（===）的运算符</font> </h2><br> 对于任何JS开发人员而言，了解相等（ <code>==</code> ）和严格相等（ <code>===</code> ）运算符之间的区别都非常重要。 事实是，运算符<code>==</code>在比较值之前会执行其类型的转换（乍看之下可能会导致奇怪的后果），而运算符<code>===</code>不会执行类型转换。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true console.log(0 === '0'); // false</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">9.对象比较</font> </h2><br> 我有时不得不看看JS编程的新手如何犯同样的错误。 他们尝试直接比较对象。  “存储”对象的变量包含对它们的引用，而不是这些对象本身。 <br><br> 因此，例如，在下面的示例中，对象看起来相同，但是直接比较时，我们得知对象是不同的，因为每个变量都包含一个指向其自己对象的链接，并且这些链接彼此不相等。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br> 此外，在下面的示例中，由于两个变量都存储对同一对象的引用，因此可以证明<code>joe1</code>等于<code>joe2</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = joe1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br> 实际对象比较的方法之一是将它们初步转换为JSON字符串格式。 确实，这种方法有一个问题，那就是在获得的对象的字符串表示形式中，不能保证其属性的某些顺序。 比较对象的一种更可靠的方法是使用一个特殊的库，该库包含用于对象的深层比较的工具（例如，这是<a href="">lodash</a>库的<a href="">isEqual（）</a>方法）。 <br><br> 为了更好地理解比较对象的复杂性并了解在不同变量中编写指向相同对象的链接的可能结果，请看一下本文讨论的第一个JS概念。 <br><br><h2>  <font color="#3AC1EF">10.回调函数</font> </h2><br> 回调函数是一个相当简单的JavaScript概念，新手有时会遇到困难。 考虑以下示例。 在这里， <code>console.log</code>函数（就是这样-不带括号<code>myFunc()</code>作为回调函数传递给<code>myFunc()</code> 。 此函数设置一个计时器，此后将调用<code>console.log()</code> ，并在控制台中显示传递给<code>myFunc()</code>的字符串。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text, callback</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   callback(text); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); } myFunc(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">11.承诺</font> </h2><br> 掌握了回调函数并开始在各处使用它们之后，您很快就会发现自己处于所谓的“回调地狱”中。 如果您真的在那里-看一下诺言。 异步代码可以包装在一个Promise中，并在成功执行后，通过调用适当的方法告知系统有关Promise的成功解决的信息，如果出了问题，请调用指示该方法并拒绝Promise的方法。 要处理Promise返回的结果，请使用<code>then()</code>方法，对于错误处理，请使用<code>catch()</code>方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hooray!'</span></span>);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rej(<span class="hljs-string"><span class="hljs-string">'Oh no!'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); myPromise .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Success: '</span></span> + data);  })  .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error: '</span></span> + err);  }); <span class="hljs-comment"><span class="hljs-comment">//  Math.random()  , ,  0.9,    : // "Success: Hooray!" //  Math.random()  , ,  0.9,  0.9,    : // "Error: On no!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">12.异步/等待构造</font> </h2><br> 在兑现承诺之后，很有可能您会想要更多。 例如，掌握async / await构造。 它是诺言的句法糖。 在以下示例中，我们使用<code>async</code>创建一个异步函数，并在其中使用<code>await</code>关键字组织等待迎接者<code>greeter</code>的等待。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> greeter; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting); } myFunc(); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 如果我们之前在这里谈论的内容对您不熟悉，那么您很可能（至少一点）通过阅读本文而超越了自己。 如果您在这里没有发现任何新鲜事物，那么我希望该材料为您提供练习和增强JavaScript知识的机会。 <br><br>  <b>亲爱的读者们！</b> 您还将在本文中添加哪些其他JavaScript概念？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441566/">https://habr.com/ru/post/zh-CN441566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441546/index.html">“ Hayabusa-2”首次碰到小行星</a></li>
<li><a href="../zh-CN441550/index.html">一个简单的程序员的生活是艰难而平淡的</a></li>
<li><a href="../zh-CN441554/index.html">Linux的整个历史。 第一部分：一切开始</a></li>
<li><a href="../zh-CN441560/index.html">2月25日至3月3日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN441562/index.html">像素驰op-第五部分-角色动画。 走路</a></li>
<li><a href="../zh-CN441568/index.html">Python内存管理</a></li>
<li><a href="../zh-CN441570/index.html">353上周的前端世界摘要（2019年2月17日至24日）</a></li>
<li><a href="../zh-CN441572/index.html">前端每周摘要（2019年2月18日至24日）</a></li>
<li><a href="../zh-CN441574/index.html">学习Docker第6部分：处理数据</a></li>
<li><a href="../zh-CN441576/index.html">Kubernetes网络：Pod</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>