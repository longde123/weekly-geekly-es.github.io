<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏻 🍵 🙅🏿 JavaScript-Verknüpfungen für Anfänger 🙎🏽 🥤 ☺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Closures sind eines der grundlegenden Konzepte von JavaScript und verursachen für viele Anfänger Schwierigkeiten, die jeder JS-Programmierer kennen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Verknüpfungen für Anfänger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424967/">  Closures sind eines der grundlegenden Konzepte von JavaScript und verursachen für viele Anfänger Schwierigkeiten, die jeder JS-Programmierer kennen und verstehen sollte.  Mit einem guten Verständnis der Verschlüsse können Sie besseren, effizienteren und saubereren Code schreiben.  Dies wiederum trägt zu Ihrer beruflichen Weiterentwicklung bei. <br><br>  Das Material, dessen Übersetzung wir heute veröffentlichen, widmet sich der Geschichte der internen Mechanismen von Schließungen und ihrer Funktionsweise in JavaScript-Programmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/808/540/652808540f60e3a5f1b4b255fe90337a.png"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist eine Schließung?</font> </h2><br>  Ein Abschluss ist eine Funktion, die Zugriff auf einen Bereich hat, der von einer externen Funktion relativ zu ihm gebildet wird, selbst nachdem diese externe Funktion ihre Arbeit abgeschlossen hat.  Dies bedeutet, dass ein Abschluss Variablen speichern kann, die in einer externen Funktion deklariert sind, und an sie übergebene Argumente.  Bevor wir tatsächlich zu Schließungen übergehen, werden wir uns mit dem Konzept der „lexikalischen Umgebung“ befassen. <br><br><h2>  <font color="#3AC1EF">Was ist eine lexikalische Umgebung?</font> </h2><br>  Der Begriff "lexikalische Umgebung" oder "statische Umgebung" in JavaScript bezieht sich auf die Möglichkeit, auf Variablen, Funktionen und Objekte basierend auf ihrer physischen Position im Quellcode zuzugreifen.  Betrachten Sie ein Beispiel: <br><br><pre><code class="hljs pgsql">let a = <span class="hljs-string"><span class="hljs-string">'global'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>() {    let b = <span class="hljs-string"><span class="hljs-string">'outer'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>() {      let c = <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(c);   // <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(b);   // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>      console.log(a);   // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    }    console.log(a);     // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    console.log(b);     // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>();  } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>(); console.log(a);         // <span class="hljs-string"><span class="hljs-string">'global'</span></span></code> </pre> <br>  Hier hat die <code>inner()</code> Funktion Zugriff auf Variablen, die in ihrem eigenen Bereich, im Bereich der <code>outer()</code> Funktion und im globalen Bereich deklariert sind.  Die Funktion <code>outer()</code> hat Zugriff auf Variablen, die in ihrem eigenen Bereich und im globalen Bereich deklariert sind. <br><br>  Die Gültigkeitsbereichskette des obigen Codes sieht folgendermaßen aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> } }</code> </pre> <br>  Beachten Sie, dass die Funktion <code>inner()</code> von der lexikalischen Umgebung der Funktion <code>outer()</code> ist, die wiederum von einem globalen Bereich umgeben ist.  Aus diesem Grund kann die Funktion <code>inner()</code> auf Variablen zugreifen, die in der Funktion <code>outer()</code> und im globalen Bereich deklariert sind. <br><br><h2>  <font color="#3AC1EF">Praktische Beispiele für Verschlüsse</font> </h2><br>  Betrachten Sie vor dem Zerlegen der Feinheiten der internen Schaltkreise einige praktische Beispiele. <br><br><h3>  <font color="#3AC1EF">▍ Beispiel Nr. 1</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Hier rufen wir die Funktion <code>person()</code> , die die interne Funktion <code>displayName()</code> , und speichern diese Funktion in der Variablen <code>peter</code> .  Wenn wir danach die Funktion <code>peter()</code> aufrufen (die entsprechende Variable speichert tatsächlich einen Verweis auf die Funktion <code>displayName()</code> ), wird der Name <code>Peter</code> in der Konsole angezeigt. <br><br>  Gleichzeitig hat die Funktion <code>displayName()</code> keine Variable mit dem Namen <code>name</code> , sodass wir daraus schließen können, dass diese Funktion auch danach irgendwie auf die Variable zugreifen kann, die in der externen Funktion <code>person()</code> deklariert ist wie diese Funktion funktionierte.  Möglicherweise liegt dies daran, dass die Funktion <code>displayName()</code> tatsächlich ein Abschluss ist. <br><br><h3>  <font color="#3AC1EF">▍ Beispiel Nr. 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Hier speichern wir wie im vorherigen Beispiel den Link zu der anonymen internen Funktion, die von der Funktion <code>getCounter()</code> wird, in der Variablenanzahl.  Da die Funktion <code>count()</code> ein Abschluss ist, kann sie auf die <code>getCount()</code> Funktion <code>getCounter()</code> auch nachdem die Funktion <code>getCounter()</code> ihre Arbeit abgeschlossen hat. <br><br>  Beachten Sie, dass der Wert der <code>counter</code> nicht bei jedem Aufruf der Funktion <code>count()</code> auf 0 zurückgesetzt wird.  Es scheint, dass es auf 0 zurückgesetzt werden sollte, wie es beim Aufrufen einer regulären Funktion der Fall wäre, aber dies geschieht nicht. <br><br>  Dies funktioniert einfach so, da bei jedem Aufruf der Funktion <code>count()</code> ein neuer Bereich dafür erstellt wird, es jedoch nur einen Bereich für die Funktion <code>getCounter()</code> .  Da die <code>getCounter()</code> im Bereich der Funktion <code>getCounter()</code> deklariert ist, wird ihr Wert zwischen Aufrufen der Funktion <code>count()</code> gespeichert, ohne auf 0 zurückgesetzt zu werden. <br><br><h2>  <font color="#3AC1EF">Wie funktionieren Kurzschlüsse?</font> </h2><br>  Bisher haben wir darüber gesprochen, was Verschlüsse sind, und praktische Beispiele untersucht.  Lassen Sie uns nun über die internen JavaScript-Mechanismen sprechen, mit denen sie funktionieren. <br><br>  Um Abschlüsse zu verstehen, müssen wir uns mit zwei entscheidenden JavaScript-Konzepten befassen.  Dies ist der Ausführungskontext und die lexikalische Umgebung. <br><br><h3>  <font color="#3AC1EF">▍ Ausführungskontext</font> </h3><br>  Der Ausführungskontext ist eine abstrakte Umgebung, in der JavaScript-Code berechnet und ausgeführt wird.  Wenn globaler Code ausgeführt wird, geschieht dies im globalen Ausführungskontext.  Der Funktionscode wird im Kontext der Funktion ausgeführt. <br><br>  Zu einem bestimmten Zeitpunkt kann Code nur in einem Ausführungskontext ausgeführt werden (JavaScript ist eine Single-Threaded-Programmiersprache).  Diese Prozesse werden über den sogenannten Call Stack verwaltet. <br><br>  Der Aufrufstapel ist eine Datenstruktur, die nach dem LIFO-Prinzip angeordnet ist (Last In, First Out - Last In, First Out).  Neue Elemente können nur oben auf dem Stapel platziert und nur Elemente daraus entfernt werden. <br><br>  Der aktuelle Ausführungskontext befindet sich immer oben im Stapel. Wenn die aktuelle Funktion beendet wird, wird ihr Ausführungskontext aus dem Stapel gezogen und die Steuerung in den Ausführungskontext übertragen, der sich im Aufrufstapel unterhalb des Kontexts dieser Funktion befand. <br><br>  Betrachten Sie das folgende Beispiel, um den Ausführungskontext und den Aufrufstapel besser zu verstehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/04d/ef3/e2304def39694bb52330011b2f0fa4af.png"></div><br>  <i><font color="#999999">Beispiel für einen Ausführungskontext</font></i> <br><br>  Wenn dieser Code ausgeführt wird, erstellt die JavaScript-Engine einen globalen Ausführungskontext zum Ausführen des globalen Codes. Wenn sie auf einen Aufruf der Funktion <code>first()</code> stößt, erstellt sie einen neuen Ausführungskontext für diese Funktion und platziert ihn oben auf dem Stapel. <br><br>  Der Aufrufstapel dieses Codes sieht folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/86c/7d2/61286c7d24769fa8df93b030e4d98c6b.png"></div><br>  <i><font color="#999999">Stapel aufrufen</font></i> <br><br>  Wenn die Ausführung der Funktion <code>first()</code> abgeschlossen ist, wird ihr Ausführungskontext aus dem Aufrufstapel abgerufen und die Steuerung in den darunter liegenden Ausführungskontext, dh in den globalen Kontext, übertragen.  Danach wird der im globalen Bereich verbleibende Code ausgeführt. <br><br><h3>  <font color="#3AC1EF">▍Lexische Umgebung</font> </h3><br>  Jedes Mal, wenn die JS-Engine einen Ausführungskontext zum Ausführen einer Funktion oder eines globalen Codes erstellt, erstellt sie auch eine neue lexikalische Umgebung zum Speichern der in dieser Funktion deklarierten Variablen während ihrer Ausführung. <br><br>  Die lexikalische Umgebung ist eine Datenstruktur, in der Informationen über die Entsprechung von Bezeichnern und Variablen gespeichert werden.  Hier ist "Bezeichner" der Name einer Variablen oder Funktion, und "Variable" ist eine Referenz auf ein Objekt (dies schließt Funktionen ein) oder einen Wert eines primitiven Typs. <br><br>  Die lexikalische Umgebung enthält zwei Komponenten: <br><br><ul><li>  Ein Umgebungsdatensatz ist der Ort, an dem Variablen- und Funktionsdeklarationen gespeichert werden. </li><li>  Verweis auf die äußere Umgebung - ein Link, über den Sie auf die externe (übergeordnete) lexikalische Umgebung zugreifen können.  Dies ist die wichtigste Komponente, die behandelt werden muss, um Verschlüsse zu verstehen. </li></ul><br>  Konzeptionell sieht die lexikalische Umgebung folgendermaßen aus: <br><br><pre> <code class="hljs xml">lexicalEnvironment = { environmentRecord: {   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>,   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> } outer: <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">the</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">parent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lexical</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">environment</span></span></span><span class="hljs-tag">&gt;</span></span> }</code> </pre> <br>  Schauen Sie sich das folgende Code-Snippet an: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">25</span></span>;  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside first function'</span></span>); } first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside global execution context'</span></span>);</code> </pre> <br>  Wenn die JS-Engine einen globalen Ausführungskontext zum Ausführen von globalem Code erstellt, erstellt sie auch eine neue lexikalische Umgebung zum Speichern von Variablen und Funktionen, die im globalen Bereich deklariert sind.  Infolgedessen sieht die lexikalische Umgebung des globalen Bereichs folgendermaßen aus: <br><br><pre> <code class="hljs pgsql">globalLexicalEnvironment = { environmentRecord: {     a : <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>,     first : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br>  Bitte beachten Sie, dass der Verweis auf die externe lexikalische Umgebung ( <code>outer</code> ) auf <code>null</code> , da der globale Bereich keine externe lexikalische Umgebung hat. <br><br>  Wenn die Engine einen Ausführungskontext für die Funktion <code>first()</code> , erstellt sie auch eine lexikalische Umgebung zum Speichern der in dieser Funktion deklarierten Variablen während ihrer Ausführung.  Infolgedessen sieht die lexikalische Umgebung der Funktion folgendermaßen aus: <br><br><pre> <code class="hljs pgsql">functionLexicalEnvironment = { environmentRecord: {     b : <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Die Verknüpfung zur externen lexikalischen Umgebung der Funktion wird auf <code>&lt;globalLexicalEnvironment&gt;</code> , da sich der Funktionscode im Quellcode im globalen Bereich befindet. <br><br>  Beachten Sie, dass nach Beendigung der Arbeit der Ausführungskontext der Funktion aus dem Aufrufstapel abgerufen wird, die lexikalische Umgebung jedoch möglicherweise aus dem Speicher gelöscht wird oder dort verbleibt.  Es hängt davon ab, ob in anderen lexikalischen Umgebungen Verweise auf diese lexikalische Umgebung in Form von Links zu einer externen lexikalischen Umgebung vorhanden sind. <br><br><h2>  <font color="#3AC1EF">Detaillierte Analyse von Beispielen für die Arbeit mit Verschlüssen</font> </h2><br>  Nachdem wir uns mit dem Wissen über den Ausführungskontext und die lexikalische Umgebung vertraut gemacht haben, werden wir zu Abschlüssen zurückkehren und dieselben Codefragmente, die wir bereits untersucht haben, genauer analysieren. <br><br><h3>  <font color="#3AC1EF">▍ Beispiel Nr. 1</font> </h3><br>  Schauen Sie sich dieses Code-Snippet an: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Wenn die <code>person()</code> -Funktion ausgeführt wird, erstellt die JS-Engine einen neuen Ausführungskontext und eine neue lexikalische Umgebung für diese Funktion.  Nach Abschluss der Arbeit gibt die Funktion die Funktion <code>displayName()</code> . Ein Verweis auf diese Funktion wird in die Variable <code>peter</code> . <br><br>  Ihre lexikalische Umgebung wird folgendermaßen aussehen: <br><br><pre> <code class="hljs powershell">personLexicalEnvironment = { environmentRecord: {   name : <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>,   displayName: &lt; displayName <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reference</span></span></span><span class="hljs-function">&gt; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer</span></span></span><span class="hljs-function">: &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">globalLexicalEnvironment</span></span></span><span class="hljs-function">&gt; }</span></span></code> </pre> <br>  Wenn die Funktion <code>person()</code> wird, wird ihr Ausführungskontext vom Stapel entfernt.  Die lexikalische Umgebung bleibt jedoch im Speicher, da in der lexikalischen Umgebung der internen Funktion <code>displayName()</code> eine Verknüpfung zu ihr besteht.  Infolgedessen bleiben in dieser lexikalischen Umgebung deklarierte Variablen verfügbar. <br><br>  Wenn die Funktion <code>peter()</code> aufgerufen wird (die entsprechende Variable speichert einen Verweis auf die Funktion <code>displayName()</code> ), erstellt die JS-Engine einen neuen Ausführungskontext und eine neue lexikalische Umgebung für diese Funktion.  Diese lexikalische Umgebung sieht folgendermaßen aus: <br><br><pre> <code class="hljs pgsql">displayNameLexicalEnvironment = { environmentRecord: {   } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;personLexicalEnvironment&gt; }</code> </pre> <br>  Die Funktion <code>displayName()</code> keine Variablen, daher ist der Umgebungsdatensatz leer.  Während der Ausführung dieser Funktion versucht die JS-Engine, die Namensvariable in der lexikalischen Umgebung der Funktion zu finden. <br><br>  Da die Suche in der lexikalischen Umgebung der Funktion <code>displayName()</code> kann, wird die Suche in der externen lexikalischen Umgebung fortgesetzt, <code>displayName()</code> in der lexikalischen Umgebung der Funktion <code>person()</code> , die sich noch im Speicher befindet.  Dort findet die Engine die gewünschte Variable und zeigt ihren Wert in der Konsole an. <br><br><h3>  <font color="#3AC1EF">▍ Beispiel Nr. 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Die lexikalische Umgebung der Funktion <code>getCounter()</code> sieht folgendermaßen aus: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">0</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Diese Funktion gibt eine anonyme Funktion zurück, die der <code>count</code> zugewiesen ist. <br><br>  Wenn die Funktion <code>count()</code> ausgeführt wird, sieht ihre lexikalische Umgebung folgendermaßen aus: <br><br><pre> <code class="hljs pgsql">countLexicalEnvironment = { environmentRecord: { } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;getCountLexicalEnvironment&gt; }</code> </pre> <br>  Bei Ausführung dieser Funktion sucht das System in seiner lexikalischen Umgebung nach der Zählervariablen.  Auch in diesem Fall ist der Funktionsumgebungsdatensatz leer, sodass die Suche nach der Variablen in der externen lexikalischen Umgebung der Funktion fortgesetzt wird. <br><br>  Die Engine findet die Variable, zeigt sie in der Konsole an und erhöht die <code>getCounter()</code> , die in der lexikalischen Umgebung der Funktion <code>getCounter()</code> gespeichert ist. <br><br>  Infolgedessen <code>getCounter()</code> die lexikalische Umgebung der Funktion <code>getCounter()</code> nach dem ersten Aufruf der Funktion <code>count()</code> aus: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">1</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Bei jedem Aufruf der Funktion <code>count()</code> erstellt die JavaScript-Engine eine neue lexikalische Umgebung für diese Funktion und erhöht die <code>getCounter()</code> , was zu Änderungen in der lexikalischen Umgebung der Funktion <code>getCounter()</code> . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir darüber gesprochen, was Verschlüsse sind, und die zugrunde liegenden JavaScript-Mechanismen aussortiert, die ihnen zugrunde liegen.  Closures sind eines der wichtigsten grundlegenden JavaScript-Konzepte, und jeder JS-Entwickler sollte sie verstehen.  Das Verständnis von Schließungen ist einer der Schritte zum Schreiben effektiver und qualitativ hochwertiger Anwendungen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie Erfahrung in der JS-Entwicklung haben, teilen Sie bitte Anfängern praktische Beispiele für die Verwendung von Verschlüssen mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424967/">https://habr.com/ru/post/de424967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424955/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 332 (24. - 30. September 2018)</a></li>
<li><a href="../de424957/index.html">Generieren von Bildern aus Text mit AttnGAN</a></li>
<li><a href="../de424961/index.html">MTA-STS für Postfix</a></li>
<li><a href="../de424963/index.html">Zuckerberg-Finanzierung: Gemeinsam Werkzeuge für die Wissenschaft bauen</a></li>
<li><a href="../de424965/index.html">Reagieren Sie auf die Anwendungsentwicklung mit ReasonReact</a></li>
<li><a href="../de424969/index.html">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a></li>
<li><a href="../de424971/index.html">Habrokast "Sunset Manually" # 1. Versuch, eine Umgebung für die Entwicklung eines Spielzeugs für Windows einzurichten</a></li>
<li><a href="../de424973/index.html">Gesichtserkennung auf Video: Raspberry Pi und Neural Compute Stick</a></li>
<li><a href="../de424975/index.html">SIEM-Tiefen: Out-of-Box-Korrelationen. Teil 2. Datenschema als Reflexion des Weltmodells</a></li>
<li><a href="../de424977/index.html">Aus Fehlern lernen: Anwendungen im App Store und bei Google Play optimieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>