<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèª üçµ üôÖüèø JavaScript-Verkn√ºpfungen f√ºr Anf√§nger üôéüèΩ ü•§ ‚ò∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Closures sind eines der grundlegenden Konzepte von JavaScript und verursachen f√ºr viele Anf√§nger Schwierigkeiten, die jeder JS-Programmierer kennen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Verkn√ºpfungen f√ºr Anf√§nger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424967/">  Closures sind eines der grundlegenden Konzepte von JavaScript und verursachen f√ºr viele Anf√§nger Schwierigkeiten, die jeder JS-Programmierer kennen und verstehen sollte.  Mit einem guten Verst√§ndnis der Verschl√ºsse k√∂nnen Sie besseren, effizienteren und saubereren Code schreiben.  Dies wiederum tr√§gt zu Ihrer beruflichen Weiterentwicklung bei. <br><br>  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, widmet sich der Geschichte der internen Mechanismen von Schlie√üungen und ihrer Funktionsweise in JavaScript-Programmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/808/540/652808540f60e3a5f1b4b255fe90337a.png"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist eine Schlie√üung?</font> </h2><br>  Ein Abschluss ist eine Funktion, die Zugriff auf einen Bereich hat, der von einer externen Funktion relativ zu ihm gebildet wird, selbst nachdem diese externe Funktion ihre Arbeit abgeschlossen hat.  Dies bedeutet, dass ein Abschluss Variablen speichern kann, die in einer externen Funktion deklariert sind, und an sie √ºbergebene Argumente.  Bevor wir tats√§chlich zu Schlie√üungen √ºbergehen, werden wir uns mit dem Konzept der ‚Äûlexikalischen Umgebung‚Äú befassen. <br><br><h2>  <font color="#3AC1EF">Was ist eine lexikalische Umgebung?</font> </h2><br>  Der Begriff "lexikalische Umgebung" oder "statische Umgebung" in JavaScript bezieht sich auf die M√∂glichkeit, auf Variablen, Funktionen und Objekte basierend auf ihrer physischen Position im Quellcode zuzugreifen.  Betrachten Sie ein Beispiel: <br><br><pre><code class="hljs pgsql">let a = <span class="hljs-string"><span class="hljs-string">'global'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>() {    let b = <span class="hljs-string"><span class="hljs-string">'outer'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>() {      let c = <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(c);   // <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(b);   // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>      console.log(a);   // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    }    console.log(a);     // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    console.log(b);     // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>();  } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>(); console.log(a);         // <span class="hljs-string"><span class="hljs-string">'global'</span></span></code> </pre> <br>  Hier hat die <code>inner()</code> Funktion Zugriff auf Variablen, die in ihrem eigenen Bereich, im Bereich der <code>outer()</code> Funktion und im globalen Bereich deklariert sind.  Die Funktion <code>outer()</code> hat Zugriff auf Variablen, die in ihrem eigenen Bereich und im globalen Bereich deklariert sind. <br><br>  Die G√ºltigkeitsbereichskette des obigen Codes sieht folgenderma√üen aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> } }</code> </pre> <br>  Beachten Sie, dass die Funktion <code>inner()</code> von der lexikalischen Umgebung der Funktion <code>outer()</code> ist, die wiederum von einem globalen Bereich umgeben ist.  Aus diesem Grund kann die Funktion <code>inner()</code> auf Variablen zugreifen, die in der Funktion <code>outer()</code> und im globalen Bereich deklariert sind. <br><br><h2>  <font color="#3AC1EF">Praktische Beispiele f√ºr Verschl√ºsse</font> </h2><br>  Betrachten Sie vor dem Zerlegen der Feinheiten der internen Schaltkreise einige praktische Beispiele. <br><br><h3>  <font color="#3AC1EF">‚ñç Beispiel Nr. 1</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Hier rufen wir die Funktion <code>person()</code> , die die interne Funktion <code>displayName()</code> , und speichern diese Funktion in der Variablen <code>peter</code> .  Wenn wir danach die Funktion <code>peter()</code> aufrufen (die entsprechende Variable speichert tats√§chlich einen Verweis auf die Funktion <code>displayName()</code> ), wird der Name <code>Peter</code> in der Konsole angezeigt. <br><br>  Gleichzeitig hat die Funktion <code>displayName()</code> keine Variable mit dem Namen <code>name</code> , sodass wir daraus schlie√üen k√∂nnen, dass diese Funktion auch danach irgendwie auf die Variable zugreifen kann, die in der externen Funktion <code>person()</code> deklariert ist wie diese Funktion funktionierte.  M√∂glicherweise liegt dies daran, dass die Funktion <code>displayName()</code> tats√§chlich ein Abschluss ist. <br><br><h3>  <font color="#3AC1EF">‚ñç Beispiel Nr. 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Hier speichern wir wie im vorherigen Beispiel den Link zu der anonymen internen Funktion, die von der Funktion <code>getCounter()</code> wird, in der Variablenanzahl.  Da die Funktion <code>count()</code> ein Abschluss ist, kann sie auf die <code>getCount()</code> Funktion <code>getCounter()</code> auch nachdem die Funktion <code>getCounter()</code> ihre Arbeit abgeschlossen hat. <br><br>  Beachten Sie, dass der Wert der <code>counter</code> nicht bei jedem Aufruf der Funktion <code>count()</code> auf 0 zur√ºckgesetzt wird.  Es scheint, dass es auf 0 zur√ºckgesetzt werden sollte, wie es beim Aufrufen einer regul√§ren Funktion der Fall w√§re, aber dies geschieht nicht. <br><br>  Dies funktioniert einfach so, da bei jedem Aufruf der Funktion <code>count()</code> ein neuer Bereich daf√ºr erstellt wird, es jedoch nur einen Bereich f√ºr die Funktion <code>getCounter()</code> .  Da die <code>getCounter()</code> im Bereich der Funktion <code>getCounter()</code> deklariert ist, wird ihr Wert zwischen Aufrufen der Funktion <code>count()</code> gespeichert, ohne auf 0 zur√ºckgesetzt zu werden. <br><br><h2>  <font color="#3AC1EF">Wie funktionieren Kurzschl√ºsse?</font> </h2><br>  Bisher haben wir dar√ºber gesprochen, was Verschl√ºsse sind, und praktische Beispiele untersucht.  Lassen Sie uns nun √ºber die internen JavaScript-Mechanismen sprechen, mit denen sie funktionieren. <br><br>  Um Abschl√ºsse zu verstehen, m√ºssen wir uns mit zwei entscheidenden JavaScript-Konzepten befassen.  Dies ist der Ausf√ºhrungskontext und die lexikalische Umgebung. <br><br><h3>  <font color="#3AC1EF">‚ñç Ausf√ºhrungskontext</font> </h3><br>  Der Ausf√ºhrungskontext ist eine abstrakte Umgebung, in der JavaScript-Code berechnet und ausgef√ºhrt wird.  Wenn globaler Code ausgef√ºhrt wird, geschieht dies im globalen Ausf√ºhrungskontext.  Der Funktionscode wird im Kontext der Funktion ausgef√ºhrt. <br><br>  Zu einem bestimmten Zeitpunkt kann Code nur in einem Ausf√ºhrungskontext ausgef√ºhrt werden (JavaScript ist eine Single-Threaded-Programmiersprache).  Diese Prozesse werden √ºber den sogenannten Call Stack verwaltet. <br><br>  Der Aufrufstapel ist eine Datenstruktur, die nach dem LIFO-Prinzip angeordnet ist (Last In, First Out - Last In, First Out).  Neue Elemente k√∂nnen nur oben auf dem Stapel platziert und nur Elemente daraus entfernt werden. <br><br>  Der aktuelle Ausf√ºhrungskontext befindet sich immer oben im Stapel. Wenn die aktuelle Funktion beendet wird, wird ihr Ausf√ºhrungskontext aus dem Stapel gezogen und die Steuerung in den Ausf√ºhrungskontext √ºbertragen, der sich im Aufrufstapel unterhalb des Kontexts dieser Funktion befand. <br><br>  Betrachten Sie das folgende Beispiel, um den Ausf√ºhrungskontext und den Aufrufstapel besser zu verstehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/04d/ef3/e2304def39694bb52330011b2f0fa4af.png"></div><br>  <i><font color="#999999">Beispiel f√ºr einen Ausf√ºhrungskontext</font></i> <br><br>  Wenn dieser Code ausgef√ºhrt wird, erstellt die JavaScript-Engine einen globalen Ausf√ºhrungskontext zum Ausf√ºhren des globalen Codes. Wenn sie auf einen Aufruf der Funktion <code>first()</code> st√∂√üt, erstellt sie einen neuen Ausf√ºhrungskontext f√ºr diese Funktion und platziert ihn oben auf dem Stapel. <br><br>  Der Aufrufstapel dieses Codes sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/86c/7d2/61286c7d24769fa8df93b030e4d98c6b.png"></div><br>  <i><font color="#999999">Stapel aufrufen</font></i> <br><br>  Wenn die Ausf√ºhrung der Funktion <code>first()</code> abgeschlossen ist, wird ihr Ausf√ºhrungskontext aus dem Aufrufstapel abgerufen und die Steuerung in den darunter liegenden Ausf√ºhrungskontext, dh in den globalen Kontext, √ºbertragen.  Danach wird der im globalen Bereich verbleibende Code ausgef√ºhrt. <br><br><h3>  <font color="#3AC1EF">‚ñçLexische Umgebung</font> </h3><br>  Jedes Mal, wenn die JS-Engine einen Ausf√ºhrungskontext zum Ausf√ºhren einer Funktion oder eines globalen Codes erstellt, erstellt sie auch eine neue lexikalische Umgebung zum Speichern der in dieser Funktion deklarierten Variablen w√§hrend ihrer Ausf√ºhrung. <br><br>  Die lexikalische Umgebung ist eine Datenstruktur, in der Informationen √ºber die Entsprechung von Bezeichnern und Variablen gespeichert werden.  Hier ist "Bezeichner" der Name einer Variablen oder Funktion, und "Variable" ist eine Referenz auf ein Objekt (dies schlie√üt Funktionen ein) oder einen Wert eines primitiven Typs. <br><br>  Die lexikalische Umgebung enth√§lt zwei Komponenten: <br><br><ul><li>  Ein Umgebungsdatensatz ist der Ort, an dem Variablen- und Funktionsdeklarationen gespeichert werden. </li><li>  Verweis auf die √§u√üere Umgebung - ein Link, √ºber den Sie auf die externe (√ºbergeordnete) lexikalische Umgebung zugreifen k√∂nnen.  Dies ist die wichtigste Komponente, die behandelt werden muss, um Verschl√ºsse zu verstehen. </li></ul><br>  Konzeptionell sieht die lexikalische Umgebung folgenderma√üen aus: <br><br><pre> <code class="hljs xml">lexicalEnvironment = { environmentRecord: {   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>,   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> } outer: <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">the</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">parent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lexical</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">environment</span></span></span><span class="hljs-tag">&gt;</span></span> }</code> </pre> <br>  Schauen Sie sich das folgende Code-Snippet an: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">25</span></span>;  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside first function'</span></span>); } first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside global execution context'</span></span>);</code> </pre> <br>  Wenn die JS-Engine einen globalen Ausf√ºhrungskontext zum Ausf√ºhren von globalem Code erstellt, erstellt sie auch eine neue lexikalische Umgebung zum Speichern von Variablen und Funktionen, die im globalen Bereich deklariert sind.  Infolgedessen sieht die lexikalische Umgebung des globalen Bereichs folgenderma√üen aus: <br><br><pre> <code class="hljs pgsql">globalLexicalEnvironment = { environmentRecord: {     a : <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>,     first : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br>  Bitte beachten Sie, dass der Verweis auf die externe lexikalische Umgebung ( <code>outer</code> ) auf <code>null</code> , da der globale Bereich keine externe lexikalische Umgebung hat. <br><br>  Wenn die Engine einen Ausf√ºhrungskontext f√ºr die Funktion <code>first()</code> , erstellt sie auch eine lexikalische Umgebung zum Speichern der in dieser Funktion deklarierten Variablen w√§hrend ihrer Ausf√ºhrung.  Infolgedessen sieht die lexikalische Umgebung der Funktion folgenderma√üen aus: <br><br><pre> <code class="hljs pgsql">functionLexicalEnvironment = { environmentRecord: {     b : <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Die Verkn√ºpfung zur externen lexikalischen Umgebung der Funktion wird auf <code>&lt;globalLexicalEnvironment&gt;</code> , da sich der Funktionscode im Quellcode im globalen Bereich befindet. <br><br>  Beachten Sie, dass nach Beendigung der Arbeit der Ausf√ºhrungskontext der Funktion aus dem Aufrufstapel abgerufen wird, die lexikalische Umgebung jedoch m√∂glicherweise aus dem Speicher gel√∂scht wird oder dort verbleibt.  Es h√§ngt davon ab, ob in anderen lexikalischen Umgebungen Verweise auf diese lexikalische Umgebung in Form von Links zu einer externen lexikalischen Umgebung vorhanden sind. <br><br><h2>  <font color="#3AC1EF">Detaillierte Analyse von Beispielen f√ºr die Arbeit mit Verschl√ºssen</font> </h2><br>  Nachdem wir uns mit dem Wissen √ºber den Ausf√ºhrungskontext und die lexikalische Umgebung vertraut gemacht haben, werden wir zu Abschl√ºssen zur√ºckkehren und dieselben Codefragmente, die wir bereits untersucht haben, genauer analysieren. <br><br><h3>  <font color="#3AC1EF">‚ñç Beispiel Nr. 1</font> </h3><br>  Schauen Sie sich dieses Code-Snippet an: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Wenn die <code>person()</code> -Funktion ausgef√ºhrt wird, erstellt die JS-Engine einen neuen Ausf√ºhrungskontext und eine neue lexikalische Umgebung f√ºr diese Funktion.  Nach Abschluss der Arbeit gibt die Funktion die Funktion <code>displayName()</code> . Ein Verweis auf diese Funktion wird in die Variable <code>peter</code> . <br><br>  Ihre lexikalische Umgebung wird folgenderma√üen aussehen: <br><br><pre> <code class="hljs powershell">personLexicalEnvironment = { environmentRecord: {   name : <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>,   displayName: &lt; displayName <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reference</span></span></span><span class="hljs-function">&gt; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer</span></span></span><span class="hljs-function">: &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">globalLexicalEnvironment</span></span></span><span class="hljs-function">&gt; }</span></span></code> </pre> <br>  Wenn die Funktion <code>person()</code> wird, wird ihr Ausf√ºhrungskontext vom Stapel entfernt.  Die lexikalische Umgebung bleibt jedoch im Speicher, da in der lexikalischen Umgebung der internen Funktion <code>displayName()</code> eine Verkn√ºpfung zu ihr besteht.  Infolgedessen bleiben in dieser lexikalischen Umgebung deklarierte Variablen verf√ºgbar. <br><br>  Wenn die Funktion <code>peter()</code> aufgerufen wird (die entsprechende Variable speichert einen Verweis auf die Funktion <code>displayName()</code> ), erstellt die JS-Engine einen neuen Ausf√ºhrungskontext und eine neue lexikalische Umgebung f√ºr diese Funktion.  Diese lexikalische Umgebung sieht folgenderma√üen aus: <br><br><pre> <code class="hljs pgsql">displayNameLexicalEnvironment = { environmentRecord: {   } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;personLexicalEnvironment&gt; }</code> </pre> <br>  Die Funktion <code>displayName()</code> keine Variablen, daher ist der Umgebungsdatensatz leer.  W√§hrend der Ausf√ºhrung dieser Funktion versucht die JS-Engine, die Namensvariable in der lexikalischen Umgebung der Funktion zu finden. <br><br>  Da die Suche in der lexikalischen Umgebung der Funktion <code>displayName()</code> kann, wird die Suche in der externen lexikalischen Umgebung fortgesetzt, <code>displayName()</code> in der lexikalischen Umgebung der Funktion <code>person()</code> , die sich noch im Speicher befindet.  Dort findet die Engine die gew√ºnschte Variable und zeigt ihren Wert in der Konsole an. <br><br><h3>  <font color="#3AC1EF">‚ñç Beispiel Nr. 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Die lexikalische Umgebung der Funktion <code>getCounter()</code> sieht folgenderma√üen aus: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">0</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Diese Funktion gibt eine anonyme Funktion zur√ºck, die der <code>count</code> zugewiesen ist. <br><br>  Wenn die Funktion <code>count()</code> ausgef√ºhrt wird, sieht ihre lexikalische Umgebung folgenderma√üen aus: <br><br><pre> <code class="hljs pgsql">countLexicalEnvironment = { environmentRecord: { } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;getCountLexicalEnvironment&gt; }</code> </pre> <br>  Bei Ausf√ºhrung dieser Funktion sucht das System in seiner lexikalischen Umgebung nach der Z√§hlervariablen.  Auch in diesem Fall ist der Funktionsumgebungsdatensatz leer, sodass die Suche nach der Variablen in der externen lexikalischen Umgebung der Funktion fortgesetzt wird. <br><br>  Die Engine findet die Variable, zeigt sie in der Konsole an und erh√∂ht die <code>getCounter()</code> , die in der lexikalischen Umgebung der Funktion <code>getCounter()</code> gespeichert ist. <br><br>  Infolgedessen <code>getCounter()</code> die lexikalische Umgebung der Funktion <code>getCounter()</code> nach dem ersten Aufruf der Funktion <code>count()</code> aus: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">1</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Bei jedem Aufruf der Funktion <code>count()</code> erstellt die JavaScript-Engine eine neue lexikalische Umgebung f√ºr diese Funktion und erh√∂ht die <code>getCounter()</code> , was zu √Ñnderungen in der lexikalischen Umgebung der Funktion <code>getCounter()</code> . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir dar√ºber gesprochen, was Verschl√ºsse sind, und die zugrunde liegenden JavaScript-Mechanismen aussortiert, die ihnen zugrunde liegen.  Closures sind eines der wichtigsten grundlegenden JavaScript-Konzepte, und jeder JS-Entwickler sollte sie verstehen.  Das Verst√§ndnis von Schlie√üungen ist einer der Schritte zum Schreiben effektiver und qualitativ hochwertiger Anwendungen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie Erfahrung in der JS-Entwicklung haben, teilen Sie bitte Anf√§ngern praktische Beispiele f√ºr die Verwendung von Verschl√ºssen mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424967/">https://habr.com/ru/post/de424967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424955/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 332 (24. - 30. September 2018)</a></li>
<li><a href="../de424957/index.html">Generieren von Bildern aus Text mit AttnGAN</a></li>
<li><a href="../de424961/index.html">MTA-STS f√ºr Postfix</a></li>
<li><a href="../de424963/index.html">Zuckerberg-Finanzierung: Gemeinsam Werkzeuge f√ºr die Wissenschaft bauen</a></li>
<li><a href="../de424965/index.html">Reagieren Sie auf die Anwendungsentwicklung mit ReasonReact</a></li>
<li><a href="../de424969/index.html">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a></li>
<li><a href="../de424971/index.html">Habrokast "Sunset Manually" # 1. Versuch, eine Umgebung f√ºr die Entwicklung eines Spielzeugs f√ºr Windows einzurichten</a></li>
<li><a href="../de424973/index.html">Gesichtserkennung auf Video: Raspberry Pi und Neural Compute Stick</a></li>
<li><a href="../de424975/index.html">SIEM-Tiefen: Out-of-Box-Korrelationen. Teil 2. Datenschema als Reflexion des Weltmodells</a></li>
<li><a href="../de424977/index.html">Aus Fehlern lernen: Anwendungen im App Store und bei Google Play optimieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>