<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛲️ 👏 🔬 Reconocimiento de gestos con APDS-9960 🥗 🤢 🛀🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al leer los comentarios en mi artículo anterior sobre APDS-9960, donde se trataba del reconocimiento de color y el nivel de luz, dos cosas se hicieron...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reconocimiento de gestos con APDS-9960</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424947/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/bk/bh/oxbkbhl6uwlr0-1dynm5tppscw0.jpeg" alt="imagen"></div><br>  Al leer los comentarios en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> anterior sobre APDS-9960, donde se trataba del reconocimiento de color y el nivel de luz, dos cosas se hicieron obvias para mí: 1) el tema del reconocimiento de gestos es interesante y 2) este tema no se revela. <br><br>  De hecho, si tomé la descripción del APDS-9960, sin considerar los gestos, la descripción parece algo incompleta.  Así que también encontré algo de tiempo libre para explorar este tema. <br><br>  En este artículo, traigo a su atención una descripción general de las capacidades de reconocimiento de gestos que proporciona el sensor APDS-9960. <br><a name="habracut"></a><br>  El artículo considerará el mecanismo de configuración del sensor, recopilación de datos, procesamiento y presentación.  Usted mismo puede ver lo fácil que es trabajar con gestos utilizando el APDS-9960. <br><br>  Como la última vez, el artículo irá acompañado de un código, todo lo que ocurra en el que se describirá en detalle.  La versión completa del código está disponible al final del artículo. <br><br>  Inmediatamente un pequeño comentario: APDS-9960 no tiene un mecanismo de detección de gestos automático incorporado;  es decir, aquí mismo, leí, significa, el registro, y allí yace el gesto procesado, esto no está en APDS-9960;  y esto significa que debe escribir su propio algoritmo de interpretación de gestos, que haremos más adelante. <br><br>  En general, esto es bueno y no muy bueno.  En realidad no, porque puede complicar el estudio de este sensor para un principiante, pero bueno, porque, junto con los datos de aproximación, puede, por refinamiento, incluso crear sus propios gestos de varios tipos y de cualquier tipo. <br><br>  Pero, dado que este artículo solo tiene una función de descripción general, nos restringimos a solo los gestos básicos ARRIBA-ABAJO-IZQUIERDA-DERECHA. <br><br>  Bueno, empecemos. <br><br><h3>  Teoría </h3><br>  Me permitiré un poco de material. <br><br>  Para obtener la información necesaria sobre el movimiento y la dirección del movimiento, el APDS-9960 utiliza un LED IR y cuatro fotodiodos que, como se ilustra en la figura a continuación, detecta señales en el rango del infrarrojo cercano (NIR). <br><br><img src="https://habrastorage.org/webt/__/k4/vq/__k4vqf3yty6sjcshtq77znw_v0.jpeg" alt="imagen"><br><br>  El LED IR (LED) tiene la función de luz de fondo, y los fotodiodos (UDLR) registran la luz reflejada por el "obstáculo". <br><br>  Los fotodiodos están ubicados en el sensor de tal manera que, dependiendo de la dirección del movimiento del "obstáculo", el fotodiodo correspondiente recibirá la mayor parte de la señal IR reflejada en la entrada y una parte más pequeña en la salida.  Al mismo tiempo, la documentación del APDS-9960 nos dice inequívocamente que puede interpretar la dirección del movimiento midiendo y comparando la amplitud y la diferencia de fase de las señales de los fotodiodos UDLR. <br><br><img src="https://habrastorage.org/webt/aj/ts/ok/ajtsok_p-tpsaa1cyx5uoy2uonm.jpeg" alt="imagen"><br><br><h3>  Practica </h3><br>  Para trabajar con APDS-9960, así como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">última vez</a> , utilizaremos STM32VLDISCOVERY.  La conexión tampoco ha cambiado. <br><br>  <u>Configurar APDS-9960</u> <br><br>  Realizamos la configuración inicial del sensor. <br><br>  Así: <br><br><div class="spoiler">  <b class="spoiler_title">APDS9960_init</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">APDS9960_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN); i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH); i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN); i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH); }</code> </pre> </div></div><br>  ¿Qué está pasando aquí?  Vamos a hacerlo bien. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN);</code> </pre> <br>  PGAIN (Control de ganancia de proximidad) es un parámetro que controla la ganancia de sensibilidad de proximidad.  Asigne un valor de 2, que corresponde a cuatro veces la ganancia. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH);</code> </pre> <br>  GPENTH (Registro de umbral de entrada de proximidad de gesto): este parámetro establece el valor de umbral de proximidad para determinar el comienzo del reconocimiento de gestos. <br><br>  GEXTH (Registro de umbral de salida de gestos), respectivamente, establece un valor umbral para determinar el final del reconocimiento de gestos. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN);</code> </pre> <br>  En el registro GCONF2 (configuración de gestos dos), establecemos explícitamente solo el parámetro GGAIN (control de ganancia de gestos) en cuatro veces el valor de ganancia. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH);</code> </pre> <br>  Luz de fondo  De forma predeterminada, el valor de la fuente actual del LED de retroiluminación IR se establece en 0, que corresponde a una corriente de 100 mA, esto nos conviene perfectamente, no lo cambiaremos. <br><br>  La iluminación IR en el APDS-9960 es una secuencia de pulsos y se caracteriza por los parámetros de registro correspondientes para gestos GPULSE (conteo y longitud de pulso de gesto): GPLEN (longitud de pulso de gesto) y GPULSE (número de pulsos de gesto), así como la aproximación PPULSE (registro de conteo de pulso de proximidad ): PPLEN (longitud de pulso de proximidad) y PPULSE (conteo de pulso de proximidad) configuran el número de pulsos y el período de cada pulso individual. <br><br>  Defina que GPLEN y PPLEN tomarán un valor de 2 igual a 16 μs, y GPULSE y PPULSE un valor de 9, que corresponde a 10 pulsos. <br><br>  Como puede ver, la configuración resultó ser un poco más complicada que la similar para el reconocimiento de color y la iluminación de la revisión anterior APDS-9960. <br><br>  <u>Lectura de datos</u> <br><br>  Ahora pasaremos al ciclo principal del programa, en el que comenzaremos a registrar e interpretar datos de fotodiodos de vez en cuando, y también aprenderemos a distinguir un gesto de otro. <br><br>  Primero lo primero, comencemos el APDS-9960 con funciones para trabajar con gestos y zoom. <br><br><pre> <code class="cpp hljs">GesturesSet(GESTURES_START);</code> </pre> <br>  E inmediatamente comenzamos a rastrear el parámetro GVALID.  GVALID (Gesture FIFO Data) es un parámetro del registro GSTATUS (Gesture Status Register) que, al estar en un estado distinto de cero, nos informa que el sensor tiene datos gestuales utilizables. <br><br>  La documentación nos enseña que la información de gestos está en el búfer, en el área de RAM, que en general tiene un tamaño de 32 x 4 bytes. <br><br>  En la práctica, el tamaño real de este búfer se puede encontrar leyendo el valor del registro GFLVL (nivel de gesto FIFO), es decir.  De acuerdo con mis observaciones experimentales puramente empíricas, se obtiene GFLVL * 4.  Algo como esto: <br><br><img src="https://habrastorage.org/webt/oy/57/ry/oy57ryfaagi3qqrur9htiefckx0.jpeg" alt="imagen"><br><br>  Bueno, como se desprende del nombre del búfer, los datos que contiene están ordenados en el orden Primero en entrar - Primero en salir.  Es decir, más o menos, cuanto más "temprano" llegó la señal de cada uno de los fotodiodos, más "alto" estará en el GFLVL. <br><br>  Los datos de los fotodiodos (UDLR) se pueden leer del correspondiente registro de gestos FIFO: <br><br>  - GFIFO_U (Gesto FIFO Datos, ARRIBA) <br>  - GFIFO_D (Datos FIFO de gestos, ABAJO) <br>  - GFIFO_L (Datos FIFO de gestos, IZQUIERDA) <br>  - GFIFO_R (Gesto FIFO Datos, DERECHA) <br><br>  Después de cada lectura de valores de estos registros, se disminuye GFLVL;  por lo tanto, en el buen sentido, es necesario leer todo el búfer hasta que el GFLVL llegue a cero. <br><br>  Para definir gestos, solo necesitamos los primeros cuatro bytes de este búfer, no más.  Por lo tanto, solo los leeremos. <br><br><pre> <code class="cpp hljs">GestureUp = i2c1_read(APDS9960_GFIFO_U); GestureDown = i2c1_read(APDS9960_GFIFO_D); GestureLeft = i2c1_read(APDS9960_GFIFO_L); GestureRight = i2c1_read(APDS9960_GFIFO_R);</code> </pre><br>  <u>Reconocimiento de gestos</u> <br><br>  Para interpretar qué tipo de gesto ocurrió, haremos cálculos simples: <br><br><pre> <code class="cpp hljs">GestUpDown = GestureUp-GestureDown; GestLeftRight = GestureLeft-GestureRight;</code> </pre> <br>  Para determinar cuáles de los gestos ocurrieron en el momento, no son los valores de GestUpDown y GestLeftRight los que son importantes para nosotros, sino solo el signo de, por así decirlo, un número real. <br><br>  Es decir, tomando los valores negativos y positivos de las variables GestUpDown y GestLeftRight como entrada, determinamos qué gesto es perfecto. <br><br>  La tabla de verdad para las variables GestUpDown y GestLeftRight se muestra en la figura a continuación. <br><br><img src="https://habrastorage.org/webt/xx/ts/g-/xxtsg-0zw2h7ralowsgsd_8tmoc.jpeg" alt="imagen"><br><br>  Ahora reinicie el GFLVL: <br><br><pre> <code class="cpp hljs">GesturesSet(GESTURES_STOP);</code> </pre> <br>  ... y de vuelta al comienzo del ciclo del programa principal. <br><br>  Y ahora todo el código: <br><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_I2C_ADDR 0x39 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_ENABLE 0x80 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GSTATUS 0xAF #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GFLVL 0xAE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Gesture FIFO Register (0xFC – 0xFF): #define APDS9960_GFIFO_U 0xFC #define APDS9960_GFIFO_D 0xFD #define APDS9960_GFIFO_L 0xFE #define APDS9960_GFIFO_R 0xFF #define APDS9960_CONTROL 0x8F #define APDS9960_GPENTH 0xA0 #define APDS9960_GEXTH 0xA1 #define APDS9960_GCONF2 0xA3 #define APDS9960_GPULSE 0xA6 #define APDS9960_PPULSE 0x8E #define GESTURES_START 0x01 #define GESTURES_STOP 0x02 #define DEFAULT_GPENTH 40 // Threshold for entering gesture mode #define DEFAULT_GEXTH 30 // Threshold for exiting gesture mode #define DEFAULT_PGAIN 8 // Proximity Gain Control: 4X #define DEFAULT_GGAIN 0x40 // Gesture Gain Control: 4X #define DEFAULT_PULSE_LENGTH 0x89 // 16us, 10 pulses /* Bit fields */ #define APDS9960_PON 0x01 #define APDS9960_AEN 0x02 #define APDS9960_PEN 0x04 #define APDS9960_WEN 0x08 #define APSD9960_AIEN 0x10 #define APDS9960_PIEN 0x20 #define APDS9960_GEN 0x40 #define APDS9960_GVALID 0x01 int GestUpDown = 0; int GestLeftRight = 0; //----------------------------------------------------------------------- uint8_t i2c1_read(uint8_t addr); void i2c1_write(uint8_t addr, uint8_t data); void I2C1_init(void) { I2C_InitTypeDef I2C_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB| RCC_APB2Periph_AFIO , ENABLE); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); I2C_StructInit(&amp;I2C_InitStructure); I2C_InitStructure.I2C_ClockSpeed = 100000; I2C_InitStructure.I2C_OwnAddress1 = 0x01; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_Init(I2C1, &amp;I2C_InitStructure); I2C_Cmd(I2C1, ENABLE); } //----------------------------------------------------------------------- void APDS9960_init(void) { i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN); i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH); i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN); i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH); } //----------------------------------------------------------------------- uint8_t i2c1_read(uint8_t addr) { uint8_t data; while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Receiver); while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)); data = I2C_ReceiveData(I2C1); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); I2C_AcknowledgeConfig(I2C1, DISABLE); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); return data; } //----------------------------------------------------------------------- void i2c1_write(uint8_t addr, uint8_t data) { I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_SendData(I2C1, data); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {}; } //----------------------------------------------------------------------- void GesturesSet(uint8_t GestSel) { switch (GestSel) { case GESTURES_START: i2c1_write(APDS9960_ENABLE, APDS9960_GEN | APDS9960_PEN | APDS9960_PON); break; case GESTURES_STOP: i2c1_write(APDS9960_ENABLE, APDS9960_PEN | APDS9960_PON); break; default: i2c1_write(APDS9960_ENABLE, APDS9960_GEN | APDS9960_PEN | APDS9960_PON); } } //----------------------------------------------------------------------- int main() { uint8_t GFLVL_buf = 0; uint8_t GSTATUS_buf = 0; uint8_t GestureUp = 0; uint8_t GestureDown = 0; uint8_t GestureLeft = 0; uint8_t GestureRight = 0; I2C1_init(); APDS9960_init(); while (1) { GFLVL_buf = 0; GSTATUS_buf = 0; GestureUp = 0; GestureDown = 0; GestureLeft = 0; GestureRight = 0; GestUpDown = 0; GestLeftRight = 0; GesturesSet(GESTURES_START); GSTATUS_buf = i2c1_read(APDS9960_GSTATUS); if(GSTATUS_buf &amp; APDS9960_GVALID) { GFLVL_buf = i2c1_read(APDS9960_GFLVL); if(GFLVL_buf) { GestureUp = i2c1_read(APDS9960_GFIFO_U); GestureDown = i2c1_read(APDS9960_GFIFO_D); GestureLeft = i2c1_read(APDS9960_GFIFO_L); GestureRight = i2c1_read(APDS9960_GFIFO_R); //Truth table: //UP: GestUpDown(+) | GestLeftRight(+) //DOWN: GestUpDown(-) | GestLeftRight(-) //LEFT: GestUpDown(+) | GestLeftRight(-) //RIGHT: GestUpDown(-) | GestLeftRight(+) GestUpDown = GestureUp-GestureDown; GestLeftRight = GestureLeft-GestureRight; GesturesSet(GESTURES_STOP); } } } }</span></span></span></span></code> </pre><br></div></div><br>  Quiero señalar que el mecanismo de gestos del APDS-9960 funciona muy bien.  El reconocimiento es estable, los filtros integrados en el APDS-9960 UV e IR funcionan bien. <br><br>  Espero que este material sea útil para alguien.  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424947/">https://habr.com/ru/post/es424947/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424935/index.html">Food Design Digest, septiembre de 2018</a></li>
<li><a href="../es424937/index.html">Eventos digitales en Moscú del 1 al 7 de octubre</a></li>
<li><a href="../es424939/index.html">Quine polimórfico</a></li>
<li><a href="../es424941/index.html">Transmisión de datos desde un servicio REST a una cola MQ</a></li>
<li><a href="../es424945/index.html">Smartphone está conduciendo un automóvil de juguete.</a></li>
<li><a href="../es424949/index.html">PHP Digest No. 140 (17-30 de septiembre de 2018)</a></li>
<li><a href="../es424951/index.html">¡Hurra! No fue paranoia</a></li>
<li><a href="../es424955/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 332 (24-30 de septiembre de 2018)</a></li>
<li><a href="../es424957/index.html">Generando imágenes a partir de texto usando AttnGAN</a></li>
<li><a href="../es424961/index.html">MTA-STS para Postfix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>