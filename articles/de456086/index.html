<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèæ üí• üöÇ iOS Storyboards: Analyse der Vor- und Nachteile, Best Practices üóìÔ∏è üññüèª üßó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apple hat Storyboards erstellt, damit Entwickler die Bildschirme von iOS-Anwendungen und die Beziehungen zwischen ihnen visualisieren k√∂nnen. Nicht je...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Storyboards: Analyse der Vor- und Nachteile, Best Practices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/456086/"><img src="https://habrastorage.org/webt/xx/gq/7w/xxgq7wvcgxjuew_bku55csqqvlu.png"><br><br>  Apple hat Storyboards erstellt, damit Entwickler die Bildschirme von iOS-Anwendungen und die Beziehungen zwischen ihnen visualisieren k√∂nnen.  Nicht jeder mochte dieses Tool und das aus gutem Grund.  Ich habe viele Artikel getroffen, in denen Storyboards kritisiert wurden, aber ich habe keine detaillierte und unvoreingenommene Analyse aller Vor- und Nachteile unter Ber√ºcksichtigung von Best Practices gefunden.  Am Ende habe ich beschlossen, einen solchen Artikel selbst zu schreiben. <br><a name="habracut"></a><br>  Ich werde versuchen, die Nachteile und Vorteile der Verwendung von Storyboards im Detail zu analysieren.  Nachdem Sie sie gewogen haben, k√∂nnen Sie eine aussagekr√§ftige Entscheidung treffen, ob sie im Projekt ben√∂tigt werden oder nicht.  Diese Entscheidung muss nicht radikal sein.  Wenn Storyboards in bestimmten Situationen Probleme verursachen, ist ihre Verwendung in anderen gerechtfertigt: Sie hilft, Aufgaben effektiv zu l√∂sen und einfachen, leicht zu wartenden Code zu schreiben. <br><br>  Beginnen wir mit den M√§ngeln und analysieren, ob alle noch relevant sind. <br><br><h2>  Nachteile </h2><br><h3>  1. Storyboards haben Schwierigkeiten, Konflikte beim Zusammenf√ºhren von √Ñnderungen zu verwalten </h3><br>  Storyboard ist eine XML-Datei.  Es ist weniger lesbar als Code, daher ist es schwieriger, Konflikte darin zu l√∂sen.  Diese Komplexit√§t h√§ngt aber auch davon ab, wie wir mit dem Storyboard arbeiten.  Sie k√∂nnen Ihre Aufgabe erheblich vereinfachen, wenn Sie die folgenden Regeln befolgen: <br><br><ul><li> Platzieren Sie nicht die gesamte Benutzeroberfl√§che in einem einzigen Storyboard, sondern teilen Sie sie in mehrere kleinere auf.  Auf diese Weise k√∂nnen Sie die Arbeit an Storyboards ohne das Risiko von Konflikten auf Entwickler verteilen und im Falle ihrer Unvermeidlichkeit die L√∂sung vereinfachen. <br></li><li>  Wenn Sie dieselbe Ansicht an mehreren Stellen verwenden m√ºssen, w√§hlen Sie sie in einer separaten Unterklasse mit einer eigenen Xib-Datei aus. <br></li><li>  Machen Sie h√§ufiger Commits, da es viel einfacher ist, mit √Ñnderungen in kleinen St√ºcken zu arbeiten. <br></li></ul><br>  Die Verwendung mehrerer Storyboards anstelle von einem macht es uns unm√∂glich, die gesamte Karte der Anwendung in einer Datei zu sehen.  Aber oft ist dies nicht notwendig - nur der spezifische Teil, an dem wir gerade arbeiten, reicht aus. <br><br><h3>  2. Storyboards verhindern die Wiederverwendung von Code </h3><br>  Wenn wir im Projekt nur Storyboards ohne Xibs verwenden, treten mit Sicherheit Probleme auf.  Allerdings sind Xibs meiner Meinung nach notwendige Elemente bei der Arbeit mit Storyboards.  Dank ihnen k√∂nnen Sie problemlos wiederverwendbare Ansichten erstellen, mit denen Sie auch bequem im Code arbeiten k√∂nnen. <br><br>  Erstellen Sie zun√§chst die Basis- <code>XibView</code> Klasse, die f√ºr das Rendern der in Xib erstellten <code>UIView</code> im Storyboard verantwortlich ist: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBDesignable</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentView: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  <code>XibView</code> l√§dt das <code>UIView</code> von Xib in das <code>contentView</code> und f√ºgt es als Unteransicht hinzu.  Wir machen das in der <code>setup()</code> Methode: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = loadViewFromNib() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.frame = bounds view.autoresizingMask = [.flexibleWidth, .flexibleHeight] addSubview(view) contentView = view }</code> </pre> <br>  Die <code>loadViewFromNib()</code> -Methode sieht folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadViewFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nibName = <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: type(of: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nib = <span class="hljs-type"><span class="hljs-type">UINib</span></span>(nibName: nibName, bundle: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">XibView</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nib.instantiate(withOwner: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, options: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIView</span></span> }</code> </pre> <br>  Die <code>setup()</code> -Methode sollte in Initialisierern aufgerufen werden: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) setup() } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(coder: aDecoder) setup() }</code> </pre> <br>  Die <code>XibView</code> Klasse <code>XibView</code> bereit.  Wiederverwendete Ansichten, deren Erscheinungsbild in einer Xib-Datei gerendert wird, werden von <code>XibView</code> geerbt: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><img src="https://habrastorage.org/webt/j8/ak/ny/j8aknyaa51sdpr6y8kbh7yjfwvs.png"><br>  Wenn Sie dem Storyboard jetzt eine neue <code>UIView</code> hinzuf√ºgen und deren Klasse auf <code>RedView</code> , wird alles erfolgreich angezeigt: <br><img src="https://habrastorage.org/webt/0l/a-/wa/0la-waqvswrxya3gc8clxvro2iw.png"><br>  Das Erstellen einer Instanz von <code>RedView</code> im Code erfolgt wie <code>RedView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> redView = <span class="hljs-type"><span class="hljs-type">RedView</span></span>()</code> </pre> <br>  Ein weiteres n√ºtzliches Detail, das nicht jeder kennen kann, ist die M√∂glichkeit, dem Verzeichnis <b>.xcassets</b> Farben <b>hinzuzuf√ºgen</b> .  Auf diese Weise k√∂nnen Sie sie global in allen Storyboards und Xibs √§ndern, in denen sie verwendet werden. <br><br>  Um Farbe hinzuzuf√ºgen, klicken Sie unten links auf ‚Äû+‚Äú und w√§hlen Sie ‚ÄûNeues Farbset‚Äú: <br><img src="https://habrastorage.org/webt/zm/3u/qi/zm3uqiunozwu020zpfckzd_slbo.png"><br>  Geben Sie den gew√ºnschten Namen und die gew√ºnschte Farbe an: <br><img src="https://habrastorage.org/webt/4j/ve/lt/4jveltbjt7fiqalngh6zzg1otr4.png"><br>  Die erstellte Farbe wird im Abschnitt "Benannte Farben" angezeigt: <br><img src="https://habrastorage.org/webt/km/cl/ak/kmclakpy0pduyyudog1_daxmx8o.png"><br>  Dar√ºber hinaus kann es im Code erhalten werden: <br><br><pre> <code class="swift hljs">innerView.backgroundColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(named: <span class="hljs-string"><span class="hljs-string">"BackgroundColor"</span></span>)</code> </pre><br><h3>  3. Sie k√∂nnen keine benutzerdefinierten Initialisierer f√ºr in Storyboard erstellte <code>UIViewControllers</code> </h3><br>  Im Fall des Storyboards k√∂nnen wir keine Abh√§ngigkeiten in den Initialisierern der <code>UIViewControllers</code> .  Normalerweise sieht es so aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"detail"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> detailVC = segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-type"><span class="hljs-type">Object</span></span>() detailVC.object = object }</code> </pre> <br>  Dieser Code kann besser mit einer Art Konstante erstellt werden, um Bezeichner oder Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SwiftGen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R.swift darzustellen</a> , oder vielleicht sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perform</a> .  Aber auf diese Weise werden wir nur String-Literale los und f√ºgen syntaktischen Zucker hinzu und l√∂sen nicht die auftretenden Probleme: <br><br><ul><li>  Woher wei√ü ich, wie der <code>DetailViewController</code> im obigen Beispiel konfiguriert <code>DetailViewController</code> ?  Wenn Sie neu im Projekt sind und nicht √ºber dieses Wissen verf√ºgen, m√ºssen Sie eine Datei mit einer Beschreibung dieses Controllers √∂ffnen und studieren. <br></li><li>  Die <code>DetailViewController</code> Eigenschaften <code>DetailViewController</code> nach der Initialisierung festgelegt. <code>DetailViewController</code> bedeutet, dass sie optional sein m√ºssen.  Es ist erforderlich, F√§lle zu behandeln, in denen eine Eigenschaft gleich <code>nil</code> , da die Anwendung sonst im ung√ºnstigsten Moment abst√ºrzen kann.  Sie k√∂nnen Eigenschaften als implizit erweitert optional markieren ( <code>var object: Object!</code> ), Aber das Wesentliche √§ndert sich nicht. <br></li><li>  Eigenschaften m√ºssen als <code>var</code> markiert sein, nicht <code>let</code> .  Eine Situation ist also m√∂glich, wenn jemand von au√üerhalb sie √§ndern m√∂chte.  <code>DetailViewController</code> sollte mit solchen Situationen umgehen. <br></li></ul><br>  Eine L√∂sung wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel beschrieben</a> . <br><br><h3>  4. Wenn das Storyboard w√§chst, wird die Navigation schwieriger </h3><br>  Wie bereits erw√§hnt, m√ºssen Sie nicht alles in ein Storyboard einf√ºgen. Es ist besser, es in mehrere kleinere zu unterteilen.  Mit dem Aufkommen der <b>Storyboard-Referenz ist</b> es sehr einfach geworden. <br>  F√ºgen Sie die Storyboard-Referenz aus der Objektbibliothek zum Storyboard hinzu: <br><img src="https://habrastorage.org/webt/m7/v4/wc/m7v4wcm7xu_chbm7n6j_mmy1ssq.png"><br>  Die erforderlichen Feldwerte werden im <b>Attributinspektor festgelegt.</b> Dies ist der Name der Storyboard-Datei und gegebenenfalls die <b>referenzierte ID</b> , die der <b>Storyboard-ID des</b> gew√ºnschten Bildschirms entspricht.  Standardm√§√üig wird der <b>Initial View Controller</b> geladen: <br><img src="https://habrastorage.org/webt/0j/2a/ee/0j2aeevobxwbcwd4impkwryj1ye.png"><br>  Wenn Sie im Feld Storyboard einen ung√ºltigen Namen angeben oder auf eine nicht vorhandene Storyboard-ID verweisen, werden Sie bei der Kompilierung von Xcode darauf hingewiesen. <br><br><h3>  5. Xcode wird beim Laden von Storyboards langsamer </h3><br>  Wenn das Storyboard eine gro√üe Anzahl von Bildschirmen mit zahlreichen Einschr√§nkungen enth√§lt, dauert das Laden wirklich einige Zeit.  Andererseits ist es besser, das gro√üe Storyboard in kleinere aufzuteilen.  Separat werden sie viel schneller geladen und es wird bequemer, mit ihnen zu arbeiten. <br><br><h3>  6. Storyboards sind zerbrechlich. Ein Fehler kann dazu f√ºhren, dass die Anwendung zur Laufzeit abst√ºrzt </h3><br>  Die Hauptschw√§chen: <br><br><ul><li>  Fehler in den <code>UITableViewCell</code> und <code>UICollectionViewCell</code> . <br></li><li>  Fehler in den Segmentkennungen. <br></li><li>  Verwenden einer Unterklasse von <code>UIView</code> , die nicht mehr vorhanden ist. <br></li><li>  Synchronisation von <code>IBActions</code> und <code>IBOutlets</code> mit Code. <br></li></ul><br>  All dies und einige andere Probleme k√∂nnen zur Laufzeit zum Absturz der Anwendung f√ºhren, was bedeutet, dass solche Fehler wahrscheinlich in den Release-Build fallen.  Wenn wir beispielsweise Zellkennungen oder Segmente im Storyboard festlegen, sollten diese √ºberall dort, wo sie verwendet werden, in den Code kopiert werden.  Durch √Ñndern des Bezeichners an einer Stelle muss er an allen anderen Stellen ge√§ndert werden.  Es besteht die M√∂glichkeit, dass Sie es einfach vergessen oder einen Tippfehler machen, aber nur w√§hrend der Ausf√ºhrung der Anwendung etwas √ºber den Fehler erfahren. <br><br>  Sie k√∂nnen die Fehlerwahrscheinlichkeit verringern, indem Sie Zeichenfolgenliterale in Ihrem Code entfernen.  Zu diesem <code>UICollectionViewCell</code> k√∂nnen den Bezeichnern <code>UITableViewCell</code> und <code>UICollectionViewCell</code> die Namen der <code>UICollectionViewCell</code> selbst zugewiesen werden. Beispielsweise ist der Bezeichner <code>ItemTableViewCell</code> die Zeichenfolge ‚ÄûItemTableViewCell‚Äú.  Im Code erhalten wir die Zelle wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span></code> </pre> <br>  Sie k√∂nnen der <code>UITableView</code> die entsprechende generische Funktion <code>UITableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dequeueReusableCell</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">T</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">T</span></span> } }</code> </pre> <br>  Und dann wird es einfacher, die Zelle zu bekommen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span> = tableView.dequeueReusableCell()</code> </pre> <br>  Wenn Sie pl√∂tzlich vergessen, den Wert der Zellenkennung im Storyboard anzugeben, zeigt Xcode eine Warnung an, sodass Sie diese nicht ignorieren sollten. <br><br>  F√ºr Segues-IDs k√∂nnen Sie Aufz√§hlungen verwenden.  Lassen Sie uns ein spezielles Protokoll erstellen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>: <span class="hljs-type"><span class="hljs-type">RawRepresentable</span></span> }</code> </pre> <br>  <code>UIViewController</code> , der dieses Protokoll unterst√ºtzt, muss einen verschachtelten Typ mit demselben Namen definieren.  Es werden alle <code>UIViewController</code> , die dieser <code>UIViewController</code> kann: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } }</code> </pre> <br>  Dar√ºber hinaus definieren <code>SegueHandler</code> in der <code>SegueHandler</code> Protokollerweiterung zwei Funktionen: Eine akzeptiert ein <code>UIStoryboardSegue</code> und gibt den entsprechenden <code>SegueIdentifier</code> Wert zur√ºck, und die andere ruft einfach <code>performSegue</code> und nimmt die <code>SegueIdentifier</code> Eingabe: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawValue</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performSegue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withIdentifier segueIdentifier: SegueIdentifier, sender: AnyObject?)</span></span></span></span> { performSegue(withIdentifier: segueIdentifier.rawValue, sender: sender) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">segueIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifier = segue.identifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifierCase = <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>(rawValue: identifier) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid segue identifier \(String(describing: segue.identifier))."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> identifierCase } }</code> </pre> <br>  Und jetzt k√∂nnen Sie in einem <code>UIViewController</code> , der das neue Protokoll unterst√ºtzt, wie folgt mit <code>prepare(for:sender:)</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segueIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: segue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signIn: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signIn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signUp: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signUp"</span></span>) } } }</code> </pre> <br>  Und laufen Sie wie folgt: <br><br><pre> <code class="swift hljs">performSegue(withIdentifier: .signIn, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Wenn Sie dem <code>SegueIdentifier</code> einen neuen Bezeichner <code>SegueIdentifier</code> , wird Xcode ihn mit Sicherheit zwingen, ihn in <code>switch/case</code> . <br><br>  Eine andere M√∂glichkeit, Zeichenfolgenliterale wie Bezeichner-Segues und andere zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entfernen,</a> ist die Verwendung von Tools zur Codegenerierung wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R.swift</a> . <br><br><h3>  7. Storyboards sind weniger flexibel als Code. </h3><br>  Ja, das ist wahr.  Wenn die Aufgabe darin besteht, einen komplexen Bildschirm mit Animationen und Effekten zu erstellen, die das Storyboard nicht verarbeiten kann, m√ºssen Sie den Code verwenden! <br><br><h3>  8. In Storyboards kann der Typ spezieller <code>UIViewControllers</code> nicht <code>UIViewControllers</code> </h3><br>  Wenn Sie beispielsweise den Typ von <code>UITableViewController</code> in <code>UICollectionViewController</code> <code>UITableViewController</code> <code>UICollectionViewController</code> , m√ºssen Sie das Objekt l√∂schen, ein neues mit einem anderen Typ hinzuf√ºgen und es neu konfigurieren.  Obwohl dies nicht h√§ufig vorkommt, ist es erw√§hnenswert, dass solche √Ñnderungen im Code schneller vorgenommen werden. <br><br><h3>  9. Storyboards f√ºgen dem Projekt zwei zus√§tzliche Abh√§ngigkeiten hinzu.  Sie k√∂nnen Fehler enthalten, die der Entwickler nicht beheben kann. </h3><br>  Dies ist Interface Builder und der Storyboards-Parser.  Solche F√§lle sind selten und k√∂nnen oft durch andere L√∂sungen umgangen werden. <br><br><h3>  10. Anspruchsvolle Code√ºberpr√ºfung </h3><br>  Beachten Sie, dass die Code√ºberpr√ºfung nicht wirklich eine Fehlersuche ist.  Ja, sie werden beim Anzeigen des Codes gefunden, aber das Hauptziel besteht darin, Schwachstellen zu identifizieren, die auf lange Sicht zu Problemen f√ºhren k√∂nnen.  Bei Storyboards ist dies in erster Linie die Arbeit von <b>Auto Layout</b> .  Es sollte keine <b>mehrdeutigen</b> und <b>verlegten geben</b> .  Um sie zu finden, verwenden Sie einfach die Suche im Storyboard-XML nach den Zeilen "mehrdeutig =" JA "" und "falsch platziert =" JA "" oder √∂ffnen Sie einfach das Storyboard im Interface Builder und suchen Sie nach roten und gelben Punkten: <br><img src="https://habrastorage.org/webt/u4/bw/l5/u4bwl5psqejad5ziovb2bjxy1eq.png"><br>  Dies reicht jedoch m√∂glicherweise nicht aus.  Konflikte zwischen Einschr√§nkungen k√∂nnen auch w√§hrend der Ausf√ºhrung der Anwendung erkannt werden.  Wenn eine √§hnliche Situation auftritt, werden Informationen dazu in der Konsole angezeigt.  Solche F√§lle sind keine Seltenheit, daher sollte auch ihre Suche ernst genommen werden. <br><br>  Alles andere - die Anpassung der Position und Gr√∂√üe der Elemente an das Design, die korrekte Bindung von <code>IBOutlets</code> und <code>IBActions</code> - dient nicht der <code>IBOutlets</code> . <br><br>  Dar√ºber hinaus ist es wichtig, h√§ufiger Commits durchzuf√ºhren, damit der Pr√ºfer die √Ñnderungen in kleinen Teilen leichter sehen kann.  Er wird besser in der Lage sein, in die Details einzutauchen, ohne etwas zu verpassen.  Dies wirkt sich wiederum positiv auf die Qualit√§t der Code√ºberpr√ºfung aus. <br><br><h3>  Zusammenfassung </h3><br>  In der Liste der Storyboard-Fehler habe ich 4 Elemente hinterlassen (in absteigender Reihenfolge ihres Werts): <br><br><ol><li>  Storyboards haben Schwierigkeiten, Konflikte beim Zusammenf√ºhren von √Ñnderungen zu verwalten. <br></li><li>  Storyboards sind weniger flexibel als Code. <br></li><li>  Storyboards sind zerbrechlich, ein Fehler kann zur Laufzeit zu einem Absturz f√ºhren. <br></li><li>  Sie k√∂nnen keine benutzerdefinierten Initialisierer f√ºr <code>UIViewControllers</code> die im Storyboard erstellt wurden. <br></li></ol><br><h2>  Die Vorteile </h2><br><h3>  1. Visualisierung der Benutzeroberfl√§che und Einschr√§nkungen </h3><br>  Selbst wenn Sie ein Anf√§nger sind und gerade ein unbekanntes Projekt gestartet haben, k√∂nnen Sie leicht den Einstiegspunkt in die Anwendung finden und herausfinden, wie Sie von dort aus zum gew√ºnschten Bildschirm gelangen.  Sie wissen, wie die einzelnen Schaltfl√§chen, Beschriftungen oder Textfelder aussehen, welche Position sie einnehmen, wie sich Einschr√§nkungen auf sie auswirken und wie sie mit anderen Elementen interagieren.  Mit wenigen Klicks k√∂nnen Sie ganz einfach ein neues <code>UIView</code> erstellen und dessen Erscheinungsbild und Verhalten anpassen.  Mit dem automatischen Layout k√∂nnen wir nat√ºrlich mit <code>UIView</code> , als ob wir gesagt h√§tten: "Diese Schaltfl√§che sollte sich links von diesem Etikett befinden und dieselbe H√∂he haben."  Diese Benutzeroberfl√§che ist intuitiv und effektiv.  Sie k√∂nnen versuchen, Beispiele zu nennen, bei denen gut geschriebener Code beim Erstellen einiger UI-Elemente mehr Zeit spart, aber global √§ndert sich daran nicht viel.  Storyboard macht seinen Job gut. <br><br>  Beachten Sie separat das automatische Layout.  Dies ist ein sehr leistungsf√§higes und n√ºtzliches Tool, ohne das es schwierig w√§re, eine Anwendung zu erstellen, die all die vielen verschiedenen Bildschirmgr√∂√üen unterst√ºtzt.  Mit Interface Builder k√∂nnen Sie das Ergebnis der Arbeit mit Auto Layout anzeigen, ohne die Anwendung zu starten. Wenn einige Einschr√§nkungen nicht in das allgemeine Schema passen, werden Sie von Xcode sofort gewarnt.  Nat√ºrlich gibt es F√§lle, in denen Interface Builder nicht in der Lage ist, das erforderliche Verhalten einer sehr dynamischen und komplexen Schnittstelle bereitzustellen, und Sie sich dann auf den Code verlassen m√ºssen.  Aber auch in solchen Situationen k√∂nnen Sie das meiste in Interface Builder tun und es mit nur ein paar Codezeilen erg√§nzen. <br><br>  Schauen wir uns einige Beispiele an, die die n√ºtzlichen Funktionen von Interface Builder demonstrieren. <br><br><h4>  Dynamische Tabellen basierend auf <code>UIStackView</code> </h4><br>  Erstellen Sie einen neuen <code>UIViewController</code> und f√ºgen Sie einen <code>UIScrollView</code> Vollbildmodus hinzu: <br><img src="https://habrastorage.org/webt/oh/-g/c8/oh-gc88tyx_mhu5zm6iehrnpvrk.png"><br>  <code>UIScrollView</code> in <code>UIScrollView</code> eine vertikale <code>UIStackView</code> , <code>UIStackView</code> sie an den Kanten ein und stellen Sie die H√∂he und Breite auf <code>UIScrollView</code> .  Weisen Sie in dieser H√∂he <b>Priorit√§t = Niedrig (250) zu</b> : <br><img src="https://habrastorage.org/webt/hp/dv/v-/hpdvv-gg-hkeh_xy5k2vbbcznr0.png"><br>  Erstellen Sie als N√§chstes alle erforderlichen Zellen und f√ºgen Sie sie der <code>UIStackView</code> .  Vielleicht ist es gew√∂hnliches <code>UIView</code> in einer einzigen Kopie oder <code>UIView</code> , f√ºr das wir unsere eigene Xib-Datei erstellt haben.  In jedem Fall befindet sich die gesamte Benutzeroberfl√§che dieses Bildschirms im Storyboard. Dank des korrekt konfigurierten automatischen Layouts funktioniert das Scrollen einwandfrei und passt sich dem Inhalt an: <br><br><img src="https://habrastorage.org/webt/vg/pr/dl/vgprdl652o0neubp6d87fvcyupk.gif" width="320" height="588"><br><br>  Wir k√∂nnen Zellen auch dazu bringen, sich an die Gr√∂√üe ihres Inhalts anzupassen.  F√ºgen <code>UILabel</code> jeder Zelle <code>UILabel</code> und binden Sie sie an die Kanten: <br><img src="https://habrastorage.org/webt/ei/u0/if/eiu0ifpkzcudjmimrknducpg5f4.png"><br>  Es ist bereits klar, wie dies alles zur Laufzeit aussehen wird.  Sie k√∂nnen den Zellen beliebige Aktionen hinzuf√ºgen, z. B. zu einem anderen Bildschirm wechseln.  Und das alles ohne eine einzige Codezeile. <br>  Wenn Sie f√ºr eine <code>UIView</code> in einer <code>UIStackView</code> <code>hidden = true</code> <code>UIStackView</code> , wird diese nicht nur <code>UIStackView</code> , sondern nimmt auch keinen Speicherplatz ein.  <code>UIStackView</code> berechnet seine Gr√∂√üen automatisch neu: <br><br><img src="https://habrastorage.org/webt/b8/cs/ch/b8cschy8jwotcb1fge4ew2ip43s.gif"><br><br><h4>  Selbstleimende Zellen </h4><br>  Setzen Sie im <b>Gr√∂√üeninspektor</b> <b>der</b> Tabelle die <b>Zeilenh√∂he = Automatisch</b> und <b>Sch√§tzen</b> auf einen Durchschnittswert: <br><img src="https://habrastorage.org/webt/p2/tp/de/p2tpdecyxveakvtukce9maxkrbq.png"><br>  Damit dies funktioniert, m√ºssen Einschr√§nkungen in den Zellen selbst korrekt konfiguriert sein und eine genaue Berechnung der Zellenh√∂he basierend auf dem Inhalt zur Laufzeit erm√∂glichen.  Wenn nicht klar ist, worum es geht, finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> eine sehr gute Erkl√§rung. <br><br>  Als Ergebnis sehen wir beim Starten der Anwendung, dass alles korrekt angezeigt wird: <br><img src="https://habrastorage.org/webt/yi/mb/4q/yimb4q-qt5ydm3_3ynqavuvr4ga.png" width="432" height="702"><br><h4>  Selbstgr√∂√üen-Tabelle </h4><br>  Sie m√ºssen dieses Tabellenverhalten implementieren: <br><br><img src="https://habrastorage.org/webt/6g/pp/bf/6gppbf-ma4zin0czafyjn3wfj08.gif" width="320" height="588"><br><br>  Wie erreicht man eine √§hnliche dynamische H√∂hen√§nderung?  Im Gegensatz zu <code>UILabel</code> , <code>UIButton</code> und anderen Unterklassen von <code>UIView</code> ist die Verwendung einer Tabelle etwas schwieriger, da die Gr√∂√üe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intrinsischen Inhalts</a> nicht von der Gr√∂√üe der darin enthaltenen Zellen abh√§ngt.  Sie kann ihre Gr√∂√üe nicht anhand des Inhalts berechnen, aber es besteht die M√∂glichkeit, ihr dabei zu helfen. <br><br>  Beachten Sie, dass sich die H√∂he der Tabelle irgendwann im Video nicht mehr √§ndert und einen bestimmten Maximalwert erreicht.  Dies kann erreicht werden, indem die Tabellenh√∂henbeschr√§nkung mit dem Wert <b>Relation = Less Than Or Equal festgelegt wird</b> : <br><img src="https://habrastorage.org/webt/xk/47/rc/xk47rcebixtr42k1ka4wqagftyy.png"><br>  Zu diesem Zeitpunkt wei√ü der Interface Builder noch nicht, wie hoch die Tabelle sein wird, er kennt nur den Maximalwert von 200 (aus der H√∂henbeschr√§nkung).  Wie bereits erw√§hnt, entspricht die intrinsische Inhaltsgr√∂√üe nicht dem Inhalt der Tabelle.  Wir haben jedoch die M√∂glichkeit, den Platzhalter im Feld <b>Eigengr√∂√üe festzulegen</b> : <br><img src="https://habrastorage.org/webt/tb/i7/eu/tbi7eut1jafonqjknoyabqyev_q.png"><br>  Dieser Wert ist nur g√ºltig, wenn Sie mit Interface Builder arbeiten.  Nat√ºrlich muss die intrinsische Inhaltsgr√∂√üe zur Laufzeit nicht diesem Wert entsprechen.  Wir haben Interface Builder gerade gesagt, dass alles unter Kontrolle ist. <br><br>  Erstellen Sie als N√§chstes eine neue Unterklasse der <code>CustomTableView</code> Tabelle: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTableView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { invalidateIntrinsicContentSize() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intrinsicContentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentSize } }</code> </pre> <br>  Einer dieser F√§lle, in denen der Code erforderlich ist.  Hier rufen wir <code>contentSize</code> <code>invalidateIntrinsicContentSize</code> wenn sich die <code>contentSize</code> der Tabelle √§ndert.  Dadurch kann das System die neue intrinsische Inhaltsgr√∂√üe akzeptieren.  Es gibt wiederum <code>contentSize</code> und zwingt die Tabelle, ihre H√∂he dynamisch anzupassen und eine bestimmte Anzahl von Zellen anzuzeigen, ohne zu scrollen.  Das Scrollen wird in dem Moment angezeigt, in dem wir die Grenze f√ºr die H√∂henbeschr√§nkung erreichen. <br><br>  Alle drei Funktionen des Interface Builder k√∂nnen miteinander kombiniert werden.  Sie bieten mehr Flexibilit√§t f√ºr die Optionen der <code>UIView</code> ohne dass zus√§tzliche Einschr√§nkungen oder <code>UIView</code> . <br><br><h3>  2. Die F√§higkeit, das Ergebnis ihrer Aktionen sofort zu sehen </h3><br>  Wenn Sie die Gr√∂√üe des <code>UIView</code> , ein paar Punkte zur Seite verschoben oder die Hintergrundfarbe ge√§ndert haben, sehen Sie sofort, wie es zur Laufzeit aussieht, ohne die Anwendung starten zu m√ºssen.  Sie m√ºssen sich nicht wundern, warum eine Schaltfl√§che nicht auf dem Bildschirm angezeigt wurde oder warum das Verhalten von <code>UIView</code> nicht wie gew√ºnscht ist. <br><br>  Die Verwendung von <code>@IBInspectable</code> zeigt diesen Vorteil noch interessanter.  F√ºgen Sie <code>UILabel</code> zwei <code>UILabel</code> und zwei Eigenschaften <code>RedView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { titleLabel.text = title } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { subtitleLabel.text = subtitle } } }</code> </pre> <br>  Im <b>Attributinspektor</b> f√ºr <code>RedView</code> zwei neue Felder <code>RedView</code> - <code>Title</code> und <code>Subtitle</code> , die wir als <code>@IBInspectable</code> markiert <code>@IBInspectable</code> : <br><img src="https://habrastorage.org/webt/wv/rh/nn/wvrhnnegpjpyo7zrj7857dlujom.png"><br>  Wenn wir versuchen, Werte in diese Felder einzugeben, sehen wir sofort, wie alles zur Laufzeit aussieht: <br><br><img src="https://habrastorage.org/webt/hn/bd/6u/hnbd6urq0ebbpghnuiaueovz38i.gif"><br><br>  Sie k√∂nnen alles steuern: <code>cornerRadius</code> , <code>borderWidth</code> , <code>borderColor</code> .  Zum Beispiel erweitern wir die Basisklasse <code>UIView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.cornerRadius = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.cornerRadius } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderWidth = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderWidth } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: <span class="hljs-type"><span class="hljs-type">UIColor?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderColor = newValue?.cgColor } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderColor != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(cgColor: layer.borderColor!) : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotate: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: newValue * .pi/<span class="hljs-number"><span class="hljs-number">180</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br>  Wir sehen, dass der Attributes Inspector des <code>RedView</code> Objekts 4 weitere neue Felder <code>RedView</code> , mit denen Sie jetzt auch spielen k√∂nnen: <br><br><img src="https://habrastorage.org/webt/gq/ib/bm/gqibbmd2an0a4zezig2iuifx5tm.gif"><br><br><h3>  3. Zeigen Sie alle Bildschirmgr√∂√üen gleichzeitig in der Vorschau an </h3><br>  Also haben wir die erforderlichen Elemente auf den Bildschirm geworfen, ihr Erscheinungsbild angepasst und die erforderlichen Einschr√§nkungen hinzugef√ºgt.  Wie k√∂nnen wir herausfinden, ob der Inhalt auf verschiedenen Bildschirmgr√∂√üen korrekt angezeigt wird?  Nat√ºrlich k√∂nnen Sie die Anwendung auf jedem Simulator ausf√ºhren, aber es wird viel Zeit in Anspruch nehmen.  Es gibt eine bessere Option: Xcode verf√ºgt √ºber einen Vorschaumodus, mit dem Sie mehrere Bildschirmgr√∂√üen gleichzeitig anzeigen k√∂nnen, ohne die Anwendung zu starten. <br><br>  Wir rufen den <b>Assistenten-Editor auf</b> , klicken auf das erste Segment der √úbergangsleiste und w√§hlen <b>Vorschau -&gt; Einstellungen.Storyboard</b> (als Beispiel): <br><img src="https://habrastorage.org/webt/aw/mg/nr/awmgnrb4ajxr49hrygbe70fz5is.png"><br>  Zuerst sehen wir nur einen Bildschirm, aber wir k√∂nnen so viel hinzuf√ºgen, wie wir brauchen, indem wir in der unteren linken Ecke auf ‚Äû+‚Äú klicken und die erforderlichen Ger√§te aus der Liste ausw√§hlen: <br><img src="https://habrastorage.org/webt/18/3f/eo/183feokkgdpycsxlcr3a1upo8jk.png"><br>  Wenn das Storyboard mehrere Sprachen unterst√ºtzt, k√∂nnen Sie au√üerdem sehen, wie der ausgew√§hlte Bildschirm mit jeder Sprache aussieht: <br><img src="https://habrastorage.org/webt/hy/nf/6g/hynf6gc-nzhc30fxq0ir2a2uzcc.png"><br>  Die Sprache kann f√ºr alle Bildschirme gleichzeitig und f√ºr jeden einzeln ausgew√§hlt werden. <br><br><h3>  4. Entfernen des Vorlagen-UI-Codes </h3><br>  Das Erstellen einer Benutzeroberfl√§che ohne Interface Builder wird entweder von einer gro√üen Menge an Boilerplate-Code oder von Superklassen und Erweiterungen begleitet, die zus√§tzliche Wartungsarbeiten erfordern.  Dieser Code kann andere Teile der Anwendung infiltrieren und das Lesen und Suchen erschweren.  Durch die Verwendung von Storyboards und Xibs kann Code ausgelagert werden, sodass der Schwerpunkt st√§rker auf der Logik liegt. <br><br><h3>  5. Gr√∂√üenklassen </h3><br>  Jedes Jahr erscheinen neue Ger√§te, f√ºr die Sie die Benutzeroberfl√§che anpassen m√ºssen.  Das Konzept der <b>Merkmalsvariationen</b> und insbesondere der <b>Gr√∂√üenklassen</b> , mit denen Sie eine Benutzeroberfl√§che f√ºr jede Gr√∂√üe und Ausrichtung des Bildschirms erstellen k√∂nnen, hilft dabei. <br><br>  Gr√∂√üenklassen klassifizieren die H√∂he (h) und Breite (w) von Ger√§tebildschirmen in Form von <b>kompakt</b> und <b>regelm√§√üig</b> ( <b>C</b> und <b>R</b> ).  Zum Beispiel hat das iPhone 8 eine Gr√∂√üenklasse <b>(wC hR)</b> im Hochformat und <b>(wC hC)</b> im <b>Querformat</b> , und das iPhone 8 Plus hat <b>(wC hR)</b> bzw. <b>(wR hC)</b> .  Die restlichen Ger√§te finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  In einem Storyboard oder Xib f√ºr jede der Gr√∂√üenklassen k√∂nnen Sie Ihren eigenen Datensatz speichern. Die Anwendung verwendet je nach Ger√§t und Bildschirmausrichtung zur Laufzeit den entsprechenden Datensatz, um die aktuelle Gr√∂√üenklasse zu ermitteln.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn einige Layoutparameter f√ºr alle Gr√∂√üenklassen gleich sind, k√∂nnen sie in der </font><font style="vertical-align: inherit;">bereits standardm√§√üig ausgew√§hlten </font><font style="vertical-align: inherit;">Kategorie " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beliebig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">konfiguriert werden </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurieren Sie beispielsweise die Schriftgr√∂√üe abh√§ngig von der Gr√∂√üenklasse. Wir w√§hlen das iPhone 8 Plus-Ger√§t f√ºr die Anzeige im Storyboard im Hochformat aus und f√ºgen eine neue Bedingung hinzu f√ºr </font></font><code>font</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Wenn die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breite Normal ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (setzen Sie alles andere auf ‚ÄûBeliebig‚Äú), sollte die Schriftgr√∂√üe 37 sein: </font></font><br><img src="https://habrastorage.org/webt/bd/bs/-7/bdbs-7i602wtlxemns-hm3jz3ps.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nun die Bildschirmausrichtung √§ndern, die Schriftgr√∂√üe erh√∂hen - eine neue Bedingung wird funktionieren, da das iPhone 8 Plus im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Querformat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Gr√∂√üenklasse </font><b><font style="vertical-align: inherit;">(wR hC) hat</font></b><font style="vertical-align: inherit;"> . Im Storyboard k√∂nnen Sie je nach Gr√∂√üenklasse auch Ansichten ausblenden, Einschr√§nkungen aktivieren / deaktivieren und deren Wert √§ndern</font></font><code>constant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und vieles mehr. Weitere Informationen dar√ºber , </font><font style="vertical-align: inherit;">wie all dies zu tun, k√∂nnen Sie lesen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im obigen Screenshot ist das untere Feld mit der Auswahl des Ger√§ts zur Anzeige des Layouts zu beachten. Sie k√∂nnen damit schnell die Anpassungsf√§higkeit der Benutzeroberfl√§che auf jedem Ger√§t und bei jeder Bildschirmausrichtung √ºberpr√ºfen und die Gr√∂√üenklasse der aktuellen Konfiguration (neben dem Ger√§tenamen) anzeigen. Unter anderem befindet sich rechts eine Schaltfl√§che " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr Eigenschaften</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variieren" </font><font style="vertical-align: inherit;">. Ihr Zweck besteht darin, Merkmalsvariationen nur f√ºr eine bestimmte Kategorie von Breite, H√∂he oder Breite und H√∂he gleichzeitig zu erm√∂glichen. Wenn Sie beispielsweise ein iPad mit einer Gr√∂√üenklasse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR) ausw√§hlen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , klicken Sie auf ‚ÄûF√ºr Merkmale </font><b><font style="vertical-align: inherit;">variieren</font></b><font style="vertical-align: inherit;"> ‚Äú und </font><b><font style="vertical-align: inherit;">aktivieren</font></b><font style="vertical-align: inherit;"> Sie das Kontrollk√§stchen neben </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂he</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt gelten alle nachfolgenden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Layout√§nderungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur f√ºr Ger√§te mit </font><b><font style="vertical-align: inherit;">(wR hR),</font></b><font style="vertical-align: inherit;"> bis wir auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Done Varying</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> klicken </font><font style="vertical-align: inherit;">.</font></font><br><br><h2>  Fazit </h2><div class="scrollable-table"><table><tbody><tr><th>  # <br></th><th>  Nachteile <br></th><th>  Die Vorteile <br></th></tr><tr><td>  1 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwer zu beherrschende Konflikte </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI-Visualisierung und Einschr√§nkungen </font></font><br></td></tr><tr><td>  2 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nicht so flexibel wie Code </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die F√§higkeit, das Ergebnis Ihrer Aktionen sofort zu sehen </font></font><br></td></tr><tr><td>  3 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Fehler kann zur Laufzeit zu einem Absturz f√ºhren. </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorschau aller Bildschirmgr√∂√üen gleichzeitig </font></font><br></td></tr><tr><td>  4 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie k√∂nnen keine benutzerdefinierten Initialisierer verwenden </font></font><code>UIViewControllers</code> <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entfernen des Vorlagen-UI-Codes </font></font><br></td></tr><tr><td>  5 <br></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√∂√üenklassen </font></font><br></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben gesehen, dass Storyboards ihre St√§rken und Schw√§chen haben. </font><font style="vertical-align: inherit;">Meiner Meinung nach sollten Sie die Verwendung nicht vollst√§ndig ablehnen. </font><font style="vertical-align: inherit;">Bei richtiger Anwendung bringen sie gro√üe Vorteile und helfen, Aufgaben effektiv zu l√∂sen. </font><font style="vertical-align: inherit;">Sie m√ºssen nur lernen, wie Sie Argumente wie "Ich mag keine Storyboards" oder "Ich bin es gewohnt, dies zu tun" priorisieren und vergessen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456086/">https://habr.com/ru/post/de456086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456072/index.html">Dav1d - standardm√§√üig der schnellste AV1-Decoder in Firefox</a></li>
<li><a href="../de456076/index.html">PyDaCon-Treffen bei Mail.ru Group: 22. Juni</a></li>
<li><a href="../de456078/index.html">Projektion von Unternehmenskonflikten auf die Netzwerkkonnektivit√§t</a></li>
<li><a href="../de456082/index.html">Wie wir personalisierte Produktempfehlungen entwickeln</a></li>
<li><a href="../de456084/index.html">Kubernetes 1.15: Highlights √úbersicht</a></li>
<li><a href="../de456088/index.html">Probleme bei der Big Data-Analyse</a></li>
<li><a href="../de456090/index.html">Einf√ºhrung in Unit Testing in Unity</a></li>
<li><a href="../de456092/index.html">Sieben beunruhigende Anzeichen daf√ºr, dass Sie wetterabh√§ngig sind, auch wenn Sie dies nicht glauben</a></li>
<li><a href="../de456094/index.html">Wir lesen Datenbl√§tter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8</a></li>
<li><a href="../de456096/index.html">Was der durchschnittliche Geektimes-Leser tut, w√§hrend er in den Wolken schwebt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>