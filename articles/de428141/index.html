<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌡️ 📧 👨🏿‍🚒 Das Backend für das Frontend oder How Yandex.Market erstellt eine API ohne Krücken 🏊 🏡 🔛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum sind einige APIs bequemer zu verwenden als andere? Was können wir als Front-End-Anbieter auf unserer Seite tun, um mit einer API von akzeptabler...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Backend für das Frontend oder How Yandex.Market erstellt eine API ohne Krücken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428141/"><p>  Warum sind einige APIs bequemer zu verwenden als andere?  Was können wir als Front-End-Anbieter auf unserer Seite tun, um mit einer API von akzeptabler Qualität zu arbeiten?  Heute werde ich den Lesern von Habr sowohl über technische Optionen als auch über organisatorische Maßnahmen berichten, die Front-End- und Back-End-Anbietern helfen, eine gemeinsame Sprache zu finden und effektive Arbeit aufzubauen. </p><br><img src="https://habrastorage.org/webt/us/fq/lo/usfqlosft_umexv3_kh5zyd_wdy.png"><br><p>  In diesem Herbst wird Yandex.Market 18 Jahre alt.  Während dieser ganzen Zeit hat sich die Affiliate-Oberfläche des Marktes weiterentwickelt.  Kurz gesagt, dies ist das Admin-Panel, mit dem Geschäfte Kataloge hochladen, mit dem Sortiment arbeiten, Statistiken folgen, auf Bewertungen reagieren usw. können.  Die Besonderheiten des Projekts sind so, dass Sie viel mit verschiedenen Backends interagieren müssen.  Daten können jedoch nicht immer an einem Ort von einem bestimmten Backend abgerufen werden. </p><br><p><a name="habracut"></a></p><h3>  Symptome eines Problems </h3><br>  Stellen Sie sich vor, es gab ein Problem.  Der Manager geht mit der Aufgabe zu den Designern - sie zeichnen das Layout.  Dann geht er zum Backend - sie machen einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stifte</a> und schreiben eine Liste von Parametern und das Antwortformat in das interne Wiki. <br><p>  Dann geht der Manager mit den Worten „Ich habe Ihnen eine API gebracht“ zum Frontend und bietet an, alles schnell zu skripten, da seiner Meinung nach fast die gesamte Arbeit bereits erledigt ist. </p><br><p>  Sie sehen sich die Dokumentation an und sehen Folgendes: </p><br><pre><code class="xml hljs">№ |   ---------------------- 53 | feed_shoffed_id 54 | fesh 55 | filter-currency 56 | showVendors</code> </pre> <br><p>  Merken Sie nichts Seltsames?  Kamel, Schlange und Kebab Fall in einem Stift.  Ich spreche nicht über den Parameter fesh.  Was ist überhaupt Fleisch?  Ein solches Wort gibt es nicht einmal.  Versuchen Sie zu erraten, bevor Sie den Spoiler öffnen. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Fesh ist ein Filter nach Geschäfts-ID.  Sie können mehrere durch Kommas getrennte Bezeichner übergeben.  Einer ID kann ein Minuszeichen vorangestellt werden. Dies bedeutet, dass dieser Speicher von den Ergebnissen ausgeschlossen werden sollte. </p></div></div><br><p>  Gleichzeitig kann ich von JavaSctipt aus natürlich nicht über die gepunktete Notation auf die Eigenschaften eines solchen Objekts zugreifen.  Ganz zu schweigen von der Tatsache, dass Sie sich offensichtlich in Ihrem Leben an einen anderen Ort gewandt haben, wenn Sie mehr als 50 Parameter an einem Ort haben. </p><br><p>  Es gibt viele Optionen für eine unbequeme API.  Ein klassisches Beispiel - die API sucht und gibt Ergebnisse zurück: </p><br><pre> <code class="javascript hljs">result: [ {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8 Plus'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone X'</span></span>}, ] result: {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>} result: <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Wenn die Ware gefunden wird, erhalten wir ein Array.  Wenn ein Produkt gefunden wird, erhalten wir ein Objekt mit diesem Produkt.  Wenn nichts gefunden wird, erhalten wir bestenfalls null.  Im schlimmsten Fall antwortet das Backend mit 404 oder sogar 400 (Bad Request). </p><br><p>  Situationen sind einfacher.  Beispielsweise müssen Sie eine Liste der Geschäfte in einem Backend und die Geschäftseinstellungen in einem anderen Backend abrufen.  In einigen Stiften sind nicht genügend Daten vorhanden, in einigen Daten sind zu viele vorhanden.  Das alles auf dem Client zu filtern oder mehrere Ajax-Anfragen zu stellen, ist eine schlechte Idee. </p><br><p>  Was können die Lösungen für dieses Problem sein?  Was können wir als Front-End-Anbieter auf unserer Seite tun, um mit einer API von akzeptabler Qualität zu arbeiten? </p><br><h3>  Frontend Backend </h3><br><p>  Wir verwenden den React / Redux-Client in der Partnerschnittstelle.  Unter dem Client befindet sich Node.js, das viele Hilfsprogramme ausführt und es beispielsweise auf die InitialState-Seite für Editoren wirft.  Wenn Sie ein serverseitiges Rendering haben, spielt es keine Rolle, mit welchem ​​Client-Framework es höchstwahrscheinlich von einem Knoten gerendert wird.  Was aber, wenn Sie noch einen Schritt weiter gehen und den Client im Backend nicht direkt kontaktieren, sondern Ihre Proxy-API auf dem Knoten so gestalten, dass sie maximal auf die Clientanforderungen zugeschnitten ist? <br>  Diese Technik wird als BFF (Backend For Frontend) bezeichnet.  Dieser Begriff wurde erstmals 2015 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> SoundCloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingeführt.</a> Die Idee kann wie folgt schematisch dargestellt werden: </p><br><img src="https://habrastorage.org/webt/du/jw/re/dujwreelvkjlvykh1ut-dphjhxe.png"><br><p>  Sie hören also auf, vom Client-Code direkt zur API zu wechseln.  Jedes Handle, jede Methode der realen API, die Sie auf dem Knoten und vom Client duplizieren, wird ausschließlich an den Knoten gesendet.  Der Knoten leitet die Anforderung bereits an die reale API weiter und gibt eine Antwort an Sie zurück. </p><br><p>  Dies gilt nicht nur für primitive Get-Anfragen, sondern allgemein für alle Anfragen, auch mit mehrteiligen / Formulardaten.  Beispielsweise lädt ein Geschäft eine XLS-Datei mit seinem Katalog über ein Formular auf einer Site hoch.  In dieser Implementierung wird das Verzeichnis also nicht direkt in die API geladen, sondern in Ihr Nod-Handle, das Proxys an ein echtes Backend überträgt. </p><br><p>  Erinnern Sie sich an dieses Beispiel mit Ergebnis, als das Backend null, ein Array oder ein Objekt zurückgab?  Jetzt können wir es wieder normalisieren - so etwas: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [response] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response }</code> </pre> <br><p>  Dieser Code sieht schrecklich aus.  Weil er schrecklich ist.  Aber wir müssen das noch tun.  Wir haben die Wahl: Machen Sie es auf dem Server oder auf dem Client.  Ich wähle einen Server. </p><br><p>  Wir können auch alle diese Kebab- und Schlangenfälle in einem für uns geeigneten Stil abbilden und bei Bedarf sofort den Standardwert festlegen. </p><br><pre> <code class="javascript hljs">query: { <span class="hljs-string"><span class="hljs-string">'feed_shoffer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'feedShofferId'</span></span>, <span class="hljs-string"><span class="hljs-string">'pi-from'</span></span>: <span class="hljs-string"><span class="hljs-string">'piFrom'</span></span>, <span class="hljs-string"><span class="hljs-string">'show-urls'</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{showUrls = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'offercard'</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">) =&gt;</span></span> showUrls, }</code> </pre> <br><p>  Welche weiteren Vorteile erhalten wir? </p><br><ol><li>  <strong>Filtern</strong> .  Der Kunde erhält nur das, was er braucht, nicht mehr und nicht weniger. </li><li>  <strong>Aggregation</strong>  Sie müssen kein Client-Netzwerk und keine Batterie verschwenden, um mehrere Ajax-Anfragen zu stellen.  Ein spürbarer Geschwindigkeitsgewinn aufgrund der Tatsache, dass das Öffnen einer Verbindung ein teurer Vorgang ist. </li><li>  <strong>Caching</strong>  Ihr wiederholter aggregierter Anruf zieht niemanden erneut an, sondern gibt einfach 304 Not Modified zurück. </li><li>  Daten <strong>verstecken</strong> .  Beispielsweise verfügen Sie möglicherweise über Token, die zwischen Backends benötigt werden und nicht an den Client gesendet werden sollten.  Der Kunde hat möglicherweise nicht das Recht, überhaupt über die Existenz dieser Token Bescheid zu wissen, ganz zu schweigen von deren Inhalt. </li><li>  <strong>Microservices</strong> .  Wenn Sie einen Monolithen auf der Rückseite haben, ist BFF der erste Schritt zu Microservices. </li></ol><br><p>  Nun zu den Nachteilen. </p><br><ol><li>  Zunehmende <strong>Schwierigkeit</strong> .  Jede Abstraktion ist eine weitere Ebene, die codiert, bereitgestellt und unterstützt werden muss.  Ein weiterer beweglicher Teil des Mechanismus, der möglicherweise ausfällt. </li><li>  <strong>Duplizieren von</strong> Griffen.  Beispielsweise können mehrere Endpunkte denselben Aggregationstyp ausführen. </li><li>  BFF ist eine <strong>Grenzschicht</strong> , die allgemeines Routing, Einschränkungen der Benutzerrechte, Abfrageprotokollierung usw. unterstützen soll. </li></ol><br><p>  Um diese Minuspunkte auszugleichen, reicht es aus, einfache Regeln einzuhalten.  Die erste besteht darin, Front-End- und Geschäftslogik zu trennen.  Ihre BFF sollte die Geschäftslogik der Kern-API nicht ändern.  Zweitens sollte Ihre Ebene Daten nur dann konvertieren, wenn dies unbedingt erforderlich ist.  Wir sprechen nicht von einer in sich geschlossenen umfassenden API, sondern nur von einem Proxy, der die Lücke füllt und die Backend-Fehler korrigiert. </p><br><h3>  GraphQL </h3><br><p>  Ähnliche Probleme werden von GraphQL gelöst.  Mit GraphQL haben Sie anstelle vieler "dummer" Endpunkte einen intelligenten Stift, der mit komplexen Abfragen arbeiten und Daten in der Form generieren kann, in der der Client sie anfordert. </p><br><p>  Gleichzeitig kann GraphQL über REST arbeiten, d. H. Die Datenquelle ist nicht die Datenbank, sondern die Rest-API.  Aufgrund des deklarativen Charakters von GraphQL und der Tatsache, dass all dies mit React and Editors befreundet ist, wird Ihr Client einfacher. </p><br><p>  Tatsächlich sehe ich GraphQL als eine Implementierung von BFF mit seinem Protokoll und seiner strengen Abfragesprache. </p><br><p>  Dies ist eine ausgezeichnete Lösung, hat jedoch mehrere Nachteile, insbesondere bei der Typisierung, bei der Differenzierung von Rechten, und im Allgemeinen ist es ein relativ neuer Ansatz.  Daher haben wir noch nicht darauf umgestellt, aber in Zukunft scheint es mir der optimalste Weg zu sein, eine API zu erstellen. </p><br><h3>  Beste Freunde für immer </h3><br><p>  Ohne organisatorische Änderungen funktioniert keine technische Lösung ordnungsgemäß.  Sie benötigen noch Dokumentation, garantiert, dass sich das Antwortformat nicht plötzlich ändert usw. </p><br><p>  Es versteht sich, dass wir alle im selben Boot sitzen.  Für einen abstrakten Kunden, egal ob es sich um einen Manager oder Ihren Manager handelt, spielt es im Großen und Ganzen keine Rolle - Sie haben dort GraphQL oder BFF.  Für ihn ist es wichtiger, dass das Problem gelöst wird und keine Fehler auf dem Produkt auftreten.  Für ihn gibt es keinen großen Unterschied, aufgrund dessen Fehler ein Fehler im Produkt aufgetreten ist - durch den Fehler der Vorder- oder Rückseite.  Daher müssen Sie mit Backdern verhandeln. </p><br><p>  Darüber hinaus sind die Fehler im Hintergrund, über die ich zu Beginn des Berichts gesprochen habe, nicht immer auf böswillige Handlungen zurückzuführen.  Es ist möglich, dass der Parameter fesh auch eine Bedeutung hat. </p><br><img src="https://habrastorage.org/webt/zh/mh/ni/zhmhnidl5c9zkj_yh04ui_eimhe.png"><br><p>  Achten Sie auf das Datum des Commits.  Es stellte sich heraus, dass Fesh zuletzt seinen siebzehnten Geburtstag feierte. </p><br><p>  Sehen Sie links einige seltsame Bezeichner?  Dies ist SVN, einfach weil es 2001 keine Gita gab.  Kein Github als Service, sondern ein Gith als Versionskontrollsystem.  Er erschien erst 2005. </p><br><h3>  Die Dokumentation </h3><br><p>  Wir müssen uns also nicht mit dem Backend streiten, sondern zustimmen.  Dies kann nur geschehen, wenn wir eine einzige Quelle der Wahrheit finden.  Diese Quelle sollte die Dokumentation sein. </p><br><p>  Das Wichtigste dabei ist, die Dokumentation zu schreiben, bevor wir mit der Arbeit an der Funktionalität beginnen.  Wie bei einer Ehevereinbarung ist es besser, sich auf alles am Ufer zu einigen. </p><br><p>  Wie funktioniert es  Relativ gesehen werden drei: Manager, Front-End und Back-End.  Fronteder ist mit dem Themenbereich bestens vertraut, daher ist seine Teilnahme von entscheidender Bedeutung.  Sie sammeln und beginnen über die API nachzudenken: Auf welche Weise, welche Antworten sollten zurückgegeben werden, bis hin zum Namen und Format der Felder. </p><br><h3>  Prahlerei </h3><br><p>  Eine gute Option für die API-Dokumentation ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swagger-</a> Format, das jetzt OpenAPI heißt.  Es ist besser, Swagger im YAML-Format zu verwenden, da es im Gegensatz zu JSON besser von Menschen gelesen wird, aber es gibt keinen Unterschied für die Maschine. </p><br><p>  Infolgedessen werden alle Vereinbarungen im Swagger-Format festgelegt und in einem gemeinsamen Repository veröffentlicht.  Die Dokumentation für das Sales Backend muss sich im Assistenten befinden. </p><br><p>  Der Master ist vor Commits geschützt, der Code gelangt nur über den Anforderungspool in ihn, Sie können ihn nicht übertragen.  Der Vertreter des Frontteams ist verpflichtet, eine Überprüfung des Anforderungspools durchzuführen. Ohne sein Upgrade geht der Code nicht an den Master.  Dies schützt Sie ohne vorherige Ankündigung vor unerwarteten API-Änderungen. </p><br><p>  Also hast du dich zusammengetan, schrieb Swagger, also hast du den Vertrag tatsächlich unterschrieben.  Von diesem Moment an können Sie als Front-End Ihre Arbeit beginnen, ohne auf die Erstellung einer echten API warten zu müssen.  Was war der Punkt der Trennung zwischen Client und Server, wenn wir nicht parallel arbeiten können und Cliententwickler auf Serverentwickler warten müssen?  Wenn wir einen „Vertrag“ haben, können wir diese Angelegenheit sicher parallelisieren. </p><br><h3>  Faker.js </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Faker</a> eignet sich hervorragend für diese Zwecke.  Dies ist eine Bibliothek zum Generieren einer großen Menge gefälschter Daten.  Es können verschiedene Arten von Daten generiert werden: Daten, Namen, Adressen usw., all dies ist gut lokalisiert, es gibt Unterstützung für die russische Sprache. </p><br><p>  Gleichzeitig ist der Fälscher mit der Prahlerei befreundet, und Sie können den Mock-Server ruhig anheben, der auf der Grundlage des Swagger-Schemas falsche Antworten auf den erforderlichen Pfaden generiert. </p><br><h3>  Validierung </h3><br><p>  Swagger kann in ein JSON-Schema konvertiert werden. Mithilfe von Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ajv können</a> Sie Backend-Antworten direkt zur Laufzeit, in Ihrer BFF validieren und Tester, Backender selbst, bei Unstimmigkeiten usw. melden. </p><br><p>  Angenommen, ein Tester findet einen Fehler auf der Site. Wenn beispielsweise auf eine Schaltfläche geklickt wird, geschieht nichts.  Was macht der Tester?  Er legt ein Ticket an das Frontend: "Dies ist Ihr Knopf, er wird nicht gedrückt, reparieren Sie ihn." </p><br><p>  Wenn sich zwischen Ihnen und dem Back ein Validator befindet, weiß der Tester, dass die Taste tatsächlich gedrückt wird. Nur das Backend sendet die falsche Antwort.  Falsch - dies ist eine Antwort, die die Front nicht erwartet, das heißt, sie entspricht nicht dem „Vertrag“.  Und hier ist es bereits notwendig, entweder die Rückseite zu reparieren oder den Vertrag zu ändern. </p><br><h3>  Schlussfolgerungen </h3><br><ol><li>  Wir sind aktiv am Design der API beteiligt.  Wir gestalten die API so, dass sie nach 17 Jahren bequem verwendet werden kann. </li><li>  Wir benötigen Swagger-Dokumentation.  Keine Dokumentation - der Backend-Vorgang wurde nicht abgeschlossen. </li><li>  Es gibt eine Dokumentation - wir veröffentlichen sie in Git, und alle Änderungen an der API sollten vom Vertreter des Frontteams aktualisiert werden. </li><li>  Wir erhöhen den gefälschten Server und beginnen an der Front zu arbeiten, ohne auf die echte API zu warten. </li><li>  Wir setzen den Knoten unter das Frontend und validieren alle Antworten.  Außerdem können wir Daten aggregieren, normalisieren und zwischenspeichern. </li></ol><br><h4>  Siehe auch </h4><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So erstellen Sie eine REST-ähnliche API in einem großen Projekt</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Backend Im Frontend</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden von GraphQL als BFF-Musterimplementierung</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428141/">https://habr.com/ru/post/de428141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428129/index.html">Einfache Fuzzy-Logik „für das, was für ein Gasturbinentriebwerk war“</a></li>
<li><a href="../de428131/index.html">Die ganze Wahrheit über RTOS. Artikel Nr. 17. Ereignisflag-Gruppen: Einführung und Basisdienste</a></li>
<li><a href="../de428133/index.html">Hasura. Hochleistungs-GraphQL-zu-SQL-Server-Architektur</a></li>
<li><a href="../de428135/index.html">So konfigurieren oder deaktivieren Sie Flusen im integrierten Code-Editor</a></li>
<li><a href="../de428137/index.html">Olympiade, Ideenwettbewerb, Vorträge über IT-Projektmanagement und Filmvorführungen: 10 bevorstehende Veranstaltungen an der ITMO University</a></li>
<li><a href="../de428143/index.html">ReactJS RBAC-Implementierungsansatz</a></li>
<li><a href="../de428147/index.html">Skript zum Sammeln von Zitaten und Erkennen von Text aus Videos in Python</a></li>
<li><a href="../de428149/index.html">Ihr neuer Mavic 2 Enterprise Sky Ally</a></li>
<li><a href="../de428151/index.html">Leistungsüberprüfung von PostgreSQL 10.5 in den neuesten Yandex.Cloud-Clouddiensten</a></li>
<li><a href="../de428155/index.html">Geschwindigkeitsbegrenzung für Elektrofahrzeuge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>