<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍯 👩🏽‍🤝‍👨🏻 🚝 Wie Lisp eine Programmiersprache für Gott wurde 👙 👨🏽‍🌾 🌹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Programmierer die Vorteile verschiedener Programmiersprachen diskutieren, sprechen sie oft prosaisch über sie als Werkzeuge in einer Reihe versch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Lisp eine Programmiersprache für Gott wurde</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428229/">  Wenn Programmierer die Vorteile verschiedener Programmiersprachen diskutieren, sprechen sie oft prosaisch über sie als Werkzeuge in einer Reihe verschiedener Geräte - eines eignet sich besser für die Systemprogrammierung, das andere zum Kleben anderer Programme, um das aktuelle Problem zu lösen.  Es sollte so sein.  Sprachen haben unterschiedliche Stärken, und die Aussage, dass eine Sprache besser ist als andere Sprachen, ohne spezifische Beispiele anzugeben, führt nur zu unproduktiven und scharfen Debatten. <br><br>  Es gibt jedoch eine Sprache, die seltsamerweise universellen Respekt erregt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lisp</a> .  Die Kreuzfahrer der Tastaturen, die bereit sind, jeden anzugreifen, der es wagt zu erklären, dass eine Sprache besser ist als andere, sind sich einig, dass sich Lisp auf einer anderen Ebene befindet.  Es geht über die utilitaristischen Kriterien hinaus, nach denen andere Sprachen beurteilt werden, da der durchschnittliche Programmierer Lisp nie verwendet hat, um etwas Praktisches zu schaffen, und dies wahrscheinlich auch nie tun wird. Der Respekt für Lisp ist jedoch so tief, dass ihm oft zugeschrieben wird mythische Eigenschaften.  In den beliebtesten xkcd-Comics aller wurde Lisp mindestens zweimal dargestellt: In einem Comic erreicht eine Figur die Erleuchtung von Lisp, was ihm hilft, die grundlegende Struktur des Universums zu verstehen.  In einem anderen Fall übergibt ein alter Programmierer im Schlafrock seinem Padawan einen Stapel Klammern und erklärt, dass dies „eine elegante Waffe für zivilisiertere Zeiten“ ist, was auf die okkulten Möglichkeiten der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Macht</a> anspielt, die Lisp innewohnt. <br><a name="habracut"></a><br>  Ein weiteres gutes Beispiel ist Bob Kanefskys Parodie auf das Lied "Gott lebt auf Terra".  Seine Parodie wurde Mitte der 90er Jahre geschrieben und heißt "Eternal Flame".  Sie beschreibt, wie Gott anscheinend die Welt mit Hilfe von Lisp erschaffen hat.  Das Folgende ist ein Auszug und die Vollversion finden Sie auf der Website der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Humor Collection</a> : <br><blockquote>  Immerhin schrieb Gott in Lisp <br>  Als er die Blätter mit Grün füllte. <br>  Fraktale Blüten und rekursive Wurzeln: <br>  Der schönste Hack, den ich je gesehen habe. <br>  Und wenn ich die Schneeflocken studiere <br>  Und ich finde nicht zwei davon <br>  Ich weiß, dass Gott die Sprache liebt <br>  Mit einem eigenen Namen aus vier Buchstaben. </blockquote><br>  Ich spreche nur für mich selbst, aber es scheint mir, dass das kulturelle Mem „Lisp ist geheime Magie“ das seltsamste und interessanteste Phänomen ist.  Lisp wurde in einem Elfenbeinturm als Werkzeug zur Erforschung der künstlichen Intelligenz konzipiert, so dass es für gewöhnliche Programmierer immer etwas ungewohnt und mysteriös sein wird.  Jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drängen</a> sich die Programmierer jedoch gegenseitig, "versuchen Sie es mit Lisp, bevor Sie sterben", als wäre es eine Art Psychedelikum, das das Bewusstsein erweitert.  Sie tun dies trotz der Tatsache, dass Lisp nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortran</a> die zweitälteste der noch verwendeten Programmiersprachen ist, und das ist nur ein Jahr.  Stellen Sie sich vor, das Unternehmen oder Team, das es entwickelt hat, würde Sie anweisen, für eine neue Programmiersprache zu werben.  Wäre es nicht cool, alle davon überzeugen zu können, dass Ihre neue Sprache göttliche Kräfte hat?  Aber wie könnte dies erreicht werden?  Wie wurde die Programmiersprache als Quelle geheimen Wissens berühmt? <br><br>  Wie kam Lisp dazu? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/303/7b7/7d7/3037b77d74f9f90ecacc06b0d77f8b6e.jpg"><br>  <i>Byte Magazine Cover, August 1979</i> <br><br><h2>  Theorie A: Axiomatische Sprache </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">John McCarthy</a> , der Schöpfer von Lisp, wollte Lisp zunächst nicht zum eleganten Wesen der Rechenprinzipien machen.  Aber nach ein oder zwei erfolgreichen Ideen und mehreren Verbesserungen wurde Lisp genau das.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paul Graham</a> - wir werden später darüber sprechen - schrieb, dass McCarthy, nachdem er Lisp erstellt hatte, "dasselbe für die Programmierung getan hat wie Euklid für die Geometrie".  Vielleicht suchen die Leute nach einer tieferen Bedeutung in Lisp, weil McCarthy sie aus so grundlegenden Teilen geschaffen hat, dass es schwer zu sagen ist, ob er sie erfunden oder entdeckt hat. <br><br>  McCarthy begann während des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dartmouth Summer Artificial Intelligence Research Project 1956</a> über die Schaffung der Sprache nachzudenken.  Dieser Workshop war eine kontinuierliche mehrwöchige akademische Konferenz, die allererste auf dem Gebiet der KI.  Übrigens war es McCarthy, der als außerordentlicher Professor für Mathematik in Dartmoor den Begriff „künstliche Intelligenz“ prägte und vorschlug, dieses Treffen abzuhalten.  An der Konferenz nahmen etwa zehn Personen teil.  Unter ihnen waren Allen Newel und Herbert Simon, zwei Forscher der RAND Corporation und der Carnegie Mellon University, die gerade die Entwicklung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPL-</a> Sprache abgeschlossen hatten. <br><br>  Newel und Simon versuchten, ein System zu schaffen, das Beweise in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Logik der Äußerungen</a> liefern kann.  Sie erkannten, dass es schwierig sein würde, dies zu tun, und blieben auf der Ebene ihrer eigenen Computeranweisungen. Deshalb beschlossen sie, eine Sprache - oder, wie sie es nannten, einen "Pseudocode" - zu erstellen, die ihnen helfen würde, die Arbeit ihrer "Maschine der theoretischen Logik" natürlicher auszudrücken.  Ihre Sprache, IPL, die "Informationsverarbeitungssprache", ähnelte eher einem Assembler-Dialekt auf hoher Ebene als einer Programmiersprache im modernen Sinne.  Newel und Simon, die sich möglicherweise auf Fortran bezogen, stellten fest, dass die damals in Entwicklung befindlichen „anderen Pseudocodes“ mit der Darstellung der Gleichungen in mathematischer Standardnotation „beschäftigt“ waren.  Stattdessen konzentrierte sich ihre Sprache darauf, Aussagen als Listen symbolischer Ausdrücke darzustellen.  IPL-Programme verwendeten Assembly-Sequenzen von Makros, um Ausdrücke in einer oder mehreren dieser Listen zu verarbeiten und auszuwerten. <br><br>  McCarthy hielt es für nützlich, algebraische Ausdrücke in einer ähnlichen Sprache wie Fortran zu haben.  Daher mochte er das IPL nicht.  Aber er dachte, dass symbolische Listen eine gute Möglichkeit sind, Aufgaben aus dem Bereich der KI zu modellieren, insbesondere solche, die Deduktion beinhalten.  Es war der Keim von McCarthys Wunsch, eine algebraische Listenverarbeitungssprache zu erstellen, eine Sprache, die Fortran ähnelte, aber mit symbolischen Listen wie dem IPL umgehen konnte. <br><br>  Natürlich ähnelt Lisp heute nicht Fortran.  In den nächsten Jahren haben sich McCarthys Ideen für eine ideale Listenverarbeitungssprache weiterentwickelt.  Seine Ideen änderten sich 1957, als er anfing, Verfahren für das Fortran-Schachprogramm zu schreiben.  Fortrans Langzeitbelichtung überzeugte McCarthy davon, dass sein Design mehrere schlechte Stellen enthielt, von denen die wichtigste die ungeschickte IF-Aussage war.  McCarthy erfand eine Alternative, den bedingten Ausdruck „true“, der bei erfolgreicher Prüfung den Unterausdruck A und in einem anderen Fall den Unterausdruck B zurückgibt und nur den zurückgegebenen Unterausdruck ausführt.  Im Sommer 1958, als McCarthy an einem differenzierbaren Programm arbeitete, stellte er fest, dass sein bedingter Ausdruck „wahr“ das Schreiben rekursiver Funktionen einfacher und natürlicher machte.  Das Differenzierungsproblem veranlasste McCarthy auch, eine Maplist-Funktion zu schreiben, die eine andere Funktion als Argument verwendet und auf alle Elemente der Liste anwendet.  Es war nützlich, um die Summen einer beliebigen Anzahl von Mitgliedern zu differenzieren. <br><br>  Fortran konnte solche Dinge nicht ausdrücken, und so stellte McCarthy im Herbst 1958 mehreren Studenten die Aufgabe, Lisp umzusetzen.  Da McCarthy nun außerordentlicher Professor am MIT war, studierten alle Studenten am MIT.  Durch die Übersetzung von Ideen in Arbeitscode nahmen McCarthy und die Schüler Änderungen vor, die die Sprache weiter vereinfachten.  Die größte davon war die Lisp-Syntax.  McCarthy wollte zunächst das sogenannte  "M-Ausdrücke", eine Schicht aus " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">syntaktischem Zucker</a> ", die die Lisp-Syntax wie Fortran aussehen ließ.  Obwohl M-Ausdrücke in S-Ausdrücke übersetzt werden können - eine einfache Liste in Klammern, für die Lisp berühmt ist - waren S-Ausdrücke wirklich eine Darstellung auf niedriger Ebene für einen Computer.  Das einzige Problem war, dass McCarthy M-Ausdrücke mit eckigen Klammern bezeichnete und es keine quadratischen Klammern für den im MIT verwendeten IBM 026-Stempel gab.  Daher beschränkte sich das Lisp-Team auf S-Ausdrücke und verwendete sie, um nicht nur Datenlisten, sondern auch die Verwendung von Funktionen darzustellen.  McCarthy und die Schüler machten mehrere andere Vereinfachungen, einschließlich der Umstellung auf Präfixaufzeichnung und eines Speichermodells, in dem die Sprache nur eine Art von Real hatte. <br><br>  1960 veröffentlichte McCarthy die berühmte Arbeit über Lisp "Rekursive Funktionen symbolischer Ausdrücke und ihre Berechnung durch Maschine].  Bis dahin war die Sprache so stark reduziert worden, dass McCarthy erkannte, dass er ein "elegantes mathematisches System" geschaffen hatte und nicht nur eine andere Programmiersprache.  Später schrieb er, dass viele der Vereinfachungen in Lisp es zu einer "Art der Beschreibung berechneter Funktionen machten, die viel genauer ist als Turing-Maschinen oder allgemeine rekursive Definitionen, die in der Theorie der rekursiven Funktionen verwendet werden".  In seiner Arbeit führte er Lisp als funktionierende Programmiersprache und als Formalismus zur Untersuchung des Verhaltens rekursiver Funktionen ein. <br><br>  McCarthy erklärte den Lesern Lisp und baute es aus einem kleinen Regelwerk auf.  Später trat Paul Graham in seinem Aufsatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roots of Lisp</a> mit einer leichter lesbaren Sprache in McCarthys Fußstapfen.  Graham kann Lisp mit nur sieben primitiven Operatoren, zwei verschiedenen Einträgen für Funktionen und sechs Funktionen auf hoher Ebene erklären, die durch primitive Operatoren definiert werden.  Die Fähigkeit, Lisp mit einer so kleinen Folge einfacher Regeln zu definieren, trägt zweifellos zu seinem Rätsel bei.  Graham nannte McCarthys Arbeit einen Versuch, "die Berechnung zu axiomatisieren".  Ich denke, dies ist eine großartige Möglichkeit, über die Attraktivität von Lisp nachzudenken.  In anderen Sprachen gibt es eindeutig künstliche Konstrukte, die durch reservierte Wörter wie while, typedef oder public static void beschrieben werden. Es scheint, dass die Lisp-Beschreibung durch die Logik der Berechnungen begrenzt ist.  Diese Qualität und Lisps ursprüngliche Verbindung mit einem esoterischen Feld wie der „Theorie der rekursiven Funktionen“ sollte das aktuelle Prestige der Sprache erklären. <br><br><h2>  Theorie B: Die Maschine der Zukunft </h2><br>  Zwei Jahrzehnte nach seiner Gründung ist Lisp laut dem berühmten " <a href="">Wörterbuch der Informatiker</a> " die "Muttersprache" der KI-Forschung geworden.  Lisp verbreitete sich in den frühen Stadien schnell, wahrscheinlich aufgrund der Tatsache, dass seine systematische Syntax die Implementierung auf neuen Maschinen relativ einfach machte.  Später verwendeten die Forscher es weiter, weil es mit symbolischen Ausdrücken gut umgehen konnte, was in einer Zeit wichtig war, als die meisten KI symbolisch waren.  Lisp wurde in so produktiven KI-Projekten wie dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SHRDLU-</a> Programm für natürliche Sprache, dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Macsyma-</a> Computeralgebrasystem und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ACL2-</a> Logiksystem verwendet. <br><br>  Mitte der 1970er Jahre mangelte es den KI-Forschern an Computerleistung.  Zum Beispiel hatte der PDP-10 - jedermanns beliebteste KI-Maschine - einen 18-Bit-Adressraum, der für KI-Programme in Lisp zunehmend fehlte.  Viele KI-Programme mussten auch interaktiv sein, und die Erstellung eines großen interaktiven Programms, das auf einem Time-Sharing-System gut funktioniert, war eine schwierige Aufgabe.  Die Lösung, die Peter Deutsch vom MIT zuerst vorschlug, bestand darin, einen dedizierten Computer für Lisp zu entwickeln.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solche Maschinen</a> sollten jedem Benutzer einen dedizierten Prozessor bieten, der für Lisp optimiert ist.  Sie mussten auch eine in Lisp geschriebene Entwicklungsumgebung für Hardcore-Lisp-Programmierer haben.  Lisp-Maschinen, die zu einem unangenehmen Zeitpunkt am Ende der Ära der Mini-Computer erfunden wurden, aber vor der Blütezeit der Mikrocomputer-Revolution, waren Hochleistungs-PCs für die Elite der Programmierer. <br><br>  Für eine Weile schien es, dass Lisp-Maschinen die Welle der Zukunft sein würden.  Es gab mehrere Unternehmen, die um die Kommerzialisierung dieser Technologie zu konkurrieren begannen.  Am erfolgreichsten war Symbolics, das von Veteranen des MIT AI Lab entwickelt wurde.  In den 1980er Jahren brachte Symbolics seine 3600er-Serie von Computern auf den Markt, die in der KI-Industrie und in Branchen, die High-Power-Computing erfordern, beliebt sind.  Die 3600-Reihe umfasste Computer mit großen Bildschirmen, Bitmap-Grafiken, einer mausbasierten Oberfläche sowie leistungsstarken Grafik- und Animationsprogrammen.  Dies waren beeindruckende Maschinen, die es ermöglichten, beeindruckende Programme zu schreiben.  Zum Beispiel schrieb mir Bob Cali, der auf dem Gebiet der Robotikforschung tätig war, über Twitter, dass er 1985 den Pfad-Suchalgorithmus auf Symbolics 3650 implementieren und visualisieren konnte. Er sagte, dass Rastergrafiken und OOP (verfügbar auf Lisp-Maschinen dank der Flavours-Erweiterung) waren in den 1980er Jahren neu.  Die Symbolik stand im Vordergrund. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed6/24f/fd8/ed624ffd86464f9be7709ddae35ca3cf.jpg"><br><br>  Infolgedessen waren Symbolics-Computer wahnsinnig teuer.  Symbolics 3600 kostete 1983 110.000 US-Dollar. Die meisten Menschen konnten sich nur über die Leistung von Lisp-Maschinen und die Magie der Bediener wundern, die aus der Ferne in Lisp schreiben.  Aber sie wunderten sich.  Das Byte-Magazin beschrieb Lisp und Lisp-Maschinen zwischen 1979 und den späten 1980er Jahren mehrmals.  In der August 1979-Ausgabe von Lisp war der Chefredakteur begeistert von den neuen Maschinen, die am MIT entwickelt wurden, "mit einem Berg an Speicher" und einem "fortschrittlichen Betriebssystem".  Er hielt sie für so vielversprechend, dass die letzten zwei Jahre, in denen Apple II, Commodore PET und TRS-80 erschienen, langweilig wirkten.  Fünf Jahre später, 1985, beschrieb der Autor des Byte-Magazins den Prozess des Schreibens von Lisp-Programmen für die „komplexe und äußerst leistungsfähige Symbolik 3670“ und ermutigte die Leser, Lisp zu lernen, und erklärte, es sei beides „die Sprache, die die meisten KI-Forscher benötigen“. und ein Kandidat für eine zukünftige Allzwecksprache. <br><br>  Ich fragte Paul MacJones, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der viel getan hatte</a> , um Lisp im Mountain View Museum für Computergeschichte zu retten, wann die Leute zum ersten Mal über Lisp als Geschenk höherdimensionaler Kreaturen sprachen.  Er sagte, dass die Merkmale der Sprache selbst sicherlich dazu beigetragen haben, aber auch die enge Verbindung zwischen Lisp und leistungsstarken KI-Anwendungen in den 1960er und 1970er Jahren.  Als es in den 1980er Jahren möglich wurde, Lisp-Maschinen zu kaufen, trafen sich einige weitere Menschen außerhalb von Orten wie MIT oder Stanford, und die Legende wuchs weiter.  Heutzutage erinnern sich nur wenige Menschen an Lisp-Maschinen und Symbolik, aber sie haben dazu beigetragen, die Aura des Lisp-Mysteriums bis in die 1980er Jahre aufrechtzuerhalten. <br><br><h2>  Theorie B: Programmiertraining </h2><br>  1985 veröffentlichten Professoren des MIT, Harold Abelson und Gerald Sasman sowie Sasmans Frau Julia das Lehrbuch Struktur und Interpretation von Computerprogrammen.  Im Lehrbuch wurde den Lesern das Programmieren in der Schemasprache Lisp-Dialekt beigebracht.  Es wurde am MIT für eine Einführung in die Programmierung für zwei Jahrzehnte verwendet.  Es scheint mir, dass dies ein Lehrbuch ist, SICP, das Lisp Mystik hinzufügte.  SICP nahm Lisp und zeigte, wie es verwendet werden kann, um die tiefen, fast philosophischen Konzepte der Programmierkunst zu veranschaulichen.  Diese Konzepte waren häufig genug, um PL zu verwenden, aber die SICP-Autoren entschieden sich für Lisp.  Infolgedessen wurde Lisps Ruf durch die Bekanntheit dieses seltsamen und brillanten Buches ergänzt, das viele Generationen von Programmierern faszinierte (und zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehr seltsamen Mem wurde</a> ).  Lisp war schon immer "McCarthys eleganter Formalismus";  Jetzt ist es auch eine Sprache geworden, die "Ihnen die verborgenen Geheimnisse des Programmierens beibringt". <br><br>  Es lohnt sich, ein wenig darüber zu sprechen, wie seltsam dieses Buch ist - denn es scheint mir, dass seine Fremdheit und Fremdheit Lisp heute zu einem verschmolzen sind.  Fremdheit beginnt auf dem Cover.  Es zeigt einen Zauberer oder einen Alchemisten, der sich einem Tisch nähert und bereit ist, eine Art Hexerei zu beginnen.  In der einen Hand hat er einen Messschieber oder Kompass, in der anderen einen Globus mit den Aufschriften "eval" und "apply".  Die Frau gegenüber zeigt auf den Tisch;  Vor dem Hintergrund strahlt der griechische Buchstabe Lambda in der Luft. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/c76/41a/dcdc7641ad77a08295763e07c85e4727.jpg"><br><br>  Was ist hier los?  Warum sitzt ein Tierbein am Tisch?  Warum zeigt eine Frau auf den Tisch?  Welche Bedeutung hat das Tintenfass?  Sollten wir verstehen, dass der Zauberer das geheime Wissen des Universums enthüllt hat und dass sie aus einem Eval / Apply-Zyklus und einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambda-Kalkül bestehen</a> ?  Anscheinend ist es das.  Nur dieses Bild hätte viel zur heutigen Wahrnehmung von Lisp beitragen sollen. <br><br>  Aber der Text des Buches selbst erweist sich oft als ebenso seltsam.  SICP ist nicht wie die meisten anderen Bücher über Informatik.  Die Autoren im Vorwort erklären, dass es in dem Buch nicht nur um das Programmieren in Lisp geht - es handelt von "drei Tricks oder Phänomenen: dem menschlichen Verstand, einer Reihe von Computerprogrammen und einem Computer".  Später beschreiben sie, dass sie davon überzeugt sind, dass Programmierung nicht als Disziplin der Informatik betrachtet werden sollte, sondern als neue Aufzeichnung der „prozeduralen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erkenntnistheorie</a> “.  Programme sind eine neue Möglichkeit, Gedanken zu strukturieren, die nur gelegentlich in einen Computer eingegeben werden.  Das erste Kapitel gibt einen kurzen Überblick über Lisp, aber der größte Teil des Buches handelt von abstrakteren Konzepten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es werden verschiedene Programmierparadigmen, die Art von Zeit und Identität in OO-Systemen und an einer Stelle diskutiert, welche Synchronisationsprobleme aufgrund der grundlegenden Einschränkungen der Nachrichtenübermittlung auftreten können, die die Rolle der Lichtgeschwindigkeit in der Relativitätstheorie spielen. </font><font style="vertical-align: inherit;">Das sind ziemlich abstruse Dinge.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und um nicht zu sagen, dass das Buch schlecht ist. Sie ist wunderbar. Es werden wichtige Programmierkonzepte auf einer höheren Ebene als in allen anderen Büchern besprochen, die ich gelesen habe, Konzepte, über die ich lange nachgedacht habe, die ich aber nicht beschreiben konnte. Überraschenderweise kann die Einführung in das Programmierlehrbuch so schnell die grundlegenden Nachteile von OOP und die Vorteile von Funktionssprachen beschreiben, die einen veränderlichen Zustand minimieren. Es ist erstaunlich, wie sich daraus eine Diskussion darüber entwickelt, wie das Streaming-Paradigma wahrscheinlich dem heutigen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RxJS ähnelt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann Ihnen das Beste aus beiden Ansätzen geben. SICP unterstreicht die Essenz der Entwicklung von Programmen auf hoher Ebene in einer Weise, die an McCarthys ursprüngliche Arbeit an Lisp erinnert. Das erste, was Sie nach dem Lesen dieses Buches tun möchten, ist, Ihre Programmierkollegen dazu zu bringen, es zu lesen. Wenn sie es finden, das Cover sehen und nicht lesen, wird nur verschoben, dass eine mysteriöse Sache namens eval / apply Zauberern eine besondere Macht über Tische mit Tierbeinen verleiht. Ich wäre von ihren Schuhen beeindruckt gewesen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber der vielleicht wichtigste Beitrag von SICP war es, Lisp von einer lustigen Neugierde zu einer pädagogischen Notwendigkeit zu machen. Lange vor SICP rieten sich die Leute gegenseitig, Lisp zu lernen, um ihr Niveau als Programmierer zu verbessern. 1979 Ausgabe des Byte Magazine. Derselbe Redakteur, der die neuen Lisp-Maschinen am MIT bewunderte, erklärte, dass es sich lohnt, diese Sprache zu lernen, da sie „eine andere Sichtweise auf die Aufgaben darstellt“. Bei SICP wurde Lisp jedoch nicht nur als Kontrast zu anderen Sprachen präsentiert. Es wurde als Einführungssprache verwendet, was darauf hindeutet, dass es die beste Sprache zum Erlernen grundlegender Programmierkonzepte ist. Wenn sich heutige Programmierer gegenseitig raten, Lisp zu probieren, bevor sie sterben, tun sie dies wahrscheinlich aufgrund von SICP. Schließlich bietet Brainfuck wahrscheinlich auch eine „andere Perspektive auf Aufgaben“.Stattdessen lernen die Leute Lisp, weil sie wissen, dass Lisps Sichtweise seit zwanzig Jahren so nützlich ist, dass Studenten am MIT Lisp in allen anderen Sprachen unterrichteten.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lisp Return </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Jahr der Veröffentlichung von SICP veröffentlichte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Björn Straustrup</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die erste Ausgabe des Buches " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Programming Language</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", das OOP in die Massen brachte. </font><font style="vertical-align: inherit;">Einige Jahre später brach der Lisp-Maschinenmarkt zusammen und der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winter der KI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> begann </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In den nächsten zehn Jahren wurden C ++ und dann Java die Sprachen der Zukunft, und Lisp wurde vegetiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich ist es unmöglich zu sagen, wann genau die Leute wieder anfingen, Lisp zu bewundern. </font><font style="vertical-align: inherit;">Vielleicht geschah dies, nachdem Paul Graham, Mitbegründer von Y-Combinator und Schöpfer von Hacker News, mehrere einflussreiche Essays veröffentlicht hatte, in denen Lisp als die beste Sprache für Startups beschrieben wurde. </font><font style="vertical-align: inherit;">Im Essay </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahead of Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Graham behauptete, dass Lisp-Makros die Sprache stärker machten als andere Sprachen. Er erklärte, dass die Verwendung von Lisp in seinem Viaweb-Startup ihm geholfen habe, bestimmte Dinge schneller zu entwickeln als seine Konkurrenten. Einige Programmierer waren überzeugt. Aber die meisten wechselten nicht zu Lisp.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stattdessen fielen immer mehr Funktionen von Lisp in die Lieblingssprachen aller. Python hat die Listengenerierung hinzugefügt. In C # - Linq. In Ruby ... nun, Ruby ist Lisp. Wie Graham bereits 2001 feststellte, "entwickelte sich die Standardsprache, die in viele der späteren populären Sprachen integriert war, allmählich zu Lisp." Und während sich andere Sprachen allmählich Lisp nähern, behält Lisp selbst irgendwie seinen besonderen Ruf als mysteriöse Sprache bei, die nur wenige verstehen, aber jeder lernen muss. 1980, im Jahr des 20-jährigen Jubiläums von Lisp, schrieb McCarthy, dass Lisp so lange überlebt habe, wie er "ein ungefähres lokales Optimum im Raum von PL" genommen habe. Dies unterschätzt jedoch den wirklichen Einfluss von Lisp. Er hat fünfzig Jahre überlebt, weil Programmierer Jahrzehnt für Jahrzehnt widerstrebend erkannten, dass dies das beste Werkzeug für ihre Aufgabe ist. Er hat trotzdem überlebtdass die meisten Programmierer es nicht verwenden. Aufgrund seiner Herkunft und Verwendung in der KI-Forschung und vielleicht auch des Erbes von SICP erfreut Lisp die Menschen weiterhin. Und bis wir uns vorstellen können, dass Gott die Welt mit Hilfe einer neueren Sprache erschaffen hat, wird Lisp nirgendwo hingehen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428229/">https://habr.com/ru/post/de428229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428219/index.html">Woher kommt die Praxis der Massenverlagerung von qualifiziertem Personal?</a></li>
<li><a href="../de428221/index.html">KI-Erzeugung realistischer Gesichter</a></li>
<li><a href="../de428223/index.html">Städte und ihre Big Data</a></li>
<li><a href="../de428225/index.html">So führen Sie Webanalysen für SaaS über Google Analytics durch: Einführung und Verfolgung eines Trichters</a></li>
<li><a href="../de428227/index.html">Maschinelles Lernen: Vorhersage der Aktienkurse an der Börse</a></li>
<li><a href="../de428231/index.html">Schön und sauber: Tools, mit denen Sie nahezu perfekten Code erzielen</a></li>
<li><a href="../de428233/index.html">Fünf Gründe, regionale IT-Partys zu lieben</a></li>
<li><a href="../de428235/index.html">Warum haben sie mich mitten in der Nacht von der NSA angerufen und nach der Quelle gefragt?</a></li>
<li><a href="../de428237/index.html">Scrum-Mitap mit Brettspiel: Laden Sie zum Scrum Values ​​Game ein</a></li>
<li><a href="../de428239/index.html">Flash-Laufwerke kurz vor 2019 - ein Relikt der Vergangenheit oder immer noch eine Notwendigkeit?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>