<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèæ üßòüèø üõåüèæ Extension SIMD √† C ++ OpenMP dans Visual Studio üë©üèæ‚Äçüíª üòµ üíá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä l'√®re des applications d'IA omnipr√©sentes, il y a une demande √©mergente du compilateur acc√©l√©rant le code d'apprentissage machine intensif en calcul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extension SIMD √† C ++ OpenMP dans Visual Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/446688/"><p>  √Ä l'√®re des applications d'IA omnipr√©sentes, il y a une demande √©mergente du compilateur acc√©l√©rant le code d'apprentissage machine intensif en calcul pour le mat√©riel existant.  Un tel code effectue g√©n√©ralement le calcul math√©matique comme la transformation et la manipulation de matrice et il est g√©n√©ralement sous la forme de boucles.  L'extension SIMD d'OpenMP offre aux utilisateurs un moyen sans effort d'acc√©l√©rer les boucles en exploitant explicitement l'unit√© vectorielle des processeurs modernes.  Nous sommes fiers de commencer √† proposer la vectorisation SIMD C / C ++ OpenMP dans Visual Studio 2019. </p><br><p>  L'interface du programme d'application OpenMP C / C ++ a √©t√© initialement con√ßue pour am√©liorer les performances des applications en permettant au code d'√™tre efficacement ex√©cut√© en parall√®le sur plusieurs processeurs dans les ann√©es 1990.  Au fil des ans, la norme OpenMP a √©t√© √©tendue pour prendre en charge des concepts suppl√©mentaires tels que la parall√©lisation bas√©e sur les t√¢ches, la vectorisation SIMD et le d√©chargement de processeur.  Depuis 2005, Visual Studio prend en charge la norme OpenMP 2.0 qui se concentre sur la parall√©lisation multithread.  Alors que le monde entre dans une √®re de l'IA, nous voyons une opportunit√© croissante d'am√©liorer la qualit√© du code en √©tendant la prise en charge de la norme OpenMP dans Visual Studio.  Nous continuons notre voyage dans Visual Studio 2019 en ajoutant la prise en charge d'OpenMP SIMD. </p><br><img src="https://habrastorage.org/webt/74/-s/cs/74-scsh4qdjqqdw-qj3ynz5ircc.jpeg"><a name="habracut"></a><br><br><p>  OpenMP SIMD, introduit pour la premi√®re fois dans la norme OpenMP 4.0, cible principalement la vectorisation de boucle.  Il s'agit √† ce jour de la fonctionnalit√© OpenMP la plus utilis√©e dans l'apprentissage automatique selon nos recherches.  En annotant une boucle avec une directive OpenMP SIMD, le compilateur peut ignorer les d√©pendances vectorielles et vectoriser la boucle autant que possible.  Le compilateur respecte l'intention des utilisateurs d'ex√©cuter simultan√©ment plusieurs it√©rations de boucle. </p><br><pre><code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 0; i &lt; count; i++) { a[i] = b[i] + 1; }</span></span></code> </pre> <br><p>  Comme vous le savez peut-√™tre, C ++ dans Visual Studio fournit d√©j√† des pragmas de boucle non OpenMP similaires comme <strong>#pragma vector</strong> et <strong>#pragma ivdep</strong> .  Cependant, le compilateur peut faire plus avec OpenMP SIMD.  Par exemple: </p><br><ol><li>  Le compilateur est toujours autoris√© √† ignorer toutes les d√©pendances vectorielles pr√©sentes. </li><li>  / fp: fast est activ√© dans la boucle. </li><li>  Les boucles avec appels de fonction sont vectorisables. </li><li>  Les boucles externes sont vectorisables. </li><li>  Les boucles imbriqu√©es peuvent √™tre fusionn√©es en une seule boucle et vectoris√©es. </li><li>  L'acc√©l√©ration hybride est r√©alisable avec <strong>#pragma omp for simd</strong> pour permettre le multithreading √† gros grain et la vectorisation √† grain fin. </li></ol><br><p>  De plus, la directive OpenMP SIMD peut prendre les clauses suivantes pour am√©liorer encore la vectorisation: </p><br><ul><li>  <strong>simdlen (</strong> <em>longueur</em> <strong>):</strong> sp√©cifiez le nombre de voies vectorielles </li><li>  <strong>safelen (</strong> <em>longueur</em> <strong>):</strong> sp√©cifiez la distance de d√©pendance du vecteur </li><li>  <strong>linear (</strong> <em>list [</em> <strong>:</strong> <em>linear-step]</em> <strong>):</strong> le mappage lin√©aire de la variable d'induction de boucle √† l'abonnement au tableau </li><li>  <strong>align√© (</strong> <em>liste [</em> <strong>:</strong> <em>alignement]</em> <strong>):</strong> l'alignement des donn√©es </li><li>  <strong>priv√© (</strong> <em>liste</em> <strong>):</strong> sp√©cifier la privatisation des donn√©es </li><li>  <strong>lastprivate (</strong> <em>liste</em> <strong>):</strong> sp√©cifiez la privatisation des donn√©es avec la valeur finale de la derni√®re it√©ration </li><li>  <strong>r√©duction (</strong> <em>r√©duction-identifiant</em> <strong>:</strong> <em>liste</em> <strong>):</strong> sp√©cifiez des op√©rations de r√©duction personnalis√©es </li><li>  <strong>effondrement (</strong> <em>n</em> <strong>):</strong> imbrication de boucle coalescente </li></ul><br><h3>  Nouveau <em>-openmp:</em> commutateur <em>exp√©rimental</em> </h3><br><p>  Un programme annot√© OpenMP-SIMD peut √™tre compil√© avec un nouveau commutateur CL <strong>-openmp: experimental.</strong>  Ce nouveau commutateur active des fonctionnalit√©s OpenMP suppl√©mentaires non disponibles sous <strong>-openmp</strong> .  Bien que le nom de ce commutateur soit ¬´exp√©rimental¬ª, le commutateur lui-m√™me et les fonctionnalit√©s qu'il active sont enti√®rement pris en charge et pr√™ts pour la production.  Le nom indique qu'il n'active aucun sous-ensemble ou version compl√®te d'une norme OpenMP.  Les futures it√©rations du compilateur pourraient utiliser ce commutateur pour activer des fonctionnalit√©s OpenMP suppl√©mentaires et de nouveaux commutateurs li√©s √† OpenMP pourraient √™tre ajout√©s.  Le <strong>commutateur -openmp: experimental</strong> r√©sume le commutateur <strong>-openmp</strong> , ce qui signifie qu'il est compatible avec toutes les fonctionnalit√©s d'OpenMP 2.0.  Notez que la directive SIMD et ses clauses ne peuvent pas √™tre compil√©es avec le commutateur <strong>-openmp</strong> . </p><br><p>  Pour les boucles qui ne sont pas vectoris√©es, le compilateur √©mettra un message pour chacune d'entre elles comme ci-dessous.  Par exemple, </p><br><p>  cl -O2 -openmp: exp√©rimental mycode.cpp </p><br><p>  mycode.cpp (84): info C5002: boucle simd Omp non vectoris√©e pour la raison '1200' </p><br><p>  mycode.cpp (90): info C5002: boucle simd Omp non vectoris√©e pour la raison '1200' </p><br><p>  Pour les boucles vectoris√©es, le compilateur reste silencieux sauf si un commutateur de journalisation de vectorisation est fourni: </p><br><p>  cl -O2 -openmp: exp√©rimental -Qvec-report: 2 mycode.cpp </p><br><p>  mycode.cpp (84): info C5002: boucle simd Omp non vectoris√©e pour la raison '1200' </p><br><p>  mycode.cpp (90): info C5002: boucle simd Omp non vectoris√©e pour la raison '1200' </p><br><p>  mycode.cpp (96): info C5001: boucle simd Omp vectoris√©e </p><br><p>  Comme premi√®re √©tape de la prise en charge d'OpenMP SIMD, nous avons fondamentalement branch√© le pragma SIMD avec le vectoriseur backend sous le nouveau commutateur.  Nous nous sommes concentr√©s sur la vectorisation des boucles les plus internes en am√©liorant l'analyse du vectoriseur et de l'alias.  Aucune des clauses SIMD n'est effective dans Visual Studio 2019 au moment de la r√©daction de cet article.  Ils seront analys√©s mais ignor√©s par le compilateur avec un avertissement √©mis pour la sensibilisation de l'utilisateur.  Par exemple, le compilateur √©mettra </p><br><p>  avertissement C4849: clause "simdlen" d'OpenMP ignor√©e dans la directive "simd" </p><br><p>  pour le code suivant: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd simdlen(8) for (i = 1; i &lt; count; i++) { a[i] = a[i-1] + 1; b[i] = *c + 1; bar(i); }</span></span></code> </pre> <br><h3>  En savoir plus sur la s√©mantique de la directive OpenMP SIMD </h3><br><p>  La directive OpenMP SIMD fournit aux utilisateurs un moyen de dicter au compilateur de vectoriser une boucle.  Le compilateur est autoris√© √† ignorer la l√©galit√© apparente d'une telle vectorisation en acceptant la promesse d'exactitude des utilisateurs.  Il incombe aux utilisateurs lorsqu'un comportement inattendu se produit avec la vectorisation.  En annotant une boucle avec la directive OpenMP SIMD, les utilisateurs ont l'intention d'ex√©cuter plusieurs it√©rations de boucle simultan√©ment.  Cela donne au compilateur beaucoup de libert√© pour g√©n√©rer du code machine qui tire parti des ressources SIMD ou vectorielles sur le processeur cible.  Bien que le compilateur ne soit pas responsable de l'exploration de l'exactitude et du profit d'un tel parall√©lisme sp√©cifi√© par l'utilisateur, il <strong>doit</strong> toujours garantir le comportement s√©quentiel d'une it√©ration √† boucle unique. </p><br><p>  Par exemple, la boucle suivante est annot√©e avec la directive OpenMP SIMD.  Il n'y a pas de parall√©lisme parfait entre les it√©rations de boucle car il y a une d√©pendance en arri√®re d'un [i] √† un [i-1].  Mais en raison de la directive SIMD, le compilateur est toujours autoris√© √† regrouper les it√©rations cons√©cutives de la premi√®re instruction dans une instruction vectorielle et √† les ex√©cuter en parall√®le. </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 1; i &lt; count; i++) { a[i] = a[i-1] + 1; b[i] = *c + 1; bar(i); }</span></span></code> </pre> <br><p>  Par cons√©quent, la forme vectorielle transform√©e suivante de la boucle est <strong>l√©gale</strong> car le compilateur conserve le comportement s√©quentiel de chaque it√©ration de boucle d'origine.  En d'autres termes, a [i] est ex√©cut√© apr√®s a [-1], b [i] est apr√®s a [i] et l'appel √† la barre se produit enfin. </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 1; i &lt; count; i+=4) { a[i:i+3] = a[i-1:i+2] + 1; b[i:i+3] = *c + 1; bar(i); bar(i+1); bar(i+2); bar(i+3); }</span></span></code> </pre> <br><p>  Il est interdit de d√©placer la r√©f√©rence de m√©moire <em>* c</em> hors de la boucle si elle peut alias avec <em>a [i]</em> ou <em>b [i]</em> .  Il est √©galement ill√©gal de r√©organiser les instructions dans une seule it√©ration d'origine si elle rompt la d√©pendance s√©quentielle.  Par exemple, la boucle transform√©e suivante n'est <strong>pas</strong> l√©gale. </p><br><pre> <code class="cs hljs">c = b; t = *c; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 1; i &lt; count; i+=4) { a[i:i+3] = a[i-1:i+2] + 1; bar(i); // illegal to reorder </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> bar[i] depends on b[i] b[i:i+3] = t + 1; // illegal to move *c out of the loop bar(i+1); bar(i+2); bar(i+3); }</span></span></code> </pre> <br><h3>  Plans futurs et r√©troaction </h3><br><p>  Nous vous encourageons √† essayer cette nouvelle fonctionnalit√©.  Comme toujours, nous appr√©cions vos commentaires.  Si vous voyez une boucle OpenMP SIMD que vous pr√©voyez d'√™tre vectoris√©e, mais pas ou si le code g√©n√©r√© n'est pas optimal, veuillez nous le faire savoir.  Nous pouvons √™tre contact√©s via les commentaires ci-dessous, par e-mail ( <a href="">visualcpp@microsoft.com</a> ), twitter (@visualc) ou via la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communaut√© des d√©veloppeurs</a> . </p><br><p>  √Ä l'avenir, nous aimerions conna√Ætre votre besoin de fonctionnalit√©s OpenMP manquantes dans Visual Studio.  Comme il y a eu plusieurs √©volutions majeures dans OpenMP depuis la norme 2.0, OpenMP a maintenant des fonctionnalit√©s √©normes pour faciliter vos efforts pour cr√©er des programmes hautes performances.  Par exemple, la programmation simultan√©e bas√©e sur les t√¢ches est disponible √† partir d'OpenMP 3.0.  L'informatique h√©t√©rog√®ne (CPU + acc√©l√©rateurs) est prise en charge dans OpenMP 4.0.  La vectorisation SIMD avanc√©e et la prise en charge de la parall√©lisation de boucle DOACROSS sont √©galement disponibles dans la derni√®re norme OpenMP.  Veuillez consulter les r√©visions standard compl√®tes et les jeux de fonctionnalit√©s sur le site officiel d'OpenMP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.openmp.org</a> .  Nous vous demandons sinc√®rement votre avis sur les fonctionnalit√©s OpenMP sp√©cifiques que vous aimeriez voir.  Nous aimerions √©galement savoir comment vous utilisez OpenMP pour acc√©l√©rer votre code.  Vos commentaires sont essentiels car ils aideront √† orienter la prise en charge d'OpenMP dans Visual Studio. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/a43/b5a/f42a43b5aa8fbbbee8c5c57453dcf1ed.jpg" alt="Avatar" width="96" height="96"><br><h5>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hongtao Yu</a> </h5></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446688/">https://habr.com/ru/post/fr446688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446674/index.html">Nous mod√©lisons l'algorithme MUSIC pour d√©terminer la direction d'arriv√©e d'une onde √©lectromagn√©tique</a></li>
<li><a href="../fr446676/index.html">Cr√©ation de touches manquantes pour le clavier en caoutchouc Commodore 116</a></li>
<li><a href="../fr446678/index.html">Live Battle: Porto ICPC Finals</a></li>
<li><a href="../fr446680/index.html">Le principal instinct de l'encodeur est d'√©liminer les solutions inefficaces de partout</a></li>
<li><a href="../fr446682/index.html">Acc√©l√©rer WebGL / Three.js avec OffscreenCanvas et Web Workers</a></li>
<li><a href="../fr446690/index.html">Electrolux lance un purificateur d'air intelligent pour les villes les plus pollu√©es</a></li>
<li><a href="../fr446694/index.html">Stockage modulaire JBOD et degr√©s de libert√©</a></li>
<li><a href="../fr446696/index.html">Mythes sur 152-FZ, ce qui peut co√ªter cher √† l'op√©rateur de donn√©es personnelles</a></li>
<li><a href="../fr446700/index.html">Lazydocker - GUI pour Docker directement dans le terminal</a></li>
<li><a href="../fr446702/index.html">Et un autre casque bizarre - pour dormir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>