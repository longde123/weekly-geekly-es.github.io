<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏿 🚶🏾 🎅 Tulis kode yang mudah dihapus dan didebug 🧒🏼 🌭 👨🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kode yang mudah di-debug adalah kode yang tidak menipu Anda. Lebih sulit untuk men-debug kode dengan perilaku tersembunyi, dengan penanganan kesalahan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tulis kode yang mudah dihapus dan didebug</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412693/"><img src="https://habrastorage.org/webt/zf/0a/g4/zf0ag4yxvf4vsw9xoftd_acnr38.png"><br><br>  Kode yang mudah di-debug adalah kode yang tidak menipu Anda.  Lebih sulit untuk men-debug kode dengan perilaku tersembunyi, dengan penanganan kesalahan yang buruk, dengan ketidakpastian, terstruktur tidak memadai atau berlebihan, atau dalam proses perubahan.  Dalam proyek yang cukup besar, Anda berakhir dengan kode yang tidak dapat Anda mengerti. <br><br>  Jika proyek ini relatif lama, maka Anda mungkin menemukan kode yang Anda lupa sama sekali, dan jika itu bukan untuk log komit, Anda akan bersumpah bahwa baris ini tidak ditulis oleh Anda.  Seiring pertumbuhan proyek, menjadi semakin sulit untuk mengingat apa yang dilakukan oleh berbagai kode.  Dan situasinya diperburuk jika kode tidak melakukan apa yang tampaknya dilakukan.  Dan ketika Anda perlu mengubah kode yang tidak Anda mengerti, Anda harus mengetahuinya dengan keras: debug. <br><br>  Kemampuan menulis kode yang mudah di-debug dimulai dengan pemahaman bahwa Anda tidak mengingat apa pun yang ditulis sebelumnya. <br><a name="habracut"></a><br><h2>  Aturan 0: Kode yang baik mengandung kesalahan yang jelas. </h2><br>  Vendor teknologi yang banyak digunakan mengklaim bahwa "tulis kode yang jelas" berarti "tulis kode yang bersih."  Masalahnya adalah bahwa tingkat “kemurnian” sangat peka konteks.  Kode murni dapat di-hardcode dalam sistem, dan kadang-kadang beberapa hack kotor ditulis sehingga mudah untuk menonaktifkannya.  Terkadang kode dianggap bersih, karena semua kotoran didorong ke suatu tempat.  Kode yang baik belum tentu bersih. <br><br>  Kebersihan mencirikan tingkat kebanggaan (atau rasa malu) yang dialami pengembang sehubungan dengan kode ini, bukan kemudahan pemeliharaan atau perubahan.  Lebih baik memberi kita kode membosankan daripada yang bersih, perubahan yang jelas: saya menemukan bahwa orang lebih bersedia untuk memodifikasi basis kode jika buah hang cukup rendah dan mudah dipetik.  Kode terbaik mungkin adalah kode yang baru saja Anda lihat dan segera mengerti cara kerjanya. <br><br><ul><li>  Kode yang tidak mencoba membuat masalah jelek agar terlihat bagus, atau masalah yang membosankan terlihat menarik. </li><li>  Kode di mana kesalahannya jelas dan perilakunya jelas, tidak seperti kode tanpa kesalahan yang jelas dan dengan perilaku tidak jelas. </li><li>  Kode di mana itu didokumentasikan di mana itu tidak ideal, berbeda dengan kode yang berusaha untuk kesempurnaan. </li><li>  Kode dengan perilaku yang sangat jelas sehingga pengembang mana pun dapat menemukan segudang cara berbeda untuk mengubah kode ini. </li></ul><br>  Kadang-kadang kode itu sangat jahat sehingga setiap upaya untuk membuatnya lebih bersih hanya memperburuk situasi.  Menulis kode tanpa memahami konsekuensi dari tindakan mereka juga dapat dianggap sebagai ritual penerapan kode yang dikelola dengan mudah. <br><br>  Saya tidak ingin mengatakan bahwa kode bersih itu buruk, tetapi terkadang keinginan untuk kebersihan lebih terlihat seperti menyapu sampah di bawah permadani.  Kode debug belum tentu bersih;  dan kode yang penuh dengan pemeriksaan atau penanganan kesalahan jarang terbaca. <br><br><h2>  Aturan 1: Selalu ada masalah di komputer </h2><br>  Komputer memiliki masalah dan program macet selama menjalankan terakhir. <br><br>  Aplikasi pertama-tama harus memastikan bahwa itu dimulai dari kondisi yang diketahui, baik, aman sebelum mencoba melakukan sesuatu.  Terkadang tidak ada salinan negara, karena pengguna menghapusnya atau memutakhirkan komputer.  Program macet selama menjalankan terakhir dan, paradoksnya, selama menjalankan pertama juga. <br><br>  Misalnya, saat membaca atau menulis status ke file, masalah berikut mungkin terjadi: <br><br><ul><li>  File tidak ada. </li><li>  File tersebut rusak. </li><li>  File versi yang lebih lama, atau lebih baru. </li><li>  Perubahan terakhir ke file belum selesai. </li><li>  Sistem file berbohong kepada Anda. </li></ul><br>  Masalah-masalah ini bukanlah hal baru, basis data telah menjumpai mereka sejak zaman kuno (1970-01-01).  Menggunakan sesuatu seperti SQLite akan membantu mengatasi banyak masalah serupa, tetapi jika program macet pada eksekusi terakhir, maka kode dapat bekerja dengan data yang salah dan / atau dengan cara yang salah. <br><br>  Misalnya, dengan program terjadwal, sesuatu dari daftar ini akan terjadi: <br><br><ul><li>  Program ini akan mulai dua kali dalam satu jam karena waktu musim panas. </li><li>  Program akan mulai dua kali karena operator lupa bahwa itu sudah berjalan. </li><li>  Program akan mulai terlambat karena kehabisan ruang disk kosong atau masalah jaringan atau cloud yang misterius. </li><li>  Program akan berjalan selama lebih dari satu jam, yang dapat menyebabkan penundaan panggilan berikutnya ke program. </li><li>  Program akan dimulai pada waktu yang salah. </li><li>  Program ini pasti akan dijalankan sesaat sebelum batas waktu, misalnya, tengah malam, akhir bulan atau tahun, dan akan gagal karena kesalahan komputasi. </li></ul><br>  Membuat perangkat lunak berkelanjutan dimulai dengan menulis perangkat lunak yang menurutnya telah jatuh sebelumnya, dan macet jika Anda tidak tahu harus berbuat apa.  Hal terbaik tentang melempar pengecualian dan meninggalkan komentar dengan gaya "ini seharusnya tidak terjadi" adalah ketika hal ini pasti terjadi, Anda akan memiliki kepala mulai men-debug kode Anda. <br><br>  Program ini bahkan tidak diwajibkan untuk pulih dari kegagalan, cukup untuk membiarkannya menyerah dan tidak memperburuk situasi.  Pemeriksaan kecil yang menghasilkan pengecualian dapat menghemat berminggu-minggu dalam pengintaian, dan file kunci sederhana dapat menghemat waktu pemulihan dari cadangan. <br><br>  Kode yang mudah di-debug adalah: <br><br><ul><li>  kode yang memeriksa untuk melihat apakah semuanya baik-baik saja sebelum melakukan apa yang mereka minta; </li><li>  kode yang membuatnya mudah untuk kembali ke keadaan terkenal dan coba lagi; </li><li>  serta kode dengan tingkat keamanan yang menyebabkan kesalahan terjadi sedini mungkin. </li></ul><br><h2>  Aturan 2: Program Anda bertarung dengan dirinya sendiri </h2><br><blockquote>  <i>Serangan DoS terbesar dalam sejarah Google berasal dari diri kita sendiri (karena sistem kami sangat besar).</i>  <i>Meskipun dari waktu ke waktu seseorang mencoba menguji kekuatan kita, tetapi kita tetap bisa melukai diri kita sendiri lebih dari orang lain.</i> <i><br><br></i>  <i>Ini berlaku untuk semua sistem kami.</i> <br><br>  Astrid Atkinson, Long Game Engineer <br></blockquote><br>  Program selalu macet selama menjalankan terakhir, selalu ada tidak cukup prosesor, memori, atau ruang disk.  Semua pekerja memalu antrian yang kosong, semua orang mencoba mengulangi permintaan yang gagal dan lama, dan semua server pada saat yang sama berhenti selama pengumpulan sampah.  Sistem tidak hanya rusak, tetapi terus-menerus mencoba untuk merusak dirinya sendiri. <br><br>  Kesulitan besar dapat menyebabkan bahkan memeriksa sistem. <br><br>  Menerapkan pemeriksaan operasi server bisa mudah, tetapi hanya jika tidak memproses permintaan.  Jika Anda tidak memeriksa durasi waktu aktif terus-menerus, maka ada kemungkinan bahwa program tersebut jatuh di antara pemeriksaan.  Bug juga dapat dipicu oleh pemeriksaan kesehatan: Saya harus menulis cek yang menyebabkan crash sistem, yang harus mereka lindungi.  Dua kali, dengan perbedaan tiga bulan. <br><br>  Kode penanganan kesalahan pasti akan mengarah pada penemuan lebih banyak kesalahan yang perlu diproses, banyak di antaranya muncul dari penanganan kesalahan itu sendiri.  Demikian pula, optimalisasi kinerja sering menjadi penyebab kemacetan dalam sistem.  Aplikasi yang bagus untuk digunakan dalam satu tab berubah menjadi masalah, diluncurkan dalam 20 salinan. <br><br>  Contoh lain: seorang pekerja di sebuah pipa berjalan terlalu cepat dan mengkonsumsi memori yang tersedia sebelum bagian selanjutnya dari pipa itu mengaksesnya.  Ini dapat dibandingkan dengan kemacetan lalu lintas: kemacetan terjadi karena peningkatan kecepatan, dan akibatnya, kemacetan lalu lintas tumbuh ke arah yang berlawanan.  Jadi optimisasi dapat menghasilkan sistem yang jatuh di bawah beban tinggi atau berat, seringkali dalam beberapa cara misterius. <br>  Dengan kata lain: semakin cepat sistem, semakin kuat tekanan di atasnya, dan jika Anda tidak membiarkan sistem sedikit menangkal, maka jangan kaget jika retak. <br><br>  Counteraction adalah salah satu bentuk umpan balik dari sistem.  Program, yang mudah di-debug, melibatkan pengguna dalam lingkaran umpan balik, memungkinkan Anda untuk melihat semua perilaku di dalam sistem, acak, disengaja, diinginkan dan tidak diinginkan.  Anda dapat dengan mudah memeriksa kode tersebut, melihat dan memahami perubahan yang terjadi dengannya. <br><br><h2>  Aturan 3: Jika Anda meninggalkan sesuatu yang ambigu sekarang, Anda harus men-debugnya nanti </h2><br>  Dengan kata lain, seharusnya mudah bagi Anda untuk melacak variabel dalam program dan memahami apa yang terjadi.  Ambil rutinitas apa pun dengan aljabar linear mimpi buruk, Anda harus berusaha menyajikan kondisi program sejelas mungkin.  Ini berarti bahwa di tengah suatu program Anda tidak dapat mengubah tujuan suatu variabel, karena menggunakan satu variabel untuk dua tujuan berbeda adalah dosa yang mematikan. <br><br>  Ini juga berarti bahwa Anda harus menghindari masalah semi-predikat dengan hati-hati, jangan pernah menggunakan nilai tunggal ( <code>count</code> ) untuk mewakili sepasang nilai ( <code>boolean</code> , <code>count</code> ).  Penting untuk menghindari mengembalikan angka positif untuk hasil dan pada saat yang sama mengembalikan <code>-1</code> jika tidak ada yang cocok.  Faktanya adalah bahwa Anda dapat dengan mudah menemukan diri Anda dalam situasi di mana Anda memerlukan sesuatu seperti " <code>0, but true</code> " (dan inilah fitur di Perl 5);  atau ketika Anda membuat kode yang sulit untuk digabungkan dengan bagian lain dari sistem ( <code>-1</code> untuk bagian selanjutnya dari program ini mungkin bukan kesalahan, tetapi nilai input yang valid). <br><br>  Selain menggunakan satu variabel untuk dua tujuan, tidak disarankan untuk menggunakan dua variabel untuk tujuan yang sama, terutama jika itu adalah Boolean.  Saya tidak bermaksud mengatakan bahwa menggunakan dua angka untuk menyimpan rentang adalah hal yang buruk, tetapi menggunakan angka Boolean untuk menunjukkan status suatu program seringkali merupakan mesin keadaan bertopeng. <br><br>  Ketika suatu negara tidak lulus dari atas ke bawah, yaitu, dalam kasus siklus episodik, yang terbaik adalah memberikan keadaan dengan variabel sendiri dan menghapus logika.  Jika Anda memiliki sekumpulan boolean di dalam objek, gantilah dengan variabel yang disebut <code>state</code> dan gunakan enum (atau string jika perlu di suatu tempat).  <code>if</code> ekspresi akan terlihat seperti <code>if state == name</code> , bukan <code>if bad_name &amp;&amp; !alternate_option</code> . <br><br>  Bahkan jika Anda membuat mesin keadaan eksplisit, ada kemungkinan untuk membingungkan: kadang-kadang kode dapat memiliki dua mesin keadaan tersembunyi di dalamnya.  Setelah saya disiksa untuk menulis proksi HTTP, sampai saya membuat setiap mesin eksplisit, melacak status koneksi dan menguraikannya secara terpisah.  Saat Anda menggabungkan dua mesin keadaan menjadi satu, mungkin sulit untuk menambahkan keadaan baru atau untuk memahami persis keadaan apa yang seharusnya dimiliki sesuatu. <br><br>  Ini lebih tentang membuat kode yang tidak harus di-debug daripada tentang debugging yang mudah.  Jika Anda mengembangkan daftar status yang benar, akan jauh lebih mudah untuk membuang yang salah tanpa kehilangan satu atau dua. <br><br><h2>  Aturan 4: Perilaku acak adalah perilaku yang diharapkan. </h2><br>  Saat Anda tidak memahami apa yang dilakukan struktur data, kesenjangan pengetahuan ini diisi oleh pengguna: perilaku apa pun dari kode, disengaja atau tidak disengaja, pada akhirnya akan bergantung pada sesuatu.  Banyak bahasa pemrograman populer mendukung tabel hash yang dapat diulang, dan yang dalam kebanyakan kasus mempertahankan ketertiban setelah penyisipan. <br><br>  Dalam beberapa bahasa, perilaku tabel hash memenuhi harapan sebagian besar pengguna, mengulangi kunci dalam urutan mereka ditambahkan.  Dalam bahasa lain, tabel hash di setiap iterasi mengembalikan kunci dalam urutan yang berbeda.  Dalam hal ini, beberapa pengguna mengeluh bahwa perilakunya <b>tidak cukup</b> acak. <br><br>  Sayangnya, semua sumber keacakan dalam program Anda pada akhirnya akan digunakan untuk simulasi statistik, atau lebih buruk lagi - kriptografi;  dan sumber penyortiran apa pun akan digunakan untuk menyortir. <br><br>  Dalam database, beberapa pengidentifikasi mengandung sedikit informasi lebih banyak daripada yang lain.  Dengan membuat tabel, pengembang dapat memilih antara berbagai jenis kunci utama.  Pilihan yang tepat adalah UUID, atau sesuatu yang tidak bisa dibedakan darinya.  Kerugian dari opsi lain adalah mereka dapat mengungkapkan informasi pemesanan dan identifikasi.  Artinya, bukan hanya <code>a == b</code> , tetapi <code>a &lt;= b</code> , dan opsi lainnya berarti kunci kenaikan otomatis. <br><br>  Saat menggunakan kunci kenaikan otomatis, basis data memberikan nomor untuk setiap baris dalam tabel, menambahkan 1 saat memasukkan baris baru.  Dan pengurutan tidak jelas: orang tidak tahu bagian mana dari data yang kanonik.  Dengan kata lain, apakah Anda mengurutkan berdasarkan kunci atau cap waktu?  Seperti halnya tabel hash, orang itu sendiri akan memilih jawaban yang tepat.  Dan masalah lain adalah bahwa pengguna dapat dengan mudah memprediksi catatan tetangga dengan kunci lain. <br><br>  Tetapi setiap upaya untuk mengecoh UUID akan gagal: kami telah mencoba menggunakan kode pos, nomor telepon dan alamat IP, dan setiap kali gagal total.  UUID mungkin tidak membuat kode Anda lebih mudah di-debug, tetapi perilaku acak yang lebih sedikit berarti lebih sedikit masalah. <br><br>  Dari tombol Anda dapat mengekstrak informasi tidak hanya tentang pemesanan.  Jika dalam database Anda membuat kunci berdasarkan bidang lain, maka orang akan membuang data dan mengembalikannya dari kunci.  Dan dua masalah akan muncul: ketika keadaan program disimpan di beberapa tempat, akan sangat mudah bagi salinan untuk saling tidak setuju;  dan menyinkronkannya akan lebih sulit jika Anda tidak yakin yang mana yang perlu diubah atau mana yang telah diubah. <br><br>  Apa pun yang Anda izinkan pengguna Anda lakukan, mereka akan melakukannya.  Menulis kode yang mudah di-debug berarti memikirkan cara untuk menyalahgunakannya, serta bagaimana orang dapat berinteraksi dengannya secara umum. <br><br><h2>  Aturan 5: Debugging adalah tugas sosial, pertama-tama, tugas teknis. </h2><br>  Ketika sebuah proyek dibagi menjadi beberapa komponen dan sistem, mungkin akan lebih sulit untuk menemukan bug.  Dengan memahami bagaimana masalah muncul, Anda dapat mengoordinasikan perubahan di berbagai bagian untuk memperbaiki perilaku.  Memperbaiki bug dalam proyek-proyek besar tidak memerlukan begitu banyak menemukan mereka sebagai meyakinkan orang tentang keberadaan bug ini, atau kemungkinan sangat adanya. <br>  Ada bug dalam perangkat lunak, karena tidak ada yang benar-benar yakin siapa yang bertanggung jawab untuk apa.  Artinya, lebih sulit untuk men-debug kode ketika tidak ada yang ditulis, Anda harus bertanya tentang segala sesuatu di Slack, dan tidak ada yang menjawab sampai seorang pakar datang. <br><br>  Ini dapat diperbaiki dengan perencanaan, alat, proses, dan dokumentasi. <br><br>  Perencanaan adalah cara untuk menghilangkan tekanan untuk tetap berhubungan, struktur manajemen insiden.  Paket ini memungkinkan Anda untuk memberi tahu pembeli, membebaskan orang-orang yang telah berhubungan terlalu lama, dan juga melacak masalah dan membuat perubahan untuk mengurangi risiko di masa depan.  Alat - cara untuk mengurangi persyaratan untuk melakukan beberapa pekerjaan, sehingga menjadi lebih mudah diakses oleh pengembang lain.  Proses ini adalah cara menghilangkan fungsi manajemen dari masing-masing peserta dan mentransfer ke tim. <br><br>  Orang dan cara interaksi akan berubah, tetapi proses dan alat akan tetap ada saat tim bertransformasi.  Bukannya yang satu lebih penting dari yang lain, tetapi yang satu dirancang untuk mendukung perubahan yang lain.  Proses ini juga dapat digunakan untuk menghapus fungsi kontrol dari tim.  Ini tidak selalu baik atau buruk, tetapi selalu <b>ada semacam</b> proses, bahkan jika tidak dijabarkan.  Dan tindakan mendokumentasikannya adalah langkah pertama untuk membiarkan orang lain mengubah proses ini. <br><br>  Dokumentasi lebih dari sekadar file teks.  Ini adalah cara mentransfer tanggung jawab, bagaimana Anda membawa orang ke tempat kerja, bagaimana Anda melaporkan perubahan kepada mereka yang terpengaruh oleh perubahan ini.  Dokumentasi menulis membutuhkan lebih banyak empati daripada saat menulis kode, dan lebih banyak keterampilan: tidak ada flag kompiler sederhana atau jenis cek, dan Anda dapat dengan mudah menulis banyak kata tanpa mendokumentasikan apa pun. <br><br>  Tanpa dokumentasi, seseorang tidak dapat mengharapkan orang lain untuk membuat keputusan berdasarkan informasi, atau bahkan setuju dengan konsekuensi dari penggunaan perangkat lunak.  Tanpa dokumentasi, alat atau proses, tidak mungkin berbagi beban pemeliharaan atau setidaknya mengganti orang-orang yang sekarang memecahkan masalah. <br><br>  Keinginan untuk memfasilitasi debugging tidak hanya berlaku untuk kode itu sendiri, tetapi juga untuk proses yang berhubungan dengan kode, ini membantu untuk memahami kulit siapa yang Anda butuhkan untuk memperbaiki kode. <br><br><h2>  Kode yang mudah di-debug mudah dijelaskan. </h2><br>  Ada pendapat bahwa jika Anda menjelaskan masalah kepada seseorang selama debugging, maka Anda sendiri yang memahaminya.  Untuk ini, Anda bahkan tidak perlu orang lain, yang terpenting adalah memaksa diri Anda untuk menjelaskan situasi dari awal, untuk menjelaskan urutan pemutaran.  Dan seringkali ini cukup untuk mengambil keputusan yang tepat. <br><br>  Kalau saja.  Terkadang, ketika kita meminta bantuan, kita tidak bertanya apa yang dibutuhkan.  Ini sangat umum sehingga disebut Masalah XY: “ <i>Bagaimana saya mendapatkan tiga huruf terakhir dari nama file?</i>  <i>Hah?</i>  <i>Tidak, maksudku ekspansi</i> . ” <br><br>  Kami berbicara tentang masalah dalam hal solusi yang kami pahami, dan kami berbicara tentang solusi dalam hal konsekuensi yang kami takuti.  Debugging adalah pemahaman yang sulit tentang konsekuensi yang tak terduga dan solusi alternatif, itu membutuhkan yang paling sulit bagi seorang programmer: untuk mengakui bahwa ia memahami sesuatu yang salah. <br><br>  Ternyata ini bukan kesalahan kompiler. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412693/">https://habr.com/ru/post/id412693/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412683/index.html">Di mana dan bagaimana cara belajar mesin?</a></li>
<li><a href="../id412685/index.html">Unity GPU Path Tracing - Bagian 2</a></li>
<li><a href="../id412687/index.html">Terapkan IdM. Prosedur dan sarana teknis - dari dasar hingga IdM</a></li>
<li><a href="../id412689/index.html">Analitik TI prediktif merampingkan pemantauan aplikasi terdistribusi</a></li>
<li><a href="../id412691/index.html">Lelucon 5 tahun di Facebook atau sejarah forensik</a></li>
<li><a href="../id412695/index.html">Gambaran keseluruhan pengujian unit</a></li>
<li><a href="../id412697/index.html">IoT sebagai bidang studi universal untuk universitas teknis multidisiplin</a></li>
<li><a href="../id412699/index.html">Penjelasan sederhana tentang prinsip-prinsip SOLID</a></li>
<li><a href="../id412701/index.html">Pemanas paling cerdas</a></li>
<li><a href="../id412703/index.html">Pada konferensi dengan Veeam: ulasan tentang VeeamON 2018 dan undangan untuk Forum VeeamON di Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>