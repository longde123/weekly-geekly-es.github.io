<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå† üë®‚ÄçüöÄ ü•ê Guide SQL: comment mieux √©crire des requ√™tes (partie 2) ü¶Ö üòó üÖ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article suivant Guide SQL: comment mieux √©crire des requ√™tes (partie 1) 

 De la demande aux plans d'ex√©cution 
 Sachant que les antipatterns ne sont ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide SQL: comment mieux √©crire des requ√™tes (partie 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/">  Article suivant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide SQL: comment mieux √©crire des requ√™tes (partie 1)</a> <br><br><h2>  De la demande aux plans d'ex√©cution </h2><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Sachant que les antipatterns ne sont pas statiques et √©voluent au fur et √† mesure que vous grandissez en tant que d√©veloppeur SQL, et le fait qu'il y a beaucoup de choses √† consid√©rer lorsque vous pensez √† des alternatives signifie √©galement qu'il est assez difficile d'√©viter les antipatterns et les requ√™tes de r√©√©criture t√¢che.  Toute aide peut √™tre utile, c'est pourquoi une approche plus structur√©e de l'optimisation des requ√™tes √† l'aide de certains outils peut √™tre la plus efficace. <br><br>  Il convient √©galement de noter que certains des anti-mod√®les mentionn√©s dans la derni√®re section sont enracin√©s dans des probl√®mes de performances, tels que les op√©rateurs <code>AND</code> , <code>OR</code> et <code>NOT</code> et leur absence lors de l'utilisation des index.  Penser √† la performance n√©cessite non seulement une approche plus structur√©e, mais aussi plus profonde. <br><br>  Cependant, cette approche structur√©e et approfondie sera principalement bas√©e sur le plan de requ√™te, qui, comme vous vous en souvenez, est le r√©sultat d'une requ√™te d'abord analys√©e dans un "arbre d'analyse" ou "arbre d'analyse" et d√©termine exactement quel algorithme utilis√© pour chaque op√©ration et comment leur ex√©cution est coordonn√©e. <br><a name="habracut"></a><br><h2>  Optimisation des requ√™tes </h2><br>  Comme vous le lisez dans l'introduction, vous devrez peut-√™tre v√©rifier et configurer des plans qui sont compil√©s manuellement par l'optimiseur.  Dans de tels cas, vous devrez analyser √† nouveau votre demande en consultant le plan de demande. <br><br>  Pour acc√©der √† ce plan, vous devez utiliser les outils fournis par le syst√®me de gestion de base de donn√©es.  Les outils suivants peuvent √™tre √† votre disposition: <br><br><ul><li>  Certains packages contiennent des outils qui g√©n√®rent une repr√©sentation graphique du plan de requ√™te.  Prenons l'exemple suivant: <br><br><img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br></li><li>  D'autres outils fourniront une description textuelle du plan de requ√™te.  Un exemple est l'instruction <code>EXPLAIN PLAN</code> dans Oracle, mais le nom de l'instruction d√©pend du SGBD avec lequel vous travaillez.  Ailleurs, vous pouvez trouver <code>EXPLAIN</code> (MySQL, PostgreSQL) ou <code>EXPLAIN QUERY PLAN</code> (SQLite). </li></ul><br>  <b>Veuillez noter</b> que lorsque vous travaillez avec PostgreSQL, vous pouvez faire une distinction entre <code>EXPLAIN</code> , o√π vous obtenez simplement une description qui indique comment le planificateur a l'intention d'ex√©cuter la requ√™te sans l'ex√©cuter, tandis <code>EXPLAIN ANALYZE</code> ex√©cute r√©ellement la requ√™te et vous renvoie l'analyse plans de demande attendus et r√©els.  De mani√®re g√©n√©rale, un v√©ritable plan d'ex√©cution est un plan dans lequel une demande est r√©ellement ex√©cut√©e, tandis qu'un plan d'ex√©cution d'√©valuation d√©termine ce qu'il fera sans r√©pondre √† la demande.  Bien que cela soit logiquement √©quivalent, le plan d'ex√©cution r√©el est beaucoup plus utile car il contient des informations et des statistiques suppl√©mentaires sur ce qui s'est r√©ellement pass√© lors de l'ex√©cution de la demande. <br><br>  Dans le reste de cette section, vous en apprendrez plus sur <code>EXPLAIN</code> et <code>ANALYZE</code> , ainsi que sur la fa√ßon de les utiliser pour obtenir plus d'informations sur le plan de requ√™te et ses performances possibles.  Pour ce faire, commencez par quelques exemples dans lesquels vous allez travailler avec deux tables: <code>one_million</code> et <code>half_million</code> . <br><br>  Vous pouvez obtenir les informations actuelles de la table <code>one_million</code> utilisant <code>EXPLAIN</code> ;  Assurez-vous de le placer directement au-dessus de la demande, et apr√®s l'avoir ex√©cut√©, il vous renverra le plan de requ√™te: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18584.82 rows=1025082 width=36) (1 row)</code> </pre> <br>  Dans ce cas, vous voyez que le co√ªt de la demande est <code>0.00..18584.82</code> et le nombre de lignes est <code>1025082</code> .  La largeur du nombre de colonnes est de <code>36</code> . <br><br>  De plus, vous pouvez mettre √† jour les statistiques √† l'aide d' <code>ANALYZE</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> one_million; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (1 row)</code> </pre> <br>  Outre <code>EXPLAIN</code> et <code>ANALYZE</code> , vous pouvez √©galement obtenir le temps d'ex√©cution r√©el avec <code>EXPLAIN ANALYZE</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ___________________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.015..1207.019 rows=1000000 loops=1) Total runtime: 2320.146 ms (2 rows)</code> </pre> <br>  L'inconv√©nient d'utiliser <code>EXPLAIN ANALYZE</code> est que la requ√™te est r√©ellement ex√©cut√©e, alors faites attention √† cela! <br><br>  Jusqu'√† pr√©sent, tous les algorithmes que vous avez vus sont le <code>Seq Scan</code> s√©quentiel ( <code>Seq Scan</code> s√©quentiel) ou le scan complet de la table: il s'agit d'un scan effectu√© dans une base de donn√©es o√π chaque ligne de la table scann√©e est lue dans l'ordre s√©rie et les colonnes trouv√©es sont v√©rifi√©es pour respect de la condition ou non.  En termes de performances, les analyses s√©quentielles ne sont certainement pas le meilleur plan d'ex√©cution car vous effectuez toujours une analyse compl√®te de la table.  Cependant, ce n'est pas si mal quand la table ne tient pas en m√©moire: les lectures s√©quentielles sont assez rapides m√™me sur des disques lents. <br><br>  Vous en apprendrez plus √† ce sujet plus tard lorsque nous parlerons de l'analyse d'index. <br><br>  Cependant, il existe d'autres algorithmes.  Prenons, par exemple, ce plan de requ√™te pour une connexion: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN _________________________________________________________________ Hash Join (cost=15417.00..68831.00 rows=500000 width=42) (actual time=1241.471..5912.553 rows=500000 loops=1) Hash Cond: (one_million.counter = half_million.counter) -&gt; Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.007..1254.027 rows=1000000 loops=1) -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5) (actual time=1241.251..1241.251 rows=500000 loops=1) Buckets: 4096 Batches: 16 Memory Usage: 770kB -&gt; Seq Scan on half_million (cost=0.00..7213.00 rows=500000 width=5) (actual time=0.008..601.128 rows=500000 loops=1) Total runtime: 6468.337 ms</code> </pre> <br>  Vous voyez que l'optimiseur de requ√™tes a choisi <code>Hash Join</code> here!  N'oubliez pas cette op√©ration, car vous en aurez besoin pour √©valuer la complexit√© temporelle de votre demande.  Pour l'instant, notez qu'il n'y a pas d'index dans <code>half_million.counter</code> , que nous ajoutons dans l'exemple suivant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> half_million(counter); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN ________________________________________________________________ <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.12</span></span>.<span class="hljs-number"><span class="hljs-number">.37650</span></span><span class="hljs-number"><span class="hljs-number">.65</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">42</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.033</span></span>.<span class="hljs-number"><span class="hljs-number">.3272</span></span><span class="hljs-number"><span class="hljs-number">.940</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> Cond: (one_million.counter = half_million.counter) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> one_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> one_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.32129</span></span><span class="hljs-number"><span class="hljs-number">.34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1000000</span></span> width=<span class="hljs-number"><span class="hljs-number">37</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.011</span></span>.<span class="hljs-number"><span class="hljs-number">.694</span></span><span class="hljs-number"><span class="hljs-number">.466</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500001</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> half_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> half_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.14120</span></span><span class="hljs-number"><span class="hljs-number">.29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">5</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.010</span></span>.<span class="hljs-number"><span class="hljs-number">.683</span></span><span class="hljs-number"><span class="hljs-number">.674</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Total runtime: <span class="hljs-number"><span class="hljs-number">3833.310</span></span> ms (<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>)</code> </pre> <br>  Vous voyez qu'en cr√©ant l'index, l'optimiseur de requ√™te a maintenant d√©cid√© d'utiliser la <code>Merge join</code> lors de l'analyse de l' <code>Index Scan</code> index. <br><br>  <b>Notez</b> la diff√©rence entre les analyses d'index et les analyses de table compl√®tes ou analyses s√©quentielles: la premi√®re, √©galement appel√©e ¬´analyses de table¬ª, analyse les donn√©es ou les pages d'index pour trouver les enregistrements correspondants, tandis que la seconde analyse chaque ligne de la table. <br><br>  Vous voyez que le temps d'ex√©cution global a diminu√© et que les performances devraient √™tre meilleures, mais il existe deux analyses d'index, ce qui rend la m√©moire plus importante ici, surtout si la table ne tient pas dedans.  Dans de tels cas, vous devez d'abord effectuer une analyse compl√®te de l'index, qui est effectu√©e √† l'aide de lectures s√©quentielles rapides et n'est pas un probl√®me, mais vous avez ensuite de nombreuses op√©rations de lecture al√©atoire pour s√©lectionner des lignes par valeur d'index.  Ce sont des op√©rations de lecture al√©atoire qui sont g√©n√©ralement plus lentes de plusieurs ordres de grandeur que les op√©rations s√©quentielles.  Dans ces cas, une analyse compl√®te de la table se produit en effet plus rapidement qu'une analyse compl√®te de l'index. <br><br>  <b>Astuce:</b> Si vous souhaitez en savoir plus sur EXPLAIN ou examiner des exemples plus en d√©tail, pensez √† lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Understanding Explain de</a> Guillaume Lelarge. <br><br><h2>  Complexit√© temporelle et Big O </h2><br>  Maintenant que vous avez bri√®vement examin√© le plan de requ√™te, vous pouvez commencer √† approfondir et √† r√©fl√©chir aux performances de mani√®re plus formelle en utilisant la th√©orie de la complexit√© de calcul.  Il s'agit d'un domaine de l'informatique th√©orique, qui, entre autres, se concentre sur la classification des probl√®mes de calcul en fonction de leur complexit√©;  Ces probl√®mes de calcul peuvent √™tre des algorithmes, mais aussi des requ√™tes. <br><br>  Cependant, pour les requ√™tes, elles ne sont pas n√©cessairement class√©es en fonction de leur complexit√©, mais plut√¥t en fonction du temps n√©cessaire pour les compl√©ter et obtenir des r√©sultats.  C'est ce qu'on appelle la complexit√© temporelle, et vous pouvez utiliser la grande notation O pour formuler ou mesurer ce type de complexit√©. <br><br>  Avec la d√©signation big O, vous exprimez le temps d'ex√©cution en termes de vitesse de croissance par rapport √† l'entr√©e, car l'entr√©e devient arbitrairement grande.  La grande notation O exclut les coefficients et les membres d'un ordre inf√©rieur, vous pouvez donc vous concentrer sur la partie importante du temps d'ex√©cution de votre requ√™te: son taux de croissance.  Lorsqu'ils sont exprim√©s de cette mani√®re, en rejetant les coefficients et les termes d'un ordre inf√©rieur, ils disent que la complexit√© temporelle est d√©crite asymptotiquement.  Cela signifie que la taille d'entr√©e va √† l'infini. <br><br>  Dans un langage de base de donn√©es, la complexit√© d√©termine le temps n√©cessaire pour terminer une requ√™te √† mesure que la taille des tables de donn√©es et donc la base de donn√©es grandit. <br><br>  <b>Veuillez noter</b> que la taille de votre base de donn√©es augmente non seulement √† cause de l'augmentation de la quantit√© de donn√©es dans les tables, mais le fait qu'il existe des index joue √©galement un r√¥le dans la taille. <br><br>  Estimation de la complexit√© temporelle de votre plan de requ√™te <br><br>  Comme vous l'avez vu pr√©c√©demment, le plan d'ex√©cution, entre autres, d√©termine quel algorithme est utilis√© pour chaque op√©ration, ce qui vous permet d'exprimer logiquement chaque temps d'ex√©cution de requ√™te en fonction de la taille de la table incluse dans le plan de requ√™te, appel√©e fonction de complexit√©.  En d'autres termes, vous pouvez utiliser la notation O et le plan d'ex√©cution pour √©valuer la complexit√© et les performances des requ√™tes. <br><br>  Dans les sections suivantes, vous obtiendrez un aper√ßu des quatre types de complexit√© temporelle et vous verrez quelques exemples de la fa√ßon dont la complexit√© temporelle des requ√™tes peut varier en fonction du contexte dans lequel elle est ex√©cut√©e. <br><br>  Astuce: les index font partie de cette histoire! <br><br>  <b>Cependant, il convient de noter</b> qu'il existe diff√©rents types d'index, diff√©rents plans d'ex√©cution et diff√©rentes impl√©mentations pour diff√©rentes bases de donn√©es, de sorte que les difficult√©s temporaires r√©pertori√©es ci-dessous sont tr√®s g√©n√©rales et peuvent varier en fonction de param√®tres sp√©cifiques. <br><br><h3>  O (1): Temps constant </h3><br>  Ils disent qu'un algorithme fonctionne en temps constant s'il a besoin du m√™me temps quelle que soit la taille des donn√©es d'entr√©e.  Quand il s'agit d'une requ√™te, elle sera ex√©cut√©e en temps constant si le m√™me temps est requis quelle que soit la taille de la table. <br><br>  Ce type de requ√™te n'est pas vraiment courant, mais en voici un exemple: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> t.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t</code> </pre> <br>  La complexit√© temporelle est constante, car une ligne arbitraire est s√©lectionn√©e dans le tableau.  Par cons√©quent, la dur√©e ne doit pas d√©pendre de la taille de la table. <br><br><h3>  Temps lin√©aire: O (n) </h3><br>  Ils disent que l'algorithme fonctionne en temps lin√©aire, si son temps d'ex√©cution est directement proportionnel √† la taille des donn√©es d'entr√©e, c'est-√†-dire que le temps augmente lin√©airement avec la taille des donn√©es d'entr√©e.  Pour les bases de donn√©es, cela signifie que le temps d'ex√©cution sera directement proportionnel √† la taille de la table: √† mesure que le nombre de lignes de la table augmente, le temps d'ex√©cution de la requ√™te augmente. <br><br>  Un exemple est une requ√™te avec une <code>WHERE</code> pour une colonne non index√©e: une analyse compl√®te de la table ou une analyse <code>Seq Scan</code> sera n√©cessaire, ce qui entra√Ænera une complexit√© temporelle O (n).  Cela signifie que chaque ligne doit √™tre lue afin de trouver la ligne avec l'identifiant (ID) souhait√©.  Vous n'avez aucune restriction, vous devez donc compter chaque ligne, m√™me si la premi√®re ligne correspond √† la condition. <br><br>  Consid√©rez √©galement l'exemple de requ√™te suivant, qui aura une complexit√© O (n) s'il n'y a pas d'index sur le champ <code>i_id</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item;</code> </pre> <br><ul><li>  Ce qui pr√©c√®de signifie √©galement que d'autres requ√™tes, telles que des requ√™tes pour calculer le nombre de lignes <code>COUNT (*) FROM TABLE;</code>  aura une complexit√© temporelle <i>O (n)</i> , car une analyse compl√®te de la table sera n√©cessaire car le nombre total de lignes n'a pas √©t√© enregistr√© pour la table.  Sinon, la complexit√© temporelle serait similaire √† <i>O (1)</i> . <br></li></ul><br>  Le runtime lin√©aire est √©troitement li√© au runtime des plans qui ont des jointures de table.  Voici quelques exemples: <br><br><ul><li>  La jointure de hachage a la complexit√© attendue de O (M + N). L'algorithme de jointure de hachage classique pour joindre en interne deux tables pr√©pare d'abord la table de hachage de la plus petite table.  Les entr√©es de la table de hachage se composent d'un attribut de connexion et de sa cha√Æne.  La table de hachage est accessible en appliquant la fonction de hachage √† l'attribut de connexion.  Une fois la table de hachage cr√©√©e, une grande table est analys√©e et les lignes correspondantes de la petite table sont trouv√©es en recherchant la table de hachage. </li><li>  Les jointures de fusion ont g√©n√©ralement une complexit√© O (M + N), mais cela d√©pendra fortement des index de colonne de jointure et, s'il n'y a pas d'index, du tri des lignes en fonction des cl√©s utilis√©es dans la jointure: <ul><li>  Si les deux tables sont tri√©es en fonction des cl√©s utilis√©es dans la jointure, la requ√™te aura une complexit√© temporelle de O (M + N). </li><li>  Si les deux tables ont un index pour les colonnes jointes, alors l'index prend d√©j√† en charge ces colonnes dans l'ordre et le tri n'est pas requis.  La difficult√© sera O (M + N). </li><li>  Si aucune des tables n'a d'index sur les colonnes connect√©es, vous devez d'abord trier les deux tables, afin que la complexit√© ressemble √† O (M log M + N log N). </li><li>  Si une seule des tables a un index sur les colonnes connect√©es, seule la table qui n'a pas d'index doit √™tre tri√©e avant que l'√©tape de jointure se produise, de sorte que la complexit√© ressemble √† O (M + N log N). </li></ul></li><li>  Pour les jointures imbriqu√©es, la complexit√© est g√©n√©ralement O (MN).  Cette jointure est efficace lorsqu'une ou les deux tables sont extr√™mement petites (par exemple, moins de 10 enregistrements), ce qui est une situation tr√®s courante lors de l'√©valuation des requ√™tes, car certaines sous-requ√™tes sont √©crites pour renvoyer une seule ligne. </li></ul><br>  <b>N'oubliez pas: une</b> jointure imbriqu√©e est une jointure qui compare chaque enregistrement d'une table avec chaque enregistrement d'une autre. <br><br><h3>  Temps logarithmique: O (log (n)) </h3><br>  On dit qu'un algorithme fonctionne en temps logarithmique si son temps d'ex√©cution est proportionnel au logarithme de la taille d'entr√©e;  Pour les requ√™tes, cela signifie qu'elles seront ex√©cut√©es si le temps d'ex√©cution est proportionnel au logarithme de la taille de la base de donn√©es. <br><br>  Cette complexit√© temporelle logarithmique est valide pour les plans de requ√™te dans lesquels une <code>Index Scan</code> ou un index cluster est analys√©.  Un index cluster est un index dont le niveau d'index final contient les lignes r√©elles de la table.  Un index clusteris√© est similaire √† tout autre index: il est d√©fini dans une ou plusieurs colonnes.  Ils forment une cl√© d'index.  La cl√© de clustering est les colonnes cl√©s d'un index cluster.  L'analyse d'un index cluster est essentiellement l'op√©ration de lecture de votre SGBD pour une ou plusieurs lignes de haut en bas dans un index cluster. <br><br>  Prenons l'exemple de requ√™te suivant, o√π il existe un index pour <code>i_id</code> et qui entra√Æne g√©n√©ralement une complexit√© O (log (n)): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_stock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i_id = N;</code> </pre> <br>  Notez que sans index, la complexit√© temporelle serait O (n). <br><br><h3>  Temps quadratique: O (n ^ 2) </h3><br>  On pense que l'algorithme est ex√©cut√© en temps quadratique, si son temps d'ex√©cution est proportionnel au carr√© de la taille d'entr√©e.  Encore une fois, pour les bases de donn√©es, cela signifie que le temps d'ex√©cution de la requ√™te est proportionnel au carr√© de la taille de la base de donn√©es. <br><br>  Un exemple possible d'une requ√™te de complexit√© temporelle quadratique est le suivant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item, author <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item.i_a_id=author.a_id</code> </pre> <br>  La complexit√© minimale peut √™tre O (n log (n)), mais la complexit√© maximale peut √™tre O (n ^ 2) sur la base des informations d'index des attributs de connexion. <br><br>  Pour r√©sumer, vous pouvez √©galement consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la feuille de triche suivante</a> pour √©valuer les performances des requ√™tes en fonction de leur complexit√© temporelle et de leur efficacit√©: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br><h2>  R√©glage SQL </h2><br>  Compte tenu du plan d'ex√©cution des requ√™tes et de la complexit√© temporelle, vous pouvez personnaliser davantage votre requ√™te SQL.  Vous pouvez commencer par vous concentrer sur les points suivants: <br><br><ul><li>  Remplacez les analyses de table compl√®tes inutiles par des analyses d'index; </li><li>  Assurez-vous que l'ordre de jointure optimal est appliqu√©. </li><li>  Assurez-vous que les index sont utilis√©s de mani√®re optimale.  Et </li><li>  La mise en cache des analyses de texte int√©gral des petites tables (cache les analyses de table compl√®te des petites tables) est utilis√©e. </li></ul><br><h2>  Utilisation ult√©rieure de SQL </h2><br>  F√©licitations!  Vous √™tes arriv√© √† la fin de cet article, qui vient de vous donner un petit aper√ßu des performances des requ√™tes SQL.  J'esp√®re que vous avez plus d'informations sur les antipatterns, l'optimiseur de requ√™tes et les outils que vous pouvez utiliser pour analyser, √©valuer et interpr√©ter la complexit√© de votre plan de requ√™te.  Mais il vous reste encore tant √† d√©couvrir!  Si vous voulez en savoir plus, lisez le livre ¬´Database Management Systems¬ª de R. Ramakrishnan et J. Gehrke. <br><br>  Enfin, je ne veux pas vous refuser StackOverflow dans cette citation: <br><blockquote>  Mon antipattern pr√©f√©r√© ne v√©rifie pas vos demandes. <br><br>  Cependant, il est applicable lorsque: <br><br><ul><li>  Votre requ√™te fournit plusieurs tables. </li><li>  Vous pensez avoir la conception optimale pour la demande, mais n'essayez pas de v√©rifier vos hypoth√®ses. </li><li>  Vous acceptez la premi√®re demande de travail, sans savoir √† quel point elle est proche de l'optimum. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465975/">https://habr.com/ru/post/fr465975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465959/index.html">Arbre g√©n√©alogique √† l'int√©rieur de git</a></li>
<li><a href="../fr465961/index.html">Apprenez le marketing Internet par vous-m√™me: plus de 50 cours gratuits</a></li>
<li><a href="../fr465963/index.html">Salaire Biographie en Allemagne 2019</a></li>
<li><a href="../fr465969/index.html">La rectitude politique p√©n√®tre la Russie √† travers des livres sur la conception de puces sur SystemVerilog pour les non-d√©butants</a></li>
<li><a href="../fr465973/index.html">10 reportages vid√©o les plus populaires du 404fest 2018</a></li>
<li><a href="../fr465977/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 31. CDP, Syslog et NTP</a></li>
<li><a href="../fr465979/index.html">N'oubliez pas que tout ^ W est exactement ce dont vous avez besoin. Exp√©rience avec Anki. Partie 1 (introduction, avant-derni√®re)</a></li>
<li><a href="../fr465981/index.html">Mon exp√©rience d'administration IBM DB2 Express-C lorsqu'il est utilis√© avec 1C: Enterprise</a></li>
<li><a href="../fr465983/index.html">Intel Comet Lake: un petit 14 nm √† la dixi√®me g√©n√©ration</a></li>
<li><a href="../fr465985/index.html">Nous acc√©l√©rons le traitement distribu√© de grands graphiques en utilisant des structures de donn√©es probabilistes et pas seulement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>