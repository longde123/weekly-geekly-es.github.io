<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚕️ 🛌🏽 🤭 C ++ vs C # 🧑🏼‍🤝‍🧑🏼 🏿 🗃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder weiß, dass es nichts Dümmeres gibt, als zu argumentieren, "welche Sprache besser ist". Zum Beispiel besser für was? Verschiedene Sprachen sind i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vs C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469467/"><img src="https://habrastorage.org/webt/ud/4s/-_/ud4s-_jhcan8lv7ei9kfabnsszo.jpeg"><br><br>  Jeder weiß, dass es nichts Dümmeres gibt, als zu argumentieren, "welche Sprache besser ist".  Zum Beispiel besser für was?  Verschiedene Sprachen sind in verschiedenen Nischen erfolgreich - und es ist sinnlos, endgültige Schlussfolgerungen zu ziehen, ohne dies zu berücksichtigen. <br><br>  Aber was passiert, wenn wir uns an erfahrene Spezialisten wenden, die das alles selbst verstehen und sie bitten, den Holivar C ++ gegen C # zu arrangieren?  Es stellt sich heraus, dass Sie viele interessante Details herausfinden können.  Das Wort "plattformübergreifend" kann auf beide Arten auf beide Sprachen angewendet werden. Was bedeutet dies in der Praxis?  Entwickelt sich C ++ jetzt aktiv?  Hat C # jemals die Abwärtskompatibilität unterbrochen?  Die Antworten mögen für diejenigen offensichtlich sein, die bereits tief in beide Sprachen gleichzeitig vertieft sind, aber es gibt nur wenige solcher Menschen - und alle anderen werden etwas Neues lernen. <br><br>  Von C ++ aus nahm <b>Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">sermp</a> Platonov</b> , Vorsitzender des Programmkomitees der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Russia</a> Conference, teil.  Die C # -Seite wurde von <b>Anatoly Kulakov vertreten</b> - er ist im PC der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext-</a> Konferenz und unter den Leitern von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNetRu vertreten</a> .  Und der Diskussionsleiter, in dessen Leben beide Welten nebeneinander existieren, war <b>Dmitry <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Mezastel</a> Nesteruk</b> . <br><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/sn/rb/_i/snrb_ie2-dnmplhnbfnl_klnvca.jpeg"><br><br>  <b>Dmitry:</b> Guten Tag, Kollegen.  Willkommen zu informellen Zusammenkünften zum Thema Programmiersprachen.  Im Internet werden wir ständig daran erinnert, dass Sprachen nicht verglichen werden können.  Und heute werden wir genau das tun, was Sie nicht können: Vergleichen Sie C ++ mit C # und .NET, deren Vor- und Nachteile.  Stell dich bitte vor. <br><br>  <b>Anatoly:</b> Mein Name ist Anatoly, und heute werde ich für C # ertrinken, weil ich diese Sprache von Anfang an studiert habe und anscheinend alles darüber weiß. <br><br>  <b>Sergey:</b> Hallo, mein Name ist Sergey, ich werde heute für C ++ ertrinken.  Dima hat richtig gesagt, dass wir die Vor- und Nachteile vergleichen werden.  Jeder nennt es "Profis", es ist bekannt, dass C # in dieser Diskussion ein Minus sein wird.  Ist das richtig, Anatoly? <br><br>  <b>Anatoly:</b> C # hat zwei weitere Pluspunkte!  Daher denke ich, dass dies eine evolutionäre Entwicklung der Vorteile ist, die bereits veraltet sind und fast nirgendwo konkurrieren können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/wy/sj/_pwysj2lxe1ncg6lmuzqxfs2dg0.jpeg"></div><br><br><h2>  Bildung </h2><br>  <b>Dmitry:</b> Ich habe das erste Thema für unsere Diskussion.  Stellen Sie sich vor, neue Studenten kommen an die Universität, sie brauchen die erste Sprache.  Was sollte Ihrer Meinung nach die erste Sprache sein, die Menschen in ihrem ersten Jahr erhalten: C ++, C # oder Assembler im Allgemeinen? <br><br>  <b>Sergey:</b> Ich habe einige Zeit unterrichtet, daher habe ich eine etablierte Meinung.  Ich verstehe, dass wir hier diskutieren werden, welche Sprache besser ist, und ich stehe für C ++ ... Aber um C ++ zu lernen, müssen Sie die Architektur des Computers verstehen.  Und damit das große Problem, Studenten zu unterrichten (zumindest an der Universität, an der ich unterrichtet habe).  Und um Algorithmen und andere Dinge zu lehren, benötigen Sie wahrscheinlich etwas, das sich nicht auf die Infrastruktur in der Sprache selbst konzentriert.  Hier war Eiffel ein Versuch, dies zu tun, aber es gibt auch viel Magie.  Daher würde ich sagen, dass keine unserer beiden Sprachen geeignet ist. <br><br>  Das Programmieren ist anders und es ist nicht das „Programmieren“, das lehrt, sondern Algorithmen, Datenstrukturen und so weiter.  Es ist möglich, dass es sinnvoll ist, für jedes Thema ein eigenes Instrument auszuwählen.  Verstehen Sie eine Art von Lisp-Datenstrukturen.  Und C ++ sollte dementsprechend gegeben werden, nachdem die Schüler etwas über Architektur verstanden haben.  Und dann wird es möglich sein zu verstehen, warum all diese Schmerzen und Leiden.  Ich werde nicht einmal argumentieren, dass es bei den Pluspunkten um Schmerz geht. <br><br>  <b>Anatoly:</b> Ja, ich stimme vollkommen zu, dass Sie Objekte trennen und nicht in die „Programmierung“ einfügen und alles in einer Sprache hämmern müssen.  Aber wenn Sie an dem Punkt angelangt sind, an dem Sie die Grundlagen, Grundlagen und Algorithmen gelernt haben und anfangen, eine industrielle Sprache zu wählen, ist C # natürlich viel besser.  Weil es Sie nicht zwingt, all diese Rückstände auf der Ebene von Architekturen, Speicherbytes und anderen „Sonnenuntergängen von Hand“ zu lernen.  Es gibt eine sofort verständliche Sprache, eine einfache Syntax und in dieser Sprache können Sie ab dem ersten oder zweiten Jahr ganz greifbares Geld verdienen. <br><br>  <b>Dmitry:</b> Es gibt ein Argument, dass es eine Art Sakrileg ist, Anfängern keine Dinge wie Hinweise zu geben.  Sie haben ein großes Loch, wenn eine Person nicht versteht, dass beispielsweise ein Link tatsächlich nur die Adresse einer Variablen im Speicher ist.  Was denkst du darüber? <br><br>  <b>Anatoly:</b> Vor 20 Jahren war dies der Fall, als Computer nicht genügend Speicher, nicht genügend Festplatten und andere Dinge hatten.  Schauen Sie sich diese Javaskripte an, sie ziehen 500 Megabyte Bibliotheken in jede "Hallo Welt".  Wie viel nehmen sie in Erinnerung?  Was ist ihre Leistung?  Was sind die Links dort?  Ja, das interessiert niemanden.  Die Hauptsache ist, schnell etwas in der Produktion zu rollen und freizugeben.  Ich behaupte nicht, dass dies ein guter oder richtiger Weg ist, ich argumentiere, dass es notwendig ist, sich zusammen mit den Realitäten zu ändern.  Vielleicht ist es jetzt nicht so wichtig, wie viel Ihr Link kostet. <br><br>  <b>Sergey:</b> Wahrscheinlich je nachdem wo.  Soweit ich weiß, war Dmitry am algorithmischen Handel interessiert - ich kann mir gut vorstellen, wie er Bibliotheken auf JS aufruft, um einen Auftrag an die Börse zu senden. <br><br>  <b>Dmitry:</b> Nun ja, natürlich verwendet in der Praxis dort niemand solche Sprachen.  Obwohl dies theoretisch möglich sein könnte: Vergessen wir nicht, dass nicht schwaches Geld in die JS-Infrastruktur geworfen wird.  Engines, die die JS-Kompilierung zu allem und jedem machen.  Viele betrachten diese Sprache als die erstklassige Sprache für alles im Allgemeinen. <br><br>  Natürlich ist der Algo-Handel heute eine von einer solchen Disziplin entfernte Disziplin, aber der Algo-Handel und die Finanzmathematik als Ganzes sind im Allgemeinen ein spezifischer Bereich.  Es dominiert nur C ++.  Und es überwiegt teilweise aufgrund der Trägheit, einfach aus historischen Gründen: Am Anfang waren alle in C ++, und dieser Bereich ist konservativ. <br><br>  <b>Sergey:</b> Dem stimme ich nicht zu.  Ich arbeite jetzt im Bereich Fintech, und Kollegen, die seit Beginn des algorithmischen Handels hier sind, sprechen über große Unternehmen, die zuerst in Java geschrieben haben.  Anfangs kam Java mit dem algorithmischen Handel zurecht, aber als der Markt zu wachsen begann und Konkurrenten mit C ++ auftauchten, konnten sie es irgendwann einfach nicht mehr, sie schafften es nicht, alles effizient zu erledigen ... Also begann nicht jeder im algorithmischen Handel mit C ++.  Nur diejenigen, die nicht darüber geschrieben haben, sind gestorben.  Solch eine natürliche Auslese. <br><br>  <b>Dmitry:</b> Eigentlich kann man es weiter nehmen.  Es gibt viele Beispiele, bei denen selbst große Banken ihre Algorithmen in einem Excel-Dokument speichern.  Sie verwenden Excel dann auch als Server, um all dies zu berechnen.  Es gibt höllische Bremsen, aber alles hängt davon ab, ob Sie Hochfrequenzhandel betreiben (oder generell etwas Hochfrequentes).  Wenn Sie ein Market Maker sind, ist es selbstverständlich, dass Sie eine hohe Leistung benötigen, und da das Geschäft nicht einmal auf C ++ beschränkt ist, beschäftigen wir uns mit Hardware und HDL-Sprachen. <br><br>  Unsere Diskussion dreht sich aber nicht nur um algorithmischen Handel, sondern auch um einfache Dinge.  Hier gebe ich ein Beispiel.  Im Zusammenhang mit dem Bau musste ich mehrere kleine Anwendungen schreiben, in denen verschiedene Dinge berechnet wurden: zum Beispiel, wie man Steine ​​um die Kontur eines Hauses legt.  Und ich kann mir kaum vorstellen, wie man solche Dinge in C ++ macht, weil dort alles, was mit der Benutzeroberfläche zu tun hat, schwächer ist.  Es gibt nur ein Framework, Qt, und selbst das Schreiben darauf ist sehr schwierig.  Und wenn ich mich für C #, für WinForms, hinsetze, mache ich sofort die Anwendung. <br><br>  <b>Anatoly:</b> Nun, der visuelle Teil war schon immer eine Stärke von C #.  Microsoft hat viel in Formen und sogar in plattformübergreifende Formen und allgemein in die Visualisierung investiert.  Wenn es sich also um visuelle Desktop-Anwendungen handelt, scheint es mir, dass die Pluspunkte im Allgemeinen weit hinterherhinken. <br><br>  <b>Sergey:</b> Nun, es kommt wie immer darauf an.  Ich mag UI wirklich nicht, aber auf den Pluspunkten muss ich es ständig tun.  Es scheint JS zu bringen und nur mit den Profis zu interagieren.  Aber ich habe mit Embedded gearbeitet und da ist es schwer.  Die Leute kauften eine Art schnelle, teure Engine, aber sie konnte das normale Rendering der in JS geschriebenen Benutzeroberfläche immer noch nicht bewältigen.  Und nachdem ich das alles auf Qt umgeschrieben hatte, stellte sich heraus, dass es übertaktet war.  Gewöhnliche Geschichte. <br><br><img src="https://habrastorage.org/webt/kc/9t/uf/kc9tufwhjjwnla-uga_j8abdwqg.jpeg"><br><br><h2>  Plattformübergreifend gegen plattformübergreifend </h2><br>  <b>Sergey:</b> Ich wollte hier klarstellen.  Ich weiß nicht viel über C #, ich habe es vor sehr langer Zeit in den ersten Versionen selbst angefasst (damals war ich von der Abwärtskompatibilität betroffen).  Die Frage ist also: Wird es immer noch nur von Microsoft entwickelt? <br><br>  <b>Anatoly:</b> Nein, jetzt ist es plattformübergreifend, offen und gemäß ISO (ECMA-334 und ISO / IEC 23270) verifiziert.  Übrigens hat C ++ meines Wissens noch keine offene ISO-Spezifikation, sondern nur kostenpflichtig.  Und C # ist dagegen völlig offen.  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Foundation</a> entwickelt, die von vielen Unternehmen (einschließlich Google, Amazon und Samsung) entwickelt wurde.  Ich kenne noch nicht einmal eine offenere Sprache als C # und seine .NET-Plattform. <br><br>  <b>Sergey:</b> Nun, Haskell. <br><br>  <b>Anatoly:</b> Übrigens, der Autor von Haskell arbeitet bei Microsoft Research und hat große Anstrengungen unternommen, um alle möglichen coolen Dinge in C # erscheinen zu lassen - zum Beispiel eine statische Überprüfung, eine Art Reflexion, von der Sie wahrscheinlich nicht einmal träumen können. <br><br>  <b>Sergey:</b> Sie können träumen und sogar in diese Richtung wird gearbeitet.  Aber es ist klar, dass alles seinen eigenen Preis hat.  In C ++ weigern sie sich einfach, diesen Preis zu zahlen. <br><br>  <b>Anatoly:</b> Welches?  Sie werden für zwei Stunden zusammengestellt, was könnte der Preis sonst sein? <br><br>  <b>Sergey:</b> In C ++ das Prinzip der Nullkostenabstraktion.  Das heißt, eine virtuelle Maschine ist keine Null-Kosten-Abstraktion, oder?  Wir müssen uns damit abfinden. <br><br>  <b>Dmitry:</b> Nun, aber eine virtuelle Maschine kann beispielsweise Code für eine bestimmte Architektur verdecken.  Wenn ich in C ++ die AVX-Anweisung auf einem Computer ohne AVX verwende, wird mein Prozess nur beendet.  Ich würde sagen, dass dieses Argument nicht ganz richtig ist, weil JIT theoretisch - ich betone theoretisch - das tun kann, was C ++ nicht verfügbar ist.  Optimierung zum Zeitpunkt des Starts. <br><br>  <b>Sergey:</b> Aber in C ++ können Sie während der Kompilierung vollständig steuern, welche Anweisungen Sie benötigen.  In diesem Fall steuern Sie es nicht mit Ihren Händen, sondern geben das Instrument (Compiler) auf.  Schauen Sie, welche Anweisungen in dieser Architektur enthalten sind, welche Anweisungen ... <br><br>  <b>Dmitry:</b> Das ist verständlich.  Aber wir können es so formulieren: Da es eine Million Plattformen gibt, werden wir niemals ein Ideal bekommen, weil wir nicht eine Million Versionen mit unterschiedlichen Kompilierungsflags veröffentlichen können.  Richtig?  Wir veröffentlichen normalerweise x86 und x64, teilen es jedoch nicht in einige Untergruppen auf. <br><br>  <b>Sergey:</b> Warum können wir nicht?  XXI Jahrhundert.  Halten Sie Docker mit verschiedenen Parametern, das ist alles. <br><br>  <b>Dmitry:</b> Wenn wir einen Endclient haben, der unsere Anwendung herunterlädt, möchte er eine bestimmte Binärdatei herunterladen.  Und in dieser Binärdatei können wir nur überall bleiben, wenn.  Wie "Wenn cpuid so und so ist und avx-Unterstützung so und so ist, dann verwenden wir den Algorithmus Version 25".  Daher benötigen wir 25 verschiedene Versionen desselben Algorithmus, da die Beschleunigung von den Plattformen abhängt und plattformabhängig ist. <br><br>  <b>Sergey:</b> Ich stimme wahrscheinlich zu.  Es ist nur so, dass ich ehrlich gesagt nie ein nicht internes Produkt erstellt habe.  Ich bin hauptsächlich in Unternehmen tätig, die ihr Produkt selbst verwenden. <br><br>  <b>Dmitry:</b> Natürlich ist die beste Option, wenn Sie die Architektur vorhersehbar kennen.  In diesem Fall zwingt Sie streng genommen niemand, überhaupt x86-Anweisungen zu verwenden.  Sie können eine bestimmte Karte (z. B. Nvidia Tesla) nehmen und tun, was Sie wollen.  Dies ist auch mein Ansatz, ich kontrolliere meine Architektur.  Aber wenn Sie Massenmarktentscheidungen für den Benutzer treffen ... Wenn Sie einen bedingten ReSharper verwenden, kann er die GPU-Beschleunigung nicht einfach für beliebige Indizes verwenden.  Weil die GPU-Beschleunigung keine tragbare Sache ist. <br><br>  <b>Sergey:</b> Eigentlich gibt es Ansätze (jetzt müssen Sie wahrscheinlich nicht mehr auf Details eingehen), es gibt interessante Leute (der Autor des Ansatzes ist anscheinend jetzt auch zu Microsoft gewechselt).  Hier auf unserer Konferenz im vorletzten Jahr gab es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> darüber, wie man ein solches Programm schreibt, der selbst versteht, was wo ist (relativ einfach, wieder Null-Kosten-Abstraktionen).  So können Sie im Handumdrehen den Code im CUDA-Stil auswählen und gegebenenfalls korrekt neu erstellen ... <br><br>  <b>Dmitry:</b> Eigentlich versucht CUDA selbst, dieses Problem zu lösen, weil es in CUDA eine bestimmte Zwischenschicht von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PTX gibt</a> , die sich damit befasst.  Dies ist jedoch immer noch sehr schwierig, da sich das Eisen evolutionär radikal verändert und es sehr schwierig ist, überhaupt mitzuhalten.  Wenn wir uns beispielsweise die Verwendung der GPU-Beschleunigung in Adobe-Produkten ansehen, verwenden sie einen sehr engen Abschnitt der verfügbaren Technologien.  Wenn Ihre Karte korrekt ist - dann ist alles in Ordnung.  Aber wenn es ein bisschen exotisch ist, ist diesbezüglich nichts garantiert. <br><br>  <b>Anatoly:</b> In dieser Diskussion haben wir ein ziemlich wichtiges Thema angesprochen, einen solchen Mythos: C ++ wurde vor vielen Jahren als solche plattformübergreifende Sprache deklariert, aber im Moment ist plattformübergreifend viel mehr in C #.  Eine einzige Binärdatei funktioniert überall dort, wo .NET unterstützt wird, und dies ist fast überall. <br><br>  <b>Sergey:</b> Nun, das ist auch ziemlich unbegründet.  Als eine Person, die den größten Teil meines Lebens in Embedded verbracht hat, habe ich selten gesehen, dass .NET von der Toolchain des Hardwareherstellers unterstützt wird.  Unternehmen, die Eisen produzieren, verwenden dasselbe G ++ oder Clang oder lassen es Code für ihre Plattform generieren. <br><br>  <b>Dmitry:</b> Ja, aber das Problem ist, dass sie jedes Mal etwas von C ++ verlieren.  Zum Beispiel verwendete Nokia eine Variante von C ++, aber ihr C ++ war mit verrückten Wendungen und verrückten APIs ausgestattet, die alle wütend machten.  Das heißt, es ist nicht nur C ++, sondern C ++ für die eine oder andere Plattform.  Und dann beginnen die Probleme.  Nehmen Sie zum Beispiel die gleiche CUDA.  Es ist, als ob es nur die Profis durchlassen sollte, es ist überhaupt kein Compiler, sondern nur ein Treiber.  Trotzdem hat sie Probleme damit, dass sie immer noch ein Framework verwendet, um CUDA-Dateien in GPU- und CPU-Teile zu zerlegen.  Und manchmal gelingt es ihr nicht. <br><br>  <b>Sergey: Das habe</b> ich nicht so gemeint.  Es ist nur so, dass, wenn ich höre, dass .NET überall läuft, die meisten meiner Arbeitsbiografien zurückfallen.  Wenn Sie eine Hardware mit einem benutzerdefinierten Prozessor kaufen, wird diese nur mit der G ++ - Lieferung geliefert.  Und es gibt gewöhnliches C ++, das G ++ von der Toolchain in Maschinencode konvertieren kann, der von diesem bestimmten Prozessor unterstützt wird. <br><br>  <b>Dmitry:</b> Aber auch dies muss wieder zusammengesetzt werden ... <br><br>  <b>Sergey:</b> Natürlich. <br><br>  <b>Dmitry:</b> Und die Idee, dass wir den vorhandenen Plus-Code in das Stück Eisen ziehen - diese Idee funktioniert auch nicht, weil Sie plötzlich Ihr reguläres x86 irgendwohin gezogen haben, wo Sie 8 Gigabyte Speicher für alles über alles haben und nicht Erweitern: Beispielsweise gibt es keinen Austausch auf die Festplatte, da keine Festplatte vorhanden ist und kein Zugriff darauf vorhanden ist.  Dies ist, wenn wir über Portabilität sprechen.  Kommt natürlich auf die Ziele an. <br><br>  <b>Anatoly:</b> Profis arbeiten auf mehr Geräten, und natürlich ist Embedded einer der stärksten Teile.  Aber normalerweise müssen Sie Ihren Code irgendwie an die Plattform anpassen.  Das ist schlecht  Ich kann eine große Anzahl von Plattformen, Architekturen und Modellen mit einem Code abdecken.  Außerdem musste ich über jede einzelne Plattform nachdenken: Wo und unter welchen Bedingungen wird sie dort beginnen?  Und es ist sehr schlimm, es hält sich sehr zurück. <br><br><img src="https://habrastorage.org/webt/f1/wn/1z/f1wn1zxi80gplsj3bpidl9fpr1i.jpeg"><br><br><h2>  Stabilität, Kompatibilität, Sprachentwicklung </h2><br>  <b>Dmitry: Es</b> wurden auch Null-Kosten-Abstraktionen erwähnt, aber das Problem ist, dass dies einen enormen Preis hat.  In .NET gibt es beispielsweise ein Konzept eines Aufzählungstyps und einer IEnumerable-Schnittstelle.  Und für jeden Typ, zum Beispiel ein Array, können Sie einen Iterator verwenden und durchlaufen.  Aber in C ++ gibt es keine solche Idee.  Aufgrund der Null-Kosten-Abstraktion gibt es, um die Sammlung zu umgehen, einige begin () und end (), es gibt Regeln für ihre Arbeit, und all dies ist viel komplizierter (insbesondere für diejenigen, die mit dem Programmieren beginnen).  Dies ist ein direktes Problem: Wie kann man ein Array von A bis Z umgehen? <br><br>  <b>Sergey:</b> Wenn ich richtig verstehe, wovon Sie sprechen ... Wenn Sie nur einen Container von Anfang bis Ende umgehen müssen, schreiben Sie jetzt einfach, wie in Python. <br><br>  <b>Dmitry:</b> Das ist alles wunderbar.  Aber Sie verwenden zum Beispiel keinen Polymorphismus dafür.  Man kann nicht sagen, dass ich hier eine Funktion habe, die einen bestimmten Wert erhält, der a priori aufgezählt wird.  Sie können nicht sagen, dass ich einen Wert habe, der die Schnittstelle implementiert, und diese Schnittstelle hat beispielsweise einen Iterator. <br><br>  <b>Sergey:</b> Wir reden über welches C ++?  Über C ++ im Allgemeinen, C ++ der Zukunft, C ++, die jetzt als Standard akzeptiert werden? <br><br>  <b>Dmitry:</b> Nun, wenn es in den Profis der Zukunft sein wird ... <br><br>  <b>Sergey:</b> In C ++ 20 ist dies bereits vorhanden.  Sie können bereits sagen, Sie können sich sogar deklarieren.  Dies sind keine Schnittstellen, aber wie man es richtig sagt ... Im Allgemeinen können Sie erklären, dass Ihr Typ diese und jene Bedingungen erfüllen muss.  Zum Beispiel hat es Anfang und Ende, die einen Iterator zurückgeben.  Und ein Iterator ist ein so vorbereitetes Konzept in der Standardbibliothek.  Er sagt was es ist, beschreibt.  Iteratoren sind auch unterschiedlich.  Im Allgemeinen versuchen wir, es für Menschen bequemer zu machen. <br><br>  <b>Dmitry:</b> Es scheint mir, dass dies aus der Tatsache entstanden ist, dass die Leute gerade erkannt haben, dass es schwierig ist, ohne die Konzepte der Iterierbarkeit eines Objekts zu leben.  Weil es nicht klar ist, wie man verallgemeinerte Dinge schreibt.  Ja, eine Abstraktion ohne Kosten bedeutet, dass wir bei der Suche nicht die Kosten haben, um die V-Tabelle herumzulaufen ... In .NET gibt es beispielsweise nur eine bestimmte Methode.  Und um es zu finden, müssen wir natürlich Anstrengungen unternehmen, die die Pluspunkte ablehnen.  Aber unter dem Gesichtspunkt der Benutzerfreundlichkeit ist das Endergebnis nicht so gut, würde ich sagen. <br><br>  <b>Sergey:</b> Natürlich muss es ein Gleichgewicht geben.  Sie können nicht alles auf einmal haben. <br><br>  <b>Anatoly:</b> Man wundert sich, wie viele Jahre vergangen sind.  Alternative Sprachen entwickeln sich, und in ihnen erscheinen solche grundlegenden Dinge von Anfang an.  Jetzt holen sie etwas Wesentlicheres und Interessanteres ein.  Und die Pluspunkte sitzen zehn Jahre lang mit derselben unverständlichen Syntax, obskuren Abstraktionen, unverständlichen Krücken und unterentwickelt.  Sie können dies als einen der Minuspunkte setzen. <br><br>  <b>Sergey:</b> Na komm schon!  Was bedeutet "schlecht entwickelt"? <br><br>  Sie haben ein Komitee erwähnt - C ++ hat auch ein ISO-Komitee, das es entwickelt.  Dort gibt es Vertreter, einschließlich Microsoft, die stark ertrinken, weil "Sie dies nicht tun können, weil wir viel Vermächtnis haben, das wir unterstützen müssen".  Nur C ++ ist die Sprache, die bereits gehalten wird.  Und natürlich geht er sehr vorsichtig.  Eine der Hauptaufgaben (die Straustrup bereits beim Erstellen deklariert hat) ist die Kompatibilität mit C. Aber jetzt hat sich C sogar ziemlich weit entwickelt. Sie müssen angeben, mit welchem ​​C kompatibel ist. <br><br>  Und meiner Meinung nach entwickelt sich C ++ jetzt in einem enormen Tempo.  In Bezug auf Konzepte und so weiter - tatsächlich wächst natürlich alles nicht durch Iterierbarkeit.  Tatsächlich folgt die Entwicklung dem, was Alexander Stepanov auch beschrieben hat - einem der Autoren dessen, was wir jetzt als "generalisierte Programmierung" bezeichnen, der Person, die tatsächlich Vorlagen, Generika usw. in C ++ gezogen hat.  Um ehrlich zu sein, ich weiß nicht, wie sehr das Komitee von diesen Ideen inspiriert ist, aber es scheint mir, dass es definitiv einen Schnittpunkt mit ihnen gibt. <br><br>  <b>Anatoly:</b> Es scheint, dass all diese Metaklassen, Iteratoren, wirklich Inspiration sind, was schon vor vielen Jahrzehnten war.  Selbst wenn Sie Metaprogrammierung, Vorlagen und Makros verwenden - all diese Leute haben lange Erfahrung, Erfahrung und es gibt viel einfachere, offensichtlichere und verständlichere Konzepte.  In anderen Sprachen wird dies alles millionenfach besser und schneller erledigt, mit Typensicherheit, Überprüfung der Kompilierungszeit und so weiter. <br><br>  <b>Sergey:</b> Warten Sie, Sie sprechen bereits über etwas, für das nicht jeder bereit ist zu bezahlen.  Ich möchte nicht, dass mein Programm ohne mein Wissen etwas in der Kompilierungszeit überprüft.  Verstehst du <br><br>  <b>Anatoly:</b> Ich denke, all diese mit Flags können konfiguriert werden.  Sie legen die Optimierungsstufe fest und überprüft Sie entweder oder nicht.  Das ist kein Problem. <br><br>  <b>Sergey:</b> Oft musst du alles mit deinen Händen kontrollieren.  Wissen Sie genau, was los ist.  Weil die Werkzeuge - na ja, das. <br><br>  <b>Dmitry:</b> Es geht nicht einmal um Werkzeuge.  Hier sagt die Tatsache, dass Sprachen wie D und Rust sagen: Nun ja, es gibt so etwas, dass Sie es überprüfen können, wenn Sie auf ein Array-Element zugreifen, aber Sie können es nicht überprüfen.  Und sie geben es einfach dem Benutzer, das heißt, Sie können sagen "aber lassen Sie uns die Array-Prüfungen ausschalten", "aber lassen Sie es uns einschalten".  Das heißt, eine Art Kontrolle in dieser Hinsicht. <br><br>  <b>Sergey:</b> Es ist nicht klar, wann Sie unsicher und sicher sind, wie in Rust. Ich sehe in diesem Fall beispielsweise keinen Unterschied zu C. <br><br>  <b>Anatoly:</b> Der Unterschied besteht darin, dass Sie sicher und schnell schreiben können.  Und in C muss man gefährlich schreiben.  Na ja, vielleicht schnell.  Stabilität ist manchmal wichtiger als Geschwindigkeit. <br><br>  <b>Dmitry:</b> Wenn wir dieses Thema mit neuen Sprachen vertiefen, gibt es in C ++ Dinge, die im Allgemeinen sehr schwer zu vermitteln sind.  Eine einfache Frage: Welche Größe hat int?  In den meisten Sprachen kennen Sie die Antwort auf diese Frage.  Sie sagen: int ist 32 Bit.  Aber Sie kennen die Profis nicht.  Sie kennen die Größe Ihres Computers, weil Sie sich daran erinnern, aber genau genommen möchten Sie nicht einmal die Basistypen verwenden, da sie nicht deterministisch sind.  Und solche Dinge machen mich wütend, wenn es eine Reihe von Legacy-Ansätzen gibt, wie der int, der auf verschiedenen Plattformen unterschiedlich sein wird.  Und jetzt verstehen wir bereits, dass dies nicht möglich ist.  Warum nicht weiter gehen und dieses Problem irgendwie lösen? <br><br>  <b>Sergey:</b> Nun, das ist entschieden.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sexuell übertragbare Krankheiten</a> , die erforderlichen Typen mit fester Länge.  Jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zieht</a> der Vertreter Russlands im Ausschuss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein</a> Int von variabler Länge (wieder mit Null-Kosten-Abstraktion). <br><br>  <b>Anatoly:</b> Erinnere ich mich richtig daran, dass es sogar eine nicht deterministische Größe eines Zeigers auf eine Methode gibt?  Das heißt, unter verschiedenen Compilern und verschiedenen Plattformen sind die Zeiger unterschiedlich? <br><br>  <b>Sergey: Das ist</b> natürlich Architektur.  Wie können Sie die Größe des Zeigers garantieren, wenn Sie sich in der Nähe der Hardware befinden, wenn Sie 8-Bit und dann 64-Bit verwenden? <br><br>  <b>Anatoly:</b> Und wie kann man danach mit Zeigern rechnen?  Das ist verrückt. <br><br>  <b>Sergey: Ich</b> meine?  Gut, vorsichtig. <br><br>  <b>Anatoly:</b> Ich verstehe.  Der Ansatz ist überall klar und alles wird sorgfältig mit Griffen gesteuert. <br><br>  <b>Sergey:</b> Nun ja.  Auch in modernen C ++ - Standards werden Ansätze entwickelt ... Wenn wir über die Wahl sprechen, dann gibt es in den modernen Pluspunkten tatsächlich die Wahl, ob der Garbage Collector verwendet werden soll.  Es ist nur so, dass GC dort auf Referenzzählern aufgebaut ist. <br><br>  Im Allgemeinen, Kollegen, habe ich das Gefühl, dass Sie Ihr Wissen über moderne Pluspunkte seit langem nicht mehr aktualisiert haben. <br><br>  Leute wie Straustrup, die Teil des Pantheons der Plus-Götter sind, kommen mit vielen Anrufen, um herauszufinden, wie man modernes C ++ lehrt.  Das Problem ist, was die Leute in den C ++ - Kategorien von 2003 denken und in denselben Kategorien unterrichten.  Und in diesem Zusammenhang gibt es interessante neue Projekte und Ansätze, es gibt moderne Kurse - sagen wir, die Jungs von Yandex haben einen wunderbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurs gemacht</a> .  Und jetzt in Pluspunkten wird es als schlechte Manieren angesehen, zum Beispiel rein neu zu verwenden und zu löschen. <br><br>  <b>Dmitry:</b> Was Ihren Kommentar zur Aktualisierung von Wissen betrifft ... Die Nuance ist, dass mein Ansatz zum Beispiel darin besteht, das kleine C ++ - Delta zu verwenden, das garantiert für mich funktioniert und mit dem ich „befreundet“ bin.  Sie sehen, C ++ ist umfangreich.  Es gibt Template-Metaprogrammierung, und alles wäre in Ordnung, es gibt viel Magie, aber leider ist diese Magie nicht lesbar.  Dies ist ein Code, in dem ein Nichtautor ihn ohne besondere Kenntnisse nicht herausfinden kann, gewissermaßen eine Black Box.  Und es gibt viele solcher Black Boxes in den Pluspunkten, Bereiche der Dunkelheit, die nicht verdaut werden können ... Ich möchte, ich weiß nicht, dass Ihre Option vorhersehbar, gut und ohne Tricks berechnet werden kann. <br><br>  Das einfachste Beispiel betrifft Bereiche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">range-v3</a> und das gesamte Thema).  Einerseits ist das alles großartig: Es gibt Dinge, die seit mehreren Jahren in C # vorhanden sind und die es beispielsweise ermöglichen, einen Kalender durch Transformationen der Standardsammlung zu erstellen.  Andererseits ist die Art und Weise, wie es in C ++ implementiert wird, im Vergleich zu C # einfach unangenehm: Es ist schwer und nicht lesbar. <br><br>  <b>Sergey:</b> Das ist Aroma.  Ich mag es im Gegenteil.  So wie ich es verstehe, sind Sie beim Nibler- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> und seiner Präsentation ... <br><br>  <b>Dmitry:</b> Sie sehen, wenn der Operator "oder" zum Filtern einer Sammlung verwendet wird, habe ich sofort Fragen dazu.  Sowohl C # als auch Java haben alles durch den Punkt gemacht, mit den üblichen Methoden. <br><br>  <b>Sergey:</b> Und es scheint mir, dass dies von Bash inspiriert ist.  Das heißt, es ist nur eine Pfeife. <br><br>  <b>Dmitry:</b> Nun ja, wahrscheinlich erklärt dies etwas in diesem Ansatz. <br><br>  <b>Sergey: Es</b> erklärt viel!  Lassen Sie uns über PowerShell sprechen, da wir über Bash sprechen.  Wer hat PowerShell gesehen? <br><br>  <b>Anatoly:</b> Ich schreibe in PowerShell, einer großartigen Sprache.  Aber auch hier muss das Rohr dort eingesetzt werden, wo es sich befindet und wo die gesamte Architektur von ihm durchdrungen ist.  Nicht, wo Sie eine einzige Aktion ausführen müssen, und es ist hier idiomatisch schlechte Syntax. <br><br>  <b>Sergey:</b> In Range Pipe ist es nur sehr ... <br><br>  <b>Dmitry:</b> Im Bereich werden sie meiner Meinung nach aus folgendem Grund verwendet ... Ich werde dies sagen: Wenn es in C ++ Erweiterungsmethoden oder Erweiterungsfunktionen gäbe, würden Sie sie natürlich verwenden.  Denn das Natürlichste, wenn Sie eine Sammlung sortieren müssen, ist das Schreiben von "collection. Filter ()".  Und nicht „Sammlung |  view :: filter () ". <br><br>  <b>Anatoly:</b> Ich hatte auch den Eindruck, dass Sie 20 Jahre lang in die Beine geschossen, ins Gesicht geschlagen, mit dem Kopf gegen die Wand geschlagen und dann endlich gesagt haben: „Nun, jetzt haben wir im 20. Standard alles wunderbar gemacht, jetzt wollen wir unterrichten Die Profis haben Recht. “  Ja, niemand will sie richtig unterrichten!  Das heißt, es ist ein langfristiger Schmerz. <br><br>  <b>Sergey:</b> Bitte unterrichten Sie nicht.  Was ist das Problem?  Schreiben Sie in C # - handeln Sie darauf, schreiben Sie eingebettet.  Ich habe nichts dagegen. <br><br>  <b>Anatoly:</b> Nun, es gibt enge Nischen, in denen die Profis noch da sind. <br><br>  <b>Sergey:</b> Eingebettet ist eine „enge Nische“ ... Im Moment sehe ich in meiner Küche ein paar Computer. <br><br>  <b>Dmitry:</b> Jedes Mal, wenn ich mit dem Flugzeug fliege, denke ich: "Verdammt, ich hoffe, diese Pluspunkte haben dort alles gut geschrieben." <br><br>  <b>Sergey:</b> Übrigens gibt es, soweit ich mich erinnere, hauptsächlich Ada. <br><br>  <b>Dmitry:</b> Ada dominiert dort, ja. <br><br>  <b>Anatoly:</b> Übrigens bin ich kürzlich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen ausgezeichneten Artikel</a> gestoßen, in dem der Autor in verschiedenen Sprachen (ungefähr 10) einen Low-Level-Treiber geschrieben hat - einen Netzwerktreiber für eine 10-Gigabit-Intel-Karte.  Von C bis Swift, JS, Python und natürlich C #.  Wenn wir uns diese Grafiken ansehen, die er erhalten hat, dann entspricht C # bei großen Chargen (wenn die Startkosten ausgeglichen sind) C und Rust. <br><br><img src="https://habrastorage.org/webt/bk/bp/ur/bkbpuriesi98tzgy1eon4cek8vs.png"><br><br>  Das heißt, wenn wir über Leistung sprechen, kann es ein Missverständnis sein, dass C # irgendwo sehr viel schlechter ist.  Es gibt auch einen funky Bericht von Federico Luis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scratched Metal</a> , in dem er zeigte, wie er den C # -Code für Prozessorprofiler optimiert hat. <br><br>  <b>Sergey:</b> Nun, es fängt wieder an.  Die Sache ist, dass, wenn Sie anfangen, dieses Java, dieses C #, zu optimieren, es unklar wird, warum Sie nicht auf Pluspunkte schreiben sollten.  Weil Sie spezifisches Wissen benötigen.  Und wie mir scheint, ist der Vorteil von Sprachen wie C # und Java gleich hoch - keine sehr hohe Eingabeschwelle.  Soweit ich weiß, war es genau das, worüber Dmitry sprach: Lesbarkeit des Codes, viel lernen, einige Konzepte schwer zu erklären und so weiter. <br><br>  <b>Anatoly:</b> Ich arbeite 99% meiner Zeit damit, in „normalem“ C # zu schreiben - sicher, stabil und ständig arbeitend.  Und 1% der Zeit möchte ich eine Art schnellen Code auf niedriger Ebene schreiben.  Und dieses C # erlaubt es mir auch.  Aber mein Hauptwerkzeug ist immer noch stabil, lesbar, ohne Fehler ... <br><br>  <b>Dmitry:</b> Tolya, lassen Sie mich ein einfaches Beispiel geben: Vektorisierung.  Mit der Vektorisierung in .NET ist alles sehr schlecht, obwohl System.Numerics.Vectors langsam gesägt wird.  Und wozu führt es zum Beispiel meinerseits?  Zu der Tatsache, dass, wenn Sie auf dem Markt herumstöbern und eine mathematische Bibliothek für .NET kaufen, diese auf den Profis geschrieben ist (mit einem vollständigen Wrapper).  Da es in .NET praktisch keinen Zugriff auf Hardwarebeschleunigung (AVX usw.) gibt, befindet es sich jetzt in einem embryonalen Stadium. <br><br>  <b>Anatoly:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intrinsics wird</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Core 3 veröffentlicht,</a> wo Sie direkt auf AVX zugreifen können.  Sie sind wirklich in den Kinderschuhen, aber es gibt grundlegende Dinge, und der Rest ist ziemlich bewegend. <br><br>  <b>Dmitry:</b> Sie verstehen, wir haben 2019 auf dem Hof.  Als Benutzer all dieses mathematisch beschleunigten Gutes habe ich nicht darauf gewartet.  Wenn ich also schnell über etwas nachdenken möchte, ist C # für mich kein Kandidat mehr.  Weil C ++ - Bibliotheken bereits existieren.  Vielleicht ist dafür schon Zeit verloren gegangen. <br><br>  <b>Anatoly:</b> Es scheint mir, dass C # sich in Richtung Plus bewegt und versucht, ihren Markt zu gewinnen.  Aber die Pluspunkte bewegen sich nirgendwo mehr. <br><br>  <b>Sergey:</b> Woher kommt das?  Was bedeutet "Pluspunkte gehen nirgendwo hin"? <br><br>  <b>Anatoly:</b> Wenn sie mir 2019 sagen, dass es Iteratoren im Standard geben wird, wird es einige Fortschritte bei Lambdas geben, scheint mir, dass ... <br><br>  <b>Sergey:</b> Ich weiß nicht, warum Sie über Iteratoren und Lambdas sprechen. Ich verstehe nicht, wie der Stein war ... <br><br>  <b>Anatoly:</b> Nicht über Iteratoren, ich habe es falsch ausgedrückt, ich meinte die unzähligen Container, die wir zuvor besprochen haben.  Und in der Zwischenzeit haben wir Pattern Matching bekommen. <br><br>  <b>Sergey:</b> Es hängt alles davon ab, ob es notwendig ist oder nicht.  Wir diskutieren den Mustervergleich.  Bisher gibt es jedoch keine Argumente dafür, ob dies bei den Profis erforderlich ist. <br><br>  <b>Dmitry:</b> Ich höre viele ähnliche Kommentare von den Pluspunkten, die besagen: „Obwohl dieser oder jener Ansatz in anderen Sprachen bereits offensichtlich vorhanden ist, wurde er bereits ausgearbeitet, die Leute lieben ihn und bauen darauf Lösungen auf. Wir wollen dies immer noch nicht in Pluspunkten. weil es keine idiomatischen Pluspunkte sind. "  Und es scheint mir, dass Java in das gleiche Loch gefallen ist.  Java sagte: "Nein, wir haben keine Delegierten."  Und in Java gibt es noch kein Konzept für Delegaten, aber in .NET funktioniert dies alles einwandfrei. <br><br>  <b>Sergey:</b> Schau, die Profis sind sehr einfach.  Nochmals zurück zum Ausschuss.  Es gibt einen Tipp - das sind Leute, die Compiler entwickeln.  Und für sie sind die Worte „Null-Kosten-Abstraktion“ genau das, woran sie sich orientieren sollten.  Und das Wort "Vermächtnis" leider. <br><br>  <b>Dmitry:</b> Nun, die Null-Kosten-Abstraktion ist ein Assembler.  Wenn wir im Allgemeinen eine Null-Kosten-Abstraktion wollen, müssen wir alles in Assembler schreiben. <br><br>  <b>Sergey:</b> Es gibt keine Abstraktion. <br><br>  <b>Dmitry:</b> Assembler ist eine Abstraktion über Binärcode.  Es ist nur die zweite Generation, nicht die dritte. <br><br>  <b>Sergey: Bei</b> allen Arten von „praktischen Dingen“ stellt sich heraus, dass nicht klar ist, wie sie schnell funktionieren sollen. <br><br>  <b>Dmitry:</b> Lass sie langsamer arbeiten.  Die Idee mit asynchronen Iteratoren, Coroutinen, all dies - in .NET mit C # weiß das Ertragsschlüsselwort nicht mehr, wie viele Releases großartig funktionieren.  Ja, hinter den Kulissen werden riesige Staatsmaschinen gebaut, nur Magie.  Aber async / await baut auch Magie auf und in Iteratoren.  Aber jeder benutzt es und es ist wirklich praktisch. <br><br>  <b>Sergey:</b> Coroutinen tragen zu den Pluspunkten bei, hallo. <br><br>  <b>Dmitry:</b> Nun ja, es werden Fortschritte gemacht.  Aber Coroutinen tauchen jetzt auf, nicht vor 10 Jahren. <br><br>  <b>Sergey:</b> Noch einmal.  Die Pluspunkte sind älter, und meiner Meinung nach sinkt die Entwicklungsgeschwindigkeit mit der Anhäufung der Codebasis.  Es hängt natürlich alles davon ab, ob der Wunsch besteht, die Legacy-Unterstützung aufrechtzuerhalten.  Für die Profis ist dies eine prinzipielle Position.  Das heißt, der Code, den Sie in den 80er Jahren geschrieben haben, wird jetzt von einem modernen Compiler kompiliert. <br><br>  <b>Dmitry:</b> Ja, aber Sie kompilieren den Code, den Sie in C # 1.0 geschrieben haben, mit einem modernen Compiler. <br><br>  <b>Sergey:</b> Das ist nicht wahr.  Ganz am Anfang der Diskussion sagte ich, dass ein Update für meine frühen Versionen von .NET eingetroffen ist und plötzlich alle Programme nicht mehr funktionieren. <br><br>  <b>Dmitry:</b> Vielleicht haben sich die von Ihnen verwendeten APIs gerade geändert.  Hier müssen Sie die Bibliothek und die Programmiersprache trennen. <br><br>  <b>Sergey:</b> Ich hatte nichts, nur C #.  Ich war jung, das waren die ersten Jahre. <br><br>  <b>Dmitry:</b> Ich erinnere mich nur an eine grundlegende Änderung in C # 4 - eine kleine Änderung im Verhalten von foreach.  Natürlich könnte in Version 1.x alles turbulenter sein, aber jetzt sind wir definitiv nicht in der Phase, in der jemand plötzlich etwas kaputt macht. <br><br>  <b>Anatoly:</b> Nun, offiziell hält Microsoft an der Position fest, die Abwärtskompatibilität streng überwacht. Sie testen neue Versionen auf einer Vielzahl von Computern und Codebasen.  Vielleicht hattest du einen Fehler oder so etwas. <br><br>  <b>Dmitry:</b> Im Allgemeinen überwacht .NET auch die Abwärtskompatibilität, aber die Geschwindigkeit des Fortschritts ist sowohl in C ++ als auch in Java gestiegen. <br><br>  <b>Sergey:</b> Es scheint mir, dass es eine große Rolle gespielt hat, dass dies zunächst von einer Firma vorangetrieben wurde.  Da C ++ ursprünglich im Ausschuss war - und dies ist Politik -, versuchen alle, ihre Entscheidung voranzutreiben, und dies ist wie eine Senatssitzung in Star Wars. <br><br>  <b>Dmitry:</b> Sie argumentieren also, dass wir alle Geiseln der Ausschüsse sind, die nicht von Innovationen getrieben werden? <br><br>  <b>Sergey:</b> Das Problem ist, dass Sie keine Lösung wählen, die alle zufriedenstellt.  Das Tool ist so weit verbreitet, dass es von vielen Unternehmen verwendet wird.  Sie die gleichen Coroutinen erinnerten sich: Warum haben sie sie spät erhalten?  Weil Microsoft anscheinend nicht mit Google übereinstimmen konnte.  Es gab zwei Implementierungen: Ich kann mich nicht erinnern, wer hinter Stackful und wer hinter Stackless steckt, konnte aber nicht zustimmen.  Da beide Unternehmen groß sind, verfügen sie über riesige Codebasen, die bereits eine Lösung enthalten, und sie weigern sich, diese neu zu schreiben. <br><br>  <b>Dmitry:</b> Aus der Sicht des Lesers wird man das Gefühl haben, dass sie von einem hohen Glockenturm auf ihn gespuckt haben, weil es Unternehmensinteressen gibt, sie sich mit Verliebten beschäftigen, und all dies scheint Sie nicht zu betreffen - gehen Sie, Lakaien, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„lassen Sie sie Kuchen essen“</a> . <br><br>  <b>Sergey:</b> Im Gegenteil.  Das Komitee versucht zu wählen, damit ein gewöhnlicher Mensch nicht leiden muss.  Und oft ist es schwer. <br><br>  <b>Dmitry:</b> Nun, ich kann für mich selbst sagen, dass ich nicht leiden werde, wenn die Nullkosten irgendwohin gehen, aber es wird eine flexible Möglichkeit geben, durch den Binärbaum zu gehen und auf verschiedene Weise ohne Zeitvariablen zu iterieren.      yield,     -   - —    ,   ,      ,  ,     - . <br><br> <b>:</b> , ,           ,        ,      - . <br><br> <b>:</b>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost</a> . <br><br> <b>:</b> ,  . Boost , ,   , …  -        .    std::string,  ,    .    size(),  length(),      :  ,    -  ?    -  ,    ,     .   , .  ,  , ,       .      ,    ,        ,   -  . <br><br><img src="https://habrastorage.org/webt/nh/k7/cd/nhk7cdikdhqxbdfj52qibe_pybo.jpeg"><br><br><h2>  Zusammenstellung </h2><br> <b>:</b>            , , ,    .       ? <br><br> <b>:</b>      , ,      «»,    . <br><br> <b>:</b>  . <br><br> <b>:</b>    embedded-,      include,  ? <br><br> <b>:</b>       .   embedded  -. <br><br> ,     , -  ?   ,    ,     .     ? <br><br> <b>:</b>  .   150 .   -     ,   .  . <br><br> <b>:</b>      ,    ! <br><br> <b>:</b>   ,     Steam, , , 64 . ,  150   ? <br><br> <b>:</b> , , . <br><br> <b>:</b>       ,        -.         ?     ,  ,      ,   —  ,    zero cost abstractions  .       -? <br><br> <b>:</b>       ,  ,       ,   , ? <br><br> <b>:</b>    ,     .      ,    ,    . <br><br> <b>:</b> ,      ,    ,   .     — ,     .     ,    .     ,   ,  .     ,  .    -.      C. <br><br> <b>:</b>   .      «».       : ,            .  ,    ,   ,     .      .  ,       . <br><br> <b>:</b> ,   .     . ,  .      proposal.    . <br><br> <b>:</b>   ,    proposal.      ,       « »: ,  STL  ,    . ,  -   ,      . <br><br> <b>:</b> STL        . STL  .  ,    ,   STL  —  ,    ,      . <br><br> <b>:</b>  ,   —   ,    ?   ,     greenfield.    brownfield development,   .   — ,  .   —  .   ? <br><br> <b>:</b>  ,  .   ,   ,    .   ,   .      ,   ,     . G++  , Clang  .   . <br><br> <b>:</b>  , ,      ,     .  «    ,   A,  B».     ,      .NET,         .  ,  ,     ,         ,       ,       ? <br><br> <b>:</b>  ,  ,     . ,    C++ 2.0.  ++C++.      ,     C. <br><br> <b>:</b>  ,    .          ,   ,  . ,  , ,   ,  #include  #import  -    —   .  ,           . ,   ,    ,           , . <br><br>     .    ,       .    , ,       ,      C#  C++,             . <br><br> <b>:</b>    ,      ,     10  .     ,  ,   ,     ,    ,       ,   .         « »,      .      ,        . <br><br> C# ,      C++.   ,     C#     .       ,   ,   .      ,  ,     , ,  JIT' —  ,   ,         -   (    int).  ,     ,   ,     ,    . <br><br> <b>:</b> ,  ,   ,   C#       —     .  ,    ,   C++  .  ,     .  ( ,   ) —   cutting edge.    ,     UI-  C++,      ,   .   C# — .  C++   ,   . <br><br>       ,   . ,     ,       ,    C++   ,  ,   , . ,     . <br><br>         ,  C#     Microsoft.   ,    .NET Foundation,      ,   ,   Microsoft.   ,             . <br><br><hr><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C++ Russia</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext</a> .  :    ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469467/">https://habr.com/ru/post/de469467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469457/index.html">Wohin Extravaganza führt</a></li>
<li><a href="../de469459/index.html">Anschließen von IoT-Geräten in der Smart City</a></li>
<li><a href="../de469461/index.html">"Zu den Sternen": Anti-Kosmische "Apokalypse heute"</a></li>
<li><a href="../de469463/index.html">Trends und Prognosen in der Verarbeitung natürlicher Sprache</a></li>
<li><a href="../de469465/index.html">Initialisierung in modernem C ++</a></li>
<li><a href="../de469471/index.html">"5 Cent", um über Sorten zu sprechen</a></li>
<li><a href="../de469475/index.html">Der Aufstieg und Fall von Flash, dem nervigen Plugin, das das moderne Web geprägt hat</a></li>
<li><a href="../de469477/index.html">Apple ist an der Zeit, den Vergleich von iPad und PC einzustellen</a></li>
<li><a href="../de469479/index.html">Woher kommt die Quantenwahrscheinlichkeit?</a></li>
<li><a href="../de469491/index.html">Interaktion mit dem Asterisk-Server über eine Java-Anwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>