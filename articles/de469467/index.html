<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öïÔ∏è üõåüèΩ ü§≠ C ++ vs C # üßëüèº‚Äçü§ù‚Äçüßëüèº üèø üóÉÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder wei√ü, dass es nichts D√ºmmeres gibt, als zu argumentieren, "welche Sprache besser ist". Zum Beispiel besser f√ºr was? Verschiedene Sprachen sind i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vs C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469467/"><img src="https://habrastorage.org/webt/ud/4s/-_/ud4s-_jhcan8lv7ei9kfabnsszo.jpeg"><br><br>  Jeder wei√ü, dass es nichts D√ºmmeres gibt, als zu argumentieren, "welche Sprache besser ist".  Zum Beispiel besser f√ºr was?  Verschiedene Sprachen sind in verschiedenen Nischen erfolgreich - und es ist sinnlos, endg√ºltige Schlussfolgerungen zu ziehen, ohne dies zu ber√ºcksichtigen. <br><br>  Aber was passiert, wenn wir uns an erfahrene Spezialisten wenden, die das alles selbst verstehen und sie bitten, den Holivar C ++ gegen C # zu arrangieren?  Es stellt sich heraus, dass Sie viele interessante Details herausfinden k√∂nnen.  Das Wort "plattform√ºbergreifend" kann auf beide Arten auf beide Sprachen angewendet werden. Was bedeutet dies in der Praxis?  Entwickelt sich C ++ jetzt aktiv?  Hat C # jemals die Abw√§rtskompatibilit√§t unterbrochen?  Die Antworten m√∂gen f√ºr diejenigen offensichtlich sein, die bereits tief in beide Sprachen gleichzeitig vertieft sind, aber es gibt nur wenige solcher Menschen - und alle anderen werden etwas Neues lernen. <br><br>  Von C ++ aus nahm <b>Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">sermp</a> Platonov</b> , Vorsitzender des Programmkomitees der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Russia</a> Conference, teil.  Die C # -Seite wurde von <b>Anatoly Kulakov vertreten</b> - er ist im PC der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext-</a> Konferenz und unter den Leitern von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNetRu vertreten</a> .  Und der Diskussionsleiter, in dessen Leben beide Welten nebeneinander existieren, war <b>Dmitry <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Mezastel</a> Nesteruk</b> . <br><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/sn/rb/_i/snrb_ie2-dnmplhnbfnl_klnvca.jpeg"><br><br>  <b>Dmitry:</b> Guten Tag, Kollegen.  Willkommen zu informellen Zusammenk√ºnften zum Thema Programmiersprachen.  Im Internet werden wir st√§ndig daran erinnert, dass Sprachen nicht verglichen werden k√∂nnen.  Und heute werden wir genau das tun, was Sie nicht k√∂nnen: Vergleichen Sie C ++ mit C # und .NET, deren Vor- und Nachteile.  Stell dich bitte vor. <br><br>  <b>Anatoly:</b> Mein Name ist Anatoly, und heute werde ich f√ºr C # ertrinken, weil ich diese Sprache von Anfang an studiert habe und anscheinend alles dar√ºber wei√ü. <br><br>  <b>Sergey:</b> Hallo, mein Name ist Sergey, ich werde heute f√ºr C ++ ertrinken.  Dima hat richtig gesagt, dass wir die Vor- und Nachteile vergleichen werden.  Jeder nennt es "Profis", es ist bekannt, dass C # in dieser Diskussion ein Minus sein wird.  Ist das richtig, Anatoly? <br><br>  <b>Anatoly:</b> C # hat zwei weitere Pluspunkte!  Daher denke ich, dass dies eine evolution√§re Entwicklung der Vorteile ist, die bereits veraltet sind und fast nirgendwo konkurrieren k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/wy/sj/_pwysj2lxe1ncg6lmuzqxfs2dg0.jpeg"></div><br><br><h2>  Bildung </h2><br>  <b>Dmitry:</b> Ich habe das erste Thema f√ºr unsere Diskussion.  Stellen Sie sich vor, neue Studenten kommen an die Universit√§t, sie brauchen die erste Sprache.  Was sollte Ihrer Meinung nach die erste Sprache sein, die Menschen in ihrem ersten Jahr erhalten: C ++, C # oder Assembler im Allgemeinen? <br><br>  <b>Sergey:</b> Ich habe einige Zeit unterrichtet, daher habe ich eine etablierte Meinung.  Ich verstehe, dass wir hier diskutieren werden, welche Sprache besser ist, und ich stehe f√ºr C ++ ... Aber um C ++ zu lernen, m√ºssen Sie die Architektur des Computers verstehen.  Und damit das gro√üe Problem, Studenten zu unterrichten (zumindest an der Universit√§t, an der ich unterrichtet habe).  Und um Algorithmen und andere Dinge zu lehren, ben√∂tigen Sie wahrscheinlich etwas, das sich nicht auf die Infrastruktur in der Sprache selbst konzentriert.  Hier war Eiffel ein Versuch, dies zu tun, aber es gibt auch viel Magie.  Daher w√ºrde ich sagen, dass keine unserer beiden Sprachen geeignet ist. <br><br>  Das Programmieren ist anders und es ist nicht das ‚ÄûProgrammieren‚Äú, das lehrt, sondern Algorithmen, Datenstrukturen und so weiter.  Es ist m√∂glich, dass es sinnvoll ist, f√ºr jedes Thema ein eigenes Instrument auszuw√§hlen.  Verstehen Sie eine Art von Lisp-Datenstrukturen.  Und C ++ sollte dementsprechend gegeben werden, nachdem die Sch√ºler etwas √ºber Architektur verstanden haben.  Und dann wird es m√∂glich sein zu verstehen, warum all diese Schmerzen und Leiden.  Ich werde nicht einmal argumentieren, dass es bei den Pluspunkten um Schmerz geht. <br><br>  <b>Anatoly:</b> Ja, ich stimme vollkommen zu, dass Sie Objekte trennen und nicht in die ‚ÄûProgrammierung‚Äú einf√ºgen und alles in einer Sprache h√§mmern m√ºssen.  Aber wenn Sie an dem Punkt angelangt sind, an dem Sie die Grundlagen, Grundlagen und Algorithmen gelernt haben und anfangen, eine industrielle Sprache zu w√§hlen, ist C # nat√ºrlich viel besser.  Weil es Sie nicht zwingt, all diese R√ºckst√§nde auf der Ebene von Architekturen, Speicherbytes und anderen ‚ÄûSonnenunterg√§ngen von Hand‚Äú zu lernen.  Es gibt eine sofort verst√§ndliche Sprache, eine einfache Syntax und in dieser Sprache k√∂nnen Sie ab dem ersten oder zweiten Jahr ganz greifbares Geld verdienen. <br><br>  <b>Dmitry:</b> Es gibt ein Argument, dass es eine Art Sakrileg ist, Anf√§ngern keine Dinge wie Hinweise zu geben.  Sie haben ein gro√ües Loch, wenn eine Person nicht versteht, dass beispielsweise ein Link tats√§chlich nur die Adresse einer Variablen im Speicher ist.  Was denkst du dar√ºber? <br><br>  <b>Anatoly:</b> Vor 20 Jahren war dies der Fall, als Computer nicht gen√ºgend Speicher, nicht gen√ºgend Festplatten und andere Dinge hatten.  Schauen Sie sich diese Javaskripte an, sie ziehen 500 Megabyte Bibliotheken in jede "Hallo Welt".  Wie viel nehmen sie in Erinnerung?  Was ist ihre Leistung?  Was sind die Links dort?  Ja, das interessiert niemanden.  Die Hauptsache ist, schnell etwas in der Produktion zu rollen und freizugeben.  Ich behaupte nicht, dass dies ein guter oder richtiger Weg ist, ich argumentiere, dass es notwendig ist, sich zusammen mit den Realit√§ten zu √§ndern.  Vielleicht ist es jetzt nicht so wichtig, wie viel Ihr Link kostet. <br><br>  <b>Sergey:</b> Wahrscheinlich je nachdem wo.  Soweit ich wei√ü, war Dmitry am algorithmischen Handel interessiert - ich kann mir gut vorstellen, wie er Bibliotheken auf JS aufruft, um einen Auftrag an die B√∂rse zu senden. <br><br>  <b>Dmitry:</b> Nun ja, nat√ºrlich verwendet in der Praxis dort niemand solche Sprachen.  Obwohl dies theoretisch m√∂glich sein k√∂nnte: Vergessen wir nicht, dass nicht schwaches Geld in die JS-Infrastruktur geworfen wird.  Engines, die die JS-Kompilierung zu allem und jedem machen.  Viele betrachten diese Sprache als die erstklassige Sprache f√ºr alles im Allgemeinen. <br><br>  Nat√ºrlich ist der Algo-Handel heute eine von einer solchen Disziplin entfernte Disziplin, aber der Algo-Handel und die Finanzmathematik als Ganzes sind im Allgemeinen ein spezifischer Bereich.  Es dominiert nur C ++.  Und es √ºberwiegt teilweise aufgrund der Tr√§gheit, einfach aus historischen Gr√ºnden: Am Anfang waren alle in C ++, und dieser Bereich ist konservativ. <br><br>  <b>Sergey:</b> Dem stimme ich nicht zu.  Ich arbeite jetzt im Bereich Fintech, und Kollegen, die seit Beginn des algorithmischen Handels hier sind, sprechen √ºber gro√üe Unternehmen, die zuerst in Java geschrieben haben.  Anfangs kam Java mit dem algorithmischen Handel zurecht, aber als der Markt zu wachsen begann und Konkurrenten mit C ++ auftauchten, konnten sie es irgendwann einfach nicht mehr, sie schafften es nicht, alles effizient zu erledigen ... Also begann nicht jeder im algorithmischen Handel mit C ++.  Nur diejenigen, die nicht dar√ºber geschrieben haben, sind gestorben.  Solch eine nat√ºrliche Auslese. <br><br>  <b>Dmitry:</b> Eigentlich kann man es weiter nehmen.  Es gibt viele Beispiele, bei denen selbst gro√üe Banken ihre Algorithmen in einem Excel-Dokument speichern.  Sie verwenden Excel dann auch als Server, um all dies zu berechnen.  Es gibt h√∂llische Bremsen, aber alles h√§ngt davon ab, ob Sie Hochfrequenzhandel betreiben (oder generell etwas Hochfrequentes).  Wenn Sie ein Market Maker sind, ist es selbstverst√§ndlich, dass Sie eine hohe Leistung ben√∂tigen, und da das Gesch√§ft nicht einmal auf C ++ beschr√§nkt ist, besch√§ftigen wir uns mit Hardware und HDL-Sprachen. <br><br>  Unsere Diskussion dreht sich aber nicht nur um algorithmischen Handel, sondern auch um einfache Dinge.  Hier gebe ich ein Beispiel.  Im Zusammenhang mit dem Bau musste ich mehrere kleine Anwendungen schreiben, in denen verschiedene Dinge berechnet wurden: zum Beispiel, wie man Steine ‚Äã‚Äãum die Kontur eines Hauses legt.  Und ich kann mir kaum vorstellen, wie man solche Dinge in C ++ macht, weil dort alles, was mit der Benutzeroberfl√§che zu tun hat, schw√§cher ist.  Es gibt nur ein Framework, Qt, und selbst das Schreiben darauf ist sehr schwierig.  Und wenn ich mich f√ºr C #, f√ºr WinForms, hinsetze, mache ich sofort die Anwendung. <br><br>  <b>Anatoly:</b> Nun, der visuelle Teil war schon immer eine St√§rke von C #.  Microsoft hat viel in Formen und sogar in plattform√ºbergreifende Formen und allgemein in die Visualisierung investiert.  Wenn es sich also um visuelle Desktop-Anwendungen handelt, scheint es mir, dass die Pluspunkte im Allgemeinen weit hinterherhinken. <br><br>  <b>Sergey:</b> Nun, es kommt wie immer darauf an.  Ich mag UI wirklich nicht, aber auf den Pluspunkten muss ich es st√§ndig tun.  Es scheint JS zu bringen und nur mit den Profis zu interagieren.  Aber ich habe mit Embedded gearbeitet und da ist es schwer.  Die Leute kauften eine Art schnelle, teure Engine, aber sie konnte das normale Rendering der in JS geschriebenen Benutzeroberfl√§che immer noch nicht bew√§ltigen.  Und nachdem ich das alles auf Qt umgeschrieben hatte, stellte sich heraus, dass es √ºbertaktet war.  Gew√∂hnliche Geschichte. <br><br><img src="https://habrastorage.org/webt/kc/9t/uf/kc9tufwhjjwnla-uga_j8abdwqg.jpeg"><br><br><h2>  Plattform√ºbergreifend gegen plattform√ºbergreifend </h2><br>  <b>Sergey:</b> Ich wollte hier klarstellen.  Ich wei√ü nicht viel √ºber C #, ich habe es vor sehr langer Zeit in den ersten Versionen selbst angefasst (damals war ich von der Abw√§rtskompatibilit√§t betroffen).  Die Frage ist also: Wird es immer noch nur von Microsoft entwickelt? <br><br>  <b>Anatoly:</b> Nein, jetzt ist es plattform√ºbergreifend, offen und gem√§√ü ISO (ECMA-334 und ISO / IEC 23270) verifiziert.  √úbrigens hat C ++ meines Wissens noch keine offene ISO-Spezifikation, sondern nur kostenpflichtig.  Und C # ist dagegen v√∂llig offen.  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Foundation</a> entwickelt, die von vielen Unternehmen (einschlie√ülich Google, Amazon und Samsung) entwickelt wurde.  Ich kenne noch nicht einmal eine offenere Sprache als C # und seine .NET-Plattform. <br><br>  <b>Sergey:</b> Nun, Haskell. <br><br>  <b>Anatoly:</b> √úbrigens, der Autor von Haskell arbeitet bei Microsoft Research und hat gro√üe Anstrengungen unternommen, um alle m√∂glichen coolen Dinge in C # erscheinen zu lassen - zum Beispiel eine statische √úberpr√ºfung, eine Art Reflexion, von der Sie wahrscheinlich nicht einmal tr√§umen k√∂nnen. <br><br>  <b>Sergey:</b> Sie k√∂nnen tr√§umen und sogar in diese Richtung wird gearbeitet.  Aber es ist klar, dass alles seinen eigenen Preis hat.  In C ++ weigern sie sich einfach, diesen Preis zu zahlen. <br><br>  <b>Anatoly:</b> Welches?  Sie werden f√ºr zwei Stunden zusammengestellt, was k√∂nnte der Preis sonst sein? <br><br>  <b>Sergey:</b> In C ++ das Prinzip der Nullkostenabstraktion.  Das hei√üt, eine virtuelle Maschine ist keine Null-Kosten-Abstraktion, oder?  Wir m√ºssen uns damit abfinden. <br><br>  <b>Dmitry:</b> Nun, aber eine virtuelle Maschine kann beispielsweise Code f√ºr eine bestimmte Architektur verdecken.  Wenn ich in C ++ die AVX-Anweisung auf einem Computer ohne AVX verwende, wird mein Prozess nur beendet.  Ich w√ºrde sagen, dass dieses Argument nicht ganz richtig ist, weil JIT theoretisch - ich betone theoretisch - das tun kann, was C ++ nicht verf√ºgbar ist.  Optimierung zum Zeitpunkt des Starts. <br><br>  <b>Sergey:</b> Aber in C ++ k√∂nnen Sie w√§hrend der Kompilierung vollst√§ndig steuern, welche Anweisungen Sie ben√∂tigen.  In diesem Fall steuern Sie es nicht mit Ihren H√§nden, sondern geben das Instrument (Compiler) auf.  Schauen Sie, welche Anweisungen in dieser Architektur enthalten sind, welche Anweisungen ... <br><br>  <b>Dmitry:</b> Das ist verst√§ndlich.  Aber wir k√∂nnen es so formulieren: Da es eine Million Plattformen gibt, werden wir niemals ein Ideal bekommen, weil wir nicht eine Million Versionen mit unterschiedlichen Kompilierungsflags ver√∂ffentlichen k√∂nnen.  Richtig?  Wir ver√∂ffentlichen normalerweise x86 und x64, teilen es jedoch nicht in einige Untergruppen auf. <br><br>  <b>Sergey:</b> Warum k√∂nnen wir nicht?  XXI Jahrhundert.  Halten Sie Docker mit verschiedenen Parametern, das ist alles. <br><br>  <b>Dmitry:</b> Wenn wir einen Endclient haben, der unsere Anwendung herunterl√§dt, m√∂chte er eine bestimmte Bin√§rdatei herunterladen.  Und in dieser Bin√§rdatei k√∂nnen wir nur √ºberall bleiben, wenn.  Wie "Wenn cpuid so und so ist und avx-Unterst√ºtzung so und so ist, dann verwenden wir den Algorithmus Version 25".  Daher ben√∂tigen wir 25 verschiedene Versionen desselben Algorithmus, da die Beschleunigung von den Plattformen abh√§ngt und plattformabh√§ngig ist. <br><br>  <b>Sergey:</b> Ich stimme wahrscheinlich zu.  Es ist nur so, dass ich ehrlich gesagt nie ein nicht internes Produkt erstellt habe.  Ich bin haupts√§chlich in Unternehmen t√§tig, die ihr Produkt selbst verwenden. <br><br>  <b>Dmitry:</b> Nat√ºrlich ist die beste Option, wenn Sie die Architektur vorhersehbar kennen.  In diesem Fall zwingt Sie streng genommen niemand, √ºberhaupt x86-Anweisungen zu verwenden.  Sie k√∂nnen eine bestimmte Karte (z. B. Nvidia Tesla) nehmen und tun, was Sie wollen.  Dies ist auch mein Ansatz, ich kontrolliere meine Architektur.  Aber wenn Sie Massenmarktentscheidungen f√ºr den Benutzer treffen ... Wenn Sie einen bedingten ReSharper verwenden, kann er die GPU-Beschleunigung nicht einfach f√ºr beliebige Indizes verwenden.  Weil die GPU-Beschleunigung keine tragbare Sache ist. <br><br>  <b>Sergey:</b> Eigentlich gibt es Ans√§tze (jetzt m√ºssen Sie wahrscheinlich nicht mehr auf Details eingehen), es gibt interessante Leute (der Autor des Ansatzes ist anscheinend jetzt auch zu Microsoft gewechselt).  Hier auf unserer Konferenz im vorletzten Jahr gab es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> dar√ºber, wie man ein solches Programm schreibt, der selbst versteht, was wo ist (relativ einfach, wieder Null-Kosten-Abstraktionen).  So k√∂nnen Sie im Handumdrehen den Code im CUDA-Stil ausw√§hlen und gegebenenfalls korrekt neu erstellen ... <br><br>  <b>Dmitry:</b> Eigentlich versucht CUDA selbst, dieses Problem zu l√∂sen, weil es in CUDA eine bestimmte Zwischenschicht von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PTX gibt</a> , die sich damit befasst.  Dies ist jedoch immer noch sehr schwierig, da sich das Eisen evolution√§r radikal ver√§ndert und es sehr schwierig ist, √ºberhaupt mitzuhalten.  Wenn wir uns beispielsweise die Verwendung der GPU-Beschleunigung in Adobe-Produkten ansehen, verwenden sie einen sehr engen Abschnitt der verf√ºgbaren Technologien.  Wenn Ihre Karte korrekt ist - dann ist alles in Ordnung.  Aber wenn es ein bisschen exotisch ist, ist diesbez√ºglich nichts garantiert. <br><br>  <b>Anatoly:</b> In dieser Diskussion haben wir ein ziemlich wichtiges Thema angesprochen, einen solchen Mythos: C ++ wurde vor vielen Jahren als solche plattform√ºbergreifende Sprache deklariert, aber im Moment ist plattform√ºbergreifend viel mehr in C #.  Eine einzige Bin√§rdatei funktioniert √ºberall dort, wo .NET unterst√ºtzt wird, und dies ist fast √ºberall. <br><br>  <b>Sergey:</b> Nun, das ist auch ziemlich unbegr√ºndet.  Als eine Person, die den gr√∂√üten Teil meines Lebens in Embedded verbracht hat, habe ich selten gesehen, dass .NET von der Toolchain des Hardwareherstellers unterst√ºtzt wird.  Unternehmen, die Eisen produzieren, verwenden dasselbe G ++ oder Clang oder lassen es Code f√ºr ihre Plattform generieren. <br><br>  <b>Dmitry:</b> Ja, aber das Problem ist, dass sie jedes Mal etwas von C ++ verlieren.  Zum Beispiel verwendete Nokia eine Variante von C ++, aber ihr C ++ war mit verr√ºckten Wendungen und verr√ºckten APIs ausgestattet, die alle w√ºtend machten.  Das hei√üt, es ist nicht nur C ++, sondern C ++ f√ºr die eine oder andere Plattform.  Und dann beginnen die Probleme.  Nehmen Sie zum Beispiel die gleiche CUDA.  Es ist, als ob es nur die Profis durchlassen sollte, es ist √ºberhaupt kein Compiler, sondern nur ein Treiber.  Trotzdem hat sie Probleme damit, dass sie immer noch ein Framework verwendet, um CUDA-Dateien in GPU- und CPU-Teile zu zerlegen.  Und manchmal gelingt es ihr nicht. <br><br>  <b>Sergey: Das habe</b> ich nicht so gemeint.  Es ist nur so, dass, wenn ich h√∂re, dass .NET √ºberall l√§uft, die meisten meiner Arbeitsbiografien zur√ºckfallen.  Wenn Sie eine Hardware mit einem benutzerdefinierten Prozessor kaufen, wird diese nur mit der G ++ - Lieferung geliefert.  Und es gibt gew√∂hnliches C ++, das G ++ von der Toolchain in Maschinencode konvertieren kann, der von diesem bestimmten Prozessor unterst√ºtzt wird. <br><br>  <b>Dmitry:</b> Aber auch dies muss wieder zusammengesetzt werden ... <br><br>  <b>Sergey:</b> Nat√ºrlich. <br><br>  <b>Dmitry:</b> Und die Idee, dass wir den vorhandenen Plus-Code in das St√ºck Eisen ziehen - diese Idee funktioniert auch nicht, weil Sie pl√∂tzlich Ihr regul√§res x86 irgendwohin gezogen haben, wo Sie 8 Gigabyte Speicher f√ºr alles √ºber alles haben und nicht Erweitern: Beispielsweise gibt es keinen Austausch auf die Festplatte, da keine Festplatte vorhanden ist und kein Zugriff darauf vorhanden ist.  Dies ist, wenn wir √ºber Portabilit√§t sprechen.  Kommt nat√ºrlich auf die Ziele an. <br><br>  <b>Anatoly:</b> Profis arbeiten auf mehr Ger√§ten, und nat√ºrlich ist Embedded einer der st√§rksten Teile.  Aber normalerweise m√ºssen Sie Ihren Code irgendwie an die Plattform anpassen.  Das ist schlecht  Ich kann eine gro√üe Anzahl von Plattformen, Architekturen und Modellen mit einem Code abdecken.  Au√üerdem musste ich √ºber jede einzelne Plattform nachdenken: Wo und unter welchen Bedingungen wird sie dort beginnen?  Und es ist sehr schlimm, es h√§lt sich sehr zur√ºck. <br><br><img src="https://habrastorage.org/webt/f1/wn/1z/f1wn1zxi80gplsj3bpidl9fpr1i.jpeg"><br><br><h2>  Stabilit√§t, Kompatibilit√§t, Sprachentwicklung </h2><br>  <b>Dmitry: Es</b> wurden auch Null-Kosten-Abstraktionen erw√§hnt, aber das Problem ist, dass dies einen enormen Preis hat.  In .NET gibt es beispielsweise ein Konzept eines Aufz√§hlungstyps und einer IEnumerable-Schnittstelle.  Und f√ºr jeden Typ, zum Beispiel ein Array, k√∂nnen Sie einen Iterator verwenden und durchlaufen.  Aber in C ++ gibt es keine solche Idee.  Aufgrund der Null-Kosten-Abstraktion gibt es, um die Sammlung zu umgehen, einige begin () und end (), es gibt Regeln f√ºr ihre Arbeit, und all dies ist viel komplizierter (insbesondere f√ºr diejenigen, die mit dem Programmieren beginnen).  Dies ist ein direktes Problem: Wie kann man ein Array von A bis Z umgehen? <br><br>  <b>Sergey:</b> Wenn ich richtig verstehe, wovon Sie sprechen ... Wenn Sie nur einen Container von Anfang bis Ende umgehen m√ºssen, schreiben Sie jetzt einfach, wie in Python. <br><br>  <b>Dmitry:</b> Das ist alles wunderbar.  Aber Sie verwenden zum Beispiel keinen Polymorphismus daf√ºr.  Man kann nicht sagen, dass ich hier eine Funktion habe, die einen bestimmten Wert erh√§lt, der a priori aufgez√§hlt wird.  Sie k√∂nnen nicht sagen, dass ich einen Wert habe, der die Schnittstelle implementiert, und diese Schnittstelle hat beispielsweise einen Iterator. <br><br>  <b>Sergey:</b> Wir reden √ºber welches C ++?  √úber C ++ im Allgemeinen, C ++ der Zukunft, C ++, die jetzt als Standard akzeptiert werden? <br><br>  <b>Dmitry:</b> Nun, wenn es in den Profis der Zukunft sein wird ... <br><br>  <b>Sergey:</b> In C ++ 20 ist dies bereits vorhanden.  Sie k√∂nnen bereits sagen, Sie k√∂nnen sich sogar deklarieren.  Dies sind keine Schnittstellen, aber wie man es richtig sagt ... Im Allgemeinen k√∂nnen Sie erkl√§ren, dass Ihr Typ diese und jene Bedingungen erf√ºllen muss.  Zum Beispiel hat es Anfang und Ende, die einen Iterator zur√ºckgeben.  Und ein Iterator ist ein so vorbereitetes Konzept in der Standardbibliothek.  Er sagt was es ist, beschreibt.  Iteratoren sind auch unterschiedlich.  Im Allgemeinen versuchen wir, es f√ºr Menschen bequemer zu machen. <br><br>  <b>Dmitry:</b> Es scheint mir, dass dies aus der Tatsache entstanden ist, dass die Leute gerade erkannt haben, dass es schwierig ist, ohne die Konzepte der Iterierbarkeit eines Objekts zu leben.  Weil es nicht klar ist, wie man verallgemeinerte Dinge schreibt.  Ja, eine Abstraktion ohne Kosten bedeutet, dass wir bei der Suche nicht die Kosten haben, um die V-Tabelle herumzulaufen ... In .NET gibt es beispielsweise nur eine bestimmte Methode.  Und um es zu finden, m√ºssen wir nat√ºrlich Anstrengungen unternehmen, die die Pluspunkte ablehnen.  Aber unter dem Gesichtspunkt der Benutzerfreundlichkeit ist das Endergebnis nicht so gut, w√ºrde ich sagen. <br><br>  <b>Sergey:</b> Nat√ºrlich muss es ein Gleichgewicht geben.  Sie k√∂nnen nicht alles auf einmal haben. <br><br>  <b>Anatoly:</b> Man wundert sich, wie viele Jahre vergangen sind.  Alternative Sprachen entwickeln sich, und in ihnen erscheinen solche grundlegenden Dinge von Anfang an.  Jetzt holen sie etwas Wesentlicheres und Interessanteres ein.  Und die Pluspunkte sitzen zehn Jahre lang mit derselben unverst√§ndlichen Syntax, obskuren Abstraktionen, unverst√§ndlichen Kr√ºcken und unterentwickelt.  Sie k√∂nnen dies als einen der Minuspunkte setzen. <br><br>  <b>Sergey:</b> Na komm schon!  Was bedeutet "schlecht entwickelt"? <br><br>  Sie haben ein Komitee erw√§hnt - C ++ hat auch ein ISO-Komitee, das es entwickelt.  Dort gibt es Vertreter, einschlie√ülich Microsoft, die stark ertrinken, weil "Sie dies nicht tun k√∂nnen, weil wir viel Verm√§chtnis haben, das wir unterst√ºtzen m√ºssen".  Nur C ++ ist die Sprache, die bereits gehalten wird.  Und nat√ºrlich geht er sehr vorsichtig.  Eine der Hauptaufgaben (die Straustrup bereits beim Erstellen deklariert hat) ist die Kompatibilit√§t mit C. Aber jetzt hat sich C sogar ziemlich weit entwickelt. Sie m√ºssen angeben, mit welchem ‚Äã‚ÄãC kompatibel ist. <br><br>  Und meiner Meinung nach entwickelt sich C ++ jetzt in einem enormen Tempo.  In Bezug auf Konzepte und so weiter - tats√§chlich w√§chst nat√ºrlich alles nicht durch Iterierbarkeit.  Tats√§chlich folgt die Entwicklung dem, was Alexander Stepanov auch beschrieben hat - einem der Autoren dessen, was wir jetzt als "generalisierte Programmierung" bezeichnen, der Person, die tats√§chlich Vorlagen, Generika usw. in C ++ gezogen hat.  Um ehrlich zu sein, ich wei√ü nicht, wie sehr das Komitee von diesen Ideen inspiriert ist, aber es scheint mir, dass es definitiv einen Schnittpunkt mit ihnen gibt. <br><br>  <b>Anatoly:</b> Es scheint, dass all diese Metaklassen, Iteratoren, wirklich Inspiration sind, was schon vor vielen Jahrzehnten war.  Selbst wenn Sie Metaprogrammierung, Vorlagen und Makros verwenden - all diese Leute haben lange Erfahrung, Erfahrung und es gibt viel einfachere, offensichtlichere und verst√§ndlichere Konzepte.  In anderen Sprachen wird dies alles millionenfach besser und schneller erledigt, mit Typensicherheit, √úberpr√ºfung der Kompilierungszeit und so weiter. <br><br>  <b>Sergey:</b> Warten Sie, Sie sprechen bereits √ºber etwas, f√ºr das nicht jeder bereit ist zu bezahlen.  Ich m√∂chte nicht, dass mein Programm ohne mein Wissen etwas in der Kompilierungszeit √ºberpr√ºft.  Verstehst du <br><br>  <b>Anatoly:</b> Ich denke, all diese mit Flags k√∂nnen konfiguriert werden.  Sie legen die Optimierungsstufe fest und √ºberpr√ºft Sie entweder oder nicht.  Das ist kein Problem. <br><br>  <b>Sergey:</b> Oft musst du alles mit deinen H√§nden kontrollieren.  Wissen Sie genau, was los ist.  Weil die Werkzeuge - na ja, das. <br><br>  <b>Dmitry:</b> Es geht nicht einmal um Werkzeuge.  Hier sagt die Tatsache, dass Sprachen wie D und Rust sagen: Nun ja, es gibt so etwas, dass Sie es √ºberpr√ºfen k√∂nnen, wenn Sie auf ein Array-Element zugreifen, aber Sie k√∂nnen es nicht √ºberpr√ºfen.  Und sie geben es einfach dem Benutzer, das hei√üt, Sie k√∂nnen sagen "aber lassen Sie uns die Array-Pr√ºfungen ausschalten", "aber lassen Sie es uns einschalten".  Das hei√üt, eine Art Kontrolle in dieser Hinsicht. <br><br>  <b>Sergey:</b> Es ist nicht klar, wann Sie unsicher und sicher sind, wie in Rust. Ich sehe in diesem Fall beispielsweise keinen Unterschied zu C. <br><br>  <b>Anatoly:</b> Der Unterschied besteht darin, dass Sie sicher und schnell schreiben k√∂nnen.  Und in C muss man gef√§hrlich schreiben.  Na ja, vielleicht schnell.  Stabilit√§t ist manchmal wichtiger als Geschwindigkeit. <br><br>  <b>Dmitry:</b> Wenn wir dieses Thema mit neuen Sprachen vertiefen, gibt es in C ++ Dinge, die im Allgemeinen sehr schwer zu vermitteln sind.  Eine einfache Frage: Welche Gr√∂√üe hat int?  In den meisten Sprachen kennen Sie die Antwort auf diese Frage.  Sie sagen: int ist 32 Bit.  Aber Sie kennen die Profis nicht.  Sie kennen die Gr√∂√üe Ihres Computers, weil Sie sich daran erinnern, aber genau genommen m√∂chten Sie nicht einmal die Basistypen verwenden, da sie nicht deterministisch sind.  Und solche Dinge machen mich w√ºtend, wenn es eine Reihe von Legacy-Ans√§tzen gibt, wie der int, der auf verschiedenen Plattformen unterschiedlich sein wird.  Und jetzt verstehen wir bereits, dass dies nicht m√∂glich ist.  Warum nicht weiter gehen und dieses Problem irgendwie l√∂sen? <br><br>  <b>Sergey:</b> Nun, das ist entschieden.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sexuell √ºbertragbare Krankheiten</a> , die erforderlichen Typen mit fester L√§nge.  Jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zieht</a> der Vertreter Russlands im Ausschuss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein</a> Int von variabler L√§nge (wieder mit Null-Kosten-Abstraktion). <br><br>  <b>Anatoly:</b> Erinnere ich mich richtig daran, dass es sogar eine nicht deterministische Gr√∂√üe eines Zeigers auf eine Methode gibt?  Das hei√üt, unter verschiedenen Compilern und verschiedenen Plattformen sind die Zeiger unterschiedlich? <br><br>  <b>Sergey: Das ist</b> nat√ºrlich Architektur.  Wie k√∂nnen Sie die Gr√∂√üe des Zeigers garantieren, wenn Sie sich in der N√§he der Hardware befinden, wenn Sie 8-Bit und dann 64-Bit verwenden? <br><br>  <b>Anatoly:</b> Und wie kann man danach mit Zeigern rechnen?  Das ist verr√ºckt. <br><br>  <b>Sergey: Ich</b> meine?  Gut, vorsichtig. <br><br>  <b>Anatoly:</b> Ich verstehe.  Der Ansatz ist √ºberall klar und alles wird sorgf√§ltig mit Griffen gesteuert. <br><br>  <b>Sergey:</b> Nun ja.  Auch in modernen C ++ - Standards werden Ans√§tze entwickelt ... Wenn wir √ºber die Wahl sprechen, dann gibt es in den modernen Pluspunkten tats√§chlich die Wahl, ob der Garbage Collector verwendet werden soll.  Es ist nur so, dass GC dort auf Referenzz√§hlern aufgebaut ist. <br><br>  Im Allgemeinen, Kollegen, habe ich das Gef√ºhl, dass Sie Ihr Wissen √ºber moderne Pluspunkte seit langem nicht mehr aktualisiert haben. <br><br>  Leute wie Straustrup, die Teil des Pantheons der Plus-G√∂tter sind, kommen mit vielen Anrufen, um herauszufinden, wie man modernes C ++ lehrt.  Das Problem ist, was die Leute in den C ++ - Kategorien von 2003 denken und in denselben Kategorien unterrichten.  Und in diesem Zusammenhang gibt es interessante neue Projekte und Ans√§tze, es gibt moderne Kurse - sagen wir, die Jungs von Yandex haben einen wunderbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurs gemacht</a> .  Und jetzt in Pluspunkten wird es als schlechte Manieren angesehen, zum Beispiel rein neu zu verwenden und zu l√∂schen. <br><br>  <b>Dmitry:</b> Was Ihren Kommentar zur Aktualisierung von Wissen betrifft ... Die Nuance ist, dass mein Ansatz zum Beispiel darin besteht, das kleine C ++ - Delta zu verwenden, das garantiert f√ºr mich funktioniert und mit dem ich ‚Äûbefreundet‚Äú bin.  Sie sehen, C ++ ist umfangreich.  Es gibt Template-Metaprogrammierung, und alles w√§re in Ordnung, es gibt viel Magie, aber leider ist diese Magie nicht lesbar.  Dies ist ein Code, in dem ein Nichtautor ihn ohne besondere Kenntnisse nicht herausfinden kann, gewisserma√üen eine Black Box.  Und es gibt viele solcher Black Boxes in den Pluspunkten, Bereiche der Dunkelheit, die nicht verdaut werden k√∂nnen ... Ich m√∂chte, ich wei√ü nicht, dass Ihre Option vorhersehbar, gut und ohne Tricks berechnet werden kann. <br><br>  Das einfachste Beispiel betrifft Bereiche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">range-v3</a> und das gesamte Thema).  Einerseits ist das alles gro√üartig: Es gibt Dinge, die seit mehreren Jahren in C # vorhanden sind und die es beispielsweise erm√∂glichen, einen Kalender durch Transformationen der Standardsammlung zu erstellen.  Andererseits ist die Art und Weise, wie es in C ++ implementiert wird, im Vergleich zu C # einfach unangenehm: Es ist schwer und nicht lesbar. <br><br>  <b>Sergey:</b> Das ist Aroma.  Ich mag es im Gegenteil.  So wie ich es verstehe, sind Sie beim Nibler- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> und seiner Pr√§sentation ... <br><br>  <b>Dmitry:</b> Sie sehen, wenn der Operator "oder" zum Filtern einer Sammlung verwendet wird, habe ich sofort Fragen dazu.  Sowohl C # als auch Java haben alles durch den Punkt gemacht, mit den √ºblichen Methoden. <br><br>  <b>Sergey:</b> Und es scheint mir, dass dies von Bash inspiriert ist.  Das hei√üt, es ist nur eine Pfeife. <br><br>  <b>Dmitry:</b> Nun ja, wahrscheinlich erkl√§rt dies etwas in diesem Ansatz. <br><br>  <b>Sergey: Es</b> erkl√§rt viel!  Lassen Sie uns √ºber PowerShell sprechen, da wir √ºber Bash sprechen.  Wer hat PowerShell gesehen? <br><br>  <b>Anatoly:</b> Ich schreibe in PowerShell, einer gro√üartigen Sprache.  Aber auch hier muss das Rohr dort eingesetzt werden, wo es sich befindet und wo die gesamte Architektur von ihm durchdrungen ist.  Nicht, wo Sie eine einzige Aktion ausf√ºhren m√ºssen, und es ist hier idiomatisch schlechte Syntax. <br><br>  <b>Sergey:</b> In Range Pipe ist es nur sehr ... <br><br>  <b>Dmitry:</b> Im Bereich werden sie meiner Meinung nach aus folgendem Grund verwendet ... Ich werde dies sagen: Wenn es in C ++ Erweiterungsmethoden oder Erweiterungsfunktionen g√§be, w√ºrden Sie sie nat√ºrlich verwenden.  Denn das Nat√ºrlichste, wenn Sie eine Sammlung sortieren m√ºssen, ist das Schreiben von "collection. Filter ()".  Und nicht ‚ÄûSammlung |  view :: filter () ". <br><br>  <b>Anatoly:</b> Ich hatte auch den Eindruck, dass Sie 20 Jahre lang in die Beine geschossen, ins Gesicht geschlagen, mit dem Kopf gegen die Wand geschlagen und dann endlich gesagt haben: ‚ÄûNun, jetzt haben wir im 20. Standard alles wunderbar gemacht, jetzt wollen wir unterrichten Die Profis haben Recht. ‚Äú  Ja, niemand will sie richtig unterrichten!  Das hei√üt, es ist ein langfristiger Schmerz. <br><br>  <b>Sergey:</b> Bitte unterrichten Sie nicht.  Was ist das Problem?  Schreiben Sie in C # - handeln Sie darauf, schreiben Sie eingebettet.  Ich habe nichts dagegen. <br><br>  <b>Anatoly:</b> Nun, es gibt enge Nischen, in denen die Profis noch da sind. <br><br>  <b>Sergey:</b> Eingebettet ist eine ‚Äûenge Nische‚Äú ... Im Moment sehe ich in meiner K√ºche ein paar Computer. <br><br>  <b>Dmitry:</b> Jedes Mal, wenn ich mit dem Flugzeug fliege, denke ich: "Verdammt, ich hoffe, diese Pluspunkte haben dort alles gut geschrieben." <br><br>  <b>Sergey:</b> √úbrigens gibt es, soweit ich mich erinnere, haupts√§chlich Ada. <br><br>  <b>Dmitry:</b> Ada dominiert dort, ja. <br><br>  <b>Anatoly:</b> √úbrigens bin ich k√ºrzlich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen ausgezeichneten Artikel</a> gesto√üen, in dem der Autor in verschiedenen Sprachen (ungef√§hr 10) einen Low-Level-Treiber geschrieben hat - einen Netzwerktreiber f√ºr eine 10-Gigabit-Intel-Karte.  Von C bis Swift, JS, Python und nat√ºrlich C #.  Wenn wir uns diese Grafiken ansehen, die er erhalten hat, dann entspricht C # bei gro√üen Chargen (wenn die Startkosten ausgeglichen sind) C und Rust. <br><br><img src="https://habrastorage.org/webt/bk/bp/ur/bkbpuriesi98tzgy1eon4cek8vs.png"><br><br>  Das hei√üt, wenn wir √ºber Leistung sprechen, kann es ein Missverst√§ndnis sein, dass C # irgendwo sehr viel schlechter ist.  Es gibt auch einen funky Bericht von Federico Luis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scratched Metal</a> , in dem er zeigte, wie er den C # -Code f√ºr Prozessorprofiler optimiert hat. <br><br>  <b>Sergey:</b> Nun, es f√§ngt wieder an.  Die Sache ist, dass, wenn Sie anfangen, dieses Java, dieses C #, zu optimieren, es unklar wird, warum Sie nicht auf Pluspunkte schreiben sollten.  Weil Sie spezifisches Wissen ben√∂tigen.  Und wie mir scheint, ist der Vorteil von Sprachen wie C # und Java gleich hoch - keine sehr hohe Eingabeschwelle.  Soweit ich wei√ü, war es genau das, wor√ºber Dmitry sprach: Lesbarkeit des Codes, viel lernen, einige Konzepte schwer zu erkl√§ren und so weiter. <br><br>  <b>Anatoly:</b> Ich arbeite 99% meiner Zeit damit, in ‚Äûnormalem‚Äú C # zu schreiben - sicher, stabil und st√§ndig arbeitend.  Und 1% der Zeit m√∂chte ich eine Art schnellen Code auf niedriger Ebene schreiben.  Und dieses C # erlaubt es mir auch.  Aber mein Hauptwerkzeug ist immer noch stabil, lesbar, ohne Fehler ... <br><br>  <b>Dmitry:</b> Tolya, lassen Sie mich ein einfaches Beispiel geben: Vektorisierung.  Mit der Vektorisierung in .NET ist alles sehr schlecht, obwohl System.Numerics.Vectors langsam ges√§gt wird.  Und wozu f√ºhrt es zum Beispiel meinerseits?  Zu der Tatsache, dass, wenn Sie auf dem Markt herumst√∂bern und eine mathematische Bibliothek f√ºr .NET kaufen, diese auf den Profis geschrieben ist (mit einem vollst√§ndigen Wrapper).  Da es in .NET praktisch keinen Zugriff auf Hardwarebeschleunigung (AVX usw.) gibt, befindet es sich jetzt in einem embryonalen Stadium. <br><br>  <b>Anatoly:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intrinsics wird</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Core 3 ver√∂ffentlicht,</a> wo Sie direkt auf AVX zugreifen k√∂nnen.  Sie sind wirklich in den Kinderschuhen, aber es gibt grundlegende Dinge, und der Rest ist ziemlich bewegend. <br><br>  <b>Dmitry:</b> Sie verstehen, wir haben 2019 auf dem Hof.  Als Benutzer all dieses mathematisch beschleunigten Gutes habe ich nicht darauf gewartet.  Wenn ich also schnell √ºber etwas nachdenken m√∂chte, ist C # f√ºr mich kein Kandidat mehr.  Weil C ++ - Bibliotheken bereits existieren.  Vielleicht ist daf√ºr schon Zeit verloren gegangen. <br><br>  <b>Anatoly:</b> Es scheint mir, dass C # sich in Richtung Plus bewegt und versucht, ihren Markt zu gewinnen.  Aber die Pluspunkte bewegen sich nirgendwo mehr. <br><br>  <b>Sergey:</b> Woher kommt das?  Was bedeutet "Pluspunkte gehen nirgendwo hin"? <br><br>  <b>Anatoly:</b> Wenn sie mir 2019 sagen, dass es Iteratoren im Standard geben wird, wird es einige Fortschritte bei Lambdas geben, scheint mir, dass ... <br><br>  <b>Sergey:</b> Ich wei√ü nicht, warum Sie √ºber Iteratoren und Lambdas sprechen. Ich verstehe nicht, wie der Stein war ... <br><br>  <b>Anatoly:</b> Nicht √ºber Iteratoren, ich habe es falsch ausgedr√ºckt, ich meinte die unz√§hligen Container, die wir zuvor besprochen haben.  Und in der Zwischenzeit haben wir Pattern Matching bekommen. <br><br>  <b>Sergey:</b> Es h√§ngt alles davon ab, ob es notwendig ist oder nicht.  Wir diskutieren den Mustervergleich.  Bisher gibt es jedoch keine Argumente daf√ºr, ob dies bei den Profis erforderlich ist. <br><br>  <b>Dmitry:</b> Ich h√∂re viele √§hnliche Kommentare von den Pluspunkten, die besagen: ‚ÄûObwohl dieser oder jener Ansatz in anderen Sprachen bereits offensichtlich vorhanden ist, wurde er bereits ausgearbeitet, die Leute lieben ihn und bauen darauf L√∂sungen auf. Wir wollen dies immer noch nicht in Pluspunkten. weil es keine idiomatischen Pluspunkte sind. "  Und es scheint mir, dass Java in das gleiche Loch gefallen ist.  Java sagte: "Nein, wir haben keine Delegierten."  Und in Java gibt es noch kein Konzept f√ºr Delegaten, aber in .NET funktioniert dies alles einwandfrei. <br><br>  <b>Sergey:</b> Schau, die Profis sind sehr einfach.  Nochmals zur√ºck zum Ausschuss.  Es gibt einen Tipp - das sind Leute, die Compiler entwickeln.  Und f√ºr sie sind die Worte ‚ÄûNull-Kosten-Abstraktion‚Äú genau das, woran sie sich orientieren sollten.  Und das Wort "Verm√§chtnis" leider. <br><br>  <b>Dmitry:</b> Nun, die Null-Kosten-Abstraktion ist ein Assembler.  Wenn wir im Allgemeinen eine Null-Kosten-Abstraktion wollen, m√ºssen wir alles in Assembler schreiben. <br><br>  <b>Sergey:</b> Es gibt keine Abstraktion. <br><br>  <b>Dmitry:</b> Assembler ist eine Abstraktion √ºber Bin√§rcode.  Es ist nur die zweite Generation, nicht die dritte. <br><br>  <b>Sergey: Bei</b> allen Arten von ‚Äûpraktischen Dingen‚Äú stellt sich heraus, dass nicht klar ist, wie sie schnell funktionieren sollen. <br><br>  <b>Dmitry:</b> Lass sie langsamer arbeiten.  Die Idee mit asynchronen Iteratoren, Coroutinen, all dies - in .NET mit C # wei√ü das Ertragsschl√ºsselwort nicht mehr, wie viele Releases gro√üartig funktionieren.  Ja, hinter den Kulissen werden riesige Staatsmaschinen gebaut, nur Magie.  Aber async / await baut auch Magie auf und in Iteratoren.  Aber jeder benutzt es und es ist wirklich praktisch. <br><br>  <b>Sergey:</b> Coroutinen tragen zu den Pluspunkten bei, hallo. <br><br>  <b>Dmitry:</b> Nun ja, es werden Fortschritte gemacht.  Aber Coroutinen tauchen jetzt auf, nicht vor 10 Jahren. <br><br>  <b>Sergey:</b> Noch einmal.  Die Pluspunkte sind √§lter, und meiner Meinung nach sinkt die Entwicklungsgeschwindigkeit mit der Anh√§ufung der Codebasis.  Es h√§ngt nat√ºrlich alles davon ab, ob der Wunsch besteht, die Legacy-Unterst√ºtzung aufrechtzuerhalten.  F√ºr die Profis ist dies eine prinzipielle Position.  Das hei√üt, der Code, den Sie in den 80er Jahren geschrieben haben, wird jetzt von einem modernen Compiler kompiliert. <br><br>  <b>Dmitry:</b> Ja, aber Sie kompilieren den Code, den Sie in C # 1.0 geschrieben haben, mit einem modernen Compiler. <br><br>  <b>Sergey:</b> Das ist nicht wahr.  Ganz am Anfang der Diskussion sagte ich, dass ein Update f√ºr meine fr√ºhen Versionen von .NET eingetroffen ist und pl√∂tzlich alle Programme nicht mehr funktionieren. <br><br>  <b>Dmitry:</b> Vielleicht haben sich die von Ihnen verwendeten APIs gerade ge√§ndert.  Hier m√ºssen Sie die Bibliothek und die Programmiersprache trennen. <br><br>  <b>Sergey:</b> Ich hatte nichts, nur C #.  Ich war jung, das waren die ersten Jahre. <br><br>  <b>Dmitry:</b> Ich erinnere mich nur an eine grundlegende √Ñnderung in C # 4 - eine kleine √Ñnderung im Verhalten von foreach.  Nat√ºrlich k√∂nnte in Version 1.x alles turbulenter sein, aber jetzt sind wir definitiv nicht in der Phase, in der jemand pl√∂tzlich etwas kaputt macht. <br><br>  <b>Anatoly:</b> Nun, offiziell h√§lt Microsoft an der Position fest, die Abw√§rtskompatibilit√§t streng √ºberwacht. Sie testen neue Versionen auf einer Vielzahl von Computern und Codebasen.  Vielleicht hattest du einen Fehler oder so etwas. <br><br>  <b>Dmitry:</b> Im Allgemeinen √ºberwacht .NET auch die Abw√§rtskompatibilit√§t, aber die Geschwindigkeit des Fortschritts ist sowohl in C ++ als auch in Java gestiegen. <br><br>  <b>Sergey:</b> Es scheint mir, dass es eine gro√üe Rolle gespielt hat, dass dies zun√§chst von einer Firma vorangetrieben wurde.  Da C ++ urspr√ºnglich im Ausschuss war - und dies ist Politik -, versuchen alle, ihre Entscheidung voranzutreiben, und dies ist wie eine Senatssitzung in Star Wars. <br><br>  <b>Dmitry:</b> Sie argumentieren also, dass wir alle Geiseln der Aussch√ºsse sind, die nicht von Innovationen getrieben werden? <br><br>  <b>Sergey:</b> Das Problem ist, dass Sie keine L√∂sung w√§hlen, die alle zufriedenstellt.  Das Tool ist so weit verbreitet, dass es von vielen Unternehmen verwendet wird.  Sie die gleichen Coroutinen erinnerten sich: Warum haben sie sie sp√§t erhalten?  Weil Microsoft anscheinend nicht mit Google √ºbereinstimmen konnte.  Es gab zwei Implementierungen: Ich kann mich nicht erinnern, wer hinter Stackful und wer hinter Stackless steckt, konnte aber nicht zustimmen.  Da beide Unternehmen gro√ü sind, verf√ºgen sie √ºber riesige Codebasen, die bereits eine L√∂sung enthalten, und sie weigern sich, diese neu zu schreiben. <br><br>  <b>Dmitry:</b> Aus der Sicht des Lesers wird man das Gef√ºhl haben, dass sie von einem hohen Glockenturm auf ihn gespuckt haben, weil es Unternehmensinteressen gibt, sie sich mit Verliebten besch√§ftigen, und all dies scheint Sie nicht zu betreffen - gehen Sie, Lakaien, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äûlassen Sie sie Kuchen essen‚Äú</a> . <br><br>  <b>Sergey:</b> Im Gegenteil.  Das Komitee versucht zu w√§hlen, damit ein gew√∂hnlicher Mensch nicht leiden muss.  Und oft ist es schwer. <br><br>  <b>Dmitry:</b> Nun, ich kann f√ºr mich selbst sagen, dass ich nicht leiden werde, wenn die Nullkosten irgendwohin gehen, aber es wird eine flexible M√∂glichkeit geben, durch den Bin√§rbaum zu gehen und auf verschiedene Weise ohne Zeitvariablen zu iterieren.      yield,     -   - ‚Äî    ,   ,      ,  ,     - . <br><br> <b>:</b> , ,           ,        ,      - . <br><br> <b>:</b>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost</a> . <br><br> <b>:</b> ,  . Boost , ,   , ‚Ä¶  -        .    std::string,  ,    .    size(),  length(),      :  ,    -  ?    -  ,    ,     .   , .  ,  , ,       .      ,    ,        ,   -  . <br><br><img src="https://habrastorage.org/webt/nh/k7/cd/nhk7cdikdhqxbdfj52qibe_pybo.jpeg"><br><br><h2>  Zusammenstellung </h2><br> <b>:</b>            , , ,    .       ? <br><br> <b>:</b>      , ,      ¬´¬ª,    . <br><br> <b>:</b>  . <br><br> <b>:</b>    embedded-,      include,  ? <br><br> <b>:</b>       .   embedded  -. <br><br> ,     , -  ?   ,    ,     .     ? <br><br> <b>:</b>  .   150 .   -     ,   .  . <br><br> <b>:</b>      ,    ! <br><br> <b>:</b>   ,     Steam, , , 64 . ,  150   ? <br><br> <b>:</b> , , . <br><br> <b>:</b>       ,        -.         ?     ,  ,      ,   ‚Äî  ,    zero cost abstractions  .       -? <br><br> <b>:</b>       ,  ,       ,   , ? <br><br> <b>:</b>    ,     .      ,    ,    . <br><br> <b>:</b> ,      ,    ,   .     ‚Äî ,     .     ,    .     ,   ,  .     ,  .    -.      C. <br><br> <b>:</b>   .      ¬´¬ª.       : ,            .  ,    ,   ,     .      .  ,       . <br><br> <b>:</b> ,   .     . ,  .      proposal.    . <br><br> <b>:</b>   ,    proposal.      ,       ¬´ ¬ª: ,  STL  ,    . ,  -   ,      . <br><br> <b>:</b> STL        . STL  .  ,    ,   STL  ‚Äî  ,    ,      . <br><br> <b>:</b>  ,   ‚Äî   ,    ?   ,     greenfield.    brownfield development,   .   ‚Äî ,  .   ‚Äî  .   ? <br><br> <b>:</b>  ,  .   ,   ,    .   ,   .      ,   ,     . G++  , Clang  .   . <br><br> <b>:</b>  , ,      ,     .  ¬´    ,   A,  B¬ª.     ,      .NET,         .  ,  ,     ,         ,       ,       ? <br><br> <b>:</b>  ,  ,     . ,    C++ 2.0.  ++C++.      ,     C. <br><br> <b>:</b>  ,    .          ,   ,  . ,  , ,   ,  #include  #import  -    ‚Äî   .  ,           . ,   ,    ,           , . <br><br>     .    ,       .    , ,       ,      C#  C++,             . <br><br> <b>:</b>    ,      ,     10  .     ,  ,   ,     ,    ,       ,   .         ¬´ ¬ª,      .      ,        . <br><br> C# ,      C++.   ,     C#     .       ,   ,   .      ,  ,     , ,  JIT' ‚Äî  ,   ,         -   (    int).  ,     ,   ,     ,    . <br><br> <b>:</b> ,  ,   ,   C#       ‚Äî     .  ,    ,   C++  .  ,     .  ( ,   ) ‚Äî   cutting edge.    ,     UI-  C++,      ,   .   C# ‚Äî .  C++   ,   . <br><br>       ,   . ,     ,       ,    C++   ,  ,   , . ,     . <br><br>         ,  C#     Microsoft.   ,    .NET Foundation,      ,   ,   Microsoft.   ,             . <br><br><hr><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C++ Russia</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext</a> .  :    ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469467/">https://habr.com/ru/post/de469467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469457/index.html">Wohin Extravaganza f√ºhrt</a></li>
<li><a href="../de469459/index.html">Anschlie√üen von IoT-Ger√§ten in der Smart City</a></li>
<li><a href="../de469461/index.html">"Zu den Sternen": Anti-Kosmische "Apokalypse heute"</a></li>
<li><a href="../de469463/index.html">Trends und Prognosen in der Verarbeitung nat√ºrlicher Sprache</a></li>
<li><a href="../de469465/index.html">Initialisierung in modernem C ++</a></li>
<li><a href="../de469471/index.html">"5 Cent", um √ºber Sorten zu sprechen</a></li>
<li><a href="../de469475/index.html">Der Aufstieg und Fall von Flash, dem nervigen Plugin, das das moderne Web gepr√§gt hat</a></li>
<li><a href="../de469477/index.html">Apple ist an der Zeit, den Vergleich von iPad und PC einzustellen</a></li>
<li><a href="../de469479/index.html">Woher kommt die Quantenwahrscheinlichkeit?</a></li>
<li><a href="../de469491/index.html">Interaktion mit dem Asterisk-Server √ºber eine Java-Anwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>