<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèΩ üö• üë©üèΩ‚Äçüöí Analisadores aplic√°veis ‚Äã‚Äãde Haskell üë®üèΩ‚Äçü§ù‚Äçüë®üèª üëô üë¶üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motiva√ß√£o 


 Quando comecei a aprender Haskell, fiquei muito irritado com o uso generalizado de abstra√ß√µes complexas em vez de com solu√ß√µes espec√≠fic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisadores aplic√°veis ‚Äã‚Äãde Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  Motiva√ß√£o </h1><br><p>  Quando comecei a aprender Haskell, fiquei muito irritado com o uso generalizado de abstra√ß√µes complexas em vez de com solu√ß√µes espec√≠ficas.  Pareceu-me que √© muito melhor sempre seguir o princ√≠pio do KISS e escrever bicicletas usando constru√ß√µes de linguagem elementar do que entender todas essas classes de tipos para escrever uma constru√ß√£o supostamente conveniente em algum lugar. </p><br><p>  N√£o tive um bom exemplo de onde os esfor√ßos despendidos no desenvolvimento do "material" seriam recompensados.  Para mim, um dos exemplos mais bem-sucedidos foi o analisador.  Agora, muitas vezes falo sobre eles quando me perguntam quais tarefas comuns voc√™ pode usar maravilhosamente o Haskell. </p><br><p>  Eu quero oferecer aos iniciantes que tamb√©m sigam esse caminho e criem uma pequena base de fun√ß√µes a partir do zero para uma implementa√ß√£o conveniente dos analisadores, e depois usem-na para escrever seu pr√≥prio analisador, cujo c√≥digo repetir√° literalmente a gram√°tica usada para a an√°lise. </p><br><p>  Espero que isso ajude algu√©m a superar o medo das abstra√ß√µes e ensin√°-las a us√°-las <em>adequadamente</em> (sim, ainda acho que √†s vezes √© mais eficiente escrever uma bicicleta). </p><a name="habracut"></a><br><p>  N√£o tenho prop√≥sito e desejo fazer um curso de Haskell a partir do zero, de modo que assumo que o leitor esteja familiarizado com a sintaxe e com programas simples desenvolvidos de forma independente.  Apenas no caso, falarei brevemente sobre classes de tipos antes de passar para a descri√ß√£o da implementa√ß√£o. </p><br><p>  Para aqueles que nunca escreveram para Haskell, mas querem entender o que est√° acontecendo aqui, recomendo que voc√™ olhe primeiro para a p√°gina correspondente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Learn X em Y minutos</a> .  Como um excelente livro em russo para iniciantes, aconselho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Sobre Haskell como</a> ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">humano", de</a> Denis Shevchenko. </p><br><p>  Vou tentar usar as constru√ß√µes de linguagem mais simples que os iniciantes possam entender.  No final do artigo, √© fornecido um link para o reposit√≥rio de origem, onde em algumas partes do c√≥digo uma entrada mais conveniente e mais curta √© usada, o que pode ser menos claro √† primeira vista. </p><br><p>  E sim, senhores haskellistas, muitas coisas s√£o explicadas de maneira muito simples e desajeitada, para casos especiais, n√£o muito abstratos, sem usar termos da teoria das categorias e outras palavras assustadoras.  Fico feliz que voc√™ os conhe√ßa e, √© claro, eles os dominaram facilmente.  Eu tamb√©m os conhe√ßo, mas n√£o acho necess√°rio despejar tanta quantidade de informa√ß√µes nesse contexto em leitores despreparados. </p><br><h1 id="klassy-tipov">  Classes de tipos </h1><br><p>  Classes do tipo Haskell n√£o t√™m nada a ver com classes em C ++ e outras linguagens orientadas a objetos.  Se tra√ßarmos uma analogia com o OOP, as classes de tipo ser√£o mais como uma sobrecarga de m√©todos e fun√ß√µes. </p><br><p> As classes determinam quais a√ß√µes podem ser executadas com objetos dos tipos que comp√µem a classe.  Por exemplo, todos os n√∫meros podem ser comparados em termos de igualdade, mas tudo pode ser ordenado, exceto os complexos e, em geral, as fun√ß√µes n√£o podem ser comparadas.  A classe de tipos que podem ser comparados √© chamada <code>Eq</code> , ordenada - <code>Ord</code> (os tipos n√£o precisam ser num√©ricos).  O que pode ser impresso pela convers√£o em uma string pertence √† classe <code>Show</code> , possui a classe <code>Read</code> "oposta", que determina como converter as strings em objetos do tipo desejado. </p><br><p>  Para um conjunto de classes de tipo padr√£o (como <code>Eq</code> , <code>Show</code> , <code>Read</code> ...), voc√™ pode solicitar ao compilador que implemente a funcionalidade desejada de maneira padr√£o, usando a palavra-chave <code>deriving</code> ap√≥s determinar o tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Voc√™ pode definir suas pr√≥prias classes de tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Aqui <code>PrettyPrint</code> √© o nome da classe, <code>a</code> √© uma vari√°vel de tipo.  A palavra-chave <code>where</code> √© seguida por uma lista dos chamados m√©todos de classe, ou seja,  fun√ß√µes que podem ser aplicadas a objetos de tipo dessa classe. </p><br><p>  Para indicar a perten√ßa de um tipo de dados a uma classe, a seguinte constru√ß√£o √© usada: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  A linguagem permite especificar restri√ß√µes nas classes de tipo √†s quais os argumentos da fun√ß√£o devem se relacionar: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  Para cada chamada de fun√ß√£o, o compilador verifica se esses requisitos de tipo s√£o atendidos e, em caso de falha, exibe um erro (√© claro, isso acontece no est√°gio de compila√ß√£o). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Implementa√ß√£o </h1><br><p>  O analisador recebe uma string de entrada que deve analisar de acordo com regras predefinidas e obter o valor do tipo que precisamos (por exemplo, um n√∫mero inteiro).  Nesse caso, a linha de entrada pode n√£o terminar e o restante servir√° como uma entrada para an√°lises adicionais.  Al√©m disso, nosso analisador geralmente n√£o √© determin√≠stico, ou seja,  retornar√° v√°rios resultados poss√≠veis de an√°lise como uma lista. </p><br><p>  Uma tupla de dois elementos <code>(String, a)</code> adequada para descrever um resultado da opera√ß√£o do analisador, em que <code>a</code> √© uma vari√°vel de tipo que pode denotar qualquer tipo de usu√°rio. </p><br><p>  Como o analisador analisa a string de acordo com algumas regras, a descrevemos como uma fun√ß√£o que recebe uma string como entrada e retorna uma lista de resultados: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  Consideraremos a an√°lise bem-sucedida se a lista de resultados consistir em um elemento e a sequ√™ncia de entrada tiver sido completamente processada.  Implementamos uma fun√ß√£o auxiliar que tenta analisar exclusivamente a cadeia inteira: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Analisadores simples </h2><br><p>  Implementamos v√°rios analisadores simples, que ser√£o √∫teis na cria√ß√£o de combina√ß√µes mais complexas. </p><br><p>  Come√ßamos analisando um √∫nico caractere que deve satisfazer um predicado.  Se a sequ√™ncia de entrada estiver vazia, o resultado do trabalho ser√° uma lista vazia.  Caso contr√°rio, verificamos o valor do predicado no primeiro caractere da string.  Se <code>True</code> retornado, o resultado da an√°lise √© esse caractere;  retorne-o com o restante da string.  Caso contr√°rio, a an√°lise tamb√©m falhar√°. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Agora podemos escrever um analisador que assume um caractere espec√≠fico no in√≠cio da linha.  Para fazer isso, use o <code>predP</code> rec√©m-escrito e passe como argumento uma fun√ß√£o que compara seu argumento com o caractere de que precisamos: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  O caso mais simples a seguir: um analisador que aceita apenas uma determinada sequ√™ncia como um todo.  <code>stringP</code> cham√°-lo de <code>stringP</code> .  A fun√ß√£o dentro do analisador compara a linha de entrada com a desejada e, se as linhas forem iguais, retorna uma lista de um elemento: um par de linhas vazias (n√£o resta mais nada na entrada) e a original.  Caso contr√°rio, a an√°lise falhou e uma lista vazia de resultados ser√° retornada. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Freq√ºentemente, √© necess√°rio pular caracteres que tenham uma determinada propriedade enquanto eles v√£o para o in√≠cio da linha (por exemplo, caracteres de espa√ßo em branco).  Al√©m disso, o resultado da an√°lise n√£o √© importante para n√≥s e n√£o ser√° √∫til no futuro.  Escrevemos uma fun√ß√£o de <code>skip</code> que ignora os caracteres iniciais da string enquanto o valor verdadeiro do predicado √© preservado.  Como resultado da an√°lise, usamos uma tupla vazia. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  Os pr√≥ximos dois analisadores s√£o muito parecidos entre si.  Ambos verificam o prefixo da linha de entrada, apenas o primeiro, se bem-sucedido, retorna esse prefixo e o segundo retorna uma tupla vazia, ou seja,  permite que voc√™ pule uma linha arbitr√°ria no in√≠cio da entrada.  A implementa√ß√£o usa a fun√ß√£o <code>isPrefixOf</code> definida no m√≥dulo <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  Um pouco mais tarde, consideraremos uma implementa√ß√£o mais simples da √∫ltima fun√ß√£o e nos livraremos da duplica√ß√£o de c√≥digo. </p><br><h2 id="parser-kak-funktor">  Analisador como um functor </h2><br><p>  Podemos distinguir uma classe inteira de tipos de cont√™iner para os quais o seguinte √© verdadeiro: se voc√™ souber converter objetos dentro de um cont√™iner, poder√° converter os cont√™ineres.  O exemplo mais simples √© uma lista como um cont√™iner e uma fun√ß√£o de <code>map</code> , dispon√≠vel em quase todos os idiomas de alto n√≠vel.  De fato, voc√™ pode passar por todos os elementos de uma lista do tipo <code>[a]</code> , aplicar <code>a -&gt; b</code> fun√ß√£o a <code>a -&gt; b</code> a cada um e obter uma lista do tipo <code>[b]</code> . </p><br><p>  Essa classe de tipo √© chamada <code>Functor</code> ; a classe possui um m√©todo <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Suponha que j√° sabemos analisar cadeias de caracteres em objetos de um determinado tipo <code>a</code> e, al√©m disso, sabemos como converter objetos do tipo <code>a</code> em objetos do tipo <code>b</code> .  √â poss√≠vel dizer que existe um analisador para objetos do tipo <code>b</code> ? </p><br><p>  Se expresso na forma de uma fun√ß√£o, ter√° o seguinte tipo: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Esse tipo coincide com o tipo da fun√ß√£o <code>fmap</code> , ent√£o vamos tentar tornar o analisador um functor.  Vamos criar um analisador de valores do tipo <code>b</code> do zero, que primeiro chamar√° o primeiro analisador (j√° temos um) e, em seguida, aplicamos a fun√ß√£o aos resultados de sua an√°lise. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  A fun√ß√£o <code>fmap</code> possui um sin√¥nimo de infixo conveniente: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  Se usarmos uma fun√ß√£o como argumento para o <code>fmap</code> que simplesmente substitui seu primeiro argumento por um novo valor, obteremos outra opera√ß√£o √∫til que j√° est√° implementada para todos os functores, mesmo em duas inst√¢ncias (eles diferem apenas na ordem dos argumentos): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  Lembra do analisador que pula uma linha espec√≠fica ( <code>skipString</code> )?  Agora voc√™ pode implement√°-lo da seguinte maneira: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Combina√ß√µes do analisador </h2><br><p>  No Haskell, todas as fun√ß√µes s√£o curry por padr√£o e s√£o parcialmente utiliz√°veis.  Isso significa que uma fun√ß√£o de <code>n</code> argumentos √© realmente uma fun√ß√£o de um argumento, retornando uma fun√ß√£o de <code>n-1</code> argumentos: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p>  Aplicamos uma fun√ß√£o de tr√™s argumentos a algum valor dentro do analisador usando <code>fmap</code> .  Os tipos ser√£o os seguintes: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  O analisador de fun√ß√µes acabou ?!  Obviamente, √© poss√≠vel uma situa√ß√£o em que a representa√ß√£o da fun√ß√£o realmente esteja na linha de entrada, mas eu gostaria de poder usar essa fun√ß√£o, ou melhor, combinar os <code>Parser (a -&gt; b)</code> e <code>Parser a</code> para obter o <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  O tipo dessa fun√ß√£o √© muito semelhante ao tipo <code>fmap</code> , apenas a pr√≥pria fun√ß√£o que precisa ser aplicada tamb√©m est√° no cont√™iner.  Isso fornece uma compreens√£o intuitiva de como deve ser a implementa√ß√£o da fun√ß√£o <code>applyP</code> : obtenha a fun√ß√£o do cont√™iner (como resultado da aplica√ß√£o do primeiro analisador), obtenha os valores aos quais a fun√ß√£o deve ser aplicada (resultado da aplica√ß√£o do segundo analisador) e "empacote" os valores convertidos usando essa fun√ß√£o de volta no cont√™iner (crie um novo analisador).  Na implementa√ß√£o, usaremos a compreens√£o da lista: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p>  Existe uma classe <code>Applicative</code> que possui um m√©todo com o mesmo prot√≥tipo.  O segundo m√©todo da classe √© chamado <code>pure</code> e √© usado para "quebrar" ou "elevar" ( <em>elevar</em> ) um valor, incluindo um funcional.  No caso da implementa√ß√£o do analisador, a fun√ß√£o <code>pure</code> adiciona seu argumento ao resultado do analisador, sem alterar a sequ√™ncia de entrada. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  A fun√ß√£o <code>applyP</code> √© a <code>&lt;*&gt;</code> da classe <code>Applicative</code> .  Os tipos pertencentes a essa classe s√£o chamados de functores aplicativos. </p><br><p>  Para functores aplicativos, duas fun√ß√µes auxiliares s√£o implementadas que ser√£o √∫teis para n√≥s: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  Essas fun√ß√µes executam duas a√ß√µes consecutivas e retornam o resultado de apenas uma delas.  Para analisadores, eles podem ser usados, por exemplo, para ignorar espa√ßos √† esquerda antes de analisar uma parte de uma sequ√™ncia que carrega uma carga sem√¢ntica. </p><br><p>  Ao combinar <code>&lt;$&gt;</code> e <code>&lt;*&gt;</code> , voc√™ pode criar designs muito convenientes.  Considere o seguinte tipo de dados: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  O construtor dos valores <code>MyStruct</code> tamb√©m √© uma fun√ß√£o, nesse caso, √© do tipo <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  Voc√™ pode trabalhar com o construtor, assim como com qualquer outra fun√ß√£o.  Suponha que os analisadores j√° tenham sido gravados para os tipos de campos de estrutura: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  Usando a fun√ß√£o <code>fmap</code> , voc√™ pode aplicar parcialmente o <code>MyStruct</code> ao primeiro desses analisadores: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Vamos tentar aplicar a fun√ß√£o que est√° agora "dentro" do analisador.  Para fazer isso, voc√™ j√° precisa usar <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  Como resultado, obtivemos um analisador para toda a estrutura (√© claro, aqui usamos a suposi√ß√£o de que na linha original as representa√ß√µes de seus campos est√£o seguidas).  O mesmo pode ser feito em uma linha: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  Tais constru√ß√µes geralmente s√£o encontradas em casos de uso. </p><br><p>  Agora, suponha que estamos tentando escrever um analisador que analisa express√µes aritm√©ticas simples nas quais n√∫meros inteiros e identificadores podem estar presentes como operandos.  Vamos criar um tipo separado de <code>Operand</code> para eles: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  Se j√° sabemos analisar inteiros e identificadores (por exemplo, como em C), precisamos de <em>um</em> analisador para operandos que possam analisar um ou outro.  Esse analisador √© uma alternativa dos outros dois, portanto, precisamos de uma fun√ß√£o que possa combinar analisadores para que os resultados de seu trabalho sejam combinados.  O resultado do analisador √© uma lista e a combina√ß√£o de listas √© sua concatena√ß√£o.  Implementamos a fun√ß√£o <code>altP</code> combinando dois analisadores: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Em seguida, o analisador de operando pode ser implementado usando esta fun√ß√£o (aqui √© assumido que <code>parserInt</code> e <code>parserIdent</code> j√° <code>parserIdent</code> descritos em algum lugar: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Obviamente, para alternativas j√° criamos uma classe separada, chamada <code>Alternative</code> .  Possui outro m√©todo, <code>empty</code> , que descreve o elemento neutro para a opera√ß√£o alternativa.  No nosso caso, √© um analisador que nunca analisa nada, ou seja,  sempre retorna uma lista vazia de resultados.  Para o analisador, a implementa√ß√£o dos m√©todos da classe <code>Alternative</code> parece com isso: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  A opera√ß√£o <code>&lt;|&gt;</code> √© a fun√ß√£o <code>altP</code> apenas na nota√ß√£o infix, que √© mais conveniente de usar combinando v√°rios analisadores seguidos. </p><br><p>  Para todos os tipos nesta classe, duas fun√ß√µes s√£o implementadas, <code>some</code> e <code>many</code> tipo <code>fa -&gt; f [a]</code> .  Cada um deles pode ser expresso atrav√©s do outro: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  Em termos de analisadores, essas fun√ß√µes permitem analisar sequ√™ncias de dados se voc√™ souber analisar um √∫nico elemento de dados.  No caso de usar <code>some</code> sequ√™ncia deve ser n√£o vazia. </p><br><h1 id="primer-ispolzovaniya">  Exemplo de uso </h1><br><p>  Agora estamos prontos para escrever seu pr√≥prio analisador, por exemplo, para express√µes aritm√©ticas simples com a seguinte gram√°tica: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  A express√£o consiste em constantes inteiras, o menos un√°rio e duas opera√ß√µes bin√°rias infix: adi√ß√£o e multiplica√ß√£o.  Os colchetes s√£o necess√°rios em torno de uma express√£o com uma opera√ß√£o bin√°ria, o s√≠mbolo da opera√ß√£o √© separado dos operandos por exatamente um espa√ßo, n√£o sendo permitido espa√ßos √† esquerda e √† esquerda. </p><br><p>  Exemplos de escrita correta da express√£o: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Exemplos de entradas incorretas: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  Declaramos os tipos de dados necess√°rios (a pr√≥pria express√£o e a opera√ß√£o bin√°ria): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  Voc√™ pode come√ßar a analisar!  A express√£o em si consiste em tr√™s alternativas.  Ent√£o escrevemos: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  Uma constante √© um n√∫mero inteiro positivo.  No nosso tipo de dados, ele √© "empacotado" no construtor, portanto, n√£o podemos usar o analisador para um n√∫mero inteiro diretamente, mas podemos usar o <code>fmap</code> para obter o valor do tipo desejado. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  Um n√∫mero inteiro, de acordo com a gram√°tica, √© representado como uma sequ√™ncia de n√∫meros n√£o vazia.  Para analisar um d√≠gito, usamos a fun√ß√£o auxiliar <code>predP</code> e o predicado <code>isDigit</code> do m√≥dulo <code>Data.Char</code> .  Agora, para construir um analisador para analisar uma sequ√™ncia de d√≠gitos, usamos a fun√ß√£o <code>some</code> (n√£o <code>many</code> , porque deve haver pelo menos um d√≠gito).  O resultado desse analisador retorna uma lista de todas as op√ß√µes de an√°lise poss√≠veis, iniciando com o registro mais longo.  Por exemplo, se a sequ√™ncia de entrada for "123ab", a lista de resultados ser√° a seguinte: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  Precisamos analisar a sequ√™ncia mais longa de d√≠gitos e convert√™-la para o tipo <code>Int</code> .  Toda a implementa√ß√£o √© a seguinte: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  A pr√≥xima maneira de escrever uma express√£o √© usar uma opera√ß√£o bin√°ria.  De acordo com a gram√°tica, o colchete de abertura deve primeiro incluir o colchete de abertura, o primeiro operando, o espa√ßo, o s√≠mbolo da opera√ß√£o, outro espa√ßo, o segundo operando e o colchete de fechamento.  Para analisar caracteres individuais (colchetes e espa√ßos), usamos a fun√ß√£o <code>charP</code> .  Operandos s√£o express√µes e j√° existe um analisador ( <code>exprParser</code> ) para analis√°-los.  Para analisar o s√≠mbolo de opera√ß√£o bin√°ria, descrevemos o analisador auxiliar logo abaixo.  Resta combinar perfeitamente esse conjunto de analisadores.  Deve haver colchetes no in√≠cio e no final da express√£o: voc√™ precisa verificar isso, mas descartar o resultado em si.  Para fazer isso, use <code>*&gt;</code> e <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Entre esses analisadores para par√™nteses, uma express√£o deve ser constru√≠da usando o construtor <code>BinaryExpr</code> e analisadores para a express√£o e opera√ß√£o.  N√£o se esque√ßa dos espa√ßos ao redor do s√≠mbolo de opera√ß√£o, usando o mesmo m√©todo dos colchetes.  Esta parte √© a seguinte: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p>  Substitu√≠mos esta express√£o por pontos de interroga√ß√£o: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  Uma opera√ß√£o bin√°ria √© um caractere <code>+</code> que analisa o valor <code>Add</code> ou <code>*</code> que analisa o <code>Mul</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  O que resta √© a parte mais simples da gram√°tica, a nega√ß√£o da express√£o.  Com um s√≠mbolo <code>-</code> fazemos o mesmo que com colchetes e espa√ßos.  Em seguida, aplique o construtor <code>NegateExpr</code> ao resultado da an√°lise recursiva: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  Portanto, todas as partes do analisador s√£o implementadas.  O c√≥digo √© muito parecido com uma gram√°tica e coincide completamente com ele na estrutura. </p><br><p>  O c√≥digo-fonte est√° dispon√≠vel no GitLab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  L√° √© mais f√°cil avaliar seu volume e grau de expressividade, pois h√° muito menos coment√°rios.  Voc√™ pode compilar o projeto com o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Stack</a> e executar o interpretador primitivo usando o analisador que escrevemos: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  Para aqueles que desejam praticar mais por conta pr√≥pria, posso aconselhar o seguinte: </p><br><ul><li>  A gram√°tica pode ser aprimorada de todas as formas, por exemplo, para permitir espa√ßos iniciais e pendentes, adicionar novas opera√ß√µes, etc. </li><li>  O analisador converte a sequ√™ncia na representa√ß√£o interna da express√£o.  Essa express√£o pode ser calculada e transformada pelo int√©rprete para que ela imprima n√£o o resultado da an√°lise, mas o resultado do c√°lculo. </li><li>  Explore as possibilidades das <code>attoparsec</code> <code>parsec</code> , <code>attoparsec</code> , <code>applicative-parsec</code> e <code>optparse-applicative</code> e tente us√°-las. </li></ul><br><p>  Obrigado pela aten√ß√£o! </p><br><h1 id="poleznye-materialy">  Materiais √∫teis </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprenda Haskell em Y minutos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Denis Shevchenko.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Sobre Haskell como ser humano"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Attoparsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca application-parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca optparse-aplicativa</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436234/">https://habr.com/ru/post/pt436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436224/index.html">Escrevemos nossa linguagem de programa√ß√£o, parte 4: Representa√ß√£o de estruturas e classes, gera√ß√£o de alocadores</a></li>
<li><a href="../pt436226/index.html">Guia e c√°bula para Wireshark</a></li>
<li><a href="../pt436228/index.html">Desenvolvimento de uma equipe para consulta de dados do banco de dados</a></li>
<li><a href="../pt436230/index.html">Como assumir o controle de sua infraestrutura de rede. CAP√çTULO TR√äS Seguran√ßa de rede. Parte dois</a></li>
<li><a href="../pt436232/index.html">Estrat√©gia de Telepatia</a></li>
<li><a href="../pt436236/index.html">Usamos ci√™ncia de dados para determinar o ciclo de vida de um cliente</a></li>
<li><a href="../pt436238/index.html">Autentica√ß√£o no Kubernetes com GitHub OAuth e Dex</a></li>
<li><a href="../pt436240/index.html">Automa√ß√£o VS Caos</a></li>
<li><a href="../pt436242/index.html">YOLO e outras metodologias soltas</a></li>
<li><a href="../pt436244/index.html">O novo c√©rebro do professor Lawrence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>