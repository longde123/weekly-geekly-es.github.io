<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏽 🚥 👩🏽‍🚒 Analisadores aplicáveis ​​de Haskell 👨🏽‍🤝‍👨🏻 👙 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motivação 


 Quando comecei a aprender Haskell, fiquei muito irritado com o uso generalizado de abstrações complexas em vez de com soluções específic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisadores aplicáveis ​​de Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  Motivação </h1><br><p>  Quando comecei a aprender Haskell, fiquei muito irritado com o uso generalizado de abstrações complexas em vez de com soluções específicas.  Pareceu-me que é muito melhor sempre seguir o princípio do KISS e escrever bicicletas usando construções de linguagem elementar do que entender todas essas classes de tipos para escrever uma construção supostamente conveniente em algum lugar. </p><br><p>  Não tive um bom exemplo de onde os esforços despendidos no desenvolvimento do "material" seriam recompensados.  Para mim, um dos exemplos mais bem-sucedidos foi o analisador.  Agora, muitas vezes falo sobre eles quando me perguntam quais tarefas comuns você pode usar maravilhosamente o Haskell. </p><br><p>  Eu quero oferecer aos iniciantes que também sigam esse caminho e criem uma pequena base de funções a partir do zero para uma implementação conveniente dos analisadores, e depois usem-na para escrever seu próprio analisador, cujo código repetirá literalmente a gramática usada para a análise. </p><br><p>  Espero que isso ajude alguém a superar o medo das abstrações e ensiná-las a usá-las <em>adequadamente</em> (sim, ainda acho que às vezes é mais eficiente escrever uma bicicleta). </p><a name="habracut"></a><br><p>  Não tenho propósito e desejo fazer um curso de Haskell a partir do zero, de modo que assumo que o leitor esteja familiarizado com a sintaxe e com programas simples desenvolvidos de forma independente.  Apenas no caso, falarei brevemente sobre classes de tipos antes de passar para a descrição da implementação. </p><br><p>  Para aqueles que nunca escreveram para Haskell, mas querem entender o que está acontecendo aqui, recomendo que você olhe primeiro para a página correspondente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Learn X em Y minutos</a> .  Como um excelente livro em russo para iniciantes, aconselho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Sobre Haskell como</a> ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">humano", de</a> Denis Shevchenko. </p><br><p>  Vou tentar usar as construções de linguagem mais simples que os iniciantes possam entender.  No final do artigo, é fornecido um link para o repositório de origem, onde em algumas partes do código uma entrada mais conveniente e mais curta é usada, o que pode ser menos claro à primeira vista. </p><br><p>  E sim, senhores haskellistas, muitas coisas são explicadas de maneira muito simples e desajeitada, para casos especiais, não muito abstratos, sem usar termos da teoria das categorias e outras palavras assustadoras.  Fico feliz que você os conheça e, é claro, eles os dominaram facilmente.  Eu também os conheço, mas não acho necessário despejar tanta quantidade de informações nesse contexto em leitores despreparados. </p><br><h1 id="klassy-tipov">  Classes de tipos </h1><br><p>  Classes do tipo Haskell não têm nada a ver com classes em C ++ e outras linguagens orientadas a objetos.  Se traçarmos uma analogia com o OOP, as classes de tipo serão mais como uma sobrecarga de métodos e funções. </p><br><p> As classes determinam quais ações podem ser executadas com objetos dos tipos que compõem a classe.  Por exemplo, todos os números podem ser comparados em termos de igualdade, mas tudo pode ser ordenado, exceto os complexos e, em geral, as funções não podem ser comparadas.  A classe de tipos que podem ser comparados é chamada <code>Eq</code> , ordenada - <code>Ord</code> (os tipos não precisam ser numéricos).  O que pode ser impresso pela conversão em uma string pertence à classe <code>Show</code> , possui a classe <code>Read</code> "oposta", que determina como converter as strings em objetos do tipo desejado. </p><br><p>  Para um conjunto de classes de tipo padrão (como <code>Eq</code> , <code>Show</code> , <code>Read</code> ...), você pode solicitar ao compilador que implemente a funcionalidade desejada de maneira padrão, usando a palavra-chave <code>deriving</code> após determinar o tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Você pode definir suas próprias classes de tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Aqui <code>PrettyPrint</code> é o nome da classe, <code>a</code> é uma variável de tipo.  A palavra-chave <code>where</code> é seguida por uma lista dos chamados métodos de classe, ou seja,  funções que podem ser aplicadas a objetos de tipo dessa classe. </p><br><p>  Para indicar a pertença de um tipo de dados a uma classe, a seguinte construção é usada: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  A linguagem permite especificar restrições nas classes de tipo às quais os argumentos da função devem se relacionar: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  Para cada chamada de função, o compilador verifica se esses requisitos de tipo são atendidos e, em caso de falha, exibe um erro (é claro, isso acontece no estágio de compilação). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Implementação </h1><br><p>  O analisador recebe uma string de entrada que deve analisar de acordo com regras predefinidas e obter o valor do tipo que precisamos (por exemplo, um número inteiro).  Nesse caso, a linha de entrada pode não terminar e o restante servirá como uma entrada para análises adicionais.  Além disso, nosso analisador geralmente não é determinístico, ou seja,  retornará vários resultados possíveis de análise como uma lista. </p><br><p>  Uma tupla de dois elementos <code>(String, a)</code> adequada para descrever um resultado da operação do analisador, em que <code>a</code> é uma variável de tipo que pode denotar qualquer tipo de usuário. </p><br><p>  Como o analisador analisa a string de acordo com algumas regras, a descrevemos como uma função que recebe uma string como entrada e retorna uma lista de resultados: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  Consideraremos a análise bem-sucedida se a lista de resultados consistir em um elemento e a sequência de entrada tiver sido completamente processada.  Implementamos uma função auxiliar que tenta analisar exclusivamente a cadeia inteira: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Analisadores simples </h2><br><p>  Implementamos vários analisadores simples, que serão úteis na criação de combinações mais complexas. </p><br><p>  Começamos analisando um único caractere que deve satisfazer um predicado.  Se a sequência de entrada estiver vazia, o resultado do trabalho será uma lista vazia.  Caso contrário, verificamos o valor do predicado no primeiro caractere da string.  Se <code>True</code> retornado, o resultado da análise é esse caractere;  retorne-o com o restante da string.  Caso contrário, a análise também falhará. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Agora podemos escrever um analisador que assume um caractere específico no início da linha.  Para fazer isso, use o <code>predP</code> recém-escrito e passe como argumento uma função que compara seu argumento com o caractere de que precisamos: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  O caso mais simples a seguir: um analisador que aceita apenas uma determinada sequência como um todo.  <code>stringP</code> chamá-lo de <code>stringP</code> .  A função dentro do analisador compara a linha de entrada com a desejada e, se as linhas forem iguais, retorna uma lista de um elemento: um par de linhas vazias (não resta mais nada na entrada) e a original.  Caso contrário, a análise falhou e uma lista vazia de resultados será retornada. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Freqüentemente, é necessário pular caracteres que tenham uma determinada propriedade enquanto eles vão para o início da linha (por exemplo, caracteres de espaço em branco).  Além disso, o resultado da análise não é importante para nós e não será útil no futuro.  Escrevemos uma função de <code>skip</code> que ignora os caracteres iniciais da string enquanto o valor verdadeiro do predicado é preservado.  Como resultado da análise, usamos uma tupla vazia. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  Os próximos dois analisadores são muito parecidos entre si.  Ambos verificam o prefixo da linha de entrada, apenas o primeiro, se bem-sucedido, retorna esse prefixo e o segundo retorna uma tupla vazia, ou seja,  permite que você pule uma linha arbitrária no início da entrada.  A implementação usa a função <code>isPrefixOf</code> definida no módulo <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  Um pouco mais tarde, consideraremos uma implementação mais simples da última função e nos livraremos da duplicação de código. </p><br><h2 id="parser-kak-funktor">  Analisador como um functor </h2><br><p>  Podemos distinguir uma classe inteira de tipos de contêiner para os quais o seguinte é verdadeiro: se você souber converter objetos dentro de um contêiner, poderá converter os contêineres.  O exemplo mais simples é uma lista como um contêiner e uma função de <code>map</code> , disponível em quase todos os idiomas de alto nível.  De fato, você pode passar por todos os elementos de uma lista do tipo <code>[a]</code> , aplicar <code>a -&gt; b</code> função a <code>a -&gt; b</code> a cada um e obter uma lista do tipo <code>[b]</code> . </p><br><p>  Essa classe de tipo é chamada <code>Functor</code> ; a classe possui um método <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Suponha que já sabemos analisar cadeias de caracteres em objetos de um determinado tipo <code>a</code> e, além disso, sabemos como converter objetos do tipo <code>a</code> em objetos do tipo <code>b</code> .  É possível dizer que existe um analisador para objetos do tipo <code>b</code> ? </p><br><p>  Se expresso na forma de uma função, terá o seguinte tipo: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Esse tipo coincide com o tipo da função <code>fmap</code> , então vamos tentar tornar o analisador um functor.  Vamos criar um analisador de valores do tipo <code>b</code> do zero, que primeiro chamará o primeiro analisador (já temos um) e, em seguida, aplicamos a função aos resultados de sua análise. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  A função <code>fmap</code> possui um sinônimo de infixo conveniente: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  Se usarmos uma função como argumento para o <code>fmap</code> que simplesmente substitui seu primeiro argumento por um novo valor, obteremos outra operação útil que já está implementada para todos os functores, mesmo em duas instâncias (eles diferem apenas na ordem dos argumentos): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  Lembra do analisador que pula uma linha específica ( <code>skipString</code> )?  Agora você pode implementá-lo da seguinte maneira: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Combinações do analisador </h2><br><p>  No Haskell, todas as funções são curry por padrão e são parcialmente utilizáveis.  Isso significa que uma função de <code>n</code> argumentos é realmente uma função de um argumento, retornando uma função de <code>n-1</code> argumentos: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p>  Aplicamos uma função de três argumentos a algum valor dentro do analisador usando <code>fmap</code> .  Os tipos serão os seguintes: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  O analisador de funções acabou ?!  Obviamente, é possível uma situação em que a representação da função realmente esteja na linha de entrada, mas eu gostaria de poder usar essa função, ou melhor, combinar os <code>Parser (a -&gt; b)</code> e <code>Parser a</code> para obter o <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  O tipo dessa função é muito semelhante ao tipo <code>fmap</code> , apenas a própria função que precisa ser aplicada também está no contêiner.  Isso fornece uma compreensão intuitiva de como deve ser a implementação da função <code>applyP</code> : obtenha a função do contêiner (como resultado da aplicação do primeiro analisador), obtenha os valores aos quais a função deve ser aplicada (resultado da aplicação do segundo analisador) e "empacote" os valores convertidos usando essa função de volta no contêiner (crie um novo analisador).  Na implementação, usaremos a compreensão da lista: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p>  Existe uma classe <code>Applicative</code> que possui um método com o mesmo protótipo.  O segundo método da classe é chamado <code>pure</code> e é usado para "quebrar" ou "elevar" ( <em>elevar</em> ) um valor, incluindo um funcional.  No caso da implementação do analisador, a função <code>pure</code> adiciona seu argumento ao resultado do analisador, sem alterar a sequência de entrada. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  A função <code>applyP</code> é a <code>&lt;*&gt;</code> da classe <code>Applicative</code> .  Os tipos pertencentes a essa classe são chamados de functores aplicativos. </p><br><p>  Para functores aplicativos, duas funções auxiliares são implementadas que serão úteis para nós: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  Essas funções executam duas ações consecutivas e retornam o resultado de apenas uma delas.  Para analisadores, eles podem ser usados, por exemplo, para ignorar espaços à esquerda antes de analisar uma parte de uma sequência que carrega uma carga semântica. </p><br><p>  Ao combinar <code>&lt;$&gt;</code> e <code>&lt;*&gt;</code> , você pode criar designs muito convenientes.  Considere o seguinte tipo de dados: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  O construtor dos valores <code>MyStruct</code> também é uma função, nesse caso, é do tipo <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  Você pode trabalhar com o construtor, assim como com qualquer outra função.  Suponha que os analisadores já tenham sido gravados para os tipos de campos de estrutura: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  Usando a função <code>fmap</code> , você pode aplicar parcialmente o <code>MyStruct</code> ao primeiro desses analisadores: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Vamos tentar aplicar a função que está agora "dentro" do analisador.  Para fazer isso, você já precisa usar <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  Como resultado, obtivemos um analisador para toda a estrutura (é claro, aqui usamos a suposição de que na linha original as representações de seus campos estão seguidas).  O mesmo pode ser feito em uma linha: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  Tais construções geralmente são encontradas em casos de uso. </p><br><p>  Agora, suponha que estamos tentando escrever um analisador que analisa expressões aritméticas simples nas quais números inteiros e identificadores podem estar presentes como operandos.  Vamos criar um tipo separado de <code>Operand</code> para eles: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  Se já sabemos analisar inteiros e identificadores (por exemplo, como em C), precisamos de <em>um</em> analisador para operandos que possam analisar um ou outro.  Esse analisador é uma alternativa dos outros dois, portanto, precisamos de uma função que possa combinar analisadores para que os resultados de seu trabalho sejam combinados.  O resultado do analisador é uma lista e a combinação de listas é sua concatenação.  Implementamos a função <code>altP</code> combinando dois analisadores: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Em seguida, o analisador de operando pode ser implementado usando esta função (aqui é assumido que <code>parserInt</code> e <code>parserIdent</code> já <code>parserIdent</code> descritos em algum lugar: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Obviamente, para alternativas já criamos uma classe separada, chamada <code>Alternative</code> .  Possui outro método, <code>empty</code> , que descreve o elemento neutro para a operação alternativa.  No nosso caso, é um analisador que nunca analisa nada, ou seja,  sempre retorna uma lista vazia de resultados.  Para o analisador, a implementação dos métodos da classe <code>Alternative</code> parece com isso: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  A operação <code>&lt;|&gt;</code> é a função <code>altP</code> apenas na notação infix, que é mais conveniente de usar combinando vários analisadores seguidos. </p><br><p>  Para todos os tipos nesta classe, duas funções são implementadas, <code>some</code> e <code>many</code> tipo <code>fa -&gt; f [a]</code> .  Cada um deles pode ser expresso através do outro: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  Em termos de analisadores, essas funções permitem analisar sequências de dados se você souber analisar um único elemento de dados.  No caso de usar <code>some</code> sequência deve ser não vazia. </p><br><h1 id="primer-ispolzovaniya">  Exemplo de uso </h1><br><p>  Agora estamos prontos para escrever seu próprio analisador, por exemplo, para expressões aritméticas simples com a seguinte gramática: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  A expressão consiste em constantes inteiras, o menos unário e duas operações binárias infix: adição e multiplicação.  Os colchetes são necessários em torno de uma expressão com uma operação binária, o símbolo da operação é separado dos operandos por exatamente um espaço, não sendo permitido espaços à esquerda e à esquerda. </p><br><p>  Exemplos de escrita correta da expressão: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Exemplos de entradas incorretas: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  Declaramos os tipos de dados necessários (a própria expressão e a operação binária): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  Você pode começar a analisar!  A expressão em si consiste em três alternativas.  Então escrevemos: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  Uma constante é um número inteiro positivo.  No nosso tipo de dados, ele é "empacotado" no construtor, portanto, não podemos usar o analisador para um número inteiro diretamente, mas podemos usar o <code>fmap</code> para obter o valor do tipo desejado. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  Um número inteiro, de acordo com a gramática, é representado como uma sequência de números não vazia.  Para analisar um dígito, usamos a função auxiliar <code>predP</code> e o predicado <code>isDigit</code> do módulo <code>Data.Char</code> .  Agora, para construir um analisador para analisar uma sequência de dígitos, usamos a função <code>some</code> (não <code>many</code> , porque deve haver pelo menos um dígito).  O resultado desse analisador retorna uma lista de todas as opções de análise possíveis, iniciando com o registro mais longo.  Por exemplo, se a sequência de entrada for "123ab", a lista de resultados será a seguinte: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  Precisamos analisar a sequência mais longa de dígitos e convertê-la para o tipo <code>Int</code> .  Toda a implementação é a seguinte: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  A próxima maneira de escrever uma expressão é usar uma operação binária.  De acordo com a gramática, o colchete de abertura deve primeiro incluir o colchete de abertura, o primeiro operando, o espaço, o símbolo da operação, outro espaço, o segundo operando e o colchete de fechamento.  Para analisar caracteres individuais (colchetes e espaços), usamos a função <code>charP</code> .  Operandos são expressões e já existe um analisador ( <code>exprParser</code> ) para analisá-los.  Para analisar o símbolo de operação binária, descrevemos o analisador auxiliar logo abaixo.  Resta combinar perfeitamente esse conjunto de analisadores.  Deve haver colchetes no início e no final da expressão: você precisa verificar isso, mas descartar o resultado em si.  Para fazer isso, use <code>*&gt;</code> e <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Entre esses analisadores para parênteses, uma expressão deve ser construída usando o construtor <code>BinaryExpr</code> e analisadores para a expressão e operação.  Não se esqueça dos espaços ao redor do símbolo de operação, usando o mesmo método dos colchetes.  Esta parte é a seguinte: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p>  Substituímos esta expressão por pontos de interrogação: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  Uma operação binária é um caractere <code>+</code> que analisa o valor <code>Add</code> ou <code>*</code> que analisa o <code>Mul</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  O que resta é a parte mais simples da gramática, a negação da expressão.  Com um símbolo <code>-</code> fazemos o mesmo que com colchetes e espaços.  Em seguida, aplique o construtor <code>NegateExpr</code> ao resultado da análise recursiva: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  Portanto, todas as partes do analisador são implementadas.  O código é muito parecido com uma gramática e coincide completamente com ele na estrutura. </p><br><p>  O código-fonte está disponível no GitLab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  Lá é mais fácil avaliar seu volume e grau de expressividade, pois há muito menos comentários.  Você pode compilar o projeto com o utilitário <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Stack</a> e executar o interpretador primitivo usando o analisador que escrevemos: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  Para aqueles que desejam praticar mais por conta própria, posso aconselhar o seguinte: </p><br><ul><li>  A gramática pode ser aprimorada de todas as formas, por exemplo, para permitir espaços iniciais e pendentes, adicionar novas operações, etc. </li><li>  O analisador converte a sequência na representação interna da expressão.  Essa expressão pode ser calculada e transformada pelo intérprete para que ela imprima não o resultado da análise, mas o resultado do cálculo. </li><li>  Explore as possibilidades das <code>attoparsec</code> <code>parsec</code> , <code>attoparsec</code> , <code>applicative-parsec</code> e <code>optparse-applicative</code> e tente usá-las. </li></ul><br><p>  Obrigado pela atenção! </p><br><h1 id="poleznye-materialy">  Materiais úteis </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprenda Haskell em Y minutos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Denis Shevchenko.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Sobre Haskell como ser humano"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Attoparsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca application-parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca optparse-aplicativa</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436234/">https://habr.com/ru/post/pt436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436224/index.html">Escrevemos nossa linguagem de programação, parte 4: Representação de estruturas e classes, geração de alocadores</a></li>
<li><a href="../pt436226/index.html">Guia e cábula para Wireshark</a></li>
<li><a href="../pt436228/index.html">Desenvolvimento de uma equipe para consulta de dados do banco de dados</a></li>
<li><a href="../pt436230/index.html">Como assumir o controle de sua infraestrutura de rede. CAPÍTULO TRÊS Segurança de rede. Parte dois</a></li>
<li><a href="../pt436232/index.html">Estratégia de Telepatia</a></li>
<li><a href="../pt436236/index.html">Usamos ciência de dados para determinar o ciclo de vida de um cliente</a></li>
<li><a href="../pt436238/index.html">Autenticação no Kubernetes com GitHub OAuth e Dex</a></li>
<li><a href="../pt436240/index.html">Automação VS Caos</a></li>
<li><a href="../pt436242/index.html">YOLO e outras metodologias soltas</a></li>
<li><a href="../pt436244/index.html">O novo cérebro do professor Lawrence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>