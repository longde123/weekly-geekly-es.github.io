<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸ‘©ğŸ¾â€ğŸ“ ğŸ‘¨â€ğŸ‘§ Server klien yang mulus ğŸš‹ ğŸ ğŸ—¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap proyek client-server menyiratkan pemisahan yang jelas dari basis kode menjadi 2 bagian (kadang-kadang lebih) - klien dan server. Seringkali, se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Server klien yang mulus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435494/"><img src="https://habrastorage.org/webt/rq/-9/mh/rq-9mhais2g6p5dd5tsfv8rllak.jpeg" align="left">  Setiap proyek client-server menyiratkan pemisahan yang jelas dari basis kode menjadi 2 bagian (kadang-kadang lebih) - klien dan server.  Seringkali, setiap bagian tersebut dieksekusi dalam bentuk proyek independen yang terpisah, didukung oleh tim pengembangnya sendiri. <br><br>  Pada artikel ini, saya mengusulkan pandangan kritis pada pembagian kode standar menjadi backend dan frontend.  Dan pertimbangkan alternatif di mana kode tidak memiliki garis yang jelas antara klien dan server. <br><br><a name="habracut"></a><br><br><h3>  Kontra dari pendekatan standar </h3><br>  Kerugian utama dari pemisahan standar proyek menjadi 2 bagian adalah erosi logika bisnis antara klien dan server.  Kami mengedit data dalam formulir di browser, memverifikasinya dalam kode klien dan mengirimkannya ke desa kakek (ke server).  Server sudah merupakan proyek lain.  Di sana, Anda juga perlu memeriksa kebenaran data yang diterima (mis., Menduplikasi fungsi klien), melakukan beberapa manipulasi tambahan (simpan dalam database, kirim email, dll.). <br><br>  Dengan demikian, untuk melacak seluruh jalur informasi dari formulir di browser ke database di server, kita harus mempelajari dua sistem yang beragam.  Jika peran dibagi dalam tim dan spesialis berbeda bertanggung jawab untuk backend dan frontend, masalah organisasi tambahan muncul terkait dengan sinkronisasi mereka. <br><br><h3>  Mari bermimpi </h3><br>  Misalkan kita dapat menggambarkan seluruh jalur data dari formulir di klien ke database di server dalam satu model.  Dalam kode, mungkin terlihat seperti ini (kode tidak berfungsi): <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDataModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         verifyData(data) { //   .... return true; } //       client saveData(data) { if(this.verifyData(data)) this.writeDataToDb(data) else consol.log('error') } //  .     server writeDataToDb(data) { if(this.verifyData(data)) this.db.insert(data) else consol.log('error') } }</span></span></code> </pre> <br>  Dengan demikian, seluruh logika bisnis model ada di depan mata kita.  Mempertahankan kode seperti itu lebih mudah.  Berikut adalah keuntungan yang dapat memadukan metode client-server dalam satu model: <br><br><ol><li>  Logika bisnis terkonsentrasi di satu tempat, tidak perlu membaginya antara klien dan server. </li><li>  Anda dapat dengan mudah mentransfer fungsionalitas dari server ke klien atau dari klien ke server selama pengembangan proyek. </li><li>  Tidak perlu menduplikasi metode yang sama untuk backend dan frontend. </li><li>  Satu set tes untuk seluruh logika bisnis proyek. </li><li>  Mengganti garis horizontal garis batas tanggung jawab dalam proyek dengan garis vertikal. </li></ol><br>  Saya akan mengungkapkan poin terakhir secara lebih rinci.  Bayangkan aplikasi client-server biasa dalam bentuk skema seperti itu: <br><br><img src="https://habrastorage.org/webt/8x/c9/de/8xc9degimzw-w-ln5w2ihiybi6w.jpeg" width="400"><br><br>  Vasya bertanggung jawab untuk frontend, Fedya - untuk backend.  Garis batas tanggung jawab berjalan secara horizontal.  Skema ini memiliki kelemahan dari setiap struktur vertikal - sulit untuk skala dan memiliki toleransi kesalahan yang rendah.  Jika proyek ini berkembang, Anda harus membuat pilihan yang agak sulit: siapa yang memperkuat Vasya atau Fedya?  Atau jika Fedya sakit atau berhenti, Vasya tidak akan bisa menggantikannya. <br><br>  Pendekatan yang diusulkan di sini memungkinkan Anda untuk memperluas garis pembagian tanggung jawab sebesar 90 derajat dan mengubah arsitektur vertikal menjadi horizontal. <br><br><img src="https://habrastorage.org/webt/v6/4m/9f/v64m9fuv5sonujosvh4yc4v8vbw.jpeg" width="400"><br><br>  Arsitektur seperti itu jauh lebih mudah untuk diukur dan lebih toleran terhadap kesalahan.  Vasya dan Fedya menjadi dipertukarkan. <br><br>  Secara teori, ini terlihat bagus, mari kita coba menerapkan semua ini dalam praktiknya, tanpa kehilangan semua yang memberi kita keberadaan terpisah dari klien dan server di sepanjang jalan. <br><br><h3>  Pernyataan masalah </h3><br>  Kami benar-benar tidak harus memiliki server klien terintegrasi dalam produk.  Sebaliknya, keputusan seperti itu akan sangat berbahaya dari semua sudut pandang.  Tugasnya adalah bahwa dalam proses pengembangan kita akan memiliki basis kode tunggal untuk model data untuk backend dan frontend, tetapi output akan menjadi klien dan server independen.  Dalam hal ini, kita akan mendapatkan semua keuntungan dari pendekatan standar dan mendapatkan fasilitas yang tercantum di atas untuk pengembangan dan dukungan proyek. <br><br><h3>  Solusi </h3><br>  Saya telah bereksperimen dengan integrasi klien dan server dalam satu file untuk beberapa waktu.  Sampai baru-baru ini, masalah utama adalah bahwa di JS standar, koneksi modul pihak ketiga pada klien dan server terlalu berbeda: memerlukan (...) di node.js, semua sihir AJAX pada klien.  Semuanya telah berubah dengan munculnya modul-ES.  Di browser modern, "impor" telah didukung sejak lama.  Node.js sedikit ketinggalan dalam hal ini dan ES-modul hanya didukung dengan flag - Eksperimental-modul diaktifkan.  Diharapkan di masa mendatang, modul akan bekerja di luar kotak di node.js.  Selain itu, tidak mungkin sesuatu akan banyak berubah, karena  di browser, fungsi ini telah berfungsi secara default sejak lama.  Saya pikir sekarang Anda dapat menggunakan modul-ES tidak hanya pada klien tetapi juga di sisi server (jika Anda memiliki kontra-argumen tentang hal ini, tulis di komentar). <br><br>  Skema solusi terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/xo/_a/vi/xo_avikvz1udp9-dwhxfe6ypt-q.png" width="600"><br><br>  Proyek ini berisi tiga katalog utama: <br><br>  <b>dilindungi</b> - backend; <br>  <b>public</b> -frontend; <br>  <b>shared</b> - model client-server bersama. <br><br>  Proses pengamat yang terpisah memonitor file dalam direktori bersama dan, dengan perubahan apa pun, membuat versi file yang diubah secara terpisah untuk klien dan secara terpisah untuk server (dalam direktori yang dilindungi / dibagikan dan publik / bersama). <br><br><h3>  Implementasi </h3><br>  Pertimbangkan contoh seorang kurir real-time yang sederhana.  Kita perlu node.js baru (saya punya versi 11.0.0) dan Redis (menginstalnya tidak dibahas di sini). <br><br>  Klon contoh: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Kolbaskin/both-example <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./both-example npm i</code> </pre><br>  Instal dan jalankan proses pengamat (pengamat dalam diagram): <br><br><pre> <code class="bash hljs">npm i both-js -g both ./index.mjs</code> </pre><br>  Jika semuanya beres, pengamat akan meluncurkan server web dan mulai memantau perubahan pada file di direktori bersama dan dilindungi.  Ketika perubahan dibuat untuk dibagikan, versi model data yang sesuai untuk klien dan server dibuat.  Setelah perubahan dilindungi, pengamat akan memulai kembali server web secara otomatis. <br><br>  Anda dapat melihat kinerja messenger di browser dengan mengklik tautan <br><br> <code>http://localhost:3000/index.html?token=123&amp;user=Vasya</code> <br> <br>  (token dan pengguna sewenang-wenang).  Untuk meniru beberapa pengguna, buka halaman yang sama di browser lain dengan menentukan token dan pengguna yang berbeda. <br><br>  Sekarang sedikit kode. <br><br><h4>  Server web </h4><br>  protected / server.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// -     //  -  import wsServer from './lib/wsServer.mjs'; const app = express(); //   - wsServer(app); //  mime  mjs express.static.mime.define({'application/javascript': ['js','mjs']}); app.use( bodyParser.json() ); app.use(bodyParser.urlencoded({ extended: true })); //      public app.use(express.static('public')); const server = app.listen(3000, () =&gt; { console.log('server is running at %s', server.address().port); });</span></span></code> </pre><br>  Ini adalah server kilat biasa, tidak ada yang menarik di sini.  Ekstensi mjs diperlukan untuk modul ES di node.js.  Untuk konsistensi, kami akan menggunakan ekstensi ini untuk klien. <br><br><h4>  Pelanggan </h4><br>  publik / index.html <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"en"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/main.mjs"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user in users"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ user.name }} ({{user.id}}) <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messages"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"msg"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sendMessage()"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message in messages"</span></span></span><span class="hljs-tag">&gt;</span></span>[{{ message.date }}] <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>{{ message.text }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Sebagai contoh, saya menggunakan Vue pada klien, tetapi ini tidak mengubah esensi.  Alih-alih Vue, bisa ada apa pun di mana Anda dapat memisahkan model data menjadi kelas yang terpisah (sistem gugur, sudut). <br><br>  public / main.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      - import ws from "/lib/Ws.mjs"; //       import Messages from "./shared/messages/model/dataModel.mjs"; //    import Users from "./shared/users/model/dataModel.mjs"; //  - (     ) window.WS = new ws({ token: new URLSearchParams(document.location.search).get("token"), user: new URLSearchParams(document.location.search).get("user") }); //       new Messages({ el: '#messages' }) //       new Users({ el: '#users' })</span></span></code> </pre><br>  main.mjs adalah skrip yang mengaitkan model data dengan tampilan yang sesuai.  Untuk menyederhanakan kode, contoh representasi untuk daftar pengguna aktif dan umpan pesan dibangun langsung ke index.html <br><br><h4>  Model data </h4><br>  shared / messages / model / dataModel.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    //          , //    import Base from '@root/lib/Base.mjs'; export default class dataModel extends Base { //!#client constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); //     this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#client async sendMessage(e) { //    await this.$sendMessage(this.msg); this.msg = ''; } //!#server async $sendMessage(text) { //   newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  Beberapa metode ini menerapkan semua fungsi pengiriman dan penerimaan pesan secara real time.  Arahan! #Client dan! #Server memberi tahu proses pengamat metode untuk bagian mana (klien atau server) yang dimaksudkan.  Jika tidak ada arahan ini sebelum mendefinisikan metode, metode seperti itu tersedia pada klien dan server.  Garis miring komentar sebelum arahan adalah opsional dan hanya ada untuk mencegah IDE standar bersumpah pada kesalahan sintaksis. <br><br>  Baris pertama jalur menggunakan pencarian &amp; root.  Saat membuat versi klien dan server, &amp; root akan diganti masing-masing dengan jalur relatif ke direktori publik dan yang dilindungi. <br><br>  Poin penting lainnya: dari metode klien, Anda hanya dapat memanggil metode server, yang namanya dimulai dengan "$": <br><br><pre> <code class="javascript hljs">... <span class="hljs-comment"><span class="hljs-comment">//    async sendMessage(e) { await this.$sendMessage(this.msg); &lt;-    this.msg = ''; } ...</span></span></code> </pre><br>  Ini dilakukan untuk alasan keamanan: dari luar Anda hanya dapat beralih ke metode yang dirancang khusus untuk ini. <br><br>  Mari kita lihat versi model data yang dihasilkan pengamat untuk klien dan server. <br><br>  <b>Klien</b> (publik / bersama / pesan / model / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} <span class="hljs-comment"><span class="hljs-comment">// constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); //     this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } // async sendMessage(e) { //    await this.$sendMessage(this.msg); this.msg = ''; } // ... async $sendMessage() {return await this.__runSharedFunction("$sendMessage",arguments)} }</span></span></code> </pre><br>  Di sisi klien, model adalah turunan dari kelas Vue (via Base.mjs).  Dengan demikian, Anda dapat bekerja dengannya seperti dengan model data Vue biasa.  Pengamat menambahkan metode __getFilePath__ ke versi klien dari model, yang mengembalikan path ke file kelas dan mengganti kode metode server $ sendMessage dengan konstruk yang, pada dasarnya, akan memanggil metode yang kita butuhkan pada server melalui mekanisme rpc (__runSharedFunction didefinisikan dalam kelas induk). <br><br>  <b>Server</b> (dilindungi / dibagikan / pesan / model / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} ...       ... <span class="hljs-comment"><span class="hljs-comment">// async $sendMessage(text) { //   newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  Dalam versi server, metode __getFilePath__ juga ditambahkan dan metode klien yang ditandai dengan arahan dihapus! #Client <br><br>  Di kedua versi model yang dibuat, semua baris yang dihapus diganti dengan yang kosong.  Ini dilakukan agar pesan kesalahan pada debugger dapat dengan mudah menemukan baris bermasalah dalam kode sumber model. <br><br><h4>  Interaksi klien-server </h4><br>  Ketika kita perlu memanggil beberapa metode server pada klien, kita lakukan saja. <br>  Jika panggilan itu dalam model yang sama, maka semuanya sederhana: <br><br><pre> <code class="javascript hljs">... !#client <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> sendMessage(e) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$sendMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg = <span class="hljs-string"><span class="hljs-string">''</span></span>; } !#server <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $sendMessage(msg) { <span class="hljs-comment"><span class="hljs-comment">// -    } ...</span></span></code> </pre><br>  Anda dapat "menarik" model lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"/shared/messages/model/dataModel.mjs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> dataModel(); msg.$sendMessage(<span class="hljs-string"><span class="hljs-string">'blah-blah-blah'</span></span>);</code> </pre><br>  Di arah yang berlawanan, mis.  Memanggil beberapa metode klien di server tidak berfungsi.  Secara teknis, ini layak, tetapi dari sudut pandang praktis tidak masuk akal, karena  server adalah satu, tetapi ada banyak klien.  Jika kami perlu melakukan beberapa tindakan pada server pada klien, kami menggunakan mekanisme acara: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ... //!#client constructor(attr) { .... //       "newmessage" this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#server async $sendMessage(text) { //     newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } ...</span></span></code> </pre><br>  Metode fireEvent mengambil 3 parameter: nama acara, kepada siapa itu ditujukan, dan data.  Anda dapat mengatur penerima dengan beberapa cara: kata kunci â€œsemuaâ€ - acara akan dikirim ke semua pengguna atau dalam larik untuk mencantumkan token sesi klien yang kepadanya acara tersebut ditangani. <br><br>  Acara ini tidak terikat pada contoh spesifik dari kelas model data dan penangan akan memecat dalam semua contoh kelas di mana fireEvent dipanggil. <br><br><h4>  Penskalaan backend horisontal </h4><br>  Monolithicity model client-server dalam implementasi yang diusulkan, pada pandangan pertama, harus memaksakan pembatasan yang signifikan pada kemungkinan penskalaan horizontal dari bagian server.  Tapi ini tidak begitu: secara teknis, server tidak tergantung pada klien.  Anda dapat menyalin direktori "publik" di mana saja dan memberikan kontennya melalui server web lain (nginx, apache, dll.). <br><br>  Sisi server dapat dengan mudah diperluas dengan meluncurkan instance backend baru.  Redis dan sistem antrian Kue digunakan untuk berinteraksi dengan instance individual. <br><br><h4>  API dan klien berbeda untuk satu backend </h4><br>  Dalam proyek nyata, beragam klien server dapat menggunakan satu server API - situs web, aplikasi seluler, layanan pihak ketiga.  Dalam solusi yang diusulkan, semua ini tersedia tanpa tarian tambahan.  Di bawah kap server metode panggilan adalah rpc tua yang baik.  Server web itu sendiri adalah aplikasi ekspres klasik.  Cukup menambahkan pembungkus di sana untuk rute dengan memanggil metode yang diperlukan dari model data yang sama. <br><br><h4>  Posting scriptum </h4><br>  Pendekatan yang diusulkan dalam artikel tidak berpura-pura dengan perubahan revolusioner dalam aplikasi client-server.  Itu hanya menambah sedikit kenyamanan pada proses pengembangan, memungkinkan Anda untuk fokus pada logika bisnis yang dirangkai di satu tempat. <br><br>  Proyek ini eksperimental, tulis di komentar apakah, menurut pendapat Anda, layak untuk melanjutkan percobaan ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435494/">https://habr.com/ru/post/id435494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435480/index.html">Microsoft dan Kroger akan memberikan perlawanan kepada Amazon di bidang ... perdagangan makanan</a></li>
<li><a href="../id435482/index.html">Sorot zirkon: vDSO (Objek Bersama Dinamis virtual)</a></li>
<li><a href="../id435484/index.html">Gaya fuzzing 1989</a></li>
<li><a href="../id435488/index.html">Mengolok-olok, bertopik dan mata-mata di Kerangka Kerja Spock</a></li>
<li><a href="../id435490/index.html">Perubahan pajak Google pada 2019</a></li>
<li><a href="../id435496/index.html">Tesla menggugat karena kecelakaan di mana pengemudi dan penumpang Model S meninggal</a></li>
<li><a href="../id435498/index.html">Perpanjangan Direktur vCloud: Migrasi</a></li>
<li><a href="../id435500/index.html">Sarung tangan biometrik di motorsport</a></li>
<li><a href="../id435502/index.html">Studi ini mengungkapkan pro dan kontra perfeksionisme</a></li>
<li><a href="../id435504/index.html">Monster tangan dalam perjuangan untuk kebersihan: pilihan vacuum cleaner manual Xiaomi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>