<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∏Ô∏è üóûÔ∏è üå∑ ¬øPor qu√© const no acelera el c√≥digo C / C ++? üîê üíÖüèº ü§¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unos meses, mencion√© en una publicaci√≥n que esto es un mito, como si const ayudara a habilitar las optimizaciones del compilador en C y C ++ . De...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øPor qu√© const no acelera el c√≥digo C / C ++?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/464777/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ck/cw/48/ckcw48o0aqklzf10gzhfqx8w3rw.jpeg"></div><br>  Hace unos meses, mencion√© en una publicaci√≥n que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto es un mito, como si const ayudara a habilitar las optimizaciones del compilador en C y C ++</a> .  Decid√≠ que esta declaraci√≥n deber√≠a explicarse, especialmente porque yo mismo cre√≠a en este mito antes.  Comenzar√© con teor√≠a y ejemplos artificiales, y luego pasar√© a experimentos y puntos de referencia basados ‚Äã‚Äãen una base de c√≥digo real: SQLite. <br><a name="habracut"></a><br><h2>  Prueba simple </h2><br>  Comencemos con, como me pareci√≥, el ejemplo m√°s simple y obvio de acelerar el c√≥digo C con <code>const</code> .  Digamos que tenemos dos declaraciones de funciones: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>;</code> </pre> <br>  Y supongamos que hay dos versiones del c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); func(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constByArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); constFunc(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); }</code> </pre> <br>  Para ejecutar <code>printf()</code> , el procesador debe recuperar <code>*x</code> de la memoria a trav√©s de un puntero.  Obviamente, la ejecuci√≥n de <code>constByArg()</code> puede ser un poco m√°s r√°pida, porque el compilador sabe que <code>*x</code> es una constante, por lo que no es necesario cargar su valor nuevamente despu√©s de que <code>constFunc()</code> haya hecho.  Derecho?  Veamos el c√≥digo de ensamblador generado por GCC con optimizaciones habilitadas: <br><br><pre> <code class="bash hljs">$ gcc -S -Wall -O3 test.c $ view test.s</code> </pre> <br>  Y aqu√≠ est√° el resultado completo del ensamblador para <code>byArg()</code> : <br><br><pre> <code class="plaintext hljs">byArg: .LFB23: .cfi_startproc pushq %rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movl (%rdi), %edx movq %rdi, %rbx leaq .LC0(%rip), %rsi movl $1, %edi xorl %eax, %eax call __printf_chk@PLT movq %rbx, %rdi call func@PLT # The only instruction that's different in constFoo movl (%rbx), %edx leaq .LC0(%rip), %rsi xorl %eax, %eax movl $1, %edi popq %rbx .cfi_def_cfa_offset 8 jmp __printf_chk@PLT .cfi_endproc</code> </pre> <br>  La √∫nica diferencia entre el c√≥digo ensamblador generado por <code>byArg()</code> y <code>constByArg()</code> es que <code>constByArg()</code> tiene una <code>call constFunc@PLT</code> , como en el c√≥digo fuente.  <code>const</code> s√≠ mismo no hace ninguna diferencia. <br><br>  Bien, eso fue GCC.  Quiz√°s necesitamos un compilador m√°s inteligente.  Di Clang <br><br><pre> <code class="cpp hljs">$ clang -S -Wall -O3 -emit-llvm test.c $ view test.ll</code> </pre> <br>  Aqu√≠ est√° el c√≥digo intermedio.  Es m√°s compacto que el ensamblador, y eliminar√© ambas funciones, para que entienda lo que quiero decir con "sin diferencia, excepto por la llamada": <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @byArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @func(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constByArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br><h2>  Opci√≥n que (tipo) funciona </h2><br>  Y aqu√≠ est√° el c√≥digo en el que la presencia de <code>const</code> realmente importa: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); constFunc(&amp;x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constLocalVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// const on the local variable printf("%d\n", x); constFunc(&amp;x); printf("%d\n", x); }</span></span></code> </pre> <br>  El c√≥digo del ensamblador para <code>localVar()</code> , que contiene dos instrucciones optimizadas fuera de <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">localVar: .LFB25: .cfi_startproc subq $<span class="hljs-number"><span class="hljs-number">24</span></span>, %rsp .cfi_def_cfa_offset <span class="hljs-number"><span class="hljs-number">32</span></span> movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, %edx movl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %edi movq %fs:<span class="hljs-number"><span class="hljs-number">40</span></span>, %rax movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rsp) xorl %eax, %eax leaq .LC0(%rip), %rsi movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp) call __printf_chk@PLT leaq <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %rdi call constFunc@PLT movl <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %edx <span class="hljs-meta"><span class="hljs-meta"># not in constLocalVar() xorl %eax, %eax movl $1, %edi leaq .LC0(%rip), %rsi # not in constLocalVar() call __printf_chk@PLT movq 8(%rsp), %rax xorq %fs:40, %rax jne .L9 addq $24, %rsp .cfi_remember_state .cfi_def_cfa_offset 8 ret .L9: .cfi_restore_state call __stack_chk_fail@PLT .cfi_endproc</span></span></code> </pre> <br>  El middleware LLVM es un poco m√°s limpio.  <code>load</code> antes de que la segunda llamada a <code>printf()</code> se optimizara fuera de <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @localVar() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">1</span></span> = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = bitcast i32* %<span class="hljs-number"><span class="hljs-number">1</span></span> to i8* call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.start.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 <span class="hljs-number"><span class="hljs-number">42</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* nonnull %<span class="hljs-number"><span class="hljs-number">1</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.end.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br>  Entonces, <code>constLocalVar()</code> ignor√≥ con √©xito el reinicio <code>*x</code> , pero podr√≠a notar algo extra√±o: en los cuerpos <code>localVar()</code> y <code>constLocalVar()</code> la misma llamada a <code>constFunc()</code> .  Si el compilador puede descubrir que <code>constFunc()</code> no modific√≥ <code>*x</code> en <code>constLocalVar()</code> , entonces ¬øpor qu√© no puede entender que la misma llamada de funci√≥n no modific√≥ <code>*x</code> en <code>localVar()</code> ? <br><br>  La explicaci√≥n es por qu√© no es pr√°ctico usar <code>const</code> en C como optimizaci√≥n.  En C, <code>const</code> tiene esencialmente dos significados posibles: <br><br><ul><li>  puede significar que una variable es un seud√≥nimo de solo lectura para algunos datos, que puede ser constante o no. <br></li><li>  o puede significar que la variable es realmente una constante.  Si desatas la <code>const</code> de un puntero a un valor constante y luego le escribes, obtendr√°s un comportamiento indefinido.  Por otro lado, no habr√° problema si <code>const</code> es un puntero a un valor que no es una constante. <br></li></ul><br>  Aqu√≠ hay un ejemplo explicativo de implementaci√≥n de <code>constFunc()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// x is just a read-only pointer to something that may or may not be a constant void constFunc(const int *x) { // local_var is a true constant const int local_var = 42; // Definitely undefined behaviour by C rules doubleIt((int*)&amp;local_var); // Who knows if this is UB? doubleIt((int*)x); } void doubleIt(int *x) { *x *= 2; }</span></span></code> </pre><br>  <code>localVar()</code> le dio a <code>constFunc()</code> un puntero <code>const</code> a una variable no <code>const</code> .  Dado que la variable no era <code>const</code> inicialmente, <code>constFunc()</code> puede resultar ser un mentiroso y modificar a la fuerza la variable sin iniciar UB.  Por lo tanto, el compilador no puede suponer que despu√©s de devolver <code>constFunc()</code> variable tendr√° el mismo valor.  La variable en <code>constLocalVar()</code> realmente es <code>const</code> , por lo que el compilador no puede suponer que no se cambiar√°, porque esta vez <i>ser√°</i> UB para <code>constFunc()</code> , de modo que el compilador desenlazar√° <code>const</code> y escribir√° en la variable. <br><br>  Las <code>byArg()</code> y <code>constByArg()</code> del primer ejemplo son in√∫tiles, porque el compilador no puede <code>constByArg()</code> si <code>*x</code> es <code>const</code> . <br><br>  ¬øPero de d√≥nde vino la inconsistencia?  Si el compilador puede suponer que <code>constFunc()</code> no cambia su argumento cuando se lo llama desde <code>constLocalVar()</code> , entonces puede aplicar las mismas optimizaciones a las llamadas <code>constFunc()</code> , ¬øverdad?  No  El compilador no puede asumir que <code>constLocalVar()</code> vez se llamar√° a <code>constLocalVar()</code> .  Y si no lo hace (por ejemplo, porque es solo un resultado adicional del generador de c√≥digo o la operaci√≥n de macro), entonces <code>constFunc()</code> puede cambiar silenciosamente los datos sin iniciar UB. <br><br>  Es posible que deba leer los ejemplos y la explicaci√≥n anteriores varias veces.  No te preocupes que suene absurdo, lo es.  Desafortunadamente, escribir en variables <code>const</code> es el peor tipo de UB: la mayor√≠a de las veces, el compilador ni siquiera sabe si ser√° UB.  Por lo tanto, cuando el compilador ve <code>const</code> , debe proceder del hecho de que alguien puede cambiarlo en alg√∫n lugar, lo que significa que el compilador no puede usar <code>const</code> para la optimizaci√≥n.  En la pr√°ctica, esto es cierto, porque una gran cantidad de c√≥digo C real contiene un rechazo de <code>const</code> en el estilo de "S√© lo que estoy haciendo". <br><br>  En resumen, hay muchas situaciones en las que el compilador no puede usar <code>const</code> para la optimizaci√≥n, incluida la recuperaci√≥n de datos de otro √°mbito mediante un puntero o la colocaci√≥n de datos en un mont√≥n.  O peor a√∫n, generalmente en situaciones donde el compilador no puede usar <code>const</code> , esto no es necesario.  Por ejemplo, cualquier compilador que se respete puede comprender sin <code>const</code> que en este c√≥digo <code>x</code> es una constante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y); y += x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y);</code> </pre> <br>  Entonces <code>const</code> casi in√∫til para la optimizaci√≥n, porque: <br><br><ol><li>  Con algunas excepciones, el compilador se ve obligado a ignorarlo, ya que algunos c√≥digos pueden desatar legalmente la <code>const</code> . <br></li><li>  En la mayor√≠a de las excepciones anteriores, el compilador a√∫n puede entender que la variable es una constante. <br></li></ol><br><h2>  C ++ </h2><br>  Si escribe en C ++, entonces <code>const</code> puede afectar la generaci√≥n de c√≥digo a trav√©s de la sobrecarga de funciones.  Puede tener sobrecargas <code>const</code> y no <code>const</code> de la misma funci√≥n, y no <code>const</code> puede ser optimizado (por un programador, no un compilador), por ejemplo, para copiar menos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Needs to do more copying of data } void foo(const int *p) { // Doesn't need defensive copies } int main() { const int x = 42; // const-ness affects which overload gets called foo(&amp;x); return 0; }</span></span></code> </pre> <br>  Por un lado, no creo que en la pr√°ctica esto se aplique a menudo en c√≥digo C ++.  Por otro lado, para que realmente marque la diferencia, un programador debe hacer suposiciones que no est√°n disponibles para el compilador, ya que no est√°n garantizadas por el lenguaje. <br><br><h2>  Experimente con SQLite3 </h2><br>  Suficiente teor√≠a y ejemplos descabellados.  ¬øQu√© efecto tiene <code>const</code> en la base de c√≥digo real?  Decid√≠ experimentar con SQLite DB (versi√≥n 3.30.0) porque: <br><br><ul><li>  Utiliza <code>const.</code> </li><li>  Esta es una base de c√≥digo no trivial (m√°s de 200 KLOC). <br></li><li>  Como base de datos, incluye varios mecanismos, comenzando con el procesamiento de valores de cadena y terminando con la conversi√≥n de n√∫meros hasta la fecha. <br></li><li>  Se puede probar con una carga limitada del procesador. <br></li></ul><br>  Adem√°s, el autor y los programadores involucrados en el desarrollo ya han pasado a√±os mejorando la productividad, por lo que podemos suponer que no se perdieron nada obvio. <br><br><h3>  Preparaci√≥n </h3><br>  Hice dos copias del <a href="">c√≥digo fuente</a> .  Uno compilado en modo normal, y el segundo preprocesado utilizando un hack para convertir a <code>const</code> en un comando inactivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> const</span></span></code> </pre> <br>  (GNU) <code>sed</code> puede agregar esto encima de cada archivo con el comando <code>sed -i '1i#define const' *.c *.h</code> . <br><br>  SQLite complica las cosas un poco, usando scripts para generar c√≥digo durante la compilaci√≥n.  Afortunadamente, los compiladores introducen mucho ruido al mezclar c√≥digo con <code>const</code> y sin <code>const</code> , por lo que inmediatamente puede notar y configurar los scripts para agregar mi c√≥digo anti- <code>const</code> . <br><br>  La comparaci√≥n directa de los c√≥digos compilados no tiene sentido, ya que un peque√±o cambio puede afectar todo el esquema de memoria, lo que conducir√° a un cambio en los punteros y las llamadas de funci√≥n en todo el c√≥digo.  Por lo tanto, tom√© un elenco desmontado ( <code>objdump -d libSQLite3.so.0.8.6</code> ) como el tama√±o del binario y el nombre mnemot√©cnico de cada instrucci√≥n.  Por ejemplo, esta funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">000000000005</span></span>d570 &lt;SQLite3_blob_read&gt;: <span class="hljs-number"><span class="hljs-number">5</span></span>d570: <span class="hljs-number"><span class="hljs-number">4</span></span>c <span class="hljs-number"><span class="hljs-number">8</span></span>d <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> a2 ff ff lea <span class="hljs-number"><span class="hljs-number">-0x5da7</span></span>(%rip),%r8 # <span class="hljs-number"><span class="hljs-number">577</span></span>d0 &lt;SQLite3BtreePayloadChecked&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d577: e9 <span class="hljs-number"><span class="hljs-number">04</span></span> fe ff ff jmpq <span class="hljs-number"><span class="hljs-number">5</span></span>d380 &lt;blobReadWrite&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d57c: <span class="hljs-number"><span class="hljs-number">0f</span></span> <span class="hljs-number"><span class="hljs-number">1f</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> nopl <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rax)</code> </pre> <br>  Se convierte en: <br><br><pre> <code class="cpp hljs">SQLite3_blob_read <span class="hljs-number"><span class="hljs-number">7l</span></span>ea <span class="hljs-number"><span class="hljs-number">5</span></span>jmpq <span class="hljs-number"><span class="hljs-number">4</span></span>nopl</code> </pre> <br>  Al compilar, no cambi√© la configuraci√≥n del ensamblaje SQLite. <br><br><h3>  An√°lisis de c√≥digo compilado </h3><br>  Para libSQLite3.so, la versi√≥n con <code>const</code> ocup√≥ 4.740.704 bytes, aproximadamente un 0.1% m√°s que la versi√≥n sin <code>const</code> con 4.736.712 bytes.  En ambos casos, se exportaron 1374 funciones (sin contar las funciones auxiliares de bajo nivel en el PLT), y 13 tuvieron diferencias en los lanzamientos. <br><br>  Algunos cambios estaban relacionados con el hack de preprocesamiento.  Por ejemplo, aqu√≠ est√° una de las funciones modificadas (elimin√© algunas definiciones espec√≠ficas de SQLite): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LARGEST_INT64 (0xffffffff|(((int64_t)0x7fffffff)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;32)) #define SMALLEST_INT64 (((int64_t)-1) - LARGEST_INT64) static int64_t doubleToInt64(double r){ /* ** Many compilers we encounter do not define constants for the ** minimum and maximum 64-bit integers, or they define them ** inconsistently. And many do not understand the "LL" notation. ** So we define our own static constants here using nothing ** larger than a 32-bit integer constant. */ static const int64_t maxInt = LARGEST_INT64; static const int64_t minInt = SMALLEST_INT64; if( r&lt;=(double)minInt ){ return minInt; }else if( r&gt;=(double)maxInt ){ return maxInt; }else{ return (int64_t)r; } }</span></span></span></span></code> </pre> <br>  Si eliminamos <code>const</code> , estas constantes se convierten en variables <code>static</code> .  No entiendo por qu√© alguien a quien no le importa <code>const</code> hacer que estas variables sean <code>static</code> .  Si eliminamos tanto la <code>static</code> como la <code>const</code> , GCC nuevamente las considerar√° constantes y obtendremos el mismo resultado.  Debido a estas variables <code>static const</code> , los cambios en tres funciones de trece resultaron ser falsas, pero no las solucion√©. <br><br>  SQLite usa muchas variables globales, y la mayor√≠a de las optimizaciones <code>const</code> verdaderas est√°n conectadas con esto: como reemplazar una comparaci√≥n con una variable con una comparaci√≥n con una constante o retroceder parcialmente el ciclo un paso (para comprender qu√© tipo de optimizaciones se hicieron, us√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Radare</a> ).  No vale la pena mencionar algunos cambios.  <code>SQLite3ParseUri()</code> contiene 487 instrucciones, pero <code>const</code> realiz√≥ solo un cambio: tom√≥ estas dos comparaciones: <br><br><pre> <code class="cpp hljs">test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br>  Y cambiado: <br><br><pre> <code class="cpp hljs">cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br><h3>  Puntos de referencia </h3><br>  SQLite viene con una prueba de regresi√≥n para medir el rendimiento, y lo ejecut√© cientos de veces para cada versi√≥n del c√≥digo usando la configuraci√≥n de compilaci√≥n est√°ndar de SQLite.  Tiempo de ejecuci√≥n en segundos: <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  const <br></td><td>  Sin constante <br></td></tr><tr><td>  M√≠nimo <br></td><td>  10,658 <br></td><td>  10,803 <br></td></tr><tr><td>  Mediana <br></td><td>  11,571 <br></td><td>  11,519 <br></td></tr><tr><td>  M√°xima <br></td><td>  11,832 <br></td><td>  11,658 <br></td></tr><tr><td>  Media <br></td><td>  11,531 <br></td><td>  11,492 <br></td></tr></tbody></table></div><br>  Personalmente, no veo mucha diferencia.  Elimin√© <code>const</code> de todo el programa, as√≠ que si hab√≠a una diferencia notable, entonces era f√°cil notarlo.  Sin embargo, si el rendimiento es extremadamente importante para usted, incluso una peque√±a aceleraci√≥n puede complacerlo.  Hagamos un an√°lisis estad√≠stico. <br><br>  Me gusta usar la prueba U de Mann-Whitney para tales tareas. Es similar a la prueba t m√°s conocida, dise√±ada para determinar las diferencias en los grupos, pero es m√°s resistente a las variaciones aleatorias complejas que ocurren al medir el tiempo en las computadoras (debido a cambios de contexto impredecibles, errores en p√°ginas de memoria, etc.).  Aqu√≠ est√° el resultado: <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  const </th><th>  Sin constante </th></tr><tr><td>  N </td><td>  100 </td><td>  100 </td></tr><tr><td>  Categor√≠a media (rango medio) </td><td>  121,38 </td><td>  79,62 </td></tr><tr><td>  Mann-whitney u </td><td></td><td>  2912 </td></tr><tr><td>  Z </td><td></td><td>  -5,10 </td></tr><tr><td>  Valor p de 2 lados </td><td></td><td>  &lt;10 <sup>-6</sup> <br></td></tr><tr><td>  La diferencia promedio es HL <br></td><td></td><td>  -0.056 s. <br></td></tr><tr><td>  Intervalo de confianza del 95 por ciento <br></td><td></td><td>  -0,077 ... -0,038 s. <br></td></tr></tbody></table></div><br>  La prueba U encontr√≥ una diferencia estad√≠sticamente significativa en el rendimiento.  Pero, ¬°una sorpresa!  - La versi√≥n sin <code>const</code> result√≥ ser m√°s r√°pida, en unos 60 ms, es decir, en un 0,5%.  Parece que el peque√±o n√∫mero de "optimizaciones" realizadas no vali√≥ el aumento en la cantidad de c√≥digo.  Es poco probable que <code>const</code> activado alguna optimizaci√≥n importante, como la vectorizaci√≥n autom√°tica.  Por supuesto, su kilometraje puede depender de varios indicadores en el compilador, o en su versi√≥n, o en la base del c√≥digo, o en otra cosa.  Pero me parece honesto decir que incluso si <code>const</code> mejora el rendimiento de C, no me di cuenta de esto. <br><br><h2>  Entonces, ¬øpara qu√© se necesita const? </h2><br>  Para todos sus defectos, <code>const</code> en C / C ++ es √∫til para proporcionar seguridad de tipo.  En particular, si usa <code>const</code> en combinaci√≥n con sem√°ntica de movimiento y <code>std::unique_pointer</code> , puede implementar la propiedad expl√≠cita del puntero.  La incertidumbre sobre la propiedad del puntero fue un gran problema en las bases de c√≥digo C ++ m√°s antiguas de m√°s de 100 KLOC, por lo que estoy agradecido de poder <code>const</code> para resolverlo. <br><br>  Sin embargo, antes de ir m√°s all√° de usar <code>const</code> para proporcionar seguridad de tipo.  Escuch√© que se considera correcto usar <code>const</code> tan activamente como sea posible para mejorar el rendimiento.  Escuch√© que si el rendimiento es realmente importante, entonces debes refactorizar el c√≥digo para agregar m√°s <code>const</code> , incluso si el c√≥digo se vuelve menos legible.  Parec√≠a razonable en ese momento, pero desde entonces me di cuenta de que esto no era cierto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464777/">https://habr.com/ru/post/464777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464763/index.html">Benchmarks para servidores en Linux: una selecci√≥n de herramientas abiertas</a></li>
<li><a href="../464765/index.html">Configurando FreePBX + GoIP</a></li>
<li><a href="../464769/index.html">C√≥mo Badoo hizo posible entregar 200k fotos por segundo</a></li>
<li><a href="../464773/index.html">Mecanografiado asincr√≥nico en una rica aplicaci√≥n de Internet y decoradores para combatirlo</a></li>
<li><a href="../464775/index.html">21 de septiembre Badoo PHP Meetup # 3: Rendimiento</a></li>
<li><a href="../464779/index.html">Sobre las abejas hedonistas, la forma en que las personas las hacen trabajar y los drones</a></li>
<li><a href="../464781/index.html">Televisores inteligentes: CRT a HDR</a></li>
<li><a href="../464785/index.html">Beneficios no competitivos de Beeline</a></li>
<li><a href="../464791/index.html">Kubernetes para el autom√≥vil: c√≥mo abrir el acceso del desarrollador a la computadora de a bordo y hacerla segura</a></li>
<li><a href="../464795/index.html">Merry Quartusel, o c√≥mo el procesador ha llegado a tal vida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>