<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçü§ù‚Äçüë®üèΩ üë∂üèº ü§õüèæ Matem√°tica gen√©rica n√£o segura em C # üèÆ üë®üèº‚Äçüé§ ü§ôüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Infelizmente, n√£o foi f√°cil traduzir adequadamente o nome da fei√∫ra que comecei para o russo. Fiquei surpreso ao descobrir que a documenta√ß√£o oficial ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matem√°tica gen√©rica n√£o segura em C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480416/"><p><img src="https://habrastorage.org/webt/mj/zg/yw/mjzgywquj0lud4_vs9bjh8xdacu.png"></p><br><p> Infelizmente, n√£o foi f√°cil traduzir adequadamente o nome da fei√∫ra que comecei para o russo.  Fiquei surpreso ao descobrir que a documenta√ß√£o oficial do <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/" rel="nofollow">MSDN</a> chama ‚Äúmodelos gen√©ricos‚Äù (modelos similares ao <code>C++</code> , suponho).  Na 4¬™ edi√ß√£o do <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow"><code>"CLR</code> via <code>C#</code> ‚Äù que</a> chamou minha aten√ß√£o <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow">,</a> <a href="https://twitter.com/jeffrichter" rel="nofollow">Jeffrey Richter</a> , traduzido por <a href="https://habr.com/en/company/piter/">Peter</a> , os gen√©ricos s√£o chamados de ‚Äúgeneraliza√ß√µes‚Äù, o que reflete o conceito muito melhor.  Este artigo abordar√° <em>opera√ß√µes matem√°ticas generalizadas inseguras em <code>C#</code></em> .  Considerando que o <code>C#</code> n√£o se destina √† computa√ß√£o de alto desempenho (embora, √© claro, seja capaz disso, mas n√£o seja capaz de competir com o mesmo <code>C/C++</code> ), as opera√ß√µes matem√°ticas no <code>BCL</code> n√£o recebem muita aten√ß√£o.  Vamos tentar simplificar o trabalho com tipos aritm√©ticos b√°sicos usando <code>C#</code> e <code>CLR</code> . </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Declara√ß√£o do problema </h2><br><p>  <strong>Isen√ß√£o de responsabilidade</strong> : o artigo conter√° muitos fragmentos de c√≥digo, alguns dos quais ilustrarei com links para o maravilhoso recurso <a href="https://sharplab.io/" rel="nofollow">SharpLab</a> ( <a href="https://github.com/ashmind/SharpLab" rel="nofollow">Gi <s>r</s> tHub</a> ) de <a href="https://twitter.com/ashmind" rel="nofollow">Andrey Shchekin</a> . </p><br><p>  A maioria dos c√°lculos, de uma maneira ou de outra, se resume a opera√ß√µes b√°sicas.  Adi√ß√£o, subtra√ß√£o (invers√£o, nega√ß√£o), multiplica√ß√£o e divis√£o podem ser complementadas por opera√ß√µes de compara√ß√£o e verifica√ß√£o de igualdade.  Obviamente, todas essas a√ß√µes podem ser executadas de maneira f√°cil e simples em vari√°veis ‚Äã‚Äãde qualquer tipo aritm√©tico b√°sico de <code>C#</code> .  O √∫nico problema √© que o <code>C#</code> deve <em>saber</em> em tempo de compila√ß√£o que as opera√ß√µes s√£o executadas em tipos espec√≠ficos e parece que √© imposs√≠vel escrever um m√©todo que igualmente eficiente (e transparente) adicione dois n√∫meros inteiros e dois n√∫meros de ponto flutuante. </p><br><p>  Vamos especificar nossos desejos por um m√©todo generalizado hipot√©tico que execute alguma opera√ß√£o matem√°tica simples: </p><br><ol><li>  Um m√©todo deve ter restri√ß√µes de tipo generalizadas que nos protegem de tentar adicionar (ou multiplicar, dividir) dois tipos arbitr√°rios.  Precisamos de alguma restri√ß√£o de tipo gen√©rico. </li><li>  Para a pureza do experimento, os tipos aceitos e retornados devem ser os mesmos.  Por exemplo, um operador bin√°rio deve ter uma assinatura no formato <code>(T, T) =&gt; T</code> </li><li>  O m√©todo deve ser pelo menos parcialmente otimizado.  Por exemplo, o boxe onipresente √© inaceit√°vel. </li></ol><br><h2 id="a-chto-tam-u-sosedey">  E os vizinhos? </h2><br><p>  Vamos olhar para <code>F#</code> .  Eu n√£o sou forte em <code>F#</code> , mas a maioria das restri√ß√µes de <code>C#</code> √© ditada pelas limita√ß√µes do <code>CLR</code> , o que significa que o <code>F#</code> sofre dos mesmos problemas.  Voc√™ pode tentar declarar um m√©todo de adi√ß√£o generalizada expl√≠cita e o m√©todo de adi√ß√£o usual e ver o que o sistema de infer√™ncia do tipo <code>F#</code> diz: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x + y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> xy = x + y add_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore</code> </pre> <br><p>  Nesse <a href="https://sharplab.io/" rel="nofollow">caso, os</a> dois m√©todos n√£o ser√£o generalizados e o c√≥digo gerado ser√° id√™ntico.  Dada a rigidez do sistema do tipo <code>F#</code> , em que n√£o h√° convers√µes impl√≠citas no formato <code>int -&gt; double</code> , ap√≥s a primeira chamada desses m√©todos com par√¢metros do tipo <code>double</code> (em termos de <code>C#</code> ), chame m√©todos com par√¢metros de outros tipos (mesmo com uma poss√≠vel perda de precis√£o devido √† convers√£o de tipos) mais falhar√°. </p><br><p>  √â importante notar que, se voc√™ substituir o operador <code>+</code> operador de igualdade <code>=</code> , a <a href="https://sharplab.io/" rel="nofollow">imagem se tornar√° um pouco diferente</a> : ambos os m√©todos se tornam generalizados (do ponto de vista de <code>C#</code> ), e um m√©todo auxiliar especial, dispon√≠vel em <code>F#</code> √© chamado para realizar a compara√ß√£o. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x = y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq xy = x = y eq_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq_gen <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore</code> </pre> <br><h3 id="chto-naschet-java">  E o <code>Java</code> ? </h3><br><p>  √â dif√≠cil para mim falar sobre <code>Java</code> , mas, tanto quanto posso dizer, tipos significativos <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">n√£o</a> existem da forma usual para n√≥s, mas ainda existem tipos <em>primitivos</em> .  Para trabalhar com primitivas em <code>Java</code> existem <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">wrappers</a> (por exemplo, uma refer√™ncia <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" rel="nofollow"><code>Long</code></a> para primitivo por valor <code>long</code> ), que possuem uma classe base comum <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html" rel="nofollow"><code>Number</code></a> .  Portanto, voc√™ pode generalizar parcialmente as opera√ß√µes usando <code>Number</code> , mas esse √© um tipo de refer√™ncia, que provavelmente n√£o ter√° um efeito positivo no desempenho. </p><br><p>  <em>Me corrija se eu estiver errado.</em> </p><br><h3 id="c">  <code>C++</code> ? </h3><br><p>  <code>C++</code> √© uma linguagem para trapaceiros. <br>  <code>C++</code> abre caminho para recursos que alguns consideram ... <a href="https://ru.wikiquote.org/wiki/%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B._%25D0%25AD%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B4_III:_%25D0%259C%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D1%2581%25D0%25B8%25D1%2582%25D1%2585%25D0%25BE%25D0%25B2" rel="nofollow">n√£o naturais</a> . <br>  Modelos (tamb√©m conhecidos como modelos), em contraste com generaliza√ß√µes (gen√©ricos), s√£o, no sentido literal, <em>modelos</em> .  Ao declarar um modelo, voc√™ pode restringir explicitamente os tipos para os quais esse modelo est√° dispon√≠vel.  Por esse motivo, em <code>C++</code> , por exemplo, o seguinte c√≥digo √© v√°lido: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T, std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;* = nullptr&gt; T Add (T left, T right) { return left + right; } int main() { std::cout &lt;&lt; Add(5, 6) &lt;&lt; std::endl; std::cout &lt;&lt; Add(5.0, 6.0) &lt;&lt; std::endl; // std::cout &lt;&lt; Add("a", "b") &lt;&lt; std::endl; Does not compile }</span></span></span></span></code> </pre> <br><p>  <code>is_arithmetic</code> , infelizmente, permite <code>char</code> e <code>bool</code> como par√¢metros.  Por outro lado, <code>char</code> pode ser equivalente a <code>sbyte</code> na terminologia <code>C#</code> , embora os tamanhos reais dos tipos inteiros dependam da fase da plataforma / compilador / lua. </p><br><h3 id="yazyki-s-dinamicheskoy-tipizaciey">  Idiomas de digita√ß√£o din√¢mica </h3><br><p>  Por fim, considere algumas linguagens dinamicamente tipadas (e <em>interpretadas</em> ), agu√ßadas pelo c√°lculo.  Nessas linguagens, geralmente a generaliza√ß√£o da computa√ß√£o n√£o causa problemas: se o tipo de par√¢metro for adequado para execu√ß√£o, al√©m disso, condicionalmente, a opera√ß√£o ser√° executada, caso contr√°rio, falhar√° com um erro. </p><br><p>  No <code>Python</code> (3.7.3 x64): </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y type(add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># &lt;class 'int'&gt; type(add(5.0, 6.0)) # &lt;class 'float'&gt; type(add('a', 'b') # &lt;class 'str'&gt;</span></span></code> </pre> <br><p>  Em <code>R</code> (3.6.1 x64) </p><br><pre> <code class="cpp hljs">add &lt;- function(x, y) x + y # <span class="hljs-function"><span class="hljs-function">Or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5L</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6L</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: integer vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"5"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"6"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Error in x + y : non-numeric argument to binary </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span></span></code> </pre> <br><h2 id="obratno-v-mir-c-ogranichivaem-obobschennyy-tip-matematicheskoy-funkcii">  Por outro lado, no mundo C #: restringimos o tipo generalizado de fun√ß√£o matem√°tica </h2><br><p>  Infelizmente, n√£o podemos fazer isso.  Em <code>C#</code> tipos primitivos s√£o tipos de valor, ou seja,  estruturas que, embora herdadas de <code>System.Object</code> (e <a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype%3Fview%3Dnetcore-3.0" rel="nofollow"><code>System.ValueType</code></a> ), n√£o t√™m muito em comum.  Uma limita√ß√£o natural e l√≥gica √© <code>where T : struct</code> .  Come√ßando com <code>C# 7.3</code> temos a restri√ß√£o <code>where T : unmanaged</code> , o que significa que <code>T</code> √© um <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow"><code> ,        null</code></a> .  Al√©m dos tipos aritm√©ticos primitivos de que precisamos, <code>char</code> , <code>bool</code> , <code>decimal</code> , <em>qualquer</em> <code>Enum</code> e <em>qualquer</em> estrutura cujos todos os campos tenham o mesmo tipo <code>unmanaged</code> atendem a esses requisitos.  I.e.  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow">este tipo</a> passar√° no teste: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coords&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TY; }</code> </pre> <br><p>  Portanto, n√£o podemos escrever uma fun√ß√£o generalizada que aceite apenas os tipos aritm√©ticos desejados.  Da√≠ a <code>Unsafe</code> no t√≠tulo do artigo - teremos que confiar nos programadores que usam nosso c√≥digo.  Uma tentativa de chamar o m√©todo hipot√©tico generalizado <code>T Add&lt;T&gt;(T left, T right) where T : unmanaged</code> levar√° a resultados imprevis√≠veis se o programador passar objetos de um tipo incompat√≠vel como argumentos. </p><br><h2 id="eksperiment-pervyy-naivnyy-dynamic">  O primeiro experimento, ing√™nuo: <code>dynamic</code> </h2><br><p>  <code>dynamic</code> √© a primeira e √≥bvia ferramenta que pode nos ajudar a resolver nosso problema.  Obviamente, usar a <code>dynamic</code> para c√°lculos √© absolutamente in√∫til - a <code>dynamic</code> equivalente ao <code>object</code> , e os m√©todos chamados com uma vari√°vel <code>dynamic</code> s√£o transformados em uma reflex√£o monstruosa pelo compilador.  Como um b√¥nus - empacotar / descompactar nossos tipos de valor.  Aqui est√° <a href="https://sharplab.io/" rel="nofollow">um exemplo</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Add(<span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> =&gt; left + right; }</code> </pre> <br><p>  Basta olhar para a <code>IL</code> m√©todo <code>Method</code> : </p><br><pre> <code class="cs hljs">.<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Method begins at RVA 0x2050 // Code size 53 (0x35) .maxstack 8 IL_0000: ldc.i4.5 IL_0001: box [System.Private.CoreLib]System.Int32 IL_0006: ldc.i4.6 IL_0007: box [System.Private.CoreLib]System.Int32 IL_000c: call object Class::Add(object, object) IL_0011: pop IL_0012: ldc.r8 5 IL_001b: box [System.Private.CoreLib]System.Double IL_0020: ldc.r8 6 IL_0029: box [System.Private.CoreLib]System.Double IL_002e: call object Class::Add(object, object) IL_0033: pop IL_0034: ret } // end of method Class::Method</span></span></code> </pre> <br><p>  Carregou <code>5</code> , <em>empacotou</em> , carregou <code>6</code> , empacotou, chamado <code>object Add(object, object)</code> . <br>  A op√ß√£o obviamente n√£o nos conv√©m. </p><br><h2 id="eksperiment-vtoroy-v-lob">  O segundo experimento, "na testa" </h2><br><p>  Bem, a <code>dynamic</code> n√£o √© para n√≥s, mas o n√∫mero de nossos tipos √© finito e eles s√£o conhecidos antecipadamente.  Vamos nos armar com um <s>p√© de cabra de</s> ramo e anot√°-lo: se <em>nosso</em> tipo <em>for</em> , vamos calcular algo, caso contr√°rio - aqui est√° a exce√ß√£o. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Left &amp;&amp; right <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Right) { <span class="hljs-comment"><span class="hljs-comment">// ??? } // ... throw new NotSupportedException(); }</span></span></code> </pre> <br><p>  III, aqui nos deparamos com um problema.  Se voc√™ entender com quais tipos estamos trabalhando, ainda poder√° aplicar a opera√ß√£o a eles, ent√£o o <code>int</code> condicional resultante precisar√° ser convertido em um tipo desconhecido <code>T</code> e isso n√£o √© muito simples.  A op√ß√£o de <code>return (T)(i32Left + i32Right)</code> n√£o √© compilada - n√£o h√° garantia de que <code>T</code> seja <code>int</code> (mesmo sabendo que √©).  Voc√™ pode tentar o <code>return (T)(object)(i32Left + i32Right)</code> convers√£o dupla <code>return (T)(object)(i32Left + i32Right)</code> .  Primeiro, a quantidade √© embalada e depois descompactada em <code>T</code>  Isso <strong>s√≥</strong> funcionar√° se os tipos <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="nofollow">corresponderem</a> antes e depois da embalagem.  Voc√™ n√£o pode empacotar <code>int</code> , mas descompacte-o em <code>double</code> , mesmo se houver uma convers√£o impl√≠cita <code>int -&gt; double</code> .  O problema com <a href="https://sharplab.io/" rel="nofollow">esse</a> c√≥digo √© a ramifica√ß√£o gigante e a abund√¢ncia de pacotes de descompacta√ß√£o, mesmo que <code>if</code> condi√ß√µes.  Esta op√ß√£o tamb√©m n√£o √© boa. </p><br><h2 id="refleksiya-i-metadannye">  Reflex√£o e Metadados </h2><br><p>  Bem, toque e basta.  Todo mundo sabe que existem operadores em <code>C#</code> que podem ser substitu√≠dos.  L√°, existem <code>+</code> , <code>-</code> , <code>==</code> , <code>==</code> <code>!=</code> E assim por diante.  Tudo o que precisamos fazer √© usar um m√©todo est√°tico do tipo <code>T</code> correspondente ao operador, por exemplo, adi√ß√µes - isso √© tudo.  Bem, sim, novamente alguns pacotes, mas sem ramifica√ß√£o e sem problemas.  A coisa toda pode ser armazenada em cache pelo tipo <code>T</code> e geralmente acelera o processo de todas as formas, reduzindo uma opera√ß√£o matem√°tica a chamar um √∫nico m√©todo de reflex√£o.  Bem, algo como isto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-comment"><span class="hljs-comment">// Simple example without cache. var method = typeof(T) .GetMethod(@"op_Addition", new [] {typeof(T), typeof(T)}) ?.CreateDelegate(typeof(Func&lt;T, T, T&gt;)) as Func&lt;T, T, T&gt;; return method?.Invoke(left, right) ?? throw new InvalidOperationException(); }</span></span></code> </pre> <br><p>  Infelizmente isso <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">n√£o funciona</a> .  O fato √© que os tipos aritm√©ticos (mas n√£o <code>decimal</code> ) <em>n√£o possuem</em> um m√©todo est√°tico.  Todas as opera√ß√µes s√£o implementadas atrav√©s de opera√ß√µes de <code>IL</code> , como <a href="" rel="nofollow"><code>add</code></a> .  A reflex√£o normal n√£o resolve o nosso problema. </p><br><h2 id="systemlinqexpressions">  System.Linq.Expressions </h2><br><p>  A solu√ß√£o baseada em <code>Expressions</code> √© descrita no blog de <a href="https://twitter.com/jonskeet" rel="nofollow">John Skeet</a> <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">aqui</a> (de Marc Gravell). <br>  A ideia √© bem simples.  Suponha que temos um tipo <code>T</code> que suporta a opera√ß√£o <code>+</code> .  Vamos criar uma express√£o como esta: </p><br><pre> <code class="cs hljs">(x, y) =&gt; x + y;</code> </pre> <br><p>  Depois disso, ap√≥s o cache, vamos us√°-lo.  Construir essa express√£o √© bastante f√°cil.  Precisamos de dois par√¢metros e uma opera√ß√£o.  Ent√£o, vamos anot√°-la. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt; Cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-comment"><span class="hljs-comment">// If op is cached by type and function name, use cached version if (Cache.TryGetValue((t, nameof(Add)), out var del)) return del is Func&lt;T, T, T&gt; specificFunc ? specificFunc(left, right) : throw new InvalidOperationException(nameof(Add)); var leftPar = Expression.Parameter(t, nameof(left)); var rightPar = Expression.Parameter(t, nameof(right)); var body = Expression.Add(leftPar, rightPar); var func = Expression.Lambda&lt;Func&lt;T, T, T&gt;&gt;(body, leftPar, rightPar).Compile(); Cache[(t, nameof(Add))] = func; return func(left, right); }</span></span></code> </pre> <br><p>  Informa√ß√µes √∫teis sobre √°rvores de express√£o e delegados foram publicadas no hub </p><br><p>  Tecnicamente, express√µes nos permitem resolver todos os nossos problemas - qualquer opera√ß√£o b√°sica pode ser reduzida a chamar um m√©todo generalizado.  Qualquer opera√ß√£o mais complexa pode ser escrita da mesma maneira, usando express√µes mais complexas.  Isso √© <em>quase o</em> suficiente. </p><br><h2 id="narushaem-vse-pravila">  N√≥s quebramos todas as regras </h2><br><p>  √â poss√≠vel conseguir algo mais usando o poder do <code>CLR/C#</code> ?  Vamos ver em que <s>ano o</s> c√≥digo √© gerado por m√©todos de adi√ß√£o <a href="https://sharplab.io/" rel="nofollow">para diferentes tipos</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-comment"><span class="hljs-comment">// Decimal only to show difference public static decimal Add(decimal x, decimal y) =&gt; x + y; }</span></span></code> </pre> <br><p>  O c√≥digo <code>IL</code> correspondente cont√©m o mesmo conjunto de instru√ß√µes: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret</code> </pre> <br><p>  Este √© o c√≥digo op muito <a href="" rel="nofollow"><code>add</code></a> no qual a adi√ß√£o de tipos primitivos aritm√©ticos √© compilada.  <code>decimal</code> nesse local chama <code>static decimal decimal.op_Addition(decimal, decimal)</code> .  Mas e se escrevermos um m√©todo que ser√° generalizado, mas conter exatamente esse c√≥digo <code>IL</code> ?  Bem, John Skeet adverte que isso <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">n√£o vale a pena</a> .  No seu caso, ele considera todos os tipos (incluindo <code>decimal</code> ), bem como seus an√°logos <code>nullable</code> .  Isso exigir√° opera√ß√µes de <code>IL</code> n√£o triviais e levar√° necessariamente a um erro.  Mas ainda podemos tentar implementar opera√ß√µes b√°sicas. </p><br><p>  Para minha surpresa, o <code>Visual Studio</code> n√£o cont√©m modelos para projetos e arquivos de <code>IL</code> .  Voc√™ n√£o pode simplesmente pegar e descrever parte do c√≥digo em <code>IL</code> e inclu√≠-lo em sua montagem.  Naturalmente, o c√≥digo aberto vem em nosso aux√≠lio.  O projeto <a href="https://github.com/ins0mniaque/ILSupport" rel="nofollow"><code>ILSupport</code></a> cont√©m modelos para projetos de <code>IL</code> , bem como um conjunto de instru√ß√µes que podem ser adicionadas a <code>*.csproj</code> para incluir o c√≥digo de <code>IL</code> no projeto.  Obviamente, descrever tudo em <code>IL</code> √© bastante dif√≠cil, portanto o autor do projeto usa o atributo <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute%3Fview%3Dnetcore-3.0" rel="nofollow"><code>MethodImpl</code></a> com o sinalizador <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions%3Fredirectedfrom%3DMSDN%26view%3Dnetcore-3.0" rel="nofollow"><code>ForwardRef</code></a> .  Este atributo permite que voc√™ declare o m√©todo como <code>extern</code> e n√£o descreva o corpo do m√©todo.  Parece algo como isto: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.ForwardRef)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  A pr√≥xima etapa √© escrever a implementa√ß√£o do m√©todo no arquivo <code>*.il</code> com c√≥digo <code>IL</code> : </p><br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hidebysig !!T Add&lt;valuetype .ctor (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">ValueType</span></span> <span class="hljs-title"><span class="hljs-title">modreq</span></span> ([<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Runtime</span></span>.<span class="hljs-title"><span class="hljs-title">InteropServices</span></span>.<span class="hljs-title"><span class="hljs-title">UnmanagedType</span></span>)) <span class="hljs-title"><span class="hljs-title">T</span></span>&gt;(!!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>, !!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { .param type [<span class="hljs-number"><span class="hljs-number">1</span></span>] .custom instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = (<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ) ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret }</code> </pre> <br><p>  Em nenhum lugar explicitamente referindo-se ao tipo <code>!!T</code> , sugerimos que o <code>CLR</code> adicione dois argumentos e retorne o resultado.  N√£o <strong>h√°</strong> verifica√ß√£o de tipo e tudo est√° na consci√™ncia do desenvolvedor.  Surpreendentemente, ele funciona e <em>relativamente</em> r√°pido. </p><br><h2 id="nemnogo-benchmarka">  Um pouco de refer√™ncia </h2><br><p>  Provavelmente, um benchmark honesto seria constru√≠do sobre uma express√£o bastante complexa, cujo c√°lculo seria "frontal", comparado com esses perigosos m√©todos de <code>IL</code> .  Escrevi um algoritmo simples que resume os quadrados de n√∫meros previamente calculados e armazenados em uma matriz <code>double</code> e divide o valor final pelo n√∫mero de n√∫meros.  Para executar a opera√ß√£o, usei os operadores <code>C#</code> <code>+</code> , <code>*</code> e <code>/</code> , como fazem as pessoas saud√°veis, fun√ß√µes criadas com <code>Expressions</code> e <code>IL</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Os resultados s√£o aproximadamente os seguintes:</b> <div class="spoiler_text"><ul><li>  <code>DirectSum</code> √© a soma usando operadores padr√£o <code>+</code> , <code>*</code> e <code>/</code> ; </li><li>  <code>BranchSum</code> usa ramifica√ß√£o por tipo e lan√ßa atrav√©s de <code>object</code> ; </li><li>  <code>UnsafeBranchSum</code> usa ramifica√ß√£o por tipo e <code>Unsafe.As&lt;,&gt;()</code> atrav√©s de <code>Unsafe.As&lt;,&gt;()</code> ; </li><li>  <code>ExpressionSum</code> usa express√µes em cache para cada opera√ß√£o ( <code>Expression</code> ); </li><li>  <code>UnsafeSum</code> usa o c√≥digo <code>IL</code> inseguro apresentado no artigo </li></ul><br><p>  Benchmark de carga √∫til - somando os quadrados dos elementos de uma matriz pr√©-preenchida aleatoriamente do tipo <code>double</code> e tamanho <code>N</code> , seguida pela divis√£o da soma por <code>N</code> e armazenamento;  otimiza√ß√µes inclu√≠das. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=3.1.100 [Host] : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Job-POXTAH : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Runtime=.NET Core 3.1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  N </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Ratio </th><th>  RatioSD </th></tr></thead><tbody><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1000</strong> </td><td>  <strong>2.128 n√≥s</strong> </td><td>  <strong>0.0341 n√≥s</strong> </td><td>  <strong>0.0303 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1000 </td><td>  57.468 n√≥s </td><td>  0.4478 us </td><td>  0.3496 nos </td><td>  26,97 </td><td>  0,46 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1000 </td><td>  72.924 n√≥s </td><td>  0.4131 nos </td><td>  0.3864 us </td><td>  34,28 </td><td>  0,50 </td></tr><tr><td>  ExpressionSum </td><td>  1000 </td><td>  144.555 n√≥s </td><td>  2.5182 nos </td><td>  2.2323 nos </td><td>  67,94 </td><td>  1,29 </td></tr><tr><td>  Inseguro </td><td>  1000 </td><td>  5.054 n√≥s </td><td>  0.0324 us </td><td>  0.0303 us </td><td>  2,37 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>10.000</strong> </td><td>  <strong>21.174 n√≥s</strong> </td><td>  <strong>0.3092 n√≥s</strong> </td><td>  <strong>0.2741 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  10.000 </td><td>  573.972 n√≥s </td><td>  2.9274 us </td><td>  2.5951 us </td><td>  27/11 </td><td>  0,40 </td></tr><tr><td>  UnsafeBranchSum </td><td>  10.000 </td><td>  735.031 n√≥s </td><td>  9.1016 us </td><td>  8.0683 us </td><td>  34,72 </td><td>  0,53 </td></tr><tr><td>  ExpressionSum </td><td>  10.000 </td><td>  1.462.593 n√≥s </td><td>  9.0932 us </td><td>  8.0609 us </td><td>  69,09 </td><td>  1.02 </td></tr><tr><td>  Inseguro </td><td>  10.000 </td><td>  50.388 n√≥s </td><td>  0.3956 us </td><td>  0.3701 nos </td><td>  2,38 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>100.000</strong> </td><td>  <strong>210.021 n√≥s</strong> </td><td>  <strong>1.9832 us</strong> </td><td>  <strong>1.7581 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  100.000 </td><td>  6.046.340 n√≥s </td><td>  86.9740 n√≥s </td><td>  77.1002 us </td><td>  28,79 </td><td>  0,42 </td></tr><tr><td>  UnsafeBranchSum </td><td>  100.000 </td><td>  7.406.489 n√≥s </td><td>  65.7415 us </td><td>  58.2782 nos </td><td>  35,27 </td><td>  0,27 </td></tr><tr><td>  ExpressionSum </td><td>  100.000 </td><td>  14.021.642 n√≥s </td><td>  189.2625 us </td><td>  167.7763 n√≥s </td><td>  66,77 </td><td>  0,88 </td></tr><tr><td>  Inseguro </td><td>  100.000 </td><td>  505.551 n√≥s </td><td>  2.3662 nos </td><td>  2.2133 nos </td><td>  2,41 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1.024.000</strong> </td><td>  <strong>2.306.751 n√≥s</strong> </td><td>  <strong>22.4173 nos</strong> </td><td>  <strong>20.9692 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1.024.000 </td><td>  61.643.224 n√≥s </td><td>  610.3048 n√≥s </td><td>  570.8795 n√≥s </td><td>  26,72 </td><td>  0,28 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1.024.000 </td><td>  75.644.639 n√≥s </td><td>  494.4096 n√≥s </td><td>  462.4711 us </td><td>  32,80 </td><td>  0,39 </td></tr><tr><td>  ExpressionSum </td><td>  1.024.000 </td><td>  154.327.137 n√≥s </td><td>  1.267.2469 us </td><td>  1.185,3835 us </td><td>  66,91 </td><td>  0,55 </td></tr><tr><td>  Inseguro </td><td>  1.024.000 </td><td>  5.295.990 n√≥s </td><td>  14.9537 us </td><td>  12.4871 n√≥s </td><td>  2,29 </td><td>  0,02 </td></tr></tbody></table></div></div></div><br><p>  Nosso c√≥digo inseguro √© cerca de <code>2.5</code> vezes mais lento (em termos de uma opera√ß√£o).  Isso pode ser atribu√≠do ao fato de que, no caso de um c√°lculo de "testa", o compilador compila <code>a + b</code> no c√≥digo de opera√ß√£o <code>add</code> e, no caso de um m√©todo inseguro, √© chamada uma fun√ß√£o est√°tica, que √© naturalmente mais lenta. </p><br><h2 id="vmesto-zaklyucheniya-kogda-true--true">  Em vez de concluir: quando <code>true != true</code> </h2><br><p>  Alguns dias atr√°s, me deparei com um <a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">tweet de</a> Jared Parsons: </p><br><blockquote>  H√° casos em que o seguinte imprimir√° "false" <br>  bool b = ... <br>  if (b) Console.WriteLine (b.IsTrue ()); </blockquote><p>  Esta foi a resposta para <a href="https://twitter.com/vreshetnikov/status/1204929378368417792" rel="nofollow">esta entrada</a> , que mostra o c√≥digo de verifica√ß√£o <code>bool</code> para <code>true</code> , que se parece com isso: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; !<span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Os cheques parecem redundantes, certo?  Jared fornece um contra-exemplo que demonstra <a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">alguns dos recursos</a> do comportamento <code>bool</code> .  A id√©ia √© que <code>bool</code> seja <code>byte</code> ( <code>sizeof(bool) == 1</code> ), enquanto <code>false</code> corresponde a <code>0</code> e <code>true</code> corresponde a <code>1</code> .  Contanto que voc√™ n√£o gire os ponteiros, o <code>bool</code> se comporta de maneira inequ√≠voca e previs√≠vel.  No entanto, como Jared mostrou, voc√™ pode criar um <code>bool</code> usando <code>2</code> como valor inicial e algumas das verifica√ß√µes falhar√£o corretamente: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;b; *ptr = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p>  Podemos obter um efeito semelhante usando nossas opera√ß√µes matem√°ticas inseguras (isso n√£o funciona com <code>Expressions</code> ): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeTrue = Subtract&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;fakeTrue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fakeTrue) Assert.AreNotEqual(fakeTrue, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Assert.Fail(<span class="hljs-string"><span class="hljs-string">"Clause not entered."</span></span>);</code> </pre> <br><p>  Sim, sim, verificamos dentro do ramo <code>true</code> se a condi√ß√£o √© <code>true</code> e esperamos que, de fato, <em>n√£o</em> seja <em><code>true</code></em> .  Por que isso √© assim?  Se voc√™ subtrair de <code>0</code> ( <code>=false</code> ) <code>1</code> ( <code>=true</code> ) sem verifica√ß√µes, o <code>byte</code> ser√° igual a <code>255</code> .  Naturalmente, <code>255</code> (nosso <code>fakeTrue</code> ) n√£o √© <code>1</code> (verdadeiro <code>true</code> ), portanto, a afirma√ß√£o √© executada.  A ramifica√ß√£o funciona de maneira diferente. </p><br><p>  <code>if</code> ocorrer invers√£o: um ramo condicional √© inserido;  se a condi√ß√£o for <em>falsa</em> , ocorrer√° uma transi√ß√£o para o ponto ap√≥s o final do bloco <code>if</code> .  A valida√ß√£o √© realizada pela <code>brfalse_S</code> / <code>brfalse_S</code> .  Ele compara o √∫ltimo valor na pilha com <em>zero</em> .  Se o valor √© zero, ent√£o √© <code>false</code> , passamos o bloco <code>if</code> .  No nosso caso, <code>fakeTrue</code> simplesmente n√£o √© igual a zero, portanto a verifica√ß√£o passa e a execu√ß√£o continua dentro do bloco <code>if</code> , onde comparamos <code>fakeBool</code> com o valor true e obtemos um resultado negativo. </p><br><p>  UPD01: <br>  Depois de discutir nos coment√°rios com <a href="https://habr.com/en/users/shai_hulud/" class="user_link">shai_hulud</a> e <a href="https://habr.com/en/users/shai_hulud/" class="user_link">blowin</a> , adicionei outro m√©todo aos benchmarks que implementam um ramo como <code>if(typeof(T) == typeof(int)) return (T)(object)((int)(object)left + (int)(object)right);</code>  .  Apesar do <code>JIT</code> otimizar as verifica√ß√µes, pelo menos quando <code>T</code> √© uma <code>struct</code> , esses m√©todos ainda funcionam em uma ordem de magnitude mais lenta.  N√£o √© √≥bvio se as transforma√ß√µes <code>T</code> -&gt; <code>int</code> -&gt; <code>T</code> otimizadas ou se o boxe / unboxing √© usado.  Os resultados do benchmark <code>MethodImpl</code> s√£o significativamente afetados pelos sinalizadores <code>MethodImpl</code> . </p><br><p>  UPD02: <br>  <a href="https://habr.com/en/users/xxxvano/" class="user_link">O xXxVano</a> nos coment√°rios mostrou um exemplo de uso de ramifica√ß√£o por tipo e lan√ßa <code>T</code> &lt;--&gt; um tipo espec√≠fico usando <code>Unsafe.As&lt;TFrom, TTo&gt;()</code> .  Por analogia com a ramifica√ß√£o usual e o costume atrav√©s do <code>object</code> , escrevi tr√™s opera√ß√µes (adi√ß√£o, multiplica√ß√£o e divis√£o) com ramifica√ß√£o para todos os tipos aritm√©ticos, ap√≥s as quais adicionei outro benchmark ( <code>UnsafeBranchSum</code> ).  Apesar do fato de que todos os m√©todos (exceto express√µes) geram c√≥digo asm quase id√™ntico (at√© onde meu conhecimento limitado de assembler me permite julgar), por algum motivo desconhecido, ambos os m√©todos com ramifica√ß√£o s√£o muito lentos em compara√ß√£o com a soma direta ( <code>DirectSum</code> ) e usando gen√©ricos e c√≥digo <code>IL</code> .  N√£o tenho explica√ß√£o para esse efeito, o fato de o tempo gasto aumentar na propor√ß√£o de <code>N</code> indica que h√° algum tipo de sobrecarga constante para <em>cada</em> opera√ß√£o, apesar de toda a magia do <code>JIT</code> .  Essa sobrecarga est√° ausente na vers√£o <code>IL</code> dos m√©todos.   ,   <code>IL</code> -    ,    /    /  ,          100%  (  ,   ). <br>   ,      , -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480416/">https://habr.com/ru/post/pt480416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480400/index.html">O Kubernetes √© o novo Linux? Entrevista com Pavel Selivanov</a></li>
<li><a href="../pt480402/index.html">Como pÃ∂–µÃ∂—Ä T–≤Ã∂—ãÃ∂–πÃ∂ o segundo mitap Android de Tinkoff</a></li>
<li><a href="../pt480404/index.html">Mikrotik e Linux. Rotina e Automa√ß√£o</a></li>
<li><a href="../pt480408/index.html">52 conjunto de dados para projetos de treinamento</a></li>
<li><a href="../pt480412/index.html">Alexei Ragozin sobre os novos e antigos recursos do Java Flight Recorder no OpenJDK 11 na reuni√£o jug.msk.ru</a></li>
<li><a href="../pt480420/index.html">Entrevista com Matthew "Oki" O'Connor sobre aterosclerose e seu tratamento</a></li>
<li><a href="../pt480422/index.html">Guia de estilo do Google em C ++. Parte 1</a></li>
<li><a href="../pt480424/index.html">Guia de estilo do Google em C ++. Parte 9</a></li>
<li><a href="../pt480428/index.html">O m√©todo da taquigrafia mais simples. Alfabeto e fonte para ela.</a></li>
<li><a href="../pt480430/index.html">Como o codec de v√≠deo funciona. Parte 2. O que, por que, como</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>