<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏽 👶🏼 🤛🏾 Matemática genérica não segura em C # 🏮 👨🏼‍🎤 🤙🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Infelizmente, não foi fácil traduzir adequadamente o nome da feiúra que comecei para o russo. Fiquei surpreso ao descobrir que a documentação oficial ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matemática genérica não segura em C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480416/"><p><img src="https://habrastorage.org/webt/mj/zg/yw/mjzgywquj0lud4_vs9bjh8xdacu.png"></p><br><p> Infelizmente, não foi fácil traduzir adequadamente o nome da feiúra que comecei para o russo.  Fiquei surpreso ao descobrir que a documentação oficial do <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/" rel="nofollow">MSDN</a> chama “modelos genéricos” (modelos similares ao <code>C++</code> , suponho).  Na 4ª edição do <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow"><code>"CLR</code> via <code>C#</code> ” que</a> chamou minha atenção <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow">,</a> <a href="https://twitter.com/jeffrichter" rel="nofollow">Jeffrey Richter</a> , traduzido por <a href="https://habr.com/en/company/piter/">Peter</a> , os genéricos são chamados de “generalizações”, o que reflete o conceito muito melhor.  Este artigo abordará <em>operações matemáticas generalizadas inseguras em <code>C#</code></em> .  Considerando que o <code>C#</code> não se destina à computação de alto desempenho (embora, é claro, seja capaz disso, mas não seja capaz de competir com o mesmo <code>C/C++</code> ), as operações matemáticas no <code>BCL</code> não recebem muita atenção.  Vamos tentar simplificar o trabalho com tipos aritméticos básicos usando <code>C#</code> e <code>CLR</code> . </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Declaração do problema </h2><br><p>  <strong>Isenção de responsabilidade</strong> : o artigo conterá muitos fragmentos de código, alguns dos quais ilustrarei com links para o maravilhoso recurso <a href="https://sharplab.io/" rel="nofollow">SharpLab</a> ( <a href="https://github.com/ashmind/SharpLab" rel="nofollow">Gi <s>r</s> tHub</a> ) de <a href="https://twitter.com/ashmind" rel="nofollow">Andrey Shchekin</a> . </p><br><p>  A maioria dos cálculos, de uma maneira ou de outra, se resume a operações básicas.  Adição, subtração (inversão, negação), multiplicação e divisão podem ser complementadas por operações de comparação e verificação de igualdade.  Obviamente, todas essas ações podem ser executadas de maneira fácil e simples em variáveis ​​de qualquer tipo aritmético básico de <code>C#</code> .  O único problema é que o <code>C#</code> deve <em>saber</em> em tempo de compilação que as operações são executadas em tipos específicos e parece que é impossível escrever um método que igualmente eficiente (e transparente) adicione dois números inteiros e dois números de ponto flutuante. </p><br><p>  Vamos especificar nossos desejos por um método generalizado hipotético que execute alguma operação matemática simples: </p><br><ol><li>  Um método deve ter restrições de tipo generalizadas que nos protegem de tentar adicionar (ou multiplicar, dividir) dois tipos arbitrários.  Precisamos de alguma restrição de tipo genérico. </li><li>  Para a pureza do experimento, os tipos aceitos e retornados devem ser os mesmos.  Por exemplo, um operador binário deve ter uma assinatura no formato <code>(T, T) =&gt; T</code> </li><li>  O método deve ser pelo menos parcialmente otimizado.  Por exemplo, o boxe onipresente é inaceitável. </li></ol><br><h2 id="a-chto-tam-u-sosedey">  E os vizinhos? </h2><br><p>  Vamos olhar para <code>F#</code> .  Eu não sou forte em <code>F#</code> , mas a maioria das restrições de <code>C#</code> é ditada pelas limitações do <code>CLR</code> , o que significa que o <code>F#</code> sofre dos mesmos problemas.  Você pode tentar declarar um método de adição generalizada explícita e o método de adição usual e ver o que o sistema de inferência do tipo <code>F#</code> diz: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x + y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> xy = x + y add_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore</code> </pre> <br><p>  Nesse <a href="https://sharplab.io/" rel="nofollow">caso, os</a> dois métodos não serão generalizados e o código gerado será idêntico.  Dada a rigidez do sistema do tipo <code>F#</code> , em que não há conversões implícitas no formato <code>int -&gt; double</code> , após a primeira chamada desses métodos com parâmetros do tipo <code>double</code> (em termos de <code>C#</code> ), chame métodos com parâmetros de outros tipos (mesmo com uma possível perda de precisão devido à conversão de tipos) mais falhará. </p><br><p>  É importante notar que, se você substituir o operador <code>+</code> operador de igualdade <code>=</code> , a <a href="https://sharplab.io/" rel="nofollow">imagem se tornará um pouco diferente</a> : ambos os métodos se tornam generalizados (do ponto de vista de <code>C#</code> ), e um método auxiliar especial, disponível em <code>F#</code> é chamado para realizar a comparação. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x = y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq xy = x = y eq_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq_gen <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore</code> </pre> <br><h3 id="chto-naschet-java">  E o <code>Java</code> ? </h3><br><p>  É difícil para mim falar sobre <code>Java</code> , mas, tanto quanto posso dizer, tipos significativos <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">não</a> existem da forma usual para nós, mas ainda existem tipos <em>primitivos</em> .  Para trabalhar com primitivas em <code>Java</code> existem <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">wrappers</a> (por exemplo, uma referência <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" rel="nofollow"><code>Long</code></a> para primitivo por valor <code>long</code> ), que possuem uma classe base comum <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html" rel="nofollow"><code>Number</code></a> .  Portanto, você pode generalizar parcialmente as operações usando <code>Number</code> , mas esse é um tipo de referência, que provavelmente não terá um efeito positivo no desempenho. </p><br><p>  <em>Me corrija se eu estiver errado.</em> </p><br><h3 id="c">  <code>C++</code> ? </h3><br><p>  <code>C++</code> é uma linguagem para trapaceiros. <br>  <code>C++</code> abre caminho para recursos que alguns consideram ... <a href="https://ru.wikiquote.org/wiki/%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B._%25D0%25AD%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B4_III:_%25D0%259C%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D1%2581%25D0%25B8%25D1%2582%25D1%2585%25D0%25BE%25D0%25B2" rel="nofollow">não naturais</a> . <br>  Modelos (também conhecidos como modelos), em contraste com generalizações (genéricos), são, no sentido literal, <em>modelos</em> .  Ao declarar um modelo, você pode restringir explicitamente os tipos para os quais esse modelo está disponível.  Por esse motivo, em <code>C++</code> , por exemplo, o seguinte código é válido: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T, std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;* = nullptr&gt; T Add (T left, T right) { return left + right; } int main() { std::cout &lt;&lt; Add(5, 6) &lt;&lt; std::endl; std::cout &lt;&lt; Add(5.0, 6.0) &lt;&lt; std::endl; // std::cout &lt;&lt; Add("a", "b") &lt;&lt; std::endl; Does not compile }</span></span></span></span></code> </pre> <br><p>  <code>is_arithmetic</code> , infelizmente, permite <code>char</code> e <code>bool</code> como parâmetros.  Por outro lado, <code>char</code> pode ser equivalente a <code>sbyte</code> na terminologia <code>C#</code> , embora os tamanhos reais dos tipos inteiros dependam da fase da plataforma / compilador / lua. </p><br><h3 id="yazyki-s-dinamicheskoy-tipizaciey">  Idiomas de digitação dinâmica </h3><br><p>  Por fim, considere algumas linguagens dinamicamente tipadas (e <em>interpretadas</em> ), aguçadas pelo cálculo.  Nessas linguagens, geralmente a generalização da computação não causa problemas: se o tipo de parâmetro for adequado para execução, além disso, condicionalmente, a operação será executada, caso contrário, falhará com um erro. </p><br><p>  No <code>Python</code> (3.7.3 x64): </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y type(add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># &lt;class 'int'&gt; type(add(5.0, 6.0)) # &lt;class 'float'&gt; type(add('a', 'b') # &lt;class 'str'&gt;</span></span></code> </pre> <br><p>  Em <code>R</code> (3.6.1 x64) </p><br><pre> <code class="cpp hljs">add &lt;- function(x, y) x + y # <span class="hljs-function"><span class="hljs-function">Or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5L</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6L</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: integer vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"5"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"6"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Error in x + y : non-numeric argument to binary </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span></span></code> </pre> <br><h2 id="obratno-v-mir-c-ogranichivaem-obobschennyy-tip-matematicheskoy-funkcii">  Por outro lado, no mundo C #: restringimos o tipo generalizado de função matemática </h2><br><p>  Infelizmente, não podemos fazer isso.  Em <code>C#</code> tipos primitivos são tipos de valor, ou seja,  estruturas que, embora herdadas de <code>System.Object</code> (e <a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype%3Fview%3Dnetcore-3.0" rel="nofollow"><code>System.ValueType</code></a> ), não têm muito em comum.  Uma limitação natural e lógica é <code>where T : struct</code> .  Começando com <code>C# 7.3</code> temos a restrição <code>where T : unmanaged</code> , o que significa que <code>T</code> é um <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow"><code> ,        null</code></a> .  Além dos tipos aritméticos primitivos de que precisamos, <code>char</code> , <code>bool</code> , <code>decimal</code> , <em>qualquer</em> <code>Enum</code> e <em>qualquer</em> estrutura cujos todos os campos tenham o mesmo tipo <code>unmanaged</code> atendem a esses requisitos.  I.e.  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow">este tipo</a> passará no teste: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coords&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TY; }</code> </pre> <br><p>  Portanto, não podemos escrever uma função generalizada que aceite apenas os tipos aritméticos desejados.  Daí a <code>Unsafe</code> no título do artigo - teremos que confiar nos programadores que usam nosso código.  Uma tentativa de chamar o método hipotético generalizado <code>T Add&lt;T&gt;(T left, T right) where T : unmanaged</code> levará a resultados imprevisíveis se o programador passar objetos de um tipo incompatível como argumentos. </p><br><h2 id="eksperiment-pervyy-naivnyy-dynamic">  O primeiro experimento, ingênuo: <code>dynamic</code> </h2><br><p>  <code>dynamic</code> é a primeira e óbvia ferramenta que pode nos ajudar a resolver nosso problema.  Obviamente, usar a <code>dynamic</code> para cálculos é absolutamente inútil - a <code>dynamic</code> equivalente ao <code>object</code> , e os métodos chamados com uma variável <code>dynamic</code> são transformados em uma reflexão monstruosa pelo compilador.  Como um bônus - empacotar / descompactar nossos tipos de valor.  Aqui está <a href="https://sharplab.io/" rel="nofollow">um exemplo</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Add(<span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> =&gt; left + right; }</code> </pre> <br><p>  Basta olhar para a <code>IL</code> método <code>Method</code> : </p><br><pre> <code class="cs hljs">.<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Method begins at RVA 0x2050 // Code size 53 (0x35) .maxstack 8 IL_0000: ldc.i4.5 IL_0001: box [System.Private.CoreLib]System.Int32 IL_0006: ldc.i4.6 IL_0007: box [System.Private.CoreLib]System.Int32 IL_000c: call object Class::Add(object, object) IL_0011: pop IL_0012: ldc.r8 5 IL_001b: box [System.Private.CoreLib]System.Double IL_0020: ldc.r8 6 IL_0029: box [System.Private.CoreLib]System.Double IL_002e: call object Class::Add(object, object) IL_0033: pop IL_0034: ret } // end of method Class::Method</span></span></code> </pre> <br><p>  Carregou <code>5</code> , <em>empacotou</em> , carregou <code>6</code> , empacotou, chamado <code>object Add(object, object)</code> . <br>  A opção obviamente não nos convém. </p><br><h2 id="eksperiment-vtoroy-v-lob">  O segundo experimento, "na testa" </h2><br><p>  Bem, a <code>dynamic</code> não é para nós, mas o número de nossos tipos é finito e eles são conhecidos antecipadamente.  Vamos nos armar com um <s>pé de cabra de</s> ramo e anotá-lo: se <em>nosso</em> tipo <em>for</em> , vamos calcular algo, caso contrário - aqui está a exceção. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Left &amp;&amp; right <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Right) { <span class="hljs-comment"><span class="hljs-comment">// ??? } // ... throw new NotSupportedException(); }</span></span></code> </pre> <br><p>  III, aqui nos deparamos com um problema.  Se você entender com quais tipos estamos trabalhando, ainda poderá aplicar a operação a eles, então o <code>int</code> condicional resultante precisará ser convertido em um tipo desconhecido <code>T</code> e isso não é muito simples.  A opção de <code>return (T)(i32Left + i32Right)</code> não é compilada - não há garantia de que <code>T</code> seja <code>int</code> (mesmo sabendo que é).  Você pode tentar o <code>return (T)(object)(i32Left + i32Right)</code> conversão dupla <code>return (T)(object)(i32Left + i32Right)</code> .  Primeiro, a quantidade é embalada e depois descompactada em <code>T</code>  Isso <strong>só</strong> funcionará se os tipos <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="nofollow">corresponderem</a> antes e depois da embalagem.  Você não pode empacotar <code>int</code> , mas descompacte-o em <code>double</code> , mesmo se houver uma conversão implícita <code>int -&gt; double</code> .  O problema com <a href="https://sharplab.io/" rel="nofollow">esse</a> código é a ramificação gigante e a abundância de pacotes de descompactação, mesmo que <code>if</code> condições.  Esta opção também não é boa. </p><br><h2 id="refleksiya-i-metadannye">  Reflexão e Metadados </h2><br><p>  Bem, toque e basta.  Todo mundo sabe que existem operadores em <code>C#</code> que podem ser substituídos.  Lá, existem <code>+</code> , <code>-</code> , <code>==</code> , <code>==</code> <code>!=</code> E assim por diante.  Tudo o que precisamos fazer é usar um método estático do tipo <code>T</code> correspondente ao operador, por exemplo, adições - isso é tudo.  Bem, sim, novamente alguns pacotes, mas sem ramificação e sem problemas.  A coisa toda pode ser armazenada em cache pelo tipo <code>T</code> e geralmente acelera o processo de todas as formas, reduzindo uma operação matemática a chamar um único método de reflexão.  Bem, algo como isto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-comment"><span class="hljs-comment">// Simple example without cache. var method = typeof(T) .GetMethod(@"op_Addition", new [] {typeof(T), typeof(T)}) ?.CreateDelegate(typeof(Func&lt;T, T, T&gt;)) as Func&lt;T, T, T&gt;; return method?.Invoke(left, right) ?? throw new InvalidOperationException(); }</span></span></code> </pre> <br><p>  Infelizmente isso <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">não funciona</a> .  O fato é que os tipos aritméticos (mas não <code>decimal</code> ) <em>não possuem</em> um método estático.  Todas as operações são implementadas através de operações de <code>IL</code> , como <a href="" rel="nofollow"><code>add</code></a> .  A reflexão normal não resolve o nosso problema. </p><br><h2 id="systemlinqexpressions">  System.Linq.Expressions </h2><br><p>  A solução baseada em <code>Expressions</code> é descrita no blog de <a href="https://twitter.com/jonskeet" rel="nofollow">John Skeet</a> <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">aqui</a> (de Marc Gravell). <br>  A ideia é bem simples.  Suponha que temos um tipo <code>T</code> que suporta a operação <code>+</code> .  Vamos criar uma expressão como esta: </p><br><pre> <code class="cs hljs">(x, y) =&gt; x + y;</code> </pre> <br><p>  Depois disso, após o cache, vamos usá-lo.  Construir essa expressão é bastante fácil.  Precisamos de dois parâmetros e uma operação.  Então, vamos anotá-la. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt; Cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-comment"><span class="hljs-comment">// If op is cached by type and function name, use cached version if (Cache.TryGetValue((t, nameof(Add)), out var del)) return del is Func&lt;T, T, T&gt; specificFunc ? specificFunc(left, right) : throw new InvalidOperationException(nameof(Add)); var leftPar = Expression.Parameter(t, nameof(left)); var rightPar = Expression.Parameter(t, nameof(right)); var body = Expression.Add(leftPar, rightPar); var func = Expression.Lambda&lt;Func&lt;T, T, T&gt;&gt;(body, leftPar, rightPar).Compile(); Cache[(t, nameof(Add))] = func; return func(left, right); }</span></span></code> </pre> <br><p>  Informações úteis sobre árvores de expressão e delegados foram publicadas no hub </p><br><p>  Tecnicamente, expressões nos permitem resolver todos os nossos problemas - qualquer operação básica pode ser reduzida a chamar um método generalizado.  Qualquer operação mais complexa pode ser escrita da mesma maneira, usando expressões mais complexas.  Isso é <em>quase o</em> suficiente. </p><br><h2 id="narushaem-vse-pravila">  Nós quebramos todas as regras </h2><br><p>  É possível conseguir algo mais usando o poder do <code>CLR/C#</code> ?  Vamos ver em que <s>ano o</s> código é gerado por métodos de adição <a href="https://sharplab.io/" rel="nofollow">para diferentes tipos</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-comment"><span class="hljs-comment">// Decimal only to show difference public static decimal Add(decimal x, decimal y) =&gt; x + y; }</span></span></code> </pre> <br><p>  O código <code>IL</code> correspondente contém o mesmo conjunto de instruções: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret</code> </pre> <br><p>  Este é o código op muito <a href="" rel="nofollow"><code>add</code></a> no qual a adição de tipos primitivos aritméticos é compilada.  <code>decimal</code> nesse local chama <code>static decimal decimal.op_Addition(decimal, decimal)</code> .  Mas e se escrevermos um método que será generalizado, mas conter exatamente esse código <code>IL</code> ?  Bem, John Skeet adverte que isso <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">não vale a pena</a> .  No seu caso, ele considera todos os tipos (incluindo <code>decimal</code> ), bem como seus análogos <code>nullable</code> .  Isso exigirá operações de <code>IL</code> não triviais e levará necessariamente a um erro.  Mas ainda podemos tentar implementar operações básicas. </p><br><p>  Para minha surpresa, o <code>Visual Studio</code> não contém modelos para projetos e arquivos de <code>IL</code> .  Você não pode simplesmente pegar e descrever parte do código em <code>IL</code> e incluí-lo em sua montagem.  Naturalmente, o código aberto vem em nosso auxílio.  O projeto <a href="https://github.com/ins0mniaque/ILSupport" rel="nofollow"><code>ILSupport</code></a> contém modelos para projetos de <code>IL</code> , bem como um conjunto de instruções que podem ser adicionadas a <code>*.csproj</code> para incluir o código de <code>IL</code> no projeto.  Obviamente, descrever tudo em <code>IL</code> é bastante difícil, portanto o autor do projeto usa o atributo <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute%3Fview%3Dnetcore-3.0" rel="nofollow"><code>MethodImpl</code></a> com o sinalizador <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions%3Fredirectedfrom%3DMSDN%26view%3Dnetcore-3.0" rel="nofollow"><code>ForwardRef</code></a> .  Este atributo permite que você declare o método como <code>extern</code> e não descreva o corpo do método.  Parece algo como isto: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.ForwardRef)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  A próxima etapa é escrever a implementação do método no arquivo <code>*.il</code> com código <code>IL</code> : </p><br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hidebysig !!T Add&lt;valuetype .ctor (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">ValueType</span></span> <span class="hljs-title"><span class="hljs-title">modreq</span></span> ([<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Runtime</span></span>.<span class="hljs-title"><span class="hljs-title">InteropServices</span></span>.<span class="hljs-title"><span class="hljs-title">UnmanagedType</span></span>)) <span class="hljs-title"><span class="hljs-title">T</span></span>&gt;(!!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>, !!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { .param type [<span class="hljs-number"><span class="hljs-number">1</span></span>] .custom instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = (<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ) ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret }</code> </pre> <br><p>  Em nenhum lugar explicitamente referindo-se ao tipo <code>!!T</code> , sugerimos que o <code>CLR</code> adicione dois argumentos e retorne o resultado.  Não <strong>há</strong> verificação de tipo e tudo está na consciência do desenvolvedor.  Surpreendentemente, ele funciona e <em>relativamente</em> rápido. </p><br><h2 id="nemnogo-benchmarka">  Um pouco de referência </h2><br><p>  Provavelmente, um benchmark honesto seria construído sobre uma expressão bastante complexa, cujo cálculo seria "frontal", comparado com esses perigosos métodos de <code>IL</code> .  Escrevi um algoritmo simples que resume os quadrados de números previamente calculados e armazenados em uma matriz <code>double</code> e divide o valor final pelo número de números.  Para executar a operação, usei os operadores <code>C#</code> <code>+</code> , <code>*</code> e <code>/</code> , como fazem as pessoas saudáveis, funções criadas com <code>Expressions</code> e <code>IL</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Os resultados são aproximadamente os seguintes:</b> <div class="spoiler_text"><ul><li>  <code>DirectSum</code> é a soma usando operadores padrão <code>+</code> , <code>*</code> e <code>/</code> ; </li><li>  <code>BranchSum</code> usa ramificação por tipo e lança através de <code>object</code> ; </li><li>  <code>UnsafeBranchSum</code> usa ramificação por tipo e <code>Unsafe.As&lt;,&gt;()</code> através de <code>Unsafe.As&lt;,&gt;()</code> ; </li><li>  <code>ExpressionSum</code> usa expressões em cache para cada operação ( <code>Expression</code> ); </li><li>  <code>UnsafeSum</code> usa o código <code>IL</code> inseguro apresentado no artigo </li></ul><br><p>  Benchmark de carga útil - somando os quadrados dos elementos de uma matriz pré-preenchida aleatoriamente do tipo <code>double</code> e tamanho <code>N</code> , seguida pela divisão da soma por <code>N</code> e armazenamento;  otimizações incluídas. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=3.1.100 [Host] : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Job-POXTAH : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Runtime=.NET Core 3.1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  N </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Ratio </th><th>  RatioSD </th></tr></thead><tbody><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1000</strong> </td><td>  <strong>2.128 nós</strong> </td><td>  <strong>0.0341 nós</strong> </td><td>  <strong>0.0303 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1000 </td><td>  57.468 nós </td><td>  0.4478 us </td><td>  0.3496 nos </td><td>  26,97 </td><td>  0,46 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1000 </td><td>  72.924 nós </td><td>  0.4131 nos </td><td>  0.3864 us </td><td>  34,28 </td><td>  0,50 </td></tr><tr><td>  ExpressionSum </td><td>  1000 </td><td>  144.555 nós </td><td>  2.5182 nos </td><td>  2.2323 nos </td><td>  67,94 </td><td>  1,29 </td></tr><tr><td>  Inseguro </td><td>  1000 </td><td>  5.054 nós </td><td>  0.0324 us </td><td>  0.0303 us </td><td>  2,37 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>10.000</strong> </td><td>  <strong>21.174 nós</strong> </td><td>  <strong>0.3092 nós</strong> </td><td>  <strong>0.2741 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  10.000 </td><td>  573.972 nós </td><td>  2.9274 us </td><td>  2.5951 us </td><td>  27/11 </td><td>  0,40 </td></tr><tr><td>  UnsafeBranchSum </td><td>  10.000 </td><td>  735.031 nós </td><td>  9.1016 us </td><td>  8.0683 us </td><td>  34,72 </td><td>  0,53 </td></tr><tr><td>  ExpressionSum </td><td>  10.000 </td><td>  1.462.593 nós </td><td>  9.0932 us </td><td>  8.0609 us </td><td>  69,09 </td><td>  1.02 </td></tr><tr><td>  Inseguro </td><td>  10.000 </td><td>  50.388 nós </td><td>  0.3956 us </td><td>  0.3701 nos </td><td>  2,38 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>100.000</strong> </td><td>  <strong>210.021 nós</strong> </td><td>  <strong>1.9832 us</strong> </td><td>  <strong>1.7581 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  100.000 </td><td>  6.046.340 nós </td><td>  86.9740 nós </td><td>  77.1002 us </td><td>  28,79 </td><td>  0,42 </td></tr><tr><td>  UnsafeBranchSum </td><td>  100.000 </td><td>  7.406.489 nós </td><td>  65.7415 us </td><td>  58.2782 nos </td><td>  35,27 </td><td>  0,27 </td></tr><tr><td>  ExpressionSum </td><td>  100.000 </td><td>  14.021.642 nós </td><td>  189.2625 us </td><td>  167.7763 nós </td><td>  66,77 </td><td>  0,88 </td></tr><tr><td>  Inseguro </td><td>  100.000 </td><td>  505.551 nós </td><td>  2.3662 nos </td><td>  2.2133 nos </td><td>  2,41 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1.024.000</strong> </td><td>  <strong>2.306.751 nós</strong> </td><td>  <strong>22.4173 nos</strong> </td><td>  <strong>20.9692 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1.024.000 </td><td>  61.643.224 nós </td><td>  610.3048 nós </td><td>  570.8795 nós </td><td>  26,72 </td><td>  0,28 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1.024.000 </td><td>  75.644.639 nós </td><td>  494.4096 nós </td><td>  462.4711 us </td><td>  32,80 </td><td>  0,39 </td></tr><tr><td>  ExpressionSum </td><td>  1.024.000 </td><td>  154.327.137 nós </td><td>  1.267.2469 us </td><td>  1.185,3835 us </td><td>  66,91 </td><td>  0,55 </td></tr><tr><td>  Inseguro </td><td>  1.024.000 </td><td>  5.295.990 nós </td><td>  14.9537 us </td><td>  12.4871 nós </td><td>  2,29 </td><td>  0,02 </td></tr></tbody></table></div></div></div><br><p>  Nosso código inseguro é cerca de <code>2.5</code> vezes mais lento (em termos de uma operação).  Isso pode ser atribuído ao fato de que, no caso de um cálculo de "testa", o compilador compila <code>a + b</code> no código de operação <code>add</code> e, no caso de um método inseguro, é chamada uma função estática, que é naturalmente mais lenta. </p><br><h2 id="vmesto-zaklyucheniya-kogda-true--true">  Em vez de concluir: quando <code>true != true</code> </h2><br><p>  Alguns dias atrás, me deparei com um <a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">tweet de</a> Jared Parsons: </p><br><blockquote>  Há casos em que o seguinte imprimirá "false" <br>  bool b = ... <br>  if (b) Console.WriteLine (b.IsTrue ()); </blockquote><p>  Esta foi a resposta para <a href="https://twitter.com/vreshetnikov/status/1204929378368417792" rel="nofollow">esta entrada</a> , que mostra o código de verificação <code>bool</code> para <code>true</code> , que se parece com isso: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; !<span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Os cheques parecem redundantes, certo?  Jared fornece um contra-exemplo que demonstra <a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">alguns dos recursos</a> do comportamento <code>bool</code> .  A idéia é que <code>bool</code> seja <code>byte</code> ( <code>sizeof(bool) == 1</code> ), enquanto <code>false</code> corresponde a <code>0</code> e <code>true</code> corresponde a <code>1</code> .  Contanto que você não gire os ponteiros, o <code>bool</code> se comporta de maneira inequívoca e previsível.  No entanto, como Jared mostrou, você pode criar um <code>bool</code> usando <code>2</code> como valor inicial e algumas das verificações falharão corretamente: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;b; *ptr = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p>  Podemos obter um efeito semelhante usando nossas operações matemáticas inseguras (isso não funciona com <code>Expressions</code> ): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeTrue = Subtract&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;fakeTrue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fakeTrue) Assert.AreNotEqual(fakeTrue, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Assert.Fail(<span class="hljs-string"><span class="hljs-string">"Clause not entered."</span></span>);</code> </pre> <br><p>  Sim, sim, verificamos dentro do ramo <code>true</code> se a condição é <code>true</code> e esperamos que, de fato, <em>não</em> seja <em><code>true</code></em> .  Por que isso é assim?  Se você subtrair de <code>0</code> ( <code>=false</code> ) <code>1</code> ( <code>=true</code> ) sem verificações, o <code>byte</code> será igual a <code>255</code> .  Naturalmente, <code>255</code> (nosso <code>fakeTrue</code> ) não é <code>1</code> (verdadeiro <code>true</code> ), portanto, a afirmação é executada.  A ramificação funciona de maneira diferente. </p><br><p>  <code>if</code> ocorrer inversão: um ramo condicional é inserido;  se a condição for <em>falsa</em> , ocorrerá uma transição para o ponto após o final do bloco <code>if</code> .  A validação é realizada pela <code>brfalse_S</code> / <code>brfalse_S</code> .  Ele compara o último valor na pilha com <em>zero</em> .  Se o valor é zero, então é <code>false</code> , passamos o bloco <code>if</code> .  No nosso caso, <code>fakeTrue</code> simplesmente não é igual a zero, portanto a verificação passa e a execução continua dentro do bloco <code>if</code> , onde comparamos <code>fakeBool</code> com o valor true e obtemos um resultado negativo. </p><br><p>  UPD01: <br>  Depois de discutir nos comentários com <a href="https://habr.com/en/users/shai_hulud/" class="user_link">shai_hulud</a> e <a href="https://habr.com/en/users/shai_hulud/" class="user_link">blowin</a> , adicionei outro método aos benchmarks que implementam um ramo como <code>if(typeof(T) == typeof(int)) return (T)(object)((int)(object)left + (int)(object)right);</code>  .  Apesar do <code>JIT</code> otimizar as verificações, pelo menos quando <code>T</code> é uma <code>struct</code> , esses métodos ainda funcionam em uma ordem de magnitude mais lenta.  Não é óbvio se as transformações <code>T</code> -&gt; <code>int</code> -&gt; <code>T</code> otimizadas ou se o boxe / unboxing é usado.  Os resultados do benchmark <code>MethodImpl</code> são significativamente afetados pelos sinalizadores <code>MethodImpl</code> . </p><br><p>  UPD02: <br>  <a href="https://habr.com/en/users/xxxvano/" class="user_link">O xXxVano</a> nos comentários mostrou um exemplo de uso de ramificação por tipo e lança <code>T</code> &lt;--&gt; um tipo específico usando <code>Unsafe.As&lt;TFrom, TTo&gt;()</code> .  Por analogia com a ramificação usual e o costume através do <code>object</code> , escrevi três operações (adição, multiplicação e divisão) com ramificação para todos os tipos aritméticos, após as quais adicionei outro benchmark ( <code>UnsafeBranchSum</code> ).  Apesar do fato de que todos os métodos (exceto expressões) geram código asm quase idêntico (até onde meu conhecimento limitado de assembler me permite julgar), por algum motivo desconhecido, ambos os métodos com ramificação são muito lentos em comparação com a soma direta ( <code>DirectSum</code> ) e usando genéricos e código <code>IL</code> .  Não tenho explicação para esse efeito, o fato de o tempo gasto aumentar na proporção de <code>N</code> indica que há algum tipo de sobrecarga constante para <em>cada</em> operação, apesar de toda a magia do <code>JIT</code> .  Essa sobrecarga está ausente na versão <code>IL</code> dos métodos.   ,   <code>IL</code> -    ,    /    /  ,          100%  (  ,   ). <br>   ,      , -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480416/">https://habr.com/ru/post/pt480416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480400/index.html">O Kubernetes é o novo Linux? Entrevista com Pavel Selivanov</a></li>
<li><a href="../pt480402/index.html">Como p̶е̶р Tв̶ы̶й̶ o segundo mitap Android de Tinkoff</a></li>
<li><a href="../pt480404/index.html">Mikrotik e Linux. Rotina e Automação</a></li>
<li><a href="../pt480408/index.html">52 conjunto de dados para projetos de treinamento</a></li>
<li><a href="../pt480412/index.html">Alexei Ragozin sobre os novos e antigos recursos do Java Flight Recorder no OpenJDK 11 na reunião jug.msk.ru</a></li>
<li><a href="../pt480420/index.html">Entrevista com Matthew "Oki" O'Connor sobre aterosclerose e seu tratamento</a></li>
<li><a href="../pt480422/index.html">Guia de estilo do Google em C ++. Parte 1</a></li>
<li><a href="../pt480424/index.html">Guia de estilo do Google em C ++. Parte 9</a></li>
<li><a href="../pt480428/index.html">O método da taquigrafia mais simples. Alfabeto e fonte para ela.</a></li>
<li><a href="../pt480430/index.html">Como o codec de vídeo funciona. Parte 2. O que, por que, como</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>