<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§“ğŸ¾ ğŸ›’ ğŸ¤¾ğŸ½ Pembuatan Kode dengan LLVM ğŸ‘¶ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ›ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kutukan Non-Determinisme 

 Upaya pertama saya untuk menulis perikop LLVM - Saya suka segfolty ini 

 Baru-baru ini, saya menemukan masalah yang menar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembuatan Kode dengan LLVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417029/"><h3>  Kutukan Non-Determinisme </h3><br><img src="https://habrastorage.org/webt/41/_f/as/41_fasuco5jnfutepliohcp44pm.jpeg"><br>  <i>Upaya pertama saya untuk menulis perikop LLVM - Saya suka segfolty ini</i> <br><br>  Baru-baru ini, saya menemukan masalah yang menarik - saya membutuhkan cara deterministik dan lintas-platform untuk menentukan runtime kode C ++.  Dengan kata "deterministik" maksud saya bahwa kode yang sama akan dieksekusi untuk jumlah unit waktu yang sama.  Dengan lintas platform, saya mengerti bahwa kode yang sama di bawah Windows dan di bawah Ubuntu akan berjalan untuk jumlah unit waktu yang sama. <br><br>  Secara alami, mengukur waktu pada CPU tidak memenuhi kondisi ini.  Kode mesin bervariasi tergantung pada arsitektur dan sistem operasi, dan kode yang sama akan membutuhkan waktu yang berbeda untuk dieksekusi.  Bahkan pada mesin yang sama, faktor-faktor seperti cache misses akan memainkan peran besar - cukup untuk mengubah hasil pengukuran waktu eksekusi kode yang sama.  Saya membutuhkan sesuatu yang lebih pintar ... <br><a name="habracut"></a><br><h3>  Motivasi </h3><br>  Saya mengalami masalah ini ketika saya sedang mengerjakan proyek saya, Code Character.  Code Character adalah kompetisi AI online di mana peserta menulis bot untuk mengendalikan pasukan dalam strategi berbasis giliran.  Saya ingin membatasi jumlah kode yang dapat dijalankan oleh satu peserta dalam satu gerakan. <br><br>  Pikiran pertama saya hanyalah mengukur waktu eksekusi kode, tetapi, seperti yang dapat kita lihat, strategi ini tidak deterministik, dan peserta yang mengirim kode yang sama dua kali akan mendapatkan hasil yang sama sekali berbeda.  Bahkan, kami mencoba menerapkan solusi ini, dan hasilnya sangat berubah sehingga peserta dapat menang atau kalah dengan kode yang sama.  Hasilnya akan sepenuhnya acak, dan kami membuang ide untuk mengukur waktu. <br><br><h3>  Bytecode LLVM </h3><br>  Karena kami tidak dapat mengukur waktu, kami memutuskan untuk mengukur jumlah instruksi yang dieksekusi.  Karena itu, kita perlu memasukkan kode peserta.  Jika Anda tidak terbiasa dengan istilah ini, ini menambahkan beberapa kode ke aplikasi, untuk memantau beberapa parameter, misalnya, penggunaan atau runtime CPU.  Secara alami, kami tidak mengharapkan para peserta untuk melakukan ini sendiri, kami harus mengotomatiskan prosesnya. <br><br>  Kami ingin menghindari biaya overhead untuk alat runtime ketika bekerja di server kami, dan karena itu sesuatu seperti alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PIN</a> tidak cocok untuk tujuan kami.  Sebagai gantinya, kami memutuskan untuk secara langsung menginstruksikan kode peserta untuk menghitung jumlah instruksi yang akan dieksekusi.  Alih-alih menginstruksikan binari (kode mesin), kami memutuskan untuk menggunakan Dentang untuk mengkompilasi kode dan instrumen bytecode LLVM. <br><br>  Jika Anda baru mengenal LLVM, ini adalah kumpulan teknologi kompiler dan toolchain modular dan dapat digunakan kembali.  Salah satu proyek utama adalah LLVM IR dan backend.  Secara sederhana, Representasi Menengah telah dikembangkan ke mana kompilasi frontend mengkompilasi kode.  Kode ini, LLVM IR, kemudian dikompilasi ke dalam kode mesin oleh backend LLVM.  Jadi, jika Anda membuat bahasa baru, Anda dapat memutuskan untuk mengizinkan LLVM untuk mendukung pembuatan dan optimisasi kode mesin, dan menulis tampilan depan untuk mengonversi bahasa Anda ke LLVM IR. <br><br><img src="https://habrastorage.org/webt/ag/ud/pm/agudpmnchiuciou-p29zk8z5nzo.png"><br>  <i>Dentang mengkonversi kode C ++ ke LLVM IR, yang kemudian dikonversi ke kode mesin oleh backend LLVM.</i> <br><br>  Dentang adalah garis depan LLVM.  Karena kita memerlukan metode lintas platform untuk mengukur kode, kita tidak dapat memasukkan kode biner.  LLVM IR, bagaimanapun, adalah platform independen, karena hanya merupakan representasi kode yang sedang.  Menginstruksikan kode IR dengan perpustakaan LLVM adalah solusi lintas platform yang sederhana. <br><br><h3>  Solusi </h3><br>  Jumlah instruksi IR LLVM sederhana jelas tidak cocok, karena kita membutuhkan jumlah instruksi yang benar-benar akan dieksekusi, dan bukan hanya jumlah instruksi dalam kode.  Pada akhirnya, kami mengembangkan algoritma sederhana berdasarkan konsep blok kode dasar. <br><br>  Unit dasar adalah seperangkat instruksi di mana hanya instruksi pertama yang dapat menjadi titik input, dan hanya instruksi terakhir yang dapat menjadi titik output.  ( <i>Transisi apa pun di dalam blok dasar juga dilarang - kira-kira terjemahan.</i> ) Untuk memahami hal ini, cobalah untuk membagi kode menjadi potongan-potongan di mana instruksi cabang (transisi, loop, dan kembali) hanya dapat menjadi yang terakhir dalam set, dan input ke blok (instruksi pertama dalam fungsi, loop atau jika / else memblokir) hanya mungkin pada instruksi pertama.  Hasilnya adalah satu set blok dasar - blok kode sekuensial yang hanya menjalankan secara berurutan, tanpa memutuskan instruksi mana yang akan dieksekusi selanjutnya. <br><br>  Kenapa kita tidak mencobanya sekarang?  Ini adalah cuplikan kode yang disediakan oleh kontributor Karakter Kode: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the soldiers who aren't patrolling attack the enemy for (int i = NUM_SOLDIERS / 2; i &lt; NUM_SOLDIERS; ++i) { auto &amp;soldier = state.soldiers[i]; if (soldier.hp == 0) // If this soldier is dead, skip it continue; for (auto enemy_soldier : state.enemy_soldiers) { if (enemy_soldier.hp != 0) { // Ensure your prospective target has // not already been slain soldier.soldier_target = enemy_soldier.id; break; } } }</span></span></code> </pre> <br>  Tautan Github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://gist.github.com/JHurricane96/8c9c3a45ec5e969de4d9fecb47ebef69#file-player_code-cpp</a> <br><br>  Dengan menggunakan fakta bahwa unit dasar hanya memiliki satu titik input (instruksi pertama), kita dapat membagi fragmen ini menjadi unit dasar berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-------------------------------- BB 1 ---------------------------------- for (int i = NUM_SOLDIERS / 2; i &lt; NUM_SOLDIERS; ++i) { //-------------------------------- BB 2 ---------------------------------- auto &amp;soldier = state.soldiers[i]; if (soldier.hp == 0) //-------------------------------- BB 3 ---------------------------------- continue; //-------------------------------- BB 4 ---------------------------------- for (auto enemy_soldier : state.enemy_soldiers) { //-------------------------------- BB 5 ---------------------------------- if (enemy_soldier.hp != 0) { //-------------------------------- BB 6 ---------------------------------- soldier.soldier_target = enemy_soldier.id; break; //-------------------------------- BB 7 ---------------------------------- } } }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github Link</a> <br>  Ini membantu kami memahami bagaimana blok dasar bekerja, sekarang mari kita lihat algoritma ini di LLVM IR: <br><br><pre> <code class="cpp hljs">; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">140</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">181</span></span>, %<span class="hljs-number"><span class="hljs-number">139</span></span> %<span class="hljs-number"><span class="hljs-number">141</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">142</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">141</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">143</span></span> = icmp slt i64 %<span class="hljs-number"><span class="hljs-number">142</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> br i1 %<span class="hljs-number"><span class="hljs-number">143</span></span>, label %<span class="hljs-number"><span class="hljs-number">144</span></span>, label %<span class="hljs-number"><span class="hljs-number">184</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">144</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">140</span></span> %<span class="hljs-number"><span class="hljs-number">145</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">146</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">147</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">146</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">148</span></span> = call dereferenceable(<span class="hljs-number"><span class="hljs-number">72</span></span>) %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* @_ZNSt5arrayIN12player_state7SoldierELm20EEixEm( %<span class="hljs-string"><span class="hljs-string">"struct.std::array.10"</span></span>* %<span class="hljs-number"><span class="hljs-number">145</span></span>, i64 %<span class="hljs-number"><span class="hljs-number">147</span></span>) #<span class="hljs-number"><span class="hljs-number">3</span></span> store %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">148</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">149</span></span> = load %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>*, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">150</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">149</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">151</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">150</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">152</span></span> = icmp eq i64 %<span class="hljs-number"><span class="hljs-number">151</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %<span class="hljs-number"><span class="hljs-number">152</span></span>, label %<span class="hljs-number"><span class="hljs-number">153</span></span>, label %<span class="hljs-number"><span class="hljs-number">154</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">153</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">144</span></span> br label %<span class="hljs-number"><span class="hljs-number">181</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github Link</a> <br><br>  Jika Anda perhatikan dengan teliti, Anda akan melihat bahwa fragmen kode di atas adalah tiga blok pertama dari fragmen kode C ++ yang dikompilasi dalam LLVM IR (setiap baris adalah awal dari blok dasar). <br><br>  LLVM memiliki perpustakaan yang memungkinkan kita untuk menulis "melewati" - kode yang dapat mengubah LLVM IR.  API LLVM memungkinkan kita untuk dengan mudah membaca dan menganalisis LLVM IR dengan melakukan iterasi melalui modul, fungsi, dan blok dasar, dan memodifikasi LLVM IR sebelum dikompilasi ke dalam kode mesin. <br><br>  Sekarang kita memiliki blok dasar dan API LLVM, menjadi hal yang sederhana untuk menghitung jumlah instruksi yang akan dieksekusi menggunakan algoritma sederhana seperti itu: <br><br><ol><li>  Kami menulis fungsi IncrementCount, yang mengambil bilangan bulat dan menambah bilangan bulat statis dengan nilai ini, setiap kali disebut.  Itu harus dikaitkan dengan kode anggota. </li><li>  Kami melakukan iterasi pada semua blok dasar.  Untuk setiap unit dasar, lakukan langkah 3 dan 4. </li><li>  Kami menemukan n - jumlah instruksi dalam unit dasar ini. </li><li>  Kami memasukkan panggilan ke fungsi IncrementCount sebelum instruksi terakhir dari unit dasar, dengan argumen n. </li><li>  Integer statis yang berfungsi dengan IncrementCount akan menjadi penghitung instruksi setelah kode dieksekusi.  Itu dapat disimpan di suatu tempat dan kemudian diperiksa. </li></ol><br>  IR instrumen kami berfungsi seperti ini: <br><br><pre> <code class="cpp hljs">; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">140</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">181</span></span>, %<span class="hljs-number"><span class="hljs-number">139</span></span> %<span class="hljs-number"><span class="hljs-number">141</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">142</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">141</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">143</span></span> = icmp slt i64 %<span class="hljs-number"><span class="hljs-number">142</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">4</span></span>) br i1 %<span class="hljs-number"><span class="hljs-number">143</span></span>, label %<span class="hljs-number"><span class="hljs-number">144</span></span>, label %<span class="hljs-number"><span class="hljs-number">184</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">144</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">140</span></span> %<span class="hljs-number"><span class="hljs-number">145</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">146</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">147</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">146</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">148</span></span> = call dereferenceable(<span class="hljs-number"><span class="hljs-number">72</span></span>) %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* @_ZNSt5arrayIN12player_state7SoldierELm20EEixEm( %<span class="hljs-string"><span class="hljs-string">"struct.std::array.10"</span></span>* %<span class="hljs-number"><span class="hljs-number">145</span></span>, i64 %<span class="hljs-number"><span class="hljs-number">147</span></span>) #<span class="hljs-number"><span class="hljs-number">3</span></span> store %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">148</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">149</span></span> = load %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>*, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">150</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">149</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">151</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">150</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">152</span></span> = icmp eq i64 %<span class="hljs-number"><span class="hljs-number">151</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">10</span></span>) br i1 %<span class="hljs-number"><span class="hljs-number">152</span></span>, label %<span class="hljs-number"><span class="hljs-number">153</span></span>, label %<span class="hljs-number"><span class="hljs-number">154</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">153</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">144</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">1</span></span>) br label %<span class="hljs-number"><span class="hljs-number">181</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github Link</a> <br><br>  Seperti yang bisa kita lihat, panggilan IncrementCount dibuat di akhir setiap blok dasar, tepat sebelum pernyataan terakhir.  Menggunakan int statis yang bekerja dengan IncrementCount, kita bisa mendapatkan jumlah instruksi di akhir setiap gerakan peserta.  Metode ini bersifat deterministik dan lintas platform, sebagai  kode sumber yang sama dijamin untuk menghasilkan LLVM IR yang sama jika kita menggunakan versi yang sama dari kompiler dan bendera yang sama. <br><br><h3>  Kesimpulan </h3><br>  Pembuatan kode bukanlah hal yang sederhana seperti yang pernah saya pikirkan.  Dalam proses mengerjakan tugas yang relatif sederhana, saya berkenalan dengan cara kerja kompiler dan cara menulis pass LLVM.  Jika Anda tertarik untuk menghasilkan kode dan ingin menulis bagian Anda sendiri, LLVM memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan pemula</a> .  ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> blog yang bagus yang saya gunakan untuk menulis bagian saya sendiri.  Karena LLVM API tidak kompatibel mundur antara versi utama, perhatikan versi LLVM yang Anda gunakan. <br><br>  Anda bisa mendapatkan kode sumber pass di <a href="">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417029/">https://habr.com/ru/post/id417029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417013/index.html">"Bukit pasir" Pluto bukan terbuat dari pasir - ini adalah butiran metana beku</a></li>
<li><a href="../id417015/index.html">Kami memahami catatan apa dan apa yang tidak merekam aplikasi Burger King</a></li>
<li><a href="../id417017/index.html">Bagaimana percobaan nuklir yang gagal secara tidak sengaja menghasilkan astronomi neutrino</a></li>
<li><a href="../id417023/index.html">Pengalaman Rambler Group: bagaimana kami mulai sepenuhnya mengontrol pembentukan dan perilaku komponen Bereaksi front-end</a></li>
<li><a href="../id417027/index.html">Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Pendahuluan</a></li>
<li><a href="../id417031/index.html">Mobile OAuth 2.0 Security</a></li>
<li><a href="../id417033/index.html">QIWI Kitchen pada 7 Juni - video pidato para pembicara kami</a></li>
<li><a href="../id417035/index.html">UnnyWorld: post-mortem</a></li>
<li><a href="../id417037/index.html">BEERBRAZZERS. Kontrol cahaya. Lampu Vixen 3. Mulai Cepat (1/4)</a></li>
<li><a href="../id417039/index.html">Pelajari wordpress (dan banyak lagi) untuk membuat pemain Youtube dengan cepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>