<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèæ ‚ôëÔ∏è üë©üèæ‚Äçüåæ Placa de depura√ß√£o STM32F4 no fator de forma do Raspberry Pi ü¶å üì§ üö®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boa tarde, queridos Khabrovites! Quero apresentar meu projeto ao p√∫blico - uma pequena placa de depura√ß√£o baseada no STM32, mas com o fator de forma d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Placa de depura√ß√£o STM32F4 no fator de forma do Raspberry Pi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413101/"><p><img src="https://habrastorage.org/webt/m_/xs/9t/m_xs9tnnhio8gxliqrjhdj3zxxw.jpeg" alt="imagem" align="left">  Boa tarde, queridos Khabrovites!  Quero apresentar meu projeto ao p√∫blico - uma pequena placa de depura√ß√£o baseada no STM32, mas com o fator de forma do Raspberry Pi.  Difere de outras placas de depura√ß√£o, pois possui uma geometria compat√≠vel com os gabinetes Raspberry Pi e um m√≥dulo ESP8266 como modem sem fio.  E tamb√©m adi√ß√µes agrad√°veis ‚Äã‚Äãna forma de um conector para um cart√£o micro-SD e um amplificador est√©reo.  Para tirar proveito de toda essa riqueza, desenvolvi uma biblioteca de alto n√≠vel e um programa de demonstra√ß√£o (em C ++ 11).  No artigo, quero descrever em detalhes as partes de hardware e software deste projeto. </p><a name="habracut"></a><br><p>  Quem pode se beneficiar desse projeto?  Provavelmente, apenas para aqueles que desejam soldar esta placa pessoalmente, pois n√£o considero nenhuma op√ß√£o, mesmo para produ√ß√£o em pequena escala.  Este √© um hobby puro.  Na minha opini√£o, o conselho abrange uma gama bastante ampla de tarefas que podem surgir no √¢mbito de pequenos trabalhos dom√©sticos usando Wi-Fi e som. </p><br><p>  Para come√ßar, tentarei responder √† pergunta por que isso √© tudo.  Os principais motivadores deste projeto s√£o os seguintes: </p><br><ul><li>  A escolha da plataforma STM32 deve-se a considera√ß√µes puramente est√©ticas - eu gosto da rela√ß√£o pre√ßo / desempenho, al√©m de uma ampla gama de perif√©ricos, al√©m de um amplo e conveniente ecossistema de desenvolvimento do fabricante do controlador (biblioteca sw4stm, cubeMX, HAL). </li><li>  Obviamente, existem muitas placas de depura√ß√£o do pr√≥prio fabricante do controlador (Discovery, Nucleo), bem como de fabricantes de terceiros (por exemplo, Olimex).  Mas repetir muitos deles em casa em seu formato √© problem√°tico para mim, pelo menos.  Na minha vers√£o, temos uma topologia simples de duas camadas e componentes convenientes para a soldagem manual. </li><li>  Para os dispositivos deles, quero ter caixas decentes para mascarar a baixa qualidade dos eletr√¥nicos internos.  Existem pelo menos duas plataformas populares para as quais h√° um grande n√∫mero de casos mais diversos: Arduino e Raspberry Pi.  O segundo deles me pareceu mais conveniente em termos da localiza√ß√£o dos recortes dos conectores.  Portanto, como doador da geometria do painel, eu o escolhi. </li><li>  O controlador que eu selecionei a bordo tem USB, SDIO, I2S, rede.  Por outro lado, essas mesmas interfaces tamb√©m s√£o √∫teis para uma plataforma de hobby em casa.  √â por isso que, al√©m do controlador com um chicote padr√£o, adicionei um conector USB, um cart√£o SD, um caminho de √°udio (conversor e amplificador digital-anal√≥gico) e um m√≥dulo sem fio baseado no ESP8266. </li></ul><br><h2 id="shema-i-komponenty">  Circuito e componentes </h2><br><p>  Parece-me que uma placa muito bonita com as seguintes caracter√≠sticas e componentes acabou: </p><br><ul><li>  Controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STM32F405RG</a> : ARM Cortex-M4 de 32 bits com um coprocessador matem√°tico, frequ√™ncia de at√© 168 MHz, mem√≥ria flash de 1 Mb, 196 Kb de RAM. <br><img src="https://habrastorage.org/webt/w1/je/fb/w1jefbi3tuwerk7nyio5awywiky.png" alt="Pinos controladores usados"><br><img src="https://habrastorage.org/webt/-a/ta/sr/-atasrnz4pajsqagowftqvzok5q.png" alt="Liga√ß√£o do controlador"></li><li>  Conector SWD para programar o controlador (6 pinos). </li><li>  Redefinir para reiniciar. </li><li>  LED de tr√™s cores.  Por um lado, tr√™s pinos do controlador s√£o perdidos.  Por outro lado, eles ainda se perderiam devido aos contatos limitados nos conectores GPIO e, para depurar esse LED, a coisa √© muito √∫til. </li><li>  HSE de alta frequ√™ncia (16 MHz para clock principal) e LSE de baixa frequ√™ncia (32,7680 kHz para clock em tempo real). </li><li>  Os pinos GPIO com passo de 2,54 mm s√£o compat√≠veis com placas de prototipagem. </li><li>  No lugar da tomada de √°udio de 3,5 mm do Raspberry Pi, posicionei o conector de 5 volts.  √Ä primeira vista, a decis√£o √© controversa.  Mas existem profissionais.  A energia do conector USB est√° opcionalmente presente (detalhes abaixo), mas essa √© uma op√ß√£o ruim para depura√ß√£o do circuito, pois o tempo antes de gravar a porta USB do computador nesse caso pode ser bastante curto. </li></ul><br><p><img src="https://habrastorage.org/webt/0s/qk/mk/0sqkmkrm5j1lt5bhkaiftrpz-y8.png" alt="Circuito de pot√™ncia"></p><br><ul><li>  Porta Mini-USB  Por um lado, √© conectado atrav√©s do chip de prote√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STF203-22.TCT</a> √† porta USB-OTG do controlador.  Por outro lado, o pino de for√ßa do VBUS est√° conectado ao conector GPIO.  Se voc√™ conect√°-lo ao pino + 5V, a placa ser√° alimentada a partir da porta USB. </li></ul><br><p><img src="https://habrastorage.org/webt/4q/te/om/4qteom17ikstddtnjafa78pqpme.png" alt="Circuito USB"></p><br><ul><li>  Conector para cart√£o de mem√≥ria micro-SD com chicote: resistores pull-up de 47 kŒ©, transistor de gerenciamento de energia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MOSFET BSH205 de canal P</a> ) e um pequeno LED verde na linha de energia. </li></ul><br><p><img src="https://habrastorage.org/webt/qb/3x/el/qb3xelfstpguacjkqhnss45nlxk.png" alt="Contorno do cart√£o Micro SD"></p><br><p>  A porta do transistor est√° conectada ao pino PA15 do controlador.  Este √© o contato do sistema do controlador JTDI, o que √© interessante, pois na posi√ß√£o inicial ele √© configurado como uma sa√≠da com um alto n√≠vel (tra√ß√£o) de tens√£o.  Como o SWD √© usado em vez do JTAG para programa√ß√£o, esse contato permanece livre e pode ser usado para outros fins, por exemplo, controlar um transistor.  Isso √© conveniente - quando a energia √© aplicada √† placa, o cart√£o de mem√≥ria √© desenergizado; para habilit√°-lo, √© necess√°rio aplicar um n√≠vel baixo ao pino PA15. </p><br><ul><li>  Conversor digital-anal√≥gico baseado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UDA1334</a> .  Este chip n√£o precisa de um sinal de rel√≥gio externo, o que facilita seu uso.  Os dados s√£o transmitidos pelo barramento I2S.  Por outro lado, a Folha de dados recomenda o uso de at√© 5 capacitores polares a 47 ŒºF.  Tamanho √© importante neste caso.  Os menores que acabaram sendo comprados s√£o o t√¢ntalo, com um tamanho de 1411, que nem √© barato.  No entanto, escreverei sobre o pre√ßo com mais detalhes abaixo.  Para energia anal√≥gica, √© usado seu pr√≥prio estabilizador linear, a energia da parte digital √© ligada / desligada por um transistor duplo. </li></ul><br><p><img src="https://habrastorage.org/webt/4f/rh/ea/4frheacnbm39nin0t79ubdatfy8.png" alt="Circuito DAC"></p><br><ul><li>  Amplificador de dois canais com base em dois chips <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">31AP2005</a> .  Sua principal vantagem √© um pequeno n√∫mero de componentes de cintas (apenas filtros de energia e um filtro de entrada).  Sa√≠da de √°udio - 4 plataformas com um passo de 2,54 mm.  Para mim, ainda n√£o decidi o que √© melhor - uma op√ß√£o improvisada ou, como em uma framboesa, um plugue de 3,5 mm.  Como regra, 3,5 mm est√£o associados aos fones de ouvido. No nosso caso, estamos falando sobre conectar alto-falantes. </li></ul><br><p><img src="https://habrastorage.org/webt/ke/ge/qa/kegeqak09asea0z1npbr7u9clyw.png" alt="Circuito amplificador"></p><br><ul><li>  O √∫ltimo m√≥dulo √© um xale ESP11 com uma cinta (alimenta√ß√£o, soquete de programa√ß√£o) como um modem WiFi.  As conclus√µes da placa UART s√£o conectadas ao controlador e emitidas simultaneamente para um conector externo (para trabalhar com a placa diretamente do terminal e da programa√ß√£o).  H√° um interruptor de energia (externo permanente ou controle de um microcontrolador).  H√° um LED adicional para indicar energia e um conector "FLASH" para colocar a placa no modo de programa√ß√£o. </li></ul><br><p><img src="https://habrastorage.org/webt/3d/cq/1d/3dcq1dpb4u-iog9jbnix9icc1ac.png" alt="Circuito ESP"></p><br><p>  Obviamente, o pr√≥prio ESP8266 √© um bom controlador, mas ainda √© inferior ao STM32F4, tanto em desempenho quanto em perif√©ricos.  Sim, e o tamanho do pre√ßo deste m√≥dulo indicava que era uma unidade de modem derramada para seu irm√£o mais velho.  O m√≥dulo √© controlado pela USRT usando um protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AT de</a> texto. </p><br><p>  Algumas fotos: <br> <a href=""><img src="https://habrastorage.org/webt/if/zv/di/ifzvdi77bc5vhkauczq8kwfa6mg.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/dg/go/lz/dggolzrzpwxghtqnwtdyf_plogo.jpeg"></a> </p><br><h2 id="podgotovka-modulya-esp11">  Preparando o m√≥dulo ESP11 </h2><br><p>  ESP8266 √© uma coisa bem conhecida.  Tenho certeza de que muitos j√° est√£o familiarizados com isso, portanto um guia detalhado ser√° sup√©rfluo aqui.  Devido aos recursos esquem√°ticos de conectar o m√≥dulo ESP11 √† placa, darei apenas um breve guia para quem deseja alterar seu firmware: </p><br><ul><li>  Vou usar o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esptool</a> para trabalhar com o ESP.  Diferentemente do utilit√°rio padr√£o do fabricante, o esptool √© independente da plataforma. </li><li>  Para come√ßar, ative o modo de energia externa com o jumper ESP-PWR (fechamos os contatos 1 e 2) e conecte o m√≥dulo ao computador atrav√©s de qualquer adaptador USART-USB.  O adaptador se conecta aos pinos GRD / RX / TD.  Fornecemos energia √† placa: <br> <a href=""><img src="https://habrastorage.org/webt/qk/sg/_u/qksg_updoacqtvh5a_bmczc_poe.jpeg"></a> </li><li>  Garantimos que o adaptador seja reconhecido pelo sistema operacional.  No meu exemplo, eu uso um adaptador baseado no FT232, portanto, com a lista de dispositivos, ele deve estar vis√≠vel como IC serial do FT232 (UART): <br><pre><code class="bash hljs">&gt; lsusb ... Bus 001 Device 010: ID 0483:3748 STMicroelectronics ST-LINK/V2 Bus 001 Device 009: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC ...</code> </pre> </li><li>  Os pr√≥prios ESP8266 diferem na quantidade de mem√≥ria flash.  Na pr√°tica, no mesmo m√≥dulo ESP11, me deparei com 512 KB (4 Mbit) e 1 MB (8 Mbit).  Portanto, a primeira coisa a verificar √© quanta mem√≥ria existe na inst√¢ncia usada do m√≥dulo.  Desligue a alimenta√ß√£o da placa e coloque o m√≥dulo no modo de programa√ß√£o, fechando o jumper "FLASH": </li></ul><br><p> <a href=""><img src="https://habrastorage.org/webt/dr/i8/8p/dri88pfduzkumw9u2_euqtz2_va.jpeg"></a> </p><br><ul><li>  Ligue a energia, execute esptool com os seguintes par√¢metros </li></ul><br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 flash_id Connecting.... Detecting chip <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>... ESP8266 Chip is ESP8266EX Uploading stub... Running stub... Stub running... Manufacturer: e0 Device: 4014 Detected flash size: 1MB Hard resetting...</code> </pre> <br><ul><li>  A esptool relata que, neste caso, estamos lidando com um m√≥dulo com 1 MB de mem√≥ria. </li><li>  Para a vers√£o com 1 MB, voc√™ pode usar o firmware mais recente, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ESP8266 AT Bin V1.6.1</a> .  Mas n√£o √© adequado para a vers√£o de 4 Mbit, para a qual voc√™ precisa usar algo mais antigo, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> .  O firmware consiste em v√°rios arquivos, os endere√ßos iniciais de cada arquivo s√£o indicados no documento oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ESP8266 AT Conjunto de instru√ß√µes</a> .  Esses endere√ßos de in√≠cio s√£o usados ‚Äã‚Äãcomo par√¢metros do utilit√°rio esptool.  Por exemplo, para um m√≥dulo com 1 MB, os par√¢metros do esptool ter√£o a seguinte apar√™ncia (todos os arquivos necess√°rios devem ser extra√≠dos primeiro do arquivo de firmware e coletados no diret√≥rio de trabalho) <br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 write_flash 0x00000 boot.bin 0x01000 user1.1024.new.2.bin 0x7E000 blank.bin 0xFB000 blank.bin 0xFC000 esp_init_data_default.bin 0xFE000 blank.bin</code> </pre> </li><li>  N√≥s fornecemos energia para a placa, execute esptool com os par√¢metros especificados. </li><li>  Ap√≥s concluir o script, desligue a energia da placa, abra o jumper "FLASH", ligue o controle de energia do microcontrolador.  O m√≥dulo est√° pronto para o trabalho. </li></ul><br><h2 id="programmnoe-obespechenie">  De software </h2><br><p>  Existe um programa de teste no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> .  Ela faz o seguinte: </p><br><ul><li>  exibe o controlador na frequ√™ncia m√°xima (168 MHz) </li><li>  ativa o rel√≥gio em tempo real </li><li>  ativa o cart√£o SD e l√™ a configura√ß√£o de rede a partir dele.  A biblioteca FatFS √© usada para trabalhar com o sistema de arquivos. </li><li>  estabelece uma conex√£o com a WLAN especificada </li><li>  conecta ao servidor NTP especificado e solicita a hora atual dele.  Leva o rel√≥gio. </li><li>  monitora o status de v√°rias portas especificadas.  Se o status deles foi alterado, envia uma mensagem de texto para o servidor TCP especificado. </li><li>  quando voc√™ clica no bot√£o externo, ele l√™ o arquivo * .wav especificado do cart√£o SD e o reproduz no modo ass√≠ncrono (I2S usando o controlador DMA). </li><li>  o trabalho com o ESP11 tamb√©m √© implementado no modo ass√≠ncrono (at√© agora sem DMA, apenas com interrup√ß√µes) </li><li>  efetua login via USART1 (pinos PB6 / PB7) </li><li>  e, claro, o LED pisca. </li></ul><br><p>  Em Habr√©, havia muitos artigos dedicados √† programa√ß√£o do STM32 em um n√≠vel bastante baixo (apenas pelo gerenciamento de registros ou CMSIS).  Por exemplo, do relativamente √∫ltimo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tr√™s</a> .  Os artigos s√£o, obviamente, de alta qualidade, mas minha opini√£o subjetiva √© de que, para o desenvolvimento √∫nico de um produto, essa abordagem talvez se justifique.  Por√©m, para um projeto de hobby de longo prazo, quando voc√™ deseja que tudo seja bonito e extens√≠vel, essa abordagem √© de n√≠vel muito baixo.  Uma das raz√µes para a popularidade do Arduino como plataforma de software, na minha opini√£o, √© que os autores do Arduino deixaram um n√≠vel t√£o baixo para a arquitetura orientada a objetos.  Portanto, decidi seguir na mesma dire√ß√£o e adicionar uma camada orientada a objetos de n√≠vel bastante alto sobre a biblioteca HAL. </p><br><p>  Assim, s√£o obtidos tr√™s n√≠veis do programa: </p><br><ul><li>  As bibliotecas de fabricantes (HAL, FatFS, no futuro USB-OTG) formam a base </li><li>  Minha biblioteca StmPlusPlus √© baseada nessa base.  Inclui um conjunto de classes base (como System, IOPort, IOPin, Timer, RealTimeClock, Usart, Spi, I2S), um conjunto de classes de drivers de dispositivos externos (como SdCard, Esp11, DcfReceiver, Dac_MCP49x1, AudioDac_UDA1334 e similares), al√©m de classes de servi√ßo, como um player ass√≠ncrono WAV. </li><li>  Com base na biblioteca StmPlusPlus, o pr√≥prio aplicativo est√° sendo constru√≠do. </li></ul><br><p>  Quanto ao dialeto do idioma.  Enquanto eu sou um pouco antiquado, permane√ßo em C ++ 11.  Esse padr√£o possui v√°rios recursos que s√£o especialmente √∫teis para o desenvolvimento de firmware: classes enum, chamando construtores com chaves para controlar os tipos de par√¢metros passados ‚Äã‚Äãe recipientes est√°ticos como std :: array.  A prop√≥sito, em Habr√©, h√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo maravilhoso</a> sobre esse assunto. </p><br><h3 id="biblioteka-stmplusplus">  Biblioteca StmPlusPlus </h3><br><p>  O c√≥digo completo da biblioteca pode ser visualizado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> .  Aqui darei apenas alguns pequenos exemplos para mostrar a estrutura, a id√©ia e os problemas gerados por essa id√©ia. </p><br><p>  <strong>O primeiro exemplo</strong> √© uma classe para pesquisar periodicamente o estado de um pino (por exemplo, um bot√£o) e chamar o manipulador quando esse estado muda: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> :</span></span> IOPin { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onButtonPressed</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Button *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numOccured)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; }; Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay = <span class="hljs-number"><span class="hljs-number">50</span></span>, duration_ms _pressDuration = <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventHandler * _handler)</span></span></span><span class="hljs-function"> </span></span>{ handler = _handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">periodic</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; rtc; duration_ms pressDelay, pressDuration; time_ms pressTime; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentState; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured; EventHandler * handler; };</code> </pre> <br><p>  O construtor define todos os par√¢metros do bot√£o: </p><br><pre> <code class="cpp hljs">Button::Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay, duration_ms _pressDuration): IOPin{name, pin, GPIO_MODE_INPUT, pull, GPIO_SPEED_LOW}, rtc{_rtc}, pressDelay{_pressDelay}, pressDuration{_pressDuration}, pressTime{INFINITY_TIME}, currentState{<span class="hljs-literal"><span class="hljs-literal">false</span></span>}, numOccured{<span class="hljs-number"><span class="hljs-number">0</span></span>}, handler{<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>} { <span class="hljs-comment"><span class="hljs-comment">// empty }</span></span></code> </pre> <br><p>  Se o tratamento desses eventos n√£o for uma prioridade, o uso de interrup√ß√µes ser√° claramente sup√©rfluo.  Portanto, v√°rios cen√°rios de prensagem (por exemplo, uma √∫nica press√£o ou reten√ß√£o) s√£o implementados no procedimento peri√≥dico, que deve ser chamado periodicamente a partir do c√≥digo principal do programa.  periodic analisa a mudan√ßa de estado e chama de forma s√≠ncrona o manipulador virtual onButtonPressed, que deve ser implementado no programa principal: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::periodic () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> newState = (gpioParameters.Pull == GPIO_PULLUP)? !getBit() : getBit(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentState == newState) { <span class="hljs-comment"><span class="hljs-comment">// state is not changed: check for periodical press event if (currentState &amp;&amp; pressTime != INFINITY_TIME) { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &gt;= pressDuration) { handler-&gt;onButtonPressed(this, numOccured); pressTime = rtc.getUpTimeMillisec(); ++numOccured; } } } else if (!currentState &amp;&amp; newState) { pressTime = rtc.getUpTimeMillisec(); numOccured = 0; } else { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &lt; pressDelay) { // nothing to do } else if (numOccured == 0) { handler-&gt;onButtonPressed(this, numOccured); } pressTime = INFINITY_TIME; } currentState = newState; }</span></span></code> </pre> <br><p>  A principal vantagem dessa abordagem √© a diversidade de l√≥gica e c√≥digo para detectar um evento de seu processamento.  N√£o √© o HAL_GetTick usado para o tempo de contagem, que, devido ao seu tipo (uint32_t), √© redefinido por estouro a cada 2 ^ 32 milissegundos (a cada 49 dias).  Eu implementei minha pr√≥pria classe RealTimeClock, que conta milissegundos desde o in√≠cio do programa, ou liguei o controlador como uint64_t, que fornece cerca de 5 ^ 8 anos. </p><br><p>  <strong>O segundo exemplo</strong> est√° trabalhando com uma interface de hardware, da qual existem v√°rias no controlador.  Por exemplo, SPI.  Do ponto de vista do programa principal, √© muito conveniente selecionar apenas a interface desejada (SPI1 / SPI2 / SPI3), e todos os outros par√¢metros que dependem dessa interface ser√£o configurados pelo construtor da classe. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spi</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TIMEOUT = <span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceName</span></span></span><span class="hljs-class"> {</span></span> SPI_1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, SPI_2 = <span class="hljs-number"><span class="hljs-number">1</span></span>, SPI_3 = <span class="hljs-number"><span class="hljs-number">2</span></span>, }; Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull = GPIO_NOPULL); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prescaler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataSize = SPI_DATASIZE_8BIT, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CLKPhase = SPI_PHASE_1EDGE)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBuffer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_SPI_Transmit(hspi, pData, pSize, TIMEOUT); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: DeviceName device; IOPin sck, miso, mosi; SPI_HandleTypeDef *hspi; SPI_HandleTypeDef spiParams; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br><p>  Os par√¢metros de pinos e os par√¢metros de interface s√£o armazenados localmente na classe.  Infelizmente, escolhi uma op√ß√£o de implementa√ß√£o n√£o totalmente bem-sucedida, quando as configura√ß√µes de par√¢metros, dependendo de uma interface espec√≠fica, s√£o implementadas diretamente: </p><br><pre> <code class="cpp hljs">Spi::Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull): device(_device), sck(sckPort, sckPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), miso(misoPort, misoPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), mosi(mosiPort, mosiPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), hspi(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (device) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DeviceName::SPI_1: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI1 sck.setAlternate(GPIO_AF5_SPI1); miso.setAlternate(GPIO_AF5_SPI1); mosi.setAlternate(GPIO_AF5_SPI1); spiParams.Instance = SPI1; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; ... case DeviceName::SPI_3: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI3 sck.setAlternate(GPIO_AF6_SPI3); miso.setAlternate(GPIO_AF6_SPI3); mosi.setAlternate(GPIO_AF6_SPI3); spiParams.Instance = SPI3; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; } spiParams.Init.Mode = SPI_MODE_MASTER; spiParams.Init.DataSize = SPI_DATASIZE_8BIT; spiParams.Init.CLKPolarity = SPI_POLARITY_HIGH; spiParams.Init.CLKPhase = SPI_PHASE_1EDGE; spiParams.Init.FirstBit = SPI_FIRSTBIT_MSB; spiParams.Init.TIMode = SPI_TIMODE_DISABLE; spiParams.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; spiParams.Init.CRCPolynomial = 7; spiParams.Init.NSS = SPI_NSS_SOFT; }</span></span></code> </pre> <br><p>  O mesmo esquema implementa os procedimentos enableClock e disableClock, que s√£o pouco extens√≠veis e pouco port√°veis ‚Äã‚Äãpara outros controladores.  Nesse caso, √© melhor usar modelos nos quais o par√¢metro do modelo √© o nome da interface HAL (SPI1, SPI2, SPI3), par√¢metros de pinos (GPIO_AF5_SPI1) e algo que controla o rel√≥gio on / off.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">H√°</a> um artigo interessante sobre esse t√≥pico, embora ele revise os controladores AVR, que, no entanto, n√£o fazem uma diferen√ßa fundamental. </p><br><p>  O in√≠cio e o fim da transfer√™ncia s√£o controlados por dois m√©todos de in√≠cio / parada: </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef Spi::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> direction, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> prescaler, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataSize, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> CLKPhase) { hspi = &amp;spiParams; enableClock(); spiParams.Init.Direction = direction; spiParams.Init.BaudRatePrescaler = prescaler; spiParams.Init.DataSize = dataSize; spiParams.Init.CLKPhase = CLKPhase; HAL_StatusTypeDef status = HAL_SPI_Init(hspi); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } <span class="hljs-comment"><span class="hljs-comment">/* Configure communication direction : 1Line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spiParams.Init.Direction == SPI_DIRECTION_1LINE) { SPI_1LINE_TX(hspi); } <span class="hljs-comment"><span class="hljs-comment">/* Check if the SPI is already enabled */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((spiParams.Instance-&gt;CR1 &amp; SPI_CR1_SPE) != SPI_CR1_SPE) { <span class="hljs-comment"><span class="hljs-comment">/* Enable SPI peripheral */</span></span> __HAL_SPI_ENABLE(hspi); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Started SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": BaudRatePrescaler = "</span></span> &lt;&lt; spiParams.Init.BaudRatePrescaler &lt;&lt; <span class="hljs-string"><span class="hljs-string">", DataSize = "</span></span> &lt;&lt; spiParams.Init.DataSize &lt;&lt; <span class="hljs-string"><span class="hljs-string">", CLKPhase = "</span></span> &lt;&lt; spiParams.Init.CLKPhase &lt;&lt; <span class="hljs-string"><span class="hljs-string">", Status = "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } HAL_StatusTypeDef Spi::stop () { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Stopping SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device); HAL_StatusTypeDef retValue = HAL_SPI_DeInit(&amp;spiParams); disableClock(); hspi = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retValue; }</code> </pre> <br><p>  <strong>Trabalhe com a interface de hardware usando interrup√ß√µes</strong> .  A classe implementa uma interface I2S usando um controlador DMA.  O I2S (Inter-IC Sound) √© um complemento de software de hardware para SPI, que, por exemplo, realiza a sele√ß√£o do rel√≥gio e o controle do canal, dependendo do protocolo de √°udio e da taxa de bits. </p><br><p>  Nesse caso, a classe I2S √© herdada da classe ‚Äúport‚Äù, ou seja, I2S √© uma porta com propriedades especiais.  Alguns dados s√£o armazenados em estruturas HAL (mais por conveni√™ncia, menos a quantidade de dados).  Alguns dados s√£o transferidos do c√≥digo principal por links (por exemplo, a estrutura irqPrio). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I2S</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOPort { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type I2S_IRQ = SPI2_IRQn; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type DMA_TX_IRQ = DMA1_Stream4_IRQn; I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> standard, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> audioFreq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataFormat)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transmit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_I2S_Transmit_DMA(&amp;i2s, pData, size); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processI2SInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_I2S_IRQHandler(&amp;i2s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDmaTxInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_DMA_IRQHandler(&amp;i2sDmaTx); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: I2S_HandleTypeDef i2s; DMA_HandleTypeDef i2sDmaTx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; irqPrio; };</code> </pre> <br><p>  Seu construtor define todos os par√¢metros est√°ticos: </p><br><pre> <code class="cpp hljs">I2S::I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio): IOPort{name, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, pin, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, irqPrio{prio} { i2s.Instance = SPI2; i2s.Init.Mode = I2S_MODE_MASTER_TX; i2s.Init.Standard = I2S_STANDARD_PHILIPS; <span class="hljs-comment"><span class="hljs-comment">// will be re-defined at communication start i2s.Init.DataFormat = I2S_DATAFORMAT_16B; // will be re-defined at communication start i2s.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE; i2s.Init.AudioFreq = I2S_AUDIOFREQ_44K; // will be re-defined at communication start i2s.Init.CPOL = I2S_CPOL_LOW; i2s.Init.ClockSource = I2S_CLOCK_PLL; i2s.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE; i2sDmaTx.Instance = DMA1_Stream4; i2sDmaTx.Init.Channel = DMA_CHANNEL_0; i2sDmaTx.Init.Direction = DMA_MEMORY_TO_PERIPH; i2sDmaTx.Init.PeriphInc = DMA_PINC_DISABLE; i2sDmaTx.Init.MemInc = DMA_MINC_ENABLE; i2sDmaTx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD; i2sDmaTx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; i2sDmaTx.Init.Mode = DMA_NORMAL; i2sDmaTx.Init.Priority = DMA_PRIORITY_LOW; i2sDmaTx.Init.FIFOMode = DMA_FIFOMODE_ENABLE; i2sDmaTx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL; i2sDmaTx.Init.MemBurst = DMA_PBURST_SINGLE; i2sDmaTx.Init.PeriphBurst = DMA_PBURST_SINGLE; }</span></span></code> </pre> <br><p>  O in√≠cio da transfer√™ncia de dados √© controlado pelos m√©todos de in√≠cio, respons√°veis ‚Äã‚Äãpela configura√ß√£o dos par√¢metros da porta, cronometrando a interface, definindo interrup√ß√µes, iniciando o DMA, iniciando a pr√≥pria interface com os par√¢metros de transmiss√£o especificados. </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef I2S::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> standard, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> audioFreq, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataFormat) { i2s.Init.Standard = standard; i2s.Init.AudioFreq = audioFreq; i2s.Init.DataFormat = dataFormat; setMode(GPIO_MODE_AF_PP); setAlternate(GPIO_AF5_SPI2); __HAL_RCC_SPI2_CLK_ENABLE(); HAL_StatusTypeDef status = HAL_I2S_Init(&amp;i2s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not start I2S: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } __HAL_RCC_DMA1_CLK_ENABLE(); __HAL_LINKDMA(&amp;i2s, hdmatx, i2sDmaTx); status = HAL_DMA_Init(&amp;i2sDmaTx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize I2S DMA/TX channel: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } HAL_NVIC_SetPriority(I2S_IRQ, irqPrio.first, irqPrio.second); HAL_NVIC_EnableIRQ(I2S_IRQ); HAL_NVIC_SetPriority(DMA_TX_IRQ, irqPrio.first + <span class="hljs-number"><span class="hljs-number">1</span></span>, irqPrio.second); HAL_NVIC_EnableIRQ(DMA_TX_IRQ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_OK; }</code> </pre> <br><p>  O procedimento de parada faz o oposto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I2S::stop () { HAL_NVIC_DisableIRQ(I2S_IRQ); HAL_NVIC_DisableIRQ(DMA_TX_IRQ); HAL_DMA_DeInit(&amp;i2sDmaTx); __HAL_RCC_DMA1_CLK_DISABLE(); HAL_I2S_DeInit(&amp;i2s); __HAL_RCC_SPI2_CLK_DISABLE(); setMode(GPIO_MODE_INPUT); }</code> </pre> <br><p>  Existem v√°rios recursos interessantes aqui: </p><br><ul><li>  As interrup√ß√µes usadas neste caso s√£o definidas como constantes est√°ticas.  Isso √© menos a portabilidade para outros controladores. </li><li>  Essa organiza√ß√£o do c√≥digo garante que os pinos da porta estejam sempre no estado GPIO_MODE_INPUT quando n√£o houver transmiss√£o.  Isto √© uma vantagem. </li><li>  A prioridade de interrup√ß√µes √© transferida de fora, ou seja, existe uma boa oportunidade para definir um mapa de prioridades de interrup√ß√£o em um local do c√≥digo principal.  Isso tamb√©m √© uma vantagem. </li><li>  O procedimento de parada desativa o rel√≥gio do DMA1.  Nesse caso, essa simplifica√ß√£o pode ter consequ√™ncias muito negativas se outra pessoa continuar usando o DMA1.  O problema √© resolvido com a cria√ß√£o de um registro centralizado dos consumidores desses dispositivos, que ser√° respons√°vel pelo rel√≥gio. </li><li>  Outra simplifica√ß√£o - o procedimento de inicializa√ß√£o n√£o leva a interface ao seu estado original em caso de erro (este √© um sinal de menos, mas facilmente corrig√≠vel).  Ao mesmo tempo, os erros s√£o registrados com mais detalhes, o que √© uma vantagem. </li><li>  Ao usar essa classe, o c√≥digo principal deve interceptar as interrup√ß√µes SPI2_IRQn e DMA1_Stream4_IRQn e garantir que os manipuladores processI2SInterrupt e processDmaTxInterrupt correspondentes sejam chamados. </li></ul><br><h3 id="osnovnaya-programma">  Programa principal </h3><br><p>  O programa principal √© escrito usando a biblioteca descrita acima de maneira bastante simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_Init(); <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::A, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::B, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::C, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// System frequency 168MHz System::ClockDiv clkDiv; clkDiv.PLLM = 16; clkDiv.PLLN = 336; clkDiv.PLLP = 2; clkDiv.PLLQ = 7; clkDiv.AHBCLKDivider = RCC_SYSCLK_DIV1; clkDiv.APB1CLKDivider = RCC_HCLK_DIV8; clkDiv.APB2CLKDivider = RCC_HCLK_DIV8; clkDiv.PLLI2SN = 192; clkDiv.PLLI2SR = 2; do { System::setClock(clkDiv, FLASH_LATENCY_3, System::RtcType::RTC_EXT); } while (System::getMcuFreq() != 168000000L); MyApplication app; appPtr = &amp;app; app.run(); }</span></span></code> </pre> <br><p>  Aqui, inicializamos a biblioteca HAL, configuramos todos os pinos do controlador por entrada (GPIO_MODE_INPUT / PULLDOWN) por padr√£o.  Defina a frequ√™ncia do controlador, inicie o rel√≥gio (incluindo um rel√≥gio em tempo real de um quartzo externo).  Depois disso, um pouco no estilo de Java, criamos uma inst√¢ncia de nosso aplicativo e chamamos seu m√©todo run, que implementa toda a l√≥gica do aplicativo. </p><br><p>  Em uma se√ß√£o separada, devemos definir todas as interrup√ß√µes usadas.  Como escrevemos em C ++ e as interrup√ß√µes s√£o coisas do mundo de C, precisamos mascar√°-las de acordo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SysTick_Handler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_IncTick(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (appPtr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { appPtr-&gt;getRtc().onMilliSecondInterrupt(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream3_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaRxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream6_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDIO_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processSdIOInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPI2_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processI2SInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA1_Stream4_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_I2S_TxCpltCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2S_HandleTypeDef *channel)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;processDmaTxCpltCallback(channel); } ... }</code> </pre> <br><p>  A classe MyApplication declara todos os dispositivos usados, chama construtores para todos esses dispositivos e tamb√©m implementa os manipuladores de eventos necess√°rios: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, WavStreamer::EventHandler, Devices::Button::EventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> INPUT_PINS = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Number of monitored input pins private: UsartLogger log; RealTimeClock rtc; IOPin ledGreen, ledBlue, ledRed; PeriodicalEvent heartbeatEvent; IOPin mco; // Interrupt priorities InterruptPriority irqPrioI2S; InterruptPriority irqPrioEsp; InterruptPriority irqPrioSd; InterruptPriority irqPrioRtc; // SD card IOPin pinSdPower, pinSdDetect; IOPort portSd1, portSd2; SdCard sdCard; bool sdCardInserted; // Configuration Config config; // ESP Esp11 esp; EspSender espSender; // Input pins std::array&lt;IOPin, INPUT_PINS&gt; pins; std::array&lt;bool, INPUT_PINS&gt; pinsState; // I2S2 Audio I2S i2s; AudioDac_UDA1334 audioDac; WavStreamer streamer; Devices::Button playButton; ...</span></span></code> </pre> <br><p>  Na verdade, todos os dispositivos usados ‚Äã‚Äãs√£o declarados estaticamente, o que potencialmente leva a um aumento na mem√≥ria usada, mas simplifica bastante o acesso aos dados.  No construtor da classe MyApplication, √© necess√°rio chamar os projetistas de todos os dispositivos, ap√≥s os quais, quando o procedimento de execu√ß√£o for iniciado, todos os dispositivos de microcontroladores usados ‚Äã‚Äãser√£o inicializados: </p><br><pre> <code class="cpp hljs"> MyApplication::MyApplication () : <span class="hljs-comment"><span class="hljs-comment">// logging log(Usart::USART_1, IOPort::B, GPIO_PIN_6, GPIO_PIN_7, 115200), // RTC rtc(), ledGreen(IOPort::C, GPIO_PIN_1, GPIO_MODE_OUTPUT_PP), ledBlue(IOPort::C, GPIO_PIN_2, GPIO_MODE_OUTPUT_PP), ledRed(IOPort::C, GPIO_PIN_3, GPIO_MODE_OUTPUT_PP), heartbeatEvent(rtc, 10, 2), mco(IOPort::A, GPIO_PIN_8, GPIO_MODE_AF_PP), // Interrupt priorities irqPrioI2S(6, 0), // I2S DMA interrupt priority: 7 will be also used irqPrioEsp(5, 0), irqPrioSd(3, 0), // SD DMA interrupt priority: 4 will be also used irqPrioRtc(2, 0), // SD card pinSdPower(IOPort::A, GPIO_PIN_15, GPIO_MODE_OUTPUT_PP, GPIO_PULLDOWN, GPIO_SPEED_HIGH, true, false), pinSdDetect(IOPort::B, GPIO_PIN_3, GPIO_MODE_INPUT, GPIO_PULLUP), portSd1(IOPort::C, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12, /* callInit = */false), portSd2(IOPort::D, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_2, /* callInit = */false), sdCard(pinSdDetect, portSd1, portSd2), sdCardInserted(false), // Configuration config(pinSdPower, sdCard, "conf.txt"), //ESP esp(rtc, Usart::USART_2, IOPort::A, GPIO_PIN_2, GPIO_PIN_3, irqPrioEsp, IOPort::A, GPIO_PIN_1), espSender(rtc, esp, ledRed), // Input pins pins { { IOPin(IOPort::A, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_6, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_7, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_0, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_1, GPIO_MODE_INPUT, GPIO_PULLUP) } }, // I2S2 Audio Configuration // PB10 --&gt; I2S2_CK // PB12 --&gt; I2S2_WS // PB15 --&gt; I2S2_SD i2s(IOPort::B, GPIO_PIN_10 | GPIO_PIN_12 | GPIO_PIN_15, irqPrioI2S), audioDac(i2s, /* power = */ IOPort::B, GPIO_PIN_11, /* mute = */ IOPort::B, GPIO_PIN_13, /* smplFreq = */ IOPort::B, GPIO_PIN_14), streamer(sdCard, audioDac), playButton(IOPort::B, GPIO_PIN_2, GPIO_PULLUP, rtc) { mco.activateClockOutput(RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_5); }</span></span></code> </pre> <br><p>  Como exemplo, o manipulador de eventos para clicar em um bot√£o que inicia / para a reprodu√ß√£o de um arquivo WAV: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::onButtonPressed (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Devices::Button * b, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == &amp;playButton) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"play button pressed: "</span></span> &lt;&lt; numOccured); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (streamer.isActive()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Stopping WAV"</span></span>); streamer.stop(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Starting WAV"</span></span>); streamer.start(AudioDac_UDA1334::SourceType:: STREAM, config.getWavFile()); } } }</code> </pre> <br><p>  E, finalmente, o m√©todo principal de execu√ß√£o conclui a configura√ß√£o dos dispositivos (por exemplo, define MyApplication como manipulador de eventos) e inicia um loop infinito, onde se refere periodicamente aos dispositivos que requerem aten√ß√£o peri√≥dica: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::run () { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.initInstance(); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Oscillator frequency: "</span></span> &lt;&lt; System::getExternalOscillatorFreq() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", MCU frequency: "</span></span> &lt;&lt; System::getMcuFreq()); HAL_StatusTypeDef status = HAL_TIMEOUT; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { status = rtc.start(<span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">2047</span></span> + <span class="hljs-number"><span class="hljs-number">7</span></span>, RTC_WAKEUPCLOCK_RTCCLK_DIV2, irqPrioRtc, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"RTC start status: "</span></span> &lt;&lt; status); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (status != HAL_OK); sdCard.setIrqPrio(irqPrioSd); sdCard.initInstance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sdCard.isCardInserted()) { updateSdCardState(); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins: "</span></span> &lt;&lt; pins.size()); pinsState.fill(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Pin state: "</span></span> &lt;&lt; fillMessage()); esp.assignSendLed(&amp;ledGreen); streamer.stop(); streamer.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); streamer.setVolume(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); playButton.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { updateSdCardState(); playButton.periodic(); streamer.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInputPinsChanged()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins change detected"</span></span>); ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); reportState = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } espSender.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (espSender.isOutputMessageSent()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reportState) { espSender.sendMessage(config, <span class="hljs-string"><span class="hljs-string">"TCP"</span></span>, config.getServerIp(), config.getServerPort(), fillMessage()); reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!reportState) { ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heartbeatEvent.isOccured()) { ledGreen.putBit(heartbeatEvent.occurance() == <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> <br><h3 id="nemnogo-eksperimentov">  Um pouco de experimenta√ß√£o </h3><br><p>   ‚Äî    .    ‚Äî 168 MHz. ,   ,      172 MHz   180 MHz,          ,      ,         MCO.     ,   USART  I2S, ,  ,      HAL. </p><br><h2 id="cena">  </h2><br><p>        .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://htmlpreview.github.io/%3F">github</a>     .    - ,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mouser</a> (   ).     37      .            .  ,        STM  Olimex,      . </p><br><h2 id="problemy-i-perspektivy">    </h2><br><p>        .       ,   : </p><br><ul><li>        (   ).  ,       ,            .       :     4  8 .        PLL,         . </li><li>    ,       .      47 ŒºF  . ,    . </li><li>   SWD      .    -  ,     .     . </li><li>     .     SMD ,    .       3       . </li></ul><br><h2 id="dokumentaciya">  A documenta√ß√£o </h2><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a>   GPL v3: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://docs.google.com/viewer%3Furl%3D"></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://docs.google.com/viewer%3Furl%3D"></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://htmlpreview.github.io/%3F"> </a> </li></ul><br><p>  Obrigado pela aten√ß√£o! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413101/">https://habr.com/ru/post/pt413101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413091/index.html">Registro conveniente no SpringBoot + Log4j2 + Maven</a></li>
<li><a href="../pt413093/index.html">Antecipando a corrida dos comerciantes espaciais nos Estados Unidos e na China</a></li>
<li><a href="../pt413095/index.html">Aplica√ß√£o de tecnologias de rede neural: desenvolvimento de software</a></li>
<li><a href="../pt413097/index.html">Baseado em software de n√≠vel empresarial, testado milh√µes de vezes: lan√ßado o openSUSE Leap 15</a></li>
<li><a href="../pt413099/index.html">RAM para downclocking no macbook</a></li>
<li><a href="../pt413103/index.html">Lan√ßamento do 3CX v15.5 Update 5 Beta e REST com AmoCRM</a></li>
<li><a href="../pt413105/index.html">Notas do provedor de IoT. Ativa√ß√£o e seguran√ßa no LoraWAN</a></li>
<li><a href="../pt413107/index.html">Tradu√ß√£o do wiki do projeto Svelto.ECS. Estrutura do ECS para Unity3D</a></li>
<li><a href="../pt413109/index.html">Como criar uma plataforma de integra√ß√£o de produtos SaaS: experi√™ncia de checkout na nuvem de p√¥steres</a></li>
<li><a href="../pt413111/index.html">STM32 + NetBeans =?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>