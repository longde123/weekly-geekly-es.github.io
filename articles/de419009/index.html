<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüè´ üï¢ üë©‚Äçüè≠ Clang und IDE: Eine Geschichte √ºber Freundschaft und Freundschaft üíá üç∏ ‚ò¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="F√ºr mich begann es vor sechseinhalb Jahren, als ich durch den Willen des Schicksals in ein geschlossenes Projekt hineingezogen wurde. Wessen Projekt -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clang und IDE: Eine Geschichte √ºber Freundschaft und Freundschaft</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419009/"><p><img src="https://habrastorage.org/webt/yi/u_/xb/yiu_xbaeyduzvwqklgpu5xujgvo.png" align="left">  F√ºr mich begann es vor sechseinhalb Jahren, als ich durch den Willen des Schicksals in ein geschlossenes Projekt hineingezogen wurde.  Wessen Projekt - nicht fragen, werde ich nicht sagen.  Ich kann nur sagen, dass seine Idee als Rechen einfach war: Einbetten des klirrenden Frontends in die IDE.  Nun, wie k√ºrzlich in QtCreator, in CLion (in gewissem Sinne) usw. getan. Clang war damals ein aufgehender Stern, viele trotteten √ºber die M√∂glichkeit nach, den vollwertigen C ++ - Parser fast kostenlos zu nutzen.  Und die Idee, sozusagen, schwebte buchst√§blich in der Luft (und die automatische Vervollst√§ndigung des Codes, der in die Clang-API eingebaut war, wie es angedeutet wurde), musste man einfach nehmen und tun.  Aber wie Boromir sagte: "Du kannst es nicht einfach nehmen und ...".  So geschah es in diesem Fall.  F√ºr Details - Willkommen unter Katze. </p><a name="habracut"></a><br><h2 id="snachala-o-horoshem">  Zuerst √ºber gut </h2><br><p>  Die Verwendung von clang als integrierter Parser in IDE C ++ bietet nat√ºrlich folgende Vorteile.  Letztendlich beschr√§nken sich die IDE-Funktionen nicht nur auf das Bearbeiten von Dateien.  Dies ist eine Datenbank mit Zeichen, Navigationsaufgaben, Abh√§ngigkeiten und vielem mehr.  Und hier steuert ein vollwertiger Compiler seine volle H√∂he, denn die gesamte Leistung des Pr√§prozessors und der Vorlagen in einem relativ einfachen selbstgeschriebenen Parser zu √ºberw√§ltigen, ist keine triviale Aufgabe.  Weil Sie normalerweise viele Kompromisse eingehen m√ºssen, was sich offensichtlich auf die Qualit√§t der Code-Analyse auswirkt.  Wen k√ºmmert es - sehen Sie sich beispielsweise den integrierten Parser des QtCeator an: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt Creator C ++ - Parser</a> </p><br><p>  An derselben Stelle im Quellcode von QtCreator k√∂nnen Sie sehen, dass das Obige nicht alles ist, was die IDE vom Parser ben√∂tigt.  Dar√ºber hinaus ben√∂tigen Sie mindestens: </p><br><ul><li>  Syntaxhervorhebung (lexikalisch und semantisch) </li><li>  alle m√∂glichen Hinweise "on the fly" mit der Anzeige von Informationen auf dem Symbol </li><li>  Hinweise, was mit dem Code nicht stimmt und wie man ihn repariert / erg√§nzt </li><li>  Code-Vervollst√§ndigung in einer Vielzahl von Kontexten </li><li>  das vielf√§ltigste Refactoring </li></ul><br><p>  Daher enden bei den zuvor aufgef√ºhrten Vorteilen (wirklich ernst!) Die Pluspunkte und der Schmerz beginnt.  Um diesen Schmerz besser zu verstehen, k√∂nnen Sie zun√§chst den Bericht von Anastasia Kazakova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">anastasiak2512</a> ) √ºber die tats√§chlichen Anforderungen des in die IDE integrierten Code-Parsers betrachten: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4giOynD7Emg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="sut-problemy">  Das Wesentliche des Problems </h2><br><p>  Aber es ist einfach, obwohl es auf den ersten Blick nicht offensichtlich ist.  Kurz gesagt: clang ist ein <em>Compiler</em> .  Und bezeichnet den Code als <em>Compiler</em> .  Und gesch√§rft durch die Tatsache, dass ihm der Code bereits ausgef√ºllt gegeben wird, und nicht durch den Stub der Datei, die jetzt im IDE-Editor ge√∂ffnet ist.  Compiler m√∂gen keine <strong>Dateibits</strong> wie unvollst√§ndige Konstruktionen, falsch geschriebene Bezeichner, <strong>erneutes Ausf√ºhren</strong> statt <strong>Zur√ºckgeben</strong> und andere Freuden, die hier und jetzt im Editor auftreten k√∂nnen.  Nat√ºrlich wird dies alles vor der Kompilierung aufger√§umt, repariert und in Einklang gebracht.  Aber hier und jetzt, im Editor, ist es das, was es ist.  In dieser Form gelangt der in die IDE integrierte Parser alle 5-10 Sekunden an die Tabelle.  Und wenn die selbstgeschriebene Version davon perfekt "versteht", dass es sich um ein halbfertiges Produkt handelt, dann klingelt - nein.  Und sehr √ºberrascht.  Was als Ergebnis einer solchen √úberraschung passiert, h√§ngt, wie man sagt, "von" ab. </p><br><p>  Gl√ºcklicherweise ist Clang ziemlich tolerant gegen√ºber Codefehlern.  Trotzdem kann es √úberraschungen geben - pl√∂tzlich verschwindende Hintergrundbeleuchtung, automatisch vervollst√§ndigte Kurve, seltsame Diagnose.  Sie m√ºssen auf all das vorbereitet sein.  Dar√ºber hinaus ist Clang nicht alles fressend.  Er hat das Recht, nichts in den Headern des Compilers zu akzeptieren, der hier und jetzt zum Erstellen des Projekts verwendet wird.  Tricky Intrinsics, nicht standardm√§√üige Erweiterungen und andere, √§hm ... Funktionen - all dies kann an den unerwartetsten Stellen zu Analysefehlern f√ºhren.  Und nat√ºrlich Leistung.  Das Bearbeiten einer Grammatikdatei auf Boost.Spirit oder das Arbeiten an einem llvm-basierten Projekt wird ein Vergn√ºgen sein.  Aber √ºber alles im Detail. </p><br><h2 id="kod-polufabrikat">  Vorgefertigter Code </h2><br><p>  Angenommen, Sie haben ein neues Projekt gestartet.  Ihre Umgebung hat ein Standard-Leerzeichen f√ºr main.cpp generiert, und Sie haben Folgendes geschrieben: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { foo(10) }</span></span></span></span></code> </pre> <br><p>  Der Code ist aus Sicht von C ++ offen gesagt ung√ºltig.  Es gibt keine Definition der Funktion foo (...) in der Datei, die Zeile ist nicht vollst√§ndig usw. Aber ... Sie haben gerade erst begonnen.  Dieser Code hat das Recht auf diesen Typ.  Wie nimmt dieser Code eine IDE mit einem selbstgeschriebenen Parser (in diesem Fall CLion) wahr? </p><br><p><img src="https://habrastorage.org/webt/us/8y/ni/us8yni2bzf5zpm6epgx_uh7m4bs.png"></p><br><p>  Und wenn Sie auf die Gl√ºhbirne klicken, k√∂nnen Sie Folgendes sehen: </p><br><p><img src="https://habrastorage.org/webt/p2/ej/h4/p2ejh4woiuojsq19oq90rmozhrm.png"></p><br><p>  Eine solche IDE, die etwas wei√ü, √§hm, mehr √ºber das Geschehen, bietet die sehr erwartete Option: eine Funktion aus dem Nutzungskontext zu erstellen.  Tolles Angebot, denke ich.  Wie verh√§lt sich die klirrbasierte IDE (in diesem Fall Qt Creator 4.7)? </p><br><p><img src="https://habrastorage.org/webt/ql/pa/hj/qlpahj0vu5of_my6s1ymrelsa3o.png"></p><br><p>  Und was wird vorgeschlagen, um die Situation zu korrigieren?  Aber nichts!  Nur Standard umbenennen! </p><br><p><img src="https://habrastorage.org/webt/kk/0m/pt/kk0mptuuwnufqjugzumnoisnyms.png"></p><br><p>  Der Grund f√ºr dieses Verhalten ist sehr einfach: F√ºr Clang ist dieser Text vollst√§ndig (und es kann nichts anderes sein).  Und er baut den AST auf dieser Annahme auf.  Und dann ist alles einfach: clang sieht eine zuvor undefinierte Kennung.  Dies ist Text in C ++ (nicht in C).  Es werden keine Annahmen √ºber die Art des Bezeichners getroffen - er ist nicht definiert, daher ist ein Code ung√ºltig.  Und in AST f√ºr diese Zeile erscheint nichts.  Sie ist einfach nicht da.  Und was nicht in AST ist, ist unm√∂glich zu analysieren.  Es ist eine Schande, nervig, okay. </p><br><p>  Der in die IDE integrierte Parser basiert auf einigen anderen Annahmen.  Er <em>wei√ü,</em> dass der Code nicht fertig ist.  Dass der Programmierer gerade Gedanken macht und die Finger hinter ihr keine Zeit haben.  Daher k√∂nnen nicht alle Bezeichner definiert werden.  Ein solcher Code ist nat√ºrlich unter dem Gesichtspunkt hoher Standards f√ºr die Compilerqualit√§t falsch, aber der Parser wei√ü, was mit einem solchen Code getan werden kann, und bietet Optionen an.  Ganz vern√ºnftige M√∂glichkeiten. </p><br><p>  Zumindest bis Version 3.7 (einschlie√ülich) traten in diesem Code √§hnliche Probleme auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class Temp { public: int i; }; template&lt;typename T&gt; class Foo { public: int Bar(Temp tmp) { Tpl(tmp); } private: template&lt;typename U&gt; void Tpl(U val) { Foo&lt;U&gt; tmp(val); tmp. } int member; }; int main() { return 0; }</span></span></span></span></code> </pre> <br><p>  Innerhalb der Template-Klassenmethoden funktionierte das Clang-basierte Autocomplet nicht.  Soweit ich es herausfinden konnte, lag der Grund in der Analyse von Vorlagen in zwei Durchg√§ngen.  Die automatische Vervollst√§ndigung in Clang wird beim ersten Durchgang ausgel√∂st, wenn Informationen zu den tats√§chlich verwendeten Typen m√∂glicherweise nicht ausreichen.  In Clang 5.0 (nach Release Notes zu urteilen) wurde dies behoben. </p><br><p>  Auf die eine oder andere Weise k√∂nnen Situationen auftreten, in denen der Compiler nicht in der Lage ist, den richtigen AST im bearbeiteten Code zu erstellen (oder die richtigen Schlussfolgerungen aus dem Kontext zu ziehen).  In diesem Fall "sieht" die IDE die entsprechenden Textabschnitte einfach nicht und kann dem Programmierer in keiner Weise helfen.  Was nat√ºrlich nicht so toll ist.  Die F√§higkeit, effektiv mit falschem Code zu arbeiten, ist das, was der Parser in der IDE ben√∂tigt und was der regul√§re Compiler √ºberhaupt nicht ben√∂tigt.  Daher kann der Parser in der IDE viele Heuristiken verwenden, die f√ºr den Compiler nicht nur nutzlos, sondern auch sch√§dlich sein k√∂nnen.  Und um zwei Betriebsmodi zu implementieren, m√ºssen Sie die Entwickler noch √ºberzeugen. </p><br><h2 id="eta-rol---rugatelnaya">  "Diese Rolle ist missbr√§uchlich!" </h2><br><p>  Die IDE des Programmierers ist normalerweise eine (also zwei), aber es gibt viele Projekte und Toolchains.  Und nat√ºrlich m√∂chte ich keine zus√§tzlichen Gesten ausf√ºhren, um von Toolchain zu Toolchain, von Projekt zu Projekt, zu wechseln.  Ein oder zwei Klicks, und die Build-Konfiguration √§ndert sich von Debug zu Release und der Compiler von MSVC zu MinGW.  Der Code-Parser in der IDE bleibt jedoch unver√§ndert.  Und er muss zusammen mit dem Build-System von einer Konfiguration zur anderen wechseln, von einer Toolchain zur anderen.  Eine Toolchain kann eine Art Exotik oder Kreuz sein.  Und die Aufgabe des Parsers hier ist es, den Code weiterhin korrekt zu analysieren.  Wenn m√∂glich mit einem Minimum an Fehlern. </p><br><p>  Clang ist Allesfresser genug.  Es kann gezwungen werden, Compiler-Erweiterungen von Microsoft, dem gcc-Compiler, zu akzeptieren.  Es k√∂nnen Optionen im Format dieser Compiler √ºbergeben werden, und Clang wird sie sogar verstehen.  All dies garantiert jedoch nicht, dass Clang eine √úberschrift von den Innereien akzeptiert, die aus dem GCC-Tank gesammelt wurden.  Jeder __builtin_intrinsic_xxx kann f√ºr ihn zum Stolperstein werden.  Oder Sprachkonstrukte, die die aktuelle Version von clang in der IDE einfach nicht unterst√ºtzt.  Dies hat h√∂chstwahrscheinlich keinen Einfluss auf die Qualit√§t der AST-Konstruktion f√ºr die aktuell bearbeitete Datei.  Das Erstellen einer globalen Zeichenbasis oder das Speichern vorkompilierter Header kann jedoch zu Problemen f√ºhren.  Und das kann ein ernstes Problem sein.  Ein √§hnliches Problem k√∂nnte sich als √§hnlicher Code herausstellen, nicht in den Kopfzeilen von Toolchains oder von Drittanbietern, sondern in den Kopfzeilen oder Quellcodes des Projekts.  √úbrigens ist all dies ein wichtiger Grund, dem Build-System (und der IDE) explizit mitzuteilen, welche Header-Dateien f√ºr Ihr Projekt "fremd" sind.  Es kann das Leben leichter machen. </p><br><p>  Auch hier wurde die IDE urspr√ºnglich f√ºr die Verwendung mit verschiedenen Compilern, Einstellungen, Toolchains und mehr entwickelt.  Entwickelt, um mit Code umgehen zu m√ºssen, von dem einige Elemente nicht unterst√ºtzt werden.  Der Release-Zyklus der IDE (nicht alle :) ist k√ºrzer als der von Compilern. Daher besteht das Potenzial, neue Funktionen schneller aufzurufen und auf festgestellte Probleme zu reagieren.  In der Welt der Compiler ist alles etwas anders: Der Release-Zyklus betr√§gt mindestens ein Jahr, die Probleme der Cross-Compiler-Kompatibilit√§t werden durch bedingte Kompilierung gel√∂st und auf die Schultern des Entwicklers √ºbertragen.  Der Compiler muss nicht universell und Allesfresser sein - seine Komplexit√§t ist bereits hoch.  Klirren ist keine Ausnahme. </p><br><h2 id="borba-za-skorost">  Der Kampf um Geschwindigkeit </h2><br><p>  In dem Teil der Zeit, die der Programmierer in der IDE verbringt, wenn er nicht im Debugger sitzt, bearbeitet er den Text.  Und sein nat√ºrlicher Wunsch ist es, es bequem zu machen (sonst warum eine IDE? Kann ich mit einem Notizblock auskommen!). Komfort beinhaltet insbesondere die hohe Reaktionsgeschwindigkeit des Editors auf Text√§nderungen und das Dr√ºcken von Hotkeys.  Wie Anastasia in ihrem Bericht richtig feststellte, ist dies schrecklich, wenn die Umgebung f√ºnf Sekunden nach dem Dr√ºcken von Strg + Leertaste nicht mit dem Erscheinen eines Men√ºs oder einer Liste der automatischen Vervollst√§ndigung reagiert hat (im Ernst, versuchen Sie es selbst).  In Zahlen bedeutet dies, dass der in die IDE integrierte Parser etwa eine Sekunde Zeit hat, um die √Ñnderungen in der Datei auszuwerten und den AST neu zu erstellen, und eineinhalb oder zwei, um dem Entwickler eine kontextsensitive Auswahl zu bieten.  Zweitens.  Na ja, vielleicht zwei.  Au√üerdem wird erwartet, dass die vorgenommenen √Ñnderungen "sichtbar" sind, wenn der Entwickler den .h-Spitznamen √§ndert und dann auf .cpp-shnik wechselt.  Die Dateien, hier sind sie, werden in den benachbarten Fenstern ge√∂ffnet.  Und jetzt eine einfache Berechnung.  Wenn Clang, das √ºber die Befehlszeile gestartet wird, den Quellcode in etwa zehn bis zwanzig Sekunden verarbeiten kann, wo ist dann der Grund zu der Annahme, dass es beim Starten √ºber die IDE den Quellcode viel schneller verarbeitet und in diese ein oder zwei Sekunden passt?  Das hei√üt, es wird eine Gr√∂√üenordnung schneller arbeiten?  Im Allgemeinen k√∂nnte dies beendet werden, aber ich werde nicht. </p><br><p>  Etwa zehn bis zwanzig Sekunden bis zur Quelle √ºbertreibe ich nat√ºrlich.  Wenn dort eine schwere API enthalten ist oder beispielsweise boost.spirit mit Hana bereitsteht und all dies aktiv im Text verwendet wird, sind 10 bis 20 Sekunden immer noch gute Werte.  Aber selbst wenn der AST Sekunden nach drei oder vier nach dem Start des integrierten Parsers bereit ist, ist es schon lange her.  Vorausgesetzt, dass solche Starts so regelm√§√üig (um das Codemodell und den Index in einem konsistenten Zustand zu halten, hervorzuheben, aufzufordern usw.) sowie bei Bedarf erfolgen - Code-Vervollst√§ndigung ist auch der Start des Compilers.  Ist es m√∂glich, diese Zeit irgendwie zu verk√ºrzen?  Leider gibt es bei der Verwendung von clang als Parser nicht viele M√∂glichkeiten.  Grund: Dies ist ein Tool eines Drittanbieters, bei dem (im <em>Idealfall</em> ) keine √Ñnderungen vorgenommen werden k√∂nnen.  Das hei√üt, mit perftool in den Clang-Code eintauchen, einige Zweige optimieren, vereinfachen - diese Funktionen sind nicht verf√ºgbar und Sie haben mit dem zu tun, was die externe API bietet (im Fall der Verwendung von libclang ist sie auch ziemlich eng). </p><br><p>  Die erste, offensichtliche und tats√§chlich einzige L√∂sung besteht darin, dynamisch generierte vorkompilierte Header zu verwenden.  Bei angemessener Implementierung ist die L√∂sung ein Killer.  Erh√∂ht die Kompilierungsgeschwindigkeit zumindest zeitweise.  Das Wesentliche ist einfach: Die Umgebung sammelt alle Header von Drittanbietern (oder Header au√üerhalb des Projektstamms) in einer einzigen .h-Datei, erstellt pch aus dieser Datei und schlie√üt diese pch dann implizit in jede Quelle ein.  Nat√ºrlich tritt ein offensichtlicher Nebeneffekt auf: Im Quellcode ( <em>in der Bearbeitungsphase</em> ) sind Symbole zu sehen, die nicht darin enthalten sind.  Dies ist jedoch eine Geb√ºhr f√ºr die Geschwindigkeit.  Ich muss w√§hlen.  Und alles w√§re in Ordnung, wenn nicht ein kleines Problem w√§re: clang ist immer noch ein Compiler.  Und als Compiler mag er keine Fehler im Code.  Und wenn pl√∂tzlich (pl√∂tzlich! - siehe vorherigen Abschnitt) Fehler in den Headern auftreten, wird die .pch-Datei nicht erstellt.  Zumindest war es bis zur Version 3.7.  Hat sich seitdem etwas ge√§ndert?  Ich wei√ü nicht, es besteht der Verdacht, dass nein.  Leider gibt es keine M√∂glichkeit mehr zu √ºberpr√ºfen. </p><br><p>  Leider sind alternative Optionen aus demselben Grund nicht verf√ºgbar: clang ist ein Compiler und eine Sache f√ºr sich.  Aktiv in den AST-Generierungsprozess eingreifen, AST aus verschiedenen Teilen zusammenf√ºhren, externe Symbolbasen beibehalten und leider alle diese Funktionen sind nicht verf√ºgbar.  Nur externe API, nur Hardcore und Einstellungen √ºber Kompilierungsoptionen verf√ºgbar.  Und dann Analyse des resultierenden AST.  Wenn Sie auf der C ++ - Version der API sitzen, stehen Ihnen etwas mehr M√∂glichkeiten zur Verf√ºgung.  Sie k√∂nnen beispielsweise mit benutzerdefinierten FrontendActions herumspielen, feinere Einstellungen f√ºr Kompilierungsoptionen vornehmen usw. In diesem Fall √§ndert sich der Hauptpunkt jedoch nicht - der bearbeitete (oder indizierte) Text wird unabh√§ngig von den anderen und vollst√§ndig kompiliert.  Das ist alles.  Der Punkt. </p><br><p>  Vielleicht (vielleicht!) Wird es eines Tages eine Gabel des Upstream-Clangs geben, die speziell f√ºr die Verwendung als Teil der IDE zugeschnitten ist.  M√∂glicherweise.  Aber im Moment ist alles so wie es ist.  Angenommen, die Integration des Teams von Qt Creator (bis zur "letzten" Phase) in libclang hat sieben Jahre gedauert.  Ich habe QtC 4.7 mit einer libclang-basierten Engine ausprobiert - ich gebe zu, ich pers√∂nlich mag die alte Version (auf der selbstgeschriebenen) einfacher, weil sie in meinen F√§llen besser funktioniert: Sie fordert und hebt hervor und alles andere.  Ich werde mich nicht verpflichten zu sch√§tzen, wie viele menschliche Stunden sie f√ºr diese Integration aufgewendet haben, aber ich wage vorzuschlagen, dass es in dieser Zeit m√∂glich sein w√ºrde, meinen eigenen Parser fertigzustellen.  Soweit ich das beurteilen kann (anhand indirekter Angaben), blickt das an CLion arbeitende Team vorsichtig auf die Integration mit libclang / clang ++ hin.  Dies sind jedoch rein pers√∂nliche Annahmen.  Die Integration auf der Ebene des Language Server-Protokolls ist eine interessante Option, aber speziell f√ºr den C ++ - Fall halte ich dies aus den oben genannten Gr√ºnden eher als Palliativ.  Es √ºbertr√§gt einfach Probleme von einer Abstraktionsebene auf eine andere.  Aber vielleicht verwechsle ich mich mit dem LSP - der Zukunft.  Mal sehen.  Trotzdem ist das Leben der Entwickler moderner IDEs f√ºr C ++ voller Abenteuer - mit Clang als Backend oder ohne. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419009/">https://habr.com/ru/post/de419009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418999/index.html">[Ank√ºndigung, Peter] JUG.ru-Treffen mit Andrei Belyaev und Alexei Stukalov - Troll unterdr√ºckt KUBA: FAQ</a></li>
<li><a href="../de419001/index.html">5 ‚ÄûSuper Skills‚Äú, die f√ºr die Arbeit der Zukunft notwendig sind</a></li>
<li><a href="../de419003/index.html">Blockchain News Digest</a></li>
<li><a href="../de419005/index.html">Ausflug zum Umspannwerk 220/110/20</a></li>
<li><a href="../de419007/index.html">Texturen f√ºr 64k Intro: wie es heute gemacht wird</a></li>
<li><a href="../de419011/index.html">Jinja2 in der C ++ - Welt, Teil zwei. Rendern</a></li>
<li><a href="../de419013/index.html">Trichterbasierte Zuordnung f√ºr SaaS-B2B-Unternehmen - da wir den Wert aller Marketingbem√ºhungen ber√ºcksichtigt haben</a></li>
<li><a href="../de419017/index.html">Was ist neu in ConstraintLayout 1.1?</a></li>
<li><a href="../de419019/index.html">AlterEgo: Ein Ger√§t, das (einige) Gedanken lesen kann</a></li>
<li><a href="../de419021/index.html">Die wichtigsten Druckarten und ihre Funktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>