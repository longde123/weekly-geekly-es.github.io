<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö† üë©‚Äçüî¨ ü¶ë C√≥mo restaurar videos para Full Throttle Remastered. Parte 2 üßú üßôüèª ü§ûüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mi publicaci√≥n anterior , habl√© sobre c√≥mo extrajimos el contenido de los archivos FMV de origen y creamos herramientas para analizar aproximadamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo restaurar videos para Full Throttle Remastered. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422367/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1de/374/14c/1de37414cbdd0d9728e11244fd636b5f.png" alt="imagen"></div><br>  En mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> habl√© sobre c√≥mo extrajimos el contenido de los archivos FMV de origen y creamos herramientas para analizar aproximadamente 67 GB de archivos en busca de componentes intermedios utilizados para crear FMV.  Estas partes son la base para crear contenido FMV remasterizado y se usaron como "dibujos de ensamblaje" para comenzar el proyecto. <br><br>  Como se indic√≥ en el art√≠culo anterior, el flujo de trabajo de remasterizaci√≥n se divide en tres ramas: remasterizaci√≥n de cuadros dibujados a mano, remasterizaci√≥n de modelos 3D y remasterizaci√≥n de sonido.  A continuaci√≥n, hablar√© sobre las caracter√≠sticas del flujo de trabajo y los trucos que utilizamos para automatizar la creaci√≥n de la parte principal del video. <br><a name="habracut"></a><br>  Aumentamos el tama√±o de todos los cuadros dibujados a mano originales para que coincida con la resoluci√≥n de 4K (3840x2160).  Teniendo en cuenta la adici√≥n del ancho de la escena renovada y el hecho de que el juego se mostraba en p√≠xeles no cuadrados, esto significaba que todos los recursos remasterizados ten√≠an que crearse en una resoluci√≥n de 4440x2400 p√≠xeles. <br><br>  Decidimos usar Adobe Animate para remasterizar todos los cuadros FMV dibujados a mano, porque ya ten√≠amos un flujo de trabajo listo despu√©s de desarrollar Day of the Tentacle Remastered.  El equipo de artistas domin√≥ bien este proceso, por lo que no consideramos otras opciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/b57/098/3e2b57098e68ff84ee833c7b56a3ad35.gif"></div><br>  <em>Ejemplo de remasterizaci√≥n de un marco dibujado a mano</em> <br><br>  Los modelos 3D originales de los archivos estaban en 3D Studio Release 3. Afortunadamente, las versiones modernas de 3D Studio Max pudieron importar todos los datos de las mallas y los fotogramas clave cinem√°ticos utilizando otro script de automatizaci√≥n.  Despu√©s de eso, convertimos este archivo intermedio para trabajar en Autodesk Maya, donde los artistas hacen su magia de remasterizaci√≥n. <br><br>  Para dar un nuevo estilo a las superficies de las mallas, se aplicaron nuevos sombreadores, se aplicaron texturas de alta calidad, y estas mallas se complementaron significativamente para darle al modelo un aspecto m√°s suave.  Adem√°s, la ventana de marco se expandi√≥ para que todas las c√°maras de entrada de video correspondieran a la resoluci√≥n de trabajo de 4440x2400 p√≠xeles, porque la c√°mara original fue dise√±ada para una relaci√≥n de aspecto m√°s estrecha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df9/949/7bd/df99497bdfb6c540ef07e330cb9142b8.gif"></div><br>  <em>Ejemplo de remasterizaci√≥n de modelos 3D</em> <br><br>  En cuanto al audio, logramos encontrar la mayor√≠a de las versiones originales de alta calidad, pero hubo excepciones.  Las grabaciones del estudio de doblaje en ingl√©s se archivaron en archivos, pero el doblaje en otros idiomas, que fueron contratados por socios externos, no estaba disponible para nosotros.  Adem√°s, logramos encontrar la m√∫sica original de The Gone Jackals, que se utiliz√≥ en FMV.  Algunas versiones de efectos de sonido (SFX) se han reemplazado por un sonido m√°s "ajustado" con un tipo de sonido similar. <br><br>  A continuaci√≥n se muestra un diagrama de flujo que explica aproximadamente c√≥mo procesamos los recursos fuente y los vinculamos al contenido remasterizado.  Los fotogramas de video originales extra√≠dos (usando SanExtract.exe) se usaron como una "fuente" para la comparaci√≥n con todos los archivos de datos de archivo.  Los archivos de manifiesto de archivo se generan mediante una b√∫squeda recursiva de todos los datos de archivo;  se utilizaron para encontrar r√°pidamente todos los archivos √∫nicos de cierto tipo. <br><br>  La herramienta SanWrangler se utiliz√≥ para comparar visualmente la "fuente" original de marcos y datos archivados.  El usuario puede adjuntar visualmente archivos de almacenamiento a los marcos originales y guardarlos como un mapa de dependencia en formato XML.  Despu√©s de crear el mapa de dependencia, fue suficiente usar un script de Python para generar autom√°ticamente cuadros dibujados manualmente a partir de los recursos originales del archivo de "dibujo", as√≠ como tambi√©n "dibujos de ensamblaje" para Maya 3D.  Estos archivos se convirtieron en el punto de partida para el equipo de artistas, que luego procedi√≥ a la remasterizaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/fa0/30a/c2dfa030a1899e9fb679ebd17caf1ee2.png"></div><br>  <em>Extraer recursos originales y crear "dibujos de ensamblaje"</em> <br><br>  Este fue el primero de muchos pasos que dieron como resultado que obtuvi√©ramos versiones remasterizadas FMV listas para usar.  S√≠, por supuesto, ahora tenemos el punto de partida de todos los archivos que deben rehacerse, pero ¬øc√≥mo conectar todos estos fragmentos? <br><br>  A continuaci√≥n hablar√© sobre los m√©todos de automatizaci√≥n utilizados en el flujo de trabajo de fabricaci√≥n de FMV.  Estos m√©todos se pueden usar no solo para generar FMV y aplicar no solo a un juego;  Creo que son bastante universales, y se pueden usar en muchos aspectos del desarrollo del juego. <br><br>  Como la mayor√≠a de los flujos de trabajo de creaci√≥n de gr√°ficos, este proceso ser√° iterativo.  En alg√∫n lugar del archivo fuente puede haber un error que el artista debe corregir, y a veces fue necesario reexportar archivos dependientes de recursos.  Creo que todos preferir√≠amos que este trabajo lo realice una computadora, en lugar de una persona propensa a errores. <br><br>  Sab√≠amos exactamente c√≥mo deber√≠a verse y sonar el video de Full Throttle Remastered, por lo que solo necesit√°bamos mejorar sus gr√°ficos y sonido.  Todos los videos ten√≠an que coincidir con los originales, cuadro por cuadro, incluidas las rutas de la c√°mara, el volumen del sonido, la panor√°mica, etc.  Para lograr esto, necesit√°bamos saber c√≥mo era el flujo de trabajo de la creaci√≥n de FMV originales.  Y estos 67 GB de datos de los archivos de LucasArts conten√≠an muchas pistas sobre c√≥mo funcionaba todo en el original.  Fueron un gran comienzo para nosotros. <br><br><h1>  El proceso de crear FMV original </h1><br>  Puede sonar un poco nost√°lgico, pero creo que es importante discutir los aspectos de "arqueolog√≠a digital" de esta remasterizaci√≥n de juegos.  Al final, comprender el proceso de creaci√≥n del original le permitir√° responder muchas preguntas y dar pistas sobre c√≥mo los recursos se convirtieron en un resultado final.  Y al crear nuevos FMV rehechos, necesitamos aplicar las mismas transformaciones a nuestros recursos remasterizados originales para que el producto terminado se vea lo m√°s cerca posible del original.  Incluyendo que necesit√°bamos lo siguiente: <br><br><ul><li>  Ubicaci√≥n de las pistas de audio en la l√≠nea de tiempo. </li><li>  Ajustes de volumen y panorama para pistas de audio cuando se juega en el juego </li><li>  Composici√≥n del marco y colocaci√≥n de cada cuadro de video en el producto terminado </li></ul><br>  Una herramienta llamada SMUSHFT (SMUSH for Full Throttle) permiti√≥ al creador de FMV colocar recursos de video y audio en la l√≠nea de tiempo, y luego codificar la pel√≠cula FMV resultante (en formato .san), que fue le√≠da por el motor del juego.  Todos los videos se dividieron en una serie de cuadros que se pegaron para crear el resultado final.  SMUSHFT permiti√≥ al usuario mover visualmente estos recursos a lo largo de la l√≠nea de tiempo y, si es necesario, rehacer el video. <br><br>  No puedes mencionar que no particip√© en la creaci√≥n del juego original.  Solo pod√≠a adivinar c√≥mo se crearon los recursos originales, estudiando datos archivados y mirando formatos y archivos ejecutables empaquetados en estos datos.  Parece que los modelos 3D se crearon en Autodesk 3D Studio Release 3, y las partes dibujadas a mano se crearon en DeluxePaint Animation v1.0.  Tampoco s√© en qu√© etapas consisti√≥ la generaci√≥n de datos de forma de onda para audio, pero cada clip de audio utilizado (en formato .sad) contiene informaci√≥n sobre el volumen y la panor√°mica por fotogramas clave, utilizados para mezclar sonido durante el juego. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/921/61a/c0392161ae29aa540fe78d7a6485a232.png"></div><br>  <em>El proceso de crear FMV original</em> <br><br>  Despu√©s de crear estas partes separadas del marco, se realiz√≥ el proceso de combinar el marco.  Este proceso combina representaciones de cuadros en 3D con cuadros de animaci√≥n dibujados a mano (junto con todo lo dem√°s), creando un producto terminado utilizado por la herramienta SMUSHFT (archivos .nut).  Una vez que el proyecto estuvo listo para la codificaci√≥n, el video se proces√≥ y el resultado final (.san) ya se pudo reproducir en el motor del juego. <br><br>  SMUSHFT realiz√≥ la codificaci√≥n final del formato de archivo del video original (.san), y cada archivo de video ten√≠a un archivo de proyecto (.pro) que describe el ensamblaje del video (sonido, video, ubicaci√≥n de los subt√≠tulos).  Quer√≠amos extraer esta informaci√≥n para poder generar el archivo de proyecto Adobe Premiere Pro y usarlo para codificar la versi√≥n convertida del video en resoluci√≥n 4K.  Para hacer esto, necesit√°bamos aplicar ingenier√≠a inversa al archivo de proyecto SMUSHFT. <br><br><h1>  Ingenier√≠a inversa de formatos de archivo </h1><br>  Es genial tener c√≥digo fuente, porque puedes estudiarlo y entender c√≥mo se cre√≥ / ley√≥ el archivo del proyecto.  Sin el c√≥digo fuente, debe abrir el archivo del proyecto en un editor hexadecimal y analizar los patrones dentro del archivo.  Esta es exactamente la forma en que sol√≠amos extraer contenido √∫til del archivo de proyecto SMUSHFT. <br><br>  Como pudimos ejecutar el SMUSHFT original en DOSBox, vimos la interfaz de usuario del programa, que nos dio pistas sobre el formato del archivo.  Eche un vistazo a esta captura de pantalla para abrir el archivo .pro original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/854/63b/cbb85463b67ad09d81d939f442f9fdc0.png"></div><br>  <em>Proyecto SMUSHFT de muestra</em> <br><br>  Aqu√≠ puede observar lo siguiente: hay recursos con nombre en el archivo (2027.NUT, 2027.SAD, IN_06A.NUT, etc.).  Es probable que dichos recursos con nombre muestren caracteres ASCII dentro del archivo.  Adem√°s, hay contadores de cuadros en la parte superior de la l√≠nea de tiempo y, a la izquierda de la l√≠nea de tiempo, hay un n√∫mero creciente de capas.  Y el √∫ltimo: cada recurso en la l√≠nea de tiempo se encuentra en un n√∫mero de cuadro espec√≠fico y tiene una cierta duraci√≥n.  Si podemos extraer esta informaci√≥n de los archivos originales del proyecto, nos informar√° d√≥nde colocar autom√°ticamente nuevos recursos en la l√≠nea de tiempo de Adobe Premiere Pro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/de5/904/3e5de59049c14a72bb8373a0c72b48a0.png"></div><br>  <em>Proyecto de muestra de Adobe Premiere Pro</em> <br><br>  Al abrir el archivo original del proyecto en un editor hexadecimal, puede obtener informaci√≥n bastante √∫til.  Mire el ejemplo anterior en hexadecimal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/008/054/b5f00805485c3d4a8af811c4dc359063.png"></div><br>  <em>Archivo de proyecto SMUSHFT en editor hexadecimal</em> <br><br>  Podemos comenzar a mirar el archivo .pro con un editor hexadecimal (prefiero Hexplorer) e intentar buscar patrones.  Puede encontrar f√°cilmente recursos con nombre en formato ASCII con un byte cero al final.  Aproximadamente en la misma √°rea de memoria hay un grupo de valores almacenados como cortos (entero de doble byte).  Comparar n√∫meros mostrados en SMUSHFT con <br>  Los n√∫meros del archivo del proyecto en formato hexadecimal nos dan la base para convertir correctamente el archivo del proyecto original en un editor de video moderno como Adobe Premiere Pro. <br><br><h1>  Kit de herramientas de automatizaci√≥n </h1><br>  La mayor parte de este flujo de trabajo fue automatizado y no requiri√≥ intervenci√≥n humana.  Una de las razones de esto fue que el contenido de todos los videos se copi√≥ completamente del original;  de hecho, solo est√°bamos actualizando el contenido.  Y, por lo tanto, pr√°cticamente no tuvimos la oportunidad de cambiar completamente el formato FMV.  Solo necesit√°bamos encontrar una manera de recrear el video utilizando recursos de alta resoluci√≥n, mientras minimizamos el tiempo dedicado al producto. <br><br>  Primero, debo decir que un paso inicial serio antes de automatizar todo el proceso deber√≠a ser una conversaci√≥n con un equipo de creadores de contenido (gr√°ficos y audio).  La raz√≥n es que la mayor√≠a de los procesos de automatizaci√≥n requieren que los creadores se adhieran a un cierto conjunto de reglas sobre la preparaci√≥n de proyectos, ubicaciones de archivos, herramientas utilizadas, etc.  En nuestro proyecto, esto significaba que ten√≠amos que discutir herramientas para crear el contenido de cuadros dibujados a mano, modelos 3D y sonidos, y luego un editor de video para reunir todo esto.  Tambi√©n fue necesario acordar qu√© partes del flujo de trabajo se realizar√°n manualmente y cu√°les se automatizar√°n. <br><br>  Como resultado, decidimos lo siguiente: <br><br><ul><li>  Los marcos dibujados manualmente se crear√°n en Adobe Animate con una resoluci√≥n de 4440x2400 p√≠xeles. </li><li>  Los modelos 3D y las animaciones se crear√°n en Autodesk Maya y se renderizar√°n manualmente, tambi√©n con una resoluci√≥n de 4440x2400 p√≠xeles </li><li>  Los archivos de audio se crear√°n en formato .wav con par√°metros de 48 kHz y 16 bits </li><li>  Inicialmente, los fragmentos del video se generar√°n autom√°ticamente y el artista podr√° cambiar cualquier parte que necesite (con algunas excepciones) </li><li>  Las etapas finales de costura y codificaci√≥n FMV ser√°n automatizadas </li></ul><br>  Para que las herramientas sean lo m√°s automatizadas posible, utilizamos varios m√©todos.  Python fue elegido como el "pegamento" que conecta todo, porque est√° bien expandido por varias bibliotecas y el c√≥digo es f√°cil de escribir y mantener.  Tambi√©n aprovechamos su soporte interno para manipulaciones de archivos independientes de la plataforma (copiar, mover, eliminar). <br><br><h2>  Python - llamando a archivos ejecutables, obteniendo resultados </h2><br>  La biblioteca de subprocesos de Python fue ideal para nosotros, ya que le permite cambiar la ejecuci√≥n de otros archivos ejecutables e incluso esperar la finalizaci√≥n de sus tareas.  Le permite obtener el c√≥digo devuelto por el programa y acceder al b√∫fer stdout &amp; stderr. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-comment"><span class="hljs-comment"># The command to execute command = 'SanExtract.exe -f -i credits.san -o \"C:/output_dir/\" ' # Execute the command via subprocess child = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Wait for process to complete, returns stdout &amp; stderr buffers stdout, stderr = child.communicate() # Retrieve the return code from the process return_code = child.returncode</span></span></code> </pre> <br>  <em>Un ejemplo de interacci√≥n con archivos ejecutables en Python</em> <br><br><h2>  Python - API Win32 </h2><br>  La API Win32 es muy √∫til porque nos dio acceso para transmitir mensajes de teclado y mouse desde Windows desde un script.  Por ejemplo, puede crear una funci√≥n que haga clic con el mouse en ciertas coordenadas X, Y de la pantalla: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClickXY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Ejemplo de simulaci√≥n de clic del mouse de Python</em> <br><br>  Incluso puede enviar eventos de pulsaci√≥n de teclas al teclado (con o sin modificadores): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32con <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PressKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code, modifierCode=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) time.sleep(<span class="hljs-number"><span class="hljs-number">0.021</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Ejemplo de simulaci√≥n de teclado Python</em> <br><br>  Hay muchas otras posibilidades, pero los ejemplos anteriores realmente ayudaron a lograr nuestros objetivos.  Puede enviar eventos de teclado a cualquier programa activo y comenzar√° a escribirlos, como si estuvi√©ramos ingresando algo desde el teclado, incluyendo presionar teclas de acceso r√°pido. <br><br><h2>  Python: visi√≥n artificial para hacer clic en botones </h2><br>  La experiencia m√°s singular fue el uso de software de visi√≥n por computadora en aquellas herramientas que no pod√≠an automatizarse mediante scripts internos.  La mayor√≠a de las herramientas modernas tienen soporte para secuencias de comandos, pero a√∫n requieren la intervenci√≥n del usuario.  Por ejemplo, 3D Studio Max le permite ejecutar archivos MAXScript desde la l√≠nea de comandos.  En nuestro caso, ejecutamos el script para importar autom√°ticamente el archivo de malla 3D, despu√©s de lo cual 3D Studio Max se inicia autom√°ticamente y muestra el cuadro de di√°logo Importar forma, en el que el usuario debe hacer clic en los botones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/b3e/4f9/ddcb3e4f9a830a8e72d9697eacf19b74.png"></div><br>  <em>Cuadro de di√°logo de ejemplo Forma Importar</em> <br><br>  Entonces, ¬øescribimos un script para la automatizaci√≥n, y ahora tenemos que sentarnos frente a la pantalla, presionando las teclas?  En lugar de sentarnos en el teclado y esperar a que aparezca la ventana emergente, podemos hacer que el script tome una captura de pantalla, usar el enlace OpenCV a Python para encontrar la plantilla de imagen del bot√≥n y hacer clic autom√°ticamente en ella.  As√≠ es como se ve la plantilla de imagen para el ejemplo descrito anteriormente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/67c/af3/b1e67caf30b4ea94761063bb6ead063c.png"></div><br>  <em>Plantilla de imagen para ok_button.png</em> <br><br>  Vale la pena se√±alar que la plantilla de imagen contiene caracter√≠sticas adicionales (texto para "Objeto √∫nico" y "Objetos m√∫ltiples").  Esto nos permite obtener un resultado de b√∫squeda m√°s determinista.  El siguiente es un script de Python de ejemplo que se usa para hacer clic autom√°ticamente en una ubicaci√≥n encontrada de una plantilla de imagen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageGrab <span class="hljs-comment"><span class="hljs-comment"># "Constants" TEMPLATE_THRESHOLD = 0.25 CLICK_OFFSET = 20 # Read the template image to search for template_image = cv2.imread('images/ok_button.png', 0) # Screenshot the current desktop and load it to a cv2 format screen = ImageGrab.grab() screen.save('screen.png') screen_image = cv2.imread('screen.png', 0) # Search for the template within the screenshot and retrieve search results match_result = cv2.matchTemplate(screen_image, template_image, cv2.TM_SQDIFF_NORMED) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(match_result) # If below the threshold, it's likely we know where to click if min_val &lt; TEMPLATE_THRESHOLD: ClickXY(min_loc[0]+CLICK_OFFSET, min_loc[1]+CLICK_OFFSET)</span></span></code> </pre> <br>  <em>Un ejemplo de hacer clic en un elemento de visualizaci√≥n usando OpenCV, escrito en Python</em> <br><br>  Todos los ejemplos anteriores se basan en Python.  Pero hay momentos en los que necesitamos un control m√°s preciso sobre el sistema de ventanas del sistema operativo Windows.  Esto nos llev√≥ a desarrollar herramientas nativas utilizando la API de automatizaci√≥n de Windows. <br><br><h2>  Windows Native (C ++) - API de automatizaci√≥n de Windows </h2><br>  La API de automatizaci√≥n de Windows proporciona acceso a la API heredada de accesibilidad activa de Microsoft (MSAA), as√≠ como a la API de automatizaci√≥n de interfaz de usuario de Microsoft.  Puede leer m√°s sobre esto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la p√°gina de Microsoft</a> . <br><br>  Como resultado, pudimos realizar solicitudes a ciertos elementos de la interfaz de Windows (botones, campos de texto, pesta√±as, elementos de men√∫), averiguar d√≥nde est√°n ubicados espacialmente estos elementos en la pantalla y hacer clic / interactuar con ellos.  El SDK de Windows tambi√©n tiene herramientas de prueba que le permiten ver qu√© propiedades est√°n disponibles.  Nos permitieron descubrir qu√© se puede automatizar en cada programa espec√≠fico. <br><br>  La aplicaci√≥n Inspect.exe es bastante √∫til para mostrar la jerarqu√≠a de la administraci√≥n de ventanas del programa;  proporciona una idea aproximada de d√≥nde se encuentran los objetos, como los controles de men√∫, y c√≥mo referirse a los elementos de la ventana mediante llamadas a la API de automatizaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/d3f/650/0f2d3f650f30c4982f10d9d31b94c35c.png"></div><br>  <em>Ejemplo Inspect.exe</em> <br><br>  Despu√©s de conocer la jerarqu√≠a de control del programa de Windows, sabr√° c√≥mo encontrarla desde el identificador de la ventana principal y c√≥mo hacer clic en diferentes elementos a trav√©s de la API: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Click on a sub-menu item given the Window &amp; Menu handles. void ClickSubMenu(HWND hwnd, HMENU hmenu, const char *pMenuName) { // Iterate through the menu items of the window int menu_item_count = GetMenuItemCount(hmenu); for(int menu_id = 0; menu_id &lt; menu_item_count; ++menu_id) { char menu_name[MAX_PATH]; int len = GetMenuString(hmenu, menu_id, reinterpret_cast&lt;LPSTR&gt;(&amp;menu_name[0]), sizeof(menu_name), MF_BYPOSITION); // Look for the specific menu you're searching for and click it // Make sure to set the window active before doing it... if(!strcmp(pMenuName, menu_name)) { // now get the rect and click the center RECT rect; BOOL success = GetMenuItemRect(hwnd, hmenu, menu_id, &amp;rect); if(success) { SetActiveWindow(hwnd); POINT point = GetMiddlePoint(rect); SetCursorPos(point.x, point.y); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, point.x, point.y, 0, 0); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTUP, point.x, point.y, 0, 0); Sleep(DO_TASK_INTERVAL_WAIT_MS); } } } }</span></span></span></span></code> </pre> <br>  <em>Un ejemplo de empujar un control de ventana en C ++</em> <br><br>  Y, por supuesto, pasar pulsaciones de teclas a la ventana activa tambi√©n es simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Type the character string to the given window handle static void TypeCharacters(HWND window_handle, const char *pString) { int len = strlen(pString); for(int count = 0; count &lt; len; ++count) { SendMessage(window_handle, WM_CHAR, (WPARAM)pString[count], (LPARAM)0); Sleep(CHARACTER_REPEAT_INTERVAL_MS); } }</span></span></span></span></code> </pre> <br>  <em>Ejemplo de simulaci√≥n de teclado C ++</em> <br><br>  Por supuesto, estas API tienen muchas m√°s funciones.  Descubr√≠ que gracias a la herramienta Inspect.exe, puede arrojar luz sobre a qu√© elementos de la ventana del programa se puede acceder. <br><br><h2>  Formatos de texto intermedios </h2><br>  Parte de nuestro flujo de trabajo consist√≠a en guardar los archivos en forma de texto y cambiar los valores en estos archivos de texto.  Al final, las herramientas tienen una interfaz de usuario para cambiar el estado de los datos auxiliares.  Y si sabe cu√°les deber√≠an ser estos datos auxiliares, entonces no es necesario trabajar con la herramienta, simplemente cambie los datos auxiliares.  El truco es saber c√≥mo manipular estos datos de soporte;  Al cambiar los formatos de archivo propietarios, esto puede ser un desaf√≠o.  ¬øNo ser√≠a bueno si todos tuvieran un archivo de texto simple con el que puedan trabajar? <br><br>  El truco es encontrar una forma de evitar los formatos de archivo propietarios utilizados por la mayor√≠a de las herramientas.  La soluci√≥n generalmente es usar las opciones de Importar y Exportar que se encuentran en la mayor√≠a de las herramientas comerciales modernas.  Aqu√≠ hay algunos ejemplos: <br><br>  Adobe Premiere Pro guarda los archivos en un formato propietario, pero puede importar / exportar proyectos como Final Cut Pro XML.  Despu√©s de exportar a XML, puede cambiar el XML de la manera que necesitamos y volver a importar el proyecto a Adobe Premiere Pro. <br><br>  Otro ejemplo es la correcci√≥n de las referencias de textura utilizadas en el obsoleto formato de malla 3D de Autodesk 3D Studio Release 3. Al importar el archivo de malla original, guardamos la malla reci√©n convertida en un archivo intermedio .fbx usando caracteres ASCII.  En este formato, puede procesar un archivo de texto y reemplazar todas las l√≠neas de enlaces de textura por las correctas. <br><br>  Adobe Animate / Flash es bastante divertido, ya que resulta que los archivos .fla en realidad son archivos .zip un poco "rotos".  En forma no comprimida, se almacenan en formato XFL, que puede hacer referencia a otros objetos XFL (por ejemplo, mapas de bits) desde una carpeta local.  El ingeniero principal de Double Fine, Oliver Franzke, cre√≥ un script Python modificado para empaquetar / descomprimir archivos .fla usando ZIP para que podamos crear / modificar estos archivos. <br><br><h1>  Ejemplos de uso </h1><br><h2>  3D Studio Max </h2><br>  La versi√≥n moderna de 3D Studio Max se utiliz√≥ para importar el archivo .prj original a la escena y guardarlo en el formato ASCII .fbx.  Para cada archivo .prj que necesitaba convertirse, se gener√≥ autom√°ticamente un archivo MaxScript (.ms) a partir del script Python, que se parec√≠a a esto: <br><br><pre> <code class="bash hljs">importFile <span class="hljs-string"><span class="hljs-string">"G:\FullThrottle_Backup\FullThrottle_SourceAssets\BENBIKE.PRJ"</span></span> <span class="hljs-comment"><span class="hljs-comment">#noPrompt</span></span></code> </pre> <br>  <em>Ejemplo de importaci√≥n de un modelo 3D con MaxScript</em> <br><br>  Despu√©s de eso, este archivo .ms simplemente fue llamado por el comando Python para ejecutarse en 3dsmax.exe: <br><br><pre> <code class="bash hljs">3dsmax.exe -U MAXScript <span class="hljs-string"><span class="hljs-string">"C:\FullThrottleRemastered\import_prj.ms"</span></span></code> </pre> <br>  <em>Un ejemplo de un comando de consola para llamar a un archivo ejecutable con el archivo MaxScript especificado</em> <br><br>  Como se mencion√≥ anteriormente, en este caso, 3D Studio Max abri√≥ un cuadro de di√°logo en el que tuvo que hacer clic.  El paquete OpenCV con Python ayud√≥ a hacer clic en el bot√≥n en esta ventana para que el archivo original se importe sin intervenci√≥n del usuario.  Despu√©s de importar el archivo, se presion√≥ una serie de teclas de men√∫ (usando Win32api Python) para iniciar otro archivo MAXScript, que export√≥ el modelo como un archivo .fbx en formato ASCII.  Como .fbx se guard√≥ como un archivo de texto normal, todas las dependencias de las dependencias de la textura del modelo fueron reemplazadas por enlaces a im√°genes en un formato moderno.  Luego, el archivo .fbx modificado se volvi√≥ a cargar autom√°ticamente en 3DSMax y se export√≥ como un archivo .max.  En este punto, el archivo .max podr√≠a enviarse al artista para su remasterizaci√≥n. <br><br><h2>  Adobe Animate / Flash </h2><br>  Adobe Animate / Flash se utiliz√≥ para remasterizar todos los recursos FMV dibujados a mano.  Tomamos los marcos originales dibujados a mano (320x200 p√≠xeles de tama√±o) encontrados por la herramienta SanWrangler y los usamos como "dibujos de ensamblaje".  La escala de la imagen se ampli√≥ para adaptarse a 4440x2400 p√≠xeles, despu√©s de lo cual se gener√≥ autom√°ticamente un archivo .fla utilizando un script Python. <br><br>  Luego fue suficiente para generar autom√°ticamente el archivo .fla desde cero, utilizando nuestro conocimiento del formato XFL Adobe Animate / Flash.  Pudimos usar el kit de herramientas ya creado por Oliver Franzke para generar dibujos de ensamblaje de archivos de animaci√≥n dibujados a mano. <br><br><h2>  Adobe Premiere Pro </h2><br>  La API de automatizaci√≥n de Windows realmente nos ayud√≥ a determinar qu√© controles de Premiere Pro est√°n en la pantalla.  En algunos casos, no ten√≠an teclas de acceso r√°pido.  Despu√©s de recibir las coordenadas de los elementos del men√∫, fue necesario mover el cursor a estas coordenadas y enviar un evento de clic del mouse. <br><br>  Todo esto es genial, pero algunos controles se representan de otras maneras y, por lo tanto, son invisibles para la API de automatizaci√≥n de Windows.  Para este caso, decidimos usar un mont√≥n de OpenCV y Python para poder usar OpenCV en un entorno de secuencias de comandos.  Esto fue especialmente √∫til al trabajar con Adobe Premiere Pro: aunque tiene soporte parcial para los scripts de JavaScript, el tipo de control necesario no estaba disponible a trav√©s de la API. <br><br>  Adem√°s, los archivos de proyecto de Adobe Premiere Pro se almacenan en un formato binario patentado.  Por lo tanto, no solo podr√≠amos crear m√°gicamente el archivo Premiere Pro, sino que podr√≠amos usar la funci√≥n de importaci√≥n, que nos permiti√≥ importar los datos en el archivo Final Cut Pro, que tiene el formato XML.  Luego fue suficiente para generar el archivo XML correcto, posicionar adecuadamente todos los recursos en la l√≠nea de tiempo y luego importar autom√°ticamente este .xml Final Cut Pro para convertirlo al formato deseado.  Luego podr√≠amos poner los cuadros exportados en una cola automatizada para poder combinarlos en un video terminado. <br><br><h1>  Todas las etapas </h1><br>  A continuaci√≥n se muestra un diagrama de bloques generalizado que muestra todas las partes automatizadas de un nuevo flujo de trabajo.  Cada segmento automatizado est√° rodeado por un rect√°ngulo redondeado con informaci√≥n adicional sobre las t√©cnicas de automatizaci√≥n utilizadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f26/2c7/7cf/f262c77cf9d06f1fb6828e356ce40cc8.png"></div><br>  <em>Diagrama de flujo de automatizaci√≥n FMV remasterizado simplificado</em> <br><br>  Notar√°s que la mayor parte del trabajo con Adobe Premiere Pro requiere el uso de Python, as√≠ como un c√≥digo especializado de Windows nativo.  La raz√≥n es la compleja estructura de las ventanas de Premiere Pro, as√≠ como la necesidad de usar la API nativa de automatizaci√≥n de Windows para garantizar una interacci√≥n adecuada con todas las ventanas secundarias dependientes de esta aplicaci√≥n. <br><br><h1>  Todos juntos </h1><br>  Utilizando los m√©todos descritos anteriormente, pudimos configurar varias m√°quinas de automatizaci√≥n para dividir el trabajo en todos los videos en partes.  Adem√°s, se integr√≥ un Slack Bot en el flujo de trabajo para enviar comentarios sobre la automatizaci√≥n a nuestro canal Slack de acuerdo con el estado de los videos que pasan a trav√©s de la tuber√≠a de procesamiento, para que sepamos cu√°ndo algo sale mal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/36d/f19/9b536df197475f6235282ac084c2efc8.gif"></div><br>  <em>Ejemplo de automatizaci√≥n de Adobe Premiere Pro</em> <br><br><h1>  Los problemas que enfrentamos </h1><br>  Todo esto suena genial, pero de hecho, al implementar el proyecto, nos encontramos con problemas.  Voy a enumerar solo los puntos principales. <br><br>  1) Iteraci√≥n de mezclar el audio terminado.  La remasterizaci√≥n de todos los archivos de audio se realiz√≥ gradualmente.  Por lo tanto, cuando tuvimos, por ejemplo, el efecto de sonido "BOOM!", El ingeniero de sonido no ten√≠a idea de d√≥nde insertarlo en la mezcla de audio, por lo que tuvo que esperar a que se codificara el video para descubrir qu√© hab√≠a salido mal. <br><br>  2) Almacenamiento de archivos intermedios sin comprimir.  Los cuadros se almacenaron en formato sin comprimir hasta el √∫ltimo momento de codificaci√≥n en el video terminado.  Por lo tanto, era necesario almacenar una gran cantidad de tramas en el almacenamiento local, algunas de las cuales estaban almacenadas en el sistema de control de versiones.  Tal aumento en el volumen almacenado fue muy notable y puede ser bastante costoso cuando se usan algunos sistemas de control de versiones (utilizamos Perforce). <br><br>  3) Plazo de ejecuci√≥n.  Una parte s√≥lida del flujo de trabajo se automatiz√≥, y esto permiti√≥ a los ingenieros hacer otras cosas.  Sin embargo, el tiempo necesario para crear un video puede ser bastante largo.  La parte que consume m√°s tiempo es la codificaci√≥n de fotogramas en resoluci√≥n de 4k.  Ten√≠amos formas de investigar el estado de los recursos dentro de Perforce para comprender qu√© pasos deben realizarse de nuevo, pero este m√©todo no estaba tan dividido en partes como quisi√©ramos. <br><br><h1>  Pr√≥ximos pasos </h1><br>  S√≠, ¬°el art√≠culo result√≥ ser voluminoso!  Aunque nuestra implementaci√≥n de este flujo de trabajo es bastante espec√≠fica para el proyecto, creo que ciertos m√©todos de automatizaci√≥n se pueden usar para desarrollar cualquier juego.  Despu√©s de descubrir el video, puedes considerar un tema relacionado: jugar FMV durante la ejecuci√≥n del juego.  Esto incluye problemas como la codificaci√≥n de una transmisi√≥n de audio multiling√ºe, as√≠ como la sincronizaci√≥n de cuadros cuando se reproduce FMV original.  ¬°Espera la tercera parte del art√≠culo! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422367/">https://habr.com/ru/post/es422367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422357/index.html">Aprendizaje profundo para determinar el estilo y el g√©nero de las pinturas.</a></li>
<li><a href="../es422359/index.html">Los resultados de la b√∫squeda por la que pasaste. O no</a></li>
<li><a href="../es422361/index.html">S√≠ndrome corporativo</a></li>
<li><a href="../es422363/index.html">Conferencia PyCon Rusia 2018: video de todos los informes y presentaciones</a></li>
<li><a href="../es422365/index.html">Yandex present√≥ una queja contra una decisi√≥n judicial de eliminar enlaces a contenido pirateado</a></li>
<li><a href="../es422369/index.html">Dise√±o de paneles de control para el sitio de comercio electr√≥nico de an√°lisis web. Parte 2: Boletines informativos por correo electr√≥nico. Tablero estrat√©gico</a></li>
<li><a href="../es422371/index.html">Revisi√≥n de la bicicleta el√©ctrica Twitter TW-E9L</a></li>
<li><a href="../es422373/index.html">Te invitamos a reuniones de c√≥digo abierto en septiembre (Mosc√∫ y San Petersburgo)</a></li>
<li><a href="../es422375/index.html">Los contratos son diferentes, o para qu√© te inscribiste</a></li>
<li><a href="../es422377/index.html">ESP8266 + FLProg - Par√°metros del sistema del usuario y sincronizaci√≥n con el servidor horario exacto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>