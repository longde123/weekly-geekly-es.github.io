<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕎 👋🏽 🖕🏾 Compatibilité binaire Reaktive: comment nous la fournissons 🕙 👅 ✍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Je m'appelle Yuri Vlad, je suis développeur Android chez Badoo et participe à la création de la bibliothèque Reaktive - Reactive Extensions sur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compatibilité binaire Reaktive: comment nous la fournissons</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/484712/"><p>  Salut  Je m'appelle Yuri Vlad, je suis développeur Android chez Badoo et participe à la création de la bibliothèque <a href="https://github.com/badoo/Reaktive">Reaktive</a> - Reactive Extensions sur Kotlin pur. </p><br><p>  Toute bibliothèque doit respecter la compatibilité binaire dans la mesure du possible.  Si différentes versions de la bibliothèque dans les dépendances sont incompatibles, le résultat sera un plantage lors de l'exécution.  Nous pouvons rencontrer un tel problème, par exemple, lors de l'ajout de la prise en charge de <a href="https://github.com/badoo/MVICore">Reaktive</a> à <a href="https://github.com/badoo/MVICore">MVICore</a> . </p><br><p><img src="https://habrastorage.org/webt/6w/hx/mc/6whxmcr9swxn5rtbxjeo46igkv8.jpeg"></p><br><p>  Dans cet article, je vais vous dire brièvement ce qu'est la compatibilité binaire et quelles sont ses fonctionnalités pour Kotlin, ainsi que la façon dont elle est prise en charge dans JetBrains, et maintenant dans Badoo. </p><a name="habracut"></a><br><h2 id="problema-binarnoy-sovmestimosti-v-kotlin">  Problème de compatibilité binaire Kotlin </h2><br><p> Supposons que nous ayons une merveilleuse bibliothèque <code>com.sample:lib:1.0</code> avec cette classe: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p>  Sur cette base, nous avons créé une deuxième bibliothèque <code>com.sample:lib-extensions:1.0</code> .  Parmi ses dépendances se trouve <code>com.sample:lib:1.0</code> .  Par exemple, il contient une méthode d'usine pour la classe <code>A</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: A = A(a)</code> </pre> <br><p>  Nous allons maintenant publier la nouvelle version de notre bibliothèque <code>com.sample:lib:2.0</code> avec la modification suivante: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><p>  Le changement entièrement compatible de Kotlin, n'est-ce pas?  Avec le paramètre par défaut, nous pouvons continuer à utiliser la construction <code>val a = A(a)</code> , mais seulement si toutes les dépendances sont complètement recompilées.  Les paramètres par défaut ne font pas partie de la JVM et sont implémentés par le constructeur synthétique spécial <code>A</code> , qui contient tous les champs de la classe dans les paramètres.  Dans le cas de la réception de dépendances du référentiel Maven, nous les obtenons déjà assemblés et ne pouvons pas les recompiler. </p><br><p>  Une nouvelle version de <code>com.sample:lib</code> et nous la connectons immédiatement à notre projet.  Nous voulons être à jour!  Nouvelles fonctionnalités, nouveaux correctifs, <del>  nouveaux bugs </del>  ! </p><br><pre> <code class="plaintext hljs">dependencies { implementation 'com.sample:lib:2.0' implementation 'com.sample:lib-extensions:1.0' }</code> </pre> <br><p>  Et dans ce cas, nous obtenons un crash lors de l'exécution.  <code>createA</code> fonction <code>createA</code> dans le bytecode va essayer d'appeler le constructeur de classe <code></code> avec un paramètre, mais il n'y en a pas un dans le bytecode.  De toutes les dépendances avec le même groupe et le même nom, Gradle sélectionnera celle qui a la version la plus récente et l'inclura dans l'assembly. </p><br><p>  Très probablement, vous avez déjà rencontré une incompatibilité binaire dans vos projets.  Personnellement, je suis tombé sur cela lorsque j'ai migré nos applications vers AndroidX. </p><br><p>  Vous pouvez en savoir plus sur la compatibilité binaire dans les articles <a href="https://habr.com/ru/post/133907/">«Compatibilité binaire dans les exemples et pas seulement»</a> de l'utilisateur de <a href="https://habr.com/ru/users/gvsmirnov/" class="user_link">gvsmirnov</a> , <a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">«Evolving Java-based APIs 2» des</a> créateurs Eclipse et dans l'article récemment publié <a href="https://jakewharton.com/public-api-challenges-in-kotlin/">«Public API challenges in Kotlin» de</a> Jake Wharton. </p><br><h2 id="sposoby-obespecheniya-binarnoy-sovmestimosti">  Moyens d'assurer la compatibilité binaire </h2><br><p>  Il semblerait que vous ayez juste besoin d'essayer d'apporter des modifications compatibles.  Par exemple, ajoutez des constructeurs avec une valeur par défaut lors de l'ajout de nouveaux champs, ajoutez de nouveaux paramètres aux fonctions en remplaçant une méthode par un nouveau paramètre, etc. Mais il est toujours facile de se tromper.  Par conséquent, divers outils pour vérifier la compatibilité binaire de deux versions différentes de la même bibliothèque ont été créés, tels que: </p><br><ol><li>  Vérificateur de conformité de l'API Java </li><li>  Clirr </li><li>  Revapi </li><li>  Japicmp </li><li>  Japitools </li><li>  Jour </li><li>  Japi-checker </li><li>  Sigtest </li></ol><br><p>  Ils prennent deux fichiers JAR et donnent le résultat: leur compatibilité. </p><br><p>  Cependant, nous développons la bibliothèque Kotlin, qui jusqu'à présent n'a de sens que d'être utilisée uniquement à partir de Kotlin.  Cela signifie que nous n'avons pas toujours besoin d'une compatibilité à 100%, par exemple, pour <code>internal</code> classes <code>internal</code> .  Bien qu'ils soient publics en bytecode, leur utilisation en dehors du code Kotlin est peu probable.  Par conséquent, pour maintenir la compatibilité binaire, kotlin-stdlib JetBrains utilise un <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">vérificateur de compatibilité binaire</a> .  Le principe de base est le suivant: un vidage de l'ensemble de l'API publique est créé à partir du fichier JAR et écrit dans le fichier.  Ce fichier est une référence (référence) pour toutes les vérifications ultérieures, et il ressemble à ceci: </p><br><pre> <code class="plaintext hljs">public final class kotlin/coroutines/ContinuationKt { public static final fun createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun createCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun startCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)V public static final fun startCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)V }</code> </pre> <br><p>  Après avoir apporté des modifications au code source, la bibliothèque de ligne de base est régénérée, par rapport à la bibliothèque actuelle, et la vérification échoue si des modifications de la ligne de base apparaissent.  Ces modifications peuvent être remplacées en passant <code>-Doverwrite.output=true</code> .  Une erreur se produira même si des modifications compatibles binaires se sont produites.  Cela est nécessaire afin de mettre à jour en temps opportun la ligne de base et de voir ses changements directement dans la demande d'extraction. </p><br><h2 id="binary-compatibility-validator">  Validateur de compatibilité binaire </h2><br><p>  Voyons comment fonctionne cet outil.  La compatibilité binaire est fournie au niveau JVM (bytecode) et est indépendante du langage.  Il est possible de remplacer l'implémentation de la classe Java par Kotlin- sans casser la compatibilité binaire (et vice versa). <br>  Vous devez d'abord comprendre quelles classes sont dans la bibliothèque.  Nous nous souvenons que même pour les fonctions globales et les constantes, une classe est créée avec le nom de fichier et le suffixe <code>Kt</code> , par exemple, <code>ContinuationKt</code> .  Pour obtenir toutes les classes, nous utilisons la classe <code>JarFile</code> du JDK, obtenons des pointeurs vers chaque classe et les transmettons à <code>org.objectweb.asm.tree.ClassNode</code> .  Cette classe nous fera connaître la visibilité de la classe, ses méthodes, champs et annotations. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jar = JarFile(<span class="hljs-string"><span class="hljs-string">"/path/to/lib.jar"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classStreams = jar.classEntries().map { entry -&gt; jar.getInputStream(entry) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNodes = classStreams.map { it.use { stream -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNode = ClassNode() ClassReader(stream).accept(classNode, ClassReader.SKIP_CODE) classNode } }</code> </pre> <br><p>  Kotlin, lors de la compilation, ajoute son annotation d'exécution <code>@Metadata</code> à chaque classe afin que <code>kotlin-reflect</code> puisse restaurer l'apparence de la classe Kotlin avant sa conversion en bytecode.  Cela ressemble à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Metadata</span></span>( mv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>}, bv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, k = <span class="hljs-number"><span class="hljs-number">1</span></span>, d1 = {<span class="hljs-string"><span class="hljs-string">"\u0000 \n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\b\n\u0002\b\u0006\n\u0002\u0010\u000b\n\u0002\b\u0003\n\u0002\u0010\u000e\n\u0000\b\u0086\b\u0018\u00002\u00020\u0001B\r\u0012\u0006\u0010\u0002\u001a\u00020\u0003¢\u0006\u0002\u0010\u0004J\t\u0010\u0007\u001a\u00020\u0003HÆ\u0003J\u0013\u0010\b\u001a\u00020\u00002\b\b\u0002\u0010\u0002\u001a\u00020\u0003HÆ\u0001J\u0013\u0010\t\u001a\u00020\n2\b\u0010\u000b\u001a\u0004\u0018\u00010\u0001HÖ\u0003J\t\u0010\f\u001a\u00020\u0003HÖ\u0001J\t\u0010\r\u001a\u00020\u000eHÖ\u0001R\u0011\u0010\u0002\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\u0005\u0010\u0006¨\u0006\u000f"</span></span>}, d2 = {<span class="hljs-string"><span class="hljs-string">"Lcom/sample/A;"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"(I)V"</span></span>, <span class="hljs-string"><span class="hljs-string">"getA"</span></span>, <span class="hljs-string"><span class="hljs-string">"()I"</span></span>, <span class="hljs-string"><span class="hljs-string">"component1"</span></span>, <span class="hljs-string"><span class="hljs-string">"copy"</span></span>, <span class="hljs-string"><span class="hljs-string">"equals"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"other"</span></span>, <span class="hljs-string"><span class="hljs-string">"hashCode"</span></span>, <span class="hljs-string"><span class="hljs-string">"toString"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"app_release"</span></span>} )</code> </pre> <br><p>  <code>ClassNode</code> pouvez obtenir l'annotation <code>@Metadata</code> de <code>@Metadata</code> et l'analyser dans <code>KotlinClassHeader</code> .  Vous devez le faire manuellement, car <code>kotlin-reflect</code> ne sait pas comment travailler avec ObjectWeb ASM. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ClassNode.kotlinMetadata: KotlinClassMetadata? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/Metadata"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> header = with(metadata) { KotlinClassHeader( kind = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"k"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?, metadataVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"mv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), bytecodeVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"bv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), data1 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), data2 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), extraString = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, packageName = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"pn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, extraInt = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? ) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> KotlinClassMetadata.read(header) }</code> </pre> <br><p>  kotlin.Metadata est nécessaire pour gérer correctement <code>internal</code> , car il n'existe pas dans le bytecode.  Les modifications apportées aux classes et fonctions <code>internal</code> ne peuvent pas affecter les utilisateurs de la bibliothèque, bien qu'elles soient une API publique en termes de bytecode. </p><br><p>  De kotlin.Metadata, vous pouvez en savoir plus sur l' <code>companion object</code> .  Même si vous le déclarez privé, il sera toujours stocké dans le champ statique public <code>Companion</code> , ce qui signifie que ce champ est soumis à l'exigence de compatibilité binaire. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeException</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { } }</code> </pre> <br><pre> <code class="plaintext hljs">public final static Lcom/badoo/reaktive/base/exceptions/CompositeException$Companion; Companion @Ljava/lang/Deprecated;()</code> </pre> <br><p>  Parmi les annotations nécessaires, il convient de noter <code>@PublishedApi</code> pour les classes et méthodes utilisées dans les fonctions publiques en <code>inline</code> .  Le corps de ces fonctions reste à la place de leur appel, ce qui signifie que les classes et méthodes qu'elles contiennent doivent être compatibles binaires.  Lorsque vous essayez d'utiliser des classes et des méthodes non publiques dans de telles fonctions, le compilateur Kotlin <code>@PublishedApi</code> erreur et suggère qu'elles soient annotées avec <code>@PublishedApi</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ClassNode.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPublishedApi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/PublishedApi"</span></span>, includeInvisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) != <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  L'arbre de l'héritage de classe et l'implémentation d'interfaces sont importants pour prendre en charge la compatibilité binaire.  Nous ne pouvons pas, par exemple, simplement supprimer une interface de la classe.  Et obtenir la classe parente et les interfaces implémentables est assez simple. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(classNode.superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + classNode.interfaces.sorted()</code> </pre> <br><p>  <code>Object</code> supprimé de la liste, car son suivi n'a aucun sens. </p><br><p>  À l'intérieur du validateur, il existe de nombreuses vérifications supplémentaires spécifiques à Kotlin: vérification des méthodes par défaut dans les interfaces via <code>Interface$DefaultImpls</code> , ignorant les classes <code>$WhenMappings</code> pour que l'opérateur fonctionne, et d'autres. </p><br><p>  Ensuite, vous devez parcourir tous les <code>ClassNode</code> et obtenir leurs <code>MethodNode</code> et <code>FieldNode</code> .  À partir de la signature des classes, de leurs champs et méthodes, nous obtenons <code>ClassBinarySignature</code> , <code>FieldBinarySignature</code> et <code>MethodBinarySignature</code> , qui sont déclarés localement dans le projet.  Tous implémentent l'interface <code>MemberBinarySignature</code> , sont capables de déterminer leur visibilité publique à l'aide de la méthode <code>isEffectivelyPublic</code> et d'afficher leur signature dans un format lisible <code>val signature: String</code> . </p><br><pre> <code class="kotlin hljs">classNodes.map { with(it) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = kotlinMetadata <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mVisibility = visibilityMapNew[name] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classAccess = AccessFlags(effectiveAccess and Opcodes.ACC_STATIC.inv()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + interfaces.sorted() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> memberSignatures = ( fields.map { with(it) { FieldBinarySignature(JvmFieldSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } + methods.map { with(it) { MethodBinarySignature(JvmMethodSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } ).filter { it.isEffectivelyPublic(classAccess, mVisibility) } ClassBinarySignature(name, superName, outerClassName, supertypes, memberSignatures, classAccess, isEffectivelyPublic(mVisibility), metadata.isFileOrMultipartFacade() || isDefaultImpls(metadata) } }</code> </pre> <br><p>  Après avoir reçu la liste <code>ClassBinarySignature</code> , vous pouvez l'écrire dans un fichier ou une mémoire à l'aide de la méthode <code>dump(to: Appendable)</code> et la comparer avec la ligne de base, ce qui se produit dans le test <code>RuntimePublicAPITest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimePublicAPITest</span></span></span><span class="hljs-class"> </span></span>{ @[Rule JvmField] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testName = TestName() <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kotlinStdlibRuntimeMerged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../stdlib/jvm/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"kotlin-stdlib"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshotAPIAndCompare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( basePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jarPattern: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, publicPackages: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; = emptyList()</span></span></span></span>, nonPublicPackages: List&lt;String&gt; = emptyList() ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> base = File(basePath).absoluteFile.normalize() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jarFile = getJarPath(base, jarPattern, System.getProperty(<span class="hljs-string"><span class="hljs-string">"kotlinVersion"</span></span>)) println(<span class="hljs-string"><span class="hljs-string">"Reading binary API from </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$jarFile</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api = getBinaryAPI(JarFile(jarFile)).filterOutNonPublic(nonPublicPackages) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target = File(<span class="hljs-string"><span class="hljs-string">"reference-public-api"</span></span>) .resolve(testName.methodName.replaceCamelCaseWithDashedLowerCase() + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>) api.dumpAndCompareWith(target) }</code> </pre> <br><p>  En validant une nouvelle ligne de base, nous obtenons les modifications dans un format lisible, comme, par exemple, dans ce <a href="https://github.com/badoo/Reaktive/pull/312/commits/c8985c15d24346ecfe89cb2ac84fbe7cf6cbeb3e">commit</a> : </p><br><pre> <code class="diff hljs"> public static final fun flattenObservable (Lcom/badoo/reaktive/single/Single;)Lcom/badoo/reaktive/observable/Observable; } + public final class com/badoo/reaktive/single/MapIterableKt { + public static final fun mapIterable (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + public static final fun mapIterableTo (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + } public final class com/badoo/reaktive/single/MapKt {</code> </pre> <br><h2 id="ispolzovanie-validatora-v-svoyom-proekte">  Utiliser un validateur dans votre projet </h2><br><p>  L'utilisation est extrêmement simple.  Copiez <code>binary-compatibility-validator</code> dans votre projet et modifiez son <code>build.gradle</code> et <code>RuntimePublicAPITest</code> : </p><br><pre> <code class="kotlin hljs">plugins { id(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlin.jvm"</span></span>) } dependencies { implementation(Deps.asm) implementation(Deps.asm.tree) implementation(Deps.kotlinx.metadata.jvm) testImplementation(Deps.kotlin.test.junit) } tasks.named(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, Test::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,   -     Gradle       : dependsOn( ":coroutines-interop:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive-testing:jvmJar", ":rxjava2-interop:jar", ":rxjava3-interop:jar", ":utils:jvmJar" ) //    ,          baseline-: outputs.upToDateWhen { false } //    systemProperty("overwrite.output", findProperty("binary-compatibility-override") ?: "true") systemProperty("kotlinVersion", findProperty("reaktive_version").toString()) systemProperty("testCasesClassesDirs", sourceSets.test.get().output.classesDirs.asPath) jvmArgs("-ea") }</span></span></code> </pre> <br><p>  Dans notre cas, l'une des fonctions de test du fichier <code>RuntimePublicAPITest</code> ressemble à ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reaktive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../reaktive/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"reaktive-jvm"</span></span>) }</code> </pre> <br><p>  Maintenant, pour chaque demande d'extraction, exécutez <code>./gradlew :tools:binary-compatibility:test -Pbinary-compatibility-override=false</code> et forcez les développeurs à mettre à jour les fichiers de base à temps. </p><br><h2 id="lozhka-dyogtya">  Voler dans la pommade </h2><br><p>  Cependant, cette approche a quelques mauvais points. </p><br><p>  Tout d'abord, nous devons analyser indépendamment les modifications apportées aux fichiers de référence.  Leurs modifications ne conduisent pas toujours à une incompatibilité binaire.  Par exemple, si vous implémentez une nouvelle interface, vous obtenez une telle différence de référence: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- public final class com/test/A { + public final class com/test/A : Comparable {</span></span></code> </pre> <br><p>  Deuxièmement, des outils qui ne sont pas destinés à cela sont utilisés.  Les tests ne devraient pas avoir d'effets secondaires sous forme d'écriture d'un fichier sur le disque, qui sera ensuite utilisé par le même test, et plus encore, en lui passant des paramètres via des variables d'environnement.  Ce serait formidable d'utiliser cet outil dans un plugin Gradle et de créer une base de référence à l'aide d'une tâche.  Mais je ne veux vraiment pas changer quelque chose par nous-mêmes dans le validateur, afin que plus tard, il soit facile de retirer toutes ses modifications du référentiel Kotlin, car à l'avenir de nouvelles constructions pourraient apparaître dans le langage qui devra être pris en charge. </p><br><p>  Enfin et troisièmement, seule la JVM est prise en charge. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  À l'aide du <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">vérificateur de compatibilité binaire,</a> vous pouvez obtenir la compatibilité binaire et répondre à temps à un changement de son état.  Pour l'utiliser dans le projet, il a fallu modifier seulement deux fichiers et connecter les tests à notre CI.  Cette solution présente certains inconvénients, mais elle est toujours très pratique à utiliser.  Reaktive va maintenant essayer de maintenir la compatibilité binaire pour la JVM de la même manière que JetBrains le fait pour la bibliothèque standard de Kotlin. </p><br><p>  Merci de votre attention! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484712/">https://habr.com/ru/post/fr484712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484700/index.html">Java 14: aperçu des enregistrements</a></li>
<li><a href="../fr484702/index.html">Alternatives à Prestashop en 2020: les meilleures plateformes de commerce électronique</a></li>
<li><a href="../fr484706/index.html">S'entraîner à travailler avec des pneus personnalisés du complexe Redd</a></li>
<li><a href="../fr484708/index.html">Richard Hamming "Chapitre inexistant": Comment savons-nous ce que nous savons (version complète)</a></li>
<li><a href="../fr484710/index.html">Enfreindre les règles de la collecte des ordures Unity</a></li>
<li><a href="../fr484716/index.html">Arrêtez d'appeler tout AI</a></li>
<li><a href="../fr484718/index.html">Les imprimantes modernes HP refusent de travailler sans abonnement à l'encre</a></li>
<li><a href="../fr484720/index.html">Concert pour une ville avec un orchestre: qui et pourquoi enregistre les sons de la vie quotidienne</a></li>
<li><a href="../fr484722/index.html">Quels outils de développement Ruby on Rails conviennent à votre projet: Top Ruby on Rails Gems for 2020</a></li>
<li><a href="../fr484724/index.html">Nouvelles du monde d'OpenStreetMap n ° 494 (12.31.2019-06.01.2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>