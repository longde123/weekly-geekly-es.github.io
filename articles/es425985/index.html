<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìô üéÖüèæ üëæ Ejecuci√≥n de c√≥digo personalizado en GO üö£üèø üë®üèæ‚Äçü§ù‚Äçüë®üèº üíÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En realidad, esto se trata de contratos inteligentes. 
 Pero si no imagina lo que es un contrato inteligente y, en general, est√° lejos de ser criptogr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ejecuci√≥n de c√≥digo personalizado en GO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425985/"><h2>  En realidad, esto se trata de contratos inteligentes. </h2><br>  Pero si no imagina lo que es un contrato inteligente y, en general, est√° lejos de ser criptogr√°fico, entonces puede imaginarse qu√© es un procedimiento almacenado en una base de datos.  El usuario crea piezas de c√≥digo que luego funcionan en nuestro servidor.  Es conveniente para el usuario escribirlos y publicarlos, y es seguro para nosotros ejecutarlos. <br><a name="habracut"></a><br>  Desafortunadamente, a√∫n no hemos desarrollado la seguridad, por lo que ahora no la describir√©, pero dar√© algunas pistas. <br><br>  Tambi√©n escribimos en Go, y su tiempo de ejecuci√≥n impone algunas restricciones muy espec√≠ficas, la principal de las cuales es, en general, no podemos vincularnos a otro proyecto escrito que no est√© en marcha, esto detendr√° nuestro tiempo de ejecuci√≥n cada vez que ejecutemos c√≥digo de terceros.  En general, tenemos la opci√≥n de usar alg√∫n tipo de int√©rprete, para lo cual encontramos un Lua completamente sano y un WASM completamente sano, pero de alguna manera no quiero agregar clientes a Lua, pero con WASM ahora hay m√°s problemas que beneficios, est√° en un estado borrador , que se actualiza cada mes, por lo que esperaremos hasta que se establezca la especificaci√≥n.  Lo usamos como un segundo motor. <br><br>  Como resultado de largas batallas con su propia conciencia, se decidi√≥ escribir contratos inteligentes en GO.  El hecho es que si crea la arquitectura para ejecutar el c√≥digo GO compilado, tendr√° que transferir esta ejecuci√≥n a un proceso separado, como recordar√°, por seguridad, y transferir a un proceso separado es una p√©rdida de rendimiento en IPC, aunque en el futuro, cuando entendamos el volumen del ejecutable c√≥digo, incluso fue de alguna manera agradable que elegimos esta soluci√≥n.  La cuesti√≥n es que es escalable, aunque agrega un retraso a cada llamada individual.  Podemos aumentar muchos tiempos de ejecuci√≥n remotos. <br><br>  Un poco m√°s sobre las decisiones tomadas para que quede claro.  Cada contrato inteligente consta de dos partes, una parte es el c√≥digo de clase y la segunda son los datos del objeto, por lo que en el mismo c√≥digo podemos, una vez que publiquemos el c√≥digo, crear muchos contratos que se comportar√°n b√°sicamente igual, pero con configuraciones diferentes , y con un estado diferente.  Si hablamos m√°s, entonces esto ya se trata de blockchain y no del tema de esta historia. <br><br><h2>  Y entonces, ejecutamos GO </h2><br>  Decidimos usar el mecanismo de complemento, que no solo est√° listo y es bueno.  √âl hace lo siguiente, compilamos lo que ser√° un complemento de una manera especial en una biblioteca compartida, y luego lo cargamos, encontramos los s√≠mbolos en √©l y pasamos la ejecuci√≥n all√≠.  Pero el problema es que GO tiene un tiempo de ejecuci√≥n, y esto es casi un megabyte de c√≥digo, y por defecto este tiempo de ejecuci√≥n tambi√©n va a esta biblioteca, y tenemos un tiempo de ejecuci√≥n raznipipenny en todas partes.  Pero ahora decidimos hacerlo, asegur√°ndonos de que podemos vencerlo en el futuro. <br><br>  Todo es simple cuando construye su biblioteca, la construye con la clave - buildmode = plugin y obtiene el archivo .so, que luego abre. <br><br><pre><code class="go hljs">p, err := plugin.Open(path)</code> </pre> <br>  Buscando el personaje que te interesa: <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(Method)</code> </pre> <br>  Y ahora, dependiendo de si la variable es una funci√≥n o una funci√≥n, puede llamarla o usarla como variable. <br><br>  Bajo el cap√≥ de este mecanismo hay un simple dlopen (3), cargamos la biblioteca, verificamos que sea un complemento y le proporcionamos el contenedor, al crear el contenedor, todos los caracteres exportados se envuelven en la interfaz {} y se almacenan.  Si es una funci√≥n, debe reducirse al tipo correcto de funci√≥n y simplemente llamarse, si es la variable, entonces funcionar como una variable. <br><br>  Lo principal a recordar es que si un s√≠mbolo es una variable, entonces es global durante todo el proceso y no se puede usar sin pensar. <br><br>  Si se ha declarado un tipo en el complemento, entonces tiene sentido colocar este tipo en un paquete separado para que el proceso principal pueda trabajar con √©l, por ejemplo, pasando como argumentos a las funciones del complemento.  Esto es opcional, no puede usar vapor y usar reflejo. <br><br>  Nuestros contratos son objetos de la "clase" correspondiente, y al principio la instancia de este objeto se almacen√≥ en nuestra variable exportada, por lo que podr√≠amos crear otra misma variable: <br><br><pre> <code class="go hljs">export, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"EXPORT"</span></span>) obj := reflect.New(reflect.ValueOf(export).Elem().Type()).Interface()</code> </pre> <br>  Y ya dentro de esta variable local del tipo correcto, deserialice el estado del objeto.  Despu√©s de restaurar el objeto, podemos invocar m√©todos en √©l.  Despu√©s de lo cual el objeto se serializa y se agrega de nuevo a la tienda, saludos, llamamos al m√©todo en el contrato. <br><br>  Si est√° interesado en c√≥mo, pero es demasiado vago para leer la documentaci√≥n, entonces: <br><br><pre> <code class="go hljs">method := reflect.ValueOf(obj).MethodByName(Method) res:= method.Call(in)</code> </pre> <br>  En el medio, tambi√©n debe completar la matriz con interfaces vac√≠as que contengan el tipo correcto de argumento, si est√° interesado, vea por s√≠ mismo c√≥mo se hizo, las fuentes est√°n abiertas, aunque ser√° dif√≠cil encontrar este lugar en la <a href="">historia</a> . <br><br>  En general, todo funcion√≥ para nosotros, puede escribir c√≥digo con algo as√≠ como una clase, ponerlo en la cadena de bloques, crear un contrato de esta clase nuevamente en la cadena de bloques, hacer una llamada al m√©todo y el nuevo estado del contrato se vuelve a escribir en la cadena de bloques.  Genial  ¬øC√≥mo crear un nuevo contrato con el c√≥digo disponible?  Muy simple, tenemos funciones de constructor que devuelven un objeto reci√©n creado, que es el nuevo contrato.  Hasta ahora, todo funciona a trav√©s de la reflexi√≥n y el usuario debe escribir: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EXPORT ContractType</code> </pre> <br>  Para que sepamos qu√© s√≠mbolo es una representaci√≥n del contrato, y realmente lo usamos como plantilla. <br><br>  Realmente no nos gusta.  Y golpeamos fuerte. <br><br><h2>  Analizando </h2><br>  En primer lugar, el usuario no debe escribir nada superfluo, y en segundo lugar, tenemos la idea de que la interacci√≥n del contrato con el contrato debe ser simple y probada sin elevar la cadena de bloques, la cadena de bloques es lenta y dif√≠cil. <br><br>  Por lo tanto, decidimos envolver el contrato en un contenedor, que se genera sobre la base del contrato y la plantilla del contenedor, en principio, una soluci√≥n comprensible.  En primer lugar, el contenedor crea un objeto de exportaci√≥n para nosotros y, en segundo lugar, reemplaza la biblioteca con la que se recopila el contrato cuando el usuario escribe el contrato, la biblioteca de base se usa con los mokas dentro, y cuando se publica el contrato, se reemplaza por uno de combate que funciona con la cadena de bloques en s√≠ . <br><br>  Para comenzar, debe analizar el c√≥digo y comprender lo que generalmente tenemos, encontrar la estructura que se hereda de BaseContract para generar un contenedor a su alrededor. <br><br>  Esto se hace de manera simple, leemos el archivo con el c√≥digo en [] byte, aunque el analizador en s√≠ mismo puede leer los archivos, es bueno tener el texto en alg√∫n lugar al que se refieren todos los elementos AST, se refieren al n√∫mero de bytes en el archivo y en el futuro queremos recibir el c√≥digo de estructura tal como es, simplemente tomamos algo como. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pf *ParsedFile)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codeOfNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(pf.code[n.Pos()<span class="hljs-number"><span class="hljs-number">-1</span></span> : n.End()<span class="hljs-number"><span class="hljs-number">-1</span></span>]) }</code> </pre> <br>  En realidad analizamos el archivo y obtenemos el nodo AST m√°s alto desde el que rastrearemos el archivo. <br><br><pre> <code class="go hljs">fileSet = token.NewFileSet() node, err := parser.ParseFile(fileSet, name, code, parser.ParseComments)</code> </pre> <br>  A continuaci√≥n, recorremos el c√≥digo a partir del nodo superior y recopilamos todo lo interesante en una estructura separada. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, decl := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Decls { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> d := decl.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.GenDecl: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.FuncDecl: ‚Ä¶ } }</code> </pre> <br>  Decls, ya est√° analizado en una matriz, una lista de todo lo que est√° definido en el archivo, pero es una matriz de interfaces Decl que no describe lo que hay dentro, por lo que cada elemento debe convertirse a un tipo espec√≠fico, aqu√≠ los autores del lenguaje se apartaron de su idea de usar interfaces, la interfaz en go / ast es m√°s bien una clase base. <br><br>  Estamos interesados ‚Äã‚Äãen nodos de tipo GenDecl y FuncDecl.  GenDecl es la definici√≥n de una variable o tipo, y debe verificar qu√© es exactamente el tipo dentro y, una vez m√°s, convertirlo al tipo TypeDecl con el que ya puede trabajar.  FuncDecl es m√°s simple: es una funci√≥n, y si tiene el campo Recv lleno, entonces este es un m√©todo de la estructura correspondiente.  Recopilamos todo esto en un almacenamiento conveniente, porque luego usamos texto / plantilla, y no tiene mucho poder expresivo. <br><br>  Lo √∫nico que debemos recordar por separado es el nombre del tipo de datos que se hereda de BaseContract, y vamos a bailar alrededor. <br><br><h2>  Generaci√≥n de c√≥digo </h2><br>  Por lo tanto, conocemos todos los tipos y funciones que est√°n en nuestro contrato y necesitamos poder realizar una llamada a un m√©todo en un objeto desde el nombre del m√©todo entrante y la matriz de argumentos serializados.  Pero despu√©s de todo, en el momento de la generaci√≥n del c√≥digo, conocemos todo el dispositivo del contrato, por lo que colocamos junto a nuestro archivo de contrato junto a otro archivo, con el mismo nombre de paquete, en el que colocamos todas las importaciones necesarias, los tipos ya est√°n definidos en el archivo principal y son innecesarios. <br><br>  Y aqu√≠ est√° lo principal, envoltorios sobre funciones.  El nombre del contenedor se complementa con alg√∫n tipo de prefijo y ahora el contenedor es f√°cil de encontrar. <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"INSMETHOD_"</span></span> + Method) wrapper, ok := symbol.(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ph proxyctx.ProxyHelper, object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, result []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Cada contenedor tiene la misma firma, por lo que cuando lo llamamos desde el programa principal, no necesitamos reflexiones adicionales, lo √∫nico es que los contenedores de funciones son diferentes de los contenedores de m√©todos, no reciben y no devuelven el estado del objeto. <br><br>  ¬øQu√© tenemos dentro del envoltorio? <br><br>  Creamos una matriz de variables vac√≠as que corresponden a los argumentos de la funci√≥n, la colocamos en una variable de tipo una matriz de interfaces y deserializamos los argumentos en ella, si somos un m√©todo, tambi√©n debemos serializar el estado del objeto, generalmente algo as√≠: <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .Methods }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INSMETHOD_</span></span></span></span>{{ $method.Name }}(ph proxyctx.ProxyHelper, object []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, data []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error) { self := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>({{ $.ContractType }}) err := ph.Deserialize(object, self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ $method.ArgumentsZeroList }} err = ph.Deserialize(data, &amp;args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $method.Results }} {{ $method.Results }} := self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ end }} state := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize(self, &amp;state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $i := $method.ErrorInterfaceInRes }} ret{{ $i }} = ph.MakeErrorSerializable(ret{{ $i }}) {{ end }} ret := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} { {{ $method.Results }} }, &amp;ret) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, ret, err } {{ end }}</code> </pre><br>  Un lector atento estar√° interesado en lo que es un ayudante proxy.  - Este es un objeto combinado que todav√≠a necesitamos, pero por ahora usamos su capacidad de serializar y deserializar. <br><br>  Bueno, cualquiera que lea preguntar√°: "Pero estos son sus argumentos, ¬øde d√≥nde son?"  Aqu√≠ tambi√©n hay una respuesta comprensible, s√≠ texto / plantilla, no hay suficientes estrellas del cielo, es por eso que calculamos estas l√≠neas en el c√≥digo, y no en la plantilla. <br><br>  method.ArgumentsZeroList contiene algo como <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> Var arg1 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ‚Äú‚Äù Var arg2 ackwardType = ackwardType{} Args := []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{&amp;arg0, &amp;arg1, &amp;arg2}</code> </pre> <br>  Y Arguments en consecuencia contiene "arg0, arg1, arg2". <br><br>  Por lo tanto, podemos llamar a lo que queramos, con cualquier firma. <br><br>  Pero no podemos serializar ninguna respuesta, el hecho es que los serializadores funcionan con reflexi√≥n, y no da acceso a campos de estructuras no exportados, es por eso que tenemos un m√©todo auxiliar proxy especial que toma un objeto de interfaz de error y crea un objeto de tipo base a partir de √©l. Error, que difiere del habitual en que el texto del error est√° en √©l en el campo exportado, y podemos serializarlo, aunque con alguna p√©rdida. <br><br>  Pero si usamos un esterilizador generador de c√≥digo, entonces ni siquiera lo necesitamos, estamos compilados en el mismo paquete, tenemos acceso a campos no exportados. <br><br><h2>  Pero, ¬øqu√© pasa si queremos llamar a un contrato desde un contrato? </h2><br>  No comprende la profundidad del problema si cree que es f√°cil llamar a un contrato desde un contrato.  El hecho es que la validez de otro contrato debe confirmarse por consenso y el hecho de esta llamada debe firmarse en la cadena de bloques, en general, simplemente compilar con otro contrato e invocar su m√©todo no funcionar√°, aunque realmente quiero hacerlo.  Pero somos amigos de los programadores, por lo que deber√≠amos darles la oportunidad de hacer todo directamente y ocultar todos los trucos bajo el cap√≥ del sistema.  Por lo tanto, el desarrollo del contrato es como si se tratara de llamadas directas, y los contratos se tiran entre s√≠ de manera transparente, pero cuando recopilamos el contrato para su publicaci√≥n, deslizamos un poder en lugar de otro contrato, que solo conoce su direcci√≥n y firmas de llamadas sobre el contrato. <br><br>  ¬øC√≥mo organizar todo esto?  - Tendremos que almacenar otros contratos en un directorio especial que nuestro generador podr√° reconocer y crear proxies para cada contrato que se importe. <br><br>  Es decir, si nos encontramos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ‚ÄúContractsDir/ContractAddress<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  Lo escribimos en la lista de contratos importados. <br><br>  Por cierto, para esto no necesita saber el c√≥digo fuente del contrato, solo necesita conocer la descripci√≥n que ya hemos recopilado, por lo que si publicamos dicha descripci√≥n en alg√∫n lugar y todas las llamadas pasan por el sistema principal, entonces no nos importa qu√© otro contrato est√° escrito en el idioma, si podemos llamar m√©todos en √©l, podemos escribir un tal√≥n para √©l en Go, que se ver√° como un paquete con un contrato al que se puede llamar directamente.  Planes napole√≥nicos, comencemos. <br><br>  En principio, ya tenemos un m√©todo de ayuda proxy, con esta firma: <br><br><pre> <code class="go hljs">RouteCall(ref Address, method <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error)</code> </pre> <br>  Este m√©todo puede llamarse directamente desde el contrato, llama al contrato remoto, devuelve una respuesta serializada que necesitamos analizar y volver a nuestro contrato. <br><br>  Pero es necesario que el usuario tenga todo el aspecto: <br><br><pre> <code class="go hljs">ret := contractPackage.GetObject(Address).Method(arg1,arg2, ‚Ä¶)</code> </pre> <br>  Comencemos, en primer lugar, en el proxy, debe enumerar todos los tipos que se utilizan en las firmas de los m√©todos de contrato, pero como recordamos, para cada nodo AST podemos tomar su representaci√≥n textual, y ahora ha llegado el momento de este mecanismo. <br><br>  Luego, necesitamos crear un tipo de contrato, en principio, √©l ya conoce su clase, solo se necesita una direcci√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> {{ .ContractType }} <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Reference Address }</code> </pre> <br>  A continuaci√≥n, debemos implementar de alguna manera la funci√≥n GetObject, que en la direcci√≥n en la cadena de bloques devolver√° una instancia de proxy que sabe c√≥mo trabajar con este contrato, y para el usuario parece una instancia de contrato. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Address)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ .ContractType }})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;{{ .ContractType }}{Reference: ref} }</code> </pre> <br>  Curiosamente, el m√©todo GetObject en modo de depuraci√≥n del usuario es directamente un m√©todo de estructura BaseContract, pero no hay nada, nada nos impide, observando el SLA, hacer lo que nos conviene.  Ahora podemos crear un contrato de representaci√≥n, cuyos m√©todos controlamos.  Queda por crear realmente los m√©todos. <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .MethodsProxies }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ $.ContractType }})</span></span></span></span> {{ $method.Name }}( {{ $method.Arguments }} ) ( {{ $method.ResultsTypes }} ) { {{ $method.InitArgs }} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argsSerialized []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> err := proxyctx.Current.Serialize(args, &amp;argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } res, err := proxyctx.Current.RouteCall(r.Reference, <span class="hljs-string"><span class="hljs-string">"{{ $method.Name }}"</span></span>, argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } {{ $method.ResultZeroList }} err = proxyctx.Current.Deserialize(res, &amp;resList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {{ $method.Results }} } {{ end }}</code> </pre> <br>  Aqu√≠ la misma historia con la construcci√≥n de la lista de argumentos, ya que somos perezosos y almacenamos exactamente el nodo anterior del m√©todo, para los c√°lculos se requieren muchas conversiones de tipos que las plantillas no conocen, por lo que todo est√° preparado de antemano.  Con las funciones, todo es mucho m√°s complicado, y este es el tema de otro art√≠culo. <br><br>  Las funciones que tenemos son constructores de objetos y se hace mucho hincapi√© en c√≥mo se crean realmente los objetos en nuestro sistema, el hecho de la creaci√≥n se registra en un ejecutor remoto, el objeto se transfiere a otro ejecutor, se verifica y se guarda all√≠, y hay muchas maneras de guardar, en vano Esta √°rea de conocimiento se llama cripta.  Y la idea es b√°sicamente simple, un contenedor dentro del cual solo se almacena la direcci√≥n, y m√©todos que serializan la llamada y extraen nuestro procesador singleton, que hace el resto.  No podemos usar el ayudante de proxy transmitido porque el usuario no nos lo pas√≥, por lo que tuvimos que hacerlo √∫nico. <br><br>  Otro truco: de hecho, todav√≠a usamos el contexto de la llamada, este es un objeto que almacena informaci√≥n sobre qui√©n, cu√°ndo, por qu√©, por qu√© se llam√≥ a nuestro contrato inteligente, en funci√≥n de esta informaci√≥n, el usuario toma la decisi√≥n de dar la ejecuci√≥n, y si es posible entonces como. <br><br>  Anteriormente, simplemente pas√°bamos el contexto, era un campo no expresable en el tipo BaseContract con un setter y getter, y el setter permiti√≥ establecer el campo solo una vez, por lo que el contexto se estableci√≥ antes de que se ejecutara el contrato, y el usuario solo pod√≠a leerlo. <br><br>  Pero aqu√≠ est√° el problema, el usuario solo lee este contexto, si realiza una llamada a alg√∫n tipo de funci√≥n del sistema, por ejemplo, una llamada proxy a otro contrato, entonces esta llamada proxy no recibe ning√∫n contexto, ya que nadie se la pasa.  Y luego el almacenamiento local goroutine entra en escena.  Decidimos no escribir el nuestro, sino usar github.com/tylerb/gls. <br><br>  Le permite establecer y tomar contexto para la rutina actual.  Por lo tanto, si no se cre√≥ una rutina dentro del contrato, solo establecemos el contexto en gls antes de comenzar el contrato, ahora le damos al usuario no un m√©todo, sino solo una funci√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">core</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicCallContext</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gls.Get(<span class="hljs-string"><span class="hljs-string">"ctx"</span></span>).(*core.LogicCallContext) }</code> </pre> <br>  Y felizmente lo usa, pero lo usamos en RouteCall (), por ejemplo, para entender qu√© contrato est√° invocando a alguien actualmente. <br><br>  En principio, el usuario puede crear goroutine, pero si lo hace, entonces el contexto se pierde, por lo que debemos hacer algo con esto, por ejemplo, si el usuario usa la palabra clave go, entonces debemos envolver esas llamadas en nuestro contenedor, que el contexto recordar√° y crear√° goroutine y restaurar el contexto en √©l, pero este es el tema de otro art√≠culo. <br><br><h2>  Todos juntos </h2><br>  B√°sicamente, nos gusta c√≥mo funciona la cadena de herramientas del lenguaje GO, de hecho, es un conjunto de comandos diferentes que hacen una cosa, que se ejecutan juntos cuando se va a construir, por ejemplo.  Decidimos hacer lo mismo, un equipo coloca un archivo de contrato en un directorio temporal, el segundo coloca un contenedor y llama por tercera vez, lo que crea un proxy para cada contrato importado, el cuarto lo compila todo, el quinto lo publica en la cadena de bloques.  Y hay un comando para ejecutarlos todos en el orden correcto. <br><br>  Hurra, ahora tenemos una cadena de herramientas y tiempo de ejecuci√≥n para lanzar GO desde GO.  Todav√≠a hay muchos problemas, por ejemplo, necesita descargar de alguna manera el c√≥digo no utilizado, debe determinar de alguna manera que se cuelga y reiniciar el proceso suspendido, pero estas son tareas que tienen claro c√≥mo resolverlo. <br><br>  S√≠, por supuesto, el c√≥digo que escribimos no pretende ser una biblioteca, no se puede usar directamente, pero leer un ejemplo de generaci√≥n de c√≥digo de trabajo siempre es genial, en un momento lo perd√≠.  En consecuencia, parte de la generaci√≥n de c√≥digo se puede ver en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compilador</a> , pero c√≥mo comienza en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecutor</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425985/">https://habr.com/ru/post/es425985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425973/index.html">C√≥mo creamos el almacenamiento S3 DataLine. Experimentos, pruebas y un poco sobre hipop√≥tamos</a></li>
<li><a href="../es425975/index.html">Convierte palabras y frases a anagramas</a></li>
<li><a href="../es425977/index.html">Flexbox: ¬øqu√© tama√±o tiene esta caja flexible?</a></li>
<li><a href="../es425981/index.html">Newbie‚Äôs Career at LK: pasos agigantados para avanzar lentamente</a></li>
<li><a href="../es425983/index.html">Seguridad de vuelo</a></li>
<li><a href="../es425989/index.html">Bajo el cap√≥ de Graveyard Keeper: c√≥mo se implementan los efectos gr√°ficos</a></li>
<li><a href="../es425991/index.html">C√≥mo creamos hosting</a></li>
<li><a href="../es425993/index.html">C√≥mo cerrar la brecha de g√©nero en tecnolog√≠a</a></li>
<li><a href="../es425995/index.html">Visualice FHIR: el est√°ndar de TI para la medicina</a></li>
<li><a href="../es425997/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 11: Ur / Lenguaje de programaci√≥n web, Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>