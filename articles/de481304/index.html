<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👁️ 🦌 📙 Amerikanische Flagge sortieren 🧐 😥 ☣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um das Funktionsprinzip dieser "Multiband" -Sortierung zu verstehen, ist es einfacher, mit einem Beispiel einer Flagge mit drei Streifen zu beginnen. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Amerikanische Flagge sortieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/481304/"><div style="text-align:center;"><img width="690" height="410" src="https://habrastorage.org/webt/3c/qf/bc/3cqfbc2j6t1knu0g3onxuvrgve8.png"></div><br>  Um das Funktionsprinzip dieser "Multiband" -Sortierung zu verstehen, ist es einfacher, mit einem Beispiel einer Flagge mit drei Streifen zu beginnen.  Und um die Dreifarben-Flagge leichter handhaben zu können, ist es besser, zuerst zu sehen, wie sie mit dem Zweifarben-Beispiel funktioniert.  <s>Und mit zwei Farben umgehen ...</s> <a name="habracut"></a><blockquote> <a href="https://www.edsd.ru/" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a> <br clear="right">  Dieser Artikel wurde mit der Unterstützung von EDISON verfasst. <br><br>  Wir befassen uns mit der <a href="https://www.edsd.ru/ru/uslugi/portirovanie-i-migracija">Portierung und Migration von Software</a> sowie der <a href="https://www.edsd.ru/ru/proekty/mobilnye_prilozhenija">Entwicklung mobiler Anwendungen für Android und iOS</a> . <br><br>  Wir lieben die Theorie der Algorithmen!  ;-) </blockquote><h2>  Zweifarbige Flagge </h2><br><img align="left" width="210" height="140" src="https://habrastorage.org/webt/rw/ya/rz/rwyarz78jggve0idacvf3k6jxs0.png"><br clear="right">  Betrachten Sie zunächst den Fall, in dem die Zahlen im sortierten Array in nur zwei Bits verteilt sind.  Der Einfachheit halber nehmen wir an, dass wir ein Array von Nullen (niedriger Ordnung) und Einsen (hoher Ordnung) haben. <br><br>  Wir haben also nur zwei "Bänder": In einem werden wir die niedrigstwertigen Bits (Nullen) und in dem anderen die höchsten Bits (Einheiten) verschieben.  Jede zweifarbige Flagge dient zur Demonstration.  Zum Beispiel die Flagge der Ukraine. <br><br><img width="740" height="94" src="https://habrastorage.org/webt/av/g1/6q/avg16qxef8rxv9etteutswrkrke.gif"><br><br>  Was ist hier los?  Da in der ersten Phase nicht bekannt ist, wie viele Nullen und wie viele Einheiten wir haben, ist unklar, in welcher Größe die einzelnen „Bänder“ enden werden.  Daher setzen wir zwei Zeiger auf die Tasten des Arrays.  Bei niedriger Ordnung wird der Zeiger an den Anfang des Arrays gesetzt, bei hoher Ordnung an das Ende.  Dann durchlaufen wir das Array einmal von links nach rechts und betrachten jedes Bitelement. <br><br>  Wenn während der Passage ein Element der höchsten Ordnung entspricht, teilt uns der zweite Zeiger mit, wohin dieses Element übertragen werden soll (wir führen einen Austausch durch).  Der Zeiger zum Einfügen des nächsten Elements bewegt sich nach links, der "Streifen" für die übergeordnete Ziffer hat sich erweitert. <br><br>  Wenn es gleich der niedrigstwertigen Ziffer ist, bewegen wir den Zeiger dafür um ein Element nach rechts.  Da wir nur zwei Ziffern haben, muss das Element nicht übertragen werden, es ist bereits an seiner Stelle.  Der „Streifen“ für die jüngere Kategorie wurde natürlich breiter. <br><br>  Infolgedessen kollidieren zwei aufeinander zu bewegende Zeiger an einem Punkt, und die Entladungen werden in ihren "Bändern" angeordnet.  Gleichzeitig müssen Sie nicht das gesamte Array durchlaufen - wenn sich die Zeiger irgendwo in der Mitte treffen, erledigt der Algorithmus seine Aufgabe. <br><br><h2>  Das Problem der niederländischen Nationalflagge :: Das Problem der niederländischen Nationalflagge </h2><br><img align="left" width="210" height="140" src="https://habrastorage.org/webt/qq/cm/rv/qqcmrvjuvvyqo7ihytacypnh1li.png"><br clear="right">  Wir erschweren die Aufgabe ein wenig und berücksichtigen nicht zwei, sondern drei Ziffern.  Lassen Sie uns die Elemente des Arrays zu den niedrigsten (Nullen), mittleren (Einheiten) und höheren (zwei) Ziffern gehören. <br><br>  Zur Demonstration nehmen wir die dreifache rot-weiß-blaue Flagge von <s>Frankreich,</s> <s>Luxemburg von</s> <s>Russland und</s> <s>Schleswig-Goldstein von den</s> Niederlanden.  Warum genau die Flagge der Niederlande?  Denn Edsger Dijkstra hat in seinen Vorlesungen am Beispiel dieser Flagge den entsprechenden Algorithmus untersucht, der als "Aufgabe der niederländischen Nationalflagge" bezeichnet wurde. <br><br><img width="735" height="95" src="https://habrastorage.org/webt/yl/hy/b6/ylhyb69kavw2mki9nmk0_idsxcq.gif"><br><br>  Wie Sie sehen, gibt es nichts besonders Neues.  Jede Kategorie hat einen eigenen Zeiger.  Anfangs nehmen die Beschriftungen für Junior und Middle die Startpositionen am Anfang des Arrays ein und bewegen sich nach rechts, wenn das entsprechende Element angetroffen wird.  Der Zeiger für die höhere Ordnung befindet sich zuerst am Ende des Arrays und bewegt sich nach links. <br><br>  Das Durchlaufen des Arrays ist auch in der Tat unvollständig. Wenn die Bits mehr oder weniger gleichmäßig verteilt sind, durchläuft der Algorithmus 2/3 des Arrays, bevor alle Elemente in seinen "Bändern" gestreut werden. <br><br><h2>  Amerikanische Flagge sortieren :: Amerikanische Flagge sortieren </h2><br><img align="left" width="285" height="150" src="https://habrastorage.org/webt/2u/bb/hq/2ubbhq_rmqqxo6hj9blipmfppnq.png"><br clear="right">  Nun können wir in unseren Erläuterungen zur amerikanischen Multiband-Flagge übergehen. <br><br>  Wenn wir nicht zwei, nicht drei, sondern eine beliebige Anzahl von Ziffern haben, legen wir fest, wo jede Ziffer beginnen soll (ihr "Band") und zeichnen die Elemente in ihren "Bändern" neu. <br><br>  In diesem Algorithmus werden Zahlen normalerweise nicht als Dezimalzahl, sondern in einer anderen Bittiefe betrachtet, wobei es sich meistens um eine Zweierpotenz handelt.  Häufig wird die Zahl 256 als Grundlage für die Bittiefe verwendet (etwas seltener als 128), sodass Sie die Sortierung effizient anpassen können, um Zeichenfolgen anzuordnen.  Bei Zahlen für die Bittiefe ist es zweckmäßiger, kleine 2 <sup>n</sup> (2, 4, 16 usw.) zu verwenden, um den Vergleich durch Verschieben um Bits zu ermöglichen, anstatt beim Vergleich von Dezimalzahlen zu einer Potenz zu werden. <br><br>  Die Animation zeigt ein Beispiel für die Bittiefe mit Basis 16: <br><br><img width="740" height="328" src="https://habrastorage.org/webt/tm/mf/lk/tmmflkyrfqa3bqrlucv8y-rzcfk.gif"><br><br><ol><li>  Suchen Sie beim ersten Durchgang nach dem Maximum, um die maximale Anzahl von Bits unter den Elementen im Array zu bestimmen (um die vom Konto bestimmten Bits korrekt aus den Elementen zu extrahieren). </li><li>  Dann erfolgt eine rekursive Verarbeitung.  Beim Aufruf werden die Grenzen des Subarrays und das aktuell verarbeitete Bit angezeigt.  Beim ersten Aufruf ist das gesamte Array ein Subarray, das erste Bit links wird genommen. </li><li>  Unter den Elementen des Subarrays wird eine anfängliche Berechnung durchgeführt - wie oft kommt jede Ziffer in der aktuellen Kategorie vor.  Mit dieser Anzahl können Sie die Lokalisierung für diese Ziffern der Ziffern bestimmen (dh, die Grenzen und die Position des "Bandes", in das Sie die Elemente verschieben möchten, die die nächste Ziffer in einer bestimmten Ziffer haben, sind bekannt).  Tatsächlich sind Lokalisierungen Zeiger auf „Bänder“, in denen die entsprechenden Elemente verschoben werden müssen. </li><li>  Entsprechend den Lokalisierungszeigern findet ein Umtausch vor Ort statt - die Ziffer in der Kategorie zeigt an, wohin Sie den Artikel senden möchten, an dessen Stelle kommt ein weiterer Artikel, mit dem der Umtausch stattgefunden hat.  Diese Klausel wird ausgeführt, bis beim nächsten Austausch ein Element, das von einer anderen Stelle ankommt, nicht an seiner Stelle ist (dann können Sie zum nächsten Element des Subarrays übergehen und diese Klausel auf ähnliche Weise für dieses Element ausführen). </li><li>  Nachdem durch den Austausch die Elemente in der nächsten Ziffer durch Zahlen in Blöcke umverteilt wurden, findet eine Rekursion statt - für jeden Block wird derselbe Algorithmus als Subarray angewendet, der nächste als aktuelle Ziffer. </li></ol><br>  In dem Artikel über das <a href="https://habr.com/ru/post/478654/">Zählen von Sortierungen mit einer ungefähren Verteilung</a> gibt es einen visuell sehr ähnlichen Algorithmus - die <b>Annäherungssortierung</b> .  Dort haben wir gezählt, wie oft jede Zahl im Array vorgekommen ist - und die Elemente entsprechend den erhaltenen Lokalisierungen neu verteilt.  Hier zählen wir, wie oft jede Ziffer in der Kategorie für Subarray-Elemente vorkommt - und verteilen die Elemente in dem Subarray entsprechend den erhaltenen Lokalisierungen.  Wenn Annäherung eine Art Zählsortierung ist, dann ist "amerikanisch" eine Zählbit-Sortierung. <br><br><div class="spoiler">  <b class="spoiler_title">American Flag Sort - Python-Implementierung</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#           def get_radix_val(x, digit, radix) -&gt; int: return int(floor(x / radix**digit)) % radix #             def compute_offsets(a_list, start: int, end: int, digit, radix) -&gt; list: #          counts = [0 for _ in range(radix)] for i in range(start, end): #        #         val = get_radix_val(a_list[i], digit, radix) counts[val] += 1 #       #          offsets = [0 for _ in range(radix)] sum = 0 #         for i in range(radix): offsets[i] = sum sum += counts[i] return offsets #      def swap(a_list, offsets, start: int, end: int, digit, radix) -&gt; None: i = start #          next_free = copy(offsets) #        #   (       ) cur_block = 0 while cur_block &lt; radix-1: # if i &gt;= start + offsets[cur_block+1]: cur_block += 1 continue radix_val = get_radix_val(a_list[i], digit, radix) if radix_val == cur_block: i += 1 continue swap_to = next_free[radix_val] a_list[i], a_list[swap_to] = a_list[swap_to], a_list[i] next_free[radix_val] += 1 #   def american_flag_sort_helper(a_list, start: int, end: int, digit, radix) -&gt; None: #          offsets = compute_offsets(a_list, start, end, digit, radix) #      swap(a_list, offsets, start, end, digit, radix) if digit == 0: #     ? return #   #       for i in range(len(offsets)-1): #      #         american_flag_sort_helper(a_list, offsets[i], offsets[i+1], digit-1, radix) #   def american_flag_sort(a_list, radix) -&gt; None: #,         for x in a_list: assert(type(x) == int) #    max_val = max(a_list) #    (  ) max_digit = int(floor(log(max_val, radix))) #   -     american_flag_sort_helper(a_list, 0, len(a_list), max_digit, radix)</span></span></code> </pre> </div></div><br><h2>  Ska sort :: Ska sort </h2><br>  Der deutsche Programmierer Malte Skarupke gab bekannt, dass er einen neuen Sortieralgorithmus entwickelt hat, der eine radikal verbesserte „amerikanische Flagge“ darstellt und <b>std :: sort</b> durchschnittlich zweimal übertrifft (std :: sort - ein Algorithmus, der auch als <b>introspektives Sortieren bezeichnet wird)</b> - Ein Hybrid aus <b>schnellem Sortieren</b> und <b>Sortieren nach Haufen</b> . <br><br><ol><li>  Das Array wird rekursiv sortiert. Auf der ersten Rekursionsebene wird das gesamte Array als Subarray betrachtet. </li><li>  Wenn das Subarray weniger als 128 Elemente enthält, wird std :: sort dafür aufgerufen. </li><li>  Wenn das Subarray 128 bis 1024 Elemente enthält, wird die amerikanische Flaggensortierung dafür aufgerufen. </li><li>  Wenn ein Subarray mehr als 1024 Elemente enthält, wird die Ska-Sortierung dafür aufgerufen. </li><li>  Um den schlimmsten Fall zu vermeiden, wechselt der Algorithmus auch dann zu <nobr>std :: sort</nobr> , wenn die rekursive Verschachtelung zu groß ist (mehr als 16 Ebenen), selbst wenn das Subarray mehr als 128 Elemente enthält. </li></ol><br>  Anscheinend ist es ein sehr effektiver und gleichzeitig äußerst komplexer Algorithmus - die Implementierung des Autors dauert fast anderthalbtausend Zeilen.  Vielleicht werden wir diese Sortierung eines Tages in Betracht ziehen, jetzt werden wir nicht mehr darauf eingehen.  Interessenten können auf die unten stehenden Links klicken. <br><br><h2>  Referenzen </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Problem der niederländischen Nationalflagge</a> , <a href="https://en.wikipedia.org/wiki/American_flag_sort">Art der amerikanischen Flagge</a> <br><br>  <b>Ska Art:</b> <img width="30" height="30" src="https://habrastorage.org/webt/-p/f7/fs/-pf7fshzu943ul4yvkrw2f4dv1g.png">  Ich habe einen schnelleren Sortieralgorithmus geschrieben ( <a href="https://probablydance.com/2016/12/27/i-wrote-a-faster-sorting-algorithm/">Teil 1</a> , <a href="https://probablydance.com/2017/01/17/faster-sorting-algorithm-part-2/">Teil 2</a> ) <img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png">  <a href="https://github.com/skarupke/ska_sort/">Github-Code</a> <br><br><h3>  Serienartikel: </h3><ul><li>  <a href="https://habr.com/post/414447/">Excel-Anwendung AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Sortierungen austauschen</a> </li><li>  <a href="https://habr.com/post/415935/">Einfügesortierung</a> </li><li>  <a href="https://habr.com/post/422085/">Nach Auswahl sortieren</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Sortierungen zusammenführen</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Nach Verteilung sortieren</a> <ul><li>  <a href="https://habr.com/ru/post/478654/">Zählsorten mit ungefährer Verteilung</a> </li><li>  <b>Amerikanische Flagge sortieren</b> </li><li>  Suffixbaum in bitweiser Sortierung </li><li>  Sortierungen nach Verteilung vergleichen </li></ul></li><li>  <a href="https://habr.com/ru/post/483786/">Hybrides Sortieren</a> </li></ul><br>  In der AlgoLab Excel-Anwendung wurde die Sortierung nach einem zweifarbigen Flag (sortiert Nullen und Einsen), einem dreifarbigen Flag (sortiert Nullen, Einsen und Zweien) und der amerikanischen Flagge angezeigt.  Um die „amerikanische Flagge“ zu sortieren, können Sie (in einem Kommentar zu der Zelle mit dem Namen des Algorithmus) das zu verteilende Zahlensystem angeben - der Standardwert ist hexadezimal. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481304/">https://habr.com/ru/post/de481304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481288/index.html">Redux Toolkit als Werkzeug für eine effektive Redux-Entwicklung</a></li>
<li><a href="../de481290/index.html">HOW-to / Network- und VLAN-Einstellungen auf einem dedizierten Hetzner- und Mikrotik-Server</a></li>
<li><a href="../de481294/index.html">Die 10 besten Tools zur Softwaretestautomatisierung</a></li>
<li><a href="../de481296/index.html">Wie schreibe ich Code, der wiederverwendet wird?</a></li>
<li><a href="../de481302/index.html">"About, yes not a cluster" oder wie wir DBMS importiert haben</a></li>
<li><a href="../de481306/index.html">Einführung von werf 1.0 stable: Was hat GitOps damit zu tun, Status und Pläne</a></li>
<li><a href="../de481312/index.html">Santa's Lost Gifts: Ankündigung einer IT-Quest für den 6. Januar</a></li>
<li><a href="../de481314/index.html">DIY Crawler Plattform für Roboter und Unterhaltung</a></li>
<li><a href="../de481316/index.html">Erstellen eines Microservice-Blogs - Teil 4 Post-Service</a></li>
<li><a href="../de481318/index.html">Hacking mit Unicode (am Beispiel von GitHub)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>