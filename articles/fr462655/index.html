<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎓 🚍 📿 Tapez enfin votre code 🍵 🤷🏼 👨🏻‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Habr! 


 L'autre jour, j'ai à nouveau obtenu le code de type 


if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tapez enfin votre code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462655/"><p>  Salut Habr! </p><br><p>  L'autre jour, j'ai à nouveau obtenu le code de type </p><br><pre><code class="plaintext hljs">if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broken channels, however we could not differ it from just not started cold system. // Therefore write this case into the logs and then in case of emergency IT Ops will able to gather the target line Log.Info("Channel {0} is broken or was not started yet", someParameter.Key) }</code> </pre> <br><p>  Il y a une caractéristique assez importante dans le code: le destinataire aimerait beaucoup savoir ce qui s'est réellement passé.  En effet, dans un cas, nous avons des problèmes avec le système, et dans l'autre, nous nous réchauffons.  Cependant, le modèle ne nous donne pas cela (pour faire plaisir à l'expéditeur, qui est souvent l'auteur du modèle). <br>  De plus, même le fait «peut-être que quelque chose ne va pas» vient du fait que la collection <code>Volatilities</code> vide.  Ce qui dans certains cas peut être correct. </p><br><p>  Je suis sûr que la plupart des développeurs expérimentés du code ont vu des lignes qui contenaient des connaissances secrètes dans le style "si cette combinaison de drapeaux est définie, alors on nous demande de faire A, B et C" (bien que cela ne soit pas visible par le modèle lui-même). </p><br><p>  De mon point de vue, de telles économies sur la structure des classes ont un impact extrêmement négatif sur le projet à l'avenir, le transformant en un ensemble de hacks et de béquilles, transformant progressivement un code plus ou moins pratique en héritage. </p><br><p>  <strong>Important:</strong> dans l'article, je donne des exemples utiles pour des projets dans lesquels plusieurs développeurs (et non un), plus qui seront mis à jour et développés pendant au moins 5-10 ans.  Tout cela n'a aucun sens si le projet a un développeur pendant cinq ans, ou si aucun changement n'est prévu après la sortie.  Et il est logique, si le projet n'est nécessaire que pour quelques mois, il est inutile d'investir dans un modèle de données clair. </p><br><p>  Cependant, si vous jouez longtemps - bienvenue au chat. </p><a name="habracut"></a><br><h1 id="ispolzuyte-pattern-visitor">  Utiliser le modèle de visiteur </h1><br><p>  Souvent, le même champ contient un objet qui peut avoir différentes significations sémantiques (comme dans l'exemple).  Cependant, pour sauvegarder les classes, le développeur ne laisse qu'un seul type, en lui fournissant des drapeaux (ou des commentaires dans le style "s'il n'y a rien ici, alors rien n'a été compté").  Une approche similaire peut masquer une erreur (ce qui est mauvais pour le projet, mais pratique pour l'équipe qui fournit le service, car les bogues ne sont pas visibles de l'extérieur).  Une option plus correcte, qui permet même à l'extrémité du fil de savoir ce qui se passe réellement, est d'utiliser l'interface + les visiteurs. </p><br><p>  Dans ce cas, l'exemple de l'en-tête se transforme en code du formulaire: </p><br><pre> <code class="plaintext hljs">class Response { public IVolatilityResponse Data { get; } } interface IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) } class VolatilityValues : IVolatilityResponse { public Surface Data; TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } class CalculationIsBroken : IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } interface IVolatilityResponseVisitor&lt;TInput, TOutput&gt; { TOutput Visit(VolatilityValues instance, TInput input); TOutput Visit(CalculationIsBroken instance, TInput input); }</code> </pre> <br><p>  Avec ce type de traitement: </p><br><ul><li>  Nous avons besoin de plus de code.  Hélas, si nous voulons exprimer plus d'informations dans le modèle, cela devrait être plus. </li><li>  En raison de ce type d'héritage, nous ne pouvons plus sérialiser la <code>Response</code> à <code>json</code> / <code>protobuf</code> , car les informations de type y sont perdues.  Nous devrons créer un conteneur spécial qui fera cela (par exemple, vous pouvez créer une classe qui contient un champ séparé pour chaque implémentation, mais un seul d'entre eux sera rempli). </li><li>  L'extension du modèle (c'est-à-dire l'ajout de nouvelles classes) nécessite d'étendre l' <code>IVolatilityResponseVisitor&lt;TInput, TOutput&gt;</code> , ce qui signifie que le compilateur le forcera à être pris en charge dans le code.  Le programmeur n'oubliera pas de traiter le nouveau type, sinon le projet ne sera pas compilé. </li><li>  En raison de la saisie statique, nous n'avons pas besoin de stocker la documentation quelque part avec des combinaisons possibles de champs, etc.  Nous avons décrit toutes les options possibles dans du code compréhensible à la fois pour le compilateur et pour la personne.  Nous n'aurons pas de désynchronisation entre la documentation et le code, car nous pouvons nous passer du premier. </li></ul><br><h2 id="pro-ogranichenie-nasledovaniya-v-drugih-yazykah">  À propos de la restriction de l'héritage dans d'autres langues </h2><br><p>  Un certain nombre d'autres langues (par exemple, <code>Scala</code> ou <code>Kotlin</code> ) ont des mots clés qui vous permettent d'interdire l'héritage d'un certain type, sous certaines conditions.  Ainsi, au stade de la compilation, nous connaissons tous les descendants possibles de notre type. </p><br><p>  En particulier, l'exemple ci-dessus peut être réécrit dans <code>Kotlin</code> comme ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: IVolatilityResponse ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityResponse</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityValues</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: Surface } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalculationIsBroken</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>()</code> </pre><br><p>  Il s'est avéré un peu moins que le code, mais maintenant dans le processus de compilation, nous savons que tous les <code>VolatilityResponse</code> possibles sont dans le même fichier avec lui, ce qui signifie que le code suivant ne sera pas compilé, car nous n'avons pas parcouru toutes les valeurs possibles de la classe. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString() }</code> </pre> <br><p>  Cependant, il convient de rappeler que ces vérifications ne fonctionnent que pour les appels fonctionnels.  Le code ci-dessous se compilera sans erreur: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; println(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString()) } }</code> </pre> <br><h1 id="ne-vse-primitivnye-tipy-oznachayut-odno-i-to-zhe">  Tous les types primitifs ne signifient pas la même chose </h1><br><p>  Considérons un développement relativement typique d'une base de données.  Très probablement, quelque part dans le code, vous aurez des identificateurs d'objet.  Par exemple: </p><br><pre> <code class="plaintext hljs">class Group { public int Id { get; } public string Name { get; } } class User { public int Id { get; } public int GroupId { get; } public string Name { get; } }</code> </pre> <br><p>  Cela ressemble à un code standard.  Les types correspondent même à ceux de la base de données.  Cependant, la question est: le code ci-dessous est-il correct? </p><br><pre> <code class="plaintext hljs">public bool IsInGroup(User user, Group group) { return user.Id == group.Id; } public User CreateUser(string name, Group group) { return new User { Id = group.Id, GroupId = group.Id, name = name } }</code> </pre> <br><p>  La réponse est très probablement non, car nous comparons l' <code>Id</code> utilisateur et l' <code>Id</code> groupe dans le premier exemple.  Et dans le second, nous avons défini par erreur l' <code>id</code> de <code>Group</code> comme l' <code>id</code> de <code>User</code> . </p><br><p>  Curieusement, c'est assez simple à corriger: obtenez simplement les types <code>GroupId</code> , <code>UserId</code> et ainsi de suite.  Ainsi, la création d' <code>User</code> ne fonctionnera plus, car vos types ne convergeront pas.  Ce qui est incroyablement cool, car vous pouvez informer le compilateur du modèle. </p><br><p>  De plus, les méthodes avec les mêmes paramètres fonctionneront correctement pour vous, car maintenant elles ne seront plus répétées: </p><br><pre> <code class="plaintext hljs">public void SetUserGroup(UserId userId, GroupId groupId) { /* some sql code */ }</code> </pre> <br><p>  Revenons cependant à l'exemple de comparaison des identifiants.  C'est un peu plus compliqué, car vous devez empêcher le compilateur de comparer l'incomparable pendant le processus de construction. </p><br><p>  Et vous pouvez le faire comme suit: </p><br><pre> <code class="plaintext hljs">class GroupId { public int Id { get; } public bool Equals(GroupId groupId) =&gt; Id == groupId?.Id; [Obsolete("GroupId can be equal only with GroupId", error: true)] public override bool Equals(object obj) =&gt; Equals(obj as GroupId) public static bool operator==(GroupId id1, GroupId id2) { if(ReferenceEquals(id1, id2)) return true; if(ReferenceEquals(id1, null) || ReferenceEquals(id2, null)) return false; return id1.Id == id2.Id; } [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(object _, GroupId __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(GroupId _, object __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") }</code> </pre> <br><p>  En conséquence: </p><br><ul><li>  Nous avions encore besoin de plus de code.  Hélas, si vous voulez donner plus d'informations au compilateur, vous devez souvent écrire plus de lignes. </li><li>  Nous avons créé de nouveaux types (nous parlerons des optimisations ci-dessous), ce qui peut parfois dégrader légèrement les performances. </li><li>  Dans notre code: <br><ul><li>  Nous avons interdit de confondre les identifiants.  Le compilateur et le développeur voient maintenant clairement qu'il est impossible de <code>GroupId</code> champ <code>GroupId</code> dans le champ <code>GroupId</code> </li><li>  Il nous est interdit de comparer l'incomparable.  Je <code>IEquitable</code> que le code de comparaison n'est pas complètement terminé (il est également souhaitable d'implémenter l'interface <code>IEquitable</code> , vous devez également implémenter la méthode <code>GetHashCode</code> ), donc l'exemple n'a pas seulement besoin d'être copié dans le projet.  Cependant, l'idée elle-même est claire: nous avons explicitement interdit au compilateur d'exprimer quand les mauvais types ont été comparés.  C'est-à-dire  au lieu de dire "ces fruits sont-ils égaux?"  le compilateur voit maintenant "est une poire égale à une pomme?". </li></ul></li></ul><br><h2 id="nemnogo-esche-ob-sql-i-ob-ogranicheniyah">  Un peu plus sur SQL et ses limites </h2><br><p>  Souvent, dans nos demandes de types, des règles supplémentaires sont introduites et faciles à vérifier.  Dans le pire des cas, un certain nombre de fonctions ressemblent à ceci: </p><br><pre> <code class="plaintext hljs">void SetName(string name) { if(name == null || name.IsEmpty() || !name[0].IsLetter || !name[0].IsCapital || name.Length &gt; MAX_NAME_COLUMN_LENGTH) { throw .... } /**/ }</code> </pre> <br><p>  Autrement dit, la fonction prend un type d'entrée assez large, puis exécute les vérifications.  Ce n'est généralement pas le cas puisque: </p><br><ul><li>  Nous n'avons pas expliqué au programmeur et au compilateur ce que nous voulons ici. </li><li>  Dans une autre fonction similaire, vous devrez copier les chèques. </li><li>  Lorsque nous avons reçu une <code>string</code> qui indiquera le <code>name</code> , nous ne sommes pas tombés immédiatement, mais pour une raison quelconque, l'exécution a continué de tomber sur quelques instructions de processeur plus tard. </li></ul><br><p>  Le comportement correct: </p><br><ul><li>  Créez un type distinct (dans notre cas, apparemment, <code>Name</code> ). </li><li>  Dans ce document, effectuez toutes les validations et vérifications nécessaires. </li><li>  Enveloppez la <code>string</code> dans <code>Name</code> aussi rapidement que possible pour obtenir une erreur aussi rapidement que possible. </li></ul><br><p>  En conséquence, nous obtenons: </p><br><ul><li>  Moins de code, car nous avons vérifié les vérifications de <code>name</code> dans le constructeur. </li><li>  Stratégie <em>Fail Fast</em> - maintenant, ayant reçu un nom problématique, nous tomberons immédiatement, au lieu d'appeler quelques méthodes supplémentaires, mais tomberons toujours.  De plus, au lieu d'une erreur d'une base de données de type type trop volumineux, nous découvrons immédiatement que cela n'a même aucun sens de commencer même à traiter de tels noms. </li><li>  Il est déjà plus difficile pour nous de mélanger les arguments si la signature de la fonction est: <code>void UpdateData(Name name, Email email, PhoneNumber number)</code> .  Après tout, nous passons maintenant non pas trois <code>string</code> identiques, mais trois entités différentes différentes. </li></ul><br><h2 id="nemnogo-o-privedenii-tipov">  Un peu de casting </h2><br><p>  En introduisant un typage assez strict, il ne faut pas non plus oublier que lors du transfert de données vers Sql, nous avons encore besoin d'obtenir un véritable identifiant.  Et dans ce cas, il est logique de mettre à jour légèrement les types qui encapsulent une <code>string</code> : </p><br><ul><li>  Ajouter une implémentation d'une interface de l'interface de formulaire <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code>  <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code> .  Dans ce cas, dans la couche de traduction en SQL, nous pouvons obtenir la valeur directement </li><li>  Au lieu de créer un tas de types plus ou moins identiques dans le code, vous pouvez créer un ancêtre abstrait et en hériter le reste.  Le résultat est un code de la forme: </li></ul><br><pre> <code class="plaintext hljs">interface IValueGet&lt;TValue&gt; { TValue Wrapped { get; } } abstract class BaseWrapper : IValueGet&lt;TValue&gt; { protected BaseWrapper(TValue initialValue) { Wrapped = initialValue; } public TValue Wrapped { get; private set; } } sealed class Name : BaseWrapper&lt;string&gt; { public Name(string value) :base(value) { /*no necessary validations*/ } } sealed class UserId : BaseWrapper&lt;int&gt; { public UserId(int id) :base(id) { /*no necessary validations*/ } }</code> </pre> <br><h1 id="proizvoditelnost">  Performances </h1><br><p>  En parlant de créer un grand nombre de types, vous pouvez souvent rencontrer deux arguments dialectiques: </p><br><ul><li>  Plus il y a de types, d'imbrication et de code, plus le logiciel est lent, car il est plus difficile pour jit d'optimiser le programme.  Par conséquent, ce type de frappe stricte entraînera de sérieux freins dans le projet. </li><li>  Plus il y a de wrappers, plus l'application mange de mémoire.  Par conséquent, l'ajout de wrappers augmentera considérablement les besoins en RAM. </li></ul><br><p>  À strictement parler, les deux arguments sont souvent présentés sans faits, cependant: </p><br><ul><li>  En fait, dans la plupart des applications sur le même java, les chaînes (et les tableaux d'octets) occupent la mémoire principale.  Autrement dit, il est peu probable que la création de wrappers soit perceptible par l'utilisateur final.  Cependant, en raison de ce type de frappe, nous obtenons un avantage important: lors de l'analyse d'un vidage de mémoire, vous pouvez évaluer la contribution de chacun de vos types à la mémoire.  Après tout, vous ne voyez pas seulement une liste anonyme de lignes réparties sur le projet.  Au contraire, nous pouvons comprendre quels types d'objets sont plus grands.  De plus, étant donné que seuls les wrappers contiennent des chaînes et d'autres objets massifs, il est plus facile pour vous de comprendre la contribution de chaque type d'encapsuleur particulier à la mémoire partagée. </li><li>  L'argument de l'optimisation jit est en partie vrai, mais il n'est pas complètement complet.  En effet, du fait d'un typage strict, votre logiciel commence à se débarrasser de nombreux contrôles à l'entrée des fonctions.  Tous vos modèles sont vérifiés pour l'adéquation dans leur conception.  Ainsi, dans le cas général, vous aurez moins de contrôles (il suffit de simplement demander le bon type).  De plus, du fait que les chèques sont transférés au constructeur, et non étalés par du code, il devient plus facile de déterminer lesquels d'entre eux prennent vraiment du temps. </li><li>  Malheureusement, dans cet article, je ne peux pas donner un test de performance à part entière, qui compare le projet avec un grand nombre de microtypes et avec le développement classique, en utilisant uniquement <code>int</code> , <code>string</code> et autres types primitifs.  La raison principale est que pour cela, vous devez d'abord faire un projet audacieux typique pour le test, puis justifier que ce projet particulier est typique.  Et avec le deuxième point, tout est compliqué, car dans la vraie vie les projets sont vraiment différents.  Cependant, il sera plutôt étrange de faire des tests synthétiques, car, comme je l'ai déjà dit, la création d'objets microtypes dans les applications Enterprise, selon mes mesures, a toujours laissé des ressources négligeables (au niveau de l'erreur de mesure). </li></ul><br><h2 id="kak-mozhno-optimizirovat-kod-sostoyaschiy-iz-bolshogo-chisla-podobnyh-mikrotipov">  Comment pouvez-vous optimiser un code composé d'un grand nombre de ces microtypes. </h2><br><p>  <strong>Important: vous</strong> ne <strong>devez</strong> gérer de telles optimisations que lorsque vous recevez des faits garantis que ce sont les microtypes qui ralentissent l'application.  D'après mon expérience, une telle situation est plutôt impossible.  Avec une probabilité plus élevée, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le même enregistreur</a> vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ralentira</a> , car chaque opération attend un vidage sur le disque (tout était acceptable sur l'ordinateur du développeur avec SSD M.2, mais un utilisateur avec un ancien disque dur voit des résultats complètement différents). </p><br><p>  Cependant, les astuces elles-mêmes: </p><br><ul><li>  Utilisez des types significatifs au lieu de types de référence.  Cela peut être utile si Wrapper fonctionne également avec des types importants, ce qui signifie qu'en théorie, vous pouvez transmettre toutes les informations nécessaires à travers la pile.  Bien qu'il ne faut pas oublier que l'accélération ne sera que si votre code souffre vraiment de GC fréquents précisément à cause des microtypes. <br><ul><li>  <code>struct</code> dans .Net peut provoquer des boxes / unboxing fréquentes.  Et en même temps, de telles structures peuvent nécessiter plus de mémoire dans les collections <code>Dictionary</code> / <code>Map</code> (car les tableaux sont alloués avec une marge). </li><li>  <code>inline</code> types en <code>inline</code> de Kotlin / Scala ont une applicabilité limitée.  Par exemple, vous ne pouvez pas y stocker plusieurs champs (ce qui peut parfois être utile pour mettre en cache la valeur <code>ToString</code> / <code>GetHashCode</code> ). </li><li>  Un certain nombre d'optimiseurs sont capables d'allouer de la mémoire sur la pile.  En particulier, .Net le <a href="">fait pour les petits objets temporaires</a> , et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GraalVM en Java peut</a> allouer un objet sur la pile, mais le copier ensuite dans le tas s'il devait être retourné (adapté au code riche en conditions). </li></ul></li><li>  Utilisez l'internement d'objets (c'est-à-dire, essayez de prendre des objets prêts à l'emploi, pré-créés). <br><ul><li>  Si le constructeur a un argument, vous pouvez simplement créer un cache où la clé est cet argument et la valeur est l'objet créé précédemment.  Ainsi, si la variété des objets est assez petite, vous pouvez simplement réutiliser ceux prêts à l'emploi. </li><li>  Si un objet a plusieurs arguments, vous pouvez simplement créer un nouvel objet, puis vérifier s'il se trouve dans le cache.  S'il y en a un similaire, il vaut mieux retourner celui déjà créé. </li><li>  Un tel schéma ralentit le travail des concepteurs, car <code>Equals</code> / <code>GetHashCode</code> doit être effectué pour tous les arguments.  Cependant, cela accélère également les comparaisons futures d'objets, si vous mettez en cache la valeur du hachage, car dans ce cas, s'ils sont différents, les objets sont différents.  Et les objets identiques auront souvent un seul lien. </li><li>  Cependant, cette optimisation accélérera le programme, en raison du <code>GetHashCode</code> / <code>Equals</code> plus rapide (voir le paragraphe ci-dessus).  De plus, la durée de vie des nouveaux objets (qui sont cependant dans le cache) diminuera considérablement, de sorte qu'ils n'entreront que dans la génération 0. </li></ul></li><li>  Lors de la création de nouveaux objets, vérifiez les paramètres d'entrée et ne les ajustez pas.  Malgré le fait que ces conseils vont souvent dans le paragraphe sur le style de codage, en fait, cela vous permet d'augmenter l'efficacité du programme.  Par exemple, si votre objet nécessite une chaîne avec uniquement de GRANDES LETTRES, alors deux approches sont souvent utilisées pour vérifier: soit rendre <code>ToUpperInvariant</code> partir de l'argument, soit vérifier dans une boucle que toutes les lettres sont grandes.  Dans le premier cas, une nouvelle ligne est garantie d'être créée, dans le second, l'itérateur maximum est créé.  En conséquence, vous économisez de la mémoire (cependant, dans les deux cas, chaque caractère sera toujours vérifié, de sorte que les performances n'augmenteront que dans le contexte d'un garbage collection plus rare). </li></ul><br><h1 id="vyvod">  Conclusion </h1><br><p>  Encore une fois, je répéterai le point important du titre: tout ce qui est décrit dans l'article a du sens dans les grands projets qui ont été développés et utilisés pendant des années.  Dans ceux où il est significatif de réduire le coût du support et de réduire le coût de l'ajout de nouvelles fonctionnalités.  Dans d'autres cas, il est souvent plus raisonnable de fabriquer un produit le plus rapidement possible sans se soucier des tests, des modèles et du «bon code». </p><br><p>  Cependant, pour les projets à long terme, il est raisonnable d'utiliser le typage le plus strict, où dans le modèle nous pouvons décrire strictement quelles valeurs sont en principe possibles. </p><br><p>  Si votre service peut parfois renvoyer un résultat non fonctionnel, exprimez-le dans le modèle et montrez-le explicitement au développeur.  N'ajoutez pas mille indicateurs avec des descriptions dans la documentation. </p><br><p>  Si vos types peuvent être les mêmes dans le programme, mais qu'ils sont différents dans leur essence, définissez-les exactement comme différents.  Ne les mélangez pas, même si les types de leurs champs sont les mêmes. </p><br><p>  Si vous avez des questions sur la productivité, appliquez la méthode scientifique et faites un test (ou mieux, demandez à une personne indépendante de vérifier tout cela).  Dans ce scénario, vous accélérerez réellement le programme et ne perdrez pas seulement le temps de l'équipe.  Cependant, l'inverse est également vrai: s'il y a un soupçon que votre programme ou bibliothèque est lent, faites un test.  Pas besoin de dire que tout va bien, il suffit de le montrer en chiffres. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462655/">https://habr.com/ru/post/fr462655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462635/index.html">Quantum, or there and back: un nouvel algorithme pour étudier la transition quantique-classique</a></li>
<li><a href="../fr462641/index.html">52 Caractéristiques du chef de produit idéal</a></li>
<li><a href="../fr462643/index.html">Déterminer les individus interdépendants à bord des structures à l'aide de python</a></li>
<li><a href="../fr462649/index.html"># 18 Mosdroid Argon - rapport</a></li>
<li><a href="../fr462653/index.html">Le LTE comme symbole de l'indépendance</a></li>
<li><a href="../fr462657/index.html">Test et test du chargeur SkyRC B6 Nano</a></li>
<li><a href="../fr462659/index.html">Premiers pas avec PVS-Studio Static Analyzer pour le développement C ++ sous Linux</a></li>
<li><a href="../fr462661/index.html">Connaissance de l'analyseur statique PVS-Studio lors du développement de programmes C ++ sous Linux</a></li>
<li><a href="../fr462663/index.html">Natation, danse (!) Et rock: quelles activités veulent absolument</a></li>
<li><a href="../fr462665/index.html">Sécurité du casque</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>