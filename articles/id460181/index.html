<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘§â€ğŸ‘§ ğŸ¤ŸğŸ¼ ğŸ”› Tingkatkan pengetahuan JavaScript Anda dengan mem-parsing kode sumber ğŸ‘©ğŸ½â€ğŸ“ ğŸ¤« ğŸ‘©â€ğŸš’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika Anda memulai karir pemrograman Anda, menggali kode sumber perpustakaan terbuka dan kerangka kerja mungkin tampak sedikit menakutkan. Dalam arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tingkatkan pengetahuan JavaScript Anda dengan mem-parsing kode sumber</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460181/"> <i>Ketika Anda memulai karir pemrograman Anda, menggali kode sumber perpustakaan terbuka dan kerangka kerja mungkin tampak sedikit menakutkan.</i>  <i>Dalam artikel ini, Karl Mungazi berbagi pengalamannya tentang bagaimana ia mengatasi rasa takutnya dan mulai menggunakan kode sumber untuk memperoleh pengetahuan dan mengembangkan keterampilan.</i>  <i>Dia juga menggunakan Redux untuk menunjukkan bagaimana dia "mem-parsing" perpustakaan.</i> <br><a name="habracut"></a><br>  Apakah Anda ingat ketika Anda pertama kali membenamkan diri dalam kode perpustakaan atau kerangka kerja yang sering Anda gunakan?  Dalam hidup saya, momen ini datang pada pekerjaan pertama saya sebagai pengembang front-end tiga tahun lalu. <br><br>  Kami hanya menulis ulang kerangka kerja lama yang sudah usang yang digunakan untuk membuat kursus pelatihan interaktif.  Pada awal penulisan ulang, kami melihat beberapa solusi turnkey, termasuk Mithril, Inferno, Angular, React, Aurelia, Vue, dan Polymer.  Karena saya masih Padawan muda (yang baru saja beralih dari jurnalisme ke pengembangan web), saya sangat takut akan kompleksitas dari setiap kerangka kerja dan kurangnya pemahaman tentang bagaimana mereka bekerja. <br><br>  Pemahaman mulai muncul ketika saya mulai hati-hati mengeksplorasi kerangka Mithril.  Sejak itu, pengetahuan saya tentang JavaScript - dan pemrograman pada umumnya - telah sangat diperkuat berkat waktu yang dihabiskan untuk menggali internal perpustakaan, yang saya gunakan setiap hari di tempat kerja dan di proyek saya sendiri.  Pada artikel ini saya akan memberi tahu Anda bagaimana Anda dapat menggunakan perpustakaan favorit Anda sebagai tutorial <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bbe/3d3/fad/bbe3d3fadd117038a615108327f4c867.png" alt="gambar"><br>  <i>Saya mulai membaca kode sumber dengan fungsi hyperscript dari Mithril</i> <br><br><h3>  Pro parsing kode sumber </h3><br>  Salah satu keuntungan utama dari parsing source code adalah Anda dapat belajar banyak.  Ketika saya mulai menguraikan kode Mithril, saya memiliki ide yang sangat buruk tentang apa DOM virtual itu.  Ketika saya selesai, saya sudah tahu bahwa DOM virtual adalah teknik yang melibatkan pembuatan pohon objek yang menggambarkan antarmuka pengguna.  Pohon ini kemudian dapat dikonversi ke elemen DOM menggunakan API DOM seperti document.createElement.  Untuk memperbarui, pohon baru dibuat yang menggambarkan keadaan antarmuka di masa depan dan kemudian dibandingkan dengan versi sebelumnya dari pohon ini. <br><br>  Saya membaca tentang ini di banyak artikel dan manual, tetapi yang paling bermanfaat adalah mengamati semua ini saat mengerjakan aplikasi kita.  Saya juga belajar mengajukan pertanyaan yang tepat saat membandingkan kerangka kerja.  Alih-alih membandingkan peringkat, misalnya, Anda dapat mengajukan pertanyaan "Bagaimana cara kerja kerangka kerja ini dengan perubahan memengaruhi kinerja dan kenyamanan pengguna akhir?" <br><br>  Kelebihan lainnya adalah pengembangan pemahaman arsitektur aplikasi yang baik.  Terlepas dari kenyataan bahwa sebagian besar proyek open-source umumnya kurang lebih memiliki struktur yang mirip dengan repositori mereka, mereka masih memiliki perbedaan.  Struktur Mithril sangat datar dan jika Anda berpengalaman dalam API-nya, Anda dapat membuat asumsi yang cukup realistis tentang kode dalam render, router dan folder permintaan.  Struktur React, di sisi lain, mencerminkan arsitektur barunya.  Pengembang memisahkan modul yang bertanggung jawab untuk memperbarui UI (react-reconciler) dari modul yang bertanggung jawab untuk merender elemen DOM (react-dom). <br><br>  Salah satu keuntungan pemisahan ini bagi pengembang adalah mereka dapat menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyaji</a> mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sendiri</a> menggunakan kait di rekonsiliasi-reaksi.  Parcel, pembuat modul yang baru saya pelajari, juga memiliki folder paket, seperti React.  Modul utama disebut paket-bundler, berisi kode yang bertanggung jawab untuk membuat rakitan, pengoperasian server pembaruan modul (server modul panas), dan alat baris perintah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdd/7ef/ac1/fdd7efac1030c6d2678f44dd39a223cc.png" alt="gambar"><br>  <i>Parsing kode sumber segera membuat Anda membaca spesifikasi JavaScript.</i> <br><br>  Kelebihan lainnya, yang merupakan kejutan besar bagi saya, adalah membuatnya lebih mudah bagi Anda untuk membaca spesifikasi JavaScript resmi.  Pertama kali saya menoleh padanya ketika saya mencoba mencari tahu apa perbedaan antara throw Error dan throw new Error (spoiler - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nothing</a> ).  Saya mengajukan pertanyaan ini karena Mithril menggunakan throw Error dalam implementasi fungsi m dan saya bertanya-tanya mengapa itu lebih baik daripada membuang Error baru.  Kemudian saya juga mengetahui bahwa operator &amp;&amp; dan ||  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">belum tentu mengembalikan nilai Boolean</a> , saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aturan</a> yang digunakan operator perbandingan non-ketat == "menyelesaikan" nilai dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alasan</a> mengapa Object.prototype.toString.call ({}) mengembalikan '[objek objek]'. <br><br><h3>  Cara mengurai kode sumber </h3><br>  Ada banyak cara untuk mengurai kode sumber.  Menurut saya, cara termudah adalah: pilih metode dari perpustakaan Anda dan jelaskan apa yang terjadi ketika Anda memanggilnya.  Tidak perlu menggambarkan setiap langkah, Anda hanya perlu mencoba memahami prinsip dan struktur umumnya. <br><br>  Baru-baru ini, saya mem-parsing ReactDOM.render dengan cara ini dan belajar banyak tentang React Fiber dan beberapa kesulitan dalam mengimplementasikannya.  Untungnya, React sangat populer dan kehadiran sejumlah besar artikel tentang topik yang sama dari pengembang lain mempercepat prosesnya. <br><br>  Menyelam ke dalam kode ini juga memperkenalkan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjadwalan koperasi</a> , metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">window.requestIdleCallback,</a> dan <a href="">contoh</a> langsung <a href="">dari daftar tertaut</a> (Bereaksi proses pembaruan dengan mengirimkannya ke antrian, yang merupakan daftar pembaruan terkait terkait).  Dalam prosesnya, akan menyenangkan untuk membuat aplikasi sederhana menggunakan perpustakaan.  Ini membuat proses debug lebih mudah karena Anda tidak harus berurusan dengan jejak tumpukan perpustakaan lain. <br><br>  Jika saya tidak melakukan review terperinci, maka saya akan membuka folder node_modules dalam proyek yang sedang saya kerjakan atau melihat GitHub.  Saya selalu melakukan ini ketika menemukan bug atau fitur menarik.  Saat membaca kode di GitHub, pastikan ini adalah versi terbaru.  Kode versi terbaru dapat dilihat dengan mengklik tombol untuk mengubah cabang dan memilih "tag".  Perubahan pustaka dan kerangka kerja sedang berlangsung, jadi Anda tidak mungkin ingin menguraikan sesuatu yang mungkin tidak ada di versi berikutnya. <br><br>  Versi yang lebih dangkal dari kode sumber belajar adalah apa yang saya sebut "tampilan cepat".  Entah bagaimana saya menginstal express.js, membuka folder node_modules dan melalui dependensi.  Jika README tidak memberi saya penjelasan yang memuaskan, saya membaca sumbernya.  Ini membawa saya ke penemuan menarik: <br><br><ul><li>  Express menggunakan dua modul untuk menggabungkan objek, dan pengoperasian modul ini sangat berbeda.  penggabung-deskriptor hanya menambahkan properti yang ditemukan di objek sumber, dan juga menambahkan properti non-enumerable, sedangkan utils-merge membahas properti yang disebutkan dari objek dan seluruh rantai prototipe.  penggabung-deskriptor menggunakan Object.getOwnPropertyNames () dan Object.getOwnPropertyDescriptor (), dan utils-merge uses for..in; </li><li>  Modul setprototypeof menyediakan opsi lintas platform untuk menentukan prototipe objek yang dibuat (dipakai); </li><li>  escape-html adalah modul pelolosan string 78-baris, setelah itu kontennya dapat dimasukkan ke dalam HTML; </li></ul><br>  Meskipun penemuan-penemuan ini kemungkinan besar tidak berguna segera, pemahaman umum tentang dependensi perpustakaan atau kerangka kerja Anda sangat membantu. <br><br>  Alat peramban debugging adalah teman terbaik Anda ketika men-debug kode di frontend.  Di antara hal-hal lain, mereka memungkinkan Anda untuk menghentikan program kapan saja dan memeriksa pada saat yang sama statusnya, melewatkan fungsi, atau masuk atau keluar.  Dalam kode yang diperkecil, ini tidak mungkin - itu sebabnya saya membongkar kode ini dan memasukkannya ke file yang sesuai di folder node_modules. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/0b7/2b1/ad00b72b170fb59cbc2d87ba99892a1f.png" alt="gambar"><br>  <i>Gunakan debugger sebagai aplikasi yang bermanfaat.</i>  <i>Buat asumsi, lalu uji.</i> <br><br><h3>  Studi kasus: menghubungkan fungsi di Redux </h3><br>  React-Redux adalah perpustakaan untuk mengelola keadaan aplikasi Bereaksi.  Ketika saya bekerja dengan perpustakaan populer seperti ini, saya mulai dengan mencari artikel tentang penggunaannya.  Dalam mempersiapkan contoh ini, saya meninjau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini.  Ini adalah nilai tambah lain dalam mempelajari kode sumber - ini akan mengarahkan Anda ke artikel informatif seperti ini yang meningkatkan pemikiran dan pemahaman Anda. <br><br>  Connect adalah fungsi react-redux yang menghubungkan komponen reaksi dan toko redux suatu aplikasi.  Bagaimana?  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi,</a> dia melakukan hal berikut: <br><blockquote>  "... mengembalikan kelas komponen baru yang terkait, yang merupakan pembungkus komponen yang diteruskan ke sana." </blockquote>  Setelah membaca ini, saya mengajukan pertanyaan berikut: <br><br><ul><li>  Apakah saya tahu pola atau konsep di mana fungsi mengembalikan parameter input yang dibungkus dengan fungsionalitas tambahan? </li><li>  Jika demikian, bagaimana saya menggunakan ini berdasarkan deskripsi dari dokumentasi? </li></ul><br>  Biasanya langkah selanjutnya adalah membuat aplikasi primitif menggunakan fungsi connect.  Namun demikian, dalam situasi ini, saya menggunakan aplikasi baru pada React, yang kami kerjakan, karena saya ingin memahami terhubung dalam konteks aplikasi yang kemungkinan besar akan segera sampai ke produksi. <br><br>  Komponen yang saya fokuskan terlihat seperti ini: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MarketContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// code omitted for brevity } const mapDispatchToProps = dispatch =&gt; { return { updateSummary: (summary, start, today) =&gt; dispatch(updateSummary(summary, start, today)) } } export default connect(null, mapDispatchToProps)(MarketContainer);</span></span></code> </pre> <br>  Ini adalah komponen wadah yang berfungsi sebagai pembungkus untuk empat komponen terkait yang lebih kecil.  Salah satu hal pertama yang Anda temukan dalam <a href="">file</a> yang menghubungkan ekspor adalah komentar "terhubung adalah fasad untuk connectAdvanced".  Sudah pada tahap ini kita dapat belajar sesuatu: kita memiliki kesempatan untuk mengamati pola "fasad" dalam aksi.  Di akhir file, kita melihat koneksi mengekspor panggilan ke fungsi createConnect.  Parameternya adalah seperangkat nilai default yang direstrukturisasi sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, mergePropsFactories = defaultMergePropsFactories, selectorFactory = defaultSelectorFactory } = {}</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Dan kami memiliki satu momen instruktif lagi: ekspor fungsi yang disebut dan perusakan argumen fungsi secara default.  Restrukturisasi bermanfaat bagi kita karena kode dapat ditulis seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, mergePropsFactories = defaultMergePropsFactories, selectorFactory = defaultSelectorFactory }</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Akibatnya, kami akan mendapatkan kesalahan - UnEught TypeError: Tidak dapat merusak properti 'connectHOC' dari 'undefined' atau 'null'.  Ini akan terjadi karena fungsi tidak memiliki nilai argumen default. <br><br>  <i>Catatan: untuk lebih memahami restrukturisasi argumen, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel David Walsh</a> .</i>  <i>Beberapa poin mungkin tampak sepele, tergantung pada pengetahuan Anda tentang bahasa - maka Anda dapat fokus pada poin-poin yang Anda tidak kenal.</i> <br><br>  Fungsi createConnect sendiri tidak melakukan apa-apa.  Itu hanya mengembalikan fungsi koneksi yang saya gunakan di sini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> connect(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, mapDispatchToProps)(MarketContainer)</code> </pre><br>  Dibutuhkan empat argumen opsional dan tiga di antaranya melewati fungsi <a href="">kecocokan</a> , yang membantu menentukan perilaku mereka berdasarkan argumen yang dilewati, serta jenisnya.  Ternyata karena argumen kedua yang dilewatkan untuk mencocokkan adalah salah satu dari tiga fungsi yang diimpor ke connect, saya harus memilih ke mana harus pergi berikutnya. <br><br>  Ada juga sesuatu untuk dipelajari dari <a href="">fungsi proxy yang</a> digunakan untuk membungkus argumen pertama dalam koneksi, jika argumen ini adalah fungsi;  dari utilitas <a href="">isPlainObject</a> yang digunakan untuk memeriksa objek biasa atau dari modul <a href="">peringatan</a> , yang menunjukkan bagaimana Anda dapat membuat debugger yang akan memecah semua kesalahan.  Setelah fungsi pertandingan, kami beralih ke connectHOC, fungsi yang mengambil komponen reaksi kami dan menghubungkannya dengan redux.  Ada panggilan fungsi lain yang mengembalikan <a href="">wrapWithConnect</a> - fungsi yang benar-benar menangani pengikatan komponen ke repositori. <br><br>  Melihat implementasi connectHOC, saya bisa menebak mengapa detail implementasi connect harus disembunyikan.  Ini pada dasarnya adalah jantung dari reaksi-redux dan mengandung logika yang seharusnya tidak dapat diakses melalui koneksi.  Bahkan jika kita memikirkan ini, maka nanti, jika kita perlu menggali lebih dalam, kita akan sudah memiliki bahan sumber dengan penjelasan rinci tentang kode. <br><br><h3>  Ringkaslah </h3><br>  Mempelajari kode sumber sangat rumit pada awalnya.  Tapi, seperti yang lainnya, itu menjadi lebih mudah seiring waktu.  Tugasnya bukan untuk memahami segalanya, tetapi untuk mengeluarkan sesuatu yang berguna untuk dirinya sendiri - pemahaman bersama dan pengetahuan baru.  Sangat penting untuk berhati-hati selama seluruh proses dan mempelajari rinciannya. <br><br>  Sebagai contoh, saya menemukan fungsi isPlainObject menarik karena menggunakan ini if â€‹â€‹(typeof obj! == 'object' || obj === null) mengembalikan false untuk memastikan bahwa argumen yang diteruskan adalah objek sederhana.  Ketika saya pertama kali membaca kode ini, saya berpikir, mengapa tidak hanya menggunakan Object.prototype.toString.call (opts)! == '[objek objek]', yang akan mengurangi kode dan objek yang terpisah dari subtipe mereka seperti Tanggal.  Tetapi sudah di baris berikutnya jelas bahwa bahkan jika tiba-tiba (tiba-tiba!) Seorang pengembang menggunakan menghubungkan mengembalikan objek Date, misalnya, memeriksa Object.getPrototypeOf (obj) === null dapat menangani ini. <br><br>  Poin tak terduga lainnya di isPlainObject di tempat ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(baseProto) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { baseProto = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(baseProto) }</code> </pre><br>  Menemukan jawaban di Google membawa saya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas ini</a> di StackOverflow, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar ini</a> di Redux GitHub, yang menjelaskan bagaimana kode ini menangani situasi di mana, misalnya, objek ditransfer dari iFrame. <br><br>  - <br><br>  <i>Pertama memutuskan untuk menerjemahkan artikel tersebut.</i>  <i>Saya akan berterima kasih atas klarifikasi, saran dan rekomendasi</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460181/">https://habr.com/ru/post/id460181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460169/index.html">Manual R baru-baru ini telah menjadi publikasi non-akademik yang paling banyak dikutip dalam makalah akademik.</a></li>
<li><a href="../id460173/index.html">Pengembangan untuk Docker. Lingkungan lokal. Bagian 2 - Nginx + PHP + MySql + phpMyAdmin</a></li>
<li><a href="../id460175/index.html">Semiotika dalam pemasaran: apa artinya ini bagi merek Anda</a></li>
<li><a href="../id460177/index.html">Sensor kebocoran air nirkabel pada nRF52832, proyek DIY</a></li>
<li><a href="../id460179/index.html">LEAN + AGILE = AGILEAN atau kami mengumpulkan seluruh bagian</a></li>
<li><a href="../id460185/index.html">Layanan online "Analisis Kecepatan dalam Kecelakaan oleh Video"</a></li>
<li><a href="../id460187/index.html">Bayangkan data Anda sebelum Anda mengumpulkannya.</a></li>
<li><a href="../id460189/index.html">14 Alat Papan Kanban Terbaik di 2019</a></li>
<li><a href="../id460191/index.html">Hentikan saluran atau pompa pipa Anda, yo</a></li>
<li><a href="../id460193/index.html">Memantau berakhirnya sertifikat pada Windows di NetXMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>