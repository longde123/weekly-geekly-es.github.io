<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😞 🏇🏼 🗯️ Mein Rechen: von Lumpen zu Reichtum 🏆 🚹 🎀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 


 Ich arbeite jetzt seit einem Jahr als Front-End-Entwickler. Mein erstes Projekt war ein "feindliches" Backend. Es kommt vor, dass dies...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mein Rechen: von Lumpen zu Reichtum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453502/"><h2 id="predystoriya">  Hintergrund </h2><br><p>  Ich arbeite jetzt seit einem Jahr als Front-End-Entwickler.  Mein erstes Projekt war ein "feindliches" Backend.  Es kommt vor, dass dies kein großes Problem ist, wenn die Kommunikation hergestellt wird. </p><br><p>  Aber in unserem Fall war es nicht so. </p><a name="habracut"></a><br><p>  Wir haben den Code entwickelt, der darauf beruhte, dass das Backend uns bestimmte Daten, eine bestimmte Struktur und ein bestimmtes Format sendet.  Während das Backend es für normal hielt, den Inhalt der Antworten zu ändern - ohne Vorwarnung.  Infolgedessen haben wir Stunden gebraucht, um festzustellen, warum ein bestimmter Teil der Website nicht mehr funktioniert. </p><br><p>  Wir haben festgestellt, dass wir überprüfen müssen, was das Backend zurückgibt, bevor wir uns auf die Daten verlassen können, die es an uns gesendet hat.  Wir haben eine Forschungsaufgabe zum Thema Datenvalidierung vom Frontend aus erstellt. </p><br><p>  Diese Studie wurde mir in Auftrag gegeben. </p><br><p>  Ich habe eine Liste erstellt, was ich in dem Tool sein möchte, das ich für die Datenvalidierung verwenden möchte. </p><br><p>  Die wichtigsten Auswahlpunkte waren folgende Punkte: </p><br><ul><li>  deklarative Beschreibung (Schema) der Validierung, die in eine Validierungsfunktion umgewandelt wird, die true / false zurückgibt (gültig, ungültig) </li><li>  niedrige Eintrittsschwelle; </li><li> Ähnlichkeit validierter Daten mit einer Beschreibung der Validierung; </li><li>  einfache Integration von benutzerdefinierten Validierungen; </li><li>  Einfache Integration von benutzerdefinierten Fehlermeldungen. </li></ul><br><p>  Als Ergebnis fand ich viele Validierungsbibliotheken, nachdem ich das TOP-5 (ajv, joi, roi ...) überprüft hatte.  Sie sind alle sehr gut.  Aber es schien mir, dass zur Lösung von 5% der komplexen Fälle 95% der häufigsten Fälle dazu verurteilt waren, ziemlich ausführlich und umständlich zu sein. </p><br><p>  Deshalb dachte ich: Warum nicht selbst etwas entwickeln, das zu mir passt? <br>  Vier Monate später erschien die siebte Version meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quartett-</a> Validierungsbibliothek. <br>  Es war eine stabile Version, vollständig getestet, 11k Downloads auf npm.  Wir haben es drei Monate lang für drei Projekte in einer Kampagne verwendet. </p><br><p>  Diese drei Monate haben eine sehr nützliche Rolle gespielt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quartett hat</a> alle seine Vorteile gezeigt.  Es gibt keine Datenprobleme vom Backend.  Jedes Mal, wenn sie die Antwort änderten, warfen wir sofort einen Fehler.  Die Zeit, die für die Suche nach den Ursachen von Fehlern aufgewendet wurde, hat sich dramatisch verringert.  Es gibt praktisch keine Datenfehler mehr. </p><br><p>  Es wurden aber auch Mängel festgestellt. </p><br><p>  Aus diesem Grund habe ich beschlossen, sie zu analysieren und eine neue Version mit Korrekturen aller Fehler zu veröffentlichen, die während der Entwicklung gemacht wurden. <br>  Ich werde im Folgenden auf diese Architekturfehler und ihre Lösungen eingehen. </p><br><h2 id="arhitekturnye-grabli">  Architektonischer Rechen </h2><br><h3 id="stroko-tipizirovannyy-yazyk-shemy">  "Stroko" - eine typische Sprache des Schemas </h3><br><p>  Ich werde ein Beispiel der alten Version des Schemas für das Objekt der Person geben. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'null'</span></span>] }</code> </pre> <br><p>  Dieses Schema überprüft ein Objekt mit drei Eigenschaften: Name - muss eine Zeichenfolge sein, Alter - muss eine Zahl sein, eine Verknüpfung zu einem Konto in LinkedIn - muss entweder null (wenn kein Konto vorhanden ist) oder Zeichenfolge (wenn ein Konto vorhanden ist) sein. </p><br><p>  Dieses Schema erfüllt meine Anforderungen an Lesbarkeit und Ähnlichkeit mit validierten Daten, und ich denke, dass die Schwelle für den Einstieg in das Erlernen des Schreibens solcher Schemata nicht hoch ist.  Darüber hinaus kann ein solches Schema leicht mit einer Typdefinition in Typoskript geschrieben werden: </p><br><pre> <code class="javascript hljs">type Person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string age: number linkedin: string | <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  (Wie Sie sehen können - die Änderungen sind eher kosmetischer Natur) </p><br><p>  Wenn ich eine Entscheidung getroffen habe, was für die häufigsten Validierungsoptionen verwendet werden soll (zum Beispiel die oben verwendeten).  Ich entschied mich für - Strings, sozusagen die Namen von Validatoren. </p><br><p>  Das Problem mit Zeichenfolgen ist jedoch, dass sie dem Compiler oder Fehleranalysator nicht zur Verfügung stehen.  Die Zeichenfolge 'Nummer' unterscheidet sich nicht wesentlich von 'Nummer'. </p><br><h3 id="reshenie">  Lösung </h3><br><p>  Die neue Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quartetts</a> 8.0.0.  Ich beschloss, aus dem Quartett zu entfernen - die Verwendung von Strings als Namen von Validatoren innerhalb des Schemas. </p><br><p>  Das Diagramm sieht jetzt so aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string age: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [v.string, <span class="hljs-literal"><span class="hljs-literal">null</span></span>] }</code> </pre> <br><p>  Diese Änderung hat zwei große Vorteile: </p><br><ul><li>  Compiler oder Fehleranalysatoren - können erkennen, dass der Methodenname mit einem Fehler geschrieben wurde. </li><li>  Linien - werden nicht mehr als Schemaelement verwendet.  Dies bedeutet, dass Sie für sie neue Funktionen in der Bibliothek auswählen können, die im Folgenden beschrieben werden. </li></ul><br><h3 id="podderzhka-typescript">  TypeScript-Unterstützung </h3><br><p>  Im Allgemeinen wurden die ersten sieben Versionen in reinem Javascript entwickelt.  Beim Wechsel zu einem Projekt mit Typescript musste die Bibliothek irgendwie angepasst werden.  Daher wurden Typdeklarationen für die Bibliothek geschrieben. </p><br><p>  Dies war jedoch ein Minus - beim Hinzufügen von Funktionen oder beim Ändern einiger Elemente der Bibliothek war es immer leicht zu vergessen, die Typdeklarationen zu aktualisieren. </p><br><p>  Es gab auch nur geringfügige Unannehmlichkeiten dieser Art: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Als wir den Objektvalidator in Zeile (0) erstellt haben.  Wir möchten nach Überprüfung der tatsächlichen Antwort aus dem Backend in Zeile (1) und Behandlung des Fehlers.  In Zeile (2), damit diese <code>person</code> Typ Person ist.  Dies ist jedoch nicht geschehen.  Leider war eine solche Überprüfung kein Typwächter. </p><br><h3 id="reshenie-1">  Lösung </h3><br><p>  Ich beschloss, die gesamte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quartettbibliothek</a> in Typescript umzuschreiben, damit der Compiler die Korrespondenz der Bibliothek mit den Typen überprüfen konnte.  Unterwegs fügen wir der Funktion, die den kompilierten Validator zurückgibt, einen Typparameter hinzu, der bestimmen würde, welcher Typschutz dieser Validatortyp ist. </p><br><p>  Ein Beispiel sieht so aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Jetzt ist in Zeile (2) <code>person</code> vom Typ <code>Person</code> . </p><br><h3 id="chitaemost">  Lesbarkeit </h3><br><p>  Es gab auch zwei Fälle, in denen der Code schlecht gelesen wurde: Überprüfung der Einhaltung eines bestimmten Wertesatzes (Überprüfung von Aufzählungen) und Überprüfung anderer Eigenschaften des Objekts. </p><br><p>  a) Überprüfen Sie die Aufzählungen <br>  Anfangs gab es eine Idee, meiner Meinung nach eine gute.  Wir werden es demonstrieren, indem wir unserem Objekt das Feld "Geschlecht" hinzufügen. <br>  Die alte Version der Schaltung sah folgendermaßen aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>) }</code> </pre> <br><p>  Die Option ist sehr gut lesbar.  Aber wie immer lief alles ein wenig vom Plan ab. <br>  Mit einer deklarierten Aufzählung im Programm, zum Beispiel: </p><br><pre> <code class="javascript hljs">enum Sex { Male = <span class="hljs-string"><span class="hljs-string">'male'</span></span>, Female = <span class="hljs-string"><span class="hljs-string">'female'</span></span> }</code> </pre> <br><p>  Natürlich möchte ich es innerhalb der Schaltung verwenden.  Wenn Sie also einen der Werte ändern (z. B. 'männlich' -&gt; 'm', 'weiblich' -&gt; 'f'), sollte sich auch das Validierungsschema ändern. </p><br><p>  Daher wurde die Enum-Validierung fast immer folgendermaßen geschrieben: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)) }</code> </pre> <br><p>  Welches sieht ziemlich sperrig aus. </p><br><p>  b) Validierung der Resteigenschaften des Objekts </p><br><p>  Angenommen, wir fügen unserem Objekt ein solches Merkmal hinzu - es kann zusätzliche Felder enthalten, aber alle müssen Links zu sozialen Netzwerken sein - das heißt, sie müssen entweder <code>null</code> oder eine Zeichenfolge sein. </p><br><p>  Das alte Schema würde so aussehen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)), ...v.rest([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null }</span></span></code> </pre> <br><p>  In diesem Eintrag wurden die verbleibenden Eigenschaften hervorgehoben - von den bereits aufgelisteten.  Die Verwendung eines Spread-Operators verwirrt eher eine Person, die dieses Schema verstehen möchte. </p><br><h3 id="reshenie-2">  Lösung </h3><br><p>  Wie oben beschrieben, sind Zeichenfolgen nicht mehr Teil von Validierungsschemata.  Nur drei Arten von Javascript-Werten blieben Validierungsschema.  Objekt - um das Validierungsschema des Objekts zu beschreiben.  Array zur Beschreibung - verschiedene Optionen für die Gültigkeit.  Funktion (Bibliothek generiert oder benutzerdefiniert) - für alle anderen Validierungsoptionen. </p><br><p>  Diese Bestimmung ermöglichte das Hinzufügen von Funktionen, wodurch die Lesbarkeit der Schaltung um ein Vielfaches erhöht werden konnte. </p><br><p>  Was ist, wenn wir den Wert mit der Zeichenfolge 'male' vergleichen möchten?  Müssen wir wirklich etwas anderes wissen als den Wert selbst und die Zeichenfolge 'männlich'? </p><br><p>  Daher wurde beschlossen, die Werte primitiver Typen als Element der Schaltung hinzuzufügen.  Wenn Sie also einen primitiven Wert im Schema treffen, bedeutet dies, dass dies der gültige Wert ist, den der nach diesem Schema erstellte Validator überprüfen sollte.  Ich gebe besser ein Beispiel: </p><br><p>  Wenn wir die Zahl auf Gleichheit überprüfen müssen 42-mind.  Dann schreiben wir es so: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> check42 = v(<span class="hljs-number"><span class="hljs-number">42</span></span>) check42(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true check42(41) // =&gt; false check42(43) // =&gt; false check42('42') // =&gt; false</span></span></code> </pre> <br><p>  Mal sehen, wie sich dies auf das Personenschema auswirkt (ohne zusätzliche Eigenschaften zu berücksichtigen): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-comment"><span class="hljs-comment">// null is primitive value sex: ['male', 'female'] // 'male', 'female' are primitive values }</span></span></code> </pre> <br><p>  Mit vordefinierten Aufzählungen können wir es folgendermaßen umschreiben: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex) <span class="hljs-comment"><span class="hljs-comment">// same as ['male', 'female'] }</span></span></code> </pre> <br><p>  In diesem Fall wurde unnötige Zeremonialität in Form der Verwendung der Enum-Methode und der Verwendung des Spread-Operators entfernt, um gültige Werte aus dem Objekt als Parameter in diese Methode einzufügen. </p><br><p>  Was als primitiver Wert angesehen wird: Zahlen, Zeichenfolgen, Zeichen, <code>true</code> , <code>false</code> , <code>null</code> und <code>undefined</code> . </p><br><p>  Das heißt, wenn wir den Wert mit ihnen vergleichen müssen, verwenden wir diese Werte einfach selbst.  Und eine Validierungsbibliothek - sie erstellt einen Validator, der den Wert streng mit den im Schema angegebenen vergleicht. </p><br><p>  Um verbleibende Eigenschaften zu validieren, wurde ausgewählt, eine spezielle Eigenschaft für alle anderen Felder des Objekts zu verwenden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), [v.rest]: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string] }</code> </pre> <br><p>  Somit sieht die Schaltung besser lesbar aus.  Und eher wie Typescript-Anzeigen. </p><br><h3 id="svyazannost-validatora-s-funkciey-kotoraya-sozdala-ego">  Der Validator bezieht sich auf die Funktion, die ihn erstellt hat </h3><br><p>  In älteren Versionen waren Fehlererklärungen nicht Teil des Validators.  Sie wurden einem Array innerhalb der <code>v</code> Funktion hinzugefügt. </p><br><p>  Zuvor mussten Sie einen Validator bei sich haben (um dies zu überprüfen) und v (um eine Erklärung der Invalidität zu erhalten), um eine Erklärung für Validierungsfehler zu erhalten.  All dies sah wie folgt aus: <br><br>  a) Wir fügen dem Diagramm Erklärungen hinzu </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>) age: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>), <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v( v.enum(...Object.values(Sex)), <span class="hljs-string"><span class="hljs-string">'wrong sex value'</span></span> ), ...v.rest( v( [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong social networks link'</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null })</span></span></code> </pre> <br><p>  Zu jedem Element der Schaltung können Sie mithilfe des zweiten Arguments der v-Compiler-Funktion eine Erklärung des Fehlers hinzufügen. </p><br><p>  b) Löschen Sie das Erklärungsarray </p><br><p>  Vor der Validierung musste dieses globale Array gelöscht werden, in dem alle Erklärungen während der Validierung aufgezeichnet wurden. </p><br><pre> <code class="javascript hljs">v.clearContext() <span class="hljs-comment"><span class="hljs-comment">// same as v.explanations = []</span></span></code> </pre> <br><p>  c) Validieren </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPersonValid = checkPerson(person)</code> </pre> <br><p>  Wenn bei dieser Überprüfung eine Gültigkeit gefunden wurde und in der Phase der Erstellung der Schaltung eine Erklärung gegeben wurde, wird diese Erklärung in das globale Array <code>v.explanation</code> . </p><br><p>  d) Fehlerbehandlung </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPersonValid) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'Invalid person response: '</span></span> + v.explanation.join(<span class="hljs-string"><span class="hljs-string">'; '</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// ex. Throws 'Invalid person response: wrong name; wrong age'</span></span></code> </pre> <br><p>  Wie Sie hier sehen können, gibt es ein großes Problem.  Denn wenn wir den Validator nicht anstelle seiner Erstellung verwenden wollen.  Wir müssen es nicht nur an die Parameter übergeben, sondern auch an die Funktion, die es erstellt hat.  Weil sich darin das Array befindet, in dem die Erklärungen hinzugefügt werden. </p><br><h3 id="reshenie-3">  Lösung </h3><br><p>  Dieses Problem wurde wie folgt gelöst: Erklärungen wurden Teil der Validierungsfunktion selbst.  Was kann aus seiner Art verstanden werden: <br>  Typ Validator = (Wert: any, Erklärungen ?: any []) =&gt; boolean </p><br><p>  Wenn Sie nun eine Erklärung des Fehlers benötigen, übergeben Sie das Array, in das Sie die Erklärung einfügen möchten. </p><br><p>  Somit wird der Validator zu einer unabhängigen Einheit.  Es wurde auch eine Methode hinzugefügt, die die Validierungsfunktion in eine Funktion umwandeln kann, die null zurückgibt, wenn der Wert gültig ist, und eine Reihe von Erklärungen zurückgibt, wenn der Wert ungültig ist. </p><br><p>  Nun sieht die Validierung mit Erklärungen folgendermaßen aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(v.string, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>), <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v(v.number, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>) sex: v(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), <span class="hljs-string"><span class="hljs-string">'wrong sex'</span></span>) [v.rest]: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong social network'</span></span>) }) <span class="hljs-comment"><span class="hljs-comment">// ... const explanations = [] if (!checkPerson(person, explanation)) { throw new TypeError('Wrong person: ' + explanations.join('; ')) } // OR const getExplanation = v.explain(checkPerson) const explanations = getExplanation(person) if (explanations) { throw new TypeError('Wrong person: ' + explanations.join('; ')) }</span></span></code> </pre> <br><h2 id="posleslovie">  Nachwort </h2><br><p>  Ich habe drei Prämissen hervorgehoben, aufgrund derer ich alles neu schreiben musste: </p><br><ul><li>  Die Hoffnung, dass sich Menschen beim Schreiben von Zeilen nicht irren </li><li>  Verwenden globaler Variablen (in diesem Fall v.explanation-Array) </li><li>  Tests mit kleinen Beispielen während der Entwicklung - zeigten nicht die Probleme, die bei der Verwendung in wirklich großen Fällen auftreten. </li></ul><br><p>  Ich bin jedoch froh, dass ich diese Probleme analysiert habe und die veröffentlichte Version bereits in unserem Projekt verwendet wird.  Und ich hoffe, es wird uns nicht weniger nützlich sein als das vorherige. </p><br><p>  Vielen Dank für das Lesen, ich hoffe, meine Erfahrung wird Ihnen nützlich sein. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453502/">https://habr.com/ru/post/de453502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453484/index.html">4-Bit-BCD-Zähler</a></li>
<li><a href="../de453486/index.html">Prinzipien des US-freien Marktes</a></li>
<li><a href="../de453490/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 461 (14.05.2019 - 05.05.2019)</a></li>
<li><a href="../de453492/index.html">Geschäftsprozessautomatisierung des Unternehmens Trello mithilfe semantischer Modellierungstechnologie</a></li>
<li><a href="../de453496/index.html">Glücklicher Chemiker, Kollegen</a></li>
<li><a href="../de453508/index.html">Mann ohne Smartphone</a></li>
<li><a href="../de453510/index.html">Alles für Sie: Tutorial zum Erstellen neuer Aktionen für UiPath RPA</a></li>
<li><a href="../de453512/index.html">Stilübertragung</a></li>
<li><a href="../de453514/index.html">Einführungsangebot für iOS</a></li>
<li><a href="../de453516/index.html">Automatisierung für die Kleinsten. Teil Null. Planung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>