<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéΩ ü•ä üë™ Test public: solution pour la confidentialit√© et l'√©volutivit√© dans Ethereum üö¥üèæ ‚úàÔ∏è üë©üèª‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La blockchain est une technologie innovante qui promet d'am√©liorer de nombreux domaines de la vie humaine. Il transf√®re les processus et produits r√©el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test public: solution pour la confidentialit√© et l'√©volutivit√© dans Ethereum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471096/">  <b>La blockchain</b> est une technologie innovante qui promet d'am√©liorer de nombreux domaines de la vie humaine.  Il transf√®re les processus et produits r√©els vers l'espace num√©rique, garantit la rapidit√© et la fiabilit√© des transactions financi√®res, r√©duit leur co√ªt et vous permet √©galement de cr√©er des applications DAPP modernes √† l'aide de contrats intelligents dans des r√©seaux d√©centralis√©s. <br><br>  Compte tenu des nombreux avantages et des diverses utilisations de la blockchain, il peut sembler √©trange que cette technologie prometteuse n'ait pas encore p√©n√©tr√© tous les secteurs.  Le probl√®me est que les cha√Ænes de blocs d√©centralis√©es modernes manquent d'√©volutivit√©.  Ethereum traite environ 20 transactions par seconde, ce qui n'est pas suffisant pour r√©pondre aux besoins des entreprises dynamiques d'aujourd'hui.  Dans le m√™me temps, les entreprises utilisant la technologie blockchain n'osent pas abandonner Ethereum en raison de son haut degr√© de protection contre le piratage et les pannes de r√©seau. <br><br>  Pour assurer la d√©centralisation, la s√©curit√© et l'√©volutivit√© sur la blockchain, r√©solvant ainsi le trilemme d'√©volutivit√©, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©quipe de</a> d√©veloppement d'Opporty <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> cr√©√© Plasma Cash - une cha√Æne enfant compos√©e d'un contrat intelligent et d'un r√©seau priv√© bas√© sur Node.js, transf√©rant p√©riodiquement son √©tat √† la cha√Æne racine ( Ethereum). <br><br><img src="https://habrastorage.org/webt/tc/kv/lg/tckvlgw0bbppuvkdlaght7jdwfa.jpeg"><br><a name="habracut"></a><br><h2>  Processus cl√©s chez Plasma Cash </h2><br>  <b>1. L'</b> utilisateur appelle la fonction du contrat intelligent ¬´d√©p√¥t¬ª, en y transf√©rant le montant en ETH, qu'il souhaite mettre dans le jeton Plasma Cash.  La fonction de contrat intelligent cr√©e un jeton et g√©n√®re un √©v√©nement √† ce sujet. <br><br>  <b>2.</b> Les n≈ìuds Plasma Cash abonn√©s aux √©v√©nements du contrat intelligent re√ßoivent un √©v√©nement sur la cr√©ation d'un d√©p√¥t et ajoutent une transaction sur la cr√©ation d'un jeton au pool. <br><br>  <b>3.</b> P√©riodiquement, des n≈ìuds sp√©ciaux Plasma Cash prennent toutes les transactions du pool (jusqu'√† 1 million) et en forment un bloc, calculent l'arbre Merkle et, en cons√©quence, le hachage.  Ce bloc est envoy√© √† d'autres n≈ìuds pour v√©rification.  Les n≈ìuds v√©rifient si le hachage Merkle est valide, si les transactions sont valides (par exemple, si l'exp√©diteur du jeton est son propri√©taire).  Apr√®s avoir v√©rifi√© le bloc, le n≈ìud appelle la fonction ¬´submitBlock¬ª du contrat intelligent, qui stocke le num√©ro et le hachage Merkle du bloc dans la cha√Æne de trace.  Un contrat intelligent g√©n√®re un √©v√©nement concernant l'ajout r√©ussi d'un bloc.  Les transactions sont supprim√©es du pool. <br><br>  <b>4. Les</b> n≈ìuds qui ont re√ßu l'√©v√©nement concernant la soumission du bloc commencent √† appliquer les transactions qui ont √©t√© ajout√©es au bloc. <br><br>  <b>5.</b> √Ä un moment donn√©, le propri√©taire (ou non propri√©taire) du jeton souhaite le retirer de Plasma Cash.  Pour ce faire, il appelle la fonction `startExit`, lui transmettant des informations sur les 2 derni√®res transactions sur le jeton, ce qui confirme qu'il est le propri√©taire du jeton.  Le contrat intelligent, √† l'aide du hachage Merkle, v√©rifie les transactions en blocs et envoie un jeton √† la sortie, ce qui se produira dans deux semaines. <br><br>  <b>6.</b> Si l'op√©ration de retrait du jeton s'est produite avec des violations (le jeton a √©t√© d√©pens√© apr√®s le d√©but de la proc√©dure de retrait ou le jeton √©tait d√©j√† un √©tranger avant le retrait), le propri√©taire du jeton peut r√©futer le retrait dans un d√©lai de deux semaines. <br><br><img src="https://habrastorage.org/webt/xm/hy/ks/xmhyksifhph5pfmw5ibsnoh_keq.jpeg"><br><br><h2>  La confidentialit√© est obtenue de deux mani√®res. </h2><br>  <b>1. La</b> cha√Æne racine ne sait rien des transactions qui sont form√©es et transmises √† l'int√©rieur de la cha√Æne enfant.  Des informations restent disponibles sur qui a commenc√© et retir√© l'ETH vers / de Plasma Cash. <br><br>  <b>2.</b> La cha√Æne enfant vous permet d'organiser des transactions anonymes √† l'aide de zk-SNARK. <br><br><h2>  Pile technologique </h2><br><ul><li>  NodeJS </li><li>  Redis </li><li>  Ethereum </li><li>  Soild </li></ul><br><h2>  Test </h2><br>  Lors du d√©veloppement de Plasma Cash, nous avons test√© la vitesse du syst√®me et obtenu les r√©sultats suivants: <br><br><ul><li>  jusqu'√† 35 000 transactions par seconde sont ajout√©es au pool; </li><li>  jusqu'√† 1 000 000 de transactions peuvent √™tre stock√©es dans le bloc. </li></ul><br>  Des tests ont √©t√© effectu√©s sur les 3 serveurs suivants: <br><br>  <i>1. Intel Core i7-6700 Skylake quadric≈ìur incl.</i>  <i>SSD NVMe - 512 Go, 64 Go de RAM DDR4</i> <br>  3 n≈ìuds Plasma Cash valid√©s ont √©t√© relev√©s. <br><br>  <i>2. AMD Ryzen 7 1700X Octa-Core ¬´Summit Ridge¬ª (Zen), SSD SATA - 500 Go, 64 Go de RAM DDR4</i> <br>  Le n≈ìud Ropsten testnet ETH a √©t√© soulev√©. <br>  3 n≈ìuds Plasma Cash valid√©s ont √©t√© relev√©s. <br><br>  <i>3. Intel Core i9-9900K Octa-Core incl.</i>  <i>SSD NVMe - 1 To, 64 Go de RAM DDR4</i> <br>  1 Le n≈ìud Submit Plasma Cash a √©t√© soulev√©. <br>  3 n≈ìuds Plasma Cash valid√©s ont √©t√© relev√©s. <br>  Un test a √©t√© lanc√© pour ajouter des transactions au r√©seau Plasma Cash. <br><br>  <b>Total:</b> 10 n≈ìuds Plasma Cash dans un r√©seau priv√©. <br><br><h3>  Test 1 </h3><br>  Il y a une limite de 1 million de transactions par bloc.  Par cons√©quent, 1 million de transactions se r√©partissent en 2 blocs (puisque le syst√®me parvient √† prendre une partie des transactions et √† les soumettre pendant leur envoi). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VhJAtRlmXVE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  √âtat initial: dernier bloc # 7;  1 million de transactions et jetons sont stock√©s dans la base de donn√©es. <br><br>  00:00 - d√©marrer le script de g√©n√©ration de transaction <br>  01:37 - 1 million de transactions ont √©t√© cr√©√©es et l'envoi au n≈ìud a commenc√© <br>  01:46 - le n≈ìud d'envoi a pris 240k transactions du pool et forme le bloc # 8.  Nous constatons √©galement que 320 000 transactions sont ajout√©es au pool en 10 secondes <br>  01:58 - le bloc # 8 est sign√© et envoy√© pour validation <br>  02:03 - le bloc # 8 est valid√© et la fonction `submitBlock` du contrat intelligent avec le hachage Merkle et le num√©ro de bloc est appel√©e <br>  02:10 - Le script de d√©monstration a fini de fonctionner, ce qui a envoy√© 1 million de transactions en 32 secondes <br>  02:33 - les n≈ìuds ont commenc√© √† recevoir des informations selon lesquelles le bloc # 8 a √©t√© ajout√© √† la cha√Æne racine, et ont commenc√© √† effectuer 240k transactions <br>  02:40 - 240k transactions ont √©t√© supprim√©es du pool, qui sont d√©j√† dans le bloc # 8 <br>  02:56 - le n≈ìud de soumission a pris les 760 000 transactions restantes du pool et a commenc√© √† calculer le hachage Merkle et √† signer le bloc # 9 <br>  03:20 - tous les n≈ìuds contiennent 1 mln 240 000 transactions et jetons <br>  03:35 - le bloc # 9 est sign√© et envoy√© pour validation aux autres n≈ìuds <br>  03:41 - une erreur r√©seau s'est produite <br>  04:40 - par timeout, l'attente de la validation du bloc # 9 s'est arr√™t√©e <br>  04:54 - le n≈ìud de soumission a pris les 760 000 transactions restantes du pool et a commenc√© √† calculer le hachage Merkle et √† signer le bloc # 9 <br>  05:32 - le bloc # 9 est sign√© et envoy√© pour validation aux autres n≈ìuds <br>  05:53 - le bloc # 9 est valid√© et envoy√© √† la cha√Æne racine <br>  06:17 - les n≈ìuds ont commenc√© √† recevoir des informations selon lesquelles le bloc # 9 a √©t√© ajout√© √† la cha√Æne racine et ont commenc√© √† effectuer 760 k transactions <br>  06:47 - le pool est effac√© des transactions qui sont dans le bloc # 9 <br>  09:06 - tous les n≈ìuds contiennent 2 millions de transactions et de jetons <br><br><h3>  Test 2 </h3><br>  Il y a une limite de 350k par bloc.  En cons√©quence, nous avons 3 blocs. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4BNpSYkwRvE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  √âtat initial: dernier bloc # 9;  2 millions de transactions et jetons stock√©s dans la base de donn√©es <br><br>  00:00 - le script de g√©n√©ration de transaction est d√©j√† en cours d'ex√©cution <br>  00:44 - 1 million de transactions ont √©t√© cr√©√©es et l'envoi au n≈ìud a commenc√© <br>  00:56 - le n≈ìud d'envoi a pris 320k transactions du pool et forme le bloc # 10.  Nous constatons √©galement que 320 000 transactions sont ajout√©es au pool en 10 secondes <br>  01:12 - le bloc # 10 est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  01:18 - Le script de d√©monstration a fini de fonctionner, ce qui a envoy√© 1 million de transactions en 34 secondes <br>  01:20 - le bloc # 10 est valid√© et envoy√© √† la cha√Æne racine <br>  01:51 - tous les n≈ìuds ont re√ßu des informations de la cha√Æne racine que le bloc # 10 a √©t√© ajout√©, et ils commencent √† appliquer 320k transactions <br>  02:01 - le pool a √©t√© effac√© pour 320k transactions ajout√©es au bloc # 10 <br>  02:15 - soumettre le noeud a pris 350k transactions du pool et forme le bloc # 11 <br>  02:34 - le bloc # 11 est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  02:51 - le bloc # 11 est valid√© et envoy√© √† la cha√Æne racine <br>  02:55 - le dernier n≈ìud a ex√©cut√© les transactions du bloc # 10 <br>  10h59 - tr√®s longtemps dans la cha√Æne racine, une transaction a √©t√© ex√©cut√©e avec une soumission de bloc # 9, mais elle a √©t√© termin√©e et tous les n≈ìuds ont re√ßu des informations √† ce sujet et ont commenc√© √† ex√©cuter 350 000 transactions <br>  11h05 - le pool a √©t√© effac√© pour 320k transactions qui ont √©t√© ajout√©es au bloc # 11 <br>  12:10 - tous les n≈ìuds contiennent 1 million de transactions et jetons 670k <br>  12:17 - soumettre le noeud a pris 330k transactions du pool et forme le bloc # 12 <br>  12:32 - le bloc # 12 est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  12:39 - le bloc # 12 est valid√© et envoy√© √† la cha√Æne racine <br>  13:44 - tous les n≈ìuds ont re√ßu des informations de la cha√Æne racine que le bloc # 12 a √©t√© ajout√© et commencent √† appliquer 330 000 transactions <br>  14:50 - tous les n≈ìuds contiennent 2 millions de transactions et de jetons <br><br><h3>  Test 3 </h3><br>  Sur les premier et deuxi√®me serveurs, un n≈ìud de validation a √©t√© remplac√© par un n≈ìud de soumission. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w5QHab3heIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  √âtat initial: dernier bloc # 84;  0 transactions et jetons sont stock√©s dans la base de donn√©es <br><br>  00:00 - 3 scripts sont lanc√©s qui g√©n√®rent et envoient 1 million de transactions <br>  01:38 - 1 million de transactions ont √©t√© cr√©√©es et l'envoi pour soumettre le noeud # 3 a commenc√© <br>  01:50 - soumettre le noeud # 3 a pris 330k transactions du pool et forme le bloc # 85 (f21).  Nous constatons √©galement que 350 000 transactions sont ajout√©es au pool en 10 secondes <br>  01:53 - 1 million de transactions ont √©t√© cr√©√©es et l'envoi pour soumettre le noeud # 1 a commenc√© <br>  01:50 - soumettre le noeud # 3 a pris 330k transactions du pool et forme le bloc # 85 (f21).  Nous constatons √©galement que 350 000 transactions sont ajout√©es au pool en 10 secondes <br>  02:01 - soumettre le noeud # 1 a pris 250k transactions du pool et forme le bloc # 85 (65e) <br>  02:06 - le bloc # 85 (f21) est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  02:08 - le script de d√©monstration du serveur # 3 a fini de fonctionner, ce qui a envoy√© 1 mln de transactions en 30 secondes <br>  02:14 - le bloc # 85 (f21) est valid√© et envoy√© √† la cha√Æne racine <br>  02:19 - le bloc # 85 (65e) est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  02:22 - 1 million de transactions ont √©t√© cr√©√©es et l'envoi pour soumettre le noeud # 2 a commenc√© <br>  02:27 - le bloc # 85 (65e) est valid√© et envoy√© √† la cha√Æne racine <br>  02:29 - soumettre le noeud # 2 a pris du pool 111855 transactions et forme le bloc # 85 (256). <br>  02:36 - le bloc # 85 (256) est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  02:36 - Le script de d√©monstration du serveur # 1 a fini de fonctionner, qui a envoy√© 1 mln de transactions en 42,5 secondes <br>  02:38 - le bloc # 85 (256) est valid√© et envoy√© √† la cha√Æne racine <br>  03h08 - le script serveur # 2, qui a envoy√© 1 million de transactions en 47 secondes, a fini de fonctionner <br>  03:38 - tous les n≈ìuds ont re√ßu des informations de la cha√Æne racine selon lesquelles les blocs # 85 (f21), # 86 (65e), # 87 (256) ont √©t√© ajout√©s et commencent √† appliquer des transactions 330k, 250k, 111855 <br>  03:49 - le pool a √©t√© effac√© √† 330k, 250k, 111855 transactions qui ont √©t√© ajout√©es aux blocs # 85 (f21), # 86 (65e), # 87 (256) <br>  03:59 - soumettre le n≈ìud n ¬∞ 1 a pris du pool 888145 transactions et formulaires bloc # 88 (214), soumettre le n≈ìud n ¬∞ 2 a pris du pool 750k transactions et formulaires bloc # 88 (50a), soumettre le n≈ìud n ¬∞ 3 a pris du pool 670k transactions et forme le bloc # 88 (d3b) <br>  04:44 - le bloc # 88 (d3b) est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  04:58 - le bloc # 88 (214) est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  05:11 - le bloc # 88 (50a) est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  05:11 - le bloc # 85 (d3b) est valid√© et envoy√© √† la cha√Æne racine <br>  05:36 - le bloc # 85 (214) est valid√© et envoy√© √† la cha√Æne racine <br>  05:43 - tous les n≈ìuds ont re√ßu des informations de la cha√Æne racine qui bloquent # 88 (d3b), # 89 (214) ont √©t√© ajout√©s et commencent √† appliquer 670k, 750k transactions <br>  06:50 - en raison d'une d√©connexion, le bloc # 85 (50a) n'a pas √©t√© valid√© <br>  06:55 - soumettre le noeud # 2 a pris 888145 transactions du pool et forme le bloc # 90 (50a) <br>  08:14 - le bloc # 90 (50a) est sign√© et envoy√© √† d'autres n≈ìuds pour validation <br>  09:04 - le bloc # 90 (50a) est valid√© et envoy√© √† la cha√Æne racine <br>  11:23 - tous les n≈ìuds ont re√ßu des informations de la cha√Æne racine que le bloc # 90 (50a) a √©t√© ajout√©, et 888145 transactions ont commenc√© √† √™tre appliqu√©es.  Dans le m√™me temps, le serveur n ¬∞ 3 applique depuis longtemps les transactions des blocs n ¬∞ 88 (d3b), n ¬∞ 89 (214) <br>  12:11 - toutes les piscines sont vides <br>  13:41 - tous les n≈ìuds de serveur # 3 contiennent 3 millions de transactions et de jetons <br>  14:35 - tous les n≈ìuds de serveur # 1 contiennent 3 millions de transactions et de jetons <br>  19:24 - tous les n≈ìuds de serveur # 2 contiennent 3 millions de transactions et de jetons <br><br><h2>  Obstacles </h2><br>  Au cours du d√©veloppement de Plasma Cash, nous avons rencontr√© les probl√®mes suivants, que nous avons progressivement r√©solus et r√©solvons: <br><br>  <b>1.</b> Le conflit d'interaction des diff√©rentes fonctions du syst√®me.  Par exemple, la fonction d'ajout de transactions au pool a bloqu√© la soumission et la validation des blocs, et vice versa, ce qui a entra√Æn√© une baisse de la vitesse. <br><br>  <b>2.</b> On ne savait pas imm√©diatement comment envoyer un grand nombre de transactions et en m√™me temps minimiser le co√ªt du transfert de donn√©es. <br><br>  <b>3.</b> Il n'√©tait pas clair comment et o√π stocker les donn√©es afin d'obtenir des r√©sultats √©lev√©s. <br><br>  <b>4. La</b> fa√ßon d'organiser un r√©seau entre les n≈ìuds n'√©tait pas claire, car la taille de bloc avec 1 million de transactions prend environ 100 Mo. <br><br>  <b>5. Le</b> travail en mode monothread coupe la connexion entre les n≈ìuds lorsque de longs calculs se produisent (par exemple, la construction d'un arbre Merkle et le calcul de son hachage). <br><br><h2>  Comment avons-nous g√©r√© tout cela? </h2><br>  La premi√®re version du n≈ìud Plasma Cash √©tait une sorte de combinaison qui pouvait tout faire en m√™me temps: accepter des transactions, soumettre et valider des blocs, fournir une API pour acc√©der aux donn√©es.  √âtant donn√© que NodeJS √©tait initialement monothread, la lourde fonction de calcul de l'arbre Merkle a bloqu√© la fonction d'ajout de transaction.  Nous avons vu deux options pour r√©soudre ce probl√®me: <br><br>  <b>1.</b> Ex√©cutez plusieurs processus NodeJS, chacun ex√©cutant certaines fonctions. <br><br>  <b>2.</b> Utilisez worker_threads et placez l'ex√©cution du code dans des threads. <br><br>  En cons√©quence, nous avons utilis√© les deux options en m√™me temps: divis√© logiquement un n≈ìud en 3 parties, qui peuvent fonctionner s√©par√©ment, mais en m√™me temps de mani√®re synchrone <br><br>  <b>1.</b> Soumettez un n≈ìud qui accepte les transactions dans le pool et cr√©e des blocs. <br><br>  <b>2.</b> Noeud de validation qui v√©rifie la validit√© des noeuds. <br><br>  <b>3.</b> Node API - fournit une API pour acc√©der aux donn√©es. <br><br>  Dans le m√™me temps, vous pouvez vous connecter √† chaque n≈ìud via un socket Unix √† l'aide de cli. <br><br>  Des op√©rations lourdes, comme le calcul de l'arbre de Merkle, nous avons effectu√© dans un flux s√©par√©. <br><br>  Ainsi, nous avons atteint le fonctionnement normal de toutes les fonctions Plasma Cash simultan√©ment et sans √©checs. <br><br>  D√®s que le syst√®me a fonctionn√©, nous avons commenc√© √† tester la vitesse et, malheureusement, nous avons obtenu des r√©sultats insatisfaisants: 5 000 transactions par seconde et jusqu'√† 50 000 transactions dans un bloc.  J'ai d√ª d√©couvrir ce qui n'√©tait pas mis en ≈ìuvre correctement. <br><br>  Pour commencer, nous avons commenc√© √† tester le m√©canisme de communication avec Plasma Cash pour d√©couvrir la capacit√© de pointe du syst√®me.  Plus t√¥t, nous avons √©crit que le n≈ìud Plasma Cash fournit une interface de socket Unix.  C'√©tait √† l'origine textuel.  Les objets json ont √©t√© envoy√©s en utilisant `JSON.parse ()` et `JSON.stringify ()`. <br><br><pre><code class="plaintext hljs">```json { "action": "sendTransaction", "payload":{ "prevHash": "0x8a88cc4217745fd0b4eb161f6923235da10593be66b841d47da86b9cd95d93e0", "prevBlock": 41, "tokenId": "57570139642005649136210751546585740989890521125187435281313126554130572876445", "newOwner": "0x200eabe5b26e547446ae5821622892291632d4f4", "type": "pay", "data": "", "signature": "0xd1107d0c6df15e01e168e631a386363c72206cb75b233f8f3cf883134854967e1cd9b3306cc5c0ce58f0a7397ae9b2487501b56695fe3a3c90ec0f61c7ea4a721c" } } ```</code> </pre> <br>  Nous avons mesur√© la vitesse de transfert de ces objets et re√ßu ~ 130k par seconde.  Ils ont essay√© de remplacer les fonctions standard par json, mais les performances ne se sont pas am√©lior√©es.  Il doit y avoir un moteur V8 bien optimis√© pour ces op√©rations. <br><br>  Le travail avec les transactions, les jetons, les blocs a √©t√© effectu√© √† travers les classes.  Lors de la cr√©ation de telles classes, les performances ont chut√© de 2 fois, ce qui indique: OOP ne nous convient pas.  J'ai d√ª tout r√©√©crire sur une approche purement fonctionnelle. <br><br><h2>  Ecrire dans la base de donn√©es </h2><br>  Initialement, Redis a √©t√© choisi pour le stockage de donn√©es comme l'une des solutions les plus productives qui r√©pondent √† nos exigences: stockage de valeur-cl√©, travail avec des tables de hachage, et bien d'autres.  Nous avons lanc√© redis-benchmark et obtenu ~ 80 000 op√©rations par seconde en 1 mode de pipeline. <br><br>  Pour des performances √©lev√©es, nous avons affin√© plus finement Redis: <br><br><ul><li>  √âtabli une connexion socket Unix. </li><li>  D√©sactivez l'enregistrement de l'√©tat sur le disque (pour plus de fiabilit√©, vous pouvez configurer la r√©plique et d√©j√† enregistrer sur le disque dans un Redis distinct). </li></ul><br>  Dans Redis, un pool est une table de hachage, car nous devons pouvoir recevoir toutes les transactions en une seule demande et supprimer les transactions une par une.  Nous avons essay√© d'utiliser une liste r√©guli√®re, mais cela fonctionne plus lentement lors du d√©chargement de la liste enti√®re. <br><br>  En utilisant la biblioth√®que NodeJS standard, les biblioth√®ques Redis ont r√©alis√© des performances de 18 000 transactions par seconde.  La vitesse a chut√© 9 fois. <br><br>  Puisque le benchmark nous a clairement montr√© les possibilit√©s 5 fois plus, ils ont commenc√© √† optimiser.  Nous avons chang√© la biblioth√®que en ioredis et obtenu une performance de 25k par seconde.  Nous avons ajout√© les transactions une par une en utilisant la commande `hset`.  Ainsi, nous avons g√©n√©r√© de nombreuses requ√™tes dans Redis.  Il y avait une id√©e de fusionner les transactions en bundles et de les envoyer avec une seule commande hmset.  Le r√©sultat est de 32k par seconde. <br><br>  Pour plusieurs raisons, qui seront d√©crites ci-dessous, nous travaillons avec des donn√©es en utilisant `Buffer` et, comme il s'est av√©r√©, si vous les traduisez en texte (` buffer.toString ('hex') ') avant d'√©crire, vous pouvez obtenir des performances suppl√©mentaires.  Ainsi, la vitesse a √©t√© augment√©e √† 35 km par seconde.  Pour le moment, nous avons d√©cid√© de suspendre toute optimisation suppl√©mentaire. <br><br>  Nous avons d√ª passer au protocole binaire car: <br><br>  <b>1.</b> Le syst√®me calcule souvent des hachages, des signatures, etc., et pour cela il a besoin de donn√©es dans `Buffer. <br><br>  <b>2.</b> Lors du transfert entre services, les donn√©es binaires p√®sent moins que le texte.  Par exemple, lors de l'envoi d'un bloc avec 1 million de transactions, les donn√©es du texte peuvent occuper plus de 300 m√©gaoctets. <br><br>  <b>3.</b> La conversion continue des donn√©es affecte les performances. <br><br>  Par cons√©quent, nous avons pris comme base notre propre protocole binaire pour le stockage et la transmission de donn√©es, d√©velopp√© sur la base de la merveilleuse biblioth√®que de donn√©es binaires. <br><br>  En cons√©quence, nous avons les structures de donn√©es suivantes: <br><br><h3>  - Transaction </h3><br><pre> <code class="plaintext hljs"> ```json { prevHash: BD.types.buffer(20), prevBlock: BD.types.uint24le, tokenId: BD.types.string(null), type: BD.types.uint8, newOwner: BD.types.buffer(20), dataLength: BD.types.uint24le, data: BD.types.buffer(({current}) =&gt; current.dataLength), signature: BD.types.buffer(65), hash: BD.types.buffer(32), blockNumber: BD.types.uint24le, timestamp: BD.types.uint48le, } ```</code> </pre><br><h3>  - Jeton </h3><br><pre> <code class="plaintext hljs"> ```json { id: BD.types.string(null), owner: BD.types.buffer(20), block: BD.types.uint24le, amount: BD.types.string(null), } ```</code> </pre><br><h3>  - Bloquer </h3><br><pre> <code class="plaintext hljs"> ```json { number: BD.types.uint24le, merkleRootHash: BD.types.buffer(32), signature: BD.types.buffer(65), countTx: BD.types.uint24le, transactions: BD.types.array(Transaction.Protocol, ({current}) =&gt; current.countTx), timestamp: BD.types.uint48le, } ```</code> </pre><br>  Par les commandes habituelles `BD.encode (block, Protocol) .slice ();` et `BD.decode (buffer, Protocol)`, nous convertissons les donn√©es en `Buffer` pour les enregistrer dans Redis ou envoyer un autre n≈ìud et r√©cup√©rer les donn√©es. <br><br>  Nous avons √©galement 2 protocoles binaires pour le transfert de donn√©es entre services: <br><br>  <i>- Protocole pour interagir avec le n≈ìud plasma via une prise Unix</i> <br><br><pre> <code class="plaintext hljs"> ```json { type: BD.types.uint8, messageId: BD.types.uint24le, error: BD.types.uint8, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  o√π: <br><br><ul><li>  <b>`type`</b> - action √† effectuer, par exemple, 1 - sendTransaction, 2 - getTransaction; </li><li>  <b>`payload`</b> - donn√©es √† transf√©rer vers la fonction correspondante; </li><li>  <b>`messageId`</b> - id du message afin que la r√©ponse puisse √™tre identifi√©e. </li></ul><br>  <i>- Protocole d'interaction entre les n≈ìuds</i> <br><br><pre> <code class="plaintext hljs"> ```json { code: BD.types.uint8, versionProtocol: BD.types.uint24le, seq: BD.types.uint8, countChunk: BD.types.uint24le, chunkNumber: BD.types.uint24le, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  o√π: <br><br><ul><li>  <b>`code`</b> - code de message, par exemple 6 - PREPARE_NEW_BLOCK, 7 - BLOCK_VALID, 8 - BLOCK_COMMIT; </li><li>  <b>`versionProtocol`</b> - version du protocole, car les n≈ìuds avec des versions diff√©rentes peuvent √™tre √©lev√©s sur le r√©seau et ils peuvent fonctionner de diff√©rentes mani√®res; </li><li>  <b>`seq`</b> - identifiant du message; </li><li>  <b>`countChunk` et`</b> <b>chunkNumber` sont</b> n√©cessaires pour diviser les gros messages; </li><li>  <b>`length` et`</b> <b>payload` la</b> longueur et les donn√©es elles-m√™mes. </li></ul><br>  Puisque nous avons tap√© les donn√©es au pr√©alable, le syst√®me final est beaucoup plus rapide que la biblioth√®que `rlp` d'Ethereum.  Malheureusement, nous n'avons pas encore pu le refuser, car il est n√©cessaire de finaliser le contrat intelligent, que nous pr√©voyons de faire √† l'avenir. <br><br>  Si nous avons r√©ussi √† atteindre une vitesse de <b>35 000</b> transactions par seconde, nous devons √©galement les traiter en temps optimal.  √âtant donn√© que le temps de formation approximatif du bloc prend 30 secondes, nous devons inclure <b>1 000 000 de</b> transactions dans le bloc, ce qui signifie envoyer plus de <b>100</b> Mo de donn√©es. <br><br>  Initialement, nous avons utilis√© la biblioth√®que `ethereumjs-devp2p` pour communiquer les n≈ìuds, mais elle ne pouvait pas g√©rer autant de donn√©es.  En cons√©quence, nous avons utilis√© la biblioth√®que `ws` et mis en place le transfert de donn√©es binaires sur websocket.  Bien s√ªr, nous avons √©galement rencontr√© des probl√®mes lors de l'envoi de gros paquets de donn√©es, mais nous les avons divis√©s en morceaux et maintenant il n'y a plus de tels probl√®mes. <br><br>  De plus, la formation de l'arbre Merkle et le calcul du hachage <b>de 1 000 000 de</b> transactions n√©cessitent environ <b>10</b> secondes de calcul continu.  Pendant ce temps, la connexion avec tous les n≈ìuds parvient √† se rompre.  Il a √©t√© d√©cid√© de transf√©rer ce calcul sur un thread s√©par√©. <br><br><h2>  Conclusions: </h2><br>  En fait, nos r√©sultats ne sont pas nouveaux, mais pour une raison quelconque, de nombreux experts les oublient pendant le d√©veloppement. <br><br><ul><li>  L'utilisation de la programmation fonctionnelle au lieu de la programmation orient√©e objet augmente les performances. </li><li>  Un monolithe est pire qu'une architecture de service pour un syst√®me de production sur NodeJS. </li><li>  L'utilisation de `worker_threads` pour le calcul intensif am√©liore la r√©activit√© du syst√®me, en particulier lorsque vous travaillez avec des op√©rations d'E / S. </li><li>  le socket unix est plus stable et plus rapide que les requ√™tes http. </li><li>  Si vous devez transf√©rer rapidement des donn√©es volumineuses sur le r√©seau, il est pr√©f√©rable d'utiliser des Websockets et d'envoyer des donn√©es binaires, divis√©es en morceaux, qui peuvent √™tre transmises si elles n'atteignent pas, puis fusionn√©es en un seul message. </li></ul><br>  Nous vous invitons √† visiter le projet <b>GitHub</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/opporty-com/Plasma-Cash/tree/new-version</a> <br><br>  L'article a √©t√© co-√©crit par <i>Alexander Nashivan</i> , d√©veloppeur principal de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Clever Solution Inc.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471096/">https://habr.com/ru/post/fr471096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471086/index.html">G√©n√©rateur de couverture musicale Python dans Blender</a></li>
<li><a href="../fr471088/index.html">Burn-out IT-sp√©cialistes: 4 histoires du manager, d√©veloppeur, produit et administrateur. Et la recette de Southbridge</a></li>
<li><a href="../fr471090/index.html">[Ne pas] utiliser CDN</a></li>
<li><a href="../fr471092/index.html">Commande CP: copier correctement les dossiers de fichiers vers * nix</a></li>
<li><a href="../fr471094/index.html">Tutu.ru et le Club des programmeurs de Moscou sont invit√©s √† une r√©union de backend le 17 octobre</a></li>
<li><a href="../fr471098/index.html">Perc√©e num√©rique - Comment c'√©tait</a></li>
<li><a href="../fr471100/index.html">Interaction entre les composants angulaires √† l'aide de RxJS</a></li>
<li><a href="../fr471102/index.html">DNS dynamique personnalis√© avec CloudFlare</a></li>
<li><a href="../fr471104/index.html">R√©sum√© des √©v√©nements informatiques d'octobre (deuxi√®me partie)</a></li>
<li><a href="../fr471112/index.html">Stupide raison pour laquelle votre application de vision industrielle astucieuse ne fonctionne pas: orientation dans EXIF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>