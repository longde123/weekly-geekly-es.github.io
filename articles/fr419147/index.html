<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕝 🔓 👨‍🍳 Cube à 1000 dimensions: est-il possible de créer un modèle informatique de la mémoire humaine aujourd'hui? ☹️ 🈂️ 🤣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce matin, en route vers le campus de Berkeley, j'ai passé mes doigts le long des feuilles d'un buisson parfumé, puis j'ai inhalé l'odeur familière. Je...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cube à 1000 dimensions: est-il possible de créer un modèle informatique de la mémoire humaine aujourd'hui?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419147/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hm/bf/hq/hmbfhq9wergzhrrb1fskxsurpsk.png" alt="image"></div><br>  Ce matin, en route vers le campus de Berkeley, j'ai passé mes doigts le long des feuilles d'un buisson parfumé, puis j'ai inhalé l'odeur familière.  Je fais cela tous les jours, et chaque jour le premier mot qui me vient dans la tête et agite la main en guise de salutation est de la <em>sauge</em> .  Mais je sais que cette plante n'est pas de la sauge, mais du romarin, alors je commande à la <em>sauge de se</em> calmer.  Mais trop tard.  Après le <em>romarin</em> et la <em>sauge,</em> je ne peux pas arrêter l'apparition du <em>persil</em> et du <em>thym</em> sur la scène, après quoi les premières notes de la mélodie et du visage apparaissent sur la couverture de l'album, et maintenant j'étais de retour au milieu des années 1960, vêtu d'une chemise avec des concombres.  Pendant ce temps, le <em>romarin</em> soulève un écart de 13 minutes dans la mémoire de Rose Mary Woods (bien que <em>maintenant</em> , après avoir consulté la mémoire collective, je sais que ce devrait être Rose Mary Woods et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un espace de 18 minutes et demie</a> ).  De Watergate, je passe aux histoires sur la page principale.  Puis je remarque dans un jardin bien entretenu une autre plante aux feuilles gris-vert duveteuses.  Ce n'est pas non plus de la sauge, mais un nettoyant (oreille d'agneau).  Cependant, la <em>sauge</em> obtient enfin son moment de gloire.  Des herbes, je passe au logiciel mathématique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sage</a> , puis au système de défense aérienne des années 50 appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SAGE</a> , l'environnement terrestre semi-automatique, qui était géré par le plus grand ordinateur jamais construit. <br><br>  En psychologie et en littérature, ces errances mentales sont appelées le <em>courant de conscience</em> (l'auteur de cette métaphore est William James).  Mais je choisirais une métaphore différente.  Ma conscience, pour autant que je le ressens, ne circule pas en douceur d'un sujet à un autre, mais flotte plutôt à travers le paysage des pensées, plus comme un papillon qu'une rivière, parfois cloué sur une fleur puis sur un autre, parfois emporté par des rafales, parfois en visite au même endroit encore et encore. <br><a name="habracut"></a><br>  Pour explorer l'architecture de ma propre mémoire, j'ai essayé de mener une expérience plus tranquille avec des associations libres.  J'ai commencé avec la même recette florale - persil, sauge, romarin et thym - mais pour cet exercice je n'ai pas flâné dans les jardins des collines de Berkeley;  Je me suis assis à table et j'ai pris des notes.  Le diagramme ci-dessous est la meilleure tentative pour reconstruire le cours complet de mes pensées. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/fp/e4/nxfpe47jmecnrrd9v1wju4k2xts.png"></div><br>  persil, sauge, romarin, thym - quatre herbes, ainsi qu'une réplique de la chanson Simon et Garfunkel. <br><br>  Simon et Garfunkel - Paul Simon et Art Garfunkel, un duo de chanteurs dans le genre folk rock des années 60 et 70. <br><br>  Madame  Robinson est une chanson de Simon et Garfunkel, ainsi qu'un personnage du film de Mike Nichols "The Graduate". <br><br>  "Où êtes-vous allé, Joe DiMaggio?"  - la question posée dans "Mme  Robinson. " <br><br>  Simon and Schuster est une maison d'édition fondée en 1924 par Richard Simon et Max Schuster (à l'origine pour la publication de mots croisés). <br><br>  Jackie Robinson est le légendaire joueur des Brooklyn Dodgers. <br><br>  Robinson Crusoe - roman de Daniel Defoe sur les naufragés (1719). <br><br>  Famille Swiss Robinsons - roman de Johan David Weiss sur les naufragés (1812). <br><br>  herbes - plantes aromatiques <br><br>  Monsieur  Wizard est une émission scientifique pour enfants du samedi 1950 organisée par Don Herbert. <br><br>  Alpert - trompettiste Armoiries d'Alpert. <br><br>  Les plastiques sont les conseils de carrière proposés par The Graduate. <br><br>  coo-coo-ca-choo - ligne de «Mme  Robinson. " <br><br>  Frank Robinson est un voltigeur des Orioles de Baltimore dans les années 1970. <br><br>  Greig Nettles est le troisième joueur de baseball des Yankees de New York dans les années 1970. <br><br>  Dustin Hoffman est un acteur qui a joué dans The Graduate. <br><br>  Abby Hoffman - "Yipee!" <br><br>  Leominster est une ville du Massachusetts qui est devenue le berceau de la fabrication de matières plastiques aux États-Unis. <br><br>  Brooks Robinson est le troisième joueur de baseball des Orioles de Baltimore dans les années 1970. <br><br>  Papillon ("The Moth") - un film de 1973 dans lequel Dustin Hoffman a joué un rôle secondaire;  "Papillon" en français, "papillon". <br><br>  Nabokov - Vladimir Nabokov, écrivain d'origine russe et entomologiste étudiant les papillons. <br><br>  papillon, Schmetterling, mariposa, farfalla - «papillon» en anglais, allemand, espagnol et italien;  il semble que tous (et le mot français aussi) sont d'origine indépendante. <br><br>  Comment s'appelle le papillon en russe - je ne sais pas.  Ou ne savait pas quand cette question s'est posée. <br><br>  «I am the Walrus» est une chanson des Beatles de 1967 qui a également la phrase «coo-coo-ca-choo». <br><br>  Carly Simon est chanteuse.  Aucun lien avec Paul Simon, mais est la fille de Richard Simon. <br><br>  "You're so vain" est une chanson de Carly Simon. <br><br>  Le graphique de haut en bas représente les sujets dans l'ordre dans lequel ils apparaissent dans le cerveau, mais les connexions entre les nœuds ne créent pas une seule séquence linéaire.  La structure ressemble à un arbre avec de courtes chaînes d'associations successives, se terminant par un retour brutal à un nœud antérieur, comme si j'étais tiré par une bande de caoutchouc tendue.  Ces interruptions sont marquées sur le graphique par des flèches vertes;  le X rouge ci-dessous est l'endroit où j'ai décidé de terminer l'expérience. <br><br>  Je m'excuse auprès de ceux qui sont nés après 1990, bon nombre des sujets mentionnés peuvent vous sembler dépassés ou mystérieux.  Des explications sont présentées sous le graphique, mais je ne pense pas qu'elles clarifieront les associations.  Au final, les souvenirs sont personnels, ils vivent à l'intérieur de la tête.  Si vous souhaitez collecter une collection d'idées pertinentes pour votre propre expérience, il vous suffit de créer votre propre calendrier d'associations gratuites.  Je recommande fortement de faire ceci: vous pouvez constater que vous ne saviez pas que vous savez quelque chose. <br><br><hr><br>  Le but de ma marche quotidienne sur la colline de Berkeley est le Simons Institute et le Computational Theory Course, auxquels je participe à un programme d'un semestre sur le cerveau et le calcul.  Un tel environnement suscite des pensées de pensées.  J'ai commencé à réfléchir: comment construire un modèle de calcul du processus de libre association?  Parmi les différentes tâches proposées à résoudre par l'intelligence artificielle, celle-ci semble assez simple.  Il n'y a pas besoin de rationalisation profonde;  tout ce que nous devons simuler, c'est juste rêver et errer dans les nuages ​​- c'est ce que fait le cerveau lorsqu'il n'est pas chargé.  Il semble qu'une telle tâche soit facile à résoudre, n'est-ce pas? <br><br>  La première idée qui me vient à l'esprit (du moins à <em>ma</em> tête) concernant l'architecture d'un tel modèle de calcul est un mouvement aléatoire le long d'un graphe ou d'un réseau mathématique.  Les nœuds de réseau sont des éléments stockés en mémoire - idées, faits, événements - et les communications sont différents types d'associations entre eux.  Par exemple, un nœud <em>papillon</em> peut être connecté avec un <em>papillon de nuit, une chenille, un monarque</em> et une <em>nacre,</em> ainsi qu'avec les transitions mentionnées dans mon calendrier, et peut-être avoir des connexions moins évidentes, par exemple <em>, l'exploration australienne »,« Shrimp »,« Mohammed Ali »,« pellagra »,« choke »</em> et <em>« stage fear »</em> .  La structure des données de l'hôte contiendra une liste de pointeurs vers tous ces hôtes associés.  Les pointeurs peuvent être numérotés de 1 à n;  le programme générera un nombre pseudo-aléatoire dans cet intervalle et ira au nœud correspondant, dans lequel toute la procédure recommencera. <br><br>  Cet algorithme reflète certaines caractéristiques de base des associations libres, mais beaucoup d'entre elles ne sont pas prises en compte.  Le modèle suppose que tous les nœuds cibles sont également probables, ce qui semble peu plausible.  Pour prendre en compte la différence de probabilités, on peut demander à chaque arête <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">je</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.802ex" height="1.937ex" viewBox="0 -728.2 345.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMATHI-69" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> i </script>  poids <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-msubsup" id="MJXp-Span-4"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-6" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.464ex" height="1.817ex" viewBox="0 -520.7 1060.8 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMATHI-69" x="1013" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> w_i </script>  , puis rendre les probabilités proportionnelles aux poids. <br><br>  Plus compliqué encore est le fait que les poids dépendent du contexte - de l'histoire récente de l'activité mentale humaine.  Si je n'avais pas de combinaison de Mme  Robinson et Jackie Robinson, penserais-je à Joe Di Maggio?  Et maintenant, quand j'écris ceci, Joltin 'Joe (surnom Di Maggio) rappelle Marilyn Monroe, puis Arthur Miller, et encore une fois je ne peux pas arrêter le train de la pensée.  Pour reproduire cet effet dans un modèle informatique, un mécanisme de régulation dynamique des probabilités de catégories entières de nœuds en fonction des autres nœuds récemment visités sera nécessaire. <br><br>  Vous devez également considérer les effets d'une nouveauté d'un type différent.  Un élastique devrait être trouvé dans le modèle, me ramenant constamment vers Simon et Garfunkel et Mme.  Robinson  Probablement, chaque site récemment visité devrait être ajouté à la liste des options cibles, même s'il n'est en aucun cas connecté au site actuel.  D'un autre côté, la dépendance est également une possibilité: les pensées trop souvent mémorisées deviennent ennuyeuses, elles doivent donc être supprimées dans le modèle. <br><br>  Un autre test final: certains souvenirs ne sont pas des faits ou des idées isolés, mais des parties de l'histoire.  Ils ont une structure narrative avec des événements se déroulant dans l'ordre chronologique.  Pour les nœuds de tels souvenirs épisodiques, le bord <em>suivant</em> , et éventuellement <em>précédent</em> , est requis.  Une telle chaîne de côtes unit toute notre vie, y compris tout ce dont vous vous souvenez. <br><br><hr><br>  Un modèle informatique similaire peut-il reproduire mes errances mentales?  La collecte de données pour un tel modèle sera un processus assez long, et cela n'est pas surprenant, car il m'a fallu toute une vie pour remplir mon crâne d'entrelacement d'herbes, d'armoiries, de Simons, de Robinsons et de Hoffmanns.  Bien plus que la quantité de données, je me soucie de la minutie de l'algorithme de traversée de graphe.  Il est très facile de dire: «choisissez un nœud en fonction de l'ensemble des probabilités pondérées», mais quand je regarde les détails sales de la mise en œuvre de cette action, je peux difficilement imaginer que quelque chose comme ça se passe dans le cerveau. <br><br>  Voici l'algorithme le plus simple que je connaisse pour la sélection pondérée aléatoire.  (Ce n'est pas le plus efficace de ces algorithmes, mais les méthodes sont encore plus chaotiques. Keith Schwartz a écrit un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel et une revue</a> sur ce sujet.) Supposons qu'une structure de données simulant un nœud de réseau comprend une liste de liens vers d'autres nœuds et une liste correspondante de poids .  Comme le montre la figure ci-dessous, le programme génère un certain nombre de sommes de poids accumulées: <math></math><img src="https://habrastorage.org/getpro/habr/formulas/17a/d19/fdd/17ad19fdd662ae349c7f22fcdedef72e.svg" alt="0 $, w_1, w_1 + w_2, w_1 + w_2 + w_3, \ points $" data-tex="inline">  .  L'étape suivante consiste à normaliser cette série en divisant chaque nombre par la somme totale des poids.  Maintenant, nous avons une série de chiffres <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-msubsup" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-10" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.059ex" height="1.817ex" viewBox="-38.5 -520.7 886.3 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMATHI-69" x="712" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> p_i </script>  passant de zéro à l'unité de façon monotone.  Ensuite, le programme sélectionne un nombre réel aléatoire <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMATHI-78" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> x </script>  de l'intervalle <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-17"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.91ex" height="2.66ex" viewBox="0 -832 2114.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMAIN-5B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMAIN-30" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMAIN-2C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMAIN-31" x="1224" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhhqs1LhhDhwGB7whETLGE0P9lMe_A#MJMAIN-29" x="1724" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> [0, 1) </script>  ; <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> x </script>  doit être dans l'un des intervalles normalisés <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-24" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> p_i </script>  , et cette valeur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-25"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">je</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> i </script>  définit le prochain nœud sélectionnable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/tb/lp/fqtblpodseuus5fug9ael204d7y.png"></div><br>  Dans le code du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langage de programmation Julia, la</a> procédure de sélection de nœud ressemble à ceci: <br><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(links, weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cum_weights</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cumsum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probabilities</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cum_weights</span></span></span><span class="hljs-function"> / </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function">:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(probabilities)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probabilities</span></span></span><span class="hljs-function">[</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">] &gt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Je décris ces détails ennuyeux des sommes accumulées et des nombres pseudo-aléatoires si lentement pour souligner de cette façon que cet algorithme de parcours de graphe n'est pas aussi simple qu'il y paraît à première vue.  Et nous n'avons pas encore examiné le sujet du changement des probabilités à la volée, bien que notre attention flotte d'un sujet à l'autre. <br><br>  Il est encore plus difficile de comprendre le processus d'apprentissage - en ajoutant de nouveaux nœuds et arêtes au réseau.  J'ai terminé ma session d'associations libres quand je suis arrivé à une question à laquelle je n'ai pas pu répondre: quel est le nom d'un papillon en russe?  Mais <em>maintenant</em> je peux lui répondre.  La prochaine fois que je jouerai à ce jeu, j'ajouterai le mot <em>babochka</em> à la liste.  Dans un modèle de calcul, l'insertion d'un nœud pour le mot <em>babochka</em> est une tâche assez simple, mais notre nouveau nœud doit également être connecté à tous les nœuds papillon existants.  De plus, la <em>babochka</em> ajoute elle-même de nouvelles côtes.  Elle est phonétiquement proche de <em>babouchka</em> (grand-mère) - l'un des nombreux mots russes de mon dictionnaire.  Le suffixe <em>-ochka est</em> diminutif, il doit donc être associé aux français <em>-ette</em> et italien <em>-ini</em> .  Le sens littéral du mot <em>babochka</em> est «petite âme», ce qui implique un nombre encore plus grand d'associations.  Après tout, l'apprentissage d'un seul nouveau mot peut nécessiter une réindexation complète de tout l'arbre des connaissances. <br><br><hr><br>  Essayons une autre méthode.  Oubliez la traversée aléatoire d'un réseau avec ses spaghettis des pointeurs aux nœuds.  Au lieu de cela, nous allons simplement stocker toutes les choses similaires dans le quartier.  Du point de vue des banques de mémoire informatique numérique, cela signifie que des choses similaires seront stockées à des adresses voisines.  Voici un segment de mémoire hypothétique centré sur le concept de <em>chien</em> .  Les lieux voisins sont occupés en d'autres termes, concepts et catégories qui sont le plus susceptibles d'être causés par la pensée d'un chien ( <em>chien</em> ): <em>chat</em> évident (chat) et <em>chiot</em> (chiot), différentes races de chiens et plusieurs chiens spécifiques (Skippy est notre chien de famille, qui était dans mon enfance), ainsi que, éventuellement, des associations plus complexes.  Chaque article a une adresse numérique.  L'adresse n'a pas de signification profonde, mais il est important que toutes les cellules de mémoire soient numérotées dans l'ordre. <br><br><table><tbody><tr><th>  l'adresse </th><th>  le contenu </th></tr><tr><td>  19216805 </td><td>  dieu </td></tr><tr><td>  19216806 </td><td>  le chien qui n'a pas aboyé dans la nuit </td></tr><tr><td>  19216807 </td><td>  Skippy </td></tr><tr><td>  19216808 </td><td>  Lassie </td></tr><tr><td>  19216809 </td><td>  canin </td></tr><tr><td>  19216810 </td><td>  chat </td></tr><tr><td>  19216811 </td><td>  chien </td></tr><tr><td>  19216812 </td><td>  chiot </td></tr><tr><td>  19216813 </td><td>  loup </td></tr><tr><td>  19216814 </td><td>  grotte canem </td></tr><tr><td>  19216815 </td><td>  Basset hound </td></tr><tr><td>  19216816 </td><td>  Braque de Weimar </td></tr><tr><td>  19216817 </td><td>  dogmatique </td></tr></tbody></table><br>  La tâche de se promener tranquillement autour de ce tableau en mémoire peut être assez simple.  Il peut traverser des adresses mémoire de manière aléatoire, mais l'avantage sera donné à de petites étapes.  Par exemple, la prochaine adresse visitée peut être déterminée par échantillonnage à partir d'une distribution normale centrée sur l'emplacement actuel.  Voici le code de Julia.  (La fonction <code>randn()</code> renvoie un nombre réel aléatoire obtenu à partir d'une distribution normale avec une valeur moyenne <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mtext" id="MJXp-Span-28">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> \ mu = 0 </script>  et écart type <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-41"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> \ sigma = 1 </script>  .) <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gaussian_ramble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr, sigma)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sigma</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addr</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int, r)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Un tel schéma présente des caractéristiques intéressantes.  Il n'est pas nécessaire de tabuler tous les nœuds cibles possibles avant de choisir l'un d'entre eux.  Les probabilités ne sont pas stockées sous forme de nombres, mais codées par la position dans le tableau, et également modulées par le paramètre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mtext" id="MJXp-Span-43">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> \ sigma </script>  , qui détermine jusqu'où la procédure veut se déplacer dans le tableau.  Bien que le programme exécute toujours l'arithmétique pour échantillonner à partir de la distribution normale, une telle fonction est susceptible d'être une solution plus simple. <br><br>  Mais encore, cette procédure a un défaut terrifiant.  Après avoir entouré le <em>chien de</em> toutes ses associations directes, nous n'avons laissé aucune place à <em>leurs</em> associations.  Les termes de chien sont bons dans leur propre contexte, mais qu'en est-il du <em>chat</em> de la liste?  Où met-on <em>chaton</em> , <em>tigre</em> , <em>neuf vies</em> et <em>Félix</em> ?  Dans un tableau unidimensionnel, il n'y a aucun moyen d'incorporer chaque élément de mémoire dans un environnement approprié. <br><br>  Passons donc à deux dimensions!  En divisant les adresses en deux composantes, nous définissons deux axes orthogonaux.  La première moitié de chaque adresse devient la coordonnée <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-49"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> y </script>  et la deuxième coordonnée <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-51"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> x </script>  .  Maintenant, le <em>chien</em> et le <em>chat</em> sont toujours des voisins proches, mais ils ont aussi des espaces personnels dans lesquels ils peuvent jouer avec leurs propres «amis». <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/kn/ef/ifknefmf6isjnhavuzpqj-q0epi.png"></div><br>  Cependant, deux mesures ne suffisent pas non plus.  Si nous essayons de remplir tous les éléments liés au <em>chat dans le chapeau</em> , ils commenceront inévitablement à entrer en collision et à entrer en conflit avec les éléments connexes du <em>chien qui n'ont pas aboyé dans la nuit</em> .  De toute évidence, nous avons besoin de plus de dimensions - beaucoup plus. <br><br><hr><br>  C'est le bon moment pour l'admettre - je ne suis pas le premier à penser à la façon dont les souvenirs peuvent être organisés en mémoire.  La liste de mes prédécesseurs peut être commencée avec Platon, qui a comparé la mémoire avec un oiseau;  nous reconnaissons les souvenirs par leur plumage, mais parfois il nous est difficile de les récupérer s'ils commencent à voltiger dans la cellule de notre crâne.  Le jésuite Matteo Ricci du XVIe siècle a parlé du «palais de la mémoire» dans lequel nous nous promenons dans diverses salles et couloirs à la recherche des trésors du passé.  Les théories modernes de la mémoire sont généralement moins imaginatives, mais plus détaillées et visent le passage de la métaphore au mécanisme.  Personnellement, ce que j'aime le plus, c'est le modèle mathématique obtenu dans les années 1980 par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pentti Canerva</a> , qui travaille maintenant au Redwood Center for Theoretical Neuroscience ici à Berkeley.  Il a eu l'idée d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une mémoire distribuée clairsemée</a> , que j'appellerai SDM.  Il applique avec succès la géométrie étonnante des espaces de grande dimension. <br><br>  Imaginez un cube en trois dimensions.  Si nous supposons que la longueur du côté est égale à l'unité de mesure, alors huit vecteurs peuvent être désignés par des vecteurs de trois chiffres binaires, en commençant par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mn" id="MJXp-Span-54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> 000 </script>  et se terminant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-mn" id="MJXp-Span-56"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> 111 </script>  .  À n'importe quel sommet, la modification d'un seul bit du vecteur nous amène au sommet qui est le plus proche voisin.  Changer deux bits nous déplace vers le prochain voisin le plus proche, et remplacer les trois bits conduit au coin opposé du cube - au sommet le plus éloigné. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ji/w0/zm/jiw0zmihd76v1dliq5ocpkmr7a0.png"></div><br>  Un cube en quatre dimensions fonctionne de manière similaire - <math></math><img src="https://habrastorage.org/getpro/habr/formulas/ede/b88/0f9/edeb880f9f7b63330852174a59d9f35f.svg" alt="16 $" data-tex="inline">  les sommets sont indiqués par des vecteurs contenant toutes les combinaisons de chiffres binaires, commençant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mn" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> 0000 </script>  et se terminant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-59"><span class="MJXp-mn" id="MJXp-Span-60"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1111</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> 1111 </script>  .  Cette description est en fait généralisée à <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> N </script>  dimensions où chaque sommet a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> N </script>  vecteur de coordonnées de bits.  Si nous mesurons la distance selon la métrique de Manhattan - en se déplaçant toujours le long des bords du cube et en ne coupant jamais le long de la diagonale - alors la distance entre deux vecteurs sera le nombre de positions dans lesquelles deux vecteurs de coordonnées diffèrent (on l'appelle également la distance de Hamming).  (Pour un OU exclusif, le symbole , parfois appelé <em>chignon</em> , est généralement utilisé. Il affiche l'opération XOR sous forme d'addition binaire modulo 2. Kanerva préfère ∗ ou ⊗ sur la base que le rôle de XOR dans l'informatique à haute dimension ressemble plus à la multiplication qu'à l'addition . J'ai décidé de me débarrasser de cette contradiction en utilisant le symbole &amp; veebar; - une façon alternative d'écrire XOR, familier des logiciens. Il s'agit d'une modification du symbole ∨ - y compris OR. Il est pratique que ce soit aussi un symbole XOR dans les programmes Julia.) Ainsi, l'unité  la mesure de la distance est un bit et le calcul de la distance est une tâche pour l'opérateur OU exclusif binaire (XOR, &amp; veebar;), qui nous donne une valeur pour différents bits <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mn" id="MJXp-Span-66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> 1 </script>  , et pour des paires identiques - la valeur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mn" id="MJXp-Span-68"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> 0 </script>  : <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">&amp;veebar; 0 = 0 0 &amp;veebar; 1 = 1 1 &amp;veebar; 0 = 1 1 &amp;veebar; 1 = 0</span></span></code> </pre> <br>  La fonction sur Julia pour mesurer la distance entre les sommets applique la fonction XOR à deux vecteurs de coordonnées et renvoie la quantité en conséquence <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mn" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> 1 </script>  . <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u</span></span></span><span class="hljs-function"> &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veebar</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_ones</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Quand <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> N </script>  devenir assez grand, certaines propriétés curieuses apparaissent <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-73"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> N </script>  -cube.  Considérez <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-75"><span class="MJXp-mn" id="MJXp-Span-76"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> 1000 </script>  -Cube dimensionnel ayant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-77"><span class="MJXp-msubsup" id="MJXp-Span-78"><span class="MJXp-mn" id="MJXp-Span-79" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-80" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-81"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> 2 ^ {1000} </script>  pics.  Si nous sélectionnons au hasard ses deux sommets, quelle sera la distance attendue entre eux?  Bien qu'il s'agisse d'une question de distance, mais nous pouvons y répondre sans plonger dans la géométrie - c'est juste la tâche de calculer les positions auxquelles deux vecteurs binaires sont distingués.  Pour les vecteurs aléatoires, chaque bit peut également être égal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-82"><span class="MJXp-mn" id="MJXp-Span-83"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> 0 </script>  ou <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-84"><span class="MJXp-mn" id="MJXp-Span-85"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> 1 </script>  par conséquent, il est prévu que les vecteurs différeront dans la moitié des positions de bits.  En cas de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-86"><span class="MJXp-mn" id="MJXp-Span-87"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> 1000 </script>  la distance standard de vecteur de bit est <math></math><img src="https://habrastorage.org/getpro/habr/formulas/b7f/44b/b8a/b7f44bb8a597e4961648677adf87806b.svg" alt="500 $" data-tex="inline">  bits.  Ce résultat ne nous surprend pas.  Cependant, <em>il convient de</em> noter que toutes les distances entre les vecteurs sont étroitement accumulées autour de la valeur moyenne de 500. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/yv/cd/d7yvcdznrtlsgollbjvqf113jak.png"></div><br>  En cas de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mn" id="MJXp-Span-89"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> 1000 </script>  -vecteurs de bits presque toutes les paires sélectionnées au hasard sont à une distance de <math></math><img src="https://habrastorage.org/getpro/habr/formulas/b43/205/d92/b43205d928fd3958d4e80ed01cf1d514.svg" alt="450 $" data-tex="inline">  avant <math></math><img src="https://habrastorage.org/getpro/habr/formulas/4b8/c79/217/4b8c7921706b088e4809c650d4fcd199.svg" alt="550 $" data-tex="inline">  peu.  Dans un échantillon de cent millions de paires aléatoires <em>(voir graphique ci-dessus),</em> aucune d’elles n’est plus <math></math><img src="https://habrastorage.org/getpro/habr/formulas/850/275/953/850275953cfb9fd21b83c00df6ad13bb.svg" alt="400 $" data-tex="inline">  peu ou plus loin que <math></math><img src="https://habrastorage.org/getpro/habr/formulas/a8d/3b2/ce4/a8d3b2ce4c94553897122cb7df1c9eef.svg" alt="600 $" data-tex="inline">  peu.  Rien dans notre vie dans un espace à faible résolution ne nous a préparé à une telle accumulation de probabilités dans la distance moyenne.  Ici sur Terre, nous pouvons trouver un endroit où nous serons complètement seuls, quand presque tous seront à quelques milliers de kilomètres de nous;  cependant, il n'y a aucun moyen de redistribuer la population de la planète pour que <em>tout le monde soit</em> en même temps dans un tel état.  Mais dans <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-90"><span class="MJXp-mn" id="MJXp-Span-91"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> 1000 </script>  -espace dimensionnel la situation est juste cela. <br><br>  Inutile de dire qu'il est difficile d'imaginer <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mn" id="MJXp-Span-93"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> 1000 </script>  -cube dimensionnel, mais nous pouvons avoir une petite compréhension intuitive de la géométrie, au moins pour l'exemple de cinq dimensions.  Ci-dessous, un tableau de toutes les coordonnées des sommets dans un cube à cinq dimensions de dimension unitaire, arrangé en fonction de la distance de Hamming du point de départ <math></math><img src="https://habrastorage.org/getpro/habr/formulas/4e2/f0d/61e/4e2f0d61e0971a9608fb381f2f23f868.svg" alt="00 000 $" data-tex="inline">  .  La plupart des pics (20 sur 32) sont à des distances moyennes - deux ou trois bits.  Le tableau aurait la même forme à tout autre sommet pris comme point de départ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/hj/yd/bchjydq4whfiksudz4grybvi7uy.png"></div><br>  Une sérieuse objection à toutes ces discussions. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mn" id="MJXp-Span-95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 1000 </script>  -Les cubes dimensionnels sont que nous ne pouvons jamais construire quelque chose comme ça;  dans l'univers, il n'y a pas assez d'atomes pour la structure de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-msubsup" id="MJXp-Span-97"><span class="MJXp-mn" id="MJXp-Span-98" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-99" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-100"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> 2 ^ {1000} </script>  pièces.  Mais Kanerva souligne que nous avons besoin d'espaces pour stocker uniquement les éléments que nous voulons stocker.  Nous pouvons concevoir des équipements pour un échantillonnage aléatoire, par exemple <math></math><img src="https://habrastorage.org/getpro/habr/formulas/1a5/b39/a24/1a5b39a243d9a1305e8eaefb0123feff.svg" alt="10 $ ^ 8 $" data-tex="inline">  sommets (dont chacun a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mn" id="MJXp-Span-102"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> 1000 </script>  -bit) et laissez le reste du cube avec une infrastructure fantomatique et inachevée.  Kanerva appelle un tel sous-ensemble des sommets qui existe dans les <em>cellules dures</em> "matérielles" <em>(emplacements durs)</em> .  Beaucoup de <math></math><img src="https://habrastorage.org/getpro/habr/formulas/1a5/b39/a24/1a5b39a243d9a1305e8eaefb0123feff.svg" alt="10 $ ^ 8 $" data-tex="inline">  les cellules solides aléatoires présenteront toujours la même distribution de distance compressée qu'un cube complet;  c'est exactement ce qui est montré dans le tableau ci-dessus. <br><br>  L'isolement relatif de chaque sommet dans un cube de grande taille nous donne un indice d'un avantage possible de la mémoire distribuée déchargée: l'élément stocké a suffisamment d'espace et peut être distribué sur une vaste zone sans déranger ses voisins.  C'est vraiment une caractéristique exceptionnelle de SDM, mais il y a autre chose. <br><br><hr><br>  Dans la mémoire informatique traditionnelle, les adresses et les éléments de données stockés sont mappés un à un.  Les adresses sont des entiers ordinaux d'une plage fixe, disons <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-105"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-107"><span class="MJXp-mn" id="MJXp-Span-108" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-109" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-110"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></span></span></span><span class="MJXp-mo" id="MJXp-Span-111" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> [0, 2 ^ {64}) </script>  .  Chaque entier de cette plage définit un seul endroit séparé en mémoire, et chaque endroit est associé à exactement une adresse.  De plus, à chaque endroit, une seule valeur est stockée à la fois;  lors de l'écriture d'une nouvelle valeur, l'ancienne est écrasée. <br><br>  SDM viole toutes ces règles.  Il a un immense espace d'adressage - pas moins <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="MJXp-msubsup" id="MJXp-Span-113"><span class="MJXp-mn" id="MJXp-Span-114" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-115" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-116"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> 2 ^ {1000} </script>  - mais seule une infime fraction aléatoire de ces lieux existe en tant qu'entités physiques;  c'est pourquoi la mémoire est appelée <em>clairsemée</em> .  Une seule information n'est pas stockée dans un seul endroit en mémoire;  de nombreux exemplaires sont distribués sur la zone - il est donc <em>distribué</em> .  De plus, dans chaque adresse distincte, plusieurs éléments de données peuvent être stockés en même temps.  Autrement dit, les informations sont réparties sur une vaste zone et regroupées en un seul point.  Cette architecture brouille également la distinction entre les adresses mémoire et les contenus mémoire;  dans de nombreux cas, la configuration binaire stockée est utilisée comme sa propre adresse.  Enfin, la mémoire peut répondre à une adresse partielle ou approximative et est très susceptible de trouver le bon article.  Alors que la mémoire traditionnelle est le «mécanisme de correspondance exacte», SDM est le «meilleur mécanisme de correspondance», renvoyant l'élément le plus similaire à celui demandé. <br><br>  Dans son livre de 1988, Kanerva fournit une analyse quantitative détaillée de la mémoire distribuée clairsemée avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-117"><span class="MJXp-mn" id="MJXp-Span-118"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1000 </script>  mesures et <math></math><img src="https://habrastorage.org/getpro/habr/formulas/66c/fbe/583/66cfbe5832c717f2a28e84c988ddd249.svg" alt="1 000 000 $" data-tex="inline">  cellules solides.  Les cellules solides sont sélectionnées au hasard dans tout l'espace. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-119"><span class="MJXp-msubsup" id="MJXp-Span-120"><span class="MJXp-mn" id="MJXp-Span-121" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-122" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-123"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> 2 ^ {1000} </script>  vecteurs d'adresse possibles.  Chaque cellule solide dispose d'un espace de stockage pour plusieurs <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mn" id="MJXp-Span-125"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> 1000 </script>  vecteurs de bits.  La mémoire dans son ensemble est conçue pour le stockage d'au moins <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0fe/af7/cee/0feaf7cee3e7aee1b802f352677072c8.svg" alt="10 000 $" data-tex="inline">  motifs uniques.  Ci-dessous, je considérerai cette mémoire comme un modèle SDM canonique, malgré le fait que selon les normes des mammifères, cela ne suffit pas, et dans un travail plus récent, Kanerva a souligné les vecteurs avec au moins <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0fe/af7/cee/0feaf7cee3e7aee1b802f352677072c8.svg" alt="10 000 $" data-tex="inline">  mesures. <br><br>  C'est ainsi que la mémoire fonctionne dans une implémentation informatique simple.  La commande <code>store(X)</code> écrit un vecteur en mémoire <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> X </script>  , le considérant à la fois comme une adresse et un contenu.  Valeur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-128"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> X </script>  stocké dans toutes les cellules solides à une certaine distance <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-130"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-43"> X </script>  .  Dans le modèle canonique, cette distance est de 451 bits.  Il définit un «cercle d'accès» destiné à unir en lui-même environ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-132"><span class="MJXp-mn" id="MJXp-Span-133"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-44"> 1000 </script>  cellules solides;  en d'autres termes, chaque vecteur est stocké approximativement dans <math></math><img src="https://habrastorage.org/getpro/habr/formulas/4a0/5a7/670/4a05a76703ce7519c75e66ab637c5559.svg" alt="1/1000 $" data-tex="inline">  l'une d'un million de cellules solides. <br><br>  Il est également important de noter que l'élément stocké <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-134"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-135"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-45"> X </script>  pas nécessairement choisir parmi <math></math><img src="https://habrastorage.org/getpro/habr/formulas/66c/fbe/583/66cfbe5832c717f2a28e84c988ddd249.svg" alt="1 000 000 $" data-tex="inline">  vecteurs binaires qui sont des adresses de cellules solides.  Au contraire. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46"> X </script>  peut être l'un des <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-138"><span class="MJXp-msubsup" id="MJXp-Span-139"><span class="MJXp-mn" id="MJXp-Span-140" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-141" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-142"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47"> 2 ^ {1000} </script>  modèles binaires possibles. <br><br>  Supposons que mille copies soient déjà écrites dans le SDM <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-143"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-48"> X </script>  , après quoi un nouvel élément arrive <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-145"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-49-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-49"> Y </script>  , qui doit également être stocké dans son propre ensemble de milliers de cellules solides.  Entre ces deux ensembles, il peut y avoir une intersection - les endroits où <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-147"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-50-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-50"> X </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-149"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-150"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51"> Y </script>  .  La nouvelle valeur n'écrase ni ne remplace la précédente;  les deux valeurs sont enregistrées.  Lorsque la mémoire est pleine à sa capacité <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0fe/af7/cee/0feaf7cee3e7aee1b802f352677072c8.svg" alt="10 000 $" data-tex="inline">  chacun d'eux est enregistré <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-151"><span class="MJXp-mn" id="MJXp-Span-152"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52"> 1000 </script>  fois, et dans une cellule dure typique, les copies seront stockées <math></math><img src="https://habrastorage.org/getpro/habr/formulas/90c/2a2/ef3/90c2a2ef3f252b20073a97d9f796ad28.svg" alt="10 $" data-tex="inline">  motifs uniques. <br><br>  Maintenant, la question est: comment utiliser cette mémoire mixte?  En particulier, comment obtenir la bonne valeur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-153"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-53-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-53"> X </script>  sans affecter <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-155"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-54-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-54"> Y </script>  et tous les autres articles qui se sont accumulés dans un seul endroit de stockage? <br><br>  L'algorithme de lecture utilisera la propriété d'une curieuse distribution des distances dans un espace de grande dimension.  Même si <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-157"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-55-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-55"> X </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-159"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-56-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-56"> Y </script>  sont les voisins les plus proches de <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0fe/af7/cee/0feaf7cee3e7aee1b802f352677072c8.svg" alt="10 000 $" data-tex="inline">  les modèles stockés, ils différeront très probablement de 420 ou 430 bits;  par conséquent, le nombre de cellules solides dans lesquelles les deux valeurs sont stockées est assez faible - généralement quatre, cinq ou six.  Il en va de même pour tous les autres motifs se croisant avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-161"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-57-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-57"> X </script>  .  Il y en a des milliers, mais aucun des modèles influents n'est présent en plus de quelques exemplaires dans le cercle d'accès <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-163"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-164"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-58-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-58"> X </script>  . <br><br>  La commande <code>fetch(X)</code> doit renvoyer la valeur précédemment écrite par la commande <code>store(X)</code> .  La première étape de la reconstruction de la valeur consiste à collecter toutes les informations stockées à l'intérieur du cercle d'accès de 451 bits centré sur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-165"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-59-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-59"> X </script>  .  Depuis <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-167"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-60-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-60"> X </script>  a déjà été enregistré dans tous ces endroits, nous pouvons être sûrs que nous recevrons <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-169"><span class="MJXp-mn" id="MJXp-Span-170"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-61-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-61"> 1000 </script>  ses copies.  Nous nous déplacerons également <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0fe/af7/cee/0feaf7cee3e7aee1b802f352677072c8.svg" alt="10 000 $" data-tex="inline">  des copies d' <em>autres</em> vecteurs stockés dans des endroits où les cercles d'accès se croisent avec des cercles <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-171"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-62-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-62"> X </script>  .  Mais comme les intersections sont petites, chacun de ces vecteurs n'est présent qu'en quelques exemplaires.  Puis généralement chacun d'eux <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-173"><span class="MJXp-mn" id="MJXp-Span-174"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-63-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-63"> 1000 </script>  peu également susceptibles d'être <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-175"><span class="MJXp-mn" id="MJXp-Span-176"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-64-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-64"> 0 </script>  ou <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-177"><span class="MJXp-mn" id="MJXp-Span-178"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-65-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-65"> 1 </script>  .  Si nous appliquons la fonction du principe de la majorité à toutes les données collectées à chaque position de bit, le résultat sera dominé par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-179"><span class="MJXp-mn" id="MJXp-Span-180"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-66-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-66"> 1000 </script>  copies <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-181"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-67-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-67"> X </script>  .  Probabilité de se différencier de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-183"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-184"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-68-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-68"> X </script>  le résultat est approximativement égal <math></math><img src="https://habrastorage.org/getpro/habr/formulas/011/9a7/e47/0119a7e471aa76f734cc4b7e85ecb0d7.svg" alt="10 $ ^ {- 19} $" data-tex="inline">  . <br><br>  La procédure du principe de la majorité est présentée plus en détail ci-dessous sur un petit exemple de cinq vecteurs de données de 20 bits chacun.  La sortie sera un vecteur différent, dont chaque bit reflète la plupart des bits correspondants dans les vecteurs de données.  (Si le nombre de vecteurs de données est pair, les "tirages" sont autorisés par sélection aléatoire <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-185"><span class="MJXp-mn" id="MJXp-Span-186"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-69-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-69"> 0 </script>  ou <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-187"><span class="MJXp-mn" id="MJXp-Span-188"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-70-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-70"> 1 </script>  .) Le schéma alternatif d'écriture et de lecture présenté ci-dessous refuse de stocker tous les motifs individuellement.  Au lieu de cela, il stocke le nombre total de bits. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-189"><span class="MJXp-mn" id="MJXp-Span-190"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-71-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-71"> 0 </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-191"><span class="MJXp-mn" id="MJXp-Span-192"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-72-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-72"> 1 </script>  dans chaque position.  La cellule solide a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-193"><span class="MJXp-mn" id="MJXp-Span-194"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-73-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-73"> 1000 </script>  compteur de bits initialisé par tous les zéros.  Lorsqu'un modèle est écrit en place, chaque compteur de bits est incrémenté pour <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-195"><span class="MJXp-mn" id="MJXp-Span-196"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-74-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-74"> 1 </script>  ou diminue pour <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-197"><span class="MJXp-mn" id="MJXp-Span-198"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-75-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-75"> 0 </script>  .  L'algorithme de lecture regarde simplement le signe de chaque compteur de bits, retournant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-199"><span class="MJXp-mn" id="MJXp-Span-200"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-76-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-76"> 1 </script>  pour une valeur positive, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-201"><span class="MJXp-mn" id="MJXp-Span-202"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-77-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-77"> 0 </script>  pour une valeur négative et aléatoire lorsque le bit de compteur est égal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-203"><span class="MJXp-mn" id="MJXp-Span-204"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-78-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-78"> 0 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f91/b82/967/f91b82967ddba26afa8e57373cc6091c.png"></div><br>  Ces deux schémas de stockage donnent des résultats identiques. <br><br><hr><br>  En termes d'informatique, cette version de la mémoire distribuée clairsemée ressemble à une blague mûrement réfléchie.  Se souvenir <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0fe/af7/cee/0feaf7cee3e7aee1b802f352677072c8.svg" alt="10 000 $" data-tex="inline">  éléments dont nous avons besoin d'un million de cellules solides, dans lesquelles nous allons stocker un millier de copies redondantes de chaque motif.  Pour récupérer un seul élément de la mémoire, nous collectons des données par <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0f8/2c3/0d0/0f82c30d08d42bf3fe9eb5fee5acf873.svg" alt="11 000 $" data-tex="inline">  modèles enregistrés et appliquer le mécanisme du principe de la majorité pour les démêler.  Et tout cela se fait à l'aide d'un tas de manœuvres acrobatiques uniquement pour obtenir le vecteur que nous avons déjà.  La mémoire traditionnelle fonctionne beaucoup moins au hasard: les accès en écriture et en lecture au même endroit. <br><br>  Mais SDM peut faire ce dont la mémoire traditionnelle est incapable.  En particulier, il peut extraire des informations sur la base de données partielles ou approximatives.  Disons un vecteur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-205"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-79-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-79"> Z </script>  est une version endommagée <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-207"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-80-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-80"> X </script>  dans lequel ont changé <math></math><img src="https://habrastorage.org/getpro/habr/formulas/b67/0e0/9b1/b670e09b14c5fe8c1245bb07d9ac2e1a.svg" alt="100 $" data-tex="inline">  de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-209"><span class="MJXp-mn" id="MJXp-Span-210"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-81-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-81"> 1000 </script>  vecteurs.  Comme les deux vecteurs sont similaires, la commande <code>fetch(Z)</code> visitera plusieurs des mêmes endroits où elle est stockée <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-211"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-82-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-82"> X </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avec une distance de Hamming de 100, on peut s'attendre à ce que </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-213"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-83-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-83"> X </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-215"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-216"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera partagé par environ 300 cellules solides. </font><font style="vertical-align: inherit;">Grâce à cette grande intersection, le vecteur est revenu</font><font style="vertical-align: inherit;">(appelons-le</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-84-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-84">Z</script><font style="vertical-align: inherit;"></font><code>fetch(Z)</code><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-217"><span class="MJXp-msubsup" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-220" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-221"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sera plus proche de</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-85-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-85">Z^{\prime}</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-222"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ce qui est</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-86-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-86"> X </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-224"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-225"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-87-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-87">Z</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons répéter ce processus avec une équipe </font></font><code>fetch(Z′)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui retournera le résultat</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-226"><span class="MJXp-msubsup" id="MJXp-Span-227"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-228" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-229" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-230"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-231"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-88-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-88">Z^{\prime\prime}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , encore plus proche de</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-232"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-233"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-89-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-89"> X </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En quelques itérations, la procédure atteindra </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-234"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-235"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-90-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-90"> X </script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanerva a montré qu'une séquence convergente d'opérations de lecture récursive réussirait avec une certitude presque totale si le modèle initial n'était pas trop éloigné de la cible. En d'autres termes, il existe un rayon critique: toute vérification de la mémoire, à partir d'un endroit à l'intérieur du cercle critique, convergera presque exactement vers le centre et le fera assez rapidement. Une tentative de restauration d'un élément stocké en dehors du cercle critique échouera, car le processus de rappel récursif s'éloignera à une distance moyenne. L’analyse de Kanerv montre que pour le SDM canonique, le rayon critique est de 209 bits. En d'autres termes, si nous connaissons environ 80% des bits, nous pouvons recréer le motif entier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'illustration ci-dessous suit l'évolution des séquences de mémoires récursives avec des signaux sources autres que la cible. </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-236"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-237"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-91-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-91"> X </script>  sur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-238"><span class="MJXp-mn" id="MJXp-Span-239"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-240" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-241"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><span class="MJXp-mo" id="MJXp-Span-242" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-243"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-244" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-245"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15 </font></font></span><span class="MJXp-mo" id="MJXp-Span-246" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font></span><span class="MJXp-mn" id="MJXp-Span-247"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-92-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-92">0, 5, 10, 15 \dots 1000</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans cette expérience, toutes les séquences commençant par la distance </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-248"><span class="MJXp-mn" id="MJXp-Span-249"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">205</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou moins convergent vers</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-93-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-93">205</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-250"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-251"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-94-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-94"> X </script><font style="vertical-align: inherit;"></font><math></math><img src="https://habrastorage.org/getpro/habr/formulas/90c/2a2/ef3/90c2a2ef3f252b20073a97d9f796ad28.svg" alt="10 $" data-tex="inline"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou moins d'itérations </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(traces bleues)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Toutes les séquences commençant à une distance initiale plus grande errent sans but à travers de vastes espaces vides</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-252"><span class="MJXp-mn" id="MJXp-Span-253"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cube de 1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dimensions, restant environ 500 bits de n'importe où.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-95-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-95">1000</script><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/ox/sa/ksoxsaesutehnsikhkl5ofspzze.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transition des chemins convergents aux chemins divergents n'est pas parfaitement claire, et cela est visible dans le graphique en lambeaux présenté ci-dessous. </font><font style="vertical-align: inherit;">Ici, nous avons zoomé pour regarder le sort des trajectoires en commençant par les décalages</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-254"><span class="MJXp-mn" id="MJXp-Span-255"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">175 </font></font></span><span class="MJXp-mo" id="MJXp-Span-256" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-257"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">176 </font></font></span><span class="MJXp-mo" id="MJXp-Span-258" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-259"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">177 </font></font></span><span class="MJXp-mo" id="MJXp-Span-260" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mo" id="MJXp-Span-261" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font></span><span class="MJXp-mn" id="MJXp-Span-262"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">225</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits. </font><font style="vertical-align: inherit;">Tous les points de départ à moins de 209 bits de la cible sont indiqués en bleu; </font><font style="vertical-align: inherit;">commençant à une distance plus longue sont orange. </font><font style="vertical-align: inherit;">La plupart des chemins bleus convergent, se déplaçant rapidement vers une distance nulle, contrairement à la plupart des chemins orange. </font><font style="vertical-align: inherit;">Cependant, à proximité de la distance critique, il existe de nombreuses exceptions.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-96-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-96">175, 176, 177, \dots 225</script><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lm/aj/rs/lmajrsq2z4z_tlzg5igefbjhwbu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le graphique ci-dessous montre un autre regard sur la façon dont la distance initiale de la cible affecte la probabilité de convergence vers la bonne adresse mémoire. </font><font style="vertical-align: inherit;">À une distance de</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-263"><span class="MJXp-mn" id="MJXp-Span-264"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">170</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits réussissent dans presque toutes les tentatives; </font><font style="vertical-align: inherit;">à</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-97-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-97">170</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-265"><span class="MJXp-mn" id="MJXp-Span-266"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">240</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> presque tous ont échoué. </font><font style="vertical-align: inherit;">Il semble que le point d'intersection (où le succès et l'échec sont également probables) se situe à peu près</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-98-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-98">240</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-267"><span class="MJXp-mn" id="MJXp-Span-268"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">203</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits, légèrement en dessous du résultat de Kanerva, égal à</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-99-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-99">203</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-269"><span class="MJXp-mn" id="MJXp-Span-270"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">209</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-100-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-100">209</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Il n'y a rien de mystérieux dans cet écart. Dans les calculs de Kanerv, le cercle d'accès est censé limiter exactement </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-271"><span class="MJXp-mn" id="MJXp-Span-272"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cellules solides. </font><font style="vertical-align: inherit;">Toutes les cellules solides à distance sont incluses dans mes expériences.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-101-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-101">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-273"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-274"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mo" id="MJXp-Span-275" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">≤ </font></font></span><span class="MJXp-mn" id="MJXp-Span-276"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">451</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">il y a en moyenne</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-102-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-102">r \le 451</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-277"><span class="MJXp-mn" id="MJXp-Span-278"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1070 de</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ces endroits.)</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-103-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-103">1070</script><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/74/gc/ei74gcngwrfwrae1iwfle95ybg4.png"></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La capacité de recréer des souvenirs à partir d'informations partielles est un élément familier de la vie humaine. Vous remarquez un acteur dans une émission de télévision, et vous comprenez que vous l'avez déjà vu, mais vous ne vous souvenez pas où. Quelques minutes plus tard, il vous apparaît: voici M. Bates de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Downton Abbey</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais sans costume de majordome. Réunion des diplômés du secondaire: en regardant un monsieur chauve serré de l'autre côté de la pièce, pouvez-vous le reconnaître comme un ami que vous ne connaissiez que quand vous étiez adolescent en short de sport? Parfois, il faut beaucoup d'efforts pour combler les lacunes. J'ai déjà </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">écrit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur ma propre «tache aveugle» inexplicable en mémoire de la croissance des glycines, que je n'ai pu nommer qu'après avoir patiemment feuilleté un catalogue de fausses odeurs: hortensia, verveine et forsythie.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre capacité à récupérer des souvenirs d'une entrée incomplète ou bruyante peut-elle fonctionner comme un processus récursif de mémorisation de vecteurs de grande dimension? Ce serait une hypothèse intéressante, mais il y a des raisons de s'en méfier. Par exemple, le cerveau semble être capable d'extraire du sens de signaux beaucoup plus maigres. Je n'ai pas besoin d'écouter les quatre cinquièmes de la "Cinquième Symphonie" pour l'identifier, les quatre premières notes suffisent. La couleur qui scintille dans les arbres vous rappelle instantanément les espèces d'oiseaux correspondantes - cardinal, geai bleu, carduelis. Le moindre souffle avec l'odeur de la poussière de craie me ramène dans une salle de classe étouffante et endormie, dans laquelle j'ai peint pendant une demi-journée à mon bureau. De tels souvenirs sont déclenchés par de minuscules fractions des informations qui les représentent, bien moins de 80%.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanerva mentionne encore une autre caractéristique de la mémoire humaine qui peut être modélisée à l'aide de SDM: le phénomène de «rotation sur le bout de la langue», dont l'essence est que vous savez que vous savez quelque chose, bien que vous ne puissiez pas l'appeler immédiatement. Ce sentiment est plutôt mystérieux: si vous ne trouvez pas ce que vous cherchiez, comment savoir que tout est stocké dans le cerveau? Le processus de rappel récursif de SDM nous offre une réponse possible. Lorsque des motifs consécutifs récupérés dans la mémoire se rapprochent constamment les uns des autres, nous pouvons raisonnablement être sûrs qu'ils convergeront vers l'objectif avant même qu'ils ne l'atteignent.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans leurs tentatives d'extraire un fait obstiné de la mémoire, beaucoup de gens trouvent que frapper constamment à la même porte n'est pas une stratégie judicieuse. Au lieu d'exiger des réponses immédiates - pour commander votre cerveau - il vaut souvent mieux mettre la tâche de côté, faire une promenade, peut-être faire une sieste; la réponse peut venir comme si elle n'était pas invitée. Cette observation peut-elle être expliquée par le modèle SDM? Peut-être au moins partiellement. Si la séquence des motifs rappelés ne converge pas, son étude ultérieure peut s'avérer infructueuse. Si vous recommencez à partir d'un point voisin de l'espace mémoire, vous pouvez arriver à un meilleur résultat. Mais il y a un mystère ici: comment trouver un nouveau point de départ avec de meilleures perspectives? Vous pourriez penser qu'il est assez simple de remplacer au hasard quelques bits dans le modèle d'entrée et espéronsqu'en conséquence, il sera plus proche de l'objectif, mais la probabilité que cela soit faible. Si le vecteur est en</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-279"><span class="MJXp-mn" id="MJXp-Span-280"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">250</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits de la cible puis</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-104-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-104">250</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-281"><span class="MJXp-mn" id="MJXp-Span-282"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">750</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits est déjà vrai (mais nous ne savons pas</font><em><font style="vertical-align: inherit;">tout</font></em><font style="vertical-align: inherit;">de</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-105-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-105">750</script><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-283"><span class="MJXp-mn" id="MJXp-Span-284"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">750</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits); </font><font style="vertical-align: inherit;">avec tout changement aléatoire, nous avons une probabilité de</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-106-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-106">750</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-285"><span class="MJXp-mn" id="MJXp-Span-286"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-287"><span class="MJXp-mo" id="MJXp-Span-288" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-289"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se rapprochent et disparaissent encore plus loin. </font><font style="vertical-align: inherit;">Pour progresser, vous devez savoir dans quelle direction aller et</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-107-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-107">3/4</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-290"><span class="MJXp-mn" id="MJXp-Span-291"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> espace à</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-290"><span class="MJXp-mn" id="MJXp-Span-291"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> dimensions est une question difficile.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-108-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-108">1000</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un aspect de l'architecture SDM est qu'elle semble correspondre à l'effet de la répétition ou de l'écoute de la mémoire. Si vous répétez le poème plusieurs fois ou si vous vous entraînez à jouer un morceau de musique, vous pouvez vous attendre à ce que vous vous en souveniez plus facilement à l'avenir. Le modèle informatique devrait présenter un effet d'entraînement similaire. Mais cela n'est pas possible dans la mémoire informatique traditionnelle: il n'y a aucun avantage à réécrire plusieurs fois la même valeur à la même adresse. Dans SDM, en revanche, chaque répétition d'un motif ajoute une autre copie à toutes les cellules solides dans le cercle d'accès du motif. Par conséquent, il y a moins d'influence des motifs qui se croisent et le rayon de rappel critique augmente. L'effet a un effet significatif:lors de l'écriture dans la mémoire d'une seule copie du motif, le rayon critique augmente d'environ</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-292"><span class="MJXp-mn" id="MJXp-Span-293"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits à plus de</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-109-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-109">200</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-294"><span class="MJXp-mn" id="MJXp-Span-295"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">300</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-110-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-110">300</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De même, jouer un motif peut rendre difficile la restauration du reste. </font><font style="vertical-align: inherit;">Cela rappelle d'oublier lorsqu'un motif activement imprimé remplit ses voisins et capture une partie de leur territoire. </font><font style="vertical-align: inherit;">Cet effet affecte également de manière significative SDM, à tel point qu'il semble même irréaliste. </font><font style="vertical-align: inherit;">Il semble qu'un vecteur stocké huit ou dix fois monopolise la majeure partie de la mémoire; </font><font style="vertical-align: inherit;">il devient une obsession, la réponse à toutes les questions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un avantage important de la mémoire distribuée clairsemée est sa résistance aux pannes ou erreurs matérielles. </font><font style="vertical-align: inherit;">Je serais contrarié si la perte d'un seul neurone dans mon cerveau laissait un trou dans ma mémoire et je ne pouvais pas reconnaître la lettre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou rappelez-vous comment attacher des lacets. </font><font style="vertical-align: inherit;">SDM ne souffre pas de cette fragilité. </font><font style="vertical-align: inherit;">Lorsque chaque motif stocké contient mille copies, aucun endroit n'est important. </font><font style="vertical-align: inherit;">Et en fait, vous pouvez effacer toutes les informations stockées dans 60% des cellules solides, et avoir toujours le rappel parfait</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-296"><span class="MJXp-mn" id="MJXp-Span-297"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , si nous supposons que nous transmettons une adresse absolument précise en tant que signal. </font><font style="vertical-align: inherit;">Avec des signaux partiels, le rayon critique diminue à mesure que les taches perdues augmentent. </font><font style="vertical-align: inherit;">Après avoir détruit 60% des sites, le rayon critique est compressé avec</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-111-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-111">10000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-298"><span class="MJXp-mn" id="MJXp-Span-299"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200 </font></font></span><span class="MJXp-mo" id="MJXp-Span-300" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits à environ</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-112-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-112">200+</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-301"><span class="MJXp-mn" id="MJXp-Span-302"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">150</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bits. Après la destruction de 80% des lieux, la mémoire est gravement endommagée, mais pas détruite.</font><font style="vertical-align: inherit;">Qu'en est-il de flotter dans les nuages? Pouvons-nous errer paresseusement à travers les prairies d'une mémoire clairsemée, sautant par chance d'un modèle stocké à un autre? Je reviendrai sur cette question.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-113-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-113">150</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart de ce qui précède est écrit il y a quelques semaines. À cette époque, j'ai lu sur diverses théories concurrentes de la mémoire et discuté de leurs mérites avec des collègues de l'Institut Simons. J'ai écrit mes réflexions sur ce sujet, mais j'ai reporté leur publication en raison de doutes persistants: ai-je bien compris les mathématiques de la mémoire distribuée clairsemée? Maintenant, je suis content de ne pas être pressé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le programme Brain and Computing s'est terminé en mai. Ses participants sont partis: je suis retourné en Nouvelle-Angleterre, où la sauge et le romarin sont de petites plantes en pot et non des buissons luxuriants suspendus au-dessus des sentiers. Mes promenades matinales vers le campus de Berkeley, les occasions quotidiennes de réfléchir sur la nature de la mémoire et de l'apprentissage, sont devenues des «engrammes» stockés quelque part dans ma tête (cependant, je ne sais toujours pas où les chercher).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, je n'ai pas abandonné ma recherche. </font><font style="vertical-align: inherit;">Après avoir quitté Berkeley, j'ai continué à lire sur les théories de la mémoire. </font><font style="vertical-align: inherit;">J'ai également écrit des programmes pour étudier la mémoire distribuée clairsemée de Pentti Canerva et ses idées plus approfondies de «calcul hyperespace». </font><font style="vertical-align: inherit;">Même si ce projet ne me révèle pas les secrets de la mémoire humaine, il m'apprendra certainement quelque chose sur l'art mathématique et informatique de la navigation dans les espaces de grande dimension. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le schéma ci-dessous montre la manière «correcte» d'implémenter SDM, si je comprends bien. </font><font style="vertical-align: inherit;">L'élément principal est une matrice croisée, dans laquelle les lignes correspondent à des cellules de mémoire solide, et les colonnes transportent des signaux qui simulent des bits individuels du vecteur d'entrée. </font><font style="vertical-align: inherit;">Il y a un million de lignes dans la mémoire canonique, chacune étant assignée au hasard</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-303"><span class="MJXp-mn" id="MJXp-Span-304"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adresse</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-303"><span class="MJXp-mn" id="MJXp-Span-304"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> bits, et</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-114-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-114">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-305"><span class="MJXp-mn" id="MJXp-Span-306"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> colonnes </font><font style="vertical-align: inherit;">Cette version de démonstration comprend 20 lignes et 8 colonnes.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-115-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-115">1000</script><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hm/bf/hq/hmbfhq9wergzhrrb1fskxsurpsk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus illustré dans le diagramme consiste à stocker un vecteur d'entrée dans une mémoire vide. </font><font style="vertical-align: inherit;">Huit bits d'entrée sont comparés simultanément aux 20 adresses des cellules solides. </font><font style="vertical-align: inherit;">Lorsque le bit d'entrée et le bit d'adresse coïncident - zéro avec zéro ou un avec un - nous mettons un point à l'intersection de la colonne et de la ligne. </font><font style="vertical-align: inherit;">Ensuite, nous comptons le nombre de points dans chaque ligne, et si le nombre est égal ou supérieur à la valeur de seuil, alors nous écrivons le vecteur d'entrée dans le registre associé à cette ligne </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(champs bleus)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans notre exemple, la valeur seuil est 5 et dans 8 adresses sur 20, il y a au moins 5 correspondances. </font><font style="vertical-align: inherit;">Dans</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-307"><span class="MJXp-mn" id="MJXp-Span-308"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valeur du seuil de mémoire de</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-307"><span class="MJXp-mn" id="MJXp-Span-308"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> bits sera égale</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-116-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-116">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-309"><span class="MJXp-mn" id="MJXp-Span-310"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">451</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-117-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-117">451</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et seulement environ un millième de tous les registres seront sélectionnés.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La magie de cette architecture est que toutes les comparaisons de bits - et il y en a un milliard dans le modèle canonique - se produisent simultanément. Par conséquent, le temps d'accès pour la lecture et l'écriture ne dépend pas du nombre de cellules solides et peut être très petit. Une telle disposition générale, connue sous le nom de mémoire associative ou d'adressage de contenu, est utilisée dans certains domaines informatiques, comme l'activation de détecteurs de particules dans le grand collisionneur de hadrons et la transmission de paquets via des routeurs sur Internet. Et le schéma de circuit peut être associé à certaines structures cérébrales. Kanerva indique que le cervelet est très similaire à une telle matrice. Les lignes sont des cellules de Purkinje plates en forme d'éventail, rassemblées comme les pages d'un livre; les colonnes sont des fibres parallèles qui s'étendent à travers toutes les cellules de Purkinje. (Cependant, le cervelet n'est pas une région du cerveau des mammifères,où l'on pense que la mémoire cognitive est située.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce serait formidable de construire une simulation SDM basée sur cette architecture croisée; </font><font style="vertical-align: inherit;">Malheureusement, je ne sais pas comment l'implémenter sur le matériel informatique à ma disposition. </font><font style="vertical-align: inherit;">Dans un processeur traditionnel, il n'existe aucun moyen de comparer simultanément tous les bits d'entrée avec des bits de cellule dure. </font><font style="vertical-align: inherit;">Au lieu de cela, je dois parcourir un million de cellules solides en séquence et comparer des milliers de bits à chaque endroit. </font><font style="vertical-align: inherit;">Cela équivaut à un million de comparaisons de bits pour chaque élément qui est stocké ou récupéré de la mémoire. </font><font style="vertical-align: inherit;">Ajoutez à cela le temps d'écrire ou de lire un million de bits (milliers d'exemplaires</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-311"><span class="MJXp-mn" id="MJXp-Span-312"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vecteur</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-311"><span class="MJXp-mn" id="MJXp-Span-312"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> bits), et vous obtenez un processus assez lent. </font><font style="vertical-align: inherit;">Voici le code pour enregistrer le vecteur:</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-118-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-118">1000</script><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">store</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v::BitVector)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDM</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hamming_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, loc.address)</span></span></span><span class="hljs-function"> &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_to_register</span></span></span><span class="hljs-function">!</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loc.register, v)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette implémentation prend environ une heure pour inventorier la mémoire avec </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-313"><span class="MJXp-mn" id="MJXp-Span-314"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> motifs mémorisés. </font><font style="vertical-align: inherit;">(Le programme complet sous la forme d'un bloc-notes Jupyter est disponible</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">sur GitHub</font></a><font style="vertical-align: inherit;">.)</font><font style="vertical-align: inherit;">Existe-t-il un meilleur algorithme pour simuler SDM sur un matériel ordinaire? </font><font style="vertical-align: inherit;">Une des stratégies possibles permet d'éviter la recherche répétée d'un ensemble de cellules solides dans le cercle d'accès d'un vecteur donné; </font><font style="vertical-align: inherit;">au lieu de cela, lorsqu'un vecteur est écrit pour la première fois dans la mémoire, le programme stocke un pointeur sur chacun des milliers d'endroits où il est stocké. </font><font style="vertical-align: inherit;">À l'avenir, avec toute référence au même vecteur, le programme pourra suivre</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-119-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-119">10000</script><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-315"><span class="MJXp-mn" id="MJXp-Span-316"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointeurs enregistrés, et ne pas scanner l'intégralité du tableau d'un million de cellules solides. </font><font style="vertical-align: inherit;">Le prix de ce schéma de mise en cache est la nécessité de stocker tous ces pointeurs - dans leur SDM canonique</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-120-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-120">1000</script><font style="vertical-align: inherit;"></font><math></math><img src="https://habrastorage.org/getpro/habr/formulas/90c/2a2/ef3/90c2a2ef3f252b20073a97d9f796ad28.svg" alt="10 $" data-tex="inline"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des millions. </font><font style="vertical-align: inherit;">Ceci est tout à fait réel et peut valoir la peine si vous souhaitez stocker et récupérer uniquement les valeurs exactes et connues. </font><font style="vertical-align: inherit;">Mais pensez à ce qui se passe en réponse à une demande de mémoire approximative avec rappel récursif</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-317"><span class="MJXp-msubsup" id="MJXp-Span-318"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-319" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-320" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-321"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-121-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-121">Z^{\prime}</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-322"><span class="MJXp-msubsup" id="MJXp-Span-323"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-324" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-325" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-326"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-327"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-122-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-122">Z^{\prime\prime}</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-328"><span class="MJXp-msubsup" id="MJXp-Span-329"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-330" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-331" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-332"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-333"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-334"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-123-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-123">Z^{\prime\prime\prime}</script>  , et ainsi de suite.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aucune de ces valeurs intermédiaires ne sera trouvée dans le cache, donc une analyse complète de toutes les cellules solides sera toujours requise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe peut-être un moyen plus délicat de tracer le chemin. Dans un récent article de revue, " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approximate Nearest Neighbour Search in High Dimensions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " par Alexander Andoni, Peter Indyk et Ilya Razenstein, une technique intrigante est mentionnée appelée hachage sensible à la localité (hachage basé sur la localité), mais jusqu'à présent, je ne comprends pas très bien comment l'adapter à la tâche SDM.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La capacité de récupérer des souvenirs à partir de signaux partiels est douloureusement une caractéristique humaine du modèle de calcul. </font><font style="vertical-align: inherit;">Peut-être qu'il peut être élargi pour fournir un mécanisme plausible d'errance oisive dans les couloirs de l'esprit, dans lequel une pensée mène à la suivante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au début, je pensais savoir comment cela pouvait fonctionner. </font><font style="vertical-align: inherit;">Modèle stocké SDM</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-335"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-336"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crée une zone d'attraction autour d'elle dans laquelle converge toute étude récursive de la mémoire à partir d'un rayon critique vers</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-124-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-124"> X </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-337"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-338"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-125-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-125"> X </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> À </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-339"><span class="MJXp-mn" id="MJXp-Span-340"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10000 de</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ces attracteurs, je peux imaginer comment ils divisent l'espace mémoire en une matrice de modules individuels comme une mousse à bulles de savon de grande taille. La zone de chaque élément stocké occupe un volume séparé, entourée de tous les côtés par d'autres zones et en butée contre elles, avec des limites claires entre les domaines adjacents. À l'appui de cette proposition, je peux voir que le rayon moyen de la région d'attraction, lorsque de nouveaux contenus sont ajoutés à la mémoire, est compressé, comme si les bulles étaient compressées en raison de l'encombrement.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-126-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-126">10000</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une telle vision des processus à l'intérieur du SDM suggère un moyen simple de passer d'un domaine à un autre: vous devez basculer au hasard un nombre suffisant de bits du vecteur pour le déplacer de l'attraction actuelle vers l'attraction voisine, puis appliquer l'algorithme de rappel récursif. La répétition de cette procédure générera une traversée aléatoire de nombreux sujets stockés en mémoire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le seul problème est que cette approche ne fonctionne pas. Si vous le vérifiez, alors il errera sans but</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-341"><span class="MJXp-mn" id="MJXp-Span-342"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grille</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-341"><span class="MJXp-mn" id="MJXp-Span-342"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> dimensions, mais nous n'y trouverons jamais rien. </font><font style="vertical-align: inherit;">L'ensemble du plan est basé sur une compréhension intuitive erronée de la géométrie SDM. </font><font style="vertical-align: inherit;">Les vecteurs stockés avec leurs régions d'attraction</font><em><font style="vertical-align: inherit;">ne</font></em><font style="vertical-align: inherit;">sont</font><em><font style="vertical-align: inherit;">pas</font></em><font style="vertical-align: inherit;">serrés comme des bulles de savon; </font><font style="vertical-align: inherit;">au contraire, ce sont des galaxies isolées suspendues dans un univers vaste et libre, séparées par d'immenses étendues d'espace vide entre elles. </font><font style="vertical-align: inherit;">De brefs calculs nous montrent la vraie nature de la situation. </font><font style="vertical-align: inherit;">Dans le modèle canonique, le rayon critique déterminant la région d'attraction est approximativement égal à</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-127-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-127">1000</script><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-343"><span class="MJXp-mn" id="MJXp-Span-344"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-128-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-128">200</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le volume d'une seule région, mesuré par le nombre de vecteurs à l'intérieur, est </font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-345"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-346">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-347">u</span><span class="MJXp-msubsup" id="MJXp-Span-348"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-349" style="margin-right: 0.05em;">m</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mrow" id="MJXp-Span-354"><span class="MJXp-mn" id="MJXp-Span-355">200</span></span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mrow" id="MJXp-Span-350"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-351">k</span><span class="MJXp-mo" id="MJXp-Span-352">=</span><span class="MJXp-mn" id="MJXp-Span-353">1</span></span></span></span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-356"><span class="MJXp-TeXmathchoice" id="MJXp-Span-357"><span class="MJXp-mrow" id="MJXp-Span-358"><span class="MJXp-mo" id="MJXp-Span-359" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.319em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.274em; margin-left: -0.09em;">(</span></span></span></span><span class="MJXp-mfrac" id="MJXp-Span-360"><span class="MJXp-box"><span class="MJXp-mn" id="MJXp-Span-361">1000</span></span><span class="MJXp-box" style="margin-top: -0.7em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-362">k</span></span></span></span></span></span><span class="MJXp-TeXmathchoice" id="MJXp-Span-363"><span class="MJXp-mrow" id="MJXp-Span-364"><span class="MJXp-mo" id="MJXp-Span-365" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.319em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.274em; margin-left: -0.09em;">)</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-129-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-129">sum_{k = 1}^{200} \binom{1000}{k}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui est à peu près égal </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-366"><span class="MJXp-msubsup" id="MJXp-Span-367"><span class="MJXp-mn" id="MJXp-Span-368" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-369" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-370">216</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-130-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-130">10^{216}</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par conséquent, tous </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-371"><span class="MJXp-mn" id="MJXp-Span-372">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-131-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-131">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> les zones occupent le volume </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-373"><span class="MJXp-msubsup" id="MJXp-Span-374"><span class="MJXp-mn" id="MJXp-Span-375" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-376" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-377">220</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-132-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-132">10^{220}</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est un grand nombre, mais c'est encore une toute petite fraction </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-378"><span class="MJXp-mn" id="MJXp-Span-379">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-133-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-133">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Cube dimensionnel. </font><font style="vertical-align: inherit;">Parmi tous les sommets du cube, seulement</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-380"><span class="MJXp-mn" id="MJXp-Span-381">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-134-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-134"> 1 </script>  de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-382"><span class="MJXp-msubsup" id="MJXp-Span-383"><span class="MJXp-mn" id="MJXp-Span-384" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-385" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-386">80</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-135-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-135">10^{80}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se trouve à moins de 200 bits du modèle enregistré. Vous pouvez vous promener pour toujours sans tomber sur aucun de ces domaines. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Pour toujours? Oh, oui, oui, cela peut ne pas être éternel. Puisqu'un hypercube est une structure finie, tout chemin à travers elle doit tôt ou tard devenir périodique, ou tomber dans un point fixe d'où il ne part jamais, ou se perdre dans un cycle répétitif Les vecteurs stockés sont des points fixes, en plus, il y a beaucoup d'autres points fixes qui ne correspondent à aucun schéma significatif. Quoi qu'il en soit, dans toutes mes expériences avec les programmes SDM, je n'ai jamais réussi à "accidentellement" entrer dans une pat enregistrée tourner.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En essayant de sauver cette mauvaise idée, j'ai mené plusieurs autres expériences. </font><font style="vertical-align: inherit;">Dans un cas, j'ai sauvegardé arbitrairement plusieurs concepts liés à des adresses voisines («voisin», c'est-à- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dire à 200 ou 300 bits). </font><font style="vertical-align: inherit;">Peut-être que dans ce cluster, je peux sauter d'un point à un autre en toute sécurité. </font><font style="vertical-align: inherit;">Mais en fait, l'ensemble de la grappe est condensé en une grande région d'attraction pour le motif central, qui devient un trou noir qui aspire tous ses compagnons. </font><font style="vertical-align: inherit;">J'ai aussi essayé de jouer avec la valeur</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-387"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-388">r</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-136-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-136">r</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(rayon du cercle d'accès pour toutes les opérations de lecture et d'écriture). </font><font style="vertical-align: inherit;">Dans le modèle canonique</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-389"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-390">r</span><span class="MJXp-mo" id="MJXp-Span-391" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-392">451</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-137-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-137">r = 451</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pensais qu'écrire dans un cercle légèrement plus petit ou lire dans un cercle légèrement plus grand laisserait suffisamment de place au hasard dans les résultats, mais cet espoir ne s'est pas non plus matérialisé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes ces tentatives étaient basées sur une mauvaise compréhension des espaces vectoriels de grande dimension. Une tentative pour trouver des grappes de valeurs voisines dans un hypercube est sans espoir; les motifs stockés sont trop espacés en volume. La création arbitraire de grappes denses est également inutile, car elle détruit la propriété même qui rend le système intéressant - la capacité de converger vers un élément stocké de n'importe où dans la zone d'attraction environnante. Si nous voulons créer un algorithme d'errance dans le cloud pour SDM, nous devons trouver une autre manière.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À la recherche d'un mécanisme alternatif du flux de conscience, vous pouvez essayer d'ajouter une petite théorie des graphes au monde de la mémoire répartie clairsemée. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons prendre du recul, revenir à l'idée originale de l'errance mentale sous la forme d'une marche aléatoire autour d'un graphique ou d'un réseau. </font><font style="vertical-align: inherit;">L'élément clé pour l'intégration de tels graphiques dans SDM s'avère être un outil familier pour nous: un opérateur OU exclusif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme mentionné ci-dessus, la distance de Hamming entre deux vecteurs est calculée en prenant leur XOR au niveau du bit et en comptant les unités résultantes. </font><font style="vertical-align: inherit;">Mais l'opération XOR donne non seulement la distance entre deux vecteurs, mais aussi d'autres informations; </font><font style="vertical-align: inherit;">il détermine également l'orientation ou la direction de la ligne qui les relie. </font><font style="vertical-align: inherit;">En particulier, l'opération</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-396"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-397">u</span><span class="MJXp-mo" id="MJXp-Span-398" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-399">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-138-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-138">u \veebar v</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> donne un vecteur listant les bits qui doivent être modifiés pour convertir </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-400"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-401">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-139-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-139">u</script>  dans <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-402"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-403">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-140-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-140">v</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et vice versa. </font><font style="vertical-align: inherit;">Peut également être perçu</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-404"><span class="MJXp-mn" id="MJXp-Span-405">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-141-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-141"> 1 </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-406"><span class="MJXp-mn" id="MJXp-Span-407">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-142-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-142"> 0 </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le vecteur XOR comme une séquence de directions que vous devez suivre pour suivre le chemin depuis </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-408"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-409">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-143-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-143">u</script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-410"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-411">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-144-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-144">v</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XOR a toujours été mon préféré de toutes les fonctions booléennes. </font><font style="vertical-align: inherit;">C'est un opérateur de différence, mais contrairement à la soustraction, XOR est symétrique:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-412"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-413">u</span><span class="MJXp-mo" id="MJXp-Span-414" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-415">v</span><span class="MJXp-mo" id="MJXp-Span-416" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-417">v</span><span class="MJXp-mo" id="MJXp-Span-418" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-419">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-145-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-145">u \veebar v = v \veebar u</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, XOR est sa propre fonction inverse. </font><font style="vertical-align: inherit;">Ce concept est facile à comprendre avec des fonctions avec un seul argument:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-420"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-421">f</span><span class="MJXp-mo" id="MJXp-Span-422" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-423">x</span><span class="MJXp-mo" id="MJXp-Span-424" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-146-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-146"> f (x) </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est sa propre fonction inverse si </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-425"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-426">f</span><span class="MJXp-mo" id="MJXp-Span-427" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-428">f</span><span class="MJXp-mo" id="MJXp-Span-429" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-430">x</span><span class="MJXp-mo" id="MJXp-Span-431" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-432" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-433" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-434">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-147-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-147">f(f(x)) = x</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est-à-dire qu'après avoir appliqué la fonction deux fois, nous pouvons revenir à notre point de départ. </font><font style="vertical-align: inherit;">Pour une fonction avec deux arguments, comme XOR, la situation est plus compliquée, mais il est toujours vrai que l'exécution de la même action deux fois restaure l'état d'origine. </font><font style="vertical-align: inherit;">En particulier, si</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-435"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-436">u</span><span class="MJXp-mo" id="MJXp-Span-437" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-438">v</span><span class="MJXp-mo" id="MJXp-Span-439" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-440">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-148-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-148">u \veebar v = w</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alors </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-441"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-442">u</span><span class="MJXp-mo" id="MJXp-Span-443" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-444">w</span><span class="MJXp-mo" id="MJXp-Span-445" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-446">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-149-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-149">u \veebar w = v</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-447"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-448">v</span><span class="MJXp-mo" id="MJXp-Span-449" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-450">w</span><span class="MJXp-mo" id="MJXp-Span-451" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-452">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-150-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-150">v \veebar w = u</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trois vecteurs - </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-453"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-454">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-151-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-151">u</script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-455"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-456">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-152-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-152">v</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-457"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-458">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-153-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-153">w</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- créez un petit univers fermé. </font><font style="vertical-align: inherit;">Vous pouvez appliquer l'opérateur XOR à n'importe quelle paire d'entre eux et obtenir le troisième élément de l'ensemble. </font><font style="vertical-align: inherit;">Ce qui suit est une tentative d'illustrer cette idée. </font><font style="vertical-align: inherit;">Chaque carré imite</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-459"><span class="MJXp-mn" id="MJXp-Span-460">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-154-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-154">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vecteur de bits aligné sous forme de tableau 100 x 100 de pixels clairs et sombres. </font><font style="vertical-align: inherit;">Les trois modèles semblent aléatoires et indépendants, mais en fait, chaque panneau est XOR des deux autres. </font><font style="vertical-align: inherit;">Par exemple, dans le carré le plus à gauche, chaque pixel rouge correspond au vert ou au bleu, mais jamais aux deux.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/xt/rc/wdxtrcs6sx8i6us8r7c7mwf9bn8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propriété d'auto-invertibilité nous indique une nouvelle façon d'organiser les informations dans SDM. Supposons que le mot </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et son homologue français </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soient stockés dans des vecteurs arbitraires et aléatoires. Ils ne seront pas proches les uns des autres; la distance entre eux est susceptible d'être d'environ 500 bits. Maintenant, nous calculons le XOR de ces vecteurs </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-461"><span class="MJXp-mo" id="MJXp-Span-462" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-155-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-155">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; le résultat est un autre vecteur qui peut également être enregistré dans SDM. Ce nouveau vecteur code une connexion </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anglais-français</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nous avons maintenant un outil de traduction. Ayant un vecteur pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous effectuons un XOR pour celui-ci avec le vecteur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anglais-français</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et obtenons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La même astuce fonctionne dans la direction opposée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette paire de mots et la connexion entre eux forment le cœur du réseau sémantique. Augmentons-le un peu. Nous pouvons enregistrer le mot </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans une adresse arbitraire </font><font style="vertical-align: inherit;">, puis calculer le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-463"><span class="MJXp-mo" id="MJXp-Span-464" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-156-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-156">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et appeler cette nouvelle relation </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adulte-jeune</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Comment s'appelle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en français </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">La chenille en français est </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous ajoutons ce fait au réseau en stockant la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-465"><span class="MJXp-mo" id="MJXp-Span-466" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-157-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-157">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anglais-français</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il est maintenant temps pour la magie: si nous prenons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-467"><span class="MJXp-mo" id="MJXp-Span-468" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-158-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-158">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous apprenons que ces mots sont liés par une relation </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adulte-jeune</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , même s'ils ne l'indiquent pas explicitement. </font><font style="vertical-align: inherit;">Cette limitation est imposée par la géométrie de la structure elle-même.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/dx/-p/ecdx-przlx4rgh7wlp1z63ito-y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le graphique peut être développé davantage en ajoutant plus de mots apparentés anglais-français ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chien-chien, cheval-cheval</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ou plus de couples adultes-jeunes: ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chien-chiot,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jeune </font><em><font style="vertical-align: inherit;">arbre</font></em><font style="vertical-align: inherit;"> ). Vous pouvez également explorer de nombreuses autres relations: synonymes, antonymes, frères et sœurs, cause-effet, prédateur-proie, etc. Il existe également un excellent moyen de joindre plusieurs événements dans une séquence chronologique en exécutant simplement XOR sur les adresses du prédécesseur et du successeur du nœud.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La façon dont XOR connecte les concepts est un hybride de géométrie et de théorie des graphes. </font><font style="vertical-align: inherit;">Dans la théorie mathématique des graphes ordinaires, les distances et les directions ne sont pas significatives; </font><font style="vertical-align: inherit;">la seule chose qui compte est la présence ou l'absence de bords de connexion entre les nœuds. </font><font style="vertical-align: inherit;">En SDM, en revanche, une arête représentant une connexion entre des nœuds est un vecteur de longueur finie et de directivité dans</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-469"><span class="MJXp-mn" id="MJXp-Span-470">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-159-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-159">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-espace dimensionnel. </font><font style="vertical-align: inherit;">Pour un nœud et un lien donnés, l'opération XOR «lie» ce nœud à une position spécifique ailleurs dans l'hypercube. </font><font style="vertical-align: inherit;">La structure résultante est absolument rigide - nous ne pouvons pas déplacer le nœud sans changer toutes les connexions auxquelles il participe. </font><font style="vertical-align: inherit;">Dans le cas des papillons et des chenilles, une configuration de quatre nœuds se révèle inévitablement être un parallélogramme, où les paires de côtés opposés ont la même longueur et la même direction.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre caractéristique unique d'un graphe associé à une opération XOR est que les nœuds et les arêtes ont exactement la même représentation. Dans la plupart des implémentations informatiques d'idées issues de la théorie des graphes, les deux entités sont très différentes; un nœud peut être une liste d'attributs, et un bord peut être une paire de pointeurs vers les nœuds connectés par lui. Dans SDM, les nœuds et les bords sont simplement des vecteurs de grande dimension qui peuvent être stockés dans le même format.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'elle est utilisée comme modèle de mémoire humaine, la liaison XOR nous donne la possibilité de connecter deux concepts via n'importe quelle connexion à laquelle nous pouvons penser. De nombreuses connexions dans le monde réel sont asymétriques; ils n'ont pas la propriété d'auto-invertibilité de XOR. Le vecteur XOR peut déclarer qu'Edward et Victoria sont le parent et l'enfant, mais ne dit pas qui est qui. Pire encore, le vecteur XOR relie exactement deux nœuds et plus jamais, donc le parent de plusieurs enfants nous met dans une position désagréable. Une autre difficulté est de maintenir l'intégrité de toutes les branches d'un grand graphique entre elles. Nous ne pouvons pas simplement ajouter arbitrairement des nœuds et des arêtes; ils doivent être attachés au graphique dans le bon ordre. L'insertion d'un stade nymphal entre un papillon et une chenille nécessitera la réécriture de la plupart des motifs;vous devrez déplacer plusieurs nœuds vers de nouveaux endroits à l'intérieur de l'hypercube et recalculer les vecteurs de connexion les reliant, tout en vous assurant que chaque changement du côté de la langue anglaise se reflète correctement sur le français.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains de ces problèmes sont résolus dans une autre technique basée sur XOR que Kanerva appelle le regroupement. L'idée est de créer une sorte de base de données pour stocker les paires attribut-valeur. Une entrée de livre peut avoir des attributs tels que l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auteur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">titre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">éditeur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, chacun étant associé à une valeur correspondante. </font><font style="vertical-align: inherit;">La première étape du regroupement de données est un XOR distinct de chaque paire attribut-valeur. </font><font style="vertical-align: inherit;">Ensuite, les vecteurs obtenus à partir de ces opérations sont combinés pour créer un seul vecteur de synthèse en utilisant le même algorithme décrit ci-dessus pour stocker plusieurs vecteurs dans une cellule SDM solide. </font><font style="vertical-align: inherit;">En effectuant le XOR du nom d'attribut avec ce vecteur combiné, nous obtenons une approximation de la valeur correspondante suffisamment proche pour la déterminer par la méthode de rappel récursif. </font><font style="vertical-align: inherit;">Dans des expériences avec le modèle canonique, j'ai trouvé que</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-471"><span class="MJXp-mn" id="MJXp-Span-472">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-160-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-160">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un vecteur binaire peut stocker six ou sept paires attribut-valeur sans grand risque de confusion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La reliure et le regroupement ne sont pas mentionnés dans le livre de 1988 de Kanerva, mais il en parle en détail dans de nouveaux articles. (Voir la section «Lecture supplémentaire» ci-dessous.) Cela indique qu'avec ces deux opérateurs, de nombreux vecteurs de haute dimension prennent la structure d'un champ algébrique, ou au moins l'approximation d'un champ. Un exemple canonique d'un champ est un ensemble de nombres réels au lieu des opérations d'addition et de multiplication, ainsi que leurs opérateurs inverses. Les nombres réels créent un ensemble fermé sous ces opérations: l'addition, la soustraction, la multiplication ou la division de deux nombres réels donne un autre nombre réel (à l'exception de la division par zéro, qui est toujours un farceur dans le jeu). De même, l'ensemble des vecteurs binaires est fermé pour la liaison et le regroupement, saufque parfois, afin de restaurer un membre d'un ensemble, le résultat extrait du vecteur de bande doit être «effacé» par le processus de rappel récursif.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La liaison et le regroupement peuvent-ils nous aider à obtenir un algorithme d'errance dans le cloud? Ils nous donnent des outils de base pour naviguer dans un graphe sémantique, y compris la possibilité d'effectuer une traversée aléatoire. À partir de n'importe quel nœud du graphe XOR connecté, l'algorithme de parcours aléatoire sélectionne parmi tous les liens disponibles dans cette piqûre. Un choix aléatoire du vecteur de communication et de l'exécution XOR de ce vecteur avec l'adresse du nœud nous conduit à un autre nœud où la procédure peut être répétée. De même, dans les paires «attribut-valeur» du regroupement, un attribut sélectionné au hasard appelle la valeur correspondante, qui devient le prochain nœud à étudier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais comment un algorithme sait-il quelles relations ou quels algorithmes sont disponibles pour la sélection? Les relations et les attributs sont représentés sous forme de vecteurs et sont stockés en mémoire comme tous les autres objets, il n'y a donc aucun moyen évident d'obtenir ces vecteurs à moins de savoir ce qu'ils sont réellement. Nous ne pouvons pas dire la mémoire de "montrez-moi toutes les connexions." Nous pouvons seulement montrer le motif et demander «existe-t-il un tel vecteur? Avez-vous vu quelque chose comme ça? "</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la mémoire informatique traditionnelle, nous pouvons obtenir un vidage de la mémoire: accédez à toutes les adresses et affichez la valeur trouvée à chaque endroit. Mais pour la mémoire distribuée, il n'y a pas une telle procédure. Ce fait déprimant m'a été donné avec difficulté. Lors de la construction du modèle de calcul SDM, j'ai réussi à devenir suffisamment bon pour avoir la possibilité de stocker plusieurs milliers de modèles générés aléatoirement dans ma mémoire. Mais je n'ai pas pu les extraire car je ne savais pas quoi demander. La solution était de créer une liste distincte en dehors du SDM lui-même, dans laquelle tout ce que j'enregistrer serait écrit. Mais l'hypothèse que le cerveau aurait gardé à la fois la mémoire et l'index de cette mémoire semble farfelue. Pourquoi ne pas simplement utiliser un index, car c'est tellement plus facile?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison de cette limitation, il semble que la mémoire distribuée clairsemée soit équipée pour servir les sens, mais pas l'imagination. Il peut reconnaître des modèles familiers et en enregistrer de nouveaux qui seront reconnus lors de futures réunions, même à partir de signaux partiels ou endommagés. Grâce à la liaison ou au regroupement, la mémoire peut également suivre les liens entre des paires d'éléments stockés. Mais tout ce qui est écrit en mémoire ne peut être récupéré qu'en transmettant un signal approprié.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/441/531/686/4415316868403204d8d2df1f22201eeb.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand je regarde </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affiche </font><em><font style="vertical-align: inherit;">Graduate</font></em><font style="vertical-align: inherit;"> , je vois Dustin Hoffman regarder la jambe d'Anne Bancroft en bas. Ce stimulus visuel excite des sous-ensembles de neurones dans le cortex cérébral, correspondant à mes souvenirs d'acteurs, de personnages, d'intrigue, de bande sonore et de 1967. Toute cette activité cérébrale peut être expliquée par l'architecture de la mémoire SDM, si nous supposons que des sous-ensembles de neurones peuvent être représentés sous une forme abstraite comme de longs vecteurs binaires aléatoires. Mais on ne peut pas expliquer aussi facilement le fait que je peux provoquer toutes les mêmes sensations dans le cerveau sans voir cette image. Comment puis-je extraire spécifiquement ces longues séquences aléatoires d'une énorme imbrication de vecteurs, sans savoir exactement où ils se trouvent?</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci conclut mon long voyage - une note de doute et de déception. Cela ne vous surprend guère que je ne sois pas parvenu à l'essentiel. C'est un sujet très complexe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tout premier jour du programme Brain and Computing au Simons Institute, Jeff Lichtman, qui a travaillé sur le traçage des circuits dans le cerveau des souris, a posé la question: les neurosciences ont-elles déjà atteint le moment Watson-Crick? En génétique moléculaire, nous avons atteint le point où nous avons pu retirer un brin d'ADN d'une cellule vivante et y lire de nombreux messages. Nous pouvons même enregistrer nos propres messages et les réinsérer dans le corps. Une capacité similaire en neuroscience serait d'étudier les tissus cérébraux et de lire les informations qui y sont stockées - connaissances, souvenirs, visions du monde. Peut-être pourrions-nous même écrire des informations directement dans le cerveau.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La science n'a même pas réussi à atteindre cet objectif, à la joie de beaucoup. Y compris moi: je ne veux pas que mes pensées soient aspirées de ma tête à travers des électrodes ou des pipettes et remplacées par #fakenews. Cependant, je </font><font style="vertical-align: inherit;">veux </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraiment</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> savoir comment fonctionne le cerveau.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le programme de l'Institut Simons m'a aveuglé avec le récent succès des neurosciences, mais il m'a aussi fait réaliser qu'une des questions les plus sérieuses reste sans réponse. Les projets de connectivité de Lichtmann et d'autres créent une carte détaillée de millions de neurones et de leurs connexions. De nouvelles techniques d'enregistrement nous permettent d'écouter les signaux émis par les neurocytes individuels et de suivre les vagues d'excitation à travers de vastes zones du cerveau. Nous avons un catalogue assez complet de types de neurones et nous en savons beaucoup sur leur physiologie et leur biochimie. Tout cela est impressionnant, mais il reste des énigmes. Nous pouvons enregistrer des signaux neuronaux, mais pour la plupart, nous ne savons pas ce qu'ils signifient. Nous ne savons pas comment les informations sont encodées et stockées dans le cerveau. Cela revient à essayer de comprendre le schéma de circuit d'un ordinateur numérique sans connaître l'arithmétique binaire et la logique booléenne.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le modèle de mémoire distribuée clairsemée de Pentti Canerva est une tentative pour combler certaines de ces lacunes. </font><font style="vertical-align: inherit;">Ce n'est pas la seule tentative de ce genre. </font><font style="vertical-align: inherit;">Une alternative mieux connue est l'approche de John Hopfield - le concept d'un réseau de neurones en tant que système dynamique, prenant la forme d'un attracteur minimisant l'énergie. </font><font style="vertical-align: inherit;">Ces deux idées ont des principes de base communs: l'information est dispersée sur un grand nombre de neurones et encodée sous une forme qui n'est pas évidente pour un observateur externe, même lui aura accès à tous les neurones et aux signaux qui les traversent. </font><font style="vertical-align: inherit;">Des schémas similaires, qui sont essentiellement mathématiques et informatiques, sont conceptuellement situés entre la psychologie de haut niveau et l'ingénierie neuronale de bas niveau. </font><font style="vertical-align: inherit;">Cette couche contient la valeur.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture complémentaire</font></font></b> <div class="spoiler_text"> Hopfield, JJ (1982). Neural networks and physical systems with emergent collective computational abilities. <em>Proceedings of the National Academy of Sciences</em> 79(8):2554–2558. <br><br> Kanerva, Pentti. 1988. <em>Sparse Distributed Memory</em> . Cambridge, Mass.: MIT Press. <br><br> Kanerva, Pentti. 1996. Binary spatter-coding of ordered <em>K</em> -tuples. In C. von der Malsburg, W. von Seelen, JC Vorbruggen and B. Sendhoff, eds. <em>Artificial Neural Networks—ICANN 96 Proceedings</em> , pp. 869–873. Berlin: Springer. <br><br> Kanerva, Pentti. 2000. Large patterns make great symbols: An example of learning from example. In S. Wermter and R. Sun, eds. <em>Hybrid Neural Systems</em> , pp. 194–203. Heidelberg: Springer. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> <br><br> Kanerva, Pentti. 2009. Hyperdimensional computing: An introduction to computing in distributed representation with high-dimensional random vectors. <em>Cognitive Computation</em> 1(2):139–159. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> <br><br> Kanerva, Pentti. 2010. What we mean when we say “What's the Dollar of Mexico?”: Prototypes and mapping in concept space. Report FS-10-08-006, AAAI Fall Symposium on Quantum Informatics for Cognitive, Social, and Semantic Processes. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> <br><br> Kanerva, Pentti. 2014. Computing with 10,000-bit words. Fifty-second Annual Allerton Conference, University of Illinois at Urbana-Champagne, October 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> </div></div><br><p> Plate, Tony. 1995. Holographic reduced representations. IEEE Transactions on Neural Networks 6(3):623–641. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> <br><br> Plate, Tony A. 2003. <em>Holographic Reduced Representation: Distributed Representation of Cognitive Structure</em> . Stanford, CA: CSLI Publications. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419147/">https://habr.com/ru/post/fr419147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419135/index.html">Vendredi JS: jeu JS et CSS en ligne</a></li>
<li><a href="../fr419137/index.html">Journalisation des activités à l'aide de l'API Web Beacon</a></li>
<li><a href="../fr419141/index.html">Le phishing sexuel gagne du terrain aux États-Unis</a></li>
<li><a href="../fr419143/index.html">Création d'une machine d'arcade d'émulation. Partie 4</a></li>
<li><a href="../fr419145/index.html">Fintech Digest: la capitalisation d'Apple a dépassé le billion de dollars, l'IA a aidé eBay à augmenter ses revenus de plusieurs milliards</a></li>
<li><a href="../fr419149/index.html">Guide de Mikrotik RoMON</a></li>
<li><a href="../fr419151/index.html">Maison intelligente: une nouvelle dimension de confort et la recherche de l'excellence. Deuxième partie</a></li>
<li><a href="../fr419153/index.html">Mémorandum sur les droits de Cyborg</a></li>
<li><a href="../fr419155/index.html">Portage de JS vers Elbrus</a></li>
<li><a href="../fr419159/index.html">Code JS, chiffres romains, devinettes géométriques: comment chiffrer notre âge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>