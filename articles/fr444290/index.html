<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üîù üç± Les bases de la programmation r√©active √† l'aide de RxJS. Partie 2. Op√©rateurs et tuyaux ü§ù üê≠ ‚õëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article pr√©c√©dent, nous avons examin√© ce que sont les flux et ce avec quoi ils mangent. Dans la nouvelle partie, nous allons nous familiariser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les bases de la programmation r√©active √† l'aide de RxJS. Partie 2. Op√©rateurs et tuyaux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444290/"><img src="https://habrastorage.org/webt/rj/7g/bm/rj7gbmr84swtbidqadkbgh5bg3q.png"><br><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent,</a> nous avons examin√© ce que sont les flux et ce avec quoi ils mangent.  Dans la nouvelle partie, nous allons nous familiariser avec les m√©thodes que RxJS fournit pour cr√©er des flux, quels sont les op√©rateurs, les tuyaux et comment travailler avec eux. <br><br>  S√©rie d'articles "Fondamentaux de la programmation r√©active utilisant RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1. R√©activit√© et flux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3. Observables d'ordre sup√©rieur</a> </li></ul><br><br>  RxJS poss√®de une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">API</a> riche.  La documentation d√©crit plus d'une centaine de m√©thodes.  Pour les conna√Ætre un peu, nous √©crirons une application simple et en pratique nous verrons √† quoi ressemble le code r√©actif.  Vous verrez que les m√™mes t√¢ches, qui semblaient routini√®res et n√©cessitaient d'√©crire beaucoup de code, ont une solution √©l√©gante si vous les regardez √† travers le prisme de la r√©activit√©.  Mais avant de commencer, nous allons voir comment les flux peuvent √™tre repr√©sent√©s graphiquement et se familiariser avec les m√©thodes pratiques pour les cr√©er et les traiter. <a name="habracut"></a><br><br><h4>  Repr√©sentation graphique des threads </h4><br>  Pour montrer clairement comment se comporte un flux particulier, j'utiliserai la notation adopt√©e dans l'approche r√©active.  Rappelons notre exemple de l'article pr√©c√©dent: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); });</code> </pre> <br>  Voici √† quoi ressemblera sa repr√©sentation graphique: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Le flux est g√©n√©ralement repr√©sent√© par une ligne droite.  Si le flux √©met une valeur, il s'affiche sur la ligne sous forme de cercle.  Une ligne droite √† l'√©cran est le signal de fin du flux.  Pour afficher l'erreur, utilisez le symbole - ¬´√ó¬ª. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.error(); });</code> </pre><br><img src="https://habrastorage.org/webt/qo/7i/ut/qo7iutxhycufjmujmhhbvjzxz5w.png"><br><br><h4>  Flux d'une ligne </h4><br>  Dans ma pratique, je devais rarement cr√©er mes propres instances observables directement.  La plupart des m√©thodes de cr√©ation de threads sont d√©j√† dans RxJS.  Pour cr√©er un flux √©mettant les valeurs 1 et 2, il suffit d'utiliser la m√©thode of: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  La m√©thode of accepte n'importe quel nombre d'arguments et retourne une instance finie de l'Observable.  Apr√®s s'√™tre abonn√©, il √©mettra les valeurs re√ßues et compl√©tera: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Si vous souhaitez repr√©senter le tableau sous forme de flux, vous pouvez utiliser la m√©thode from.  La m√©thode from en tant qu'argument attend tout objet it√©rable (tableau, cha√Æne, etc.) ou promesse, et projette cet objet sur le flux.  Voici √† quoi ressemblera le flux obtenu √† partir de la cha√Æne: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/y7/ky/nd/y7kynd1a6oolkik-adnjnriav6e.png"><br><br>  Et donc, vous pouvez envelopper une promesse dans un flux: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(promise);</code> </pre><br><img src="https://habrastorage.org/webt/rc/us/sr/rcussrgfjolqzykg9ao3lkj_aj4.png"><br><br>  <b>Remarque:</b> souvent, les discussions sont compar√©es √† la promesse.  En fait, ils n'ont qu'une chose en commun: une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">strat√©gie de pouss√©e pour</a> propager le changement.  Les autres sont des entit√©s compl√®tement diff√©rentes.  La promesse ne peut pas produire plusieurs valeurs.  Il peut uniquement ex√©cuter la r√©solution ou le rejet, c'est-√†-dire  n'ont que deux √©tats.  Un flux peut transmettre plusieurs valeurs et peut √™tre r√©utilis√©. <br><br>  Vous souvenez-vous de l'exemple avec l'intervalle du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article</a> ?  Ce flux est une minuterie qui compte le temps en secondes √† partir du moment de l'abonnement. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  Voici comment vous pouvez impl√©menter la m√™me chose sur une seule ligne: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/yd/ju/ks/ydjuksn4esnkrup6euizzcnqwm8.png"><br><br>  Et enfin, une m√©thode qui vous permet de cr√©er un flux d'√©v√©nements pour les √©l√©ments DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = fromEvent(domElementRef, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);</code> </pre><br>  En tant que valeurs, ce flux recevra et √©mettra des objets d'√©v√©nement keyup. <br><br><h4>  Tuyaux et op√©rateurs </h4><br>  Pipe est une m√©thode de classe Observable ajout√©e dans RxJS dans la version 5.5.  Gr√¢ce √† lui, nous pouvons construire des cha√Ænes d'op√©rateurs pour le traitement s√©quentiel des valeurs re√ßues dans le flux.  Le tuyau est un canal unidirectionnel qui relie les op√©rateurs.  Les op√©rateurs eux-m√™mes sont des fonctions normales d√©crites dans RxJS qui traitent les valeurs d'un flux. <br><br>  Par exemple, ils peuvent convertir la valeur et la transmettre au flux, ou ils peuvent agir comme des filtres et ne sauter aucune valeur s'ils ne remplissent pas la condition sp√©cifi√©e. <br><br>  Regardons les op√©rateurs en action.  Multipliez chaque valeur du flux par 2 √† l'aide de l'op√©rateur de carte: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value * <span class="hljs-number"><span class="hljs-number">2</span></span>) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Voici √† quoi ressemble le flux avant d'appliquer l'op√©rateur de carte: <br><br><img src="https://habrastorage.org/webt/ns/a_/fh/nsa_fhvt6qqz_yktb4yl4jgac-k.png"><br><br>  Apr√®s l'instruction de la carte: <br><br><img src="https://habrastorage.org/webt/5_/vt/ku/5_vtku2aaynipw8jt4gae9iotlc.png"><br><br>  Utilisons l'op√©rateur de filtre.  Cette instruction fonctionne exactement comme la fonction de filtre de la classe Array.  La m√©thode prend une fonction comme premier argument, qui d√©crit une condition.  Si la valeur du flux satisfait la condition, elle est transmise: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( <span class="hljs-comment"><span class="hljs-comment">//     filter(value =&gt; value % 2 !== 0), map(value = value * 2) ).subscribe({ next: console.log });</span></span></code> </pre><br>  Et voici √† quoi ressemblera l'ensemble du sch√©ma de notre flux: <br><br><img src="https://habrastorage.org/webt/ke/ne/wm/kenewmpioakcrwofit2b2x2k-je.png"><br><br>  Apr√®s le filtre: <br><br><img src="https://habrastorage.org/webt/l1/xr/z1/l1xrz1kaxs96xuz7t35k_6safny.png"><br><br>  Apr√®s la carte: <br><br><img src="https://habrastorage.org/webt/uv/za/va/uvzavasqypswdfiqk51esahuu0g.png"><br><br>  <b>Remarque:</b> pipe! == abonnez-vous.  La m√©thode pipe d√©clare le comportement de flux, mais ne s'abonne pas.  Jusqu'√† ce que vous appeliez la m√©thode d'abonnement, votre flux ne commencera pas √† fonctionner. <br><br><h4>  Nous r√©digeons une candidature </h4><br>  Maintenant que nous avons compris ce que sont les tuyaux et les op√©rateurs, vous pouvez vous mettre √† la pratique.  Notre application effectuera une t√¢che simple: afficher une liste des r√©f√©rentiels github ouverts par le surnom du propri√©taire entr√©. <br><br>  Il y aura peu d'exigences: <br><br><ul><li>  N'ex√©cutez pas de demande d'API si la cha√Æne entr√©e en entr√©e contient moins de 3 caract√®res; </li><li>  Afin de ne pas r√©pondre √† la demande de chaque caract√®re entr√© par l'utilisateur, vous devez d√©finir le d√©lai (anti-rebond) sur 700 millisecondes avant d'acc√©der √† l'API; </li></ul><br>  Pour rechercher des r√©f√©rentiels, nous utiliserons l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">API github</a> .  Je recommande d'ex√©cuter les exemples eux-m√™mes sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">stackblitz</a> .  L√†, j'ai expos√© l'impl√©mentation termin√©e.  Des liens sont fournis √† la fin de l'article. <br><br>  Commen√ßons par le balisage html.  D√©crivons les √©l√©ments d'entr√©e et ul: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Ensuite, dans le fichier js ou ts, nous obtenons des liens vers les √©l√©ments actuels en utilisant l'API du navigateur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>);</code> </pre><br>  Nous avons √©galement besoin d'une m√©thode qui ex√©cutera une demande √† l'API github.  Vous trouverez ci-dessous le code de la fonction getUsersRepsFromAPI, qui accepte le surnom de l'utilisateur et ex√©cute une demande ajax √† l'aide de la r√©cup√©ration.  Ensuite, il renvoie une promesse, convertissant la r√©ponse r√©ussie en json en cours de route: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(response.ok) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>); }); }</code> </pre><br>  Ensuite, nous √©crivons une m√©thode qui listera les noms des r√©f√©rentiels: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> recordRepsToList = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reps.length; i++) { <span class="hljs-comment"><span class="hljs-comment">//    ,    if (!ul.children[i]) { const newEl = document.createElement('li'); ul.appendChild(newEl); } //      const li = ul.children[i]; li.innerHTML = reps[i].name; } //    while (ul.children.length &gt; reps.length) { ul.removeChild(ul.lastChild); } }</span></span></code> </pre><br>  Les pr√©paratifs sont termin√©s.  Il est temps de jeter un ≈ìil √† RxJS en action.  Nous devons √©couter l'√©v√©nement keyup de notre entr√©e.  Tout d'abord, nous devons comprendre que dans une approche r√©active, nous travaillons avec des flux.  Heureusement, RxJS propose d√©j√† une option similaire.  Rappelez-vous la m√©thode fromEvent que j'ai mentionn√©e ci-dessus.  Nous l'utilisons: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyUp = fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>); keyUp.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Maintenant, notre √©v√©nement est pr√©sent√© comme un flux.  Si nous regardons ce qui est affich√© dans la console, nous verrons un objet de type KeyboardEvent.  Mais nous avons besoin d'une valeur entr√©e par l'utilisateur.  C'est l√† que la m√©thode pipe et l'op√©rateur de carte sont utiles: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Nous proc√©dons √† la mise en ≈ìuvre des exigences.  Pour commencer, nous ex√©cuterons la requ√™te lorsque la valeur entr√©e contient plus de deux caract√®res.  Pour ce faire, utilisez l'op√©rateur de filtrage: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Nous avons trait√© la premi√®re exigence.  Nous passons √† la seconde.  Nous devons mettre en place un anti-rebond.  RxJS a une instruction debounceTime.  Cet op√©rateur comme premier argument prend le nombre de millisecondes pendant lequel la valeur sera conserv√©e avant de passer.  Dans ce cas, chaque nouvelle valeur r√©initialisera la minuterie.  Ainsi, √† la sortie, nous obtenons la derni√®re valeur, apr√®s laquelle 700 millisecondes se sont √©coul√©es. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Voici √† quoi pourrait ressembler notre flux sans debounceTime: <br><br><img src="https://habrastorage.org/webt/c4/tl/lc/c4tllccvfohixydheaohwj2wcvy.png"><br><br>  Et voici √† quoi ressemblera le m√™me flux traversant cette instruction: <br><br><img src="https://habrastorage.org/webt/o0/lg/lx/o0lglx4knoa6ulhkaafuvxyhl1o.png"><br><br>  Avec debounceTime, nous serons moins susceptibles d'utiliser l'API, qui permettra d'√©conomiser du trafic et de d√©charger le serveur. <br><br>  Pour une optimisation suppl√©mentaire, je sugg√®re d'utiliser un autre op√©rateur - distinctUntilChanged.  Cette m√©thode nous sauvera des doublons.  Il est pr√©f√©rable de montrer son travail √† l'aide d'un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'aaabccc'</span></span>).pipe( distinctUntilChanged() )</code> </pre><br>  Sans distinctUntilChanged: <br><br><img src="https://habrastorage.org/webt/ti/ng/7j/ting7jpkqbe1bgfb713x5wleaki.png"><br><br>  Avec distinctUntilChanged: <br><br><img src="https://habrastorage.org/webt/kv/is/-1/kvis-1lx1hwylsyg4dfvuf4tgoa.png"><br><br>  Ajoutez cette instruction imm√©diatement apr√®s l'instruction debounceTime.  Ainsi, nous n'acc√©derons pas √† l'API si la nouvelle valeur co√Øncide pour une raison quelconque avec la pr√©c√©dente.  Une situation similaire peut se produire lorsque l'utilisateur a entr√© de nouveaux caract√®res, puis les a effac√©s √† nouveau.  Puisque nous avons impl√©ment√© un d√©lai, seule la derni√®re valeur tombera dans le flux, la r√©ponse √† laquelle nous avons d√©j√†. <br><br><h4>  Allez sur le serveur </h4><br>  D√©j√† maintenant, nous pouvons d√©crire la logique de la demande et le traitement de la r√©ponse.  Alors que nous ne pouvons travailler qu'avec promesse.  Par cons√©quent, nous d√©crivons un autre op√©rateur de carte qui appellera la m√©thode getUsersRepsFromAPI.  Dans l'observateur, nous d√©crivons la logique de traitement de notre promesse: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  !     RxJS    promise,      */</span></span> fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> getUsersRepsFromAPI(value)) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function"> =&gt;</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps)) });</code> </pre><br>  Pour le moment, nous avons mis en ≈ìuvre tout ce que nous voulions.  Mais notre exemple a un gros inconv√©nient: il n'y a pas de gestion d'erreur.  Notre observateur ne re√ßoit qu'une promesse et n'a aucune id√©e que quelque chose pourrait mal tourner. <br><br>  Bien s√ªr, nous pouvons accrocher la prise sur la promesse dans la m√©thode suivante, mais √† cause de cela, notre code commencera √† ressembler de plus en plus √† un ¬´enfer de rappel¬ª.  Si soudain nous devons ex√©cuter une autre requ√™te, la complexit√© du code augmentera. <br><br>  <b>Remarque: l'</b> utilisation de promesse dans le code RxJS est consid√©r√©e comme anti-mod√®le.  La promesse pr√©sente de nombreux inconv√©nients par rapport √† l'observable.  Il ne peut pas √™tre annul√© et ne peut pas √™tre r√©utilis√©.  Si vous avez le choix, choisissez observable.  Il en va de m√™me pour la m√©thode toPromise de la classe Observable.  Cette m√©thode a √©t√© impl√©ment√©e pour assurer la compatibilit√© avec les biblioth√®ques qui ne peuvent pas fonctionner avec les flux. <br><br>  Nous pouvons utiliser la m√©thode from pour projeter une promesse sur un flux, mais cette m√©thode est lourde d'appels suppl√©mentaires √† la m√©thode d'abonnement et entra√Ænera √©galement la croissance et la complexit√© du code. <br><br>  Ce probl√®me peut √™tre r√©solu √† l'aide de l'op√©rateur mergeMap: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Maintenant, nous n'avons pas besoin d'√©crire la logique de traitement des promesses.  La m√©thode from a g√©n√©r√© un flux de promesses et l'op√©rateur mergeMap l'a trait√©.  Si la promesse est remplie avec succ√®s, la m√©thode suivante est appel√©e et notre observateur recevra l'objet fini.  Si une erreur se produit, la m√©thode d'erreur sera appel√©e et notre observateur affichera une erreur dans la console. <br><br>  L'op√©rateur mergeMap est l√©g√®rement diff√©rent des op√©rateurs avec lesquels nous avons travaill√© plus t√¥t; il appartient aux soi-disant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">observables d'ordre sup√©rieur</a> , dont je parlerai dans le prochain article.  Mais, pour l'avenir, je dirai que la m√©thode mergeMap elle-m√™me souscrit au flux. <br><br><h4>  Gestion des erreurs </h4><br>  Si notre thread re√ßoit une erreur, il se terminera.  Et si nous essayons d'interagir avec l'application apr√®s une erreur, nous n'obtiendrons aucune r√©action, car notre thread est termin√©. <br><br>  Ici, l'op√©rateur catchError nous aidera.  catchError est d√©clench√©e uniquement lorsqu'une erreur se produit dans le flux.  Il vous permet de l'intercepter, de le traiter et de rendre au flux la valeur habituelle, ce qui ne conduira pas √† son ach√®vement. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Nous interceptons l'erreur dans catchError et retournons √† la place un flux avec un tableau vide.  Maintenant, lorsqu'une erreur se produit, nous effa√ßons la liste des r√©f√©rentiels.  Mais alors le flux se termine √† nouveau. <br><br>  Le fait est que catchError remplace notre flux d'origine par un nouveau.  Et puis notre observateur n'√©coute que lui.  Lorsque le flux √©met un tableau vide, la m√©thode compl√®te est appel√©e. <br><br>  Afin de ne pas remplacer notre thread d'origine, nous appelons l'op√©rateur catchError sur le thread from depuis l'int√©rieur de l'op√©rateur mergeMap. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Ainsi, notre flux d'origine ne remarquera rien.  Au lieu d'une erreur, il obtiendra un tableau vide. <br><br><h4>  Conclusion </h4><br>  Nous avons finalement commenc√© √† pratiquer et avons vu √† quoi servent les tuyaux et les op√©rateurs.  Nous avons examin√© comment r√©duire le code en utilisant la riche API que RxJS nous fournit.  Bien s√ªr, notre application n'est pas termin√©e, dans la partie suivante, nous analyserons comment il est possible d'en traiter une autre dans un thread et comment annuler notre demande http afin d'√©conomiser encore plus de trafic et de ressources de notre application.  Et pour que vous puissiez voir la diff√©rence, j'ai pr√©sent√© un exemple sans utiliser RxJS, vous pouvez le voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> .  Sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ce lien,</a> vous trouverez le code complet de l'application actuelle.  Pour g√©n√©rer les circuits, j'ai utilis√© le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">visualiseur RxJS</a> . <br><br>  J'esp√®re que cet article vous a aid√© √† mieux comprendre comment fonctionne RxJS.  Je vous souhaite du succ√®s dans votre √©tude! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444290/">https://habr.com/ru/post/fr444290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444278/index.html">Comment inciter des dizaines de milliers de personnes √† lire votre article en anglais pour Habr: 3 conseils simples</a></li>
<li><a href="../fr444282/index.html">7 extensions Chrome pour apprendre l'anglais</a></li>
<li><a href="../fr444284/index.html">compositeur et compl√©tion en ligne de commande</a></li>
<li><a href="../fr444286/index.html">Analyse des cam√©ras PTZ: ce qu'il y a √† l'int√©rieur et comment cela fonctionne</a></li>
<li><a href="../fr444288/index.html">Nouvelle application mobile LampTest.ru</a></li>
<li><a href="../fr444294/index.html">Fonctionnement de l'aviation d'affaires en Russie (centres FBO)</a></li>
<li><a href="../fr444296/index.html">6 ressources et services utiles pour les √©migrants potentiels aux √âtats-Unis, en Allemagne et au Canada</a></li>
<li><a href="../fr444298/index.html">Les scientifiques disent qu'ils peuvent remodeler les dinosaures vivants pendant 5 ans</a></li>
<li><a href="../fr444300/index.html">L'√©volution de l'architecture du syst√®me de n√©gociation et de compensation de la Bourse de Moscou. Partie 1</a></li>
<li><a href="../fr444302/index.html">L'√©volution de l'architecture du syst√®me de n√©gociation et de compensation de la Bourse de Moscou. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>