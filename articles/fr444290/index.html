<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏽 🔝 🍱 Les bases de la programmation réactive à l'aide de RxJS. Partie 2. Opérateurs et tuyaux 🤝 🐭 ⛑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article précédent, nous avons examiné ce que sont les flux et ce avec quoi ils mangent. Dans la nouvelle partie, nous allons nous familiariser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les bases de la programmation réactive à l'aide de RxJS. Partie 2. Opérateurs et tuyaux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444290/"><img src="https://habrastorage.org/webt/rj/7g/bm/rj7gbmr84swtbidqadkbgh5bg3q.png"><br><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent,</a> nous avons examiné ce que sont les flux et ce avec quoi ils mangent.  Dans la nouvelle partie, nous allons nous familiariser avec les méthodes que RxJS fournit pour créer des flux, quels sont les opérateurs, les tuyaux et comment travailler avec eux. <br><br>  Série d'articles "Fondamentaux de la programmation réactive utilisant RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1. Réactivité et flux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3. Observables d'ordre supérieur</a> </li></ul><br><br>  RxJS possède une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">API</a> riche.  La documentation décrit plus d'une centaine de méthodes.  Pour les connaître un peu, nous écrirons une application simple et en pratique nous verrons à quoi ressemble le code réactif.  Vous verrez que les mêmes tâches, qui semblaient routinières et nécessitaient d'écrire beaucoup de code, ont une solution élégante si vous les regardez à travers le prisme de la réactivité.  Mais avant de commencer, nous allons voir comment les flux peuvent être représentés graphiquement et se familiariser avec les méthodes pratiques pour les créer et les traiter. <a name="habracut"></a><br><br><h4>  Représentation graphique des threads </h4><br>  Pour montrer clairement comment se comporte un flux particulier, j'utiliserai la notation adoptée dans l'approche réactive.  Rappelons notre exemple de l'article précédent: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); });</code> </pre> <br>  Voici à quoi ressemblera sa représentation graphique: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Le flux est généralement représenté par une ligne droite.  Si le flux émet une valeur, il s'affiche sur la ligne sous forme de cercle.  Une ligne droite à l'écran est le signal de fin du flux.  Pour afficher l'erreur, utilisez le symbole - «×». <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.error(); });</code> </pre><br><img src="https://habrastorage.org/webt/qo/7i/ut/qo7iutxhycufjmujmhhbvjzxz5w.png"><br><br><h4>  Flux d'une ligne </h4><br>  Dans ma pratique, je devais rarement créer mes propres instances observables directement.  La plupart des méthodes de création de threads sont déjà dans RxJS.  Pour créer un flux émettant les valeurs 1 et 2, il suffit d'utiliser la méthode of: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  La méthode of accepte n'importe quel nombre d'arguments et retourne une instance finie de l'Observable.  Après s'être abonné, il émettra les valeurs reçues et complétera: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Si vous souhaitez représenter le tableau sous forme de flux, vous pouvez utiliser la méthode from.  La méthode from en tant qu'argument attend tout objet itérable (tableau, chaîne, etc.) ou promesse, et projette cet objet sur le flux.  Voici à quoi ressemblera le flux obtenu à partir de la chaîne: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/y7/ky/nd/y7kynd1a6oolkik-adnjnriav6e.png"><br><br>  Et donc, vous pouvez envelopper une promesse dans un flux: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(promise);</code> </pre><br><img src="https://habrastorage.org/webt/rc/us/sr/rcussrgfjolqzykg9ao3lkj_aj4.png"><br><br>  <b>Remarque:</b> souvent, les discussions sont comparées à la promesse.  En fait, ils n'ont qu'une chose en commun: une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stratégie de poussée pour</a> propager le changement.  Les autres sont des entités complètement différentes.  La promesse ne peut pas produire plusieurs valeurs.  Il peut uniquement exécuter la résolution ou le rejet, c'est-à-dire  n'ont que deux états.  Un flux peut transmettre plusieurs valeurs et peut être réutilisé. <br><br>  Vous souvenez-vous de l'exemple avec l'intervalle du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article</a> ?  Ce flux est une minuterie qui compte le temps en secondes à partir du moment de l'abonnement. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  Voici comment vous pouvez implémenter la même chose sur une seule ligne: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/yd/ju/ks/ydjuksn4esnkrup6euizzcnqwm8.png"><br><br>  Et enfin, une méthode qui vous permet de créer un flux d'événements pour les éléments DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = fromEvent(domElementRef, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);</code> </pre><br>  En tant que valeurs, ce flux recevra et émettra des objets d'événement keyup. <br><br><h4>  Tuyaux et opérateurs </h4><br>  Pipe est une méthode de classe Observable ajoutée dans RxJS dans la version 5.5.  Grâce à lui, nous pouvons construire des chaînes d'opérateurs pour le traitement séquentiel des valeurs reçues dans le flux.  Le tuyau est un canal unidirectionnel qui relie les opérateurs.  Les opérateurs eux-mêmes sont des fonctions normales décrites dans RxJS qui traitent les valeurs d'un flux. <br><br>  Par exemple, ils peuvent convertir la valeur et la transmettre au flux, ou ils peuvent agir comme des filtres et ne sauter aucune valeur s'ils ne remplissent pas la condition spécifiée. <br><br>  Regardons les opérateurs en action.  Multipliez chaque valeur du flux par 2 à l'aide de l'opérateur de carte: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value * <span class="hljs-number"><span class="hljs-number">2</span></span>) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Voici à quoi ressemble le flux avant d'appliquer l'opérateur de carte: <br><br><img src="https://habrastorage.org/webt/ns/a_/fh/nsa_fhvt6qqz_yktb4yl4jgac-k.png"><br><br>  Après l'instruction de la carte: <br><br><img src="https://habrastorage.org/webt/5_/vt/ku/5_vtku2aaynipw8jt4gae9iotlc.png"><br><br>  Utilisons l'opérateur de filtre.  Cette instruction fonctionne exactement comme la fonction de filtre de la classe Array.  La méthode prend une fonction comme premier argument, qui décrit une condition.  Si la valeur du flux satisfait la condition, elle est transmise: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( <span class="hljs-comment"><span class="hljs-comment">//     filter(value =&gt; value % 2 !== 0), map(value = value * 2) ).subscribe({ next: console.log });</span></span></code> </pre><br>  Et voici à quoi ressemblera l'ensemble du schéma de notre flux: <br><br><img src="https://habrastorage.org/webt/ke/ne/wm/kenewmpioakcrwofit2b2x2k-je.png"><br><br>  Après le filtre: <br><br><img src="https://habrastorage.org/webt/l1/xr/z1/l1xrz1kaxs96xuz7t35k_6safny.png"><br><br>  Après la carte: <br><br><img src="https://habrastorage.org/webt/uv/za/va/uvzavasqypswdfiqk51esahuu0g.png"><br><br>  <b>Remarque:</b> pipe! == abonnez-vous.  La méthode pipe déclare le comportement de flux, mais ne s'abonne pas.  Jusqu'à ce que vous appeliez la méthode d'abonnement, votre flux ne commencera pas à fonctionner. <br><br><h4>  Nous rédigeons une candidature </h4><br>  Maintenant que nous avons compris ce que sont les tuyaux et les opérateurs, vous pouvez vous mettre à la pratique.  Notre application effectuera une tâche simple: afficher une liste des référentiels github ouverts par le surnom du propriétaire entré. <br><br>  Il y aura peu d'exigences: <br><br><ul><li>  N'exécutez pas de demande d'API si la chaîne entrée en entrée contient moins de 3 caractères; </li><li>  Afin de ne pas répondre à la demande de chaque caractère entré par l'utilisateur, vous devez définir le délai (anti-rebond) sur 700 millisecondes avant d'accéder à l'API; </li></ul><br>  Pour rechercher des référentiels, nous utiliserons l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">API github</a> .  Je recommande d'exécuter les exemples eux-mêmes sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">stackblitz</a> .  Là, j'ai exposé l'implémentation terminée.  Des liens sont fournis à la fin de l'article. <br><br>  Commençons par le balisage html.  Décrivons les éléments d'entrée et ul: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Ensuite, dans le fichier js ou ts, nous obtenons des liens vers les éléments actuels en utilisant l'API du navigateur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>);</code> </pre><br>  Nous avons également besoin d'une méthode qui exécutera une demande à l'API github.  Vous trouverez ci-dessous le code de la fonction getUsersRepsFromAPI, qui accepte le surnom de l'utilisateur et exécute une demande ajax à l'aide de la récupération.  Ensuite, il renvoie une promesse, convertissant la réponse réussie en json en cours de route: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(response.ok) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>); }); }</code> </pre><br>  Ensuite, nous écrivons une méthode qui listera les noms des référentiels: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> recordRepsToList = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reps.length; i++) { <span class="hljs-comment"><span class="hljs-comment">//    ,    if (!ul.children[i]) { const newEl = document.createElement('li'); ul.appendChild(newEl); } //      const li = ul.children[i]; li.innerHTML = reps[i].name; } //    while (ul.children.length &gt; reps.length) { ul.removeChild(ul.lastChild); } }</span></span></code> </pre><br>  Les préparatifs sont terminés.  Il est temps de jeter un œil à RxJS en action.  Nous devons écouter l'événement keyup de notre entrée.  Tout d'abord, nous devons comprendre que dans une approche réactive, nous travaillons avec des flux.  Heureusement, RxJS propose déjà une option similaire.  Rappelez-vous la méthode fromEvent que j'ai mentionnée ci-dessus.  Nous l'utilisons: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyUp = fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>); keyUp.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Maintenant, notre événement est présenté comme un flux.  Si nous regardons ce qui est affiché dans la console, nous verrons un objet de type KeyboardEvent.  Mais nous avons besoin d'une valeur entrée par l'utilisateur.  C'est là que la méthode pipe et l'opérateur de carte sont utiles: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Nous procédons à la mise en œuvre des exigences.  Pour commencer, nous exécuterons la requête lorsque la valeur entrée contient plus de deux caractères.  Pour ce faire, utilisez l'opérateur de filtrage: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Nous avons traité la première exigence.  Nous passons à la seconde.  Nous devons mettre en place un anti-rebond.  RxJS a une instruction debounceTime.  Cet opérateur comme premier argument prend le nombre de millisecondes pendant lequel la valeur sera conservée avant de passer.  Dans ce cas, chaque nouvelle valeur réinitialisera la minuterie.  Ainsi, à la sortie, nous obtenons la dernière valeur, après laquelle 700 millisecondes se sont écoulées. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Voici à quoi pourrait ressembler notre flux sans debounceTime: <br><br><img src="https://habrastorage.org/webt/c4/tl/lc/c4tllccvfohixydheaohwj2wcvy.png"><br><br>  Et voici à quoi ressemblera le même flux traversant cette instruction: <br><br><img src="https://habrastorage.org/webt/o0/lg/lx/o0lglx4knoa6ulhkaafuvxyhl1o.png"><br><br>  Avec debounceTime, nous serons moins susceptibles d'utiliser l'API, qui permettra d'économiser du trafic et de décharger le serveur. <br><br>  Pour une optimisation supplémentaire, je suggère d'utiliser un autre opérateur - distinctUntilChanged.  Cette méthode nous sauvera des doublons.  Il est préférable de montrer son travail à l'aide d'un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'aaabccc'</span></span>).pipe( distinctUntilChanged() )</code> </pre><br>  Sans distinctUntilChanged: <br><br><img src="https://habrastorage.org/webt/ti/ng/7j/ting7jpkqbe1bgfb713x5wleaki.png"><br><br>  Avec distinctUntilChanged: <br><br><img src="https://habrastorage.org/webt/kv/is/-1/kvis-1lx1hwylsyg4dfvuf4tgoa.png"><br><br>  Ajoutez cette instruction immédiatement après l'instruction debounceTime.  Ainsi, nous n'accéderons pas à l'API si la nouvelle valeur coïncide pour une raison quelconque avec la précédente.  Une situation similaire peut se produire lorsque l'utilisateur a entré de nouveaux caractères, puis les a effacés à nouveau.  Puisque nous avons implémenté un délai, seule la dernière valeur tombera dans le flux, la réponse à laquelle nous avons déjà. <br><br><h4>  Allez sur le serveur </h4><br>  Déjà maintenant, nous pouvons décrire la logique de la demande et le traitement de la réponse.  Alors que nous ne pouvons travailler qu'avec promesse.  Par conséquent, nous décrivons un autre opérateur de carte qui appellera la méthode getUsersRepsFromAPI.  Dans l'observateur, nous décrivons la logique de traitement de notre promesse: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  !     RxJS    promise,      */</span></span> fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> getUsersRepsFromAPI(value)) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function"> =&gt;</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps)) });</code> </pre><br>  Pour le moment, nous avons mis en œuvre tout ce que nous voulions.  Mais notre exemple a un gros inconvénient: il n'y a pas de gestion d'erreur.  Notre observateur ne reçoit qu'une promesse et n'a aucune idée que quelque chose pourrait mal tourner. <br><br>  Bien sûr, nous pouvons accrocher la prise sur la promesse dans la méthode suivante, mais à cause de cela, notre code commencera à ressembler de plus en plus à un «enfer de rappel».  Si soudain nous devons exécuter une autre requête, la complexité du code augmentera. <br><br>  <b>Remarque: l'</b> utilisation de promesse dans le code RxJS est considérée comme anti-modèle.  La promesse présente de nombreux inconvénients par rapport à l'observable.  Il ne peut pas être annulé et ne peut pas être réutilisé.  Si vous avez le choix, choisissez observable.  Il en va de même pour la méthode toPromise de la classe Observable.  Cette méthode a été implémentée pour assurer la compatibilité avec les bibliothèques qui ne peuvent pas fonctionner avec les flux. <br><br>  Nous pouvons utiliser la méthode from pour projeter une promesse sur un flux, mais cette méthode est lourde d'appels supplémentaires à la méthode d'abonnement et entraînera également la croissance et la complexité du code. <br><br>  Ce problème peut être résolu à l'aide de l'opérateur mergeMap: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Maintenant, nous n'avons pas besoin d'écrire la logique de traitement des promesses.  La méthode from a généré un flux de promesses et l'opérateur mergeMap l'a traité.  Si la promesse est remplie avec succès, la méthode suivante est appelée et notre observateur recevra l'objet fini.  Si une erreur se produit, la méthode d'erreur sera appelée et notre observateur affichera une erreur dans la console. <br><br>  L'opérateur mergeMap est légèrement différent des opérateurs avec lesquels nous avons travaillé plus tôt; il appartient aux soi-disant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">observables d'ordre supérieur</a> , dont je parlerai dans le prochain article.  Mais, pour l'avenir, je dirai que la méthode mergeMap elle-même souscrit au flux. <br><br><h4>  Gestion des erreurs </h4><br>  Si notre thread reçoit une erreur, il se terminera.  Et si nous essayons d'interagir avec l'application après une erreur, nous n'obtiendrons aucune réaction, car notre thread est terminé. <br><br>  Ici, l'opérateur catchError nous aidera.  catchError est déclenchée uniquement lorsqu'une erreur se produit dans le flux.  Il vous permet de l'intercepter, de le traiter et de rendre au flux la valeur habituelle, ce qui ne conduira pas à son achèvement. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Nous interceptons l'erreur dans catchError et retournons à la place un flux avec un tableau vide.  Maintenant, lorsqu'une erreur se produit, nous effaçons la liste des référentiels.  Mais alors le flux se termine à nouveau. <br><br>  Le fait est que catchError remplace notre flux d'origine par un nouveau.  Et puis notre observateur n'écoute que lui.  Lorsque le flux émet un tableau vide, la méthode complète est appelée. <br><br>  Afin de ne pas remplacer notre thread d'origine, nous appelons l'opérateur catchError sur le thread from depuis l'intérieur de l'opérateur mergeMap. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Ainsi, notre flux d'origine ne remarquera rien.  Au lieu d'une erreur, il obtiendra un tableau vide. <br><br><h4>  Conclusion </h4><br>  Nous avons finalement commencé à pratiquer et avons vu à quoi servent les tuyaux et les opérateurs.  Nous avons examiné comment réduire le code en utilisant la riche API que RxJS nous fournit.  Bien sûr, notre application n'est pas terminée, dans la partie suivante, nous analyserons comment il est possible d'en traiter une autre dans un thread et comment annuler notre demande http afin d'économiser encore plus de trafic et de ressources de notre application.  Et pour que vous puissiez voir la différence, j'ai présenté un exemple sans utiliser RxJS, vous pouvez le voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> .  Sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ce lien,</a> vous trouverez le code complet de l'application actuelle.  Pour générer les circuits, j'ai utilisé le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">visualiseur RxJS</a> . <br><br>  J'espère que cet article vous a aidé à mieux comprendre comment fonctionne RxJS.  Je vous souhaite du succès dans votre étude! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444290/">https://habr.com/ru/post/fr444290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444278/index.html">Comment inciter des dizaines de milliers de personnes à lire votre article en anglais pour Habr: 3 conseils simples</a></li>
<li><a href="../fr444282/index.html">7 extensions Chrome pour apprendre l'anglais</a></li>
<li><a href="../fr444284/index.html">compositeur et complétion en ligne de commande</a></li>
<li><a href="../fr444286/index.html">Analyse des caméras PTZ: ce qu'il y a à l'intérieur et comment cela fonctionne</a></li>
<li><a href="../fr444288/index.html">Nouvelle application mobile LampTest.ru</a></li>
<li><a href="../fr444294/index.html">Fonctionnement de l'aviation d'affaires en Russie (centres FBO)</a></li>
<li><a href="../fr444296/index.html">6 ressources et services utiles pour les émigrants potentiels aux États-Unis, en Allemagne et au Canada</a></li>
<li><a href="../fr444298/index.html">Les scientifiques disent qu'ils peuvent remodeler les dinosaures vivants pendant 5 ans</a></li>
<li><a href="../fr444300/index.html">L'évolution de l'architecture du système de négociation et de compensation de la Bourse de Moscou. Partie 1</a></li>
<li><a href="../fr444302/index.html">L'évolution de l'architecture du système de négociation et de compensation de la Bourse de Moscou. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>