<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ä üë©üèø‚Äç‚öïÔ∏è üßúüèª Haskell-abh√§ngige Typen: Warum ist die Zukunft der Softwareentwicklung? üë®‚Äçüî¨ ‚ô¶Ô∏è üçî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Serokell engagieren wir uns nicht nur f√ºr kommerzielle Projekte, sondern bem√ºhen uns auch, die Welt zum Besseren zu ver√§ndern. Zum Beispiel arbeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell-abh√§ngige Typen: Warum ist die Zukunft der Softwareentwicklung?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485174/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fce/995/232/fce99523266b5bc548c3d1730c70b885.jpg"></p><br><p> Bei Serokell engagieren wir uns nicht nur f√ºr kommerzielle Projekte, sondern bem√ºhen uns auch, die Welt zum Besseren zu ver√§ndern.  Zum Beispiel arbeiten wir daran, das Hauptwerkzeug aller Haskelisten zu verbessern - den Glasgow Haskell Compiler (GHC).  Wir konzentrierten uns auf die Erweiterung des Typensystems unter dem Einfluss von Richard Eisenbergs Arbeit <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf" rel="nofollow">"Abh√§ngige Typen in Haskell: Theorie und Praxis".</a> </p><br><p>  In <a href="https://serokell.io/blog/why-dependent-haskell" rel="nofollow">unserem Blog hat</a> Vladislav bereits dar√ºber gesprochen, warum Haskell keine abh√§ngigen Typen hat und wie wir sie hinzuf√ºgen wollen.  Wir haben beschlossen, diesen Beitrag ins Russische zu √ºbersetzen, damit m√∂glichst viele Entwickler abh√§ngige Typen verwenden und einen weiteren Beitrag zur Entwicklung von Haskell als Sprache leisten k√∂nnen. </p><a name="habracut"></a><br><h1 id="tekuschee-polozhenie-del">  Aktueller Stand der Dinge </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6d3/260/bba/6d3260bbad59d047ba6f10b1fffd5383.jpg" alt="Algorithmus zur Auswahl der Programmiersprache"></p><br><p>  Abh√§ngige Typen sind das, was ich in Haskell am meisten vermisse.  Lassen Sie uns diskutieren, warum.  Aus dem Code, den wir wollen: </p><br><ul><li>  Leistung, dh Ausf√ºhrungsgeschwindigkeit und geringer Speicherverbrauch; </li><li>  Wartbarkeit und Verst√§ndlichkeit; </li><li>  Richtigkeit durch die Methode der Kompilierung garantiert. </li></ul><br><p>  Mit vorhandenen Technologien ist es selten m√∂glich, alle drei Merkmale zu erreichen, aber mit der Unterst√ºtzung von Haskell-abh√§ngigen Typen wird die Aufgabe vereinfacht. </p><br><h2 id="standartnyy-haskell-ergonomika--proizvoditelnost">  Haskell Standard: Ergonomie + Leistung </h2><br><p>  Haskell basiert auf einem einfachen System: einem polymorphen Lambda-Kalk√ºl mit Lazy-Berechnungen, algebraischen Datentypen und Typklassen.  Diese Kombination von Sprachfunktionen erm√∂glicht es uns, eleganten, unterst√ºtzten und gleichzeitig produktiven Code zu schreiben.  Um diese Behauptung zu untermauern, vergleichen wir Haskell kurz mit popul√§reren Sprachen. </p><br><p>  Sprachen mit unsicherem Speicherzugriff wie C f√ºhren zu den schwerwiegendsten Fehlern und Sicherheitsl√ºcken (z. B. Puffer√ºberlauf, Speicherlecks).  Manchmal werden solche Sprachen ben√∂tigt, aber meistens ist ihre Verwendung eine Idee. </p><br><p>  Sprachen f√ºr den sicheren Speicherzugriff bilden zwei Gruppen: diejenigen, die auf dem Garbage Collector basieren, und Rust.  Rust scheint einzigartig darin zu sein, einen <a href="https://pcwalton.github.io/2013/05/20/safe-manual-memory-management.html" rel="nofollow">sicheren Speicherzugriff ohne Speicherbereinigung</a> anzubieten.  In dieser Gruppe werden auch Cyclone und andere Forschungssprachen nicht mehr unterst√ºtzt.  Doch im Gegensatz zu ihnen ist Rust auf dem Weg zur Popularit√§t.  Der Nachteil ist, dass die Speicherverwaltung von Rust trotz Sicherheit nicht trivial und manuell ist.  In Anwendungen, die die Verwendung des Garbage Collectors erm√∂glichen, ist es besser, die Entwickler mit anderen Aufgaben zu besch√§ftigen. </p><br><p>  Es gibt noch Sprachen f√ºr M√ºllsammler, die wir basierend auf ihrem Typensystem in zwei Kategorien unterteilen werden. </p><br><p>  Dynamisch typisierte (oder eher <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" rel="nofollow">monotypisierte</a> ) Sprachen wie JavaScript oder Clojure bieten keine statische Analyse und k√∂nnen daher nicht das gleiche Ma√ü an Vertrauen in die Richtigkeit des Codes bieten (und nein, Tests k√∂nnen keine Typen ersetzen - Sie ben√∂tigen beide). !). </p><br><p>  Statisch typisierte Sprachen wie Java oder Go haben oft ein sehr eingeschr√§nktes Typensystem.  Dies zwingt Programmierer, redundanten Code zu schreiben und unsichere Sprachfunktionen zu verwenden.  Beispielsweise erzwingt das Fehlen generischer Typen in Go die Verwendung von <a href="https://tour.golang.org/methods/14" rel="nofollow">Interface {}</a> und das <a href="https://golang.org/ref/spec" rel="nofollow">Casting von Laufzeittypen</a> .  Es gibt auch keine Trennung zwischen Berechnungen mit Nebenwirkungen (Eingabe, Ausgabe) und reinen Berechnungen. </p><br><p>  Schlie√ülich zeichnet sich Haskell unter Sprachen mit sicherem Speicherzugriff, einem Garbage Collector und einem leistungsstarken Typsystem durch Faulheit aus.  <a href="https://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html" rel="nofollow">Lazy Computing ist</a> √§u√üerst n√ºtzlich, um komponierbaren, modularen Code zu schreiben.  Sie erm√∂glichen es, beliebige Teile von Ausdr√ºcken, einschlie√ülich Konstruktionen, die einen Kontrollfluss definieren, in Hilfsdefinitionen zu zerlegen. </p><br><p>  Haskell scheint eine nahezu perfekte Sprache zu sein, bis Sie erkennen, wie weit es davon entfernt ist, sein volles Potenzial in Bezug auf die statische Verifikation im Vergleich zu <a href="https://agda.readthedocs.io/en/latest/" rel="nofollow">Satzbeweiswerkzeugen</a> wie <a href="https://agda.readthedocs.io/en/latest/" rel="nofollow">Agda freizusetzen</a> . </p><br><p> Als einfaches Beispiel f√ºr den Fall, dass das Haskell-Typensystem nicht leistungsf√§hig genug ist, betrachten Sie den <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html" rel="nofollow">Listenindizierungsoperator</a> aus <code>Prelude</code> (oder das <a href="http://hackage.haskell.org/package/primitive-0.6.4.0/docs/Data-Primitive-Array.html" rel="nofollow">Indizieren eines Arrays</a> aus einem <code>primitive</code> Paket): </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a indexArray :: <span class="hljs-type"><span class="hljs-type">Array</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a</code> </pre> <br><p>  Nichts in diesen Typensignaturen spiegelt die Anforderung wider, dass der Index nicht negativ und k√ºrzer als die L√§nge der Auflistung sein muss.  F√ºr Software mit hohen Zuverl√§ssigkeitsanforderungen ist dies nicht akzeptabel. </p><br><h2 id="agda-ergonomika--korrektnost">  Agda: Ergonomie + Korrektheit </h2><br><p>  Beweismittel f√ºr Theoreme (z. B. <a href="https://coq.inria.fr/" rel="nofollow">Coq</a> ) sind Softwaretools, mit denen mithilfe eines Computers formale Beweise f√ºr mathematische Theoreme erstellt werden k√∂nnen.  F√ºr einen Mathematiker ist die Verwendung solcher Werkzeuge wie das Schreiben von Beweisen auf Papier.  Der Unterschied in der beispiellosen Genauigkeit, die ein Computer ben√∂tigt, um die G√ºltigkeit solcher Beweise festzustellen. </p><br><p>  F√ºr den Programmierer ist das Mittel zum Beweisen der Theoreme jedoch nicht so verschieden vom Compiler f√ºr die esoterische Programmiersprache mit einem unglaublichen Typsystem (und m√∂glicherweise einer integrierten Entwicklungsumgebung) und mittelm√§√üigem (oder sogar fehlendem) allem anderen.  Ein Mittel, um Theoreme zu beweisen, sind in der Tat Programmiersprachen, deren Autoren ihre ganze Zeit damit verbracht haben, ein Schreibsystem zu entwickeln, und die vergessen haben, dass Programme noch ausgef√ºhrt werden m√ºssen. </p><br><p>  Der gehegte Traum verifizierter Softwareentwickler ist ein Mittel, um Theoreme zu beweisen, die eine gute Programmiersprache mit qualitativ hochwertigem Codegenerator und Laufzeit w√§ren.  In dieser Richtung experimentierten unter anderem die Macher von <a href="https://www.idris-lang.org/" rel="nofollow">Idris</a> .  Dies ist jedoch eine Sprache mit strengen (energetischen) Berechnungen, und ihre Implementierung ist derzeit nicht stabil. </p><br><p>  Unter allen Beweismitteln f√ºr die Theoreme sind die Haskelisten von Agda am beliebtesten.  In vielerlei Hinsicht √§hnelt es Haskell, verf√ºgt jedoch √ºber ein leistungsf√§higeres Typensystem.  Wir bei Serokell verwenden es, um die verschiedenen Eigenschaften unserer Programme zu beweisen.  Meine Kollegin Dania Rogozin hat eine <a href="https://serokell.io/blog/2018/11/14/logical-background" rel="nofollow">Reihe von Artikeln</a> dar√ºber geschrieben. </p><br><p>  Hier ist ein <a href="" rel="nofollow">Lookup-</a> Funktionstyp √§hnlich dem Haskell-Operator <code>(!!)</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lookup</span></span> : ‚àÄ (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">Fin</span></span> (length xs) ‚Üí <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br><p>  Der erste Parameter hier ist vom Typ <code>List A</code> , der <code>[a]</code> in Haskell entspricht.  Wir geben ihm jedoch den Namen <code>xs</code> , auf den er sich f√ºr den Rest der <code>xs</code> bezieht.  In Haskell k√∂nnen wir auf Funktionsargumente nur im Hauptteil der Funktion auf der Termebene zugreifen: </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a <span class="hljs-comment"><span class="hljs-comment">--   xs  (!!) = \xs i -&gt; ... --   xs </span></span></code> </pre> <br><p>  In Agda k√∂nnen wir uns jedoch auf diesen <code>xs</code> Wert auf der Typebene beziehen, was wir im zweiten <code>lookup</code> Parameter <code>Fin (length xs)</code> tun.  Eine Funktion, die auf der Typebene auf ihren Parameter verweist, wird als <em>abh√§ngige Funktion bezeichnet</em> und ist ein Beispiel f√ºr abh√§ngige Typen. </p><br><p>  Der zweite Parameter in der <code>lookup</code> ist vom Typ <code>Fin n</code> f√ºr <code>n ~ length xs</code> .  Ein Wert vom Typ <code>Fin n</code> entspricht einer Zahl im Bereich <code>[0, n)</code> , sodass <code>Fin (length xs)</code> eine nicht negative Zahl ist, die k√ºrzer als die L√§nge der Eingabeliste ist.  Genau dies ist erforderlich, um einen g√ºltigen Index eines Listenelements anzuzeigen.  Grob gesagt besteht die <code>lookup ["x","y","z"] 2</code> die Typpr√ºfung, aber die <code>lookup ["x","y","z"] 42</code> schl√§gt fehl. </p><br><p>  Wenn es darum geht, Agda-Programme auszuf√ºhren, k√∂nnen wir sie in Haskell mit dem MAlonzo- <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php%3Fn%3DDocs.MAlonzo" rel="nofollow">Backend</a> kompilieren.  Die Leistung des generierten Codes ist jedoch unbefriedigend.  Dies ist nicht MAlonzos Schuld: Er muss zahlreiche <code>unsafeCoerce</code> einf√ºgen, damit der GHC Code <code>unsafeCoerce</code> , der bereits von Agda verifiziert wurde.  Aber das gleiche <code>unsafeCoerce</code> <a href="https://dspace.library.uu.nl/bitstream/handle/1874/357868/3800296.pdf" rel="nofollow">verringert die Leistung</a> <em>(nach der Diskussion dieses Artikels stellte sich heraus, dass Leistungsprobleme durch andere Gr√ºnde verursacht wurden - Anmerkung des Autors)</em> . </p><br><p>  Dies bringt uns in eine schwierige Position: Wir m√ºssen Agda f√ºr die Modellierung und formale Verifizierung verwenden und dann dieselbe Funktionalit√§t auf Haskell erneut implementieren.  Bei dieser Organisation von Workflows fungiert unser Agda-Code als computer√ºberpr√ºfte Spezifikation.  Dies ist besser als die Spezifikation in nat√ºrlicher Sprache, aber alles andere als ideal.  Das Ziel ist, dass, wenn der Code kompiliert wird, er gem√§√ü der Spezifikation funktioniert. </p><br><h2 id="haskell-s-rasshireniyami-korrektnost--proizvoditelnost">  Haskell mit Erweiterungen: Korrektheit + Leistung </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/954/0e8/735/9540e8735ab539e67787046735ee5789.jpg"></p><br><p>  GHC strebt nach statischen Garantien f√ºr Sprachen mit abh√§ngigen Typen und hat einen langen Weg zur√ºckgelegt.  Es wurden Erweiterungen hinzugef√ºgt, um die Aussagekraft des Typensystems zu erh√∂hen.  Ich habe angefangen, Haskell zu verwenden, als GHC 7.4 die neueste Version des Compilers war.  Schon damals gab es die wichtigsten Erweiterungen f√ºr die erweiterte Programmierung auf <code>RankNTypes</code> : <code>RankNTypes</code> , <code>GADTs</code> , <code>TypeFamilies</code> , <code>DataKinds</code> und <code>PolyKinds</code> . </p><br><p>  Dennoch gibt es in Haskell noch keine vollwertigen abh√§ngigen Typen: weder abh√§ngige Funktionen (Œ†-Typen) noch abh√§ngige Paare (Œ£-Typen).  Auf der anderen Seite haben wir zumindest eine Kodierung f√ºr sie! </p><br><p>  Aktuelle Praktiken sind wie folgt: </p><br><ul><li>  Funktionen auf Typebene als private Typfamilien codieren, </li><li>  Funktionalisierung verwenden, um unges√§ttigte Funktionen zu erm√∂glichen, </li><li>  √úberbr√ºcken Sie die L√ºcke zwischen Begriffen und Typen mithilfe einzelner Typen. </li></ul><br><p>  Dies f√ºhrt zu einer erheblichen Menge an redundantem Code, aber die <code>singletons</code> Bibliothek automatisiert ihre Generierung durch Template Haskell. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/003/56f/e2a/00356fe2af43f034df850dbb556fb82f.jpg"></p><br><p>  Die Wagemutigsten und Entschlossensten k√∂nnen jetzt also abh√§ngige Typen in Haskell codieren.  Zur Veranschaulichung ist hier eine Implementierung der <code>lookup</code> √§hnlich der Variante auf Agda: </p><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# OPTIONS -Wall -Wno-unticked-promoted-constructors -Wno-missing-signatures #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE LambdaCase, DataKinds, PolyKinds, TypeFamilies, GADTs, ScopedTypeVariables, EmptyCase, UndecidableInstances, TypeSynonymInstances, FlexibleInstances, TypeApplications, TemplateHaskell #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ListLookup <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.TH <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.Prelude singletons [d| data N = Z | SN len :: [a] -&gt; N len [] = Z len (<span class="hljs-title"><span class="hljs-title">_</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = S (<span class="hljs-title"><span class="hljs-title">len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) |] data Fin n where FZ :: Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) FS :: Fin n -&gt; Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) lookupS :: SingKind a =&gt; SList (<span class="hljs-title"><span class="hljs-title">xs</span></span> :: [<span class="hljs-title"><span class="hljs-title">a</span></span>]) -&gt; Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) -&gt; Demote a lookupS SNil = \case{} lookupS (<span class="hljs-type"><span class="hljs-type">SCons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) = \case FZ -&gt; fromSing x FS i' -&gt; lookupS xs i'</code> </pre> <br><p>  Und hier ist eine GHCi-Sitzung, die zeigt, dass Lookups zu gro√üe Indizes tats√§chlich ablehnen: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">8.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>: http://www.haskell.org/ghc/ :? for help [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">ListLookup</span></span> ( <span class="hljs-type"><span class="hljs-type">ListLookup</span></span>.hs, interpreted ) <span class="hljs-type"><span class="hljs-type">Ok</span></span>, one <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> loaded. *ListLookup&gt; :set -XTypeApplications -XDataKinds *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) FZ "x" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>) "y" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)) "z" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) &lt;interactive&gt;:5:34: error: ‚Ä¢ Couldn't match type ''S n0' with ''Z' Expected type: Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> '["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) Actual type: Fin ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n0</span></span>)))) ‚Ä¢ In the second argument of 'lookupS', namely '(<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))' In the expression: lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) In an equation for 'it': it = lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))</code> </pre> <br><p>  Dieses Beispiel zeigt, dass Machbarkeit nicht praktikabel ist.  Ich bin froh, dass Haskell √ºber Sprachf√§higkeiten f√ºr die Implementierung von <code>lookupS</code> , aber gleichzeitig bin ich besorgt √ºber die unn√∂tige Komplexit√§t, die entsteht.  Au√üerhalb von Forschungsprojekten w√ºrde ich einen solchen Codestil nicht empfehlen. </p><br><p>  In diesem speziellen Fall k√∂nnten wir mit l√§ngenindexierten Vektoren das gleiche Ergebnis mit weniger Komplexit√§t erzielen.  Die direkte Code-√úbersetzung von Agda zeigt jedoch besser die Probleme, die Sie unter anderen Umst√§nden haben m√ºssen. </p><br><p>  Hier sind einige von ihnen: </p><br><ul><li>  Die Typisierungsrelation <code>a :: t</code> und die Zielrelation der Form <code>t :: k</code> unterschiedlich.  <code>5 :: Integer</code> ist in Begriffen wahr, aber nicht in Typen.  <code>"hi" :: Symbol</code> ist in Typen wahr, aber nicht in Begriffen.  Dies erfordert die <code>Demote</code> , um Ansichten und Typen zuzuordnen. </li><li>  Die Standardbibliothek verwendet <code>Int</code> als Darstellung von Listenindizes (und <code>singletons</code> verwendet <code>Nat</code> in erweiterten Definitionen).  <code>Int</code> und <code>Nat</code> sind nicht induktive Typen.  Obwohl sie effizienter sind als die un√§re Codierung nat√ºrlicher Zahlen, funktionieren sie mit induktiven Definitionen wie <code>Fin</code> oder <code>lookupS</code> nicht sehr gut.  Aus diesem Grund definieren wir die <code>length</code> als <code>len</code> . </li><li>  Haskell hat keine eingebauten Mechanismen, um Funktionen auf die Ebene der Typen zu heben.  <code>singletons</code> kodieren sie als private Typfamilien und wenden Funktionalisierung an, um den Mangel an teilweiser Verwendung von Typfamilien zu umgehen.  Diese Kodierung ist kompliziert.  Au√üerdem mussten wir die <code>len</code> Definition in ein Template-Haskell-Zitat einf√ºgen, damit die <code>singletons</code> ihr Gegenst√ºck auf <code>Len</code> , <code>Len</code> generieren. </li><li>  Es gibt keine eingebauten abh√§ngigen Funktionen.  Man muss <a href="https://repository.brynmawr.edu/cgi/viewcontent.cgi%3Farticle%3D1009%26context%3Dcompsci_pubs" rel="nofollow">Einheitentypen verwenden</a> , um die L√ºcke zwischen Begriffen und Typen zu schlie√üen.  Anstelle der √ºblichen Liste √ºbergeben wir die <code>SList</code> an die Eingabe <code>lookupS</code> .  Daher m√ºssen wir mehrere Definitionen von Listen gleichzeitig ber√ºcksichtigen.  Dies f√ºhrt auch zu einem Overhead w√§hrend der Programmausf√ºhrung.  Sie entstehen durch die Umrechnung zwischen <code>toSing</code> und Werten von Einheitentypen ( <code>toSing</code> , <code>fromSing</code> ) und durch die √úbertragung des Umrechnungsverfahrens ( <code>SingKind</code> Restriktion). </li></ul><br><p>  Unbequemlichkeit ist das geringere Problem.  Schlimmer noch, diese Sprachfunktionen sind unzuverl√§ssig.  Zum Beispiel habe ich bereits 2016 das Problem <a href="https://gitlab.haskell.org/ghc/ghc/issues/12564" rel="nofollow">Nr. 12564</a> gemeldet, und es gibt auch <a href="https://gitlab.haskell.org/ghc/ghc/issues/12088" rel="nofollow">Nr. 12088</a> desselben Jahres.  Beide Probleme behindern die Implementierung fortgeschrittenerer Programme als Beispiele aus Lehrb√ºchern (z. B. Indexlisten).  Diese GHC-Fehler sind immer noch nicht behoben, und der Grund, so scheint es mir, ist, dass die Entwickler einfach nicht genug Zeit haben.  Die Anzahl der Personen, die aktiv am GHC arbeiten, ist √ºberraschend gering, sodass sich einige Dinge nicht herumsprechen. </p><br><h2 id="rezyume">  Zusammenfassung </h2><br><p>  Ich habe bereits erw√§hnt, dass wir alle drei Eigenschaften aus dem Code √ºbernehmen m√∂chten. Hier ist eine Tabelle, die den aktuellen Stand der Dinge veranschaulicht: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Standard Haskell </th><th>  Agda </th><th>  Haskell mit Erweiterungen </th></tr></thead><tbody><tr><td>  Ergonomie und Wartbarkeit </td><td>  + </td><td>  + </td><td>  - </td></tr><tr><td>  Leistung </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Die Richtigkeit wird durch die Zeichnungsmethode garantiert </td><td>  - </td><td>  + </td><td>  + </td></tr></tbody></table></div><br><h1 id="svetloe-buduschee">  Strahlende Zukunft </h1><br><p>  Jede der drei verf√ºgbaren Optionen hat ihre Nachteile.  Wir k√∂nnen sie jedoch beheben: </p><br><ul><li>  Nehmen Sie das Standard-Haskell und f√ºgen Sie abh√§ngige Typen direkt hinzu, anstatt umst√§ndliche Codierungen √ºber <code>singletons</code> .  (Leichter gesagt als getan.) </li><li>  Nehmen Sie Agda und implementieren Sie einen effizienten Codegenerator und RTS daf√ºr.  (Leichter gesagt als getan.) </li><li>  Nehmen Sie Haskell mit Erweiterungen, beheben Sie Fehler und f√ºgen Sie weitere Erweiterungen hinzu, um die Codierung abh√§ngiger Typen zu vereinfachen.  (Leichter gesagt als getan.) </li></ul><br><p>  Die gute Nachricht ist, dass alle drei Optionen (gewisserma√üen) an einem Punkt zusammenlaufen.  Stellen Sie sich die kleinste Erweiterung von Haskell vor, die abh√§ngige Typen hinzuf√ºgt und es Ihnen daher erm√∂glicht, die Richtigkeit des Codes durch die Art und Weise, wie er geschrieben wurde, zu gew√§hrleisten.  Agda-Code kann in diese Sprache ohne <code>unsafeCoerce</code> kompiliert (transponiert) werden.  Und Haskell mit Erweiterungen ist gewisserma√üen ein unvollendeter Prototyp dieser Sprache.  Es muss etwas verbessert und etwas entfernt werden, aber am Ende werden wir das gew√ºnschte Ergebnis erzielen. </p><br><h2 id="izbavlenie-ot-singletons">  <code>singletons</code> </h2><br><p>  Ein guter Indikator f√ºr den Fortschritt ist die Vereinfachung der <code>singletons</code> Bibliothek.  Da abh√§ngige Typen in Haskell implementiert sind, sind keine Problemumgehungen und keine spezielle Behandlung von in <code>singletons</code> implementierten Sonderf√§llen mehr erforderlich.  Letztendlich wird die Notwendigkeit f√ºr dieses Paket vollst√§ndig verschwinden.  Beispielsweise habe ich 2016 mit der Erweiterung <a href="https://github.com/goldfirere/singletons/pull/148/files" rel="nofollow">-XTypeInType KProxy</a> von <code>SingKind</code> und <code>SomeSing</code> .  Diese √Ñnderung wurde durch die Vereinigung von Typen und Typen erm√∂glicht.  Vergleichen Sie alte und neue Definitionen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> kparam </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kproxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  In den alten Definitionen kommt <code>k</code> ausschlie√ülich in Ansichtspositionen rechts von Anmerkungen der Form <code>t :: k</code> .  Wir verwenden <code>kparam :: KProxy k</code> , um <code>k</code> auf Typen zu √ºbertragen. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  In den neuen Definitionen bewegt sich <code>k</code> frei zwischen Ansichts- und <code>KProxy</code> , sodass <code>KProxy</code> nicht mehr ben√∂tigt <code>KProxy</code> .  Der Grund daf√ºr ist, dass ab GHC 8.0 Typen und Typen in dieselbe syntaktische Kategorie fallen. </p><br><p>  In Standard-Haskell gibt es drei v√∂llig getrennte Welten: Begriffe, Typen und Ansichten.  Wenn Sie sich den Quellcode von GHC 7.10 ansehen, sehen Sie einen separaten <a href="" rel="nofollow">Parser</a> f√ºr Ansichten und eine separate <a href="" rel="nofollow">Pr√ºfung</a> .  GHC 8.0 hat sie nicht mehr: Der <a href="" rel="nofollow">Parser</a> und die <a href="" rel="nofollow">Validierung</a> f√ºr Typen und Ansichten sind √ºblich. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d01/37e/387/d0137e3870470beb4b2aee56240926cf.jpg"></p><br><p>  In Haskell mit Erweiterungen ist view genau die Rolle, in der sich der Typ befindet: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">T</span></span> z -&gt; ... <span class="hljs-comment"><span class="hljs-comment">-- 'z'   g :: T (a :: z) -&gt; ... -- 'z'   h :: T z -&gt; T (a :: z) -&gt; ... -- 'z'   ,  </span></span></code> </pre> <br><p>  In GHC 8.0‚Äì8.4 gab es noch einige Unterschiede zwischen der Namensaufl√∂sung in Typen und Typen.  Aber ich habe sie auf GHC 8.6 minimiert: Ich habe die <code>StarIsType</code> Erweiterung erstellt und die <code>TypeInType</code> Funktionalit√§t in <code>PolyKinds</code> .  Ich <a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">habe die</a> verbleibenden Unterschiede als <a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">Warnung</a> zu GHC 8.8 gemacht und <a href="https://github.com/ghc/ghc/commit/5bc195b1fe788e9a900a15fbe473967850517c3e" rel="nofollow">sie</a> in GHC 8.10 <a href="https://github.com/ghc/ghc/commit/5bc195b1fe788e9a900a15fbe473967850517c3e" rel="nofollow">vollst√§ndig beseitigt</a> (die <em>√úbersetzung dieses Absatzes wurde aktualisiert, im Original wird die geleistete Arbeit als zuk√ºnftige Aufgaben beschrieben - Anmerkung des Autors</em> ). </p><br><p>  Was ist der n√§chste Schritt?  <code>SingKind</code> wir einen Blick auf <code>SingKind</code> in der neuesten Version von <code>singletons</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">) | r -&gt; k fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  Die <code>Demote</code> erforderlich, um die Abweichungen zwischen der Typisierungsrelation <code>a :: t</code> und der <code>Demote</code> der Form <code>t :: k</code> zu ber√ºcksichtigen.  Am h√§ufigsten (f√ºr algebraische Datentypen) ist <code>Demote</code> eine Identit√§tszuordnung: </p><br><ul><li> <code>type Demote Bool = Bool</code> </li> <li> <code>type Demote [a] = [Demote a]</code> </li> <li> <code>type Demote (Either ab) = Either (Demote a) (Demote b)</code> </li> </ul><br><p>  <code>Demote (Either [Bool] Bool) = Either [Bool] Bool</code> .  Diese Beobachtung veranlasst uns, folgende Vereinfachung vorzunehmen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fromSing :: <span class="hljs-type"><span class="hljs-type">Sing</span></span> (a :: k) -&gt; k toSing :: k -&gt; <span class="hljs-type"><span class="hljs-type">SomeSing</span></span> k</code> </pre> <br><p>  <code>Demote</code> nicht erforderlich!  Tats√§chlich w√ºrde dies sowohl mit <code>Either [Bool] Bool</code> als auch mit anderen algebraischen Datentypen funktionieren.  In der Praxis haben wir es jedoch mit nicht-algebraischen Datentypen zu tun: <code>Integer,</code> <code>Natural</code> , <code>Char</code> , <code>Text</code> und so weiter.  Wenn sie als Spezies verwendet werden, sind sie nicht besiedelt: <code>1 :: Natural</code> ist auf der Ebene der Begriffe wahr, aber nicht auf der Ebene der Typen.  Aus diesem Grund haben wir es mit folgenden Definitionen zu tun: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Natural</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span></span></code> </pre> <br><p>  Die L√∂sung f√ºr dieses Problem besteht darin, primitive Typen zu erheben.  Beispielsweise ist <code>Text</code> wie <code>Text</code> definiert: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | A space efficient, packed, unboxed Unicode text type. data Text = Text {-# UNPACK #-} !Array -- payload (Word16 elements) {-# UNPACK #-} !Int -- offset (units of Word16, not Char) {-# UNPACK #-} !Int -- length (units of Word16, not Char) data Array = Array ByteArray# data Int = I# Int#</span></span></code> </pre> <br><p>  Wenn wir <code>ByteArray#</code> und <code>Int#</code> richtig auf die Ebene der Typen erh√∂hen, k√∂nnen wir <code>Text</code> anstelle von <code>Symbol</code> .  Wenn Sie dasselbe mit <code>Natural</code> und m√∂glicherweise ein paar anderen Typen <code>Demote</code> , k√∂nnen Sie <code>Demote</code> loswerden, oder? </p><br><p>  Leider nicht so.  Oben habe ich den wichtigsten Datentyp ignoriert: Funktionen.  Sie haben auch eine spezielle <code>Demote</code> Instanz: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k1</span></span></span><span class="hljs-class"> ~&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k2</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k1 -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k2 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> a ~&gt; b = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> ab -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span></span></code> </pre> <br><p>  <code>~&gt;</code> Dies ist ein Typ, mit dem Funktionen auf Typebene in Singletons codiert werden, basierend auf privaten Typfamilien und <a href="https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/" rel="nofollow">Funktionalisierung</a> . </p><br><p>  Zun√§chst scheint es eine gute Idee zu sein, <code>~&gt;</code> und <code>-&gt;</code> zu kombinieren, da beide den Typ (Typ) der Funktion bedeuten.  Das Problem ist, dass <code>-&gt;</code> in der Typposition und <code>-&gt;</code> in der Ansichtsposition verschiedene Dinge bedeuten.  Auf der Termebene sind alle Funktionen von <code>a</code> bis <code>b</code> vom Typ <code>a -&gt; b</code> .  Auf der Typebene sind nur <em>Konstruktoren</em> von <code>a</code> bis <code>b</code> vom Typ <code>a -&gt; b</code> , aber sie sind keine Synonyme f√ºr Typen und keine Typfamilien.  Um Typen ableiten zu k√∂nnen, geht GHC davon aus, dass <code>f ~ g</code> und <code>a ~ b</code> aus <code>fa ~ gb</code> folgen, was f√ºr Konstruktoren gilt, aber nicht f√ºr Funktionen - deshalb gibt es eine Einschr√§nkung. </p><br><p>  Daher m√ºssen wir die Konstruktoren auf einen separaten Typ verschieben, um Funktionen auf die Ebene der Typen zu heben, aber um die Typinferenz beizubehalten.  Wir nennen es <code>a :-&gt; b</code> , denn es wird wirklich wahr sein, dass <code>f ~ g</code> und <code>a ~ b</code> aus <code>fa ~ gb</code> folgen.  Andere Funktionen sind weiterhin vom Typ <code>a -&gt; b</code> .  Zum Beispiel <code>Just :: a :-&gt; Maybe a</code> , aber gleichzeitig <code>isJust :: Maybe a -&gt; Bool</code> . </p><br><p>  Wenn <code>Demote</code> beendet ist, besteht der letzte Schritt darin, <code>Sing</code> selbst loszuwerden.  Dazu brauchen wir einen neuen Quantifizierer, einen Hybrid zwischen <code>forall</code> und <code>-&gt;</code> .  Schauen wir uns die isJust-Funktion genauer an: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">isJust</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isJust = \x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br><p>  Die Funktion <code>isJust</code> mit dem Typ <code>a</code> und dann mit dem Wert <code>x :: Maybe a</code> parametriert.  Diese beiden Parameter haben unterschiedliche Eigenschaften: </p><br><ul><li>  Ausdr√ºcklich.  Beim <code>isJust (Just "hello")</code> wir <code>x = Just "hello"</code> explizit, und <code>a = String</code> wird implizit vom Compiler ausgegeben.  Im modernen Haskell k√∂nnen wir auch die explizite √úbergabe beider Parameter <code>isJust @String (Just "hello")</code> : <code>isJust @String (Just "hello")</code> . </li><li>  Relevanz  Der an die Eingabe an <code>isJust</code> im Code √ºbergebene Wert wird auch w√§hrend der Ausf√ºhrung des Programms √ºbertragen: Wir f√ºhren einen Mustervergleich mit <code>case</code> , um <code>isJust</code> , dass es sich um <code>Nothing</code> oder <code>Just</code> .  Daher wird der Wert als relevant angesehen.  Der Typ wird jedoch gel√∂scht und kann nicht mit dem Muster verglichen werden: Die Funktion verarbeitet " <code>Maybe Int</code> , " <code>Maybe String</code> , " <code>Maybe Bool</code> usw.  Daher wird es als irrelevant angesehen.  Diese Eigenschaft wird auch als Parametrizit√§t bezeichnet. </li><li>  Sucht.  In <code>forall a. t</code>  <code>forall a. t</code> , Typ <code>t</code> kann sich auf <code>a</code> beziehen und h√§ngt daher von dem bestimmten bestandenen <code>a</code> .  Zum Beispiel ist <code>isJust @String</code> vom Typ <code>Maybe String -&gt; Bool</code> und <code>isJust @Int</code> vom Typ <code>Maybe Int -&gt; Bool</code> .  Dies bedeutet, dass <code>forall</code> ein abh√§ngiger Quantifizierer ist.  Beachten Sie den Unterschied zum value-Parameter: Es spielt keine Rolle, ob wir <code>isJust Nothing</code> oder <code>isJust (Just ‚Ä¶)</code> Der Ergebnistyp ist immer <code>Bool</code> .  Daher ist <code>-&gt;</code> ein unabh√§ngiger Quantifizierer. </li></ul><br><p>  Um <code>Sing</code> herauszunehmen, brauchen wir einen Quantifikator, der explizit und relevant ist, wie <code>a -&gt; b</code> und gleichzeitig abh√§ngig, wie <code>forall (a :: k). t</code>  <code>forall (a :: k). t</code> .  Bezeichne es als <code>foreach (a :: k) -&gt; t</code> .  Um <code>SingI</code> , f√ºhren wir auch einen implizit relevanten abh√§ngigen Quantor ein, <code>foreach (a :: k). t</code>  <code>foreach (a :: k). t</code> .  Infolgedessen werden <code>singletons</code> nicht ben√∂tigt, da wir der Sprache nur abh√§ngige Funktionen hinzugef√ºgt haben. </p><br><h2 id="kratkiy-vzglyad-na-haskell-s-zavisimymi-tipami">  Ein kurzer Blick auf Haskell mit abh√§ngigen Typen </h2><br><p>  Mit dem Aufstieg der Funktionen auf die Ebene der Typen und des <code>foreach</code> Quantifizierers k√∂nnen wir <code>lookupS</code> wie folgt umschreiben: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SN</span></span></span><span class="hljs-class"> len :: [a] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> len [] = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> len (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) lookupS :: foreach (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">]) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) -&gt; a lookupS [] = \case{} lookupS (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = \case </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> -&gt; x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> i' -&gt; lookupS xs i'</span></span></code> </pre> <br><p>  Kurz gesagt, der Code tat es nicht, aber <code>singletons</code> ziemlich gut darin, redundanten Code zu verstecken.  Der neue Code ist jedoch viel einfacher: Es gibt keine <code>Demote</code> , <code>SingKind</code> , <code>SList</code> , <code>SNil</code> , <code>SCons</code> <code>fromSing</code> .  <code>TemplateHaskell</code> wird nicht verwendet, da wir jetzt die <code>len</code> Funktion direkt aufrufen k√∂nnen, anstatt die <code>Len</code> <code>len</code> zu erstellen.  Die Leistung wird auch <code>fromSing</code> , da Sie keine Konvertierung von <code>fromSing</code> mehr durchf√ºhren m√ºssen. </p><br><p>  Wir m√ºssen noch die <code>length</code> als <code>len</code> neu definieren, um ein induktiv definiertes <code>N</code> anstelle von <code>Int</code> .  Vielleicht sollte dieses Problem im Rahmen des Hinzuf√ºgens abh√§ngiger Typen zu Haskell nicht ber√ºcksichtigt werden, da Agda auch ein induktiv definiertes <code>N</code> in der <code>lookup</code> verwendet. </p><br><p>  In einigen Aspekten ist Haskell mit abh√§ngigen Typen sogar einfacher als Standard-Haskell.  Dabei werden Typen und Typen zu einer einheitlichen Sprache zusammengefasst.  Ich kann mir leicht vorstellen, Code in diesem Stil in einem kommerziellen Projekt zu schreiben, um die Korrektheit der Schl√ºsselkomponenten von Anwendungen formal zu beweisen.  Viele Haskell-Bibliotheken bieten sicherere Schnittstellen ohne die Komplexit√§t von <code>singletons</code> . </p><br><p>  Dies wird nicht leicht zu erreichen sein.  Wir sind mit vielen technischen Problemen konfrontiert, die alle Komponenten des GHC betreffen: Parser, Namensaufl√∂sung, Typpr√ºfung und sogar die Kernsprache.  Alles muss modifiziert oder sogar komplett neu gestaltet werden. </p><br><hr><br><h1 id="tezaurus">  Thesaurus </h1><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>Laufzeit</strong> <br></td><td>  <strong>√úbersetzung</strong> <br></td><td>  <strong>Erkl√§rung</strong> <br></td></tr><tr><td>  baulich richtig <br></td><td> ,       <br></td><td>  ,         (,   ),   . <br></td></tr><tr><td> memory unsafe <br></td><td>      <br></td><td>         ,    . <br></td></tr><tr><td> unityped <br></td><td>  <br></td><td> ,   Bob Harper     ,    .           . <br></td></tr><tr><td> boilerplate <br></td><td>   <br></td><td>       ,    -   . <br></td></tr><tr><td> generics <br></td><td>   <br></td><td>       . ,     ¬´¬ª  ¬´¬ª,     ,    &lt;&gt;  &lt;&gt;. <br></td></tr><tr><td> runtime cast <br></td><td>     <br></td><td>              . <br></td></tr><tr><td> effectful computation <br></td><td>     <br></td><td> ,          . <br></td></tr><tr><td> composable <br></td><td>  <br></td><td>  ,          . <br></td></tr><tr><td> control structures <br></td><td> ,    <br></td><td>  ,       . <br></td></tr><tr><td> proof assistant <br></td><td>    <br></td><td>       . <br></td></tr><tr><td> strict (eager) evaluation <br></td><td>  ()  <br></td><td>   ,         . <br></td></tr><tr><td> backend <br></td><td>  <br></td><td>  ,         . <br></td></tr><tr><td> singleton type <br></td><td>   <br></td><td> ,   ,       . <br></td></tr><tr><td> promoted definitions <br></td><td>   <br></td><td>    ,         . <br></td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485174/">https://habr.com/ru/post/de485174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485158/index.html">Nikolay Vavilov. Der Mann, der die ganze Welt ern√§hren wollte und in einer Gef√§ngniszelle verhungerte</a></li>
<li><a href="../de485160/index.html">Was ist ich in ACID oder einer anderen Perspektive</a></li>
<li><a href="../de485162/index.html">Wie sich Codekommentare von den 1940ern bis 2020 entwickelten</a></li>
<li><a href="../de485164/index.html">Transformatoren und Hass in Vancouver: Wie Anti-Plagiat das NeurIPS-2019 beherrscht</a></li>
<li><a href="../de485172/index.html">Architekturprobleme in gro√üen Projekten</a></li>
<li><a href="../de485176/index.html">Sechs Konzepte zur Erl√§uterung von Produktmanagementkonzepten</a></li>
<li><a href="../de485178/index.html">Methode zur Rekonstruktion von verlorenen Geb√§uden aus Fotografien</a></li>
<li><a href="../de485180/index.html">Ben√∂tigen wir einen Datensee? Was tun mit dem Data Warehouse?</a></li>
<li><a href="../de485182/index.html">Sennheiser im Jahr 2020 - aktualisierte Funkkopfh√∂rer zum Jubil√§um</a></li>
<li><a href="../de485184/index.html">Umfrageergebnisse mit Registerkarten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>