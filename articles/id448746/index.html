<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔧 👩🏿‍🔬 👨🏼‍✈️ Indeks dalam PostgreSQL - 7 (GIN) 🚵 📿 👩🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah berkenalan dengan mesin pengindeksan PostgreSQL dan antarmuka metode akses dan membahas indeks hash , B-tree , serta indeks GiST dan SP-GiS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 7 (GIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448746/">  Kami telah berkenalan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan</a> PostgreSQL dan antarmuka metode akses dan membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks GiST</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SP-GiST</a> .  Dan artikel ini akan menampilkan indeks GIN. <br><br><h1>  Gin </h1><br>  <em>"Gin? .. Gin sepertinya, minuman keras Amerika?"</em> <em><br></em>  <em>"Aku bukan minuman, oh, bocah yang ingin tahu!"</em>  <em>Sekali lagi lelaki tua itu berkobar, lagi-lagi dia menyadari dirinya dan kembali memegang tangannya.</em>  <em>"Aku bukan minuman, tapi roh yang kuat dan tidak gentar, dan tidak ada keajaiban di dunia yang tidak akan bisa kulakukan."</em> <br>  - Lazar Lagin, "Khottabych Tua." <br><br>  <em>Gin adalah singkatan dari Generalized Inverted Index dan harus dianggap sebagai jin, bukan minuman.</em> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">README</a> <br><a name="habracut"></a><br><h2>  Konsep umum </h2><br>  GIN adalah Generated Inverted Index yang disingkat.  Ini disebut <em>indeks terbalik</em> .  Itu memanipulasi tipe data yang nilainya bukan atom, tetapi terdiri dari elemen.  Kami akan memanggil senyawa jenis ini.  Dan ini bukan nilai-nilai yang diindeks, tetapi elemen individual;  setiap elemen referensi nilai-nilai di mana itu terjadi. <br><br>  Analogi yang baik untuk metode ini adalah indeks pada akhir buku, yang untuk setiap istilah, memberikan daftar halaman tempat istilah ini muncul.  Metode akses harus memastikan pencarian cepat elemen yang diindeks, seperti halnya indeks dalam sebuah buku.  Oleh karena itu, elemen-elemen ini disimpan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree yang</a> familiar (implementasi yang berbeda, lebih sederhana, digunakan untuk itu, tetapi tidak masalah dalam kasus ini).  Rangkaian referensi yang disusun untuk baris tabel yang berisi nilai gabungan dengan elemen dihubungkan ke setiap elemen.  Ketertiban tidak penting untuk pengambilan data (urutan urutan TID tidak banyak berarti), tetapi penting untuk struktur internal indeks. <br><br>  Elemen tidak pernah dihapus dari indeks GIN.  Diperkirakan bahwa nilai-nilai yang mengandung unsur-unsur dapat menghilang, muncul, atau bervariasi, tetapi himpunan unsur-unsur yang menyusunnya kurang lebih stabil.  Solusi ini secara signifikan menyederhanakan algoritma untuk pekerjaan bersamaan dari beberapa proses dengan indeks. <br><br>  Jika daftar TUT cukup kecil, itu dapat masuk ke halaman yang sama dengan elemen (dan disebut "daftar posting").  Tetapi jika daftar itu besar, struktur data yang lebih efisien diperlukan, dan kami sudah menyadarinya - itu adalah B-tree lagi.  Pohon seperti ini terletak di halaman data terpisah (dan disebut "pohon posting"). <br><br>  Jadi, indeks GIN terdiri dari B-tree elemen, dan B-tree atau daftar datar TIDs terkait dengan baris daun B-tree itu. <br><br>  Sama seperti indeks GiST dan SP-GiST, yang dibahas sebelumnya, GIN menyediakan antarmuka aplikasi kepada pengembang untuk mendukung berbagai operasi dari tipe data majemuk. <br><br><h2>  Pencarian teks lengkap </h2><br>  Area aplikasi utama untuk metode GIN adalah mempercepat pencarian teks lengkap, yang, oleh karena itu, masuk akal untuk digunakan sebagai contoh dalam diskusi yang lebih rinci dari indeks ini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel yang terkait dengan GiST</a> telah memberikan pengantar kecil untuk pencarian teks lengkap, jadi mari kita langsung ke titik tanpa pengulangan.  Jelas bahwa nilai majemuk dalam hal ini adalah <em>dokumen</em> , dan elemen dari dokumen ini adalah <em>leksem</em> . <br><br>  Mari kita perhatikan contoh dari artikel terkait GiST: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv);</code> </pre> <br>  Struktur yang mungkin dari indeks ini ditunjukkan pada gambar: <br><br><img src="https://habrastorage.org/webt/lc/nh/m-/lcnhm-vqquxgvzpklv8kemu6z-a.png"><br><br>  Tidak seperti di semua gambar sebelumnya, referensi ke baris tabel (TIDs) dilambangkan dengan nilai numerik pada latar belakang gelap (nomor halaman dan posisi pada halaman) daripada dengan panah. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  Dalam contoh spekulatif ini, daftar TIDs masuk ke dalam halaman reguler untuk semua leksem kecuali "sheet", "slit", dan "slitter".  Leksem ini muncul di banyak dokumen, dan daftar TUT untuk mereka telah ditempatkan di pohon-B individu. <br><br>  Ngomong-ngomong, bagaimana kita bisa mengetahui berapa banyak dokumen yang mengandung leksem?  Untuk sebuah meja kecil, teknik "langsung", ditunjukkan di bawah, akan berhasil, tetapi kita akan belajar lebih lanjut apa yang harus dilakukan dengan yang lebih besar. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (unnest(doc_tsv)).lexeme, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> lexeme | count ----------+------- sheet | 9 slit | 8 slitter | 5 sit | 2 upon | 1 mani | 1 whoever | 1 sleekest | 1 good | 1 could | 1 ever | 1 (11 rows)</code> </pre><br>  Perhatikan juga bahwa tidak seperti B-tree biasa, halaman indeks GIN dihubungkan oleh daftar searah dan bukan dari dua arah.  Ini cukup karena melintasi pohon hanya dilakukan satu arah. <br><br><h3>  Contoh kueri </h3><br>  Bagaimana pertanyaan berikut akan dilakukan untuk contoh kita? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) (4 rows)</code> </pre><br>  Leksem individual (kunci pencarian) diekstraksi dari kueri terlebih dahulu: "mani" dan "slitter".  Ini dilakukan oleh fungsi API khusus yang memperhitungkan tipe data dan strategi yang ditentukan oleh kelas operator: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'tsvector_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- @@(tsvector,tsquery) | 1 matching search query @@@(tsvector,tsquery) | 2 synonym for @@ (for backward compatibility) (2 rows)</code> </pre><br>  Dalam B-tree of lexemes, kita selanjutnya menemukan kedua kunci dan pergi melalui daftar siap TUT.  Kami mendapatkan: <br><br>  untuk "mani" - (0,2). <br>  untuk "slitter" - (0,1), (0,2), (1,2), (1,3), (2,2). <br><br><img src="https://habrastorage.org/webt/mg/qc/do/mgqcdou-xlhsztvkxii5qluc5rq.png"><br><br>  Akhirnya, untuk setiap TID yang ditemukan, fungsi konsistensi API dipanggil, yang harus menentukan baris mana yang ditemukan cocok dengan permintaan pencarian.  Karena leksem dalam kueri kami bergabung dengan Boolean "dan", satu-satunya baris yang dikembalikan adalah (0,2): <br><br><pre> <code class="plaintext hljs"> | | | consistency | | | function TID | mani | slitter | slit &amp; slitter -------+------+---------+---------------- (0,1) | f | T | f (0,2) | T | T | T (1,2) | f | T | f (1,3) | f | T | f (2,2) | f | T | f</code> </pre><br>  Dan hasilnya adalah: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc --------------------------------------------- How many sheets could a sheet slitter slit? (1 row)</code> </pre><br>  Jika kita membandingkan pendekatan ini dengan yang sudah dibahas untuk GiST, keuntungan dari GIN untuk pencarian teks lengkap tampak jelas.  Tetapi ada lebih dari ini dalam memenuhi mata. <br><br><h3>  Masalah pembaruan lambat </h3><br>  Masalahnya adalah bahwa penyisipan atau pembaruan data dalam indeks GIN cukup lambat.  Setiap dokumen biasanya berisi banyak leksem untuk diindeks.  Oleh karena itu, ketika hanya satu dokumen yang ditambahkan atau diperbarui, kami harus memperbarui pohon indeks secara besar-besaran. <br><br>  Di sisi lain, jika beberapa dokumen diperbarui secara bersamaan, beberapa leksemya mungkin sama, dan jumlah total pekerjaan akan lebih kecil daripada saat memperbarui dokumen satu per satu. <br><br>  Indeks GIN memiliki parameter penyimpanan "perbaruan cepat", yang dapat kita tentukan selama pembuatan indeks dan perbarui nanti: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (fastupdate = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  Dengan diaktifkannya parameter ini, pembaruan akan diakumulasikan dalam daftar terpisah yang tidak disusun (pada setiap halaman yang terhubung).  Ketika daftar ini menjadi cukup besar atau selama vakum, semua pembaruan yang terakumulasi secara instan dibuat ke indeks.  Daftar apa yang dianggap "cukup besar" ditentukan oleh parameter konfigurasi "gin_pending_list_limit" atau oleh parameter penyimpanan nama-sama dari indeks. <br><br>  Tetapi pendekatan ini memiliki kelemahan: pertama, pencarian diperlambat (karena daftar yang tidak berurutan perlu diperiksa selain dari pohon), dan kedua, pembaruan berikutnya secara tak terduga dapat memakan banyak waktu jika daftar yang tidak berurutan telah diluap. <br><br><h3>  Cari kecocokan parsial </h3><br>  Kami dapat menggunakan kecocokan sebagian dalam pencarian teks lengkap.  Misalnya, pertimbangkan permintaan berikut: <br><br><pre> <code class="pgsql hljs">gin=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc -------------------------------------------------------- Can a sheet slitter slit sheets? How many sheets could a sheet slitter slit? I slit a sheet, a sheet I slit. Upon a slitted sheet I sit. Whoever slit the sheets is a good sheet slitter. I am a sheet slitter. I slit sheets. I am the sleekest sheet slitter that ever slit sheets. She slits the sheet she sits on. (9 rows)</code> </pre><br>  Kueri ini akan menemukan dokumen yang berisi leksem dimulai dengan "celah".  Dalam contoh ini, leksem semacam itu "slit" dan "slitter". <br><br>  Bagaimanapun, sebuah kueri pasti akan berfungsi, bahkan tanpa indeks, tetapi GIN juga mengizinkan untuk mempercepat pencarian berikut: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) (4 rows)</code> </pre><br>  Di sini semua leksem yang memiliki awalan yang ditentukan dalam permintaan pencarian dilihat di pohon dan bergabung dengan Boolean "atau". <br><br><h3>  Leksem yang sering dan jarang </h3><br>  Untuk melihat bagaimana pengindeksan bekerja pada data langsung, mari kita ambil arsip email "pgsql-hacker", yang telah kita gunakan saat membahas GiST.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi arsip ini</a> berisi 356125 pesan dengan tanggal kirim, subjek, penulis, dan teks. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv);</code> </pre><br>  Mari kita pertimbangkan leksem yang muncul di banyak dokumen.  Kueri yang menggunakan "undest" akan gagal berfungsi pada ukuran data sebesar itu, dan teknik yang benar adalah dengan menggunakan fungsi "ts_stat", yang menyediakan informasi tentang leksem, jumlah dokumen di mana mereka terjadi, dan jumlah total kejadian. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ndoc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc -------+-------- re | 322141 wrote | 231174 use | 176917 (3 rows)</code> </pre><br>  Mari kita pilih "menulis". <br><br>  Dan kami akan mengambil beberapa kata yang jarang untuk email pengembang, katakanlah, "tato": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> word = <span class="hljs-string"><span class="hljs-string">'tattoo'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc --------+------ tattoo | 2 (1 row)</code> </pre><br>  Apakah ada dokumen di mana kedua leksem ini muncul?  Tampaknya ada: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row)</code> </pre><br>  Muncul pertanyaan bagaimana melakukan kueri ini.  Jika kita mendapatkan daftar TUT untuk kedua leksem, seperti dijelaskan di atas, pencarian jelas akan tidak efisien: kita harus melewati lebih dari 200 ribu nilai, hanya satu yang tersisa.  Untungnya, menggunakan statistik perencana, algoritma memahami bahwa "menulis" leksem sering terjadi, sementara "tato" jarang terjadi.  Oleh karena itu, pencarian leksem yang jarang dilakukan, dan dua dokumen yang diambil kemudian diperiksa untuk terjadinya leksem "tulis".  Dan ini jelas dari kueri, yang dilakukan dengan cepat: <br><br><pre> <code class="pgsql hljs">fts=# \<span class="hljs-keyword"><span class="hljs-keyword">timing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row) Time: 0,959 ms</code> </pre><br>  Pencarian "wrote" saja memakan waktu lebih lama: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count -------- 231174 (1 row) Time: 2875,543 ms (00:02,876)</code> </pre><br>  Optimalisasi ini tentu saja berfungsi tidak hanya untuk dua leksem, tetapi dalam kasus yang lebih kompleks juga. <br><br><h3>  Membatasi hasil kueri </h3><br>  Fitur metode akses GIN adalah bahwa hasilnya selalu dikembalikan sebagai bitmap: metode ini tidak dapat mengembalikan hasil TID oleh TID.  Karena hal ini, semua paket kueri dalam artikel ini menggunakan pemindaian bitmap. <br><br>  Oleh karena itu, keterbatasan hasil pemindaian indeks menggunakan klausa LIMIT tidak cukup efisien.  Perhatikan perkiraan biaya operasi (bidang "biaya" pada simpul "Batas"): <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------- Limit (cost=1283.61..1285.13 rows=1) -&gt; Bitmap Heap Scan on mail_messages (cost=1283.61..209975.49 rows=137207) Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) -&gt; Bitmap Index Scan on mail_messages_tsv_idx (cost=0.00..1249.30 rows=137207) Index Cond: (tsv @@ to_tsquery('wrote'::text)) (5 rows)</code> </pre><br>  Biaya diperkirakan 1285.13, yang sedikit lebih besar dari biaya membangun seluruh bitmap 1249.30 (bidang "biaya" dari node Bitmap Index Scan). <br><br>  Oleh karena itu, indeks memiliki kemampuan khusus untuk membatasi jumlah hasil.  Nilai ambang ditentukan dalam parameter konfigurasi "gin_fuzzy_search_limit" dan sama dengan nol secara default (tidak ada batasan yang terjadi).  Tetapi kita dapat mengatur nilai ambang: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5746 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">10000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 14726 (1 row)</code> </pre><br>  Seperti yang bisa kita lihat, jumlah baris yang dikembalikan oleh query berbeda untuk nilai parameter yang berbeda (jika akses indeks digunakan).  Batasannya tidak ketat: lebih banyak baris dari yang ditentukan dapat dikembalikan, yang membenarkan bagian "fuzzy" dari nama parameter. <br><br><h3>  Representasi yang kompak </h3><br>  Di antara yang lainnya, indeks GIN bagus berkat kekompakannya.  Pertama, jika satu dan leksem yang sama muncul di beberapa dokumen (dan biasanya ini masalahnya), ia disimpan dalam indeks hanya sekali.  Kedua, TUT disimpan dalam indeks dengan cara yang teratur, dan ini memungkinkan kita untuk menggunakan kompresi sederhana: masing-masing TUT berikutnya dalam daftar sebenarnya disimpan sebagai perbedaan dari yang sebelumnya;  ini biasanya sejumlah kecil, yang membutuhkan bit lebih sedikit daripada TID 6-byte yang lengkap. <br><br>  Untuk mengetahui ukurannya, mari kita bangun B-tree dari teks pesan.  Tetapi perbandingan yang adil belum tentu akan terjadi: <br><br><ul><li>  GIN dibangun di atas tipe data yang berbeda ("tsvector" daripada "text"), yang lebih kecil, </li><li>  pada saat yang sama, ukuran pesan untuk B-tree harus dipersingkat menjadi sekitar dua kilobyte. </li></ul><br>  Namun demikian, kami terus: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages(substring(body_plain <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span>));</code> </pre><br>  Kami akan membangun indeks GiST juga: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_gist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Ukuran indeks pada "vakum penuh": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gin, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_gist'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gist, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_btree'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> btree;</code> </pre><pre> <code class="plaintext hljs"> gin | gist | btree --------+--------+-------- 179 MB | 125 MB | 546 MB (1 row)</code> </pre><br>  Karena kekompakan representasi, kita dapat mencoba menggunakan indeks GIN selama migrasi dari Oracle sebagai pengganti indeks bitmap (tanpa merinci, saya memberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi ke posting Lewis</a> untuk pikiran ingin tahu).  Sebagai aturan, indeks bitmap digunakan untuk bidang yang memiliki beberapa nilai unik, yang sangat baik juga untuk GIN.  Dan, seperti yang ditunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada artikel pertama</a> , PostgreSQL dapat membangun bitmap berdasarkan indeks apa pun, termasuk GIN, dengan cepat. <br><br><h3>  GiST atau GIN? </h3><br>  Untuk banyak tipe data, kelas operator tersedia untuk GiST dan GIN, yang menimbulkan pertanyaan indeks mana yang akan digunakan.  Mungkin, kita sudah bisa membuat beberapa kesimpulan. <br><br>  Sebagai aturan, GIN mengalahkan GiST dalam akurasi dan kecepatan pencarian.  Jika data diperbarui tidak sering dan pencarian cepat diperlukan, kemungkinan besar GIN akan menjadi pilihan. <br><br>  Di sisi lain, jika data diperbarui secara intensif, biaya overhead untuk memperbarui GIN mungkin tampak terlalu besar.  Dalam hal ini, kita harus membandingkan kedua opsi dan memilih salah satu yang karakteristiknya lebih seimbang. <br><br><h2>  Array </h2><br>  Contoh lain menggunakan GIN adalah pengindeksan array.  Dalam hal ini, elemen array masuk ke dalam indeks, yang memungkinkan untuk mempercepat sejumlah operasi melalui array: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- &amp;&amp;(anyarray,anyarray) | 1 intersection @&gt;(anyarray,anyarray) | 2 contains array &lt;@(anyarray,anyarray) | 3 contained in array =(anyarray,anyarray) | 4 equality (4 rows)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Database demo</a> kami memiliki tampilan "rute" dengan informasi tentang penerbangan.  Di antara yang lain, tampilan ini berisi kolom "days_of_week" - array hari kerja ketika penerbangan dilakukan.  Misalnya, penerbangan dari Vnukovo ke Gelendzhik berangkat pada hari Selasa, Kamis, dan Minggu: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0049'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> departure_airport_name | arrival_airport_name | days_of_week ------------------------+----------------------+-------------- Vnukovo | Gelendzhik | {2,4,7} (1 row)</code> </pre><br>  Untuk membangun indeks, mari "wujudkan" tampilan menjadi tabel: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week);</code> </pre><br><br>  Sekarang kita dapat menggunakan indeks untuk mengetahui semua penerbangan yang berangkat pada hari Selasa, Kamis, dan Minggu: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (4 rows)</code> </pre><br>  Tampaknya ada enam di antaranya: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flight_no, departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> flight_no | departure_airport_name | arrival_airport_name | days_of_week -----------+------------------------+----------------------+-------------- PG0005 | Domodedovo | Pskov | {2,4,7} PG0049 | Vnukovo | Gelendzhik | {2,4,7} PG0113 | Naryan-Mar | Domodedovo | {2,4,7} PG0249 | Domodedovo | Gelendzhik | {2,4,7} PG0449 | Stavropol | Vnukovo | {2,4,7} PG0540 | Barnaul | Vnukovo | {2,4,7} (6 rows)</code> </pre><br>  Bagaimana cara kueri ini dilakukan?  Cara yang persis sama seperti yang dijelaskan di atas: <br><br><ol><li>  Dari array {2,4,7}, yang memainkan peran permintaan pencarian di sini, elemen (kata kunci pencarian) diekstraksi.  Jelas, ini adalah nilai-nilai "2", "4", dan "7". <br></li><li>  Di pohon elemen, kunci yang diekstraksi ditemukan, dan untuk masing-masingnya daftar TUT dipilih. <br></li><li>  Dari semua TIDs yang ditemukan, fungsi konsistensi memilih yang cocok dengan operator dari kueri.  Untuk <code>=</code> operator, hanya TIDs yang cocok dengan itu yang terjadi di ketiga daftar (dengan kata lain, array awal harus berisi semua elemen).  Tetapi ini tidak cukup: array juga tidak perlu mengandung nilai lain, dan kami tidak dapat memeriksa kondisi ini dengan indeks.  Oleh karena itu, dalam hal ini, metode akses meminta mesin pengindeksan untuk memeriksa kembali semua TID yang dikembalikan dengan tabel. <br></li></ol><br>  Menariknya, ada strategi (misalnya, "terkandung dalam array") yang tidak dapat memeriksa apa pun dan harus memeriksa ulang semua TUT yang ditemukan dengan tabel. <br><br>  Tetapi apa yang harus dilakukan jika kita perlu mengetahui penerbangan yang berangkat dari Moskow pada hari Selasa, Kamis, dan Minggu?  Indeks tidak akan mendukung kondisi tambahan, yang akan masuk ke kolom "Filter". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) Filter: (departure_city = 'Moscow'::text) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (5 rows)</code> </pre><br>  Di sini ini OK (indeks hanya memilih enam baris saja), tetapi dalam kasus di mana kondisi tambahan meningkatkan kemampuan selektif, diinginkan untuk memiliki dukungan seperti itu.  Namun, kami tidak bisa hanya membuat indeks: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type text has no default operator class for access method "gin" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Tapi ekstensi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">btree_gin</a> " akan membantu, yang menambahkan kelas operator GIN yang mensimulasikan pekerjaan B-tree biasa. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gin; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) -&gt; Bitmap Index Scan on routes_t_days_of_week_departure_city_idx Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) (4 rows)</code> </pre><br><h2>  Jsonb </h2><br>  Satu lagi contoh tipe data majemuk yang memiliki dukungan GIN bawaan adalah JSON.  Untuk bekerja dengan nilai JSON, sejumlah operator dan fungsi didefinisikan saat ini, beberapa di antaranya dapat dipercepat menggunakan indeks: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opc.opcname, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> str <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'jsonb_ops'</span></span>,<span class="hljs-string"><span class="hljs-string">'jsonb_path_ops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> opcname | amopopr | str ----------------+------------------+----- jsonb_ops | ?(jsonb,text) | 9 top-level key exists jsonb_ops | ?|(jsonb,text[]) | 10 some top-level key exists jsonb_ops | ?&amp;(jsonb,text[]) | 11 all top-level keys exist jsonb_ops | @&gt;(jsonb,jsonb) | 7 JSON value is at top level jsonb_path_ops | @&gt;(jsonb,jsonb) | 7 (5 rows)</code> </pre><br>  Seperti yang dapat kita lihat, dua kelas operator tersedia: "jsonb_ops" dan "jsonb_path_ops". <br><br>  Kelas operator pertama "jsonb_ops" digunakan secara default.  Semua kunci, nilai, dan elemen array sampai ke indeks sebagai elemen dari dokumen JSON awal.  Atribut ditambahkan ke masing-masing elemen ini, yang menunjukkan apakah elemen ini adalah kunci (ini diperlukan untuk strategi "ada", yang membedakan antara kunci dan nilai). <br><br>  Misalnya, mari kita wakili beberapa baris dari "rute" sebagai JSON sebagai berikut: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_jsonb(t) route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> flight_no <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ) t; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb;</code> </pre><pre> <code class="plaintext hljs"> ctid | jsonb_pretty -------+------------------------------------------------- (0,1) | { + | "days_of_week": [ + | 1 + | ], + | "arrival_airport_name": "Surgut", + | "departure_airport_name": "Ust-Ilimsk" + | } (0,2) | { + | "days_of_week": [ + | 2 + | ], + | "arrival_airport_name": "Ust-Ilimsk", + | "departure_airport_name": "Surgut" + | } (0,3) | { + | "days_of_week": [ + | 1, + | 4 + | ], + | "arrival_airport_name": "Sochi", + | "departure_airport_name": "Ivanovo-Yuzhnyi"+ | } (0,4) | { + | "days_of_week": [ + | 2, + | 5 + | ], + | "arrival_airport_name": "Ivanovo-Yuzhnyi", + | "departure_airport_name": "Sochi" + | } (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(route);</code> </pre><br><br>  Indeks mungkin terlihat sebagai berikut: <br><br><img src="https://habrastorage.org/webt/oo/yi/x3/ooyix34gx7mrpiwdcol3a3ewnwu.png"><br><br>  Sekarang, kueri seperti ini, misalnya, dapat dilakukan menggunakan indeks: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------- Bitmap Heap Scan on routes_jsonb Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) -&gt; Bitmap Index Scan on routes_jsonb_route_idx Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) (4 rows)</code> </pre><br>  Dimulai dengan akar dokumen JSON, <code>@&gt;</code> operator memeriksa apakah rute yang ditentukan ( <code>"days_of_week": [5]</code> ) terjadi.  Di sini kueri akan mengembalikan satu baris: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> jsonb_pretty ------------------------------------------------ { + "days_of_week": [ + 2, + 5 + ], + "arrival_airport_name": "Ivanovo-Yuzhnyi",+ "departure_airport_name": "Sochi" + } (1 row)</code> </pre><br>  Permintaan dilakukan sebagai berikut: <br><br><ol><li>  Dalam kueri pencarian ( <code>"days_of_week": [5]</code> ) elemen (kunci pencarian) diekstraksi: "days_of_week" dan "5". <br></li><li>  Di pohon elemen kunci yang diekstraksi ditemukan, dan untuk masing-masing daftar TIDs dipilih: untuk "5" - (0,4), dan untuk "days_of_week" - (0,1), (0,2) ), (0,3), (0,4). <br></li><li>  Dari semua TIDs yang ditemukan, fungsi konsistensi memilih yang cocok dengan operator dari kueri.  Untuk operator <code>@&gt;</code> , dokumen yang mengandung tidak semua elemen dari permintaan pencarian tidak akan memastikan, sehingga hanya (0,4) yang tersisa.  Tetapi kita masih perlu memeriksa kembali TID yang tersisa dengan tabel karena tidak jelas dari indeks dalam urutan apa elemen yang ditemukan terjadi dalam dokumen JSON. <br></li></ol><br>  Untuk menemukan rincian lebih lanjut dari operator lain, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br>  Selain operasi konvensional untuk berurusan dengan JSON, ekstensi "jsquery" telah lama tersedia, yang mendefinisikan bahasa permintaan dengan kemampuan yang lebih kaya (dan tentu saja, dengan dukungan indeks GIN).  Selain itu, pada tahun 2016, standar SQL baru dikeluarkan, yang mendefinisikan set operasi sendiri dan bahasa query "SQL / JSON path".  Implementasi standar ini telah selesai, dan kami yakin ini akan muncul di PostgreSQL 11. <br><br><blockquote>  Patch path SQL / JSON akhirnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berkomitmen</a> untuk PostgreSQL 12, sementara bagian lainnya masih dalam perjalanan.  Semoga kita akan melihat fitur yang sepenuhnya diimplementasikan di PostgreSQL 13. <br></blockquote><br><h2>  Internal </h2><br>  Kita dapat melihat ke dalam indeks GIN menggunakan ekstensi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pageinspect</a> ". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Informasi dari halaman meta menunjukkan statistik umum: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+----------- pending_head | 4294967295 pending_tail | 4294967295 tail_free_size | 0 n_pending_pages | 0 n_pending_tuples | 0 n_total_pages | 22968 n_entry_pages | 13751 n_data_pages | 9216 n_entries | 1423598 version | 2</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur halaman</a> menyediakan area khusus tempat metode akses menyimpan informasinya;  area ini "buram" untuk program biasa seperti ruang hampa udara.  Fungsi "Gin_page_opaque_info" menunjukkan data ini untuk GIN.  Sebagai contoh, kita bisa mengetahui kumpulan halaman indeks: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flags, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">22967</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g(id), <span class="hljs-comment"><span class="hljs-comment">-- n_total_pages gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) group by flags;</span></span></code> </pre><pre> <code class="plaintext hljs"> flags | count ------------------------+------- {meta} | 1 meta page {} | 133 internal page of element B-tree {leaf} | 13618 leaf page of element B-tree {data} | 1497 internal page of TID B-tree {data,leaf,compressed} | 7719 leaf page of TID B-tree (5 rows)</code> </pre><br>  Fungsi "Gin_leafpage_items" memberikan informasi tentang TUT yang disimpan di halaman {data, leaf, compressed}: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_leafpage_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">2672</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------------------------------------------------------------- first_tid | (239,44) nbytes | 248 tids | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... -[ RECORD 2 ]--------------------------------------------------------------------- first_tid | (247,40) nbytes | 248 tids | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... ...</code> </pre><br>  Perhatikan di sini bahwa meninggalkan halaman-halaman pohon TIDs sebenarnya mengandung daftar kecil dari pointer ke baris tabel daripada pointer individual. <br><br><h2>  Properti </h2><br>  Mari kita lihat sifat-sifat metode akses GIN (pertanyaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah disediakan</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gin | can_order | f gin | can_unique | f gin | can_multi_col | t gin | can_exclude | f</code> </pre><br>  Menariknya, GIN mendukung pembuatan indeks multikolom.  Namun, tidak seperti untuk B-tree biasa, alih-alih kunci majemuk, indeks multikolom masih akan menyimpan elemen individu, dan nomor kolom akan diindikasikan untuk setiap elemen. <br><br>  Properti lapisan indeks berikut tersedia: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Perhatikan bahwa mengembalikan hasil TID dengan TID (pemindaian indeks) tidak didukung;  hanya pemindaian bitmap yang dimungkinkan. <br><br>  Pemindaian mundur juga tidak didukung: fitur ini penting untuk pemindaian indeks saja, tetapi tidak untuk pemindaian bitmap. <br><br>  Dan berikut ini adalah properti layer-layer: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Tidak ada yang tersedia di sini: tidak ada penyortiran (yang jelas), tidak ada penggunaan indeks sebagai penutup (karena dokumen itu sendiri tidak disimpan dalam indeks), tidak ada manipulasi NULLs (karena tidak masuk akal untuk elemen tipe senyawa) . <br><br><h2>  Tipe data lainnya </h2><br>  Beberapa ekstensi lagi tersedia yang menambahkan dukungan GIN untuk beberapa tipe data. <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_trgm</a> " memungkinkan kita untuk menentukan "persamaan" kata-kata dengan membandingkan berapa banyak urutan tiga huruf (trigram) yang tersedia.  Dua kelas operator ditambahkan, "gist_trgm_ops" dan "gin_trgm_ops", yang mendukung berbagai operator, termasuk perbandingan melalui LIKE dan ekspresi reguler.  Kita dapat menggunakan ekstensi ini bersama dengan pencarian teks lengkap untuk menyarankan opsi kata untuk memperbaiki kesalahan ketik. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hstore</a> " mengimplementasikan penyimpanan "nilai kunci".  Untuk tipe data ini, kelas operator untuk berbagai metode akses tersedia, termasuk GIN.  Namun, dengan diperkenalkannya tipe data "jsonb", tidak ada alasan khusus untuk menggunakan "hstore". <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intarray</a> " memperluas fungsi array integer.  Dukungan indeks termasuk GiST, dan juga GIN ("gin__int_ops" kelas operator). <br></li></ul><br>  Dan dua ekstensi ini telah disebutkan di atas: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">btree_gin</a> " menambahkan dukungan GIN untuk tipe data reguler agar dapat digunakan dalam indeks multikolom bersama dengan tipe majemuk. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsquery</a> " mendefinisikan bahasa untuk kueri JSON dan kelas operator untuk dukungan indeks bahasa ini.  Ekstensi ini tidak termasuk dalam pengiriman PostgreSQL standar. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448746/">https://habr.com/ru/post/id448746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448734/index.html">Drone dan robot membantu menyelamatkan Katedral Paris Notre Dame</a></li>
<li><a href="../id448738/index.html">Siapa yang memburu startup?</a></li>
<li><a href="../id448740/index.html">Kami mendengarkan musik SID (Commodore 64) melalui OPL3 pada PC modern</a></li>
<li><a href="../id448742/index.html">Kotak Pandora: kami menganalisis eksploitasi kerentanan WinRAR menggunakan contoh pekerjaan NeoQUEST-2019</a></li>
<li><a href="../id448744/index.html">Bagaimana cara mentransfer variabel dari fragmen ke aktivitas di Android?</a></li>
<li><a href="../id448750/index.html">Tentang satu kerentanan yang tidak</a></li>
<li><a href="../id448756/index.html">Latar belakang: mengapa Apple dan Qualcomm bertengkar, dan kemudian berdamai</a></li>
<li><a href="../id448758/index.html">Jam tangan pintar dengan BASIC pada fisik 6502</a></li>
<li><a href="../id448760/index.html">Pengembangan di cloud, keamanan informasi dan data pribadi: intisari untuk dibaca pada akhir pekan dari 1cloud</a></li>
<li><a href="../id448762/index.html">Kerusuhan di Picaba. Pengguna secara besar-besaran pergi ke Reddit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>