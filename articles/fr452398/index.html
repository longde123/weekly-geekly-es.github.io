<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÅ üé∫ üë∂üèª EFORTH pour calculatrice programmable üëµ ü•Å ‚ÜîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceci est le premier article de la s√©rie 161eForth v0.5b, se terminant ici: habr.com/en/post/452572 

 Le traducteur EFORTH est maintenant √©galement su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH pour calculatrice programmable</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452398/">  <i>Ceci est le premier article de la s√©rie 161eForth v0.5b, se terminant ici:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/en/post/452572</a> <br><br>  Le traducteur EFORTH est maintenant √©galement sur la calculatrice domestique MK-161 Electronics!  Le 17 mai, la version v0.5b a r√©ussi mes tests, ainsi que cinq tests de cr√©ation TEST-TEST4.  J'ai r√©alis√© ce qui peut √™tre fait seul, mais je pense que ce n'est que la moiti√© de la bataille.  Il est temps de pr√©senter un nouvel outil √† la communaut√© en ouvrant le code 161eForth pour les tests publics.  J'ai une liste de ce qu'il faut am√©liorer et o√π ¬´travailler sur la stabilit√©¬ª.  Vos suggestions et commentaires seront pris en compte lors de l'ach√®vement du travail et de la version 1.0 <br><br>  Lors du portage de la derni√®re version d'eForth sur la plate-forme nationale, deux obstacles ont √©t√© surmont√©s avec succ√®s - la vitesse relativement faible de la machine 8 bits, qui est programm√©e dans son propre langage d'entr√©e, et la modeste quantit√© de m√©moire binaire disponible (voir 2.4.1), seulement 4096 octets. <br><img src="https://habrastorage.org/webt/lx/76/pw/lx76pw2yfjmfnqz4wxg9pp_m6ya.jpeg"><br><a name="habracut"></a><br>  Lors de l'√©criture de 161eForth, des solutions toutes faites pr√©par√©es pour Callisto, le langage d'entr√©e de nouvelle g√©n√©ration pour les PMK domestiques, ont √©t√© utilis√©es.  Il s'agit d'une technologie pour impl√©menter une machine fort au-dessus de l'ALU d√©cimal et de l'architecture ¬´Harvard¬ª, des pilotes de console et une disposition de clavier alphanum√©rique, ainsi qu'un terminal logiciel bas√© sur eux, fonctionnant via le port s√©rie RS-232.  En plus de l'√©lectronique MK-161 et de la distribution 161eForth, vous aurez peut-√™tre besoin d'un clavier patch fait maison o√π les lettres des alphabets russe et anglais sont sign√©es sur les touches.  Les lettres sont class√©es alphab√©tiquement ligne par ligne, de gauche √† droite et de haut en bas. <br><img src="https://habrastorage.org/webt/ff/pu/ry/ffpury7pflujlbysn28jipoylgg.png"><br><br>  Le Dr Chen-Hanson Ting, auteur de versions modernes d'eForth, souligne dans son livre [1] l'importance de comprendre les deux composantes du fort.  Il s'agit d'un interpr√®te interne ("adresse") qui permet √† l'√©quipement d'ex√©cuter le code cousu de Fort, et d'un interpr√®te externe ("texte") responsable du dialogue avec une personne. <br><br>  Dans deux articles, je m'attarderai en d√©tail sur les solutions les plus radicales utilis√©es dans la mise en ≈ìuvre de chacun de ces deux interpr√®tes chez Electronics.  L'apprentissage de ces solutions peut √™tre utile et inspirant pour migrer eForth vers d'autres appareils avec une m√©moire et des performances limit√©es.  La compr√©hension des articles aidera √† une introduction initiale aux microcalculateurs programmables (PMC) et √† Fort.  Je vais vous expliquer les moments difficiles propres √† Electronics MK et au traducteur eForth. <br><br>  Pour commencer, les mots eForth sont divis√©s en g√©n√©ral et syst√©mique.  <b>La taille des lettres est importante.</b>  <b>Les noms des mots ordinaires sont d√©finis en lettres majuscules et en minuscules syst√®me.</b>  J'ai √©galement fait mes innovations dans eForth en minuscules.  L'auteur d'eForth sugg√®re de mener le dialogue principal en mode CAPS.  Lorsque vous devez utiliser le mot syst√®me, changez l'heure en lettres minuscules (combinaison de touches FP). <br><br>  Dans l'article, tous les mots sont √©crits en majuscules pour se d√©marquer du texte.  Dans plusieurs premi√®res impl√©mentations eForth, les en-t√™tes de mots syst√®me ont √©t√© exclus et non √©mis par la commande WORDS.  Cela a contribu√© √† simplifier l'apparence d'eForth et √† attirer l'attention de ceux qui utilisent Fort pour la premi√®re fois.  Dans 161eForth, les titres de ces mots ont √©t√© enregistr√©s principalement en raison de la pr√©sence du d√©compilateur de mots deux points SEE (voir la vid√©o n ¬∞ 3 √† la fin de l'article), qui n'affichera pas les noms des mots syst√®me si leurs titres sont supprim√©s. <br><br>  Pour rationaliser l'article et le rendre utile comme r√©f√©rence, j'ai d√ª utiliser plusieurs termes avant de les d√©finir.  Les professionnels de Fort et PMK doivent √™tre familiaris√©s avec ces termes.  Les d√©butants doivent parfois regarder dans les sections voisines (j'ai mis les liens aux bons endroits) ou relire l'article plusieurs fois. <br><br>  161eForth lui-m√™me est pr√©sent√© ici, avec le texte source, un clavier graphique √† l'√©cran et l'aide words.txt avec une description de tous les mots impl√©ment√©s: <a href="">http://the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  J'ai √©galement post√© 5 petites vid√©os sur YouTube illustrant le fonctionnement du 161eForth pour ceux qui n'ont pas le MK-161.  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regarder l'int√©gralit√© de la playlist sur YouTube</a> .  Ci-dessous est le premier d'entre eux, les 4 restants √† la fin de l'article. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RxarUWHdNTE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  eForth et sa mise en ≈ìuvre </h2><br>  eForth a √©t√© con√ßu comme un remplacement moderne du traducteur fig-Fort tr√®s connu.  Pour passer au MK-161, j'ai choisi une version 32 bits 5.2 du traducteur 86eForth avec code cousu indirect, √©crite en 2016 sur l'assembleur MASM pour le syst√®me d'exploitation Windows.  Cette version est d√©crite en d√©tail dans la troisi√®me √©dition d'eForth et Zen [1].  Ceux qui connaissent l'anglais, je vous conseille de trouver et d'√©tudier ce livre, il est tr√®s utile pour comprendre 161eForth. <br><br>  Dans une lettre personnelle, l'auteur a confirm√© que 86eForth502.asm de ce livre est la derni√®re version d'eForth.  Sur Internet, vous pouvez trouver de nombreuses informations en anglais √† ce sujet et sur les versions pr√©c√©dentes d'eForth. <br><br>  Le d√©veloppement d'eForth a suivi une voie scientifique enseign√©e par le professeur Wirth en utilisant l'exemple de son langage de programmation Oberon.  Chaque version ult√©rieure d'eForth √©tait une simplification de la version pr√©c√©dente.  Tout ce qui peut √™tre dispens√© a √©t√© retir√© de la langue.  Il reste un ensemble soigneusement pens√© de constructions langagi√®res fortes et expressives, dont la puissance a √©t√© test√©e sur plus de 40 impl√©mentations eForth pour diverses plates-formes.  Maintenant sur la calculatrice! <br><br>  √âtant un dialecte minimaliste de Fort, eForth n'a pas pour objectif de gagner la course contre le plus petit Fort.  L'ensemble de mots qu'il propose est assez pratique et peut facilement √™tre √©tendu par le programmeur dans le sens n√©cessaire √† ses t√¢ches. <br><br>  La premi√®re version d'eForth a √©t√© publi√©e en 1990 dans l'assembleur MASM pour les processeurs 8086 et fonctionnait sous MS-DOS.  Il contenait 31 mots de base d√©pendant de la machine et 191 mots de haut niveau.  L'id√©e √©tait simple: vous ne traduisez que 31 mots dans votre assembleur et obtenez imm√©diatement eForth sur votre ordinateur. <br><br>  Cette approche a √©t√© critiqu√©e sur Internet, car la fa√ßon de minimiser le nombre de mots dans l'assembleur a conduit √† des performances extr√™mement faibles pour les syst√®mes embarqu√©s.  D√©j√† dans la deuxi√®me version d'eForth, le nombre maximum de mots a commenc√© √† √™tre impl√©ment√© dans l'assembleur, ce qui a redirig√© l'inclinaison vers non seulement un portable facilement, mais aussi un syst√®me de programmation pratique. <br><br>  Pendant plusieurs ann√©es, Bill Munch, l'auteur original d'eForth, et son coll√®gue le Dr Chen-Hanson Ting ont publi√© leurs versions eForth en parall√®le.  Chaque version avait ses propres caract√©ristiques.  Les options eForth pour diff√©rentes plates-formes ont √©galement √©t√© int√©gr√©es par d'autres programmeurs. <br><br>  La version 5.2, publi√©e en 2016, contient 71 mots de ¬´code¬ª et 110 mots de ¬´deux points¬ª.  Un quart de si√®cle de recherche de l'id√©al a permis de r√©duire consid√©rablement le nombre total de mots.  Dans le m√™me temps, pour des raisons de performances, le pourcentage de mots mis en ≈ìuvre √† un faible niveau a augment√©. <br><br>  Le 161eForth propos√© b√©n√©ficie des avantages g√©n√©reux de ces progr√®s, mais ne pr√©tend pas d√©velopper davantage la ligne principale.  Mon impl√©mentation fournit au programmeur tous les outils pr√©sents dans la version 5.2.  Lorsque l'architecture MK-161 rend l'impl√©mentation de certains mots 86eForth impossible ou vide de sens, au lieu de jeter l'exc√©dent, je donne aux programmeurs un remplacement complet, en le prenant de la norme ANSI / ISO [4].  Ceux qui recherchent le minimalisme peuvent ind√©pendamment jeter des mots ¬´suppl√©mentaires¬ª, car par tradition 161eForth est livr√© avec du code source. <br><br>  Lors de la mise en ≈ìuvre d'eForth, j'ai adh√©r√© √† la compr√©hension de l'auteur.  Par exemple, √† mon avis, une boucle FOR NEXT avec une valeur initiale de n devrait s'ex√©cuter exactement n fois.  La m√™me conclusion est finalement arriv√©e √† Chuck Moore, l'auteur des langues Forth et colorForth.  Malheureusement, eForth utilise une convention obsol√®te et ex√©cute un tel cycle n + 1 fois, avec un compteur de n √† 0. Je n'ai pas corrig√© cela et plusieurs autres lacunes, pr√©f√©rant la compatibilit√© de 161eForth avec les impl√©mentations pour d'autres plates-formes. <br><br>  √âtant donn√© que 161eForth est le premier syst√®me de programmation embarqu√© pratique pour l'√©lectronique MK-161, √† l'exception de la langue d'usine, j'ai retrac√© la longue histoire d'eForth et j'ai renvoy√© quelques mots √† la langue qui √©tait utile sur d'autres plates-formes et qui peut √™tre demand√©e maintenant. <br><br>  Par exemple, la nouvelle ancienne variable 'BOOT contient le jeton (voir 3.1) du mot, qui est ex√©cut√© d'abord apr√®s l'initialisation de l'environnement, mais avant le d√©but du dialogue.  Par d√©faut, 'BOOT contient un jeton TLOAD pour interpr√©ter le code de la "zone de texte" (voir 2.4.2).  Cela permet au programmeur de personnaliser eForth pour lui-m√™me sans recompiler l'environnement, ce qui est toujours impossible √† produire √† bord de l '¬´√©lectronique¬ª. <br><br>  Les t√¢ches prioritaires de l'impl√©mentation √©taient la sauvegarde de la m√©moire binaire (voir 2.4.1) et l'am√©lioration des performances.  Leur solution a entra√Æn√© une diminution spectaculaire du nombre de mots de haut niveau, car leur code occupe cette pr√©cieuse m√©moire, en raison d'une augmentation du nombre de mots de base rapides impl√©ment√©s dans la m√©moire de programme bon march√© (voir 2.4.3). <br><br>  Par cons√©quent, 161eForth contient 129 mots de code, 78 mots de haut niveau et occupe 1816 octets de m√©moire binaire MK-161, soit moins de la moiti√©.  Cela donne de l'espoir pour la m√©tacompilation de sa partie de haut niveau directement √† bord de l'√©lectronique. <br><br>  Le code source de l'eForth MK-161 est divis√© en deux grandes parties.  Le noyau √©crit dans le syst√®me de commande MK-161 est contenu dans le fichier eForth0.mkl.  Les mots de haut niveau sont d√©finis dans SP-Forth et plac√©s dans le fichier eForth.f. <br><br>  La distribution a √©galement un fichier d'aide words.txt, qui documente tous les mots 161eForth avec la notation de pile et une br√®ve explication, en une seule ligne. <br><br><h3>  1.1 Le code source du noyau eForth0.mkl </h3><br>  Le noyau eForth contient du code ex√©cutable op√©rant dans la m√©moire des programmes MK-161 (voir 2.4.3), qui est compil√© sur un ordinateur dans le fichier eForth0.mkp par des moyens standard, par exemple, le compilateur propri√©taire MKL2MKP. <br><br>  Le code source du noyau contenu dans le fichier eForth0.mkl est √©crit en <i>mn√©moniques latins</i> .  Par exemple, une commande IPE pour lire le registre E (aka R14) est √©crite dans ce mn√©monique comme RME.  √âtant inhabituel pour les propri√©taires de PMK sovi√©tique, les mn√©moniques latins sont pratiques pour taper √† partir d'un clavier d'ordinateur.  En effet, il est plus facile de taper des FX ^ 2 bizarres que des Fx¬≤ familiers. <br><br>  Le fichier eForth0.mkp est un pr√©r√©glage du noyau.  En plus du code des primitives, il contient un en-t√™te de noyau et une table de noms tblNames, que eForth.f transf√®re lors du d√©codage vers des registres d√©cimaux (voir 2.4.4).  C'est sur la base de eForth0.mkp que le noyau eForth.mkp sera cr√©√© (voir 2.4.3), donc eForth0.mkl doit d'abord √™tre compil√©. <br><br><h3>  1.2 Code source des mots de haut niveau eForth.f </h3><br>  Le fichier eForth.f est aliment√© √† l'entr√©e du merveilleux compilateur domestique SP-Forth [5].  Le fichier contient les d√©finitions de tous les mots de haut niveau.  Au fil du temps, ils peuvent √™tre identifi√©s sur l'eForth lui-m√™me et √©ventuellement compil√©s directement √† bord de l'√©lectronique MK-161. <br><br>  Pendant la compilation, eForth.f lit le noyau vierge eForth0.mkp et avec son aide cr√©e trois fichiers dans le r√©pertoire courant pour un chargement ult√©rieur dans MK-161: eForth.mkp, eForth.mkd et eForth.mkb.  C'est eForth.mkb qui contient les corps des mots de haut niveau, bien que leurs en-t√™tes se trouvent dans le fichier eForth.mkd. <br><br>  Le quatri√®me fichier, eForth.mkt, est √©crit manuellement dans eForth et peut √™tre modifi√© √† bord du MK-161 √† l'aide de l'√©diteur de texte int√©gr√©.  J'analyserai chacun de ces quatre fichiers plus en d√©tail ci-dessous (voir 2.4). <br><br><h2>  2. √âlectronique MK-161 </h2><br>  Un fabricant de Novossibirsk appelle le MK-161 un vieil acronyme.  C'√©tait le nom des toutes premi√®res calculatrices de l'URSS.  Le syst√®me d'instruction MK-161 h√©rite du syst√®me de commande des calculatrices sovi√©tiques "Electronics B3-34" et "Electronics MK-61".  Cela signifie que les programmes √©crits pour les calculatrices sovi√©tiques iront sur le MK-161 sans changements ou avec des changements mineurs. <br><br>  L'inverse n'est pas vrai.  eForth n'ira pas au PMK sovi√©tique, car  utilise beaucoup de ressources qui sont apparues pour la premi√®re fois dans le MK-152/161 et n'√©taient pas disponibles dans les mod√®les pr√©c√©dents de la s√©rie. <br><br>  Consid√©rez les caract√©ristiques du langage d'entr√©e et de l'architecture du MK-161, qui ont influenc√© 161eForth (ci-apr√®s simplement eForth) et ont donn√© √† la mise en ≈ìuvre discut√©e d'eForth un "accent russe". <br><br>  La premi√®re de ces caract√©ristiques est l' <b>accord ¬´senior at junior address¬ª, qui</b> est syst√©matiquement maintenu dans MK-161.  Par exemple, le nombre 1000 = 3 √ó 256 + 232 sera √©crit sur deux octets cons√©cutifs, comme 3 et 232. <br><br><h3>  2.1 Adressage indirect </h3><br>  Programmation Le PMK sovi√©tique a entendu parler de l'adressage indirect.  Pour <i>l'adressage direct,</i> nous indiquons explicitement le num√©ro de registre auquel nous nous r√©f√©rons.  Par exemple, P IP 44 consid√®re le contenu du registre 44. La cl√© P qui est apparue dans MK-152 est utilis√©e pour acc√©der aux registres avec le num√©ro 15 ou plus - ces registres √©taient absents dans la PMK sovi√©tique. <br><br>  En <i>adressage indirect, le</i> num√©ro du registre requis n'est pas connu √† l'avance.  Ce num√©ro est dans un registre diff√©rent.  Par exemple, si le registre 8 contient le num√©ro 44, la commande K PI 8 consid√®re le contenu du registre 44 (R44). <br><br>  Les touches K et P peuvent √™tre combin√©es.  Par exemple, la commande R K BP 20 transf√©rera le contr√¥le (GOTO en mn√©moniques latins) √† l'adresse stock√©e dans R20. <br><br>  La caract√©ristique qui s'est av√©r√©e importante pour l'interpr√®te eForth interne est li√©e √† l'augmentation / diminution pr√©liminaire des registres lors de l'adressage indirect.  Cette fonctionnalit√© est h√©rit√©e du PMK sovi√©tique. <br><br>  Par exemple, les commandes de lecture indirecte KI 0, KI 1, KI 2 et KI 3 r√©duisent de un le contenu des registres 0, 1, 2 ou 3 au registre souhait√©. Les commandes KI 4, KI 5 et KI 6 avant de lire, augmentez le contenu des registres 4, 5 ou 6 d'une unit√©. <br><br>  Cette ¬´modification¬ª du registre d'adresses vous permet de traiter des groupes entiers de registres en boucle.  Il est similaire √† ++ R et --R en C.  Le num√©ro de registre du registre est important.  C'est lui qui d√©termine s'il va augmenter (registres 4-6) ou diminuer (registres 0-3) avec adressage indirect. <br><br>  L'architecture 161eForth a √©t√© affect√©e par le fait que l'augmentation des registres 4-6 √† adressage indirect est <i>pr√©liminaire</i> .  Par cons√©quent, le pointeur d'interpr√©tation (IP) situ√© dans R6 <i>pointe</i> toujours <i>vers le dernier octet du</i> code cousu.  Dans 86eForth, IP indique toujours un octet suivant qui n'a pas encore √©t√© lu. <br><br>  Cela est √©galement vrai pour le pointeur de pile de retour (RP) stock√© dans le registre 2. R2 pointe toujours vers le haut de la pile de retour. <br><br>  Une caract√©ristique utile du MK-161 est l'absence d'augmentation / diminution du registre si un adressage indirect se produit avec la nouvelle cl√© R. Par exemple, RKIP02 compte le nombre du haut de la pile de retour sans changer le pointeur.  Il s'agit d'une √©quipe Fort R @ pr√™te √† l'emploi.  De ce qui pr√©c√®de, il s'ensuit que la valeur lue est inf√©rieure de un √† l'adresse du jeton suivant, qui sera ex√©cut√©e apr√®s le retour du mot "deux points". <br><br>  Lorsque vous devez d√©velopper ou √©tudier des mots qui interagissent √©troitement avec l'interpr√®te interne eForth, assurez-vous de bien comprendre ce point subtil associ√© √† l' <b>exag√©ration</b> . <br><br><h3>  2.2 Tableaux, ordonn√©s et associatifs </h3><br>  Les tables MK-161 sont situ√©es dans la m√©moire du programme (voir 2.4.3).  Ils sont apparus dans le "Electronics MK" de Novossibirsk et sont totalement inconnus des experts du PMK sovi√©tique.  L'adresse de la table utilis√©e est toujours stock√©e dans le registre 9042, mais leur acc√®s est diff√©rent. <br><br>  <i>Une table ordonn√©e</i> est un tableau d'entiers 16 bits non sign√©s.  eForth contient une telle table tblTokens avec les adresses des primitives (voir 3.1.1) - Mots forts √©crits dans le syst√®me de commande MK-161.  L'interpr√©teur d'adresses (voir 3.2) utilise tblTokens pour ex√©cuter rapidement le code cousu, eForth essaie donc de toujours contenir l'adresse de cette table dans R9042. <br><br>  Pour acc√©der √† une table command√©e, vous devez √©crire le num√©ro de l'article souhait√© dans R9210.  Le nombre n dans le registre X sera remplac√© par la valeur de l'√©l√©ment de table par le nombre n, le d√©compte part de z√©ro. <br><br>  <i>Les tableaux associatifs</i> ("recherche par valeur") sont activement utilis√©s par eForth, principalement par la primitive (FIND), √† la recherche d'un mot par son nom.  De plus, la table associative tblCHPUT est utilis√©e lors de l'impression de lettres √† l'√©cran pour traiter les sauts de ligne et autres codes de contr√¥le. <br><br>  Pour rechercher l'√©l√©ment n dans le tableau associatif, √©crivez n √† R9212.  Le nombre n dans le registre X (la direction l'appelle l '¬´index¬ª) sera remplac√© par la valeur de 16 bits enregistr√©e dans le tableau imm√©diatement apr√®s son ¬´index¬ª n. <br><br>  La pr√©sence de cette fonction de recherche rapide, quoique simple, impl√©ment√©e en langage assembleur dans le ¬´firmware¬ª MK-161 a aid√© eForth √† obtenir des performances acceptables lors de la reconnaissance des noms de mots et de la compilation des programmes.  Bien s√ªr, pour cela, j'ai d√ª d√©velopper non pas les tables de reconnaissance de noms les plus simples, ¬´aff√ªt√©es¬ª pour cette fonction.  Nous en parlerons plus en d√©tail dans le deuxi√®me article. <br><br><h3>  2.3 Interruptions et console </h3><br>  ¬´MK Electronics¬ª permet √† ses propri√©taires d'√©crire des programmes dans la langue d'entr√©e qui r√©pondent √† certains √©v√©nements - comme appuyer ou rel√¢cher un bouton, mettre fin au d√©compte de la minuterie. <br><br>  eForth utilise activement ce <i>syst√®me d'interruption</i> pour l'entr√©e au clavier et l'affichage du curseur clignotant lorsque vous y √™tes invit√©, et pour l'entr√©e / sortie via un port s√©rie universel (RS-232). <br><br>  Les lettres saisies √† partir du clavier sont mises en file d'attente bufKbd lorsque vous appuyez sur les touches.  Ceci est tr√®s pratique et permet de gagner du temps sur les syst√®mes √† faible vitesse.  Le changement d'alphabet et de cas est g√©r√© par l'interruption KeyPress et ne prend pas d'espace dans la file d'attente.  Un appui long sur la touche appelle la r√©p√©tition automatique. <br><br>  Lorsque la ligne de 8 lettres est pleine et que eForth n'est pas encore pr√™t √† traiter l'entr√©e (la situation est tr√®s rare), le MK-161 √©met un grincement malheureux.  Bien s√ªr, je ne voudrais pas impl√©menter tout ce travail naturel du clavier dans le traducteur, mais obtenir le MK-161 ¬´pr√™t √† l'emploi¬ª en tant que service du programme int√©gr√© (firmware).  Mais ce qui, comme on dit, est riche. <br><br>  Apr√®s le d√©but du travail, toutes les sorties eForth sont dirig√©es vers <i>l'√©cran graphique</i> MK-161.  La sortie des lettres dessus est effectu√©e par une routine relativement simple de la CNCut.  La seule difficult√© ici est l'impl√©mentation du code de contr√¥le BS, le ¬´space back¬ª.  MK-161 utilise une police proportionnelle.  Par cons√©quent, dans un tampon sp√©cial tblBS, vous devez vous rappeler les positions des caract√®res affich√©s, d'o√π le code de sortie BS les prend plus tard. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant le dialogue, l'utilisateur peut utiliser le mot IO&gt; pour rediriger toutes les E / S vers le port s√©rie RS-232, ce qui permet de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programmer le MK-161 √† partir d'un clavier d'ordinateur familier ou d'un autre MK-161</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le mot CON&gt; renvoie le contr√¥le √† la console de calcul.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4 Zones de m√©moire et installation d'eForth sur le MK-161 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©moire ¬´MK-161 Electronics¬ª se compose d'une m√©moire de programme adressable s√©par√©ment et d'une m√©moire de registre de donn√©es. √Ä son tour, la m√©moire de registre est h√©t√©rog√®ne et est divis√©e en trois grandes zones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les registres avec des nombres de 0 √† 999 stockent des "nombres d√©cimaux". Ce sont des registres ordinaires, comme dans "Electronics B3-34" et autres calculatrices. Ils sont simplement capables de stocker non pas 8, mais 12 d√©cimales de la ¬´mantisse¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les registres avec des nombres de 1000 √† 8167 stockent des entiers de 0 √† 255. Les 3 derniers kilo-octets de cette zone avec des adresses de 5096 √† 8167 sont appel√©s </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la zone de texte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les registres avec des nombres de 9000 √† 9999 sont appel√©s </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registres de fonction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette zone de service de l'espace d'adressage ressemble aux ports d'E / S du microprocesseur. </font><font style="vertical-align: inherit;">√Ä l'aide de commandes d'√©criture et de lecture, ces adresses sont utilis√©es pour acc√©der aux p√©riph√©riques d'E / S, aux syst√®mes d'interruption, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour installer eForth sur "Electronics MK-161", il suffit de transf√©rer quatre fichiers vers la calculatrice, par exemple, en utilisant le programme du constructeur MK.EXE:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âcrivez eForth.mkp dans la m√©moire du programme √† partir de la page 0. La version 0.5b occupe 74 pages. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ecrire eForth.mkd dans la m√©moire de donn√©es d√©cimales </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ecrire eForth.mkb dans la m√©moire de donn√©es binaires </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ecrire eForth.mkt dans la m√©moire de texte </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s le transfert vers la calculatrice, je recommande d' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> imm√©diatement </font><b><font style="vertical-align: inherit;">ces quatre fichiers dans un r√©pertoire s√©par√© du</font></b><font style="vertical-align: inherit;"> ¬´disque √©lectronique¬ª int√©gr√©. </font><font style="vertical-align: inherit;">Puisqu'ils ont le m√™me nom, vous pouvez t√©l√©charger eForth imm√©diatement √† la fois en tant que ¬´package¬ª.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.1 M√©moire binaire ("octet") MK-161: eForth.mkb </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les registres Electronics MK avec des nombres de 1000 √† 5095 sont utilis√©s pour stocker des nombres de 0 √† 255. Cette zone de la m√©moire de registre de la calculatrice est appel√©e binaire. Deux registres binaires cons√©cutifs sont accessibles depuis eForth comme une seule ¬´cellule¬ª de 16 bits et (comme partout sur le MK-161), les 8 bits sup√©rieurs sont dans le registre avec un nombre inf√©rieur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth utilise cette minuscule ¬´m√©moire binaire¬ª comme son principal. Les mots fonctionnent avec elle! et @, ICI et ALLOT, seulement √† partir d'ici l'interpr√©teur d'adresses ex√©cute le code cousu (voir 3.2). Voici les variables eForth, le tampon d'entr√©e de texte (TIB), le dictionnaire et la pile de restauration tblBS pour impl√©menter le retour arri√®re. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4096 octets est tr√®s modeste, selon les normes modernes. Par cons√©quent, d'√©normes efforts ont √©t√© d√©ploy√©s pour apporter √† d'autres domaines de la m√©moire tout ce qui est possible.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.2 Zone de texte: eForth.mkt </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imm√©diatement apr√®s que la m√©moire binaire soit une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zone de texte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les registres avec des nombres de 5095 √† 8167. Techniquement, ce sont les m√™mes registres d'octets, mais la possibilit√© de les √©crire sur le disque et de les lire dans un fichier s√©par√© rend cette zone sp√©ciale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot TLOAD est utilis√© pour travailler avec ¬´texte¬ª dans eForth. </font><font style="vertical-align: inherit;">Il alimente toute cette zone √† l'entr√©e de l'interpr√©teur de texte, sous la forme d'une cha√Æne de 3072 lettres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a d√©saccord sur la fa√ßon de diviser le texte en lignes. </font><font style="vertical-align: inherit;">Un √©diteur int√©gr√© √† MK Electronics insiste sur une longueur de ligne de 24 caract√®res. </font><font style="vertical-align: inherit;">Callisto utilise la convention Fort, o√π la cha√Æne contient 64 caract√®res. </font><font style="vertical-align: inherit;">eForth offre √† l'utilisateur le choix de compter tout le texte comme une longue ligne. </font><font style="vertical-align: inherit;">Vous pouvez utiliser l'√©diteur int√©gr√© MK-161. </font><font style="vertical-align: inherit;">Vous pouvez √©crire le v√¥tre, compatible avec Callisto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici le contenu initial de eForth.mkt, pour plus de commodit√©, divis√© en trois lignes: </font></font><br><br><pre><code class="plaintext hljs">: hi ." , %user%!" CR ; ' hi 'boot ! hi \</code> </pre> <br>  La premi√®re ligne d√©finit le nouveau mot hi qui salue l'utilisateur.  La deuxi√®me ligne prend le jeton de ce mot (voir 3.1) et le place dans la variable 'BOOT (voir 1).  D√©sormais, la zone de texte cesse de se compiler √† chaque d√©marrage d'eForth.  Au lieu de cela, le message d'accueil d√©j√† compil√© sera ex√©cut√©. <br><br>  La derni√®re ligne commence le mot salut, affichant un message d'accueil √† l'√©cran.  Le mot \ termine l'interpr√©tation du texte et renvoie le contr√¥le √† la console. <br><br>  Pour compiler un fichier texte arbitraire, vous devez aller dans la calculatrice avec la commande BYE, aller dans le menu principal et charger le fichier souhait√© en mode DOS.  Vous pouvez √©galement transf√©rer le fichier mkt depuis un ordinateur.  La touche C / P vous ram√®nera √† eForth, apr√®s quoi avec la commande TLOAD vous pourrez compiler le fichier charg√© dans la zone de texte. <br><br><h4>  2.4.3 M√©moire de programme: eForth.mkp </h4><br>  La m√©moire de programme MK-161 est un espace d'adressage isol√©.  Il stocke √©galement des octets, mais ils sont en lecture seule.  La m√©moire du programme contient 10 000 ¬´√©tapes¬ª, qui se sont av√©r√©es redondantes pour eForth.  Plus d'un quart de la m√©moire du programme s'est av√©r√© √™tre libre, ce qui donne une bonne r√©serve pour le d√©veloppement du traducteur. <br><br>  Ce n'est que dans la m√©moire du programme que des "mots de code" peuvent √™tre impl√©ment√©s.  De plus, les tables de reconnaissance de nom et toutes les cha√Ænes de texte connues sont affich√©es ici, ce qui √©conomise de la m√©moire binaire. <br><br>  Certains mots, tels que C @, COUNT et TYPE, peuvent adresser la m√©moire de programme si l'adresse n'est pas un nombre positif.  Par exemple, la phrase 0 C @ compte comme un ¬´pas¬ª (octet) √† partir de l'adresse 0 de la m√©moire de programme. <br><br><h4>  2.4.4 M√©moire d√©cimale: eForth.mkd </h4><br>  Les registres de MK Electronics avec des nombres de 0 √† 999 sont appel√©s d√©cimaux et contiennent des nombres utilis√©s pour les calculs ordinaires sur la calculatrice - 12 chiffres d√©cimaux de la ¬´mantisse¬ª et 2 chiffres d√©cimaux de ¬´l'ordre¬ª.  Le fort est con√ßu pour fonctionner avec des entiers jusqu'√† 4 octets de long, une telle ressource est clairement redondante pour eForth. <br><br>  La m√©moire d√©cimale est utilis√©e pour √©conomiser la pr√©cieuse m√©moire binaire.  Des piles de donn√©es et de retours sont effectu√©es ici.  Les en-t√™tes de mots sont stock√©s ici - √† la fois d√©finis par l'utilisateur et int√©gr√©s, un registre par titre.  Cette approche vous permet de red√©finir m√™me des mots avec des noms standard. <br><br>  La pile en m√©moire d√©cimale conduit √† un certain nombre de caract√©ristiques caract√©ristiques du Fort sur le MK-161.  Tout d'abord, la plage de valeurs des √©l√©ments de la pile est √©norme; elle peut accueillir des entiers 32 bits.  Le besoin de "doubles entiers" sur le MK-161 dispara√Æt, bien que pour des raisons de compatibilit√©, j'ai mis en ≈ìuvre les mots eForth correspondants.  Les ¬´doubles entiers¬ª sont pr√©sent√©s sur MK-161, sous la forme de deux √©l√©ments de pile contenant des nombres de 0 √† 65535, codant un entier 32 bits avec un signe dans le code suppl√©mentaire.  Les 16 bits sup√©rieurs de ce nombre sont plac√©s en haut, c'est-√†-dire √† l'adresse la plus basse. <br><br>  Les op√©rations logiques au niveau du bit AND, OR, XOR et NOT traitent leurs arguments comme des entiers 16 bits.  Un r√©sultat de 32768 √† 65535 est converti en nombres n√©gatifs de -32768 √† -1.  Dans eForth, false est cod√© avec z√©ro et v√©rit√© moins un.  Est √©galement vrai toute valeur autre que z√©ro. <br><br>  La deuxi√®me caract√©ristique de la pile de donn√©es 161eForth est qu'elle contient des num√©ros sign√©s.  Lorsque le mot @ lit le nombre 65535 dans une ¬´cellule¬ª de 16 bits, il est automatiquement converti en -1.  Un <b>mot sp√©cial ¬´non sign√©¬ª U @ est</b> pr√©vu pour compter directement 65535, avec un signe plus. <br><br>  Je rappelle que pour des raisons de vitesse, les <b>deux √©l√©ments sup√©rieurs de la pile de</b> donn√©es ne sont pas situ√©s en m√©moire d√©cimale, mais directement <b>dans les registres X et Y.</b> <br><br>  Le fait que les registres d√©cimaux puissent contenir des nombres fractionnaires et des nombres √† virgule flottante n'est pas utilis√© par eForth.  La machine virtuelle eForth utilise ces registres pour stocker des entiers d√©cimaux 12 bits sign√©s.  Les registres d√©cimaux sont accessibles par les mots C @ et C!  - les m√™mes que ceux qui fonctionnent avec des registres uniques. <br><br><h2>  3. L'interpr√®te interne </h2><br>  Le noyau eForth est un programme √©crit dans le langage d'entr√©e MK-161.  Sa premi√®re commande MAIN transf√®re le contr√¥le au code MAIN, qui d√©couvre tout d'abord les circonstances du red√©marrage.  S'il a √©t√© caus√© par un mauvais jeton, le MK-161 grincera.  Au premier d√©marrage, et √©galement apr√®s avoir allum√© le MK-161, l'√©cran est effac√©.  Ensuite, MAIN appelle le sous-programme Init pour initialiser le syst√®me d'interruption et tout ce dont les pilotes de console MK-161 ont besoin. <br><br>  Apr√®s avoir initialis√© les piles de donn√©es et les retours, la partie de bas niveau du d√©marrage est termin√©e.  Des choses incroyables se produisent pour les machines avec l'architecture Harvard - eForth continue d'ex√©cuter du ¬´code c√¢bl√©¬ª √† partir de la m√©moire d'octets.  L'honneur d'√™tre le premier appartient √† un mot dont l'adresse d'en-t√™te est enregistr√©e en R43.  Il s'agit g√©n√©ralement du mot FROID. <br><br>  Comment <i>les mots de haut niveau</i> (IED) sont-ils organis√©s?  Tout mot se compose de deux parties, un corps et un titre.  <i>L'en-t√™te</i> est stock√© en d√©cimal.  Il aide l'interpr√©teur et d√©compilateur externes √† trouver le nom et le corps du mot.  L'en-t√™te contient √©galement <i>un champ ¬´lexique¬ª</i> - un ensemble d'indicateurs qui aident l'interpr√®te externe √† traiter correctement le mot trouv√©.  L'interpr√®te interne est beaucoup plus important pour le corps VCA situ√© dans la m√©moire binaire et stock√© dans le dictionnaire.  Il est m√™me capable d'ex√©cuter des mots sans titre. <br><br>  <i>Le corps du</i> VCA commence par l'octet du <i>champ de code</i> , qui contient l'adresse du <i>processeur du</i> mot donn√©.  Quatre gestionnaires VCA sont √©crits dans la langue d'entr√©e MK-161 et commencent sur la premi√®re page de la m√©moire du programme.  Nous les analyserons tous (voir 3.3), mais le principal s'appelle DOLST et se situe √† l'adresse 02, imm√©diatement apr√®s la commande MAIN BP d√©j√† consid√©r√©e.  Ce gestionnaire ex√©cute les mots Fort d√©finis avec deux points. <br><br>  Apr√®s l'octet du <i>champ de</i> code se <i>trouve un champ de param√®tre de</i> longueur arbitraire.  Dans les ¬´deux points¬ª, le champ de param√®tre contient un ¬´code cousu¬ª - une s√©quence de jetons 16 bits, chacun indiquant une action qui lui est affect√©e. <br><br>  Tout d'abord, nous examinerons le jeton plus en d√©tail.  Ensuite, nous √©tudierons l'interpr√©teur interne INEXT, qui passe d'un jeton √† l'ex√©cution du suivant.  EForth appelle INEXT un gestionnaire primitif.  Nous concluons cette visite de l'interpr√®te interne en analysant les quatre processeurs IED. <br><br><h3>  3.1 Jetons </h3><br>  <i>Le jeton</i> repr√©sente le mot dans le code cousu et la pile, ce qui permet de l'ex√©cuter rapidement.  Le jeton est un pointeur vers le corps du mot, mais l'architecture dure du MK-161 a fait ses propres ajustements √† cette id√©e simple.  Analysons tous les types de jetons, en commen√ßant par le jeton primitif. <br><br><h4>  3.1.1 Jeton primitif </h4><br>  Tous les mots inclus dans la distribution eForth sont num√©rot√©s de 0 √† 206. Cette num√©rotation est de bout en bout, en tenant compte √† la fois des primitives et du VCA.  Ceci est fait de sorte que par le num√©ro du mot, il √©tait facile de restaurer son <i>nom</i> .  Ces noms sont stock√©s dans la m√©moire du programme.  Le lien vers le nom souhait√© est facilement trouv√© dans la table d'en-t√™te. <br><br>  <b>Le nombre primitif est son jeton</b> .  Comme tout jeton, la primitive prend deux octets dans le code cousu.  Le premier est z√©ro.  Le second contient son num√©ro.  La table tblTokens vous permet de trouver rapidement l'adresse du code primitif par ce num√©ro.  L'adresse tblTokens est stock√©e en permanence dans R9042 (voir 2.2), c'est-√†-dire que tout est toujours √† port√©e de main pour ex√©cuter la primitive. <br><br>  Le mot XT&gt; permet de conna√Ætre l'adresse d'un code primitif par son num√©ro (token).  Le code des primitives √©tant toujours situ√© dans la m√©moire du programme, l'adresse re√ßue est toujours n√©gative (voir 2.4.3). <br><br><h4>  3.1.2 Jeton VCA </h4><br>  VCA peut avoir son propre num√©ro et le nom standard associ√©, ou il peut √™tre compl√®tement nouveau, cr√©√© par l'utilisateur.  Dans tous les cas, le <b>jeton VCA est l'adresse de son champ de code</b> (voir 3), c'est-√†-dire un nombre compris entre 1000 et 5095. <br><br>  Dans le code cousu, le jeton VCA est √©crit d'une mani√®re tr√®s inhabituelle.  Le nombre de centaines (un nombre de 10 √† 50) est √©crit dans le premier octet, le reste de la division du jeton par 100 (un nombre de 0 √† 99) dans le deuxi√®me octet. <br><br>  Par exemple, le jeton 1234 sera repr√©sent√© par deux octets 12 et 34. La compilation de celui-ci, et de tout autre jeton, est effectu√©e en utilisant le mot COMPILE tir√© de la norme ANSI.  Pour √©crire et lire les jetons VCA dans le code cousu, les mots XT!  et XT @.  Ils acc√®dent aux adresses (voir 3.1.4), et le mot XT @ est √©galement capable de lire le jeton primitif. <br><br><h4>  3.1.3 Litt√©raux entiers </h4><br>  <i>Les litt√©raux entiers</i> sont une sorte de jetons primitifs.  Ils sont suffisamment inhabituels pour √™tre consid√©r√©s s√©par√©ment. <br><br>  Dans le code cousu, les jetons DOLIT et DOLITM occupent quatre octets.  Les deux premiers octets contiennent le jeton primitif d√©j√† consid√©r√©, c'est-√†-dire 0 et le num√©ro de la primitive.  Les deux octets suivants contiennent un entier que le litt√©ral donn√© mettra sur la pile de donn√©es pendant l'ex√©cution. <br><br>  DOLITM diff√®re en ce qu'il change le signe du nombre avant de le mettre sur la pile.  Il est con√ßu pour impl√©menter des nombres n√©gatifs. <br><br><h4>  3.1.4 Litt√©raux d'adresse </h4><br>  Comme les litt√©raux entiers, les trois <i>litt√©raux d'adresse</i> BRANCH,? BRANCH et DONXT occupent chacun 4 octets dans le code cousu.  Les 2 premiers octets contiennent le jeton primitif, les deux derniers octets sont l'adresse de saut. <br><br>  L'adresse est enregistr√©e dans le m√™me format que le jeton VCA (voir 3.1.2).  Le premier octet contient le nombre de centaines, le second contient le reste de la division de l'adresse par 100. Je rappelle qu'en raison de l'exag√©ration (voir 2.1), l'adresse de transition ne contient pas l'adresse du jeton souhait√©, mais un nombre inf√©rieur √† un. <br><br>  Le jeton DONXT aide √† impl√©menter le ¬´cycle de fin¬ª FOR-NEXT (voir 1).  Le saut inconditionnel BRANCH est n√©cessaire pour impl√©menter la boucle BEGIN-AGAIN infinie.  Branche conditionnelle? BRANCH transf√®re le contr√¥le si z√©ro se trouve en haut de la pile de donn√©es (faux).  Il sert √† impl√©menter l'instruction conditionnelle IF-THEN, quitte les "boucles ind√©finies" BEGIN-UNTIL et BEGIN-WHILE-REPEAT. <br><br><h4>  3.1.5 Litt√©raux de cha√Æne </h4><br>  <i>Les litt√©raux de cha√Æne</i> sont un type de jetons VCA.  Dans le code cousu d'un litt√©ral de cha√Æne, apr√®s le jeton, il y a un octet avec la longueur de la cha√Æne, apr√®s quoi la cha√Æne elle-m√™me, du premier octet au dernier. <br><br>  EForth a trois litt√©raux de cha√Æne: $ "| ,." |  et abandonner "|. Ils sont d√©finis dans le fichier eForth0.mkl en tant que jetons STRQP, DOTQP et ABORQ, respectivement. Le travail" litt√©ral "principal est effectu√© par le mot do $ pour eux, le jeton DOSTR. <br><br>  Pour que la taille de l'article soit raisonnable, je ne peux pas trop m'attarder sur ce sujet int√©ressant, mais c'est agr√©able de conna√Ætre leur disponibilit√© dans eForth. <br><br><h3>  3.2 Interpr√®te d'adresse </h3><br>  Il est temps de consid√©rer <i>l'interpr√©teur de jetons</i> , dont l'adresse est toujours √©crite dans le registre 9. La plupart des primitives terminent leur travail avec la commande K BP 9, qui transf√®re le contr√¥le √† l'√©tiquette INEXT. <br><br><pre> <code class="plaintext hljs">INEXT: 6 Fx‚â†0 NPrime NData:  2 6 + 7 F‚ü≥ 7 8 F‚ü≥ 8</code> </pre> <br>  Tout d'abord, l'interpr√©teur d'adresses lit le premier octet du jeton suivant avec la commande KIP6.  S'il est nul, il s'agit d'une primitive et le code sous l'√©tiquette NPrime g√©rera le jeton. <br><br>  L'√©tiquette NData indique le traitement du jeton VCA.  Le premier octet est multipli√© par cent par la commande VP 2, apr√®s quoi KIP6 + ajoute le deuxi√®me octet du jeton au r√©sultat (voir 3.1.2).  Le jeton de lecture est saisi par l'√©quipe P7 dans le WP ¬´registre de travail¬ª (R7). <br><br>  Nous savons que le jeton VCA est l'adresse de son champ de code, qui contient l'adresse du processeur.  Les commandes KIP7 P8 lisent l'octet du champ de code dans R8, et la commande KBP8 transf√®re le contr√¥le au processeur VCA.  Le gestionnaire sait que R7 contient un nombre de moins que l'adresse du champ de param√®tre du mot en cours de traitement. <br><br>  Les commandes F‚ü≥ avec le code 25 sont ¬´rang√©es¬ª sur la pile.  Le fait est que eForth stocke les deux premiers √©l√©ments de la pile de donn√©es directement dans les registres X et Y de la pile MK-161.  Une telle solution acc√©l√®re le travail, mais n√©cessite de s'assurer que ces donn√©es importantes ne sont pas perdues. <br><br>  Reste √† comprendre comment l'interpr√©teur d'adresses ex√©cute les primitives. <br><br><pre> <code class="plaintext hljs">NPrime: F‚ü≥ 6 9210 8 F‚ü≥ 8</code> </pre> <br>  La commande KIP6 lit le deuxi√®me octet du jeton primitif.  Les commandes RRP9210 P8 lisent l'adresse de cette primitive dans la table tblTokens (voir 2.2 et 3.1.1), et KBP8 transf√®re le contr√¥le √† cette primitive. <br><br>  Comme ci-dessus, F‚ü≥ supprime l'exc√©dent de la pile, restituant le contenu des registres X et Y. <br><br>  L'interpr√©teur d'adresses eForth est si petit qu'il est dupliqu√© plusieurs fois dans la m√©moire du programme.  La copie principale est ex√©cut√©e par la commande K BP 9, qui compl√®te la plupart des primitives. <br><br>  Comme exercice, je recommande d'√©tudier la mise en ≈ìuvre du mot EXECUTE, plac√© apr√®s le label EXECU.  Il s'agit d'une variante INEXT, qui ne lit pas le jeton dans le code cousu, mais le prend dans la pile de donn√©es. <br><br><h3>  3.3 Gestionnaires VCA </h3><br>  Quatre vari√©t√©s de VCA ont quatre gestionnaires diff√©rents: DOLST, DOVAR, DOCON et DOCONM.  Nous avons d√©j√† vu plus haut que l'interpr√©teur d'adresses avant d'appeler le gestionnaire laisse dans R7 l'adresse du champ de code du mot en cours de traitement. <br><br>  eForth.f apprend les adresses de ces gestionnaires en lisant l'en-t√™te du noyau dans le fichier eForth0.mkp.  Cela l'aide √† compiler correctement le VCA pour l'√©lectronique MK-161 en pla√ßant le r√©sultat dans le fichier eForth.mkb. <br><br><h4>  3.3.1 Mots deux points: DOLST et EXIT </h4><br>  Le prochain sujet important apr√®s INEXT est ce que fait l'interpr√©teur interne lorsqu'il rencontre le jeton d'un mot d√©fini par des deux-points.  Le champ de code d'un tel mot contient le num√©ro 2, donc INEXT transf√®re le contr√¥le au gestionnaire DOLST, qui effectue le travail n√©cessaire pour commencer √† interpr√©ter la nouvelle liste de jetons. <br><br><pre> <code class="plaintext hljs">DOLST: 6 2 F‚ü≥ 7 6 F‚ü≥ INEXT:</code> </pre> <br>  Le registre 2, comme nous l'avons d√©j√† expliqu√© (voir 2.1), contient un pointeur de pile de retour RP.  Les commandes IP6 KP2 √©crivent la valeur de R6, le pointeur d'interpr√©tation (IP), dans la pile de retour.  Plus tard, cela aidera √† se souvenir de la position actuelle dans l'ancienne liste de jetons, o√π INEXT est tomb√© sur un mot deux-points.  IP7 P6 r√©organise d√©sormais IP au d√©but d'une nouvelle liste. <br><br>  Imm√©diatement apr√®s le code DOLST, le code INEXT est plac√©, ce qui ex√©cutera le premier mot de la nouvelle liste de jetons.  Comme ailleurs, les commandes F  permettent de maintenir les deux premiers √©l√©ments de la pile de donn√©es. <br><br>  Les mots deux-points se terminent g√©n√©ralement par un jeton EXITT, qui fait le contraire, par rapport √† DOLST - il prend l'ancienne valeur IP de la pile de retour et revient √† l'interpr√©tation de l'ancienne liste de jetons. <br><br><pre> <code class="plaintext hljs">EXITT: 02 6 x 1 2 + 2 F‚ü≥ INEXT:</code> </pre> <br>  Les commandes RKIP02 P6 lisent l'ancienne valeur IP depuis le haut de la pile de retour (voir 2.1).  Apr√®s cela, les commandes Cx 1 IP2 + P2 corrigent la valeur de RP, en l'augmentant d'une unit√©.  La commande F‚ü≥ restaure la pile, apr√®s quoi INEXT ex√©cute le mot suivant de l'ancienne liste de jetons. <br><br>  Bien s√ªr, INEXT ne peut pas aller √† la fois apr√®s DOLST et apr√®s EXITT en m√™me temps.  Pour ce faire, j'ai appliqu√© une ancienne astuce de l'√©poque de l'URSS.  Vous pouvez √©galement le ma√Ætriser en examinant les lignes correspondantes dans le fichier eForth0.mkl. <br><br><h4>  3.3.2 DOVAR, gestionnaire de variables et de tableaux </h4><br>  Les mots g√©n√©r√©s par les mots CREATE et VARIABLE utilisent le m√™me gestionnaire DOVAR.  Ce gestionnaire pousse sur la pile l'adresse de la variable situ√©e dans le champ de param√®tre, qui va imm√©diatement apr√®s l'octet du champ de code.  Les variables VARIABLE occupent 2 octets et les tableaux cr√©√©s √† l'aide de CREATE contiennent autant d'octets que le programmeur le souhaite. <br><br><pre> <code class="plaintext hljs">DOVAR: ‚áî 3 x 1 7 + 9</code> </pre> <br>  Les commandes ‚áî KP3 enregistrent le contenu du registre Y dans la pile de donn√©es. En m√™me temps, le nombre du haut de la pile est entr√© dans RY, lib√©rant RX √† la nouvelle valeur.  Apr√®s les commandes Cx 1 IP7 +, cette nouvelle valeur en haut de la pile devient l'adresse du champ de param√®tre du mot ex√©cutable.  KBP9 transf√®re le contr√¥le √† INEXT, sans aucune astuce, en passant au mot suivant. <br><br><h4>  3.3.3 Gestionnaires de constantes: DOCON et DOCONM </h4><br>  Contrairement √† DOVAR, <i>le gestionnaire de constante</i> acc√®de au champ de param√®tre de son mot lui-m√™me.  DOCON y lit une valeur constante de 16 bits.  Cette valeur est toujours positive. <br><br><pre> <code class="plaintext hljs">DOCON: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + 9</code> </pre> <br>  Les commandes ‚áî KP3 ‚áî enregistrent RY dans la pile de donn√©es.  Mais cette fois, l'ancien sommet de la pile de donn√©es revient √† RX.  Les commandes IP7 P5 le forcent √† revenir dans RY, tout en pr√©parant le registre de pointeur R5 √† lire la valeur de la constante.  Ensuite, Cx 256 remplace les ordures du registre X par le nombre 256. <br><br>  Les instruments KIP5 √ó KIP5 + lisent une constante du champ de param√®tres jusqu'en haut de la pile de donn√©es, c'est-√†-dire en RX.  Comme nous nous en souvenons, dans MK-161, le premier octet est toujours √©lev√©.  Il est multipli√© par 256, apr√®s quoi l'octet le moins significatif de la constante est ajout√© au produit.  Tout le travail est fait, KBP9 transf√®re le contr√¥le au mot suivant. <br><br>  DOCONM fonctionne exactement de la m√™me mani√®re, seul le signe constant apr√®s lecture change √† l'oppos√©.  Les constantes n√©gatives sont impl√©ment√©es sur le MK-161 en tant que processeur s√©par√© pour des raisons de vitesse: <br><br><pre> <code class="plaintext hljs">DOCONM: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + /-/ 9</code> </pre> <br>  Maintenant, nous avons compl√®tement compris comment eForth ex√©cute son code sur l'√©lectronique MK-161 √† partir de la zone de donn√©es, abordant m√™me un sujet plus profond des litt√©raux de cha√Æne (voir 3.1.5). <br><br>  Dans le deuxi√®me article de la s√©rie, je vais parler de l'interpr√©teur externe de ¬´texte¬ª 161eForth, analyser la structure des tables d'en-t√™te et la reconnaissance des noms.  Cette partie du traducteur m'a demand√© de d√©velopper des solutions beaucoup plus radicales, dans le contexte desquelles ce qui pr√©c√®de est le Fort traditionnel, ancien et bon. <br><br>  Programmation Happy Fort! <br><br><h2>  Litt√©rature </h2><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth et Zen - 3e √©dition, 2017. Disponible sur Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Langage fort et sa mise en ≈ìuvre.  - L.: G√©nie m√©canique.  Leningrad  D√©partement, 1988. </li><li>  Semenov Yu.A.  Programmation en langage FORT.  - M.: Radio et communications, 1991. </li><li>  Norme ANS Forth.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La traduction</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation SP-Forth</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Offete Store (Actes du Dr Chen-Hanson Ting)</a> , o√π vous pouvez t√©l√©charger 86eForth v5.2 pour Windows, documentation en anglais. </li></ol><br><br><h2>  Illustrations vid√©o </h2><br>  Ces quatre petites vid√©os 161eForth se poursuivent.  La premi√®re vid√©o au d√©but de l'article. <br><br>  Partie 2 sur 5. Tests TEST-TEST4 du livre "eForth and Zen", 3√®me √©dition, sur le MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7UuQSozjuJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Partie 3 sur 5. VOIR le d√©compilateur. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K-mWJuL1fiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Partie 4 de 5. Breakpoint BYE, terminal RS-232 et acc√®s √† distance au MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Cfj60ICJrHU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Partie 5 de 5. Mots finaux. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oAAX29TpH9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452398/">https://habr.com/ru/post/fr452398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452384/index.html">Le processeur acc√©l√©rera l'optique √† 800 Gb / s: comment cela fonctionne</a></li>
<li><a href="../fr452388/index.html">Tamis d'Eratosth√®ne au-del√† de O (n). Preuve</a></li>
<li><a href="../fr452390/index.html">Radio d√©finie par logiciel - comment √ßa marche? 3e partie</a></li>
<li><a href="../fr452392/index.html">Une s√©lection de jeux de donn√©es d'apprentissage automatique</a></li>
<li><a href="../fr452394/index.html">Opus sur Sa Majest√© Clay. Deuxi√®me partie - Viva, cyanoacrylate! Viva, superglue</a></li>
<li><a href="../fr452400/index.html">Affaires inefficaces</a></li>
<li><a href="../fr452402/index.html">Exp√©riences avec une diode tunnel analogique</a></li>
<li><a href="../fr452404/index.html">Cinq tendances cl√©s de l'ITSM pour cette ann√©e</a></li>
<li><a href="../fr452408/index.html">Toilette Maine Coon</a></li>
<li><a href="../fr452410/index.html">Lancement de Bash en d√©tail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>