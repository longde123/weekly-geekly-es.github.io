<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♋️ 👐🏻 😿 ¿Cómo se organiza el código de barras? 🔹 ⚡️ 👪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 Una persona moderna encuentra códigos de barras todos los días, sin siquiera pensarlo. Cuando compramos productos en el supermercado, su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Cómo se organiza el código de barras?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439604/">  Hola Habr! <br><br>  Una persona moderna encuentra códigos de barras todos los días, sin siquiera pensarlo.  Cuando compramos productos en el supermercado, sus códigos se leen precisamente con la ayuda de un código de barras.  También paquetes, productos en almacenes, y así sucesivamente.  Sin embargo, pocas personas saben cómo funciona realmente. <br><br>  ¿Cómo está organizado el código de barras y qué está codificado en esta imagen? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Intentemos resolverlo, al mismo tiempo escribiremos un decodificador de dichos códigos. <a name="habracut"></a><br><br><h2>  Introduccion </h2><br>  El uso de códigos de barras tiene una larga historia.  Los primeros intentos de automatización comenzaron en la década de 1950; una patente para un lector de código se obtuvo en 1952.  El ingeniero involucrado en la clasificación de los vagones en el ferrocarril quería simplificar el proceso.  La idea era obvia: codificar el número con tiras y leerlas con fotocélulas.  En 1962, los códigos comenzaron a usarse oficialmente para identificar autos en el ferrocarril estadounidense (sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KarTrak</a> ), en 1968 el reflector fue reemplazado por un rayo láser, lo que aumentó la precisión y redujo el tamaño del lector.  En 1973, apareció el formato "Código de producto universal", y en 1974 el primer producto se vendió usando un escáner de código (el chicle de Wrigley es Estados Unidos) en un supermercado.  En 1984, un tercio de las tiendas usaban serpentinas, pero en Rusia comenzaron a usarse alrededor de los años 90. <br><br>  Se utilizan muchos códigos diferentes para diferentes tareas, por ejemplo, la secuencia "12345678" se puede representar de esta manera (y esto no es todo): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Comencemos el análisis bit a bit.  Además, todo lo que se describe a continuación se referirá al formulario "Código 128", simplemente porque su formato es bastante simple y directo.  Aquellos que deseen experimentar con otras especies pueden abrir un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generador en línea</a> y ver por sí mismos. <br><br>  A primera vista, el código de barras parece ser solo una secuencia aleatoria de líneas, de hecho, su estructura está claramente fijada: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Espacio vacío necesario para identificar claramente el inicio del código <br>  2 - Símbolo de inicio.  Para el Código 128, son posibles 3 opciones (llamadas A, B y C): 11010000100, 11010010000 o 11010011100, corresponden a diferentes tablas de códigos (más <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Wikipedia</a> ). <br>  3 - En realidad, el código que contiene los datos que necesitamos <br>  4 - Suma de verificación <br>  5 - Símbolo de parada.  Para el Código 128, esto es 1100011101011. <br>  6 (1) - Espacio vacío. <br><br>  Ahora sobre cómo se codifican los bits.  Aquí todo es muy simple: si toma el ancho de la línea más delgada como "1", la línea de doble ancho dará el código "11", un triple "111", y así sucesivamente.  El espacio vacío será "0" o "00" o "000" según el mismo principio.  Aquellos que lo deseen pueden comparar el código de inicio en la imagen para asegurarse de que se cumpla la regla. <br><br>  Ahora puedes comenzar a programar. <br><br><h2>  Obtenga la secuencia de bits </h2><br>  En principio, esta es la parte más difícil y, por supuesto, algorítmicamente, se puede implementar de diferentes maneras.  No estoy seguro de que el siguiente algoritmo sea óptimo, pero es suficiente para un estudio de caso. <br><br>  Para comenzar, cargue la imagen, estírela en ancho, tome una línea horizontal desde el centro de la imagen, conviértala en b / w y cárguela como una matriz. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  En el código de barras, "1" corresponde a negro, y en RGB, por el contrario, 0, por lo que la matriz debe invertirse.  Al mismo tiempo, calculamos el valor promedio. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Iniciamos el programa para asegurarnos de que el código de barras se cargue correctamente: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Ahora necesita determinar el ancho de un "bit".  Para hacer esto, destacamos el comienzo de la secuencia de inicio "1101", registrando los momentos de transición del gráfico a través de la línea media. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Registramos solo las transiciones a través del medio, por lo que el código "1101" se escribirá como "101", pero esto es suficiente para que podamos encontrar su ancho en píxeles. <br><br>  Ahora la decodificación real.  Encontramos la siguiente transición a través del medio, y determinamos el número de bits que caen en el intervalo.  Como la coincidencia no es absoluta (el código puede estar ligeramente curvado o estirado), utilizamos el redondeo. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  No estoy seguro de si esta es la mejor opción, tal vez hay una mejor manera, aquellos que lo deseen pueden escribir en los comentarios. <br><br>  Si todo se hizo correctamente, obtenemos la siguiente secuencia de salida: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Decodificación </h2><br>  Aquí, en principio, no hay dificultades.  Los caracteres en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código 128</a> están codificados con un código de 11 bits, que tiene 3 variedades (A, B y C) y puede almacenar diferentes codificaciones de caracteres o números del 00 al 99. <br><br>  En nuestro caso, el comienzo de la secuencia es 11010010000, que corresponde al "Código B".  Se rompió terriblemente para manejar manualmente todos los códigos de Wikipedia, por lo que la tabla simplemente se copió del navegador y su análisis también se realizó en Python (pista: esto no es necesario para la producción). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Ahora queda lo más simple.  Rompemos nuestra secuencia de bits en bloques de 11 caracteres: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Finalmente, formamos la línea y la mostramos en la pantalla: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  No daré la respuesta a lo que está codificado en la tabla, deje que sea una tarea para los lectores (el uso de programas listos para teléfonos inteligentes se considerará trampa :). <br><br>  El código tampoco implementa la verificación CRC, quienes lo deseen pueden hacerlo ellos mismos. <br><br>  Por supuesto, el algoritmo es imperfecto y se escribió en media hora.  Para fines más profesionales, hay bibliotecas listas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar</a> , por ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pyzbar</a> .  El código que usa una biblioteca de este tipo solo tomará 4 líneas: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (primero debe instalar la biblioteca ingresando el comando pip install pyzbar) <br><br>  <b>Adición</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">vinograd19</a> escribió en los comentarios sobre el conteo de CRC: <br><br>  <i>La historia del dígito de verificación es interesante.</i>  <i>Surgió evolutivamente.</i> <i><br></i>  <i>El dígito de verificación es necesario para evitar una decodificación incorrecta.</i>  <i>Si el código de barras era 1234 y se reconoció como 7234, entonces necesita una validación que evitará el reemplazo de 1 por 7. La validación puede ser inexacta, de modo que al menos el 90% de los números no válidos se determinan por adelantado.</i> <i><br><br></i>  <i>1er enfoque: tomemos la cantidad.</i>  <i>Para que el resto de la división entre 10 sea 0. Bueno, es decir, los primeros 12 caracteres llevan una carga de información, y el último dígito se selecciona de modo que la suma de los dígitos se divida por 10. Decodifique la secuencia, si la suma no es divisible por diez, significa decodificado con un error y debe hacerlo Esta vez más.</i>  <i>Por ejemplo, el código 1234 es válido.</i>  <i>1 + 2 + 3 + 4 = 10. El código 1216 también es válido, pero 1218 no lo es.</i> <i><br><br></i>  <i>Esto evita problemas con la automatización.</i>  <i>Sin embargo, en el momento de crear los códigos de barras, hubo un retroceso en la forma de escribir un número en las teclas.</i>  <i>Y hay un mal caso: si cambia el orden de los dos dígitos, la suma de verificación no cambia, y esto es malo.</i>  <i>Es decir, si el código de barras 1234 se introdujo como 2134, la suma de verificación convergerá, pero ingresamos el número incorrecto.</i>  <i>Resulta que el orden incorrecto de los números es un caso común si toca las teclas rápidamente.</i> <i><br><br></i>  <i>2º enfoque</i>  <i>Bueno, hagamos que la cantidad sea un poco más complicada.</i>  <i>Para que los números en lugares pares se tengan en cuenta dos veces.</i>  <i>Luego, al cambiar el orden, la cantidad definitivamente no convergerá al deseado.</i>  <i>Por ejemplo, el código 2364 es válido (2 + 3 + 3 + 6 + 4 + 4 = 20), y el código 3264 no es válido (3+ 2 + 2 + 6 + 4 + 4 = 19).</i>  <i>Pero aquí había otro mal ejemplo de conducción.</i>  <i>Algunos teclados son tales que diez dígitos están dispuestos en dos filas.</i>  <i>la primera fila es 12345 y debajo de la segunda segunda fila es 67890. Si, en lugar de la tecla "1", presione la tecla "2" a la derecha, la suma de verificación evitará la entrada incorrecta.</i>  <i>Pero si en lugar de la tecla "1", presiona la tecla "6" a continuación, es posible que no advierta.</i>  <i>Después de todo, 6 = 1 + 5, y en el caso de que esta cifra esté en un lugar par al calcular la suma de verificación, tenemos 2 * 6 = 2 * 1 + 2 * 5.</i>  <i>Es decir, la suma de verificación aumentó exactamente 10, por lo que su último dígito no ha cambiado.</i>  <i>Por ejemplo, las sumas de verificación en los códigos 2134 y 2634 son las mismas.</i>  <i>El mismo error ocurrirá si presionamos 7 en lugar de 2, en lugar de 3 presionamos 8, y así sucesivamente.</i> <i><br><br></i>  <i>3er enfoque.</i>  <i>Ok, tomemos la suma nuevamente, solo se tendrán en cuenta los números en lugares pares ... tres veces.</i>  <i>Es decir, el código 1234565 es válido, porque 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>El método descrito se ha convertido en el estándar para calcular la suma de verificación EAN13 con algunas correcciones: el número de dígitos se ha vuelto fijo e igual a 13, donde el 13 es la misma suma de verificación.</i>  <i>Los números en lugares impares se cuentan tres veces, en pares, una vez.</i> <br><br><h2>  Conclusión </h2><br>  Como puede ver, incluso algo tan simple como un código de barras tiene muchas cosas interesantes.  Por cierto, otro truco de vida para aquellos que han leído hasta aquí: el texto debajo del código de barras (si lo hay) duplica completamente su contenido.  Esto se hace para que, en caso de código ilegible, el operador pueda ingresarlo manualmente.  Por lo tanto, averiguar el contenido de un código de barras suele ser simple: solo mire el texto debajo de él. <br><br>  Como se sugiere en los comentarios, el más popular en el comercio es el código EAN-13, la codificación de bits es la misma allí, y aquellos que lo deseen pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver la</a> estructura de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> personajes. <br><br>  Si los lectores no han perdido interés, puede considerar por separado los códigos QR. <br><br>  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439604/">https://habr.com/ru/post/439604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439594/index.html">Anotaciones de primavera: AOP Magic</a></li>
<li><a href="../439596/index.html">Cómo aceleré el procesamiento de imágenes en Android 15 veces</a></li>
<li><a href="../439598/index.html">Microsoft habló sobre el costo del soporte pagado para Windows 7</a></li>
<li><a href="../439600/index.html">Finlandia resume los resultados preliminares del experimento con ingresos básicos garantizados</a></li>
<li><a href="../439602/index.html">La ética en el espacio digital: las reglas básicas de las relaciones digitales internacionales</a></li>
<li><a href="../439606/index.html">Producción piloto de electrónica por un precio mínimo.</a></li>
<li><a href="../439608/index.html">Religión moderna: ¿qué le dan Google, Facebook, Amazon y Apple a las personas?</a></li>
<li><a href="../439610/index.html">Como en mi vehículo eléctrico Chevrolet Bolt, bajo garantía, se reemplazaron dos módulos de batería y el tercero bajo monitoreo</a></li>
<li><a href="../439612/index.html">JavaScript robusto: persiguiendo un mito</a></li>
<li><a href="../439614/index.html">Cómo distinguir una buena reparación de una mala, o cómo en SRG hicimos una biblioteca Java multiproceso del analizador Tomit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>