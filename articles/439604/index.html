<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>鮫勇 游녫游낕 游 쮺칩mo se organiza el c칩digo de barras? 游댳 丘뫮잺 游놁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 Una persona moderna encuentra c칩digos de barras todos los d칤as, sin siquiera pensarlo. Cuando compramos productos en el supermercado, su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>쮺칩mo se organiza el c칩digo de barras?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439604/">  Hola Habr! <br><br>  Una persona moderna encuentra c칩digos de barras todos los d칤as, sin siquiera pensarlo.  Cuando compramos productos en el supermercado, sus c칩digos se leen precisamente con la ayuda de un c칩digo de barras.  Tambi칠n paquetes, productos en almacenes, y as칤 sucesivamente.  Sin embargo, pocas personas saben c칩mo funciona realmente. <br><br>  쮺칩mo est치 organizado el c칩digo de barras y qu칠 est치 codificado en esta imagen? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Intentemos resolverlo, al mismo tiempo escribiremos un decodificador de dichos c칩digos. <a name="habracut"></a><br><br><h2>  Introduccion </h2><br>  El uso de c칩digos de barras tiene una larga historia.  Los primeros intentos de automatizaci칩n comenzaron en la d칠cada de 1950; una patente para un lector de c칩digo se obtuvo en 1952.  El ingeniero involucrado en la clasificaci칩n de los vagones en el ferrocarril quer칤a simplificar el proceso.  La idea era obvia: codificar el n칰mero con tiras y leerlas con fotoc칠lulas.  En 1962, los c칩digos comenzaron a usarse oficialmente para identificar autos en el ferrocarril estadounidense (sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KarTrak</a> ), en 1968 el reflector fue reemplazado por un rayo l치ser, lo que aument칩 la precisi칩n y redujo el tama침o del lector.  En 1973, apareci칩 el formato "C칩digo de producto universal", y en 1974 el primer producto se vendi칩 usando un esc치ner de c칩digo (el chicle de Wrigley es Estados Unidos) en un supermercado.  En 1984, un tercio de las tiendas usaban serpentinas, pero en Rusia comenzaron a usarse alrededor de los a침os 90. <br><br>  Se utilizan muchos c칩digos diferentes para diferentes tareas, por ejemplo, la secuencia "12345678" se puede representar de esta manera (y esto no es todo): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Comencemos el an치lisis bit a bit.  Adem치s, todo lo que se describe a continuaci칩n se referir치 al formulario "C칩digo 128", simplemente porque su formato es bastante simple y directo.  Aquellos que deseen experimentar con otras especies pueden abrir un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generador en l칤nea</a> y ver por s칤 mismos. <br><br>  A primera vista, el c칩digo de barras parece ser solo una secuencia aleatoria de l칤neas, de hecho, su estructura est치 claramente fijada: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Espacio vac칤o necesario para identificar claramente el inicio del c칩digo <br>  2 - S칤mbolo de inicio.  Para el C칩digo 128, son posibles 3 opciones (llamadas A, B y C): 11010000100, 11010010000 o 11010011100, corresponden a diferentes tablas de c칩digos (m치s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Wikipedia</a> ). <br>  3 - En realidad, el c칩digo que contiene los datos que necesitamos <br>  4 - Suma de verificaci칩n <br>  5 - S칤mbolo de parada.  Para el C칩digo 128, esto es 1100011101011. <br>  6 (1) - Espacio vac칤o. <br><br>  Ahora sobre c칩mo se codifican los bits.  Aqu칤 todo es muy simple: si toma el ancho de la l칤nea m치s delgada como "1", la l칤nea de doble ancho dar치 el c칩digo "11", un triple "111", y as칤 sucesivamente.  El espacio vac칤o ser치 "0" o "00" o "000" seg칰n el mismo principio.  Aquellos que lo deseen pueden comparar el c칩digo de inicio en la imagen para asegurarse de que se cumpla la regla. <br><br>  Ahora puedes comenzar a programar. <br><br><h2>  Obtenga la secuencia de bits </h2><br>  En principio, esta es la parte m치s dif칤cil y, por supuesto, algor칤tmicamente, se puede implementar de diferentes maneras.  No estoy seguro de que el siguiente algoritmo sea 칩ptimo, pero es suficiente para un estudio de caso. <br><br>  Para comenzar, cargue la imagen, est칤rela en ancho, tome una l칤nea horizontal desde el centro de la imagen, convi칠rtala en b / w y c치rguela como una matriz. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  En el c칩digo de barras, "1" corresponde a negro, y en RGB, por el contrario, 0, por lo que la matriz debe invertirse.  Al mismo tiempo, calculamos el valor promedio. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Iniciamos el programa para asegurarnos de que el c칩digo de barras se cargue correctamente: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Ahora necesita determinar el ancho de un "bit".  Para hacer esto, destacamos el comienzo de la secuencia de inicio "1101", registrando los momentos de transici칩n del gr치fico a trav칠s de la l칤nea media. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Registramos solo las transiciones a trav칠s del medio, por lo que el c칩digo "1101" se escribir치 como "101", pero esto es suficiente para que podamos encontrar su ancho en p칤xeles. <br><br>  Ahora la decodificaci칩n real.  Encontramos la siguiente transici칩n a trav칠s del medio, y determinamos el n칰mero de bits que caen en el intervalo.  Como la coincidencia no es absoluta (el c칩digo puede estar ligeramente curvado o estirado), utilizamos el redondeo. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  No estoy seguro de si esta es la mejor opci칩n, tal vez hay una mejor manera, aquellos que lo deseen pueden escribir en los comentarios. <br><br>  Si todo se hizo correctamente, obtenemos la siguiente secuencia de salida: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Decodificaci칩n </h2><br>  Aqu칤, en principio, no hay dificultades.  Los caracteres en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C칩digo 128</a> est치n codificados con un c칩digo de 11 bits, que tiene 3 variedades (A, B y C) y puede almacenar diferentes codificaciones de caracteres o n칰meros del 00 al 99. <br><br>  En nuestro caso, el comienzo de la secuencia es 11010010000, que corresponde al "C칩digo B".  Se rompi칩 terriblemente para manejar manualmente todos los c칩digos de Wikipedia, por lo que la tabla simplemente se copi칩 del navegador y su an치lisis tambi칠n se realiz칩 en Python (pista: esto no es necesario para la producci칩n). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Ahora queda lo m치s simple.  Rompemos nuestra secuencia de bits en bloques de 11 caracteres: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Finalmente, formamos la l칤nea y la mostramos en la pantalla: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  No dar칠 la respuesta a lo que est치 codificado en la tabla, deje que sea una tarea para los lectores (el uso de programas listos para tel칠fonos inteligentes se considerar치 trampa :). <br><br>  El c칩digo tampoco implementa la verificaci칩n CRC, quienes lo deseen pueden hacerlo ellos mismos. <br><br>  Por supuesto, el algoritmo es imperfecto y se escribi칩 en media hora.  Para fines m치s profesionales, hay bibliotecas listas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar</a> , por ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pyzbar</a> .  El c칩digo que usa una biblioteca de este tipo solo tomar치 4 l칤neas: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (primero debe instalar la biblioteca ingresando el comando pip install pyzbar) <br><br>  <b>Adici칩n</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">vinograd19</a> escribi칩 en los comentarios sobre el conteo de CRC: <br><br>  <i>La historia del d칤gito de verificaci칩n es interesante.</i>  <i>Surgi칩 evolutivamente.</i> <i><br></i>  <i>El d칤gito de verificaci칩n es necesario para evitar una decodificaci칩n incorrecta.</i>  <i>Si el c칩digo de barras era 1234 y se reconoci칩 como 7234, entonces necesita una validaci칩n que evitar치 el reemplazo de 1 por 7. La validaci칩n puede ser inexacta, de modo que al menos el 90% de los n칰meros no v치lidos se determinan por adelantado.</i> <i><br><br></i>  <i>1er enfoque: tomemos la cantidad.</i>  <i>Para que el resto de la divisi칩n entre 10 sea 0. Bueno, es decir, los primeros 12 caracteres llevan una carga de informaci칩n, y el 칰ltimo d칤gito se selecciona de modo que la suma de los d칤gitos se divida por 10. Decodifique la secuencia, si la suma no es divisible por diez, significa decodificado con un error y debe hacerlo Esta vez m치s.</i>  <i>Por ejemplo, el c칩digo 1234 es v치lido.</i>  <i>1 + 2 + 3 + 4 = 10. El c칩digo 1216 tambi칠n es v치lido, pero 1218 no lo es.</i> <i><br><br></i>  <i>Esto evita problemas con la automatizaci칩n.</i>  <i>Sin embargo, en el momento de crear los c칩digos de barras, hubo un retroceso en la forma de escribir un n칰mero en las teclas.</i>  <i>Y hay un mal caso: si cambia el orden de los dos d칤gitos, la suma de verificaci칩n no cambia, y esto es malo.</i>  <i>Es decir, si el c칩digo de barras 1234 se introdujo como 2134, la suma de verificaci칩n converger치, pero ingresamos el n칰mero incorrecto.</i>  <i>Resulta que el orden incorrecto de los n칰meros es un caso com칰n si toca las teclas r치pidamente.</i> <i><br><br></i>  <i>2췈 enfoque</i>  <i>Bueno, hagamos que la cantidad sea un poco m치s complicada.</i>  <i>Para que los n칰meros en lugares pares se tengan en cuenta dos veces.</i>  <i>Luego, al cambiar el orden, la cantidad definitivamente no converger치 al deseado.</i>  <i>Por ejemplo, el c칩digo 2364 es v치lido (2 + 3 + 3 + 6 + 4 + 4 = 20), y el c칩digo 3264 no es v치lido (3+ 2 + 2 + 6 + 4 + 4 = 19).</i>  <i>Pero aqu칤 hab칤a otro mal ejemplo de conducci칩n.</i>  <i>Algunos teclados son tales que diez d칤gitos est치n dispuestos en dos filas.</i>  <i>la primera fila es 12345 y debajo de la segunda segunda fila es 67890. Si, en lugar de la tecla "1", presione la tecla "2" a la derecha, la suma de verificaci칩n evitar치 la entrada incorrecta.</i>  <i>Pero si en lugar de la tecla "1", presiona la tecla "6" a continuaci칩n, es posible que no advierta.</i>  <i>Despu칠s de todo, 6 = 1 + 5, y en el caso de que esta cifra est칠 en un lugar par al calcular la suma de verificaci칩n, tenemos 2 * 6 = 2 * 1 + 2 * 5.</i>  <i>Es decir, la suma de verificaci칩n aument칩 exactamente 10, por lo que su 칰ltimo d칤gito no ha cambiado.</i>  <i>Por ejemplo, las sumas de verificaci칩n en los c칩digos 2134 y 2634 son las mismas.</i>  <i>El mismo error ocurrir치 si presionamos 7 en lugar de 2, en lugar de 3 presionamos 8, y as칤 sucesivamente.</i> <i><br><br></i>  <i>3er enfoque.</i>  <i>Ok, tomemos la suma nuevamente, solo se tendr치n en cuenta los n칰meros en lugares pares ... tres veces.</i>  <i>Es decir, el c칩digo 1234565 es v치lido, porque 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>El m칠todo descrito se ha convertido en el est치ndar para calcular la suma de verificaci칩n EAN13 con algunas correcciones: el n칰mero de d칤gitos se ha vuelto fijo e igual a 13, donde el 13 es la misma suma de verificaci칩n.</i>  <i>Los n칰meros en lugares impares se cuentan tres veces, en pares, una vez.</i> <br><br><h2>  Conclusi칩n </h2><br>  Como puede ver, incluso algo tan simple como un c칩digo de barras tiene muchas cosas interesantes.  Por cierto, otro truco de vida para aquellos que han le칤do hasta aqu칤: el texto debajo del c칩digo de barras (si lo hay) duplica completamente su contenido.  Esto se hace para que, en caso de c칩digo ilegible, el operador pueda ingresarlo manualmente.  Por lo tanto, averiguar el contenido de un c칩digo de barras suele ser simple: solo mire el texto debajo de 칠l. <br><br>  Como se sugiere en los comentarios, el m치s popular en el comercio es el c칩digo EAN-13, la codificaci칩n de bits es la misma all칤, y aquellos que lo deseen pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver la</a> estructura de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> personajes. <br><br>  Si los lectores no han perdido inter칠s, puede considerar por separado los c칩digos QR. <br><br>  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439604/">https://habr.com/ru/post/439604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439594/index.html">Anotaciones de primavera: AOP Magic</a></li>
<li><a href="../439596/index.html">C칩mo aceler칠 el procesamiento de im치genes en Android 15 veces</a></li>
<li><a href="../439598/index.html">Microsoft habl칩 sobre el costo del soporte pagado para Windows 7</a></li>
<li><a href="../439600/index.html">Finlandia resume los resultados preliminares del experimento con ingresos b치sicos garantizados</a></li>
<li><a href="../439602/index.html">La 칠tica en el espacio digital: las reglas b치sicas de las relaciones digitales internacionales</a></li>
<li><a href="../439606/index.html">Producci칩n piloto de electr칩nica por un precio m칤nimo.</a></li>
<li><a href="../439608/index.html">Religi칩n moderna: 쯤u칠 le dan Google, Facebook, Amazon y Apple a las personas?</a></li>
<li><a href="../439610/index.html">Como en mi veh칤culo el칠ctrico Chevrolet Bolt, bajo garant칤a, se reemplazaron dos m칩dulos de bater칤a y el tercero bajo monitoreo</a></li>
<li><a href="../439612/index.html">JavaScript robusto: persiguiendo un mito</a></li>
<li><a href="../439614/index.html">C칩mo distinguir una buena reparaci칩n de una mala, o c칩mo en SRG hicimos una biblioteca Java multiproceso del analizador Tomit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>