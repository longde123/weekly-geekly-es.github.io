<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÇ üèÖ üßùüèº Comprobaci√≥n del c√≥digo fuente de Roslyn üñêüèº üèîÔ∏è üòá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De vez en cuando volvemos a los proyectos que hemos verificado previamente utilizando PVS-Studio, lo que da como resultado sus descripciones en varios...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprobaci√≥n del c√≥digo fuente de Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio vs Roslyn"></div><br>  De vez en cuando volvemos a los proyectos que hemos verificado previamente utilizando PVS-Studio, lo que da como resultado sus descripciones en varios art√≠culos.  Dos razones hacen que estos regresos sean emocionantes para nosotros.  En primer lugar, la oportunidad de evaluar el progreso de nuestro analizador.  En segundo lugar, monitorear los comentarios de los autores del proyecto sobre nuestro art√≠culo y el informe de errores, que generalmente les proporcionamos.  Por supuesto, los errores pueden corregirse sin nuestra participaci√≥n.  Sin embargo, siempre es bueno cuando nuestros esfuerzos ayudan a mejorar un proyecto.  Roslyn no fue la excepci√≥n.  El art√≠culo anterior sobre la verificaci√≥n de este proyecto data del 23 de diciembre de 2015. En vista del progreso que nuestro analizador ha hecho desde entonces, es bastante largo.  Dado que el n√∫cleo C # del analizador PVS-Studio se basa en Roslyn, nos da un inter√©s adicional en este proyecto.  Como resultado, estamos tan interesados ‚Äã‚Äãcomo la mostaza sobre la calidad del c√≥digo de este proyecto.  Ahora prob√©moslo una vez m√°s y descubramos algunos problemas nuevos e interesantes (pero esperemos que nada significativo) que PVS-Studio pueda encontrar. <br><a name="habracut"></a><br>  Es probable que muchos de nuestros lectores conozcan bien a Roslyn (o .NET Compiler Platform).  En resumen, es un conjunto de compiladores de c√≥digo abierto y una API para el an√°lisis de c√≥digo de los lenguajes C # y Visual Basic .NET de Microsoft.  El c√≥digo fuente del proyecto est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br>  No dar√© una descripci√≥n detallada de esta plataforma y recomendar√© revisar el art√≠culo de mi colega Sergey Vasiliev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a Roslyn y su uso en el desarrollo de programas</a> " a todos los lectores interesados.  A partir de este art√≠culo, puede descubrir no solo las caracter√≠sticas de la arquitectura de Roslyn, sino tambi√©n c√≥mo usamos exactamente esta plataforma. <br><br>  Como mencion√© anteriormente, han pasado m√°s de 3 a√±os desde que mi colega Andrey Karpov escribi√≥ el √∫ltimo art√≠culo sobre el cheque de Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lanzamiento de A√±o Nuevo PVS-Studio 6.00: Escaneo de Roslyn</a> ".  Desde entonces, el analizador C # PVS-Studio ten√≠a muchas caracter√≠sticas nuevas.  En realidad, el art√≠culo de Andrey era un caso de prueba, ya que en ese momento el analizador C # acababa de agregarse en PVS-Studio.  A pesar de esto, logramos detectar errores en el proyecto Roslyn, que sin duda fue de alta calidad.  Entonces, ¬øqu√© ha cambiado en el analizador para el c√≥digo C # en este momento que nos permitir√° realizar un an√°lisis m√°s profundo? <br><br>  Desde entonces, tanto el n√∫cleo como la infraestructura se han desarrollado.  Agregamos soporte para Visual Studio 2017 y Roslyn 2.0, y una integraci√≥n profunda con MSBuild.  El art√≠culo de mi colega Paul Eremeev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de Visual Studio 2017 y Roslyn 2.0 en PVS-Studio: a veces no es tan f√°cil de usar como parece</a> " describe nuestro enfoque de integraci√≥n con MSBuild y los motivos de esta decisi√≥n. <br><br>  Por el momento, estamos trabajando activamente para pasar a Roslyn 3.0 de la misma manera que inicialmente admitimos Visual Studio 2017. Requiere el uso de nuestro propio conjunto de herramientas, incluido en el distributivo PVS-Studio como un "trozo", que es un MSBuild vac√≠o archivo .exe  A pesar del hecho de que parece una "muleta" (MSBuild API no es muy amigable para reutilizar en proyectos de terceros debido a la baja portabilidad de las bibliotecas), este enfoque ya nos ha ayudado a superar relativamente f√°cilmente m√∫ltiples actualizaciones de Roslyn en t√©rminos de Visual Studio 2017. Hasta ahora, estaba ayudando (incluso con algunos desaf√≠os) a pasar por la actualizaci√≥n de Visual Studio 2019 y mantener una compatibilidad y un rendimiento completos para sistemas con versiones anteriores de MSBuild. <br><br>  El n√∫cleo del analizador tambi√©n ha experimentado una serie de mejoras.  Una de las caracter√≠sticas principales es un an√°lisis interprocedural completo con consideraci√≥n de los valores de los m√©todos de entrada y salida, evaluando (dependiendo de estos par√°metros) el alcance de las ramas de ejecuci√≥n y los puntos de retorno. <br><br>  Estamos en camino de completar la tarea de monitorear los par√°metros dentro de los m√©todos (por ejemplo, desreferencias potencialmente peligrosas) junto con guardar sus anotaciones autom√°ticas.  Para un diagn√≥stico que utiliza un mecanismo de flujo de datos, esto permitir√° tener en cuenta situaciones peligrosas que se producen al pasar un par√°metro en un m√©todo.  Antes de esto, al analizar lugares tan peligrosos, no se generaba una advertencia, ya que no pod√≠amos conocer todos los valores de entrada posibles en dicho m√©todo.  Ahora podemos detectar el peligro, ya que en todos los lugares de llamar a este m√©todo, estos par√°metros de entrada se tendr√°n en cuenta. <br><br>  Nota: puede leer acerca de los mecanismos b√°sicos del analizador, como el flujo de datos y otros en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tecnolog√≠as utilizadas en el analizador de c√≥digo PVS-Studio para encontrar errores y vulnerabilidades potenciales</a> ". <br><br>  El an√°lisis interprocedural en PVS-Studio C # no est√° limitado ni por los par√°metros de entrada, ni por la profundidad.  La √∫nica limitaci√≥n son los m√©todos virtuales en las clases, abiertos para la herencia, as√≠ como tambi√©n para entrar en recursi√≥n (el an√°lisis se detiene cuando se topa con una llamada repetida del m√©todo ya evaluado).  Al hacerlo, el m√©todo recursivo en s√≠ mismo se evaluar√° eventualmente suponiendo que se desconoce el valor de retorno de su recursividad. <br><br>  Otra gran caracter√≠stica nueva en el analizador C # se ha convertido en tener en cuenta la posible desreferencia de un puntero potencialmente nulo.  Antes de eso, el analizador se quej√≥ de una posible excepci√≥n de referencia nula, asegur√°ndose de que en todas las ramas de ejecuci√≥n el valor de la variable sea nulo.  Por supuesto, estuvo mal en algunos casos, por eso el diagn√≥stico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> hab√≠a llamado previamente referencia nula potencial. <br><br>  Ahora el analizador es consciente del hecho de que la variable podr√≠a ser nula en una de las ramas de ejecuci√≥n (por ejemplo, bajo una cierta condici√≥n <i>if</i> ).  Si nota el acceso a dicha variable sin una verificaci√≥n, emitir√° la advertencia V3080, pero con un nivel de certeza m√°s bajo, que si ve nulo en todas las ramas.  Junto con el an√°lisis interprocedural mejorado, dicho mecanismo permite encontrar errores que son muy dif√≠ciles de detectar.  Aqu√≠ hay un ejemplo: imagine una larga cadena de llamadas a m√©todos, la √∫ltima de las cuales no le es familiar.  Bajo ciertas circunstancias, devuelve nulo en el bloque <i>catch</i> , pero no se ha protegido de esto, como simplemente no lo ha sabido.  En este caso, el analizador solo se queja cuando ve exactamente la asignaci√≥n nula.  En nuestra opini√≥n, distingue cualitativamente nuestro enfoque de la caracter√≠stica de C # 8.0 como referencia de tipo anulable, que, de hecho, se limita a establecer verificaciones para nulo para cada m√©todo.  Sin embargo, sugerimos la alternativa: realizar comprobaciones solo en lugares donde realmente puede ocurrir nulo, y nuestro analizador ahora puede buscar tales casos. <br><br>  Por lo tanto, no demoremos demasiado el punto principal y pasemos a la toma de culpa: analicemos los resultados de la verificaci√≥n de Roslyn.  Primero, consideremos los errores encontrados debido a las caracter√≠sticas descritas anteriormente.  En resumen, esta vez hubo muchas advertencias para el c√≥digo de Roslyn.  Creo que est√° relacionado con el hecho de que la plataforma est√° evolucionando muy activamente (en este punto, la base de c√≥digo es de aproximadamente 2,770,000 l√≠neas excluidas las vac√≠as), y no hemos analizado este proyecto por mucho tiempo.  Sin embargo, no hay tantos errores cr√≠ticos, mientras que son de mayor inter√©s para el art√≠culo.  Como de costumbre, exclu√≠ las pruebas del cheque, hay muchas en Roslyn. <br><br>  Comenzar√© con los errores V3080 del nivel medio de certeza, en el que el analizador ha detectado un posible acceso por referencia nula, pero no en todos los casos posibles (ramificaciones de c√≥digo). <br><br>  <b>Posible desreferencia nula - Media</b> <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'actual'.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Consideremos el m√©todo <i>GetNode</i> .  El analizador sugiere que el acceso por referencia nula es posible en la condici√≥n del bloque <i>while</i> <i>.</i>  A la variable se le asigna un valor en el cuerpo del bloque <i>while</i> , que es el resultado del m√©todo <i>AsNode</i> .  En algunos casos, este valor ser√° <i>nulo</i> .  Un buen ejemplo de an√°lisis interprocedural en acci√≥n. <br><br>  Ahora consideremos un caso similar, en el que el an√°lisis interprocedural se realiz√≥ a trav√©s de dos llamadas a m√©todos. <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'directorio'.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  La variable de <i>directorio</i> en el cuerpo del m√©todo <i>ExpandFileNamePattern</i> obtiene el valor del m√©todo <i>GetDirectoryName (string)</i> .  Eso, a su vez, devuelve el resultado del m√©todo sobrecargado <i>GetDirectoryName (string, bool)</i> cuyo valor puede ser <i>nulo</i> .  Dado que el <i>directorio</i> variable se usa sin una comprobaci√≥n preliminar de nulo en el cuerpo del m√©todo <i>ExpandFileNamePattern</i> , podemos proclamar que el analizador es correcto al emitir la advertencia.  Esta es una construcci√≥n potencialmente insegura. <br><br>  Otro fragmento de c√≥digo con el error V3080, m√°s precisamente, con dos errores, emitido para una sola l√≠nea de c√≥digo.  El an√°lisis interprocedural no era necesario aqu√≠. <br><br>  V3080 Posible desreferencia nula.  Considere la posibilidad de inspeccionar 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Las variables <i>spanStartLocation</i> y <i>spanEndLocationExclusive</i> son del tipo <i>int anulables</i> y se inicializan por <i>null</i> .  M√°s adelante en el c√≥digo se les pueden asignar valores, pero solo bajo ciertas condiciones.  En algunos casos, su valor sigue siendo <i>nulo</i> .  Despu√©s de eso, se accede a estas variables por referencia sin verificaci√≥n preliminar de nulo, lo que indica el analizador. <br><br>  El c√≥digo de Roslyn contiene muchos de estos errores, m√°s de 100. A menudo, el patr√≥n de estos errores es el mismo.  Hay alg√∫n tipo de m√©todo general, que potencialmente devuelve <i>nulo</i> .  El resultado de este m√©todo se usa en muchos lugares, a veces a trav√©s de docenas de llamadas a m√©todos intermedios o verificaciones adicionales.  Es importante comprender que estos errores no son fatales, pero potencialmente pueden conducir al acceso por referencia nula.  Si bien la detecci√≥n de tales errores es bastante desafiante.  Es por eso que en algunos casos uno deber√≠a considerar la refactorizaci√≥n de c√≥digo, en cuyo caso si <i>nulo</i> regresa, el m√©todo arrojar√° una excepci√≥n.  De lo contrario, puede proteger su c√≥digo solo con verificaciones generales, lo cual es bastante agotador y, a veces, poco confiable.  De todos modos, est√° claro que cada caso espec√≠fico requiere una soluci√≥n basada en las especificaciones del proyecto. <br><br>  Nota  Sucede que en un punto dado no hay tales casos (datos de entrada), cuando el m√©todo devuelve <i>nulo</i> y no hay un error real.  Sin embargo, dicho c√≥digo a√∫n no es confiable, porque todo puede cambiar al introducir algunos cambios en el c√≥digo. <br><br>  Para abandonar el tema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> , echemos un vistazo a los errores obvios de alto nivel de certeza, cuando el acceso por referencia nula es el m√°s probable o incluso inevitable. <br><br>  <b>Posible desreferencia nula - Alta</b> <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Debido al error tipogr√°fico en la condici√≥n ( <i>&amp;&amp;</i> se usa en lugar del operador <i>||</i> ), el c√≥digo funciona de manera diferente a la prevista y el acceso a la variable <i>collectionType.Type</i> se ejecutar√° cuando sea <i>nulo</i> .  La condici√≥n debe corregirse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Por cierto, las cosas pueden desarrollarse de otra manera: en la primera parte de la condici√≥n, los operadores <i>==</i> y <i>! =</i> Est√°n en mal estado <i>.</i>  Entonces el c√≥digo correcto se ver√≠a as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Esta versi√≥n del c√≥digo es menos l√≥gica, pero tambi√©n corrige el error.  La soluci√≥n final recae en la decisi√≥n de los autores del proyecto. <br><br>  Otro error similar. <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'acci√≥n'.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  El error se produce al generar el mensaje para la excepci√≥n.  Le sigue el intento de acceder a la propiedad <i>action.DisplayText a</i> trav√©s de la variable <i>action</i> , que se sabe que es <i>nula</i> . <br><br>  Aqu√≠ viene el √∫ltimo error V3080 del nivel alto. <br><br>  V3080 Posible desreferencia nula.  Considere inspeccionar 'tipo'.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  El m√©todo es bastante peque√±o, as√≠ que lo cito por completo.  La condici√≥n en el bloque de <i>retorno</i> es incorrecta.  En algunos casos, al acceder a <i>type.FullName</i> , puede producirse una excepci√≥n.  Usar√© par√©ntesis para aclararlo (no cambiar√°n el comportamiento): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Seg√∫n la precedencia de las operaciones, el c√≥digo funcionar√° exactamente as√≠.  En caso de que la variable de <i>tipo</i> sea <i>nula</i> , entraremos en el check de else, donde usaremos la referencia de <i>tipo</i> nulo, despu√©s de haber verificado la variable <i>targetTypeName</i> para <i>null</i> .  El c√≥digo puede repararse, por ejemplo, de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Creo que es suficiente para revisar los errores de V3080.  Ahora es el momento de ver otras cosas interesantes que el analizador PVS-Studio logr√≥ encontrar. <br><br>  <b>Error tipogr√°fico</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3005</a> La variable 'SourceCodeKind' se asigna a s√≠ misma.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Debido al error en el nombre de las variables, se realiz√≥ un error tipogr√°fico en el constructor de la clase <i>DynamicFileInfo</i> .  Al campo <i>SourceCodeKind</i> se le asigna su propio valor en lugar de utilizar el par√°metro <i>sourceCodeKind</i> .  Para minimizar la probabilidad de tales errores, le recomendamos que utilice el prefijo de subrayado para los nombres de los par√°metros en tales casos.  Aqu√≠ hay un ejemplo de una versi√≥n corregida del c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Inadvertencia</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3006</a> El objeto fue creado pero no se est√° utilizando.  Podr√≠a faltar la palabra clave 'throw': lanzar una nueva InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Bajo cierta condici√≥n, el destructor debe lanzar una excepci√≥n, pero no sucede mientras el objeto de excepci√≥n simplemente se crea.  Se perdi√≥ la palabra clave de <i>lanzamiento</i> .  Aqu√≠ est√° la versi√≥n corregida del c√≥digo: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  El problema con los destructores en C # y el lanzamiento de excepciones de ellos es un tema para otra discusi√≥n, que est√° m√°s all√° del alcance de este art√≠culo. <br><br>  <b>Cuando el resultado no es importante</b> <br><br>  Los m√©todos, que recibieron el mismo valor en todos los casos, activaron un cierto n√∫mero de advertencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3009</a> .  En algunos casos, puede no ser cr√≠tico o el valor de retorno simplemente no se verifica en el c√≥digo de llamada.  Me salt√© tales advertencias.  Pero algunos fragmentos de c√≥digo parec√≠an sospechosos.  Aqu√≠ est√° uno de ellos: <br><br>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  El m√©todo <i>TryExecuteCommand</i> devuelve nada m√°s que <i>verdadero</i> .  Al hacerlo, en el c√≥digo de llamada, el valor devuelto participa en algunas comprobaciones. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Es dif√≠cil decir exactamente en qu√© medida ese comportamiento es peligroso.  Pero si el resultado no es necesario, tal vez el tipo del valor de retorno deber√≠a cambiarse a vac√≠o y uno deber√≠a hacer peque√±as modificaciones en el m√©todo de llamada.  Esto har√° que el c√≥digo sea m√°s legible y seguro. <br><br>  Advertencias de analizador similares: <br><br><ul><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  JsonRpcClient.cs 138 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'falso'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  ObjectList.cs 173 </li><li>  V3009 Es extra√±o que este m√©todo siempre devuelva uno y el mismo valor de 'verdadero'.  ObjectList.cs 249 </li></ul><br>  <b>Comprobado lo incorrecto</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3019</a> Posiblemente, una variable incorrecta se compara con nulo despu√©s de la conversi√≥n de tipo usando la palabra clave 'as'.  Verifique las variables 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  La variable de <i>valor</i> se <i>convierte</i> al tipo <i>NamingStylePreferences</i> .  El problema est√° en el control que sigue a esto.  Incluso si la variable de <i>valor</i> no es nula, no garantiza que la conversi√≥n de tipos haya sido exitosa y <i>valueToSerialize</i> no contenga <i>nulo</i> .  Posible lanzamiento de la excepci√≥n <i>NullReferenceException</i> .  El c√≥digo debe corregirse de la siguiente manera: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Otro error similar: <br><br>  V3019 Posiblemente, una variable incorrecta se compara con nulo despu√©s de la conversi√≥n de tipo usando la palabra clave 'as'.  Verifique las variables 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  La variable <i>columnState</i> se <i>convierte</i> al tipo <i>ColumnState2</i> .  Sin embargo, el resultado de la operaci√≥n, que es la variable <i>columnState2,</i> no se verifica para <i>nulo</i> adicional.  En cambio, la variable <i>columnState</i> se verifica utilizando el operador <i>nulo</i> condicional.  ¬øPor qu√© es peligroso este c√≥digo?  Al igual que en el ejemplo anterior, la conversi√≥n con el operador <i>as</i> puede fallar y la variable ser√° <i>nula, lo</i> que dar√° como resultado una excepci√≥n.  Por cierto, un error tipogr√°fico puede ser el culpable aqu√≠.  Observe la condici√≥n en el bloque <i>if</i> . <br><br>  Tal vez, en lugar de <i>columnState? .Name,</i> el autor quer√≠a escribir <i>columnState2? .Name</i> .  Es muy probable, considerando nombres de variables bastante defectuosos <i>columnState</i> y <i>columnState2.</i> <br><br>  <b>Cheques redundantes</b> <br><br>  Se emiti√≥ una gran cantidad de advertencias (m√°s de 100) en construcciones no cr√≠ticas pero potencialmente inseguras relacionadas con verificaciones redundantes.  Por ejemplo, este es uno de ellos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3022 La</a> expresi√≥n 'navInfo == null' siempre es falsa.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Puede ser que no haya un error real aqu√≠.  Es solo una buena raz√≥n para demostrar que el "an√°lisis interprocedural + an√°lisis de flujo de datos" funciona en un remolque.  El analizador sugiere que la segunda verificaci√≥n <i>navInfo == null</i> es redundante.  De hecho, antes de eso, el valor asignado a <i>navInfo</i> se obtendr√° del m√©todo <i>libraryService.NavInfoFactory.CreateForProject</i> , que construir√° y devolver√° un nuevo objeto de la clase <i>NavInfo</i> .  De ninguna manera volver√° <i>nulo</i> .  Aqu√≠ surge la pregunta, ¬øpor qu√© el analizador no emiti√≥ una advertencia para la primera verificaci√≥n <i>navInfo == null</i> ?  Hay algunas razones  En primer lugar, si la variable de <i>s√≠mbolo</i> es <i>nula</i> , el valor <i>navInfo</i> seguir√° siendo una referencia nula tambi√©n.  En segundo lugar, incluso si <i>navInfo</i> obtiene el valor del m√©todo <i>ibraryService.NavInfoFactory.CreateForSymbol</i> , este valor tambi√©n puede ser <i>nulo</i> .  Por lo tanto, la primera verificaci√≥n <i>navInfo == null</i> es realmente necesaria. <br><br>  <b>Controles insuficientes</b> <br><br>  Ahora la situaci√≥n inversa de lo discutido anteriormente.  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">activaron</a> varias advertencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3042</a> para el c√≥digo, en el que es posible el acceso por referencia nula.  Incluso uno o dos cheques peque√±os podr√≠an haber solucionado todo. <br><br>  Consideremos otro fragmento de c√≥digo interesante, que tiene dos de esos errores. <br><br>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'receptor' Binder_Expressions.cs 7770 <br><br>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'receptor' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  La variable del <i>receptor</i> puede ser nula.  El autor del c√≥digo sabe de esto, ya que utiliza el operador <i>nulo</i> condicional en la condici√≥n del bloque <i>if</i> para acceder al <i>receptor ?</i> . <i>Sintaxis</i> .  Adem√°s, la variable del <i>receptor</i> se usa sin ninguna comprobaci√≥n para acceder a <i>receptor.Tipo</i> , <i>receptor.Sintaxis</i> y <i>receptor.TieneErrores</i> .  Estos errores deben corregirse: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Tambi√©n debemos asegurarnos de que el constructor admite obtener valores <i>nulos</i> para sus par√°metros o debemos realizar una refactorizaci√≥n adicional. <br><br>  Otros errores similares: <br><br><ul><li>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'contienenType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'expresi√≥n' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Posible NullReferenceException.  El '?.'  y '.'  Los operadores se utilizan para acceder a los miembros del objeto 'expresi√≥n' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Error en la condicion</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3057</a> La funci√≥n ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subcadena</a> ' podr√≠a recibir el valor '-1' mientras se espera un valor no negativo.  Inspeccione el segundo argumento.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  En caso de que la variable de <i>dos puntos</i> sea ‚Äã‚Äã0, lo cual est√° bien de acuerdo con la condici√≥n del c√≥digo, el m√©todo <i>Substring</i> arrojar√° una excepci√≥n.  Esto tiene que ser arreglado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Posible error tipogr√°fico</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> par√°metro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3065</a> 't2' no se utiliza dentro del cuerpo del m√©todo.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  La expresi√≥n lambda acepta dos par√°metros: t1 y t2.  Sin embargo, solo se usa t1.  Parece sospechoso, teniendo en cuenta el hecho de lo f√°cil que es cometer un error al usar variables con tales nombres. <br><br>  <b>Inadvertencia</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3083</a> Invocaci√≥n insegura del evento 'TagsChanged', NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  El evento <i>TagsChanged</i> se invoca de forma insegura.  Entre la comprobaci√≥n de <i>nulo</i> y la invocaci√≥n del evento, alguien puede darse de baja del mismo, luego se lanzar√° una excepci√≥n.  Adem√°s, se realizan otras operaciones en el cuerpo del bloque <i>if</i> justo antes de invocar el evento.  Llam√© a este error "Inadvertencia", porque este evento se maneja con m√°s cuidado en otros lugares, de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  El uso de una variable de <i>controlador</i> adicional evita el problema.  En el m√©todo <i>OnTextBufferChanged,</i> uno tiene que hacer ediciones para manejar el evento de manera segura. <br><br>  <b>Rangos de intersecci√≥n</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3092 Las</a> intersecciones de rango son posibles dentro de expresiones condicionales.  Ejemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} m√°s if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Para una mejor comprensi√≥n, perm√≠tanme reescribir este c√≥digo, cambiando los nombres de las constantes con sus valores reales: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Probablemente, no hay un error real, pero la condici√≥n parece extra√±a.  Su segunda parte ( <i>si no</i> ) se ejecutar√° solo para el rango de 2147483648 + 1 a 4294967295. <br><br>  Otro par de advertencias similares: <br><br><ul><li>  V3092 Las intersecciones de rango son posibles dentro de expresiones condicionales.  Ejemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} m√°s if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Las intersecciones de rango son posibles dentro de expresiones condicionales.  Ejemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} m√°s if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>M√°s sobre cheques para nulo (o falta de ellos)</b> <br><br>  Un par de errores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3095</a> en la comprobaci√≥n de una variable para nulo justo despu√©s de su uso.  El primero es ambiguo, consideremos el c√≥digo. <br><br>  V3095 El objeto 'displayName' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Se supone que la referencia <i>tee</i> puede ser nula.  Para esto, se realiz√≥ la verificaci√≥n <i>Debug.Assert</i> .  No est√° claro por qu√© va despu√©s de usar una cadena.  Tambi√©n debe tenerse en cuenta que para configuraciones diferentes de Debug, el compilador eliminar√° <i>Debug.Assert</i> <i>.</i>  ¬øSignifica que obtener una referencia nula solo es posible para Debug?  Si no es as√≠, ¬øpor qu√© el autor realiz√≥ la comprobaci√≥n de <i>string.IsNullOrEmpty (string)</i> , por ejemplo.  Es la pregunta a los autores del c√≥digo. <br><br>  El siguiente error es m√°s evidente. <br><br>  V3095 El objeto 'scriptArgsOpt' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Creo que este c√≥digo no necesita ninguna explicaci√≥n.  D√©jame darte la versi√≥n fija: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  En el c√≥digo de Roslyn, hubo 15 errores m√°s similares: <br><br><ul><li>  V3095 El objeto 'LocalFunctions' se us√≥ antes de que se verificara contra nulo.  L√≠neas de verificaci√≥n: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 El objeto 'resolution.OverloadResolutionResult' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 El objeto 'resolution.MethodGroup' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 El objeto 'TouchFilesLogger' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 El objeto 'newExceptionRegionsOpt' se us√≥ antes de que se verificara contra nulo.  L√≠neas de verificaci√≥n: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 El objeto 's√≠mbolo' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 El objeto '_state.BaseTypeOrInterfaceOpt' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 El objeto 'elemento' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 El objeto 'idiomas' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 El objeto 'memberType' se us√≥ antes de que se verificara contra nulo.  L√≠neas de verificaci√≥n: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 El objeto 'validTypeDeclarations' se us√≥ antes de que se verificara contra nulo.  L√≠neas de verificaci√≥n: 223, 228. SyntaxTreeExtensions.cs 223 </li><li>  V3095 El objeto 'texto' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 376, 385. MSBuildWorkspace.cs 376 </li><li>  V3095 El objeto 'nameOrMemberAccessExpression' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 206, 223. CSharpGenerateTypeService.cs 206 </li><li>  V3095 El objeto 'simpleName' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 83, 85. CSharpGenerateMethodService.cs 83 </li><li>  V3095 El objeto 'opci√≥n' se us√≥ antes de que se verificara como nulo.  L√≠neas de verificaci√≥n: 23, 28. OptionKey.cs 23 </li></ul><br>  Consideremos los errores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3105</a> .  Aqu√≠, el operador <i>nulo</i> condicional se usa al inicializar la variable, pero adem√°s la variable se usa sin verificaciones para <i>nulo</i> . <br><br>  Dos advertencias indican el siguiente error: <br><br>  V3105 La variable 'documentId' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo.  NullReferenceException es posible.  CodeLensReferencesService.cs 138 <br><br>  V3105 La variable 'documentId' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo.  NullReferenceException es posible.  CodeLensReferencesService.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br>  La variable <i>documentId</i> se puede inicializar por <i>nulo</i> .  Como resultado, la creaci√≥n de un objeto <i>ReferenceLocationDescriptor</i> generar√° una excepci√≥n.  El c√≥digo debe ser arreglado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br>  Los desarrolladores tambi√©n deben cubrir la posibilidad de que las variables, pasadas a un constructor, sean <i>nulas.</i> <br><br>  Otros errores similares en el c√≥digo: <br><br><ul><li>  V3105 La variable 's√≠mbolo' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo.  NullReferenceException es posible.  SymbolFinder_Hierarchy.cs 44 </li><li>  V3105 La variable 's√≠mbolo' se us√≥ despu√©s de que se asign√≥ a trav√©s del operador condicional nulo.  NullReferenceException es posible.  SymbolFinder_Hierarchy.cs 51 </li></ul><br>  <b>Prioridades y par√©ntesis</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3123</a> Quiz√°s el operador '?:' Funciona de una manera diferente a la esperada.  Su prioridad es menor que la prioridad de otros operadores en su condici√≥n.  Edit.cs 70 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br>  La condici√≥n en el bloque de retorno no se eval√∫a seg√∫n lo previsto por el desarrollador.  Se supuso que la primera condici√≥n ser√° <i>_kind == other._kin</i> d, (es por eso que despu√©s de esta condici√≥n hay un salto de l√≠nea), y despu√©s de eso, los bloques de condiciones con el operador " <i>?</i> " Se evaluar√°n en secuencia.  De hecho, la primera condici√≥n es <i>_kind == other._kind &amp;&amp; (_oldNode == null)</i> .  Esto se debe al hecho de que el operador <i>&amp;&amp;</i> tiene mayor prioridad que el operador " <i>?</i> ".  Para solucionar esto, un desarrollador debe tomar todas las expresiones del operador " <i>?</i> " Entre par√©ntesis: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br>  Con esto concluye mi descripci√≥n de los errores encontrados. <br><br>  <b>Conclusi√≥n</b> <br><br>  A pesar de la gran cantidad de errores, que logr√© encontrar, en t√©rminos del tama√±o del c√≥digo del proyecto Roslyn (2,770,000 l√≠neas), no es demasiado.  Como Andrey escribi√≥ en un art√≠culo anterior, tambi√©n estoy listo para reconocer la alta calidad de este proyecto. <br><br>  Me gustar√≠a se√±alar que tales comprobaciones de c√≥digo ocasionales no tienen nada que ver con la metodolog√≠a del an√°lisis est√°tico y son casi in√∫tiles.  El an√°lisis est√°tico debe aplicarse con regularidad, y no caso por caso.  De esta forma, muchos errores se corregir√°n en las primeras etapas y, por lo tanto, el costo de corregirlos ser√° diez veces menor.  Esta idea se expone con m√°s detalle en esta peque√±a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nota</a> , por favor, √©chale un vistazo. <br><br>  Puede comprobar usted mismo algunos errores tanto en este proyecto como en otro.  Para hacer esto, solo necesita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargar</a> y probar nuestro analizador. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446588/">https://habr.com/ru/post/446588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446570/index.html">La historia de la primera GPU: Rendition V√©rit√© 1000</a></li>
<li><a href="../446572/index.html">Editor.js es un excelente editor que guarda el c√≥digo fuente en formato JSON</a></li>
<li><a href="../446576/index.html">Sustituci√≥n de importaciones, o c√≥mo los helic√≥pteros rusos hicieron algo mal</a></li>
<li><a href="../446578/index.html">Lenguaje de programaci√≥n basado en postales</a></li>
<li><a href="../446582/index.html">Reflexiones sobre el alojamiento solar para abejas</a></li>
<li><a href="../446590/index.html">39 nuevas funciones estar√°n disponibles en Java 12</a></li>
<li><a href="../446592/index.html">Comprobando el c√≥digo fuente de Roslyn</a></li>
<li><a href="../446598/index.html">Recreando Fuentes CRT</a></li>
<li><a href="../446602/index.html">Corriente DC m√°xima a trav√©s del transistor de efecto de campo</a></li>
<li><a href="../446604/index.html">ESET: Nuevos esquemas de entrega de puerta trasera Oceanberg de Cybergroup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>