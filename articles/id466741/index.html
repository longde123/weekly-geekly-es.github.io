<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏾 👨‍❤️‍💋‍👨 🖕🏼 Yang terbaik adalah musuh dari yang baik 🔯 👨🏾‍🎤 👨🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah tentang bagaimana sekali kami memutuskan untuk sedikit meningkatkan alat internal SelfTester, yang digunakan untuk memeriksa kualit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Yang terbaik adalah musuh dari yang baik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466741/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Gambar 12" align="left"></p>  Artikel ini adalah tentang bagaimana sekali kami memutuskan untuk sedikit meningkatkan alat internal SelfTester, yang digunakan untuk memeriksa kualitas penganalisa PVS-Studio.  Peningkatannya sederhana dan terlihat bermanfaat, tetapi menciptakan banyak masalah bagi kami, dan kemudian ternyata akan lebih baik jika kami tidak melakukannya. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Kami mengembangkan dan mempromosikan penganalisis kode statis PVS-Studio untuk C, C ++, C # dan Java.  Untuk memeriksa kualitas penganalisa, kami menggunakan alat internal yang secara kolektif disebut SelfTester.  Setiap bahasa yang didukung memiliki versi SelfTester sendiri.  Ini karena fitur pengujian, dan itu hanya lebih nyaman.  Dengan demikian, saat ini, perusahaan kami menggunakan tiga alat SelfTester internal untuk C \ C ++, C # dan Java, masing-masing.  Selanjutnya, saya akan berbicara tentang versi Windows dari SelfTester untuk proyek-proyek Visual Studio C \ C ++, menyebutnya hanya SelfTester.  Penguji ini adalah yang pertama dalam garis alat internal tersebut, ini adalah yang paling canggih dan paling kompleks dari semuanya. <br><br>  Bagaimana cara kerja SelfTester?  Idenya sederhana: ambil kumpulan proyek uji (kami menggunakan proyek open source nyata) dan menganalisanya menggunakan PVS-Studio.  Akibatnya, log peringatan penganalisis dihasilkan untuk setiap proyek.  Log ini dibandingkan dengan log <i>referensi</i> untuk proyek yang sama.  Saat membandingkan log, SelfTester membuat <i>log</i> perbandingan log dalam bentuk yang nyaman untuk dilihat oleh pengembang. <br><br>  Setelah mempelajari buku catatan, pengembang membuat kesimpulan tentang perubahan perilaku penganalisa: jumlah dan sifat peringatan, kecepatan operasi, ada kesalahan penganalisa internal, dll.  Semua informasi ini sangat penting, memungkinkan Anda untuk memahami seberapa baik alat analisis itu melakukan tugasnya. <br><br>  Berdasarkan log perbandingan log, pengembang membuat perubahan pada inti penganalisa (misalnya, ketika membuat aturan diagnostik baru), segera mengendalikan efek suntingannya.  Jika pengembang tidak lagi memiliki pertanyaan tentang perbandingan log berikutnya, maka ia <i>membuat</i> log peringatan <i>saat ini</i> untuk proyek sebagai <i>referensi</i> .  Kalau tidak, pekerjaan terus berlanjut. <br><br>  Jadi, tugas SelfTester adalah bekerja dengan kumpulan proyek uji (ngomong-ngomong, sudah ada lebih dari 120 di antaranya untuk C / C ++).  Proyek-proyek untuk kumpulan dipilih sebagai solusi Visual Studio.  Ini dilakukan untuk menguji penganalisis tambahan pada berbagai versi Visual Studio yang didukung penganalisa (dari Visual Studio 2010 ke Visual Studio 2019 saat ini). <br><br>  <i>Catatan</i> : Saya selanjutnya akan memisahkan konsep <i>solusi</i> dan <i>proyek</i> , memahami proyek sebagai bagian dari solusi, seperti kebiasaan di Visual Studio. <br><br>  Antarmuka SelfTester terlihat seperti: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Gambar 3"></div><br>  Di sebelah kiri adalah daftar solusi, di sebelah kanan adalah hasil tes untuk setiap versi Visual Studio. <br><br>  Tanda abu-abu "Tidak didukung" menunjukkan bahwa solusi tidak mendukung versi Visual Studio yang dipilih atau belum dikonversi untuk versi ini.  Beberapa solusi di kumpulan memiliki pengaturan yang menunjukkan versi spesifik Visual Studio untuk diperiksa.  Jika versi tidak ditentukan, solusi akan diperbarui ke semua versi Visual Studio berikutnya.  Contoh dari solusi seperti itu dalam tangkapan layar adalah "smart_ptr_check.sln" (verifikasi dilakukan untuk semua versi Visual Studio). <br><br>  Tanda "OK" berwarna hijau menunjukkan bahwa pemeriksaan berikutnya tidak mengungkapkan perbedaan dengan log referensi.  Tanda “Diff” berwarna merah menunjukkan perbedaan.  Label-label inilah yang harus diperhatikan pengembang.  Untuk melakukan ini, ia perlu mengklik dua kali pada label yang diinginkan.  Solusi yang dipilih akan dibuka dalam versi Visual Studio yang diinginkan, dan jendela dengan log peringatan juga akan dibuka di sana.  Tombol kontrol di bawah ini memungkinkan Anda untuk memulai kembali analisis dari keputusan yang dipilih atau semua, menetapkan log yang dipilih (atau sekaligus) ke yang standar, dll. <br><br>  Hasil karya SelfTester yang disajikan selalu diduplikasi dalam laporan html (log perbedaan). <br><br>  Selain GUI, SelfTester juga memiliki mode otomatis untuk menjalankan selama pembangunan malam hari.  Namun, pola penggunaan yang biasa adalah peluncuran berulang oleh pengembang selama hari kerja.  Oleh karena itu, salah satu karakteristik penting untuk SelfTester adalah <i>kecepatannya</i> . <br><br>  Mengapa kecepatan itu penting: <br><br><ol><li>  Untuk menjalankan selama tes malam, waktu yang dibutuhkan untuk menyelesaikan setiap langkah sangat penting.  Jelas, semakin cepat tes lulus, semakin baik.  Dan waktu operasi rata-rata SelfTester saat ini melebihi 2 jam; </li><li>  Ketika meluncurkan SelfTester di siang hari, pengembang harus menunggu lebih sedikit untuk hasilnya, yang meningkatkan produktivitas tenaga kerja. </li></ol><br>  Adalah keinginan untuk mempercepat pekerjaan SelfTester yang menyebabkan peningkatan kali ini. <br><br><h2>  Multithreading di SelfTester </h2><br>  SelfTester pada awalnya dibuat sebagai aplikasi multi-utas dengan kemampuan untuk memeriksa beberapa solusi secara paralel.  Satu-satunya batasan adalah bahwa Anda tidak dapat secara bersamaan memeriksa solusi yang sama untuk versi Visual Studio yang berbeda, karena banyak solusi perlu diperbarui ke versi Visual Studio tertentu sebelum memeriksa.  Selama ini, perubahan dilakukan langsung ke <i>file</i> proyek <i>.vcxproj</i> , yang mengarah ke kesalahan saat berjalan secara paralel. <br><br>  Untuk membuat pekerjaan lebih efisien, SelfTester menggunakan penjadwal tugas cerdas yang memungkinkan Anda untuk menetapkan nilai yang sangat terbatas untuk utas paralel dan memeliharanya. <br><br>  Penjadwal digunakan pada dua level.  Yang pertama adalah level <i>solusi</i> , yang digunakan untuk mulai memeriksa solusi <i>.sln menggunakan utilitas PVS-Studio_Cmd.exe</i> .  Di dalam <i>PVS-Studio_Cmd.exe</i> (pada tingkat memeriksa <i>file</i> kode sumber) penjadwal yang sama digunakan, tetapi dengan <i>tingkat</i> pengaturan <i>paralelisme yang</i> berbeda. <br><br>  Tingkat paralelisme adalah parameter yang benar-benar menunjukkan berapa banyak thread paralel yang harus dijalankan secara bersamaan.  Untuk nilai derajat paralelisme pada tingkat keputusan dan file, nilai default <i>empat</i> dan <i>delapan</i> dipilih, masing-masing.  Dengan demikian, jumlah utas paralel untuk implementasi ini harus sama dengan 32 (empat solusi yang diuji secara bersamaan dan delapan file).  Menurut kami, pengaturan ini optimal bagi penganalisis untuk bekerja pada prosesor delapan inti. <br><br>  Pengembang dapat secara mandiri menetapkan nilai lain dari tingkat paralelisme, dengan fokus pada kinerja komputernya atau tugas saat ini.  Jika dia tidak mengatur parameter ini, maka secara default jumlah prosesor logis dari sistem akan dipilih. <br><br>  <i>Catatan</i> : selanjutnya kami akan mempertimbangkan bahwa pekerjaan dilakukan dengan tingkat standar nilai paralelisme. <br><br>  <i>Penjadwal LimitedConcurrencyLevelTaskScheduler</i> diwarisi dari <i>System.Threading.Tasks.TaskScheduler</i> dan disempurnakan untuk memberikan tingkat paralelisme maksimum saat bekerja di atas <i>ThreadPool</i> .  Hierarki Warisan: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>PausableTaskScheduler</i> memungkinkan <i>Anda</i> untuk menghentikan sementara pelaksanaan tugas, dan <i>LimitedConcurrencyLevelTaskScheduler</i> , di samping itu, memberikan kontrol cerdas terhadap antrian tugas dan penjadwalan pelaksanaannya, dengan mempertimbangkan tingkat paralelisme, jumlah tugas terjadwal, dan faktor lainnya.  Penjadwal digunakan ketika memulai tugas <i>System.Threading.Tasks.Task</i> . <br><br><h2>  Prasyarat untuk peningkatan </h2><br>  Implementasi pekerjaan yang dijelaskan di atas memiliki kelemahan: itu tidak optimal ketika bekerja dengan solusi dari berbagai ukuran.  Dan ukuran solusi dalam kumpulan uji <i>sangat</i> berbeda: dari 8 KB hingga 4 GB untuk ukuran folder dengan solusinya, dan dari satu hingga beberapa ribu file kode sumber di masing-masingnya. <br><br>  Penjadwal membuat antrian keputusan secara berurutan, tanpa komponen intelektual.  Biarkan saya mengingatkan Anda bahwa secara default, lebih dari empat solusi tidak dapat diperiksa pada saat yang sama.  Jika saat ini empat solusi besar sedang diperiksa (jumlah file di masing-masing lebih dari delapan), diasumsikan bahwa kami bekerja secara efisien, karena kami menggunakan jumlah utas yang maksimum (32). <br><br>  Tetapi bayangkan situasi yang cukup umum ketika beberapa solusi kecil diuji.  Misalnya, satu solusi besar dan berisi 50 file (maksimum delapan utas akan terlibat), dan tiga lainnya berisi masing-masing tiga, empat dan lima file.  Dalam hal ini, kami hanya menggunakan 20 utas (8 + 3 + 4 + 5).  Kami kurang memanfaatkan waktu prosesor dan penurunan kinerja secara keseluruhan. <br><br>  <i>Catatan</i> : pada kenyataannya, bottleneck, sebagai suatu peraturan, masih merupakan subsistem disk, bukan prosesor. <br><br><h2>  Perbaikan </h2><br>  Peningkatan yang dengan sendirinya menunjukkan dirinya dalam hal ini adalah peringkat daftar solusi yang diajukan untuk verifikasi.  Penting untuk mencapai penggunaan optimal dari sejumlah utas yang dijalankan secara simultan (32) dengan mengirimkan proyek dengan jumlah file yang "benar" untuk verifikasi. <br><br>  Mari kita lihat contoh kita lagi, ketika empat solusi diuji dengan jumlah file berikut di masing-masing: 50, 3, 4, dan 5. Tugas yang memeriksa solusi dari <i>tiga</i> file mungkin akan segera bekerja.  Dan alih-alih itu, akan lebih optimal untuk menambahkan solusi di mana ada delapan file atau lebih (untuk menggunakan maksimal delapan stream yang tersedia untuk solusi ini).  Maka secara total kita akan menggunakan sudah 25 utas (8 + <b>8</b> + 4 + 5).  Tidak buruk.  Namun, tujuh utas masih belum digunakan.  Dan di sini muncul gagasan perbaikan lain, terkait dengan penghapusan pembatasan pada empat utas untuk memeriksa solusi.  Memang, dalam contoh di atas, Anda dapat menambahkan tidak hanya satu, tetapi beberapa solusi, menggunakan sebanyak mungkin semua 32 utas.  Mari kita bayangkan bahwa kita memiliki dua solusi lagi, masing-masing tiga dan empat file.  Menambahkan tugas-tugas ini akan sepenuhnya menutup "celah" di utas yang tidak digunakan, dan akan ada 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ). <br><br>  Saya pikir idenya jelas.  Padahal, implementasi perbaikan ini juga tidak membutuhkan banyak upaya.  Semuanya dilakukan dalam satu hari. <br><br>  Itu perlu untuk memperbaiki kelas tugas: warisan dari <i>System.Threading.Tasks.Task</i> dan menambahkan bidang "berat".  Untuk mengatur bobot solusi, digunakan algoritma sederhana: jika jumlah file dalam solusi kurang dari delapan, maka bobotnya disetel sama dengan nilai ini (misalnya, 5), jika jumlah file lebih dari atau sama dengan delapan, maka bobot yang dipilih sama dengan delapan. <br><br>  Itu juga perlu untuk memperbaiki penjadwal: untuk mengajarnya memilih solusi dengan bobot yang tepat untuk mencapai nilai maksimum 32 utas.  Itu juga perlu untuk memungkinkan alokasi lebih dari empat utas untuk verifikasi simultan solusi. <br><br>  Akhirnya, dibutuhkan langkah awal untuk menganalisis semua solusi kumpulan (evaluasi menggunakan MSBuild API) untuk menghitung dan mengatur bobot solusi (dapatkan jumlah file dengan kode sumber). <br><br><h2>  Hasil </h2><br>  Saya pikir, setelah perkenalan yang begitu panjang, Anda sudah menebak bahwa hasilnya adalah nol. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Gambar 15"></div><br>  Sangat baik bahwa peningkatannya sederhana dan cepat. <br><br>  Nah, sekarang, pada kenyataannya, bagian dari artikel tentang "menciptakan banyak masalah bagi kita" dimulai, dan itu saja. <br><br><h2>  Efek samping </h2><br>  Jadi, hasil negatif juga merupakan hasil.  Ternyata jumlah solusi besar di kolam <i>secara signifikan</i> melebihi jumlah yang kecil (kurang dari delapan file).  Dalam kondisi ini, perbaikan yang dilakukan tidak memiliki efek yang nyata, karena mereka praktis tidak terlihat: verifikasi mereka membutuhkan waktu yang mikroskopis dibandingkan dengan proyek besar. <br><br>  Namun demikian, diputuskan untuk meninggalkan revisi sebagai "tidak mengganggu" dan berpotensi bermanfaat.  Selain itu, kumpulan solusi pengujian terus diisi ulang, sehingga di masa depan, mungkin, situasinya akan berubah. <br><br>  Dan kemudian ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Gambar 5"></div><br>  Salah satu pengembang mengeluh tentang "jatuhnya" SelfTester.  Ya itu terjadi.  Untuk mencegah kesalahan ini agar tidak hilang, insiden internal (tiket) diluncurkan dengan nama "Pengecualian ketika bekerja dengan SelfTester".  Kesalahan terjadi selama evaluasi proyek.  Benar, jendela yang begitu banyak memberi kesaksian tentang masalah ini juga pada penangan kesalahan.  Tapi ini dengan cepat dihilangkan, dan selama minggu berikutnya tidak ada yang rusak.  Tiba-tiba, pengguna lain mengeluh tentang SelfTester.  Dan lagi ke kesalahan evaluasi proyek: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Gambar 8"></div><br>  Tumpukan kali ini berisi informasi yang lebih berguna - kesalahan dalam format xml.  Mungkin, saat memproses file proyek <i>Proto_IRC.vcxproj</i> (perwakilan xml-nya), sesuatu terjadi pada file itu sendiri, sehingga <i>XmlTextReader</i> tidak dapat memprosesnya. <br><br>  Kehadiran dua kesalahan dalam waktu yang cukup singkat membuat kami melihat lebih dekat pada masalahnya.  Selain itu, seperti yang saya katakan di atas, SelfTester sangat aktif digunakan oleh pengembang. <br><br>  Untuk mulai dengan, analisis dibuat dari tempat terakhir musim gugur.  Sayangnya, tidak ada yang mencurigakan yang dapat diidentifikasi.  Untuk berjaga-jaga, mereka meminta pengembang (pengguna SelfTester) waspada dan melaporkan kemungkinan kesalahan. <br><br>  Poin penting: kode tempat kesalahan terjadi digunakan kembali di SelfTester.  Awalnya, ini digunakan untuk mengevaluasi proyek-proyek dalam penganalisa itu sendiri ( <i>PVS-Studio_Cmd.exe</i> ).  Itu sebabnya perhatian terhadap masalah telah tumbuh.  Namun, tidak ada tetes yang sama terjadi pada penganalisa. <br><br>  Sementara itu, tiket tentang masalah dengan SelfTester diisi dengan kesalahan baru: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Gambar 9"></div><br>  Dan lagi <i>XmlException</i> .  Jelas, di suatu tempat ada utas bersaing yang bekerja dengan membaca dan menulis file proyek.  SelfTester bekerja dengan proyek dalam kasus-kasus berikut: <br><br><ol><li>  Evaluasi proyek selama perhitungan awal bobot keputusan: langkah baru yang awalnya menimbulkan kecurigaan; </li><li>  Memutakhirkan proyek ke versi yang diperlukan dari Visual Studio: dilakukan segera sebelum verifikasi (proyek tidak berpotongan dengan cara apa pun) dan tidak boleh memengaruhi pekerjaan; </li><li>  Evaluasi proyek selama verifikasi: mekanisme aman thread debug, yang digunakan kembali dari <i>PVS-Studio_Cmd.exe</i> ; </li><li>  Memulihkan file proyek (mengganti file <i>.vcxproj yang</i> diubah <i>dengan</i> file referensi asli) saat keluar dari SelfTester, karena file proyek dapat diperbarui ke versi Visual Studio yang diperlukan dalam proses: langkah terakhir, yang juga tidak mempengaruhi mekanisme lain. </li></ol><br>  Kecurigaan jatuh pada kode baru yang ditambahkan untuk optimisasi (perhitungan bobot).  Tetapi studi kode ini menunjukkan bahwa jika pengguna memulai analisis segera setelah dimulainya SelfTester, tester selalu benar menunggu akhir evaluasi pendahuluan.  Tempat ini tampak aman. <br><br>  Sekali lagi, kami tidak dapat mengidentifikasi sumber masalah. <br><br><h2>  Nyeri </h2><br>  Selama bulan berikutnya, SelfTester terus turun dari waktu ke waktu.  Tiket diisi ulang dengan data, tetapi tidak jelas apa yang harus dilakukan dengan data ini.  Sebagian besar crash semua dengan <i>XmlException yang</i> sama.  Kadang-kadang ada sesuatu yang lain, tetapi pada kode yang digunakan kembali yang sama dari <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Gambar 1"></div><br>  Secara tradisional, persyaratan yang tidak terlalu tinggi dikenakan pada alat internal, jadi meskipun demikian, kesalahan SelfTester dilakukan berdasarkan residual.  Dari waktu ke waktu, orang-orang yang berbeda saling terhubung (sepanjang waktu kejadian, enam orang menangani masalah ini, termasuk dua orang magang yang dilatih)  Namun demikian, tugas itu harus dialihkan. <br><br>  <i>Kesalahan pertama kami.</i>  Bahkan, di sini sudah mungkin untuk menyelesaikan masalah sekali dan untuk semua.  Bagaimana?  Jelas bahwa kesalahan itu disebabkan oleh optimasi baru.  Bagaimanapun, sebelum itu, semuanya bekerja dengan baik, dan kode yang digunakan kembali jelas tidak bisa seburuk itu.  Apalagi optimasi ini tidak membawa manfaat apa pun.  Jadi apa yang harus dilakukan?  <i>Hapus pengoptimalan ini</i> <b>.</b>  Seperti yang Anda tahu, ini tidak dilakukan.  Kami terus mengerjakan masalah yang telah kami ciptakan sendiri.  Pencarian dilanjutkan untuk jawaban atas pertanyaan: "BAGAIMANA ???"  Bagaimana itu jatuh?  Namun sepertinya ditulis dengan benar. <br><br>  <i>Kesalahan kedua kami.</i>  <i>Orang lain terhubung</i> dengan solusi masalah.  Kesalahan yang sangat, sangat besar.  Sayangnya, ini tidak hanya tidak menyelesaikan masalah, tetapi sumber daya tambahan dikeluarkan.  Ya, orang-orang baru membawa ide-ide baru, tetapi untuk implementasi mereka butuh (benar-benar terbuang) banyak waktu kerja.  Pada tahap tertentu, program pengujian ditulis (oleh peserta yang sama), meniru evaluasi proyek yang sama di utas berbeda dengan modifikasi paralel proyek di utas lain.  Itu tidak membantu.  Selain apa yang sudah kami ketahui sebelumnya, API MSBuild aman di dalamnya, mereka belum menemukan sesuatu yang baru.  Dan di SelfTester, dump mini ditambahkan ketika <i>XmlException</i> dilempar.  Lalu semua orang ini hancur lebur, ngeri.  Diskusi diadakan, banyak hal lain yang tidak perlu dilakukan. <br><br>  <i>Akhirnya, kesalahan ketiga kami</i> .  Tahukah Anda berapa banyak waktu telah berlalu sejak masalah dengan SelfTester muncul dan sampai diselesaikan?  Meski tidak, hitung sendiri.  Insiden ini dibuat pada 09/17/2018 dan ditutup pada 02/20/2019, dan ada lebih dari 40 (empat puluh!) Pesan di sana.  Guys, ini banyak waktu!  Kami <i>mengizinkan diri</i> untuk melakukan IT <i>selama</i> lima bulan.  Pada saat yang sama (secara paralel), kami terlibat dalam mendukung Visual Studio 2019, menambahkan bahasa Jawa, mulai menerapkan standar MISRA C / C ++, meningkatkan penganalisa C #, secara aktif berpartisipasi dalam konferensi, menulis banyak artikel, dll.  Dan semua karya ini tidak menerima waktu pengembang karena kesalahan bodoh SelfTester. <br><br>  Warga negara, belajarlah dari kesalahan kita dan jangan pernah melakukan itu.  Dan kita tidak akan melakukannya. <br><br>  Saya memiliki segalanya. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Gambar 17"></div><br>  Tentu saja, ini adalah lelucon, dan saya akan memberi tahu Anda apa masalahnya dengan SelfTester :) <br><br><h2>  Bingo! </h2><br>  Untungnya, di antara kami adalah orang dengan kesadaran yang paling tidak suram (kolega saya Sergey Vasiliev), yang hanya melihat masalah dari sudut yang sama sekali berbeda (dan juga dia sedikit beruntung).  Bagaimana jika di dalam SelfTester benar-benar baik-baik saja, dan proyek merusak sesuatu dari luar?  Sejalan dengan SelfTester, biasanya tidak ada yang dimulai, dalam beberapa kasus kami mengontrol runtime secara ketat.  Dalam hal ini, "sesuatu" ini hanya bisa merupakan SelfTester itu sendiri, tetapi contoh lain dari itu. <br><br>  Setelah keluar dari SelfTester, aliran memulihkan file proyek dari standar terus bekerja selama beberapa waktu.  Pada titik ini, Anda dapat memulai kembali tester.  Perlindungan terhadap menjalankan beberapa instance SelfTester pada saat yang sama ditambahkan <i>kemudian</i> dan sekarang terlihat seperti ini: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Gambar 16"></div><br>  Tapi kemudian dia pergi. <br><br>  Luar biasa, selama hampir setengah tahun siksaan tidak ada yang memperhatikannya.  Memulihkan proyek dari standar adalah prosedur latar belakang yang cukup cepat, tetapi, sayangnya, tidak cukup cepat agar tidak mengganggu restart SelfTester.  Dan apa yang terjadi saat startup?  Itu benar, menghitung bobot keputusan.  Satu proses menimpa file <i>.vcxproj</i> , sementara yang lain mencoba membacanya.  Hai, <i>XmlException</i> . <br><br>  Sergey mengetahui semua ini ketika dia menambahkan ke tester kemampuan untuk beralih ke mode bekerja dengan satu set log standar.  Kebutuhan untuk ini muncul setelah menambahkan aturan MISRA yang ditetapkan ke penganalisa.  Anda dapat beralih langsung di antarmuka, sementara pengguna melihat jendela: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Gambar 14"></div><br>  Setelah itu SelfTester <i>memulai kembali</i> .  Nah, sebelumnya, tampaknya, pengguna entah bagaimana meniru masalah itu sendiri, memulai penguji lagi. <br><br><h2>  Tanya jawab dan kesimpulan </h2><br>  Tentu saja, kami menghapus, atau lebih tepatnya, menonaktifkan optimasi yang dibuat sebelumnya.  Selain itu, itu jauh lebih mudah daripada melakukan semacam sinkronisasi antara sisa tester itu sendiri.  Dan semuanya mulai bekerja dengan baik, seperti sebelumnya.  Dan sebagai langkah tambahan, perlindungan yang dijelaskan di atas terhadap peluncuran tester secara bersamaan telah ditambahkan. <br><br>  Saya sudah menulis di atas tentang kesalahan utama kami selama mencari masalah, jadi self-flagellation sudah cukup.  Kita adalah manusia juga, dan karena itu kita salah.  Penting untuk belajar dari kesalahan Anda dan menarik kesimpulan.  Kesimpulan di sini cukup sederhana: <br><br><ul><li>  Penting untuk melacak dan mengevaluasi pertumbuhan kompleksitas tugas; </li><li>  Berhenti tepat waktu; </li><li>  Cobalah untuk melihat masalahnya secara lebih luas, karena seiring berjalannya waktu pandangan "kabur", dan sudut pandangnya menyempit; </li><li>  Jangan takut untuk menghapus kode lama atau tidak perlu. </li></ul><br>  Sekarang pasti - itu saja.  Terima kasih sudah membaca.  Untuk semua kode yang tidak ada harapan! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yang terbaik adalah musuh dari yang baik</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466741/">https://habr.com/ru/post/id466741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466731/index.html">Extravaganza. September naik</a></li>
<li><a href="../id466733/index.html">Selamat datang di DINS Java EVENING 18 September</a></li>
<li><a href="../id466735/index.html">Cara mudah untuk membuat peringatan suara di sistem Home Automation ("Smart Home")</a></li>
<li><a href="../id466737/index.html">Mengapa jaringan sosial Google+ gagal</a></li>
<li><a href="../id466739/index.html">Yang terbaik adalah musuh dari yang baik</a></li>
<li><a href="../id466745/index.html">Tempat kerja pertama atau cara mulai mengembangkan API di Node.js</a></li>
<li><a href="../id466747/index.html">Mitap pengembang iOS di Redmadrobot</a></li>
<li><a href="../id466753/index.html">Administrasi Jaringan Cepat dan Efisien - Jaringan MACMonitor</a></li>
<li><a href="../id466755/index.html">Komputer akan membuat Anda enak</a></li>
<li><a href="../id466757/index.html">Mitap Flutter pertama di St. Petersburg - 26 September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>