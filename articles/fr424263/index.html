<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèº üö® ü§ôüèª Mise √† niveau d'IDA Pro. Nous r√©parons les jambages des modules processeurs ‚öõÔ∏è üëàüèø üëçüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous 


 Apr√®s un temps assez long depuis la r√©daction du premier article, j'ai tout de m√™me d√©cid√©, quoique un peu, d'√©crire des articles s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mise √† niveau d'IDA Pro. Nous r√©parons les jambages des modules processeurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424263/"><p><img src="https://habrastorage.org/webt/ew/v2/2v/ewv22vcc4kkpbzrvgthcwqwbge4.png"></p><br><p>  Bonjour √† tous </p><br><p>  Apr√®s un temps assez long depuis la r√©daction du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article,</a> j'ai tout de m√™me d√©cid√©, quoique un peu, d'√©crire des articles sur le th√®me de la modification / am√©lioration d' <strong>IDA Pro</strong> . </p><br><p>  Cet article explique comment fixer correctement les montants dans ces modules de processeur, dont vous n'avez pas la source, mais les montants ne donnent pas en direct.  Malheureusement, tous les probl√®mes r√©pertori√©s ci-dessous ne peuvent pas √™tre attribu√©s aux montants, il est donc peu probable que les d√©veloppeurs les impl√©mentent. <a name="habracut"></a></p><br><h2 id="lokalizuem-bagi">  Nous localisons les bugs </h2><br><p>  Remarque: les erreurs ci-apr√®s seront prises en compte dans le module <em>Motorola M68000</em> (mon pr√©f√©r√© et tr√®s souvent utilis√©). </p><br><p> Donc, le <u>premier cant</u> : l'adressage par rapport au registre <em>PC</em> .  L'erreur est que la liste d√©mont√©e pour de telles instructions n'est pas toujours correcte.  Jetez un ≈ìil √† la capture d'√©cran: <br><img src="https://habrastorage.org/webt/ei/5j/rv/ei5jrvslehyigbplu8dpxxycxua.png"><br>  Il ne semble pas y avoir d'erreur ici.  De plus, sa pr√©sence n'interf√®re pas avec l'analyse.  Mais, l'opcode n'est pas assembl√© correctement.  Regardons le dysasme dans un d√©sassembleur en ligne: <br><img src="https://habrastorage.org/webt/vm/dd/wn/vmddwnrstyww2lzjmuy3zmfppaa.png"><br>  Nous voyons que l'adressage doit √™tre relatif au registre <em>PC</em> , car  L'adresse de destination du lien se situe dans la plage <code>signed short</code> . </p><br><p>  <u>Impossible deux</u> : "miroirs" pour la RAM et certaines autres r√©gions.  Parce que  √âtant donn√© que l'adressage dans <em>m68k est de</em> 24 bits, tous les appels vers les r√©gions sup√©rieures (ou vice versa, inf√©rieures) doivent √™tre redirig√©s vers la m√™me plage que les r√©f√©rences crois√©es. </p><br><p>  <u>Il y a trois</u> cant (plut√¥t, m√™me pas un cant, mais le manque de fonctionnalit√©): les soi-disant √©mulateurs <strong>lineA</strong> ( <em>1010</em> ) et <strong>lineF</strong> ( <em>1111</em> ).  Ce sont de tels opcodes pour lesquels l'ensemble de commandes de base ne suffisait pas, ils doivent donc √™tre trait√©s de mani√®re sp√©ciale par des vecteurs d'interruption.  La taille des opcodes d√©pend uniquement de l'impl√©mentation au niveau du processeur.  Je n'ai vu qu'une impl√©mentation sur deux octets.  Nous ajouterons. </p><br><p>  <u>Jam four</u> : <strong>trap #N Les</strong> instructions ne donnent pas de <em>crefs</em> aux crochets eux-m√™mes. </p><br><p>  <u>Jamb cinq</u> : l'instruction <strong>movea.w</strong> devrait faire une <em>xr√©f</em> compl√®te √† une adresse √† partir d'un lien de <em>mot</em> , mais nous n'avons qu'un num√©ro de <em>mot</em> . </p><br><h2 id="ispravlyaem-bagi-shablon">  Nous corrigeons des bugs (mod√®le) </h2><br><p>  Afin de comprendre comment r√©parer un module processeur sp√©cifique, vous devez comprendre quelles possibilit√©s nous avons sur ce sujet en principe et ce qui constitue un ¬´correctif¬ª. </p><br><p>  En fait, le "fixateur" est un plugin ordinaire.  √áa, c'est un peu comme √ßa, peut √™tre √©crit en <em>Python</em> , mais j'ai tout fait dans les "plus".  Seule la portabilit√© en souffre, mais si quelqu'un s'engage √† r√©√©crire le plugin en <em>Python</em> , je serai tr√®s reconnaissant. </p><br><p>  Tout d'abord, cr√©ez un projet <em>DLL</em> vide dans <em>Visual Studio</em> : <em>Fichier-&gt; Nouveau-&gt; Projet-&gt; Assistant Bureau Windows-&gt; Biblioth√®que de liens dynamiques</em> (.dll), √©galement en cochant la <em>case</em> <em>Projet vide</em> <em>et en d√©cochant le</em> reste: <br><img src="https://habrastorage.org/webt/ni/eg/ak/niegakemj47gtfsgva9kldhywou.png"></p><br><p>  D√©compressez le <em>SDK IDA</em> et √©crivez-le dans les macros <em>Visual Studio</em> (j'utiliserai <em>2017</em> ) afin qu'√† l'avenir vous puissiez facilement le r√©f√©rencer.  Dans le m√™me temps, nous ajouterons une macro pour le chemin vers <em>IDA Pro</em> . </p><br><p>  Allez dans <em>Affichage</em> -&gt; <em>Autres fen√™tres</em> -&gt; <em>Gestionnaire de propri√©t√©s</em> : <br><img src="https://habrastorage.org/webt/59/de/41/59de412a0dc50466086740.png"></p><br><p>  Parce que  nous travaillons avec <em>SDK</em> version <em>7.0</em> , la compilation se fera par compilateur <em>x64</em> .  Par cons√©quent, s√©lectionnez <em>D√©boguer |</em>  <em>x64</em> -&gt; <em>Microsoft.Cpp.x64.user</em> -&gt; <em>Propri√©t√©s</em> : <br><img src="https://habrastorage.org/webt/59/de/42/59de423c59c08942765331.png"></p><br><p>  Cliquez sur le bouton <em>Ajouter une macro</em> dans la section <em>Macros utilisateur</em> et √©crivez-y la macro <strong>IDA_SDK</strong> avec le chemin o√π vous avez d√©compress√© le <em>SDK</em> : <br><img src="https://habrastorage.org/webt/59/de/43/59de43354eef5656763373.png"></p><br><p>  Nous faisons de m√™me avec <strong>IDA_DIR</strong> (le chemin vers votre <em>IDA Pro</em> ): <br><img src="https://habrastorage.org/webt/59/de/43/59de4393df765196799873.png"><br>  Je note que l' <em>IDA</em> est d√©fini par d√©faut sur <em>% Program Files%</em> , ce qui n√©cessite des droits d'administrateur. </p><br><p>  Supprimons √©galement la configuration <em>Win32</em> (dans cet article, je n'affecterai pas la compilation pour <em>les</em> syst√®mes <em>x86</em> ), ne laissant que l'option <em>x64</em> . </p><br><p>  Cr√©ez un fichier <strong>ida_plugin.cpp</strong> vide.  Nous n'ajoutons pas encore de code. <br>  Il est maintenant possible de d√©finir l'encodage et d'autres param√®tres pour <em>C ++</em> : <br><img src="https://habrastorage.org/webt/py/y5/hr/pyy5hrmaodnyg88lqx_nzdtnlfi.png"></p><br><p><img src="https://habrastorage.org/webt/fk/xc/hp/fkxchpgi2jaige5obcmrnupxtny.png"></p><br><p><img src="https://habrastorage.org/webt/_l/tk/wf/_ltkwfmoex1we-lss1o4z8b4bzy.png"></p><br><p>  Nous √©crivons les inclusions: <br><img src="https://habrastorage.org/webt/4j/wg/v1/4jwgv1u0h3-_tyy_jhzix5cevkk.png"></p><br><p>  Et les biblioth√®ques du <em>SDK</em> : <br><img src="https://habrastorage.org/webt/hl/yl/pl/hlylplttumswxacaiw7s8cgxnmg.png"></p><br><p><img src="https://habrastorage.org/webt/yv/vw/az/yvvwaz3lccmj-srbihmk7e3psq8.png"></p><br><p>  Ajoutez maintenant le mod√®le de code: </p><br><div class="spoiler">  <b class="spoiler_title">Code Ida_plugin.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ida.hpp&gt; #include &lt;idp.hpp&gt; #include &lt;ua.hpp&gt; #include &lt;bytes.hpp&gt; #include &lt;loader.hpp&gt; #include &lt;offset.hpp&gt; #define NAME "M68000 proc-fixer plugin" #define VERSION "1.0" static bool plugin_inited; static bool my_dbg; //-------------------------------------------------------------------------- static void print_version() { static const char format[] = NAME " v%s\n"; info(format, VERSION); msg(format, VERSION); } //-------------------------------------------------------------------------- static bool init_plugin(void) { if (ph.id != PLFM_68K) return false; return true; } #ifdef _DEBUG static const char* const optype_names[] = { "o_void", "o_reg", "o_mem", "o_phrase", "o_displ", "o_imm", "o_far", "o_near", "o_idpspec0", "o_idpspec1", "o_idpspec2", "o_idpspec3", "o_idpspec4", "o_idpspec5", }; static const char* const dtyp_names[] = { "dt_byte", "dt_word", "dt_dword", "dt_float", "dt_double", "dt_tbyte", "dt_packreal", "dt_qword", "dt_byte16", "dt_code", "dt_void", "dt_fword", "dt_bitfild", "dt_string", "dt_unicode", "dt_3byte", "dt_ldbl", "dt_byte32", "dt_byte64", }; static void print_insn(const insn_t *insn) { if (my_dbg) { msg("cs=%x, ", insn-&gt;cs); msg("ip=%x, ", insn-&gt;ip); msg("ea=%x, ", insn-&gt;ea); msg("itype=%x, ", insn-&gt;itype); msg("size=%x, ", insn-&gt;size); msg("auxpref=%x, ", insn-&gt;auxpref); msg("segpref=%x, ", insn-&gt;segpref); msg("insnpref=%x, ", insn-&gt;insnpref); msg("insnpref=%x, ", insn-&gt;insnpref); msg("flags["); if (insn-&gt;flags &amp; INSN_MACRO) msg("INSN_MACRO|"); if (insn-&gt;flags &amp; INSN_MODMAC) msg("OF_OUTER_DISP"); msg("]\n"); } } static void print_op(ea_t ea, const op_t *op) { if (my_dbg) { msg("type[%s], ", optype_names[op-&gt;type]); msg("flags["); if (op-&gt;flags &amp; OF_NO_BASE_DISP) msg("OF_NO_BASE_DISP|"); if (op-&gt;flags &amp; OF_OUTER_DISP) msg("OF_OUTER_DISP|"); if (op-&gt;flags &amp; PACK_FORM_DEF) msg("PACK_FORM_DEF|"); if (op-&gt;flags &amp; OF_NUMBER) msg("OF_NUMBER|"); if (op-&gt;flags &amp; OF_SHOW) msg("OF_SHOW"); msg("], "); msg("dtyp[%s], ", dtyp_names[op-&gt;dtype]); if (op-&gt;type == o_reg) msg("reg=%x, ", op-&gt;reg); else if (op-&gt;type == o_displ || op-&gt;type == o_phrase) msg("phrase=%x, ", op-&gt;phrase); else msg("reg_phrase=%x, ", op-&gt;phrase); msg("addr=%x, ", op-&gt;addr); msg("value=%x, ", op-&gt;value); msg("specval=%x, ", op-&gt;specval); msg("specflag1=%x, ", op-&gt;specflag1); msg("specflag2=%x, ", op-&gt;specflag2); msg("specflag3=%x, ", op-&gt;specflag3); msg("specflag4=%x, ", op-&gt;specflag4); msg("refinfo["); opinfo_t buf; if (get_opinfo(&amp;buf, ea, op-&gt;n, op-&gt;flags)) { msg("target=%x, ", buf.ri.target); msg("base=%x, ", buf.ri.base); msg("tdelta=%x, ", buf.ri.tdelta); msg("flags["); if (buf.ri.flags &amp; REFINFO_TYPE) msg("REFINFO_TYPE|"); if (buf.ri.flags &amp; REFINFO_RVAOFF) msg("REFINFO_RVAOFF|"); if (buf.ri.flags &amp; REFINFO_PASTEND) msg("REFINFO_PASTEND|"); if (buf.ri.flags &amp; REFINFO_CUSTOM) msg("REFINFO_CUSTOM|"); if (buf.ri.flags &amp; REFINFO_NOBASE) msg("REFINFO_NOBASE|"); if (buf.ri.flags &amp; REFINFO_SUBTRACT) msg("REFINFO_SUBTRACT|"); if (buf.ri.flags &amp; REFINFO_SIGNEDOP) msg("REFINFO_SIGNEDOP"); msg("]"); } msg("]\n"); } } #endif static bool ana_addr = 0; static ssize_t idaapi hook_idp(void *user_data, int notification_code, va_list va) { switch (notification_code) { case processor_t::ev_ana_insn: { insn_t *out = va_arg(va, insn_t*); if (ana_addr) break; ana_addr = 1; if (ph.ana_insn(out) &lt;= 0) { ana_addr = 0; break; } ana_addr = 0; #ifdef _DEBUG print_insn(out); #endif for (int i = 0; i &lt; UA_MAXOP; ++i) { op_t &amp;op = out-&gt;ops[i]; #ifdef _DEBUG print_op(out-&gt;ea, &amp;op); #endif } return out-&gt;size; } break; case processor_t::ev_emu_insn: { const insn_t *insn = va_arg(va, const insn_t*); } break; case processor_t::ev_out_mnem: { outctx_t *outbuffer = va_arg(va, outctx_t *); //outbuffer-&gt;out_custom_mnem(mnem); //return 1; } break; default: { #ifdef _DEBUG if (my_dbg) { msg("msg = %d\n", notification_code); } #endif } break; } return 0; } //-------------------------------------------------------------------------- static int idaapi init(void) { if (init_plugin()) { plugin_inited = true; my_dbg = false; hook_to_notification_point(HT_IDP, hook_idp, NULL); print_version(); return PLUGIN_KEEP; } return PLUGIN_SKIP; } //-------------------------------------------------------------------------- static void idaapi term(void) { if (plugin_inited) { unhook_from_notification_point(HT_IDP, hook_idp); plugin_inited = false; } } //-------------------------------------------------------------------------- static bool idaapi run(size_t /*arg*/) { return false; } //-------------------------------------------------------------------------- const char comment[] = NAME; const char help[] = NAME; //-------------------------------------------------------------------------- // // PLUGIN DESCRIPTION BLOCK // //-------------------------------------------------------------------------- plugin_t PLUGIN = { IDP_INTERFACE_VERSION, PLUGIN_PROC | PLUGIN_MOD, // plugin flags init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // long comment about the plugin // it could appear in the status line // or as a hint help, // multiline help about the plugin NAME, // the preferred short name of the plugin "" // the preferred hotkey to run the plugin };</span></span></span></span></code> </pre> </div></div><br><h2 id="ispravlyaem-bagi-razbiraemsya-v-shablone">  Nous corrigeons des bugs (nous comprenons le mod√®le) </h2><br><p>  Les fonctions <code>print_op()</code> et <code>print_insn()</code> sont n√©cessaires pour comprendre quels drapeaux sont d√©finis par le module processeur actuel pour certaines instructions.  Ceci est n√©cessaire si nous voulons trouver des drapeaux pour les opcodes existants, puis les utiliser lors de la correction. </p><br><p>  En fait, le corps de notre "correction" est la fonction <code>hook_idp()</code> .  Dans ce document, pour nos besoins, nous devons impl√©menter trois rappels: </p><br><ol><li>  <code>processor_t::ev_ana_insn</code> : n√©cessaire s'il n'y a pas d'impl√©mentation de certains opcodes dans le module processeur </li><li>  <code>processor_t::ev_emu_insn</code> : ici, vous pouvez cr√©er des r√©f√©rences crois√©es sur les donn√©es / code, qui sont r√©f√©renc√©es par de nouveaux opcodes (ou les anciens ne sont pas r√©f√©renc√©s) </li><li>  <code>processor_t::ev_out_mnem</code> : de nouveaux opcodes doivent en quelque sorte √™tre sortis.  Tout est l√† </li></ol><br><p>  La fonction <code>init_plugin()</code> notre patch de se charger dans d'autres modules de processeur. <br>  Eh bien, et le plus important - nous raccrochons tout le rappel sur les √©v√©nements du module processeur: </p><br><pre> <code class="cpp hljs">hook_to_notification_point(HT_IDP, hook_idp, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br><blockquote>  L'astuce avec la variable globale <code>ana_addr</code> n√©cessaire pour que <code>ana_insn</code> n'entre pas en r√©cursivit√© lorsque vous essayez d'obtenir des informations sur une instruction que nous n'analysons pas manuellement.  Oui, h√©las, cette ¬´b√©quille¬ª dure tr√®s longtemps, m√™me par rapport aux anciennes versions. </blockquote><br><h3 id="ispravlenie-dlya-problemy-1">  Correction du probl√®me num√©ro 1 </h3><br><p>  Afin de r√©soudre correctement ce probl√®me, j'ai d√ª bricoler beaucoup avec la premi√®re conclusion, que je viens de mettre en ≈ìuvre pour cette t√¢che.  Je savais que dans certains cas, l' <em>IDA</em> affiche avec succ√®s des liens sur le <em>PC</em> (dans les instructions o√π il y a un saut sur la table de d√©calage, qui n'est pas loin de l'instruction actuelle, plus un index de cas), mais pour l'instruction <code>lea</code> , le mappage d'adresse n'est pas correctement impl√©ment√©.  En cons√©quence, j'ai trouv√© une telle instruction de saut et j'ai d√©couvert quels drapeaux doivent √™tre d√©finis pour que le <em>PC</em> avec crochets s'affiche: </p><br><p><img src="https://habrastorage.org/webt/gn/x3/uu/gnx3uu3rcfu50sk0avayghnpvgm.png"></p><br><div class="spoiler">  <b class="spoiler_title">R√©soudre le probl√®me num√©ro 1</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_ana_insn: { <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> *out = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ana_addr) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ana_addr = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ph.ana_insn(out) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { ana_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ana_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; UA_MAXOP; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">op_t</span></span> &amp;op = out-&gt;ops[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_near: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_mem: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (out-&gt;itype != <span class="hljs-number"><span class="hljs-number">0x76</span></span> || op.n != <span class="hljs-number"><span class="hljs-number">0</span></span> || (op.phrase != <span class="hljs-number"><span class="hljs-number">0x09</span></span> &amp;&amp; op.phrase != <span class="hljs-number"><span class="hljs-number">0x0A</span></span>) || (op.addr == <span class="hljs-number"><span class="hljs-number">0</span></span> || op.addr &gt;= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">23</span></span>)) || op.specflag1 != <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// lea table(pc),Ax break; short diff = op.addr - out-&gt;ea; if (diff &gt;= SHRT_MIN &amp;&amp; diff &lt;= SHRT_MAX) { out-&gt;Op1.type = o_displ; out-&gt;Op1.offb = 2; out-&gt;Op1.dtype = dt_dword; out-&gt;Op1.phrase = 0x5B; out-&gt;Op1.specflag1 = 0x10; } } break; } } return out-&gt;size; } break;</span></span></code> </pre> </div></div><br><h3 id="ispravlenie-dlya-problemy-2">  Correction du probl√®me num√©ro 2 </h3><br><p>  Ici, tout est simple.  <em>Masquez</em> simplement les adresses dans une plage sp√©cifique: <em>0xFF0000-0xFFFFFF</em> (pour la RAM) et <em>0xC00000-0xC000FF</em> (pour la m√©moire vid√©o <em>VDP</em> ).  L'essentiel ici est de filtrer par type d'op√©rande <code>o_near</code> et <code>o_mem</code> . </p><br><div class="spoiler">  <b class="spoiler_title">R√©soudre le probl√®me num√©ro 2</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_ana_insn: { <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> *out = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ana_addr) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ana_addr = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ph.ana_insn(out) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { ana_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ana_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; UA_MAXOP; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">op_t</span></span> &amp;op = out-&gt;ops[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_near: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_mem: { op.addr &amp;= <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">// for any mirrors if ((op.addr &amp; 0xE00000) == 0xE00000) // RAM mirrors op.addr |= 0x1F0000; if ((op.addr &gt;= 0xC00000 &amp;&amp; op.addr &lt;= 0xC0001F) || (op.addr &gt;= 0xC00020 &amp;&amp; op.addr &lt;= 0xC0003F)) // VDP mirrors op.addr &amp;= 0xC000FF; } break; } } return out-&gt;size; } break;</span></span></code> </pre> </div></div><br><h3 id="ispravlenie-dlya-problemy-3">  Correction du probl√®me num√©ro 3 </h3><br><p>  En fait, pour ajouter l'opcode souhait√©, vous devez: </p><br><ol><li>  D√©finissez des indices pour de nouveaux opcodes.  Tous les nouveaux index doivent commencer par <code>CUSTOM_INSN_ITYPE</code> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m68k_insn_type_t</span></span> { M68K_linea = CUSTOM_INSN_ITYPE, M68K_linef, };</code> </pre> </li><li>  <strong>Les</strong> opcodes <strong>lineA</strong> / <strong>lineF</strong> sont d√©clench√©s si des octets sont trouv√©s dans le code: <strong>0xA0</strong> / <strong>0xF0</strong> .  Nous lisons donc un octet </li><li>  Obtenez un lien vers un vecteur de gestionnaire.  Dans les 64 premiers m√®tres de l'en-t√™te, dans mon cas, il y a des vecteurs d'interruption.  Aux positions <strong>0x0A</strong> et <strong>0x0B, il</strong> y a des <strong>gestionnaires lineA</strong> / <strong>lineF</strong> : <br><pre> <code class="cpp hljs">value = get_dword(<span class="hljs-number"><span class="hljs-number">0x0A</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint32)); <span class="hljs-comment"><span class="hljs-comment">// ... value = get_dword(0x0B * sizeof(uint32));</span></span></code> </pre> </li><li>  Dans <code>ev_emu_insn</code> ajoutez des <code>ev_emu_insn</code> aux gestionnaires et √† l'instruction suivante afin que le <em>flux de code</em> ne <em>soit</em> pas interrompu: <br><pre> <code class="cpp hljs"> insn-&gt;add_cref(insn-&gt;Op1.addr, <span class="hljs-number"><span class="hljs-number">0</span></span>, fl_CN); <span class="hljs-comment"><span class="hljs-comment">// code ref insn-&gt;add_cref(insn-&gt;ea + insn-&gt;size, insn-&gt;Op1.offb, fl_F); // flow ref</span></span></code> </pre> </li><li>  Dans <code>ev_out_mnem</code> notre opcode personnalis√©: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *mnem = (outbuffer-&gt;insn.itype == M68K_linef) ? <span class="hljs-string"><span class="hljs-string">"line_f"</span></span> : <span class="hljs-string"><span class="hljs-string">"line_a"</span></span>; outbuffer-&gt;out_custom_mnem(mnem);</code> </pre> </li></ol><br><p><img src="https://habrastorage.org/webt/yf/uy/dz/yfuydznfymnf5sxkpz_bco9_szo.png"></p><br><div class="spoiler">  <b class="spoiler_title">Solution au probl√®me 3</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m68k_insn_type_t</span></span> { M68K_linea = CUSTOM_INSN_ITYPE, M68K_linef, }; <span class="hljs-comment"><span class="hljs-comment">/* after includes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_ana_insn: { <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> *out = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ana_addr) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; uint16 itype = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> value = out-&gt;ea; uchar b = get_byte(out-&gt;ea); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-number"><span class="hljs-number">0xA0</span></span> || b == <span class="hljs-number"><span class="hljs-number">0xF0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (b) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xA0</span></span>: itype = M68K_linea; value = get_dword(<span class="hljs-number"><span class="hljs-number">0x0A</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint32)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xF0</span></span>: itype = M68K_linef; value = get_dword(<span class="hljs-number"><span class="hljs-number">0x0B</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint32)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } out-&gt;itype = itype; out-&gt;size = <span class="hljs-number"><span class="hljs-number">2</span></span>; out-&gt;Op1.type = o_near; out-&gt;Op1.offb = <span class="hljs-number"><span class="hljs-number">1</span></span>; out-&gt;Op1.dtype = dt_dword; out-&gt;Op1.addr = value; out-&gt;Op1.phrase = <span class="hljs-number"><span class="hljs-number">0x0A</span></span>; out-&gt;Op1.specflag1 = <span class="hljs-number"><span class="hljs-number">2</span></span>; out-&gt;Op2.type = o_imm; out-&gt;Op2.offb = <span class="hljs-number"><span class="hljs-number">1</span></span>; out-&gt;Op2.dtype = dt_byte; out-&gt;Op2.value = get_byte(out-&gt;ea + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out-&gt;size; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_emu_insn: { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> *insn = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (insn-&gt;itype == M68K_linea || insn-&gt;itype == M68K_linef) { insn-&gt;add_cref(insn-&gt;Op1.addr, <span class="hljs-number"><span class="hljs-number">0</span></span>, fl_CN); insn-&gt;add_cref(insn-&gt;ea + insn-&gt;size, insn-&gt;Op1.offb, fl_F); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_out_mnem: { <span class="hljs-keyword"><span class="hljs-keyword">outctx_t</span></span> *outbuffer = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">outctx_t</span></span> *); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outbuffer-&gt;insn.itype != M68K_linea &amp;&amp; outbuffer-&gt;insn.itype != M68K_linef) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *mnem = (outbuffer-&gt;insn.itype == M68K_linef) ? <span class="hljs-string"><span class="hljs-string">"line_f"</span></span> : <span class="hljs-string"><span class="hljs-string">"line_a"</span></span>; outbuffer-&gt;out_custom_mnem(mnem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> </div></div><br><h3 id="ispravlenie-dlya-problemy-4">  Correction du probl√®me 4 </h3><br><p>  Il est r√©solu de cette fa√ßon: nous trouvons l'opcode pour l'instruction <code>trap</code> , nous obtenons l'index de l'instruction, et nous prenons un vecteur gestionnaire de cet index.  Vous obtenez quelque chose comme √ßa: </p><br><p><img src="https://habrastorage.org/webt/nx/kx/lp/nxkxlp9clt0duvzifv_sfuikk0y.png"></p><br><div class="spoiler">  <b class="spoiler_title">Solution au probl√®me 4</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_emu_insn: { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> *insn = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (insn-&gt;itype == <span class="hljs-number"><span class="hljs-number">0xB6</span></span>) <span class="hljs-comment"><span class="hljs-comment">// trap #X { qstring name; ea_t trap_addr = get_dword((0x20 + (insn-&gt;Op1.value &amp; 0xF)) * sizeof(uint32)); get_func_name(&amp;name, trap_addr); set_cmt(insn-&gt;ea, name.c_str(), false); insn-&gt;add_cref(trap_addr, insn-&gt;Op1.offb, fl_CN); return 1; } } break;</span></span></code> </pre> </div></div><br><h3 id="ispravlenie-dlya-problemy-5">  Correction du probl√®me num√©ro 5 </h3><br><p>  Ici aussi, tout est simple: tout d'abord, filtrer par op√©ration <code>movea.w</code> .  Ensuite, si l'op√©rande est du type mot, et fait r√©f√©rence √† la RAM, nous faisons une r√©f√©rence de fa√ßon abrupte, par rapport √† la base 0xFF0000.  Cela ressemblera √† ceci: </p><br><p><img src="https://habrastorage.org/webt/m3/6f/m7/m36fm7jynpygy2m8gs61yi2owyo.png"></p><br><div class="spoiler">  <b class="spoiler_title">R√©soudre le probl√®me num√©ro 5</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_ana_insn: { <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> *out = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ana_addr) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ana_addr = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ph.ana_insn(out) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { ana_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ana_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; UA_MAXOP; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">op_t</span></span> &amp;op = out-&gt;ops[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_imm: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (out-&gt;itype != <span class="hljs-number"><span class="hljs-number">0x7F</span></span> || op.n != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// movea break; if (op.value &amp; 0xFF0000 &amp;&amp; op.dtype == dt_word) { op.value &amp;= 0xFFFF; } } break; } } return out-&gt;size; } break; case processor_t::ev_emu_insn: { const insn_t *insn = va_arg(va, const insn_t*); for (int i = 0; i &lt; UA_MAXOP; ++i) { const op_t &amp;op = insn-&gt;ops[i]; switch (op.type) { case o_imm: { if (insn-&gt;itype != 0x7F || op.n != 0 || op.dtype != dt_word) // movea break; op_offset(insn-&gt;ea, op.n, REF_OFF32, BADADDR, 0xFF0000); } break; } } } break;</span></span></code> </pre> </div></div><br><h2 id="vyvody">  Conclusions </h2><br><p>  En fait, la r√©paration des modules existants n'est pas une t√¢che tr√®s simple, si elle concerne non seulement l'impl√©mentation d'opcodes inconnus, mais quelque chose de plus compliqu√©. <br>  Il faut plusieurs heures pour d√©boguer l'impl√©mentation existante, une compr√©hension de ce qui s'y passe (parfois m√™me l'inverse du module de pourcentage).  Mais le r√©sultat en vaut la peine. </p><br><p>  Lien vers la source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/lab313ru/m68k_fixer</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424263/">https://habr.com/ru/post/fr424263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424251/index.html">Nous consid√©rons les statistiques sur les exp√©riences sur hh.ru</a></li>
<li><a href="../fr424255/index.html">Comment utiliser correctement l'analyse statique</a></li>
<li><a href="../fr424257/index.html">Cartes hexagonales dans Unity: parties 1 √† 3</a></li>
<li><a href="../fr424259/index.html">Security Week 36: Telnet devrait √™tre ferm√©</a></li>
<li><a href="../fr424261/index.html">Comment r√©soudre tout probl√®me de programmation</a></li>
<li><a href="../fr424265/index.html">Test du v√©lo √©lectrique Twitter Mantis E-1</a></li>
<li><a href="../fr424267/index.html">Comment d√©boguer un ECS auto-√©crit dans un navigateur sur un serveur de jeu</a></li>
<li><a href="../fr424271/index.html">Exploration de donn√©es Pubmed et Pubchem - bases de donn√©es d'informations m√©dicales et biochimiques</a></li>
<li><a href="../fr424273/index.html">Bo√Æte de vitesses √† un √©tage entra√Æn√©e par un moteur pas √† pas</a></li>
<li><a href="../fr424275/index.html">L'√©nergie dans la cellule. Utilisation et stockage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>