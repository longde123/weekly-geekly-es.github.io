<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚öïÔ∏è ‚ôêÔ∏è üëáüèª Pensamentos sobre C ++ moderno e desenvolvimento de jogos üßïüèº üö¢ üíáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O novo ano para desenvolvedores de jogos come√ßou com uma onda de cr√≠ticas que ca√≠ram sobre o comit√™ de padroniza√ß√£o de C ++ ap√≥s a publica√ß√£o de Recla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamentos sobre C ++ moderno e desenvolvimento de jogos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435036/">  <i>O novo ano para desenvolvedores de jogos come√ßou com uma onda de cr√≠ticas que ca√≠ram sobre o comit√™ de padroniza√ß√£o de C ++ ap√≥s a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o de Reclama√ß√µes de Aras Prankevichus sobre o Modern C ++</a> .</i>  <i>Surgiu uma pergunta s√©ria: o comit√™ de padr√µes realmente perdeu o contato com a realidade, ou √© o contr√°rio, e esses desenvolvedores de jogos est√£o se afastando do resto da comunidade C ++?</i> <i><br><br></i>  <i>N√≥s oferecemos uma tradu√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">popular post de</a> Ben Dean, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">veterano da ind√∫stria de jogos</a> , que trabalhou por um longo tempo na Blizzard, Electronic Arts e Bullfrog como desenvolvedor de C ++ e l√≠der de equipe, no qual ele responde √†s cr√≠ticas do ponto de vista de sua pr√≥pria experi√™ncia.</i> <br><blockquote> TL; DR: O Comit√™ de Padroniza√ß√£o do C ++ n√£o tem o objetivo oculto de ignorar as necessidades dos desenvolvedores de jogos, e o C ++ "moderno" n√£o se tornar√° uma linguagem "depurada". </blockquote>  Durante a semana passada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> houve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma discuss√£o ativa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Twitter</a> , durante a qual muitos programadores - especialmente aqueles que trabalham no campo do desenvolvimento de jogos - disseram que o atual vetor de desenvolvimento do "C ++ moderno" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o atende √†s suas necessidades</a> .  Em particular, do ponto de vista de um desenvolvedor de jogos comum, tudo parece que o desempenho da depura√ß√£o no idioma √© ignorado e a otimiza√ß√£o do c√≥digo se torna esperada e necess√°ria. <br><br>  Devido ao fato de que em 2019 eu consegui trabalhar na ind√∫stria de jogos por mais de 23 anos, tenho minha pr√≥pria opini√£o com base em observa√ß√µes sobre esse t√≥pico em rela√ß√£o ao desenvolvimento de jogos, que gostaria de compartilhar.  A depura√ß√£o √© importante para os desenvolvedores de jogos e por qu√™?  Quais s√£o os problemas associados a ele? <br><br>  Para come√ßar - uma pequena digress√£o na hist√≥ria. <br><a name="habracut"></a><br>  Muitos desenvolvedores de jogos em C ++ trabalham no Microsoft Visual C ++.  Historicamente, um enorme mercado de jogos se formou em torno das plataformas Microsoft, e isso afetou a experi√™ncia t√≠pica de um programador de jogos comum.  Nos anos 90 e 2000, a maioria dos jogos foi escrita com essas circunst√¢ncias em mente.  Mesmo com o advento de consoles de outros fabricantes e a crescente popularidade de jogos para celular, os ativos de muitos est√∫dios AAA e de v√°rios programadores de jogos hoje em dia s√£o ferramentas feitas pela Microsoft. <br><br>  O Visual Studio √© sem d√∫vida o melhor depurador de C ++ do mundo.  Al√©m disso, o Visual Studio realmente se destaca mais em termos de depura√ß√£o de programas - mais do que com seu front-end, back-end, implementa√ß√£o STL ou qualquer outra coisa.  Nos √∫ltimos cinco anos, a Microsoft fez progressos significativos no desenvolvimento de ferramentas de desenvolvimento em C ++, mas mesmo antes disso, o depurador no Visual Studio sempre foi muito legal.  Portanto, quando voc√™ est√° desenvolvendo em um PC com Windows, sempre tem um depurador de classe mundial dispon√≠vel. <br><br>  Dado o exposto, vejamos o processo de obten√ß√£o de c√≥digo no qual n√£o haver√° bugs;  oportunidades que temos do ponto de vista de um programador que n√£o lida com jogos;  bem como as limita√ß√µes enfrentadas pelos desenvolvedores de jogos.  Se voc√™ reformular o argumento principal em favor do "vetor de desenvolvimento do C ++ moderno", ele ser√° reduzido a tipos, ferramentas e testes.  Seguindo esse pensamento, o depurador deve ser a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltima linha de defesa</a> .  Antes de alcan√ß√°-lo, temos as seguintes op√ß√µes. <br><br><h3>  Oportunidade N¬∫ 1: Tipos </h3><br>  Podemos usar a digita√ß√£o forte necess√°ria para eliminar classes inteiras de bugs em tempo de compila√ß√£o.  A digita√ß√£o forte √©, sem d√∫vida, uma oportunidade que a recente evolu√ß√£o do C ++ nos proporcionou;  por exemplo, come√ßando com o C ++ 11, conseguimos: <br><br><ul><li> extens√£o significativa de <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">type traits</a></code> de <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">type traits</a></code> ; </li><li>  inova√ß√µes como <code>nullptr</code> e <code>scoped enum</code> com <code>scoped enum</code> para combater a heran√ßa C - tipagem fraca; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GSL</a> e ferramentas auxiliares; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conceitos</a> em C ++ 20. </li></ul><br>  Alguns de voc√™s podem n√£o gostar da metaprograma√ß√£o de modelos;  outros podem n√£o gostar do estilo de codifica√ß√£o que usa o <code>auto</code> quase universalmente.  Independentemente dessas prefer√™ncias, o principal motivo para usar os estilos listados em C ++ √© claramente tra√ßado aqui - este √© o desejo de ajudar o compilador para que, por sua vez, possa nos ajudar, usando ao mesmo tempo o que sabe melhor: o sistema de tipos. <br><br>  Se falamos sobre programa√ß√£o de jogos, a digita√ß√£o forte aqui √© um amplo campo de pesquisa, e √© ativamente usada por programadores de jogos familiares a mim, interessados ‚Äã‚Äãem melhorar suas habilidades no uso de C ++ na pr√°tica.  Duas coisas importantes s√£o preocupantes aqui: o efeito no tempo de compila√ß√£o e o efeito na legibilidade do c√≥digo. <br><br>  Francamente, voc√™ pode facilmente ignorar o tempo de compila√ß√£o - mas apenas com a condi√ß√£o de ser um programador de uma empresa muito grande que n√£o joga jogos e tem uma infraestrutura interna estabelecida e um poder de computa√ß√£o sem fim para compilar qualquer c√≥digo que voc√™ possa escrever .  Essas grandes empresas est√£o preocupadas com o custo da compila√ß√£o - portanto, usam m√≥dulos - mas, como regra, isso n√£o causa problemas para desenvolvedores individuais.  Ao mesmo tempo, para a maioria dos programadores de jogos, esse n√£o √© o caso.  Os desenvolvedores independentes n√£o t√™m fazendas para construir;  Os desenvolvedores de jogos AAA geralmente usam algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Incredibuild</a> , mas, como podem trabalhar facilmente com uma base de c√≥digo com 10 anos ou mais, o processo de compila√ß√£o ainda pode levar de 15 a 20 minutos. <br><br>  Podemos discutir sobre o custo relativo da adi√ß√£o de hardware versus o custo do tempo do programador, e concordo com a opini√£o de que o hardware √© mais barato: <br><br><ul><li>  O hardware √© uma despesa real real que ser√° alocada ao or√ßamento do trimestre atual, em contraste com as despesas n√£o t√£o tang√≠veis em tempo / contrata√ß√£o / semelhantes, que ser√£o alocadas por um per√≠odo mais longo.  As pessoas n√£o lidam bem com a decis√£o em favor de tal compromisso, e as empresas s√£o constru√≠das especialmente para otimizar o lucro a curto prazo. </li><li>  A infraestrutura requer suporte e quase ningu√©m entra na ind√∫stria de jogos para se tornar um engenheiro de lan√ßamento.  Comparado a outras √°reas em que o C ++ √© usado, o sal√°rio dos desenvolvedores de jogos n√£o √© t√£o alto - e os engenheiros que n√£o s√£o de jogos s√£o pagos ainda menos aqui. </li></ul><br>  Tamb√©m se pode especular sobre o fato de que o tempo de compila√ß√£o nunca deveria ter atingido tal estado;  e novamente eu concordo com voc√™.  O pre√ßo disso √© vigil√¢ncia constante - novamente, proveniente de um engenheiro de lan√ßamento - e, idealmente, alguma ferramenta automatizada que permite acompanhar as altera√ß√µes no tempo necess√°rio para construir a constru√ß√£o.  Felizmente, com o advento dos sistemas de CI, esse objetivo pode ser alcan√ßado muito mais facilmente hoje. <br><br><h3>  Oportunidade No. 2: Ferramentas </h3><br>  Devemos usar o m√°ximo de ferramentas dispon√≠veis - avisos, an√°lises est√°ticas, desinfetantes, ferramentas de an√°lise din√¢mica, criadores de perfil e outros. <br><br>  Minha experi√™ncia √© que os desenvolvedores de jogos usam essas ferramentas sempre que poss√≠vel, mas aqui a ind√∫stria como um todo tem v√°rios problemas: <br><br><ul><li>  Essas ferramentas tendem a funcionar melhor em plataformas que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o s√£o da Microsoft</a> - e, como mencionado anteriormente, esse n√£o √© um cen√°rio t√≠pico de desenvolvimento de jogos. </li><li>  A maioria dessas ferramentas visa trabalhar com C ++ "padr√£o".  Eles <code>CStaticVector</code> suportam <code>std::vector</code> , mas n√£o minha classe auto-escrita <code>CStaticVector</code> de um mecanismo hipot√©tico.  Obviamente, culpar as ferramentas √© in√∫til, mas essa ainda √© uma das barreiras ao uso que os desenvolvedores precisam superar. </li><li>  Criar e manter uma cadeia de ICs que executar√° todas essas ferramentas requer a presen√ßa de engenheiros de lan√ßamento - e, como mencionado anteriormente, contratar pessoas para trabalhos de engenharia que n√£o estejam diretamente relacionados a jogos √© um problema sist√™mico para a ind√∫stria de jogos. </li></ul><br>  Portanto, como essas ferramentas funcionam t√£o bem com C ++ padr√£o, por que os desenvolvedores de jogos n√£o usam STL? <br><br>  Por onde come√ßar a resposta a esta pergunta?  Talvez, da pr√≥xima excurs√£o √† hist√≥ria do desenvolvimento de jogos: <br><br><ul><li>  At√© o in√≠cio dos anos 90, n√£o confi√°vamos nos compiladores C, por isso escrev√≠amos jogos em assembler. </li><li>  Desde o in√≠cio at√© meados dos anos 90, come√ßamos a confiar nos compiladores C, mas ainda n√£o confi√°vamos nos compiladores C ++.  Nosso c√≥digo era C, que usava coment√°rios no estilo C ++, e n√£o precis√°vamos mais escrever typedefs para nossas estruturas o tempo todo. </li><li>  Por volta de 2000, a revolu√ß√£o do C ++ ocorreu no mundo do desenvolvimento de jogos.  Era uma era <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de padr√µes de design</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grandes hierarquias de classe</a> .  Naquela √©poca, o suporte da STL aos consoles deixava muito a desejar, e os consoles dominavam o mundo na √©poca.  No PS2, estamos sempre presos ao GCC 2.95. </li><li>  Por volta de 2010, foram lan√ßadas mais duas revolu√ß√µes.  A dor do uso de grandes hierarquias de classe estimulou o desenvolvimento de uma abordagem componente ao c√≥digo.  Essa mudan√ßa continua sua evolu√ß√£o hoje na forma de arquiteturas de sistema de componentes de entidade.  De m√£os dadas com isso estava a segunda revolu√ß√£o - uma tentativa de tirar proveito das arquiteturas de multiprocessadores. </li></ul><br>  Durante essas mudan√ßas de paradigma, as pr√≥prias plataformas de desenvolvimento de jogos estavam constantemente mudando e mudando seriamente.  A mem√≥ria segmentada deu lugar a um espa√ßo de endere√ßo plano.  As plataformas se tornaram multiprocessadores, sim√©tricas e n√£o muito.  Os desenvolvedores de jogos, acostumados a trabalhar com arquiteturas da Intel, tiveram que se acostumar com o MIPS (Playstation), depois com um hardware especial com CPUs heterog√™neas (PS2), depois com o PowerPC (XBox 360), e com uma heterogeneidade ainda maior (PS3) ... A nova plataforma possui novos recursos de desempenho para processadores, mem√≥ria e unidades.  Se voc√™ queria alcan√ßar o desempenho ideal, foi for√ßado a reescrever seu c√≥digo antigo, e muitos e frequentemente.  N√£o vou nem mencionar o quanto os jogos foram influenciados pelo surgimento e crescimento da popularidade da Internet, bem como pelas restri√ß√µes que os propriet√°rios de plataformas impuseram aos desenvolvedores. <br><br>  Historicamente, as implementa√ß√µes de STL em plataformas de jogos s√£o insatisfat√≥rias.  N√£o √© segredo que os cont√™ineres da STL n√£o s√£o adequados para jogos.  Se voc√™ empurrar o desenvolvedor do jogo contra a parede, talvez ele admita que <code>std::string</code> esteja bem, e <code>std::vector</code> seja uma op√ß√£o padr√£o razo√°vel.  Mas todos os cont√™ineres contidos no STL t√™m um problema de controle de aloca√ß√£o e inicializa√ß√£o.  Em muitos jogos, voc√™ precisa se preocupar com as limita√ß√µes de mem√≥ria para v√°rias tarefas - e nos objetos para os quais voc√™ provavelmente ter√° que alocar mem√≥ria dinamicamente durante o jogo, os alocadores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>laje</i></a> ou <i>arena</i> s√£o frequentemente usados.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tempo constante amortizado</a> n√£o √© um bom resultado, uma vez que a aloca√ß√£o √© potencialmente uma das coisas mais "caras" que podem acontecer durante a execu√ß√£o do programa, e eu n√£o quero pular um quadro apenas porque aconteceu quando eu n√£o esperava. .  Como desenvolvedor de jogos, preciso gerenciar meus requisitos de mem√≥ria com anteced√™ncia. <br><br>  Uma hist√≥ria semelhante √© obtida para outras depend√™ncias em geral.  Os desenvolvedores de jogos querem saber o que cada ciclo do processador leva, onde, quando e por que cada byte de mem√≥ria √© respons√°vel, e tamb√©m onde e quando cada encadeamento de execu√ß√£o √© controlado.  At√© recentemente, os compiladores da Microsoft alteravam a ABI a cada atualiza√ß√£o - portanto, se voc√™ tivesse muitas depend√™ncias, reconstruir todas elas poderia ser um processo doloroso.  Os desenvolvedores de jogos geralmente preferem pequenas depend√™ncias f√°ceis de integrar, fazem apenas uma coisa e fazem bem - de prefer√™ncia com uma API estilo C - e s√£o usadas por muitas empresas, est√£o dispon√≠veis ao p√∫blico ou t√™m uma licen√ßa gratuita que n√£o requer uma indica√ß√£o do autor.  <i>SQLite</i> e <i>zlib</i> s√£o bons exemplos de quais desenvolvedores de jogos preferem usar. <br><br>  Al√©m disso, a ind√∫stria de jogos em C ++ tem um hist√≥rico rico de pacientes com a s√≠ndrome "N√£o inventado aqui".  Isso era de se esperar da ind√∫stria, que come√ßou com entusiastas solteiros que criavam suas pr√≥prias coisas com equipamentos completamente novos e n√£o tinham outras op√ß√µes.  A ind√∫stria de jogos, entre outras coisas, √© a √∫nica em que os programadores s√£o indicados nos cr√©ditos em nenhuma ordem espec√≠fica.  <i>Escrever uma variedade de coisas √© divertido e ajuda sua carreira!</i>  <i>√â muito melhor construir algo pr√≥prio do que comprar pronto!</i>  E, como estamos t√£o preocupados com o desempenho, podemos adaptar nossa solu√ß√£o de forma que ela seja adequada especificamente para o nosso projeto - em vez de usar uma solu√ß√£o generalizada que desperdice recursos dispon√≠veis sem pensar.  A hostilidade ao Boost √© o principal exemplo de como esse pensamento se manifesta no desenvolvimento de jogos.  Trabalhei em projetos da seguinte maneira: <br><br><ul><li>  Para come√ßar, para resolver um problema espec√≠fico, conectamos uma biblioteca do Boost ao projeto. </li><li>  Tudo funciona muito bem.  Quando voc√™ precisa atualizar, ocorre um pouco de dificuldade, mas n√£o mais do que na atualiza√ß√£o de qualquer outra depend√™ncia. </li><li>  Outro jogo quer usar nosso c√≥digo, mas o obst√°culo √© que usamos o Boost - apesar de nossa experi√™ncia com o Boost ter corrido muito bem. </li><li>  Removemos o c√≥digo usando o Boost, mas agora estamos diante de um novo problema: precisamos resolver o problema que a biblioteca do Boost, em vez da nossa, resolveu antes. </li><li>  Essencialmente, copiamos as partes do c√≥digo Boost necess√°rias em nossos pr√≥prios namespaces. </li><li>  Mais tarde, inevitavelmente, de tempos em tempos, nos deparamos com o fato de que precisamos de funcionalidades adicionais que j√° estariam no c√≥digo original se n√£o o tiv√©ssemos jogado fora.  Mas agora somos os propriet√°rios desse c√≥digo, por isso temos que continuar a apoi√°-lo. </li></ul><br>  N√£o gostamos de algo enorme que esteja tentando fazer muitas coisas ao mesmo tempo ou que possa afetar o tempo de compila√ß√£o - e isso √© bastante razo√°vel.  O que as pessoas cometem erros repetidamente √© que se op√µem a aceitar a suposta dor hoje - enquanto, por causa dessa decis√£o, enfrentar√£o uma dor muito real e muito maior com o apoio de algo √† custa de algu√©m. o or√ßamento que eles ter√£o que experimentar nos pr√≥ximos tr√™s anos.  Infelizmente, a presen√ßa de evid√™ncias na forma de jogos que usam com sucesso um prato de STL e Boost, de forma alguma pode afetar a psicologia humana e convencer os desenvolvedores de jogos. <br><br>  Por todos esses motivos, muitas empresas de jogos criaram suas pr√≥prias bibliotecas que cobrem o que a STL faz - e ainda mais - enquanto suportam casos de uso espec√≠ficos de jogos.  Algumas grandes empresas de jogos conseguiram dominar o desenvolvimento de sua pr√≥pria <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">substitui√ß√£o STL</a> , compat√≠vel com a API, quase completamente compat√≠vel, o que implicou custos enormes para apoiar este projeto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√â aconselh√°vel encontrar uma alternativa aprimorada ao</a> <code>std::map</code> ou aplicar <i>uma otimiza√ß√£o de buffer pequeno</i> no <code>std::vector</code> .  √â muito menos aceit√°vel estar condenado a suportar suas pr√≥prias implementa√ß√µes de <code>algorithms</code> ou <code>type traits</code> , o que far√° pouco bem.  Quanto a mim, √© lament√°vel que, para a maioria dos desenvolvedores, STLs sejam apenas cont√™ineres.  Como ao aprender STL no in√≠cio, eles aprendem exatamente que, falando em STL, a maioria implica <code>std::vector</code> - embora na verdade eles devam pensar em <code>std::find_if</code> . <br><br><h3>  Oportunidade No. 3: Testes </h3><br>  Argumenta-se que testes extensivos devem ser realizados, TDD e / ou BDD devem abranger todo o c√≥digo que pode ser coberto, e os erros devem ser resolvidos escrevendo novos testes. <br><br>  Portanto, vamos discutir o t√≥pico de teste. <br><br>  A julgar pela minha experi√™ncia, o teste automatizado praticamente n√£o √© usado na ind√∫stria de jogos.  Porque <br><br><h4>  1. Como a corre√ß√£o <i>n√£o</i> √© <i>t√£o</i> importante, mas n√£o h√° especifica√ß√£o real </h4><br>  Como jovem programador da ind√∫stria de jogos, rapidamente me livrei da ideia de que deveria me esfor√ßar para simular algo de forma realista.  Os jogos s√£o <i>fuma√ßa e espelhos</i> e a busca por caminhos curtos.  Ningu√©m se importa com o qu√£o realista √© a sua simula√ß√£o;  o principal √© que seja divertido.  Quando voc√™ n√£o tem outra especifica√ß√£o al√©m de "o jogo deve parecer certo", o assunto do teste est√° ausente.  Gra√ßas a bugs, a jogabilidade pode melhorar ainda mais.  Muitas vezes, um bug entra no lan√ßamento e at√© ganha o amor dos usu√°rios ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lembre-se do mesmo Gandhi do Civilization</a> ).  Jogos s√£o diferentes de outras √°reas que usam C ++;  aqui, a falta de corre√ß√£o n√£o leva ao fato de que algu√©m acaba perdendo suas economias. <br><br><h4>  2. Porque √© dif√≠cil </h4><br>  Obviamente, voc√™ gostaria de produzir testes automatizados sempre que puder.  Isso pode ser feito para alguns subsistemas para os quais existem resultados finais claramente definidos.  O teste de unidade na ind√∫stria de jogos, √© claro, est√° presente, mas, como regra, √© limitado ao c√≥digo de baixo n√≠vel - os an√°logos do STL mencionados anteriormente, procedimentos de convers√£o de strings, m√©todos de mecanismo f√≠sico, etc.  Os casos em que a se√ß√£o execut√°vel do c√≥digo tem resultados previs√≠veis geralmente s√£o testados por testes de unidade, embora o TDD n√£o seja usado aqui - j√° que os programadores de jogos preferem simplificar suas vidas, e n√£o vice-versa.  Mas como voc√™ testa o c√≥digo da jogabilidade (veja o ponto um)?  Assim que voc√™ vai al√©m do teste de unidade, encontra imediatamente outra raz√£o pela qual o teste de jogos √© t√£o dif√≠cil. <br><br><h4>  3. Porque o conte√∫do est√° envolvido </h4><br>  O teste de sistemas n√£o triviais provavelmente incluir√° o fornecimento de conte√∫do com o qual ele ser√° implementado.  A maioria dos engenheiros n√£o √© muito boa em produzir esse conte√∫do por conta pr√≥pria; portanto, para obter um teste significativo, voc√™ precisar√° atrair algu√©m com as habilidades certas para criar o conte√∫do.  Depois disso, voc√™ encontrar√° o problema de medir o que obt√©m na sa√≠da - afinal, isso n√£o √© mais uma linha ou um n√∫mero, mas uma imagem na tela ou um som que muda com o tempo. <br><br><h4>  4. Porque n√≥s n√£o praticamos </h4><br>  O teste de unidade √© uma fun√ß√£o para a qual conhe√ßo as poss√≠veis entradas e sa√≠das.  No entanto, a jogabilidade √© um comportamento imprevis√≠vel, que evolui dinamicamente, e eu n√£o sei como esse fen√¥meno pode ser testado adequadamente.  O que posso testar - se, √© claro, obtenho permiss√£o do meu gerente para dedicar tempo suficiente a isso - isto √©, por exemplo, desempenho ou recursos de alto n√≠vel, como um matchmaking, que posso analisar.  Esse trabalho de infraestrutura pode ser empolgante para alguns programadores de jogos, mas para a maioria simplesmente n√£o √© interessante e, al√©m disso, requer aprova√ß√£o e suporte do propriet√°rio da carteira.  Como programador de jogos, nunca tenho a oportunidade de praticar a escrita de testes de alto n√≠vel. <br><br><h4>  5. Como a [empresa] n√£o v√™ a necessidade de testes automatizados </h4><br>  Nosso principal objetivo √© lan√ßar o jogo.  Vivemos em uma era da ind√∫stria que avan√ßa com hits que aproveitam ao m√°ximo seu dinheiro no primeiro m√™s de vendas, quando os custos de marketing desses hits s√£o maximizados.  O ciclo de vida dos consoles nos ensinou que o c√≥digo, em qualquer caso, n√£o permanecer√° por muito tempo.  Se estamos trabalhando em um jogo online, provavelmente teremos tempo adicional para testar a correspond√™ncia ou a carga do servidor.  Como para o lan√ßamento do jogo, precisamos que seu desempenho esteja em ordem, devemos pelo menos realizar testes de desempenho, mas n√£o devemos automatizar esse processo.  Para o gerenciamento na ind√∫stria de jogos, o teste automatizado nada mais √© do que um desperd√≠cio de tempo e dinheiro.  Para sua implementa√ß√£o, √© necess√°rio contratar engenheiros experientes que realizar√£o o trabalho, cujo resultado ser√° quase impercept√≠vel.  O mesmo tempo pode ser gasto no desenvolvimento de novos recursos.  No curto prazo, √© muito mais lucrativo usar a equipe de controle de qualidade para testar o jogo, o que nos leva ao pr√≥ximo ponto. <br><br><h4>  6. Porque, em geral, o teste em jogos √© classificado como atividade de segunda categoria </h4><br>  Adoro bons profissionais de controle de qualidade.  Para mim, eles valem seu peso em ouro.  Eles sabem como melhorar seu jogo quebrando-o de uma maneira que nunca teria passado pela sua cabe√ßa.  Eles s√£o especialistas especializados em sua jogabilidade naquele aspecto em que voc√™ n√£o entende e quase nunca entende.  Eles s√£o melhores do que uma equipe de compiladores super capazes para ajud√°-lo a fazer tudo certo.  Fico feliz por ter tido a chance de trabalhar com v√°rios especialistas maravilhosos em controle de qualidade ao longo dos anos do meu trabalho. <br><br>  Eu quase sempre tive que lutar para garantir que eles ficassem no meu time. <br><br>   AAA-, ,  QA ‚Äî         ,       .     ,         .  ,      . <br><br>   ,      ,              ,       .   ¬´¬ª   ,       ,  QA   ,          ,        ,          . <br><br>   .             ,     .      QA-,          ,     API         ,    ¬´ ¬ª.    ,        ,         . <br><br>   .  ,       ,            ,     ‚Äî       . <br><br>   .       .       ,      ,  ¬´ .¬ª  ¬´ Y.¬ª.      QA- ‚Äî   ,         ,   . <br><br>      ,          ,        ;  ,     ‚Äî ,      ,      ‚Äî   QA   ,     , ,   ,   QA  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nas melhores equipes com as quais trabalhei, insistimos que nossas equipes tivessem seus pr√≥prios engenheiros de controle de qualidade que trabalhariam conosco. </font><font style="vertical-align: inherit;">No entanto, eles n√£o perderam sua objetividade ou desejo de alcan√ßar um resultado melhor. </font><font style="vertical-align: inherit;">Eles tiveram o prazer de receber ajuda de programadores para escrever testes automatizados. </font><font style="vertical-align: inherit;">O que certamente n√£o duvido √© que seria √∫til para a ind√∫stria de jogos fazer automa√ß√£o com mais frequ√™ncia.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desempenho de depura√ß√£o </font></font></h3><br>     ‚Äî   ,   API  ,     ,   (    )   ‚Äî  ,        . <br><br>        ,    ,         C++. <br><br>      ,    .    ,   ,  ,  ,        ,      .  ,  - ,            ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em outras palavras, queremos ter uma depura√ß√£o produtiva, porque, para detectar bugs, geralmente precisamos executar aplicativos com conjuntos de dados suficientemente grandes e representativos. Mas, de fato, quando chegamos a esse ponto, o depurador geralmente se torna uma ferramenta muito rude de usar - independentemente de ser produtiva ou n√£o. Obviamente, definir pontos de interrup√ß√£o nos dados ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pontos de interrup√ß√£o de dados</font></font></i> )        ,   ,       ‚Äî ,    ,       ?   ,      ,     ,      ,     ,         ,       ,       ,    ,     ( <i>soak testing</i> )? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tra√ßo dois, podemos confiar apenas no depurador. Nesse caso, fazemos o que sempre fizemos. Estamos tentando isolar o problema, fazer com que isso aconte√ßa com mais frequ√™ncia; adicionamos registro e analisamos nosso programa atrav√©s dele; ajustamos temporizadores e configura√ß√µes de fluxo; usamos pesquisa bin√°ria de constru√ß√£o; estudamos despejos de n√∫cleo e logs de falhas; tentamos reproduzir o problema reduzindo o conte√∫do ao m√≠nimo; refletimos sobre o que pode estar causando o problema e o discutimos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitas vezes, at√© chegarmos √† verdadeira causa do acidente, teremos tempo para consertar algumas outras coisas. Em outras palavras, resolvemos problemas e, no final, usar um depurador √© apenas uma pequena parte desse processo. Ent√£o, sim, a velocidade de depura√ß√£o √© uma boa adi√ß√£o, mas sua falta n√£o nos impede de continuar sendo engenheiros. Ainda precisamos de outras habilidades, como a capacidade de analisar dumps principais e ler o assembler otimizado.</font></font><br><br>   ¬´ ++¬ª       ,   .      ;     ,   ;    ,    .   ¬´ C++¬ª     , ‚Äî  ,    ,  STL  _ _,    STL .    ,  STL  ¬´ ¬ª,     ; ,    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   ,      </a> . <br><br>       ,      ,  ¬´ C++¬ª   ‚Äî   ,           .   <i> </i> ‚Äî    ,   . <br><br>      ,    C++      ,         .    ,     .     ,                .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>copy elision</i> ( )   </a> ,         .         . ,      ,      NRVO    ,      ,         . ,  C++     <i></i> . <br><br><h3> :   ++ </h3><br>            ,   C++,           . <br><br><h4> 1.    </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supondo que voc√™ ainda escreva c√≥digo C ++, voc√™ pode simplesmente continuar usando a linguagem da mesma maneira que antes. N√£o √© necess√°rio come√ßar a usar novos recursos, se voc√™ n√£o quiser fazer isso. Quase tudo o que voc√™ usa agora continuar√° a ser suportado - e, ao fazer isso, nos pr√≥ximos anos voc√™ continuar√° a colher os benef√≠cios de melhorar o compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa √© uma estrat√©gia de comportamento completamente apropriada para quem trabalha por conta pr√≥pria ou com uma equipe de pessoas afins. O C ++ 98, junto com alguns recursos mais recentes, ainda √© um bom ajuste para a cria√ß√£o de jogos.</font></font><br><br> ,      ,           ,         .   ,     C++-,       ¬´¬ª C++.    ‚Äî      , C  C++98.    ,     ,      ,   ‚Äì ,          .       ? <br><br><h4> 2.   </h4><br>  ,         GDC,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CppCon</a> ,        ,     .    ;   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>    ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>     .        ,     ,      ‚Äî        ,       . <br><br>     C++   .     ,       SG14,  SG7,  SG15 ‚Äî     ,     ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser encontrado em isocpp.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O comit√™ n√£o tem planos secretos - de fato, voc√™ realmente acha que mais de 200 programadores podem concordar com uma agenda comum? </font><font style="vertical-align: inherit;">Aqui, mesmo os "chefes" do comit√™ frequentemente deixam de "empurrar" suas id√©ias. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ deseja que sua opini√£o seja ouvida, comece a falar onde sua opini√£o pode ser ouvida, e n√£o no Twitter ou no Reddit. </font><font style="vertical-align: inherit;">Por favor, siga este conselho - estou ansioso por nossa discuss√£o.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435036/">https://habr.com/ru/post/pt435036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435018/index.html">Em 2018, finalmente come√ßamos a levar a s√©rio o tempo gasto no smartphone</a></li>
<li><a href="../pt435020/index.html">Consumer Electronics Hall of Fame: As hist√≥rias dos melhores gadgets dos √∫ltimos 50 anos, parte 2</a></li>
<li><a href="../pt435026/index.html">Criamos um messenger * que funciona mesmo no elevador</a></li>
<li><a href="../pt435028/index.html">Testes C sem SMS e registro</a></li>
<li><a href="../pt435032/index.html">A sonda Chang'e-4 fez um pouso bem-sucedido no lado oposto da lua e enviou a primeira foto</a></li>
<li><a href="../pt435038/index.html">Energia nuclear mundial em 2018</a></li>
<li><a href="../pt435040/index.html">Bitcoin h√° 10 anos</a></li>
<li><a href="../pt435044/index.html">Antiguidades: Minidisc em seu habitat natural</a></li>
<li><a href="../pt435050/index.html">Hist√≥ria de como o .NET 4.5 foi instalado no ReactOS</a></li>
<li><a href="../pt435054/index.html">Universidade ITMO "na pr√°tica": com que empresas de tecnologia cooperamos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>