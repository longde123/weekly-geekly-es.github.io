<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüåæ üèä üë®üèø‚Äçüé® Excepciones deterministas y manejo de errores en "C ++ del futuro" üôáüèª üìß ü•£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es extra√±o que en Habrt a√∫n no se mencionara una propuesta clamorosa para el est√°ndar C ++ llamada "Excepciones deterministas de sobrecarga cero". Cor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Excepciones deterministas y manejo de errores en "C ++ del futuro"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Es extra√±o que en Habrt a√∫n no se mencionara una propuesta clamorosa para el est√°ndar C ++ llamada "Excepciones deterministas de sobrecarga cero".  Corregir esta molesta omisi√≥n. </p><br><p>  Si le preocupa la sobrecarga de excepciones, o tuvo que compilar el c√≥digo sin soporte de excepci√≥n, o simplemente se pregunta qu√© suceder√° con el manejo de errores en C ++ 2b (una referencia a una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n reciente</a> ), le pido cat.  Est√°s esperando un poco de todo lo que ahora se puede encontrar sobre el tema, y ‚Äã‚Äãun par de encuestas. </p><a name="habracut"></a><br><p>  La discusi√≥n a continuaci√≥n se llevar√° a cabo no solo sobre excepciones est√°ticas, sino tambi√©n sobre propuestas relacionadas con el est√°ndar, y sobre todo tipo de otras formas de manejar errores.  Si fuiste aqu√≠ para ver la sintaxis, aqu√≠ est√°: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Si el tipo espec√≠fico de error no es importante / desconocido, simplemente puede usar <code>throws</code> and <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Bueno saber </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> y <code>std::expected</code> </h3><br><p>  Decidamos que el error que podr√≠a surgir en la funci√≥n no es lo suficientemente "fatal" como para lanzarle una excepci√≥n.  Tradicionalmente, la informaci√≥n de error se devuelve utilizando un par√°metro de salida.  Por ejemplo, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sistema de archivos TS</a> ofrece una serie de caracter√≠sticas similares: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (¬øNo arroja una excepci√≥n debido al hecho de que no se encontr√≥ el archivo?) Sin embargo, el procesamiento del c√≥digo de error es engorroso y propenso a errores.  El c√≥digo de error es f√°cil de olvidar.  Los estilos de c√≥digo modernos <a href="">proh√≠ben el</a> uso de par√°metros de salida; en cambio, se recomienda devolver una estructura que contenga el resultado completo. </p><br><p>  Por alg√∫n tiempo, Boost ha estado ofreciendo una soluci√≥n elegante para manejar tales errores "no fatales", que en ciertos escenarios pueden ocurrir en el programa correcto por cientos: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  El tipo <code>expected</code> es similar a la <code>variant</code> , pero proporciona una interfaz conveniente para trabajar con el "resultado" y el "error".  Por defecto, el resultado <code>expected</code> se almacena en <code>expected</code> .  La implementaci√≥n de <code>file_size</code> podr√≠a verse as√≠: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Si la causa del error no nos interesa, o el error puede consistir solo en la "ausencia" del resultado, entonces se puede usar <code>optional</code> : </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  En C ++ 17 de Boost, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">opcional</a> lleg√≥ a std (sin soporte para <code>optional&lt;T&amp;&gt;</code> );  en C ++ 20, pueden agregar lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esperado</a> (esto es solo una Propuesta, gracias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">RamzesXI</a> por la correcci√≥n). </p><br><h3 id="contracts">  Contratos </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los contratos</a> (que no deben confundirse con los conceptos) es una nueva forma de imponer restricciones a los par√°metros de la funci√≥n, que se agrega en C ++ 20.  Se agregaron 3 anotaciones: </p><br><ul><li>  <strong>espera</strong> verifica los par√°metros de la funci√≥n </li><li>  <strong>asegura</strong> comprueba el valor de retorno de la funci√≥n (lo toma como argumento) </li><li>  <strong>afirmar</strong> - un reemplazo civilizado para la macro afirmaci√≥n </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Puede configurar por incumplimiento de contrato: </p><br><ul><li>  Llamado comportamiento indefinido, o </li><li>  Verific√≥ y llam√≥ a la salida del usuario, despu√©s de lo cual <code>std::terminate</code> </li></ul><br><p>  Es imposible continuar ejecutando el programa despu√©s del incumplimiento del contrato, porque los compiladores usan las garant√≠as de los contratos para optimizar el c√≥digo de funci√≥n.  Si existe la m√°s m√≠nima duda de que el contrato se cumplir√°, vale la pena agregar un cheque adicional. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  La biblioteca <code>&lt;system_error&gt;</code> , agregada en C ++ 11, le permite estandarizar el manejo de c√≥digos de error en su programa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">std :: error_code</a> consiste en un c√≥digo de error de tipo <code>int</code> y un puntero al objeto de alguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase</a> descendiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">std :: error_category</a> .  Este objeto, de hecho, desempe√±a el papel de una tabla de funciones virtuales y determina el comportamiento de un determinado <code>std::error_code</code> . </p><br><p>  Para crear su <code>std::error_code</code> , debe definir su <code>std::error_category</code> descendiente <code>std::error_category</code> e implementar m√©todos virtuales, el m√°s importante de los cuales es: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Tambi√©n debe crear una variable global para su <code>std::error_category</code> .  El manejo de errores usando error_code + esperado se ve as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  Es importante que en <code>std::error_code</code> valor de 0 significa que no hay error.  Si este no es el caso de sus c√≥digos de error, antes de convertir el c√≥digo de error del sistema a <code>std::error_code</code> , debe reemplazar el c√≥digo 0 con SUCCESS, y viceversa. </p><br><p>  Todos los c√≥digos de error del sistema se describen en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errc</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">system_category</a> .  Si en cierto momento el reenv√≠o manual de los c√≥digos de error se vuelve demasiado triste, entonces siempre puede ajustar el c√≥digo de error en la <code>std::system_error</code> y tirarlo a la basura. </p><br><h3 id="destructive-move--trivially-relocatable">  Movimiento destructivo / Trivialmente reubicable </h3><br><p>  Deje que necesite crear otra clase de objetos que posean algunos recursos.  Lo m√°s probable es que desee que no se pueda copiar, pero que se pueda mover, porque los objetos inm√≥viles son inconvenientes para trabajar (antes de C ++ 17 no pod√≠an ser devueltos desde una funci√≥n). </p><br><p>  Pero aqu√≠ est√° el problema: en cualquier caso, el objeto movido necesita ser eliminado.  Por lo tanto, es necesario un estado especial de "movido desde", es decir, un objeto "vac√≠o" que no elimina nada.  Resulta que cada clase de C ++ debe tener un estado vac√≠o, es decir, es imposible crear una clase con una invariante (garant√≠a) de correcci√≥n, desde el constructor hasta el destructor.  Por ejemplo, no es posible crear la clase correcta de archivo abierto de un archivo que est√° abierto durante toda su vida √∫til.  Es extra√±o observar esto en uno de los pocos idiomas que usan activamente RAII. </p><br><p>  Otro problema es la puesta a cero de objetos antiguos cuando se mueve agrega una sobrecarga: el relleno <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> puede ser hasta 2 veces m√°s lento que <code>std::vector&lt;T*&gt;</code> debido al mont√≥n de puesta a cero de punteros antiguos al mover , seguido de la eliminaci√≥n de maniqu√≠es. </p><br><p>  Los desarrolladores de C ++ han lamido durante mucho tiempo a Rust, donde los destructores no se invocan en objetos reubicados.  Esta caracter√≠stica se llama movimiento destructivo.  Desafortunadamente, la Propuesta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trivialmente reubicable</a> no ofrece agregarlo a C ++.  Pero el problema general se resolver√°. </p><br><p>  Una clase se considera trivialmente reubicable si dos operaciones: mover y eliminar el objeto antiguo son equivalentes a memcpy del objeto antiguo al nuevo.  El antiguo objeto no se elimina, los autores lo llaman "dejarlo caer al suelo". </p><br><p>  Un tipo es reubicable trivialmente desde el punto de vista del compilador si se cumple una de las siguientes condiciones (recursivas): </p><br><ol><li>  Es trivialmente m√≥vil + trivialmente destructible (por ejemplo, estructura <code>int</code> o POD) </li><li>  Esta es la clase marcada con el atributo <code>[[trivially_relocatable]]</code> </li><li>  Esta es una clase cuyos miembros son trivialmente reubicables. </li></ol><br><p>  Puede usar esta informaci√≥n con <code>std::uninitialized_relocate</code> , que ejecuta move init + delete de la manera habitual, o si es posible, se acelera.  Se sugiere marcar como <code>[[trivially_relocatable]]</code> mayor√≠a de los tipos de la biblioteca est√°ndar, incluidos <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Gastos generales <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> con esto en mente La propuesta desaparecer√°. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  ¬øQu√© hay de malo con las excepciones ahora? </h2><br><p>  El mecanismo de excepci√≥n C ++ se desarroll√≥ en 1992.  Se han propuesto varias opciones de implementaci√≥n.  De estos, se seleccion√≥ un mecanismo de tabla de excepci√≥n que garantiza la ausencia de una sobrecarga para la ruta principal de ejecuci√≥n del programa.  Porque desde el momento mismo de su creaci√≥n, se asumi√≥ que las <em>excepciones deber√≠an lanzarse muy raramente</em> . </p><br><p>  Desventajas de las excepciones din√°micas (es decir, regulares): </p><br><ol><li>  En el caso de la excepci√≥n lanzada, la sobrecarga es en promedio de aproximadamente 10,000-100,000 ciclos de CPU, y en el peor de los casos, puede alcanzar el orden de milisegundos. </li><li>  El tama√±o del archivo binario aumenta en un 15-38% </li><li>  Incompatibilidad con la interfaz de programaci√≥n C </li><li>  Excepci√≥n impl√≠cita en el soporte de lanzamiento en todas las funciones, excepto en <code>noexcept</code> .  Se puede lanzar una excepci√≥n en casi cualquier parte del programa, incluso cuando el autor de la funci√≥n no lo espera. </li></ol><br><p>  Debido a estas deficiencias, el alcance de las excepciones es significativamente limitado.  Cuando no se pueden aplicar excepciones: </p><br><ol><li>  Donde el determinismo es importante, es decir, donde es inaceptable que el c√≥digo "a veces" funcione 10, 100, 1000 veces m√°s lento de lo habitual </li><li>  Cuando no son compatibles con ABI, por ejemplo, en microcontroladores </li><li>  Cuando una gran parte del c√≥digo est√° escrito en C </li><li>  En empresas con una gran carga de c√≥digo heredado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de estilo de Google</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qt</a> ).  Si hay al menos una funci√≥n que no es segura para excepciones en el c√≥digo, entonces, de acuerdo con la ley de maldad, tarde o temprano se generar√° una excepci√≥n y se crear√° un error </li><li>  En empresas que contratan programadores que no tienen idea de la seguridad de excepci√≥n </li></ol><br><p>  Seg√∫n las encuestas, en los lugares de trabajo del 52% (!) Desarrolladores, las excepciones est√°n prohibidas por las normas corporativas. </p><br><p>  ¬°Pero las excepciones son una parte integral de C ++!  Al incluir el <code>-fno-exceptions</code> , los desarrolladores pierden la capacidad de utilizar una parte importante de la biblioteca est√°ndar.  Esto incita a las empresas a plantar sus propias "bibliotecas est√°ndar" y, s√≠, inventar su propia clase de cadena. </p><br><p>  Pero este no es el final.  Las excepciones son la √∫nica forma est√°ndar de cancelar la creaci√≥n de un objeto en el constructor y generar un error.  Cuando se apagan, aparece una abominaci√≥n como la inicializaci√≥n de dos fases.  Los operadores tampoco pueden usar c√≥digos de error, por lo que se reemplazan con funciones como <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Propuesta: excepciones del futuro </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Nuevo mecanismo de transferencia de excepciones </h3><br><p>  Herb Sutter en P709 describi√≥ un nuevo mecanismo de transferencia de excepciones.  En principio, la funci√≥n devuelve <code>std::expected</code> , sin embargo, en lugar de un discriminador separado del tipo <code>bool</code> , que junto con la alineaci√≥n ocupar√° hasta 8 bytes en la pila, este bit de informaci√≥n se transmite de manera m√°s r√°pida, por ejemplo, a Carry Flag. </p><br><p>  Las funciones que no tocan CF (la mayor√≠a de ellas) tendr√°n la oportunidad de usar excepciones est√°ticas de forma gratuita, ¬°tanto en el caso de un retorno normal como en el caso de lanzar una excepci√≥n!  Las funciones que se ven obligadas a guardarlo y restaurarlo recibir√°n una sobrecarga m√≠nima, y ‚Äã‚Äãseguir√° siendo m√°s r√°pido que <code>std::expected</code> y cualquier c√≥digo de error ordinario. </p><br><p>  Las excepciones est√°ticas se ven as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  En la versi√≥n alternativa, se propone obligar a la palabra clave <code>try</code> en la misma expresi√≥n que la llamada de funci√≥n <code>throws</code> : <code>try i + safe_divide(j, k)</code> .  Esto reducir√° el n√∫mero de casos de uso de funciones <code>throws</code> en c√≥digo que no es seguro para excepciones a casi cero.  En cualquier caso, a diferencia de las excepciones din√°micas, el IDE podr√° resaltar de alguna manera las expresiones que arrojan excepciones. </p><br><p>  El hecho de que la excepci√≥n lanzada no se almacene por separado, sino que se coloca directamente en el lugar del valor devuelto, impone restricciones sobre el tipo de excepci√≥n.  Primero, debe ser trivialmente reubicable.  En segundo lugar, su tama√±o no debe ser muy grande (pero puede ser algo como <code>std::unique_ptr</code> ), de lo contrario, todas las funciones reservar√°n m√°s espacio en la pila. </p><br><h3 id="status_code">  status_code </h3><br><p>  La biblioteca <code>&lt;system_error2&gt;</code> , desarrollada por Niall Douglas, contendr√° <code>status_code&lt;T&gt;</code> - "nuevo, mejor" <code>error_code</code> .  Las principales diferencias de <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> : un tipo de plantilla que se puede usar para almacenar casi cualquier c√≥digo de error concebible (junto con un puntero a <code>status_code_category</code> ), sin usar excepciones est√°ticas </li><li>  <code>T</code> deber√≠a ser trivialmente reubicable y copiable (este √∫ltimo, en mi humilde opini√≥n, no deber√≠a ser obligatorio).  Al copiar y eliminar, las funciones virtuales se llaman desde <code>status_code_category</code> </li><li>  <code>status_code</code> puede almacenar no solo datos de error, sino tambi√©n informaci√≥n adicional sobre una operaci√≥n completada con √©xito </li><li>  La funci√≥n "virtual" <code>code.message()</code> no devuelve <code>std::string</code> , pero <code>string_ref</code> es un tipo de cadena bastante pesado, que es un <code>std::string_view</code> virtual "posiblemente propietario".  All√≠ puede <code>string_view</code> o <code>string</code> , o <code>std::shared_ptr&lt;string&gt;</code> , o alguna otra forma loca de poseer una cadena.  Niall afirma que <code>#include &lt;string&gt;</code> har√≠a que el encabezado <code>&lt;system_error2&gt;</code> inaceptablemente "pesado" </li></ol><br><p>  A continuaci√≥n, se <code>errored_status_code&lt;T&gt;</code> : un contenedor sobre <code>status_code&lt;T&gt;</code> con el siguiente constructor: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  error </h3><br><p>  El tipo de excepci√≥n predeterminado ( <code>throws</code> sin tipo), as√≠ como el tipo b√°sico de excepciones a las que se emiten todos los dem√°s (como <code>std::exception</code> ), es <code>error</code> .  Se define algo como esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Es decir, el <code>error</code> es un <code>status_code</code> "error", en el que el valor ( <code>value</code> ) se coloca en 1 puntero.  Dado que el mecanismo <code>status_code_category</code> garantiza la eliminaci√≥n, el movimiento y la copia correctos, te√≥ricamente, cualquier estructura de datos se puede guardar por <code>error</code> .  En la pr√°ctica, esta ser√° una de las siguientes opciones: </p><br><ol><li>  Enteros (int) </li><li>  <code>std::exception_handle</code> , es decir, un puntero a una excepci√≥n din√°mica lanzada </li><li>  <code>status_code_ptr</code> , es decir, <code>unique_ptr</code> a un <code>status_code&lt;T&gt;</code> arbitrario <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  El problema es que el caso 3 no est√° planeado para dar la oportunidad de devolver el <code>error</code> a <code>status_code&lt;T&gt;</code> .  Lo √∫nico que puede hacer es obtener el <code>message()</code> <code>status_code&lt;T&gt;</code> empaquetado <code>status_code&lt;T&gt;</code> .  Para poder recuperar el valor devuelto por <code>error</code> , t√≠ralo como una excepci√≥n din√°mica (!), Luego t√≥malo y envu√©lvelo por <code>error</code> .  En general, Niall cree que solo los c√≥digos de error y los mensajes de cadena deben almacenarse con <code>error</code> , lo cual es suficiente para cualquier programa. </p><br><p>  Para distinguir entre diferentes tipos de errores, se propone utilizar el operador de comparaci√≥n "virtual": </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  ¬°Usar m√∫ltiples bloques catch o <code>dynamic_cast</code> para seleccionar el tipo de excepci√≥n fallar√°! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interacci√≥n con excepciones din√°micas. </h3><br><p>  Una funci√≥n puede tener una de las siguientes especificaciones: </p><br><ul><li>  <code>noexcept</code> : no arroja excepciones </li><li>  <code>throws(E)</code> : lanza solo excepciones est√°ticas </li><li>  (nada): arroja solo excepciones din√°micas </li></ul><br><p>  <code>throws</code> implican no <code>noexcept</code> .  Si se lanza una excepci√≥n din√°mica desde una funci√≥n "est√°tica", entonces se envuelve por <code>error</code> .  Si se lanza una excepci√≥n est√°tica desde una funci√≥n "din√°mica", entonces se envuelve en una excepci√≥n <code>status_error</code> .  Un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Excepciones en C?! </h3><br><p>  La propuesta prev√© la adici√≥n de excepciones a uno de los futuros est√°ndares de C, y estas excepciones ser√°n compatibles con ABI con excepciones est√°ticas de C ++.  Una estructura similar a <code>std::expected&lt;T, U&gt;</code> , el usuario tendr√° que declarar de forma independiente, aunque la redundancia se puede eliminar mediante macros.  La sintaxis consiste en (por simplicidad, supondremos esto) las palabras clave falla, falla, captura. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Al mismo tiempo, en C ++ tambi√©n ser√° posible llamar a funciones <code>fails</code> desde C, declar√°ndolas en bloques <code>extern C</code> .  Por lo tanto, en C ++ habr√° una galaxia completa de palabras clave para trabajar con excepciones: </p><br><ul><li>  <code>throw()</code> - eliminado en C ++ 20 </li><li>  <code>noexcept</code> - especificador de funci√≥n, la funci√≥n no arroja excepciones din√°micas </li><li>  <code>noexcept(expression)</code> - especificador de funci√≥n, la funci√≥n no arroja excepciones din√°micas proporcionadas </li><li>  <code>noexcept(expression)</code> : ¬øuna expresi√≥n arroja excepciones din√°micas? </li><li>  <code>throws(E)</code> - especificador de funci√≥n, la funci√≥n arroja excepciones est√°ticas </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> : una funci√≥n importada de C genera excepciones est√°ticas </li></ul><br><p>  Entonces, en C ++ trajeron (o mejor dicho, entregaron) un carrito de nuevas herramientas para el manejo de errores.  A continuaci√≥n, surge una pregunta l√≥gica: </p><br><h2 id="kogda-chto-ispolzovat">  ¬øCu√°ndo usar qu√©? </h2><br><h3 id="napravlenie-v-celom">  Direcci√≥n general </h3><br><p>  Los errores se dividen en varios niveles: </p><br><ul><li>  Errores de programador.  Procesado mediante contratos.  Conducen a la recopilaci√≥n de registros y la terminaci√≥n del programa de acuerdo con el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">falla r√°pida</a> .  Ejemplos: puntero nulo (cuando esto no es v√°lido);  divisi√≥n por cero;  errores de asignaci√≥n de memoria no previstos por el programador. </li><li>  Errores fatales proporcionados por el programador.  Se descarta un mill√≥n de veces con menos frecuencia que un retorno normal de una funci√≥n, lo que justifica el uso de excepciones din√°micas.  Por lo general, en tales casos, debe reiniciar todo el subsistema del programa o dar un error al realizar la operaci√≥n.  Ejemplos: p√©rdida repentina de conexi√≥n con la base de datos;  errores de asignaci√≥n de memoria proporcionados por el programador. </li><li>  Errores recuperables cuando <em>algo</em> impide que la funci√≥n complete su tarea, pero la funci√≥n de llamada puede saber qu√© hacer con ella.  Manejado por excepciones est√°ticas.  Ejemplos: trabajar con el sistema de archivos;  otros errores de entrada / salida (IO);  Datos de usuario incorrectos  <code>vector::at()</code> . </li><li>  La funci√≥n complet√≥ con √©xito su tarea, aunque con un resultado inesperado.  <code>std::variant</code> <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Ejemplos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  En la biblioteca est√°ndar, es m√°s confiable abandonar por completo el uso de excepciones din√°micas para hacer legal la compilaci√≥n "sin excepciones". </p><br><h3 id="errno">  errno </h3><br><p>  Las funciones que usan <code>errno</code> para trabajar r√°pida y f√°cilmente con c√≥digos de error C y C ++ deben reemplazarse con <code>fails(int)</code> y <code>throws(std::errc)</code> , respectivamente.  Durante alg√∫n tiempo, las versiones antigua y nueva de las funciones de la biblioteca est√°ndar coexistir√°n, luego la antigua se declarar√° obsoleta. </p><br><h3 id="out-of-memory">  Sin memoria </h3><br><p>  Los errores de asignaci√≥n de memoria son manejados por el <code>new_handler</code> global <code>new_handler</code> , que puede: </p><br><ol><li>  Elimine la falta de memoria y contin√∫e la ejecuci√≥n. </li><li>  Lanzar una excepci√≥n </li><li>  Programa de bloqueo </li></ol><br><p>  Ahora <code>std::bad_alloc</code> lanza por defecto.  Se sugiere llamar a <code>std::terminate()</code> por defecto.  Si necesita el comportamiento anterior, reemplace el controlador con el que necesita al principio de <code>main()</code> . </p><br><p>  Todas las funciones existentes de la biblioteca est√°ndar pasar√°n a ser <code>noexcept</code> y bloquear√°n el programa cuando <code>std::bad_alloc</code> .  Al mismo tiempo, se agregar√°n nuevas API como <code>vector::try_push_back</code> , que permiten errores de asignaci√≥n de memoria. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Excepciones <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> informan una violaci√≥n de una condici√≥n previa de la funci√≥n.  El nuevo modelo de error deber√≠a usar contratos en su lugar.  Los tipos de excepciones enumerados <strong>no</strong> ser√°n obsoletos, pero casi todos los casos de su uso en la biblioteca est√°ndar ser√°n reemplazados por <code>[[expects: ‚Ä¶]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Estado actual de la propuesta </h2><br><p>  La propuesta se encuentra ahora en un estado borrador.  Ya ha cambiado bastante y todav√≠a puede cambiar mucho.  Algunos desarrollos no lograron publicarse, por lo que la API propuesta <code>&lt;system_error2&gt;</code> no <code>&lt;system_error2&gt;</code> todo relevante. </p><br><p>  La propuesta se describe en 3 documentos: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P709</a> - documento original del escudo de armas de Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1095</a> - Excepciones determinadas en Niall Douglas Vision, algunos momentos cambiados, compatibilidad con lenguaje C agregado </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1028</a> - API de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementaci√≥n de prueba de</a> <code>std::error</code> </li></ol><br><p>  Actualmente no hay un compilador que admita excepciones est√°ticas.  En consecuencia, todav√≠a no es posible hacer sus puntos de referencia. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430690/">https://habr.com/ru/post/es430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430680/index.html">Escribir un procesador simple y un entorno para ello</a></li>
<li><a href="../es430682/index.html">Tres a√±os del proyecto de microsat√©lites lunares: etapas de crecimiento</a></li>
<li><a href="../es430684/index.html">Escaneo de contratos de Ethereum en vivo en busca de un error de env√≠o sin marcar. Parte 2</a></li>
<li><a href="../es430686/index.html">Descripci√≥n general: la primera m√°quina de corte por chorro de agua de WAZER</a></li>
<li><a href="../es430688/index.html">Transferencia de datos v√≠a QR animado a Gomobile y GopherJS</a></li>
<li><a href="../es430692/index.html">Ingenier√≠a social con software de plataforma universal de Windows (APPX)</a></li>
<li><a href="../es430694/index.html">Una breve gu√≠a para aprender C ++: qu√©, cu√°ndo y qu√© crear</a></li>
<li><a href="../es430700/index.html">Un sistema unificado para grabar vistas de pel√≠culas en l√≠nea comenzar√° a funcionar en Rusia</a></li>
<li><a href="../es430702/index.html">Entrenamiento muy extra√±o</a></li>
<li><a href="../es430704/index.html">C√≥mo las tecnolog√≠as de inteligencia artificial ayudan a Aviasales a crecer: siete ejemplos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>