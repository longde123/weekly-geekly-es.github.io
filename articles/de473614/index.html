<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôëÔ∏è üéöÔ∏è ü§ûüèæ Das Buch ‚ÄûHead First. Kotlin ¬ª ü•ê üçä ü§∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, habrozhiteli! Wir haben ein Buch ver√∂ffentlicht, um Kotlin mit der Head First-Technik zu untersuchen, das √ºber die Syntax und Anweisungen zur L√∂su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch ‚ÄûHead First. Kotlin ¬ª</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/473614/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ev/fj/ao/evfjaohk2b8qeka0nzciygs_q70.jpeg" align="left" alt="Bild"></a>  Hi, habrozhiteli!  Wir haben ein Buch ver√∂ffentlicht, um Kotlin mit der Head First-Technik zu untersuchen, das √ºber die Syntax und Anweisungen zur L√∂sung spezifischer Probleme hinausgeht.  Dieses Buch bietet Ihnen alles, was Sie brauchen - von den Grundlagen der Sprache bis zu fortgeschrittenen Methoden.  Und Sie k√∂nnen objektorientierte und funktionale Programmierung √ºben. <br><br>  Unter dem Schnitt ist ein Auszug "Datenklassen" dargestellt. <br><a name="habracut"></a><br><h3>  Mit Daten arbeiten </h3><br>  Niemand m√∂chte Zeit verschwenden und wiederholen, was bereits getan wurde.  Die meisten Anwendungen verwenden Klassen zum Speichern von Daten.  Um die Arbeit zu vereinfachen, schlugen die Entwickler von Kotlin das Konzept einer Datenklasse vor.  In diesem Kapitel erfahren Sie, wie Datenklassen Ihnen helfen, eleganteren und pr√§gnanteren Code zu schreiben, von dem Sie vorher nur tr√§umen konnten.  Wir werden uns die Hilfsfunktionen von Datenklassen ansehen und lernen, wie ein Datenobjekt in Komponenten zerlegt wird.  Gleichzeitig werden wir beschreiben, wie die Standardparameterwerte den Code flexibler machen, und Ihnen Any vorstellen, den Vorfahren aller Oberklassen. <br><br><h3>  Der Operator == ruft eine Funktion namens equals auf </h3><br>  Wie Sie bereits wissen, kann der Operator == verwendet werden, um die Gleichheit zu √ºberpr√ºfen.  Jedes Mal, wenn die Anweisung == ausgef√ºhrt wird, wird eine Funktion namens equals aufgerufen.  Jedes Objekt enth√§lt eine Gleichheitsfunktion, und die Implementierung dieser Funktion bestimmt das Verhalten des Operators ==. <br><br>  Standardm√§√üig pr√ºft die Funktion equals zum √úberpr√ºfen der Gleichheit, ob zwei Variablen auf dasselbe Objekt verweisen. <br><br>  Um zu verstehen, wie es funktioniert, stellen Sie sich zwei Wolf-Variablen mit den Namen w1 und w2 vor.  Wenn w1 und w2 Verweise auf ein Wolf-Objekt enthalten, ist das Ergebnis beim Vergleich mit dem Operator == wahr: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/21/xu/jv/21xujvaljehbr6dvg7klxpu7qi8.png" alt="Bild"></div><br>  Wenn jedoch w1 und w2 Verweise auf verschiedene Wolf-Objekte enthalten, ergibt der Vergleich mit dem Operator == das Ergebnis false, selbst wenn die Objekte dieselben Eigenschaftswerte enthalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/de/xo/fb/dexofbmvz5qakq1ls-hhvp7h8r8.png" alt="Bild"></div><br>  Wie bereits erw√§hnt, ist die Funktion equals automatisch in jedem von Ihnen erstellten Objekt enthalten.  Aber woher kommt diese Funktion? <br><br><h3>  gleich erbt von der Oberklasse Any </h3><br>  Jedes Objekt enth√§lt eine Funktion namens equals, da seine Klasse eine Funktion von einer Klasse namens Any erbt.  Die Any-Klasse ist der Vorfahr aller Klassen: die resultierende Oberklasse von allem.  Jede Klasse, die Sie definieren, ist eine Unterklasse von Any, und Sie m√ºssen im Programm nicht darauf hinweisen.  Wenn Sie also einen Klassencode namens myClass schreiben, der folgenderma√üen aussieht: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br>  Der Compiler konvertiert es automatisch in das folgende Formular: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tv/04/lg/tv04lgenrnekhx2uqa2bsfr4meu.png" alt="Bild"></div><br><blockquote>  Jede Klasse ist eine Unterklasse von Any und erbt ihr Verhalten.  Jede Klasse ist eine Unterklasse von Any, und Sie m√ºssen dies nicht im Programm melden. </blockquote><br><h3>  Die Bedeutung jeglicher Vererbung </h3><br>  Das Einbeziehen von Any als resultierende Superklasse hat zwei wichtige Vorteile: <br><br><ul><li>  <b>Es stellt sicher, dass jede Klasse gemeinsames Verhalten erbt.</b>  Die Klasse Any definiert ein wichtiges Verhalten, von dem der Betrieb des Systems abh√§ngt.  Und da jede Klasse eine Unterklasse von Any ist, wird dieses Verhalten von allen von Ihnen erstellten Objekten √ºbernommen.  Die Any-Klasse definiert also eine Funktion namens equals. Daher wird diese Funktion automatisch von allen Objekten geerbt. </li><li>  <b>Dies bedeutet, dass Polymorphismus mit allen Objekten verwendet werden kann.</b>  Jede Klasse ist eine Unterklasse von Any, daher hat jedes Objekt, das Sie erstellen, die Any-Klasse als endg√ºltigen Supertyp.  Dies bedeutet, dass Sie eine Funktion mit beliebigen Parametern oder einem beliebigen R√ºckgabetyp erstellen k√∂nnen, der mit Objekten eines beliebigen Typs funktioniert.  Dies bedeutet auch, dass Sie polymorphe Arrays zum Speichern von Objekten eines beliebigen Typs mit Code der folgenden Form erstellen k√∂nnen: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myArray = arrayOf(Car(), Guitar(), Giraffe())</code> </pre><br>  Der Compiler stellt fest, dass jedes Objekt im Array einen gemeinsamen Prototyp von Any hat, und erstellt daher ein Array vom Typ Array. <br><br>  Das allgemeine Verhalten der Any-Klasse ist einen genaueren Blick wert. <br><br><h3>  Allgemeines Verhalten von Any geerbt </h3><br>  Die Any-Klasse definiert mehrere Funktionen, die von jeder Klasse geerbt werden.  Hier einige Beispiele f√ºr Grundfunktionen und deren Verhalten: <br><br><ul><li>  <b>gleich (any: Any): Boolean</b> <br>  √úberpr√ºft, ob zwei Objekte als "gleich" betrachtet werden.  Standardm√§√üig gibt die Funktion true zur√ºck, wenn ein Objekt √ºberpr√ºft wird, oder false - f√ºr verschiedene Objekte.  Hinter den Kulissen wird die Funktion equals jedes Mal aufgerufen, wenn der Operator == im Programm verwendet wird. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = w1 println(w1.equals(w2)) println(w1.equals(w2)) <span class="hljs-literal"><span class="hljs-literal">false</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   w1  w2   w1  w2        .)      ‚Äî   ,   w1 == w2.</code> </pre> <br><ul><li>  <b>hashCode (): Int</b> <br>  Gibt einen Hash-Code f√ºr ein Objekt zur√ºck.  Hash-Codes werden h√§ufig von einigen Datenstrukturen verwendet, um Werte effizient zu speichern und abzurufen. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.hashCode())</code> </pre> <br>  <b>523429237</b> (Wert des Hash-Codes w) <br><br><ul><li>  <b>toString (): String</b> <br>  Gibt eine String-Nachricht zur√ºck, die das Objekt darstellt.  Standardm√§√üig enth√§lt die Nachricht den Klassennamen und eine Nummer, die uns normalerweise egal ist. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.toString())</code> </pre> <br>  <b>Wolf @ 1f32e575</b> <br><br><blockquote>  Standardm√§√üig pr√ºft die Funktion equals, ob zwei Objekte dasselbe tats√§chliche Objekt sind. <br><br>  Die Funktion equals bestimmt das Verhalten des Operators ==. </blockquote><br>  Die Any-Klasse bietet eine Standardimplementierung f√ºr alle aufgelisteten Funktionen, und diese Implementierungen werden von allen Klassen geerbt.  Sie k√∂nnen diese Implementierungen jedoch √ºberschreiben, um das Standardverhalten aller aufgelisteten Funktionen zu √§ndern. <br><br><h3>  Einfache √Ñquivalenzpr√ºfung von zwei Objekten </h3><br>  In einigen Situationen m√ºssen Sie die Implementierung der Funktion equals √§ndern, um das Verhalten des Operators == zu √§ndern. <br><br>  Angenommen, Sie haben eine Rezeptklasse, mit der Sie Objekte zum Speichern von Rezepten erstellen k√∂nnen.  In einer solchen Situation werden Sie wahrscheinlich zwei Rezeptobjekte als gleich (oder gleichwertig) betrachten, wenn sie eine Beschreibung desselben Rezepts enthalten.  Angenommen, die Rezeptklasse ist mit zwei Eigenschaften definiert - title und isVegetarian: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br>  Der Operator == gibt true zur√ºck, wenn er zum Vergleichen von zwei Rezeptobjekten mit denselben Eigenschaften, title und isVegetarian, verwendet wird: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x6/xf/mf/x6xfmfs4maim5uck7papwh2pqdg.png" alt="Bild"></div><br>  Obwohl Sie das Verhalten des Operators == √§ndern k√∂nnen, indem Sie zus√§tzlichen Code schreiben, um die Funktion equals zu √ºberschreiben, haben Kotlin-Entwickler eine bequemere L√∂sung bereitgestellt: Sie haben das Konzept einer Datenklasse erstellt.  Mal sehen, was diese Klassen sind und wie sie erstellt werden. <br><br><h3>  Mit der Datenklasse k√∂nnen Sie Datenobjekte erstellen. </h3><br>  Eine Datenklasse ist eine Klasse zum Erstellen von Objekten zum Speichern von Daten.  Es enth√§lt Tools, die f√ºr die Arbeit mit Daten n√ºtzlich sind - beispielsweise eine neue Implementierung der Funktion equals, mit der √ºberpr√ºft wird, ob zwei Datenobjekte dieselben Eigenschaftswerte enthalten.  Wenn zwei Objekte dieselben Daten enthalten, k√∂nnen sie als gleich angesehen werden. <br><br>  Um eine Datenklasse zu definieren, stellen Sie der √ºblichen Datendefinition das Datenschl√ºsselwort voran.  Der folgende Code konvertiert die zuvor erstellte Rezeptklasse in eine Datenklasse: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br>  Das Datenpr√§fix konvertiert eine regul√§re Klasse in eine Datenklasse. <br><br><h3>  So erstellen Sie Objekte basierend auf einer Datenklasse </h3><br>  Datenklassenobjekte werden auf die gleiche Weise wie regul√§re Klassenobjekte erstellt: durch Aufrufen des Konstruktors dieser Klasse.  Der folgende Code erstellt beispielsweise ein neues Rezeptdatenobjekt und weist es einer neuen Variablen mit dem Namen r1 zu: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Datenklassen √ºberschreiben automatisch ihre Gleichheitsfunktionen, um das Verhalten des Operators == zu √§ndern, sodass die Gleichheit von Objekten basierend auf den Eigenschaftswerten jedes Objekts √ºberpr√ºft wird.  Wenn Sie beispielsweise zwei Rezeptobjekte mit denselben Eigenschaftswerten erstellen, ergibt der Vergleich der beiden Objekte mit dem Operator == das Ergebnis true, da dieselben Daten in ihnen gespeichert sind: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//r1 == r2  true</span></span></code> </pre><br>  r1 und r2 werden als "gleich" betrachtet, da zwei Rezeptobjekte dieselben Daten enthalten. <br><br>  Zus√§tzlich zur neuen Implementierung der Funktion equals, die von den Datenklassen der Superklasse Any geerbt wurde <br>  √úberschreiben Sie auch die Funktionen hashCode und toString.  Mal sehen, wie diese Funktionen implementiert werden. <br><br><h3>  Klassenobjekte definieren ihr geerbtes Verhalten neu </h3><br>  Um mit Daten arbeiten zu k√∂nnen, ben√∂tigt die Datenklasse Objekte. Daher werden automatisch die folgenden Implementierungen f√ºr die Funktionen equals, hashCode und toString bereitgestellt, die von der Superklasse Any geerbt wurden: <br><br><h3>  Die Funktion equals vergleicht Eigenschaftswerte </h3><br>  Beim Definieren einer Datenklasse gibt ihre Gleichheitsfunktion (und damit der Operator ==) weiterhin true zur√ºck, wenn die Verkn√ºpfungen auf dasselbe Objekt verweisen.  Es wird aber auch true zur√ºckgegeben, wenn die Objekte dieselben im Konstruktor definierten Eigenschaftswerte haben: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.equals(r2)) <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><blockquote>  Datenobjekte gelten als gleich, wenn ihre Eigenschaften denselben Wert enthalten. </blockquote><br><h3>  F√ºr gleiche Objekte werden dieselben hashCode-Werte zur√ºckgegeben </h3><br>  Wenn zwei Datenobjekte als gleich betrachtet werden (mit anderen Worten, sie haben dieselben Eigenschaftswerte), gibt die Funktion hashCode f√ºr diese Objekte denselben Wert zur√ºck: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.hashCode()) println(r2.hashCode())</code> </pre> <br>  <b>241131113</b> <b><br></b>  <b>241131113</b> <br><br><h3>  toString gibt die Werte aller Eigenschaften zur√ºck </h3><br>  Schlie√ülich gibt die Funktion toString nicht mehr den Namen der Klasse gefolgt von einer Zahl zur√ºck, sondern eine n√ºtzliche Zeichenfolge mit den Werten aller im Konstruktor der Datenklasse definierten Eigenschaften: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.toString()) Recipe(title=Chicken Bhuna, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Zus√§tzlich zum √úberschreiben von Funktionen, die von der Superklasse Any geerbt wurden, bietet die Datenklasse zus√§tzliche Tools, die eine effizientere Arbeit mit Daten erm√∂glichen, z. B. die M√∂glichkeit, Datenobjekte zu kopieren.  Mal sehen, wie diese Tools funktionieren. <br><br><h3>  Kopieren von Datenobjekten mit der Kopierfunktion </h3><br>  Wenn Sie eine Kopie des Datenobjekts erstellen m√ºssen, indem Sie einige seiner Eigenschaften √§ndern, die anderen Eigenschaften jedoch im urspr√ºnglichen Zustand belassen, verwenden Sie die Kopierfunktion.  Dazu wird die Funktion f√ºr das Objekt aufgerufen, das Sie kopieren m√∂chten, und die Namen aller ver√§nderlichen Eigenschaften mit neuen Werten werden an das Objekt √ºbergeben. <br><br>  Angenommen, Sie haben ein Rezeptobjekt mit dem Namen r1, das im Code wie folgt definiert ist: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/hk/oi/tuhkoizk5srtgdpish28kozd5o4.png" alt="Bild"></div><br>  Wenn Sie eine Kopie des Rezeptobjekts erstellen und den Wert der Eigenschaft isVegetarian durch true ersetzen m√∂chten, gehen Sie folgenderma√üen vor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p1/_9/xb/p1_9xbbjnwqi2p-lwlsh7jzjvcw.png" alt="Bild"></div><br>  Im Wesentlichen bedeutet dies: "Erstellen Sie eine Kopie des r1-Objekts, √§ndern Sie den Wert seiner isVegetarian-Eigenschaft in true und weisen Sie einer Variablen mit dem Namen r2 ein neues Objekt zu."  Dadurch wird eine neue Kopie des Objekts erstellt, und das urspr√ºngliche Objekt bleibt unver√§ndert. <br><br>  Neben der Kopierfunktion bieten Datenklassen auch eine Reihe von Funktionen zum Aufteilen eines Datenobjekts in eine Reihe von Werten seiner Eigenschaften - dieser Vorgang wird als Destrukturierung bezeichnet.  Mal sehen, wie das gemacht wird. <br><br><h3>  Datenklassen definieren KomponentenN ... -Funktionen </h3><br>  Beim Definieren einer Datenklasse f√ºgt der Compiler der Klasse automatisch eine Reihe von Funktionen hinzu, die als alternativer Mechanismus f√ºr den Zugriff auf Objekteigenschaftswerte verwendet werden k√∂nnen.  Diese Funktionen sind unter dem allgemeinen Namen der Komponenten-N-Funktionen bekannt, wobei N die Anzahl der abzurufenden Eigenschaften ist (in der Deklarationsreihenfolge). <br><br>  Angenommen, Sie haben das folgende Rezeptobjekt, um zu sehen, wie die Funktionen von componentN funktionieren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Wenn Sie den Wert der ersten Eigenschaft des Objekts (title-Eigenschaft) abrufen m√∂chten, k√∂nnen Sie dazu die component1 () -Funktion des Objekts aufrufen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1()</code> </pre> <br>  component1 () gibt die Referenz zur√ºck, die in der ersten im Konstruktor der Datenklasse definierten Eigenschaft enthalten ist. <br><br>  Die Funktion funktioniert wie der folgende Code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title</code> </pre> <br>  Der Code mit der Funktion ist universeller.  Warum sind die ComponentN-Funktionen in Datenklassen so n√ºtzlich? <br><br><h3>  ... zur Umstrukturierung von Datenobjekten </h3><br>  Die generischen componentN-Funktionen sind vor allem deshalb n√ºtzlich, weil sie eine einfache und bequeme M√∂glichkeit bieten, ein Datenobjekt in Eigenschaftswerte aufzuteilen oder zu zerst√∂ren. <br><br>  Angenommen, Sie m√∂chten die Werte der Eigenschaften eines Rezeptobjekts √ºbernehmen und den Wert jeder seiner Eigenschaften einer separaten Variablen zuweisen.  Anstelle von Code <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.isVegetarian</code> </pre> <br>  Bei der sequentiellen Verarbeitung jeder Eigenschaft k√∂nnen Sie den folgenden Code verwenden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r</code> </pre> <br>  Weist der ersten Eigenschaft r den Titel und der zweiten Eigenschaft den vegetarischen Titel zu. <br><br>  Dieser Code bedeutet "Erstellen Sie zwei Variablen, Titel und Vegetarisch, und weisen Sie den Wert einer der r Eigenschaften jeder Variablen zu."  Er macht dasselbe wie das n√§chste Fragment <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.component2()</code> </pre> <br>  aber es f√§llt kompakter aus. <br><br>  <b>Der Operator === pr√ºft immer, ob sich zwei Variablen auf dasselbe Objekt beziehen.</b> <br><br>  Wenn Sie √ºberpr√ºfen m√∂chten, ob zwei Variablen unabh√§ngig von ihrem Typ auf dasselbe Objekt verweisen, verwenden Sie den Operator === anstelle von ==.  Der Operator === gibt das Ergebnis nur dann als wahr an, wenn (und nur wenn) zwei Variablen einen Verweis auf ein tats√§chliches Objekt enthalten.  Wenn Sie zwei Variablen haben, x und y, und den folgenden Ausdruck: <br><br><pre> <code class="kotlin hljs">x === y</code> </pre> <br>  Wenn das Ergebnis true ist, wissen Sie, dass sich die Variablen x und y auf dasselbe Objekt beziehen m√ºssen. <br><br>  Im Gegensatz zum Operator == ist das Verhalten des Operators === unabh√§ngig von der Funktion equals.  Der Operator === verh√§lt sich unabh√§ngig vom Klassentyp immer gleich. <br><br>  Nachdem Sie gelernt haben, wie Sie Datenklassen erstellen und verwenden, erstellen Sie ein Projekt f√ºr den Rezeptcode. <br><br><h3>  Erstellen eines Rezeptprojekts </h3><br>  Erstellen Sie ein neues Kotlin-Projekt f√ºr die JVM und nennen Sie es "Rezepte".  Dann erstellen Sie eine neue <br>  Kotlin-Datei mit dem Namen Recipes.kt: W√§hlen Sie den Ordner src aus, √∂ffnen Sie das Men√º Datei und w√§hlen Sie den Befehl aus <br>  Neu ‚Üí Kotlin-Datei / Klasse.  Geben Sie den Dateinamen "Rezepte" ein und w√§hlen Sie die Option "Datei" in der Gruppe "Art". <br><br>  Wir f√ºgen dem Projekt eine neue Datenklasse mit dem Namen Rezept hinzu und erstellen Rezeptdatenobjekte.  Unten ist der Code.  Aktualisieren Sie Ihre Version von Recipes.kt und bringen Sie sie mit unserer in Einklang: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) (  {} ,        .) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r3 = r1.copy(title = <span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>) (  r1    title) println(<span class="hljs-string"><span class="hljs-string">"r1 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r2 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r2.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r3 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r3.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 toString: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.toString()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 === r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 === r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r3? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r3}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r1 ( r1) println(<span class="hljs-string"><span class="hljs-string">"title is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$title</span></span></span><span class="hljs-string"> and vegetarian is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$vegetarian</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br>  Wenn Sie Ihren Code ausf√ºhren, wird der folgende Text im Ausgabefenster der IDE angezeigt: <br><br><pre> <code class="kotlin hljs">r1 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r2 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r3 hash code: <span class="hljs-number"><span class="hljs-number">241131113</span></span> r1 toString: Recipe(title=Thai Curry, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>) r1 == r2? <span class="hljs-literal"><span class="hljs-literal">true</span></span> r1 === r2? <span class="hljs-literal"><span class="hljs-literal">false</span></span> r1 == r3? <span class="hljs-literal"><span class="hljs-literal">false</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Thai Curry and vegetarian <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br>  25% Rabatt auf Gutschein f√ºr Khabrozhitel - <b>Kotlin</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473614/">https://habr.com/ru/post/de473614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473600/index.html">Wer braucht Chromebooks?</a></li>
<li><a href="../de473602/index.html">Asynchron arbeiten</a></li>
<li><a href="../de473608/index.html">Ein Leitfaden zum Verst√§ndnis des Konzepts der modernen Web-App-Entwicklung</a></li>
<li><a href="../de473610/index.html">Analysieren der neuen Plesk Obsidian-Webkonsole</a></li>
<li><a href="../de473612/index.html">Abhandlung √ºber den Stift. Gedanken zur Konfiguration und Arbeit mit Pins in C ++ f√ºr Mikrocontroller (am Beispiel von CortexM)</a></li>
<li><a href="../de473626/index.html">‚ÄûDer Entwickler m√∂chte in drei Jahren ein Flugzeug kaufen. Meine Aufgabe ist es, ihm zu helfen ‚Äú- Denis Puschkin √ºber die Motivation von Skyeng</a></li>
<li><a href="../de473628/index.html">C ++ im Dienste der Kieferorthop√§die: Interview mit Mikhail Matrosov, CAD-Entwickler bei Align Technology</a></li>
<li><a href="../de473630/index.html">Best Practices und Tools f√ºr die Entwicklung von iOS-Anwendungen</a></li>
<li><a href="../de473632/index.html">Wir haben einen Artikel √ºber Habr gesehen</a></li>
<li><a href="../de473634/index.html">Comcast-Lobbys verbieten die DNS-Verschl√ºsselung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>