<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♑️ 🎚️ 🤞🏾 Das Buch „Head First. Kotlin » 🥐 🍊 🤸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, habrozhiteli! Wir haben ein Buch veröffentlicht, um Kotlin mit der Head First-Technik zu untersuchen, das über die Syntax und Anweisungen zur Lösu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch „Head First. Kotlin »</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/473614/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ev/fj/ao/evfjaohk2b8qeka0nzciygs_q70.jpeg" align="left" alt="Bild"></a>  Hi, habrozhiteli!  Wir haben ein Buch veröffentlicht, um Kotlin mit der Head First-Technik zu untersuchen, das über die Syntax und Anweisungen zur Lösung spezifischer Probleme hinausgeht.  Dieses Buch bietet Ihnen alles, was Sie brauchen - von den Grundlagen der Sprache bis zu fortgeschrittenen Methoden.  Und Sie können objektorientierte und funktionale Programmierung üben. <br><br>  Unter dem Schnitt ist ein Auszug "Datenklassen" dargestellt. <br><a name="habracut"></a><br><h3>  Mit Daten arbeiten </h3><br>  Niemand möchte Zeit verschwenden und wiederholen, was bereits getan wurde.  Die meisten Anwendungen verwenden Klassen zum Speichern von Daten.  Um die Arbeit zu vereinfachen, schlugen die Entwickler von Kotlin das Konzept einer Datenklasse vor.  In diesem Kapitel erfahren Sie, wie Datenklassen Ihnen helfen, eleganteren und prägnanteren Code zu schreiben, von dem Sie vorher nur träumen konnten.  Wir werden uns die Hilfsfunktionen von Datenklassen ansehen und lernen, wie ein Datenobjekt in Komponenten zerlegt wird.  Gleichzeitig werden wir beschreiben, wie die Standardparameterwerte den Code flexibler machen, und Ihnen Any vorstellen, den Vorfahren aller Oberklassen. <br><br><h3>  Der Operator == ruft eine Funktion namens equals auf </h3><br>  Wie Sie bereits wissen, kann der Operator == verwendet werden, um die Gleichheit zu überprüfen.  Jedes Mal, wenn die Anweisung == ausgeführt wird, wird eine Funktion namens equals aufgerufen.  Jedes Objekt enthält eine Gleichheitsfunktion, und die Implementierung dieser Funktion bestimmt das Verhalten des Operators ==. <br><br>  Standardmäßig prüft die Funktion equals zum Überprüfen der Gleichheit, ob zwei Variablen auf dasselbe Objekt verweisen. <br><br>  Um zu verstehen, wie es funktioniert, stellen Sie sich zwei Wolf-Variablen mit den Namen w1 und w2 vor.  Wenn w1 und w2 Verweise auf ein Wolf-Objekt enthalten, ist das Ergebnis beim Vergleich mit dem Operator == wahr: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/21/xu/jv/21xujvaljehbr6dvg7klxpu7qi8.png" alt="Bild"></div><br>  Wenn jedoch w1 und w2 Verweise auf verschiedene Wolf-Objekte enthalten, ergibt der Vergleich mit dem Operator == das Ergebnis false, selbst wenn die Objekte dieselben Eigenschaftswerte enthalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/de/xo/fb/dexofbmvz5qakq1ls-hhvp7h8r8.png" alt="Bild"></div><br>  Wie bereits erwähnt, ist die Funktion equals automatisch in jedem von Ihnen erstellten Objekt enthalten.  Aber woher kommt diese Funktion? <br><br><h3>  gleich erbt von der Oberklasse Any </h3><br>  Jedes Objekt enthält eine Funktion namens equals, da seine Klasse eine Funktion von einer Klasse namens Any erbt.  Die Any-Klasse ist der Vorfahr aller Klassen: die resultierende Oberklasse von allem.  Jede Klasse, die Sie definieren, ist eine Unterklasse von Any, und Sie müssen im Programm nicht darauf hinweisen.  Wenn Sie also einen Klassencode namens myClass schreiben, der folgendermaßen aussieht: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br>  Der Compiler konvertiert es automatisch in das folgende Formular: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tv/04/lg/tv04lgenrnekhx2uqa2bsfr4meu.png" alt="Bild"></div><br><blockquote>  Jede Klasse ist eine Unterklasse von Any und erbt ihr Verhalten.  Jede Klasse ist eine Unterklasse von Any, und Sie müssen dies nicht im Programm melden. </blockquote><br><h3>  Die Bedeutung jeglicher Vererbung </h3><br>  Das Einbeziehen von Any als resultierende Superklasse hat zwei wichtige Vorteile: <br><br><ul><li>  <b>Es stellt sicher, dass jede Klasse gemeinsames Verhalten erbt.</b>  Die Klasse Any definiert ein wichtiges Verhalten, von dem der Betrieb des Systems abhängt.  Und da jede Klasse eine Unterklasse von Any ist, wird dieses Verhalten von allen von Ihnen erstellten Objekten übernommen.  Die Any-Klasse definiert also eine Funktion namens equals. Daher wird diese Funktion automatisch von allen Objekten geerbt. </li><li>  <b>Dies bedeutet, dass Polymorphismus mit allen Objekten verwendet werden kann.</b>  Jede Klasse ist eine Unterklasse von Any, daher hat jedes Objekt, das Sie erstellen, die Any-Klasse als endgültigen Supertyp.  Dies bedeutet, dass Sie eine Funktion mit beliebigen Parametern oder einem beliebigen Rückgabetyp erstellen können, der mit Objekten eines beliebigen Typs funktioniert.  Dies bedeutet auch, dass Sie polymorphe Arrays zum Speichern von Objekten eines beliebigen Typs mit Code der folgenden Form erstellen können: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myArray = arrayOf(Car(), Guitar(), Giraffe())</code> </pre><br>  Der Compiler stellt fest, dass jedes Objekt im Array einen gemeinsamen Prototyp von Any hat, und erstellt daher ein Array vom Typ Array. <br><br>  Das allgemeine Verhalten der Any-Klasse ist einen genaueren Blick wert. <br><br><h3>  Allgemeines Verhalten von Any geerbt </h3><br>  Die Any-Klasse definiert mehrere Funktionen, die von jeder Klasse geerbt werden.  Hier einige Beispiele für Grundfunktionen und deren Verhalten: <br><br><ul><li>  <b>gleich (any: Any): Boolean</b> <br>  Überprüft, ob zwei Objekte als "gleich" betrachtet werden.  Standardmäßig gibt die Funktion true zurück, wenn ein Objekt überprüft wird, oder false - für verschiedene Objekte.  Hinter den Kulissen wird die Funktion equals jedes Mal aufgerufen, wenn der Operator == im Programm verwendet wird. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = w1 println(w1.equals(w2)) println(w1.equals(w2)) <span class="hljs-literal"><span class="hljs-literal">false</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   w1  w2   w1  w2        .)      —   ,   w1 == w2.</code> </pre> <br><ul><li>  <b>hashCode (): Int</b> <br>  Gibt einen Hash-Code für ein Objekt zurück.  Hash-Codes werden häufig von einigen Datenstrukturen verwendet, um Werte effizient zu speichern und abzurufen. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.hashCode())</code> </pre> <br>  <b>523429237</b> (Wert des Hash-Codes w) <br><br><ul><li>  <b>toString (): String</b> <br>  Gibt eine String-Nachricht zurück, die das Objekt darstellt.  Standardmäßig enthält die Nachricht den Klassennamen und eine Nummer, die uns normalerweise egal ist. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.toString())</code> </pre> <br>  <b>Wolf @ 1f32e575</b> <br><br><blockquote>  Standardmäßig prüft die Funktion equals, ob zwei Objekte dasselbe tatsächliche Objekt sind. <br><br>  Die Funktion equals bestimmt das Verhalten des Operators ==. </blockquote><br>  Die Any-Klasse bietet eine Standardimplementierung für alle aufgelisteten Funktionen, und diese Implementierungen werden von allen Klassen geerbt.  Sie können diese Implementierungen jedoch überschreiben, um das Standardverhalten aller aufgelisteten Funktionen zu ändern. <br><br><h3>  Einfache Äquivalenzprüfung von zwei Objekten </h3><br>  In einigen Situationen müssen Sie die Implementierung der Funktion equals ändern, um das Verhalten des Operators == zu ändern. <br><br>  Angenommen, Sie haben eine Rezeptklasse, mit der Sie Objekte zum Speichern von Rezepten erstellen können.  In einer solchen Situation werden Sie wahrscheinlich zwei Rezeptobjekte als gleich (oder gleichwertig) betrachten, wenn sie eine Beschreibung desselben Rezepts enthalten.  Angenommen, die Rezeptklasse ist mit zwei Eigenschaften definiert - title und isVegetarian: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br>  Der Operator == gibt true zurück, wenn er zum Vergleichen von zwei Rezeptobjekten mit denselben Eigenschaften, title und isVegetarian, verwendet wird: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x6/xf/mf/x6xfmfs4maim5uck7papwh2pqdg.png" alt="Bild"></div><br>  Obwohl Sie das Verhalten des Operators == ändern können, indem Sie zusätzlichen Code schreiben, um die Funktion equals zu überschreiben, haben Kotlin-Entwickler eine bequemere Lösung bereitgestellt: Sie haben das Konzept einer Datenklasse erstellt.  Mal sehen, was diese Klassen sind und wie sie erstellt werden. <br><br><h3>  Mit der Datenklasse können Sie Datenobjekte erstellen. </h3><br>  Eine Datenklasse ist eine Klasse zum Erstellen von Objekten zum Speichern von Daten.  Es enthält Tools, die für die Arbeit mit Daten nützlich sind - beispielsweise eine neue Implementierung der Funktion equals, mit der überprüft wird, ob zwei Datenobjekte dieselben Eigenschaftswerte enthalten.  Wenn zwei Objekte dieselben Daten enthalten, können sie als gleich angesehen werden. <br><br>  Um eine Datenklasse zu definieren, stellen Sie der üblichen Datendefinition das Datenschlüsselwort voran.  Der folgende Code konvertiert die zuvor erstellte Rezeptklasse in eine Datenklasse: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br>  Das Datenpräfix konvertiert eine reguläre Klasse in eine Datenklasse. <br><br><h3>  So erstellen Sie Objekte basierend auf einer Datenklasse </h3><br>  Datenklassenobjekte werden auf die gleiche Weise wie reguläre Klassenobjekte erstellt: durch Aufrufen des Konstruktors dieser Klasse.  Der folgende Code erstellt beispielsweise ein neues Rezeptdatenobjekt und weist es einer neuen Variablen mit dem Namen r1 zu: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Datenklassen überschreiben automatisch ihre Gleichheitsfunktionen, um das Verhalten des Operators == zu ändern, sodass die Gleichheit von Objekten basierend auf den Eigenschaftswerten jedes Objekts überprüft wird.  Wenn Sie beispielsweise zwei Rezeptobjekte mit denselben Eigenschaftswerten erstellen, ergibt der Vergleich der beiden Objekte mit dem Operator == das Ergebnis true, da dieselben Daten in ihnen gespeichert sind: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//r1 == r2  true</span></span></code> </pre><br>  r1 und r2 werden als "gleich" betrachtet, da zwei Rezeptobjekte dieselben Daten enthalten. <br><br>  Zusätzlich zur neuen Implementierung der Funktion equals, die von den Datenklassen der Superklasse Any geerbt wurde <br>  Überschreiben Sie auch die Funktionen hashCode und toString.  Mal sehen, wie diese Funktionen implementiert werden. <br><br><h3>  Klassenobjekte definieren ihr geerbtes Verhalten neu </h3><br>  Um mit Daten arbeiten zu können, benötigt die Datenklasse Objekte. Daher werden automatisch die folgenden Implementierungen für die Funktionen equals, hashCode und toString bereitgestellt, die von der Superklasse Any geerbt wurden: <br><br><h3>  Die Funktion equals vergleicht Eigenschaftswerte </h3><br>  Beim Definieren einer Datenklasse gibt ihre Gleichheitsfunktion (und damit der Operator ==) weiterhin true zurück, wenn die Verknüpfungen auf dasselbe Objekt verweisen.  Es wird aber auch true zurückgegeben, wenn die Objekte dieselben im Konstruktor definierten Eigenschaftswerte haben: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.equals(r2)) <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><blockquote>  Datenobjekte gelten als gleich, wenn ihre Eigenschaften denselben Wert enthalten. </blockquote><br><h3>  Für gleiche Objekte werden dieselben hashCode-Werte zurückgegeben </h3><br>  Wenn zwei Datenobjekte als gleich betrachtet werden (mit anderen Worten, sie haben dieselben Eigenschaftswerte), gibt die Funktion hashCode für diese Objekte denselben Wert zurück: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.hashCode()) println(r2.hashCode())</code> </pre> <br>  <b>241131113</b> <b><br></b>  <b>241131113</b> <br><br><h3>  toString gibt die Werte aller Eigenschaften zurück </h3><br>  Schließlich gibt die Funktion toString nicht mehr den Namen der Klasse gefolgt von einer Zahl zurück, sondern eine nützliche Zeichenfolge mit den Werten aller im Konstruktor der Datenklasse definierten Eigenschaften: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.toString()) Recipe(title=Chicken Bhuna, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Zusätzlich zum Überschreiben von Funktionen, die von der Superklasse Any geerbt wurden, bietet die Datenklasse zusätzliche Tools, die eine effizientere Arbeit mit Daten ermöglichen, z. B. die Möglichkeit, Datenobjekte zu kopieren.  Mal sehen, wie diese Tools funktionieren. <br><br><h3>  Kopieren von Datenobjekten mit der Kopierfunktion </h3><br>  Wenn Sie eine Kopie des Datenobjekts erstellen müssen, indem Sie einige seiner Eigenschaften ändern, die anderen Eigenschaften jedoch im ursprünglichen Zustand belassen, verwenden Sie die Kopierfunktion.  Dazu wird die Funktion für das Objekt aufgerufen, das Sie kopieren möchten, und die Namen aller veränderlichen Eigenschaften mit neuen Werten werden an das Objekt übergeben. <br><br>  Angenommen, Sie haben ein Rezeptobjekt mit dem Namen r1, das im Code wie folgt definiert ist: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/hk/oi/tuhkoizk5srtgdpish28kozd5o4.png" alt="Bild"></div><br>  Wenn Sie eine Kopie des Rezeptobjekts erstellen und den Wert der Eigenschaft isVegetarian durch true ersetzen möchten, gehen Sie folgendermaßen vor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p1/_9/xb/p1_9xbbjnwqi2p-lwlsh7jzjvcw.png" alt="Bild"></div><br>  Im Wesentlichen bedeutet dies: "Erstellen Sie eine Kopie des r1-Objekts, ändern Sie den Wert seiner isVegetarian-Eigenschaft in true und weisen Sie einer Variablen mit dem Namen r2 ein neues Objekt zu."  Dadurch wird eine neue Kopie des Objekts erstellt, und das ursprüngliche Objekt bleibt unverändert. <br><br>  Neben der Kopierfunktion bieten Datenklassen auch eine Reihe von Funktionen zum Aufteilen eines Datenobjekts in eine Reihe von Werten seiner Eigenschaften - dieser Vorgang wird als Destrukturierung bezeichnet.  Mal sehen, wie das gemacht wird. <br><br><h3>  Datenklassen definieren KomponentenN ... -Funktionen </h3><br>  Beim Definieren einer Datenklasse fügt der Compiler der Klasse automatisch eine Reihe von Funktionen hinzu, die als alternativer Mechanismus für den Zugriff auf Objekteigenschaftswerte verwendet werden können.  Diese Funktionen sind unter dem allgemeinen Namen der Komponenten-N-Funktionen bekannt, wobei N die Anzahl der abzurufenden Eigenschaften ist (in der Deklarationsreihenfolge). <br><br>  Angenommen, Sie haben das folgende Rezeptobjekt, um zu sehen, wie die Funktionen von componentN funktionieren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Wenn Sie den Wert der ersten Eigenschaft des Objekts (title-Eigenschaft) abrufen möchten, können Sie dazu die component1 () -Funktion des Objekts aufrufen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1()</code> </pre> <br>  component1 () gibt die Referenz zurück, die in der ersten im Konstruktor der Datenklasse definierten Eigenschaft enthalten ist. <br><br>  Die Funktion funktioniert wie der folgende Code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title</code> </pre> <br>  Der Code mit der Funktion ist universeller.  Warum sind die ComponentN-Funktionen in Datenklassen so nützlich? <br><br><h3>  ... zur Umstrukturierung von Datenobjekten </h3><br>  Die generischen componentN-Funktionen sind vor allem deshalb nützlich, weil sie eine einfache und bequeme Möglichkeit bieten, ein Datenobjekt in Eigenschaftswerte aufzuteilen oder zu zerstören. <br><br>  Angenommen, Sie möchten die Werte der Eigenschaften eines Rezeptobjekts übernehmen und den Wert jeder seiner Eigenschaften einer separaten Variablen zuweisen.  Anstelle von Code <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.isVegetarian</code> </pre> <br>  Bei der sequentiellen Verarbeitung jeder Eigenschaft können Sie den folgenden Code verwenden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r</code> </pre> <br>  Weist der ersten Eigenschaft r den Titel und der zweiten Eigenschaft den vegetarischen Titel zu. <br><br>  Dieser Code bedeutet "Erstellen Sie zwei Variablen, Titel und Vegetarisch, und weisen Sie den Wert einer der r Eigenschaften jeder Variablen zu."  Er macht dasselbe wie das nächste Fragment <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.component2()</code> </pre> <br>  aber es fällt kompakter aus. <br><br>  <b>Der Operator === prüft immer, ob sich zwei Variablen auf dasselbe Objekt beziehen.</b> <br><br>  Wenn Sie überprüfen möchten, ob zwei Variablen unabhängig von ihrem Typ auf dasselbe Objekt verweisen, verwenden Sie den Operator === anstelle von ==.  Der Operator === gibt das Ergebnis nur dann als wahr an, wenn (und nur wenn) zwei Variablen einen Verweis auf ein tatsächliches Objekt enthalten.  Wenn Sie zwei Variablen haben, x und y, und den folgenden Ausdruck: <br><br><pre> <code class="kotlin hljs">x === y</code> </pre> <br>  Wenn das Ergebnis true ist, wissen Sie, dass sich die Variablen x und y auf dasselbe Objekt beziehen müssen. <br><br>  Im Gegensatz zum Operator == ist das Verhalten des Operators === unabhängig von der Funktion equals.  Der Operator === verhält sich unabhängig vom Klassentyp immer gleich. <br><br>  Nachdem Sie gelernt haben, wie Sie Datenklassen erstellen und verwenden, erstellen Sie ein Projekt für den Rezeptcode. <br><br><h3>  Erstellen eines Rezeptprojekts </h3><br>  Erstellen Sie ein neues Kotlin-Projekt für die JVM und nennen Sie es "Rezepte".  Dann erstellen Sie eine neue <br>  Kotlin-Datei mit dem Namen Recipes.kt: Wählen Sie den Ordner src aus, öffnen Sie das Menü Datei und wählen Sie den Befehl aus <br>  Neu → Kotlin-Datei / Klasse.  Geben Sie den Dateinamen "Rezepte" ein und wählen Sie die Option "Datei" in der Gruppe "Art". <br><br>  Wir fügen dem Projekt eine neue Datenklasse mit dem Namen Rezept hinzu und erstellen Rezeptdatenobjekte.  Unten ist der Code.  Aktualisieren Sie Ihre Version von Recipes.kt und bringen Sie sie mit unserer in Einklang: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) (  {} ,        .) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r3 = r1.copy(title = <span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>) (  r1    title) println(<span class="hljs-string"><span class="hljs-string">"r1 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r2 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r2.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r3 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r3.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 toString: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.toString()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 === r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 === r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r3? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r3}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r1 ( r1) println(<span class="hljs-string"><span class="hljs-string">"title is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$title</span></span></span><span class="hljs-string"> and vegetarian is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$vegetarian</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br>  Wenn Sie Ihren Code ausführen, wird der folgende Text im Ausgabefenster der IDE angezeigt: <br><br><pre> <code class="kotlin hljs">r1 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r2 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r3 hash code: <span class="hljs-number"><span class="hljs-number">241131113</span></span> r1 toString: Recipe(title=Thai Curry, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>) r1 == r2? <span class="hljs-literal"><span class="hljs-literal">true</span></span> r1 === r2? <span class="hljs-literal"><span class="hljs-literal">false</span></span> r1 == r3? <span class="hljs-literal"><span class="hljs-literal">false</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Thai Curry and vegetarian <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br>  25% Rabatt auf Gutschein für Khabrozhitel - <b>Kotlin</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473614/">https://habr.com/ru/post/de473614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473600/index.html">Wer braucht Chromebooks?</a></li>
<li><a href="../de473602/index.html">Asynchron arbeiten</a></li>
<li><a href="../de473608/index.html">Ein Leitfaden zum Verständnis des Konzepts der modernen Web-App-Entwicklung</a></li>
<li><a href="../de473610/index.html">Analysieren der neuen Plesk Obsidian-Webkonsole</a></li>
<li><a href="../de473612/index.html">Abhandlung über den Stift. Gedanken zur Konfiguration und Arbeit mit Pins in C ++ für Mikrocontroller (am Beispiel von CortexM)</a></li>
<li><a href="../de473626/index.html">„Der Entwickler möchte in drei Jahren ein Flugzeug kaufen. Meine Aufgabe ist es, ihm zu helfen “- Denis Puschkin über die Motivation von Skyeng</a></li>
<li><a href="../de473628/index.html">C ++ im Dienste der Kieferorthopädie: Interview mit Mikhail Matrosov, CAD-Entwickler bei Align Technology</a></li>
<li><a href="../de473630/index.html">Best Practices und Tools für die Entwicklung von iOS-Anwendungen</a></li>
<li><a href="../de473632/index.html">Wir haben einen Artikel über Habr gesehen</a></li>
<li><a href="../de473634/index.html">Comcast-Lobbys verbieten die DNS-Verschlüsselung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>