<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔧 🎅🏼 👶🏼 Faites-en plus avec les modèles en C # 8.0 🙎 🏘️ 🏘️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Visual Studio 2019 Preview 2 est sorti! Et avec lui, quelques fonctionnalités C # 8.0 supplémentaires sont prêtes à être essayées. Il s'agit principal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faites-en plus avec les modèles en C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/438256/"><img width="120" align="left" src="https://habrastorage.org/webt/8w/rq/7v/8wrq7vfhyqv2saamr2d5z2jha5o.png"><p>  Visual Studio 2019 Preview 2 est sorti!  Et avec lui, quelques fonctionnalités C # 8.0 supplémentaires sont prêtes à être essayées.  Il s'agit principalement de correspondance de motifs, bien que j'aborde quelques autres nouvelles et modifications à la fin. </p><br><a name="habracut"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Original dans le blog</a> <br><br><h1>  Plus de modèles dans plus d'endroits </h1><br><p> Lorsque C # 7.0 a introduit la correspondance de modèles, nous avons dit que nous nous attendions à ajouter <em>plus de</em> modèles à <em>plus d'</em> endroits dans le futur.  Ce moment est venu!  Nous ajoutons ce que nous appelons <em>des modèles récursifs</em> , ainsi qu'une forme d'expression plus compacte d'instructions <code>switch</code> appelées (vous l'avez deviné!) <em>Expressions</em> switch. </p><br><p>  Voici un exemple simple de modèles C # 7.0 pour commencer: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { get; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { get; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre><br><h2>  Changer d'expressions </h2><br><p>  Tout d'abord, observons que de nombreuses instructions <code>switch</code> ne font pas vraiment beaucoup de travail intéressant au sein des corps de <code>case</code> .  Souvent, ils produisent tous une valeur, soit en l'affectant à une variable, soit en la renvoyant (comme ci-dessus).  Dans toutes ces situations, la déclaration switch est franchement plutôt maladroite.  Cela ressemble à la fonction linguistique vieille de 5 décennies, avec beaucoup de cérémonie. </p><br><p>  Nous avons décidé qu'il était temps d'ajouter une forme d'expression de <code>switch</code> .  Le voici, appliqué à l'exemple ci-dessus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre><br><p>  Il y a plusieurs choses ici qui ont changé par rapport aux instructions switch.  Énumérons-les: </p><br><ul><li>  Le mot-clé <code>switch</code> est "infixe" entre la valeur testée et la liste <code>{...}</code> de cas.  Cela le rend plus compositionnel avec d'autres expressions, et aussi plus facile à distinguer visuellement d'une instruction switch. </li><li>  Le mot clé <code>case</code> et le <code>:</code> ont été remplacés par une flèche lambda <code>=&gt;</code> par souci de concision. </li><li>  <code>default</code> a été remplacée par le modèle <code>_</code> discard pour plus de concision. </li><li>  Les corps sont des expressions!  Le résultat du corps sélectionné devient le résultat de l'expression de commutation. </li></ul><br><p>  Puisqu'une expression doit avoir une valeur ou lever une exception, une expression de commutateur qui atteint la fin sans correspondance lèvera une exception.  Le compilateur fait un excellent travail pour vous avertir lorsque cela peut être le cas, mais ne vous forcera pas à terminer toutes les expressions de commutateur avec un fourre-tout: vous le savez peut-être mieux! </p><br><p>  Bien sûr, puisque notre méthode <code>Display</code> se compose désormais d'une seule instruction return, nous pouvons la simplifier pour qu'elle soit dotée d'un corps d'expression: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Pour être honnête, je ne sais pas quelle orientation de mise en forme nous donnerons ici, mais il doit être clair que c'est beaucoup plus clair et clair, surtout parce que la brièveté vous permet généralement de formater le commutateur de manière "tabulaire", comme ci-dessus , avec des motifs et des corps sur la même ligne, et les <code>=&gt;</code> alignés les uns sous les autres. </p><br><p>  Soit dit en passant, nous prévoyons d'autoriser une virgule de fin <code>,</code> après le dernier cas, conformément à toutes les autres "listes séparées par des virgules entre accolades" en C #, mais l'aperçu 2 ne le permet pas encore. </p><br><h2>  Modèles de propriété </h2><br><p>  En parlant de brièveté, les motifs deviennent soudainement les éléments les plus lourds de l'expression de commutateur ci-dessus!  Faisons quelque chose à ce sujet. </p><br><p>  Notez que l'expression de commutateur utilise le <em>modèle de type</em> <code>Point p</code> (deux fois), ainsi qu'une clause <code>when</code> pour ajouter des conditions supplémentaires pour le premier <code>case</code> . </p><br><p>  Dans C # 8.0, nous ajoutons plus d'éléments facultatifs au modèle de type, ce qui permet au modèle lui-même de creuser davantage dans la valeur qui correspond au modèle.  Vous pouvez en faire un <em>modèle de propriété</em> en ajoutant des modèles imbriqués contenant des <code>{...}</code> à appliquer aux propriétés ou champs accessibles de la valeur.  Cela nous permet de réécrire l'expression de commutateur comme suit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } p =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Les deux cas vérifient toujours que <code>o</code> est un <code>Point</code> .  Le premier cas applique ensuite le motif constant <code>0</code> manière récursive aux propriétés <code>X</code> et <code>Y</code> de <code>p</code> , vérifiant si elles ont cette valeur.  Ainsi, nous pouvons éliminer la clause <code>when</code> dans ce cas et dans de nombreux cas courants. </p><br><p>  Le deuxième cas applique le modèle <code>var</code> à chacun de <code>X</code> et <code>Y</code>  Rappelez-vous que le modèle <code>var</code> en C # 7.0 réussit toujours et déclare simplement une nouvelle variable pour contenir la valeur.  Ainsi, <code>x</code> et <code>y</code> contiennent les valeurs int de <code>pX</code> et <code>pY</code> . </p><br><p>  Nous n'utilisons jamais <code>p</code> , et pouvons en fait l'omettre ici: </p><br><pre> <code class="cpp hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre><br><p>  Une chose qui reste vraie pour tous les modèles de type, y compris les modèles de propriété, est qu'ils nécessitent que la valeur soit non nulle.  Cela ouvre la possibilité que le modèle de propriété "vide" <code>{}</code> soit utilisé comme modèle compact "non nul".  Par exemple, nous pourrions remplacer le cas de secours par les deux cas suivants: </p><br><pre> <code class="cpp hljs"> {} =&gt; o.ToString(), null =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre><br><p>  Le <code>{}</code> traite des objets <code>null</code> nuls restants, et <code>null</code> obtient les nulls, donc le commutateur est exhaustif et le compilateur ne se plaindra pas de la chute des valeurs. </p><br><h2>  Modèles de position </h2><br><p>  Le modèle de propriété n'a pas exactement <em>raccourci</em> le deuxième cas de <code>Point</code> et ne semble pas en valoir la peine, mais il y a plus à faire. </p><br><p>  Notez que la classe <code>Point</code> a une méthode <code>Deconstruct</code> , un soi-disant <em>déconstructeur</em> .  En C # 7.0, les déconstructeurs permettaient de déconstruire une valeur lors de l'affectation, afin que vous puissiez écrire par exemple: </p><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre><br><p>  C # 7.0 n'a pas intégré la déconstruction aux motifs.  Cela change avec les <em>modèles de position</em> qui sont un moyen supplémentaire d'étendre les modèles de type en C # 8.0.  Si le type correspondant est un type de tuple ou a un déconstructeur, nous pouvons utiliser des modèles de position comme un moyen compact d'appliquer des modèles récursifs sans avoir à nommer les propriétés: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(var x, var y) =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Une fois que l'objet a été mis en correspondance en tant que <code>Point</code> , le déconstructeur est appliqué et les motifs imbriqués sont appliqués aux valeurs résultantes. </p><br><p>  Les déconstructeurs ne sont pas toujours appropriés.  Ils ne doivent être ajoutés qu'aux types où il est vraiment clair laquelle des valeurs est laquelle.  Pour une classe <code>Point</code> , par exemple, il est sûr et intuitif de supposer que la première valeur est <code>X</code> et la seconde est <code>Y</code> , donc l'expression de commutateur ci-dessus est intuitive et facile à lire. </p><br><h2>  Modèles de tuple </h2><br><p>  Un cas spécial très utile des modèles de position est lorsqu'ils sont appliqués à des tuples.  Si une instruction switch est appliquée directement à une expression de tuple, nous autorisons même la suppression du jeu de parenthèses supplémentaire, comme dans <code>switch (x, y, z)</code> au lieu de <code>switch ((x, y, z))</code> . </p><br><p>  Les modèles de tuple sont parfaits pour tester plusieurs éléments d'entrée en même temps.  Voici une implémentation simple d'une machine à états: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  Bien sûr, nous pourrions choisir d'inclure <code>hasKey</code> dans le tuple activé au lieu d'utiliser des clauses <code>when</code> - c'est vraiment une question de goût: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  Dans l'ensemble, j'espère que vous pouvez voir que les modèles récursifs et les expressions de commutateur peuvent conduire à une logique de programme plus claire et plus déclarative. </p><br><h1>  Autres fonctionnalités C # 8.0 dans l'aperçu 2 </h1><br><p>  Bien que les fonctionnalités de modèle soient les principales à être mises en ligne dans VS 2019 Preview 2, il y en a quelques-unes plus petites que j'espère que vous trouverez également utiles et amusantes.  Je n'entrerai pas dans les détails ici, mais je vais juste vous donner une brève description de chacun. </p><br><h2>  Utilisation de déclarations </h2><br><p>  En C #, l' <code>using</code> instructions entraîne toujours un niveau d'imbrication, ce qui peut être très ennuyeux et nuire à la lisibilité.  Pour les cas simples où vous voulez simplement qu'une ressource soit nettoyée à la fin d'une étendue, vous devez désormais <em>utiliser des déclarations à la</em> place.  Les déclarations <code>using</code> sont simplement des déclarations de variables locales avec un mot-clé <code>using</code> devant, et leur contenu est supprimé à la fin du bloc d'instructions en cours.  Donc au lieu de: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre><br><p>  Vous pouvez simplement écrire </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> var options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre><br><h2>  Structures de référence jetables </h2><br><p>  Les structures de référence ont été introduites dans C # 7.2, et ce n'est pas le lieu de réitérer leur utilité, mais en retour, elles comportent de sérieuses limitations, telles que l'impossibilité d'implémenter des interfaces.  Les structures de référence peuvent désormais être jetées sans implémenter l'interface <code>IDisposable</code> , simplement en ayant une méthode <code>Dispose</code> . </p><br><h2>  Fonctions locales statiques </h2><br><p>  Si vous voulez vous assurer que votre fonction locale n'entraîne pas les coûts d'exécution associés à la "capture" (référencement) des variables de la portée englobante, vous pouvez la déclarer <code>static</code> .  Ensuite, le compilateur empêchera la référence à tout ce qui est déclaré dans les fonctions englobantes - à l'exception d'autres fonctions locales statiques! </p><br><h1>  Changements depuis l'aperçu 1 </h1><br><p>  Les principales caractéristiques de l'aperçu 1 étaient des types de référence annulables et des flux asynchrones.  Les deux ont un peu évolué dans l'aperçu 2, donc si vous avez commencé à les utiliser, ce qui suit est bon à savoir. </p><br><h2>  Types de référence nullables </h2><br><p>  Nous avons ajouté plus d'options pour contrôler les avertissements <code>#nullable</code> à la fois dans la source (via <code>#pragma warning</code> directives d' <code>#pragma warning</code> <code>#nullable</code> et <code>#pragma warning</code> ) et au niveau du projet.  Nous avons également modifié l'opt-in du fichier de projet en <code>&lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt;</code> . </p><br><h2>  Flux asynchrones </h2><br><p>  Nous avons changé la forme de l' <code>IAsyncEnumerable&lt;T&gt;</code> le compilateur!  Cela met le compilateur hors de synchronisation avec l'interface fournie dans .NET Core 3.0 Preview 1, ce qui peut vous causer un certain nombre de problèmes.  Cependant, .NET Core 3.0 Preview 2 devrait sortir sous peu, ce qui ramène les interfaces à la synchronisation. </p><br><h1>  Allez-y! </h1><br><p>  Comme toujours, nous attendons vos commentaires!  Veuillez jouer avec les nouvelles fonctionnalités de motif en particulier.  Vous rencontrez des murs de briques?  Quelque chose de gênant?  Quels sont les scénarios sympas et utiles que vous leur trouvez?  Appuyez sur le bouton de rétroaction et faites-le nous savoir! </p><br><p>  Piratage heureux </p><br><p>  Mads Torgersen, responsable de la conception pour C # </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438256/">https://habr.com/ru/post/fr438256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438244/index.html">Nous traitons de la réglementation cryptographique russe ... en utilisant l'exemple de l'arrestation d'un seigneur de la drogue</a></li>
<li><a href="../fr438248/index.html">GitHub Action Life</a></li>
<li><a href="../fr438250/index.html">L'ignorance des principes de la sécurité de l'information n'exempte pas</a></li>
<li><a href="../fr438252/index.html">Pourquoi n'a pas décollé du portail immobilier. Partie 1</a></li>
<li><a href="../fr438254/index.html">Eclipse lance GlassFish 5.1 pour Java EE 8</a></li>
<li><a href="../fr438260/index.html">C ++ "moderne": une session de lamentations avec lamentations</a></li>
<li><a href="../fr438262/index.html">Systèmes cyber-physiques dans le monde moderne</a></li>
<li><a href="../fr438264/index.html">Chiffrement du trafic dans Direct Connect, partie 1</a></li>
<li><a href="../fr438266/index.html">Pourquoi le pentesting est important pour votre entreprise?</a></li>
<li><a href="../fr438270/index.html">Love Kubernetes chez Mail.ru Group: 14 février</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>