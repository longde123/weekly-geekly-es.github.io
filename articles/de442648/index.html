<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèø üôçüèø üëåüèª Go-Zuweisungsmechanismen üïê ‚òùÔ∏è ü§æüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich zum ersten Mal versuchte zu verstehen, wie die Speicherzuweisungswerkzeuge in Go funktionieren, schien mir das, was ich herausfinden wollte, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go-Zuweisungsmechanismen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442648/">  Als ich zum ersten Mal versuchte zu verstehen, wie die Speicherzuweisungswerkzeuge in Go funktionieren, schien mir das, was ich herausfinden wollte, wie eine mysteri√∂se Black Box.  Wie bei jeder anderen Technologie ist das Wichtigste hier hinter vielen Abstraktionsebenen verborgen, durch die Sie hindurch m√ºssen, um etwas zu verstehen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br>  Der Autor des Materials, dessen √úbersetzung wir ver√∂ffentlichen, hat beschlossen, die Mittel zur Speicherzuweisung in Go auf den Grund zu gehen und dar√ºber zu sprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Physischer und virtueller Speicher</font> </h2><br>  Alle Mittel zum Zuweisen von Speicher m√ºssen mit dem Adressraum des virtuellen Speichers arbeiten, der vom Betriebssystem gesteuert wird.  Lassen Sie uns einen Blick darauf werfen, wie Speicher funktioniert, beginnend auf der untersten Ebene - mit Speicherzellen. <br>  So stellen Sie sich eine RAM-Zelle vor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">Speicherzellenlayout</font></i> <br><br>  Wenn wir uns auf sehr vereinfachte Weise eine Speicherzelle vorstellen und was sie umgibt, erhalten wir Folgendes: <br><br><ol><li>  Die Adressleitung (der Transistor fungiert als Schalter) erm√∂glicht den Zugang zum Kondensator (Datenleitung). </li><li>  Wenn ein Signal in der Adresszeile (rote Linie) erscheint, k√∂nnen Sie √ºber die Datenleitung Daten in die Speicherzelle schreiben, dh den Kondensator aufladen, wodurch ein logischer Wert entsprechend 1 darin gespeichert werden kann. </li><li> Wenn in der Adressleitung (gr√ºne Leitung) kein Signal vorhanden ist, ist der Kondensator isoliert und seine Ladung √§ndert sich nicht.  Um in Zelle 0 zu schreiben, m√ºssen Sie ihre Adresse ausw√§hlen und eine logische 0 √ºber die Datenleitung senden, dh die Datenleitung mit einem Minus verbinden, wodurch der Kondensator entladen wird. </li><li>  Wenn der Prozessor den Wert aus dem Speicher lesen muss, wird das Signal entlang der Adressleitung gesendet (der Schalter schlie√üt).  Wenn der Kondensator geladen ist, geht das Signal durch die Datenleitung (1 wird gelesen), andernfalls geht das Signal nicht durch die Datenleitung (0 wird gelesen). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">Das Schema der Interaktion von physischem Speicher und Prozessor</font></i> <br><br>  Der Datenbus ist f√ºr den Transport von Daten zwischen dem Prozessor und dem physischen Speicher verantwortlich. <br><br>  Lassen Sie uns nun √ºber die Adresszeile und die adressierbaren Bytes sprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">Busadressleitungen zwischen Prozessor und physischem Speicher</font></i> <br><br><ol><li>  Jedem Byte im RAM wird eine eindeutige numerische Kennung (Adresse) zugewiesen.  Es ist zu beachten, dass die Anzahl der im Speicher vorhandenen physischen Bytes nicht gleich der Anzahl der Adressleitungen ist. </li><li>  Jede Adresszeile kann einen 1-Bit-Wert angeben, sodass ein Bit in der Adresse eines bestimmten Bytes angegeben wird. </li><li>  Unsere Schaltung hat 32 Adressleitungen.  Infolgedessen verwendet jedes adressierbare Byte eine 32-Bit-Nummer als Adresse.  [00000000000000000000000000000000] - die niedrigste Speicheradresse.  [11111111111111111111111111111111] - die h√∂chste Speicheradresse. </li><li>  Da jedes Byte eine 32-Bit-Adresse hat, besteht unser Adressraum aus 2 <sup>32</sup> adressierbaren Bytes (4 GB). </li></ol><br>  Als Ergebnis stellt sich heraus, dass die Anzahl der adressierbaren Bytes von der Gesamtzahl der Adressleitungen abh√§ngt.  Wenn beispielsweise 64 Adressleitungen (x86-64-Prozessoren) vorhanden sind, k√∂nnen Sie 2 <sup>64</sup> Byte (16 Exabyte) Speicher adressieren. Die meisten Architekturen, die 64-Bit-Zeiger verwenden, verwenden jedoch tats√§chlich 48-Bit-Adressleitungen (AMD64). und 42-Bit-Adressleitungen (Intel), mit denen Computer theoretisch mit 256 Terabyte physischem Speicher ausgestattet werden k√∂nnen (Linux erm√∂glicht auf der x86-64-Architektur bei Verwendung von Adressseiten der Ebene 4, Prozessen Prozesse mit bis zu 128 TB Adressraum zuzuweisen, mit Windows k√∂nnen Sie bis zu 128 TB Adressraum zuweisen 192 TB). <br>  Da die Gr√∂√üe des physischen Arbeitsspeichers begrenzt ist, wird jeder Prozess in einer eigenen "Sandbox" ausgef√ºhrt - im sogenannten "virtuellen Adressraum", dem so genannten virtuellen Speicher. <br><br>  Die Byteadressen im virtuellen Adressraum stimmen nicht mit den Adressen √ºberein, die der Prozessor f√ºr den Zugriff auf den physischen Speicher verwendet.  Daher ben√∂tigen wir ein System, mit dem wir virtuelle Adressen in physische Adressen konvertieren k√∂nnen.  Sehen Sie sich an, wie Adressen des virtuellen Speichers aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">Darstellung des virtuellen Adressraums</font></i> <br><br>  Wenn der Prozessor einen Befehl ausf√ºhrt, der sich auf eine Speicheradresse bezieht, besteht der erste Schritt darin, die logische Adresse in eine lineare Adresse zu √ºbersetzen.  Diese Konvertierung wird von der Speicherverwaltungseinheit durchgef√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">Vereinfachte Darstellung der Beziehung zwischen virtuellem und physischem Speicher</font></i> <br><br>  Da logische Adressen zu gro√ü sind, um separat damit arbeiten zu k√∂nnen (dies h√§ngt von verschiedenen Faktoren ab), ist der Speicher in Strukturen organisiert, die als Seiten bezeichnet werden.  In diesem Fall ist der virtuelle Adressraum in kleine Bereiche unterteilt, Seiten, die in den meisten Betriebssystemen 4 KB gro√ü sind, obwohl diese Gr√∂√üe normalerweise ge√§ndert werden kann.  Dies ist die kleinste Einheit der Speicherverwaltung im virtuellen Speicher.  Der virtuelle Speicher speichert nichts, sondern stellt lediglich die Entsprechung zwischen dem Adressraum des Programms und dem physischen Speicher ein. <br><br>  Prozesse sehen nur Adressen des virtuellen Speichers.  Was passiert, wenn ein Programm mehr dynamischen Speicher ben√∂tigt (auch Heapspeicher oder ‚ÄûHeap‚Äú genannt)?  Hier ist ein Beispiel f√ºr einfachen Assembler-Code, in dem zus√§tzlicher dynamisch zugewiesener Speicher vom System angefordert wird: <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br>  So kann es in Form eines Diagramms dargestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">Erh√∂hen Sie den dynamisch zugewiesenen Speicher</font></i> <br><br>  Das Programm fordert √ºber den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brk</a> -Systemaufruf (sbrk / mmap usw.) zus√§tzlichen Speicher an.  Der Kernel aktualisiert die Informationen zum virtuellen Speicher, aber neue Seiten wurden noch nicht im physischen Speicher angezeigt, und hier gibt es einen Unterschied zwischen virtuellem und physischem Speicher. <br><br><h2>  <font color="#3AC1EF">Speicherzuordnung</font> </h2><br>  Nachdem wir allgemein √ºber die Arbeit mit dem virtuellen Adressraum gesprochen und dar√ºber gesprochen haben, wie zus√§tzlicher dynamischer Speicher (Speicher auf dem Heap) angefordert werden kann, wird es f√ºr uns einfacher sein, √ºber Mittel zum Zuweisen von Speicher zu sprechen. <br><br>  Wenn der Heap √ºber gen√ºgend Speicher verf√ºgt, um unsere Codeanforderungen zu erf√ºllen, kann der Speicherzuweiser diese Anforderungen ausf√ºhren, ohne auf den Kernel zuzugreifen.  Andernfalls muss er den Heap mithilfe eines Systemaufrufs (z. B. brk) vergr√∂√üern und gleichzeitig einen gro√üen Speicherblock anfordern.  Im Fall von malloc bedeutet "gro√ü" die durch den Parameter <code>MMAP_THRESHOLD</code> Gr√∂√üe, die standardm√§√üig 128 <code>MMAP_THRESHOLD</code> betr√§gt. <br><br>  Ein Speicherzuweiser hat jedoch mehr Verantwortlichkeiten als nur das Zuweisen von Speicher.  Eine seiner wichtigsten Aufgaben ist es, die interne und externe Speicherfragmentierung zu reduzieren und Speicherbl√∂cke so schnell wie m√∂glich zuzuweisen.  Angenommen, unser Programm f√ºhrt nacheinander Anforderungen zum Zuweisen fortlaufender Speicherbl√∂cke unter Verwendung einer Funktion des Formulars <code>malloc(size)</code> , wonach dieser Speicher mithilfe einer Funktion des Formulars <code>free(pointer)</code> freigegeben wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">Demonstration der externen Fragmentierung</font></i> <br><br>  Im vorherigen Diagramm haben wir in Schritt p4 nicht gen√ºgend sequenziell angeordnete Speicherbl√∂cke, um die Anforderung der Zuweisung von sechs solchen Bl√∂cken zu erf√ºllen, obwohl die Gesamtmenge an freiem Speicher dies zul√§sst.  Diese Situation f√ºhrt zu einer Speicherfragmentierung. <br><br>  Wie kann die Speicherfragmentierung reduziert werden?  Die Antwort auf diese Frage h√§ngt vom spezifischen Speicherzuweisungsalgorithmus ab, auf dem die Basisbibliothek f√ºr die Arbeit mit dem Speicher verwendet wird. <br><br>  Jetzt schauen wir uns das TCMalloc-Speicherzuweisungstool an, auf dem die Go-Speicherzuweisungsmechanismen basieren. <br><br><h2>  <font color="#3AC1EF">TCMalloc</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TCMalloc</a> basiert auf der Idee, den Speicher in mehrere Ebenen zu unterteilen, um die Speicherfragmentierung zu verringern.  In TCMalloc ist die Speicherverwaltung in zwei Teile unterteilt: Arbeiten mit dem Thread-Speicher und Arbeiten mit dem Heap. <br><br><h3>  <font color="#3AC1EF">‚ñç Thread-Speicher</font> </h3><br>  Jede Speicherseite ist in eine Folge von Fragmenten bestimmter Gr√∂√üen unterteilt, die gem√§√ü den Gr√∂√üenklassen ausgew√§hlt werden.  Dies reduziert die Fragmentierung.  Infolgedessen verf√ºgt jeder Thread √ºber einen Cache f√ºr kleine Objekte, der eine sehr effiziente Speicherzuweisung f√ºr Objekte mit einer Gr√∂√üe von 32 KB oder weniger erm√∂glicht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">Stream-Cache</font></i> <br><br><h3>  <font color="#3AC1EF">¬ªB√ºndel</font> </h3><br>  Ein von TCMalloc verwalteter Heap ist eine Sammlung von Seiten, in denen eine Reihe aufeinanderfolgender Seiten als Seitenbereich (Bereich) dargestellt werden kann.  Wenn Sie Speicher f√ºr ein Objekt zuweisen m√ºssen, das gr√∂√üer als 32 KB ist, wird Heap zum Zuweisen von Speicher verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">Haufen und arbeiten mit Seiten</font></i> <br><br>  Wenn nicht gen√ºgend Speicherplatz vorhanden ist, um kleine Objekte im Speicher abzulegen, wenden sie sich an den Heap f√ºr den Speicher.  Wenn der Heap nicht √ºber gen√ºgend freien Speicher verf√ºgt, wird vom Betriebssystem zus√§tzlicher Speicher angefordert. <br><br>  Infolgedessen unterst√ºtzt das vorgestellte Modell der Arbeit mit Speicher den Speicherpool f√ºr den Benutzerbereich, da seine Verwendung die Effizienz beim Zuweisen und Freigeben von Speicher erheblich verbessert. <br><br>  Es ist zu beachten, dass das Go-Speicherzuweisungstool urspr√ºnglich auf TCMalloc basierte, sich jedoch geringf√ºgig davon unterscheidet. <br><br><h2>  <font color="#3AC1EF">Gehen Sie Speicherzuordnung</font> </h2><br>  Wir wissen, dass die Go-Laufzeit plant, Goroutinen auf logischen Prozessoren auszuf√ºhren.  In √§hnlicher Weise unterteilt die von Go verwendete Version von TCMalloc Speicherseiten in Bl√∂cke, deren Gr√∂√üe bestimmten Gr√∂√üenklassen entspricht, von denen 67 existieren. <br><br>  Wenn Sie mit dem Go-Scheduler nicht vertraut sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> dar√ºber lesen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">Gehen Sie Gr√∂√üenklassen</font></i> <br><br>  Da die minimale Seitengr√∂√üe in Go 8192 Bytes (8 KB) betr√§gt, erhalten wir 8 solcher Bl√∂cke, wenn eine solche Seite in Bl√∂cke von 1 KB unterteilt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">Eine Seitengr√∂√üe von 8 KB ist in Bl√∂cke unterteilt, die einer Klassengr√∂√üe von 1 KB entsprechen</font></i> <br><br>  √Ñhnliche Seitenfolgen in Go werden mithilfe einer Struktur namens mspan gesteuert. <br><br><h3>  <font color="#3AC1EF">‚ñçStruktur mspan</font> </h3><br>  Die mspan-Struktur ist eine doppelt verkn√ºpfte Liste, ein Objekt, das die Startadresse der Seite, Informationen zur Seitengr√∂√üe und die Anzahl der darin enthaltenen Seiten enth√§lt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Mspan Struktur</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç mcache-Struktur</font> </h3><br>  Wie TCMalloc stellt Go jedem logischen Prozessor einen lokalen Thread-Cache zur Verf√ºgung, der als mcache bezeichnet wird.  Wenn Goroutine Speicher ben√∂tigt, kann er diesen direkt aus mcache abrufen.  Dazu m√ºssen Sie keine Sperren durchf√ºhren, da zu einem bestimmten Zeitpunkt nur ein Goroutin auf einem logischen Prozessor ausgef√ºhrt wird. <br><br>  Die mcache-Struktur enth√§lt in Form eines Caches mspan-Strukturen verschiedener Gr√∂√üenklassen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">Interaktion zwischen logischem Prozessor, mcache und mspan in Go</font></i> <br><br>  Da jeder logische Prozessor √ºber einen eigenen mcache verf√ºgt, sind beim Zuweisen von Speicher aus mcache keine Sperren erforderlich. <br><br>  Jede Gr√∂√üenklasse kann durch eines der folgenden Objekte dargestellt werden: <br><br><ul><li>  Ein Scanobjekt ist ein Objekt, das einen Zeiger enth√§lt. </li><li>  Ein Noscan-Objekt ist ein Objekt, in dem es keinen Zeiger gibt. </li></ul><br>  Eine der St√§rken dieses Ansatzes besteht darin, dass Noscan-Objekte bei der Speicherbereinigung nicht umgangen werden m√ºssen, da sie keine Objekte enthalten, denen Speicher zugewiesen ist. <br><br>  Was kommt in mcache?  Objekte, deren Gr√∂√üe 32 KB nicht √ºberschreitet, werden mit mspan der entsprechenden Gr√∂√üenklasse direkt an mcache √ºbergeben. <br><br>  Was passiert, wenn mcache keine freie Zelle hat?  Dann erhalten sie einen neuen mspan der gew√ºnschten Gr√∂√üenklasse aus der Liste der mspan-Objekte mit dem Namen mcentral. <br><br><h3>  <font color="#3AC1EF">‚ñçZentrale Struktur</font> </h3><br>  Die zentrale Struktur sammelt alle Seitenbereiche einer bestimmten Gr√∂√üenklasse.  Jedes mcentral-Objekt enth√§lt zwei Listen von mspan-Objekten. <br><br><ol><li>  Liste der mspan-Objekte, in denen keine freien Objekte vorhanden sind, oder der mspan-Objekte, die sich im mcache befinden. </li><li>  Liste der mspan-Objekte mit freien Objekten. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">Mcentrale Struktur</font></i> <br><br>  Jede zentrale Struktur existiert innerhalb der mheap-Struktur. <br><br><h3>  <font color="#3AC1EF">HeaHaufenstruktur</font> </h3><br>  Die mheap-Struktur wird durch ein Objekt dargestellt, das die Heap-Verwaltung in Go √ºbernimmt.  Es gibt nur ein solches globales Objekt, das einen virtuellen Adressraum besitzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">Mheap Struktur</font></i> <br><br>  Wie Sie dem obigen Diagramm entnehmen k√∂nnen, enth√§lt die mheap-Struktur ein Array von mcentral-Strukturen.  Dieses Array enth√§lt zentrale Strukturen f√ºr alle Gr√∂√üenklassen. <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br>  Da wir f√ºr jede Gr√∂√üenklasse eine mcentral-Struktur haben, wird auf mcentral-Ebene eine Sperre angewendet, wenn mcache die mspan-Struktur von mcentral anfordert. Infolgedessen k√∂nnen Anforderungen von anderen mcache-anfordernden mspan-Strukturen anderer Gr√∂√üen gleichzeitig bedient werden. <br><br>  Durch die Ausrichtung (Pad) wird sichergestellt, dass die zentralen Strukturen durch die Anzahl der Bytes, die dem <code>CacheLineSize</code> Wert entsprechen, <code>CacheLineSize</code> sind.  Infolgedessen verf√ºgt jede <code>mcentral.lock</code> √ºber eine eigene Cache-Zeile, wodurch die Probleme vermieden werden, die mit einer falschen Speicherfreigabe verbunden sind. <br><br>  Was passiert, wenn die mcentral-Liste leer ist?  Dann empf√§ngt mcentral eine Folge von Seiten von mheap, um Speicherfragmente der erforderlichen Gr√∂√üenklasse zuzuweisen. <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code> ist ein Array von spanList.  Die mspan-Struktur in jeder spanList besteht aus 1 ~ 127 (_MaxMHeapList - 1) Seiten.  Zum Beispiel ist free [3] eine verkn√ºpfte Liste von mspan-Strukturen mit 3 Seiten.  Das Wort "frei" zeigt in diesem Fall an, dass es sich um eine leere Liste handelt, in der kein Speicher zugeordnet ist.  Eine Liste kann im Gegensatz zu einer leeren Liste eine Liste sein, in der Speicher zugewiesen ist (belegt). </li><li>  <code>freelarge mSpanList</code> ist eine Liste der freien mspan-Strukturen.  Die Anzahl der Seiten pro Element (dh mspan) betr√§gt mehr als 127. Zur Unterst√ºtzung dieser Liste wird die mtreap-Datenstruktur verwendet.  Die Liste der ausgelasteten mspan-Strukturen wird als Busylarge bezeichnet. </li></ul><br>  Objekte, die gr√∂√üer als 32 KB sind, werden als gro√üe Objekte betrachtet. Der Speicher f√ºr sie wird direkt von mheap zugewiesen.  Anforderungen zum Zuweisen von Speicher f√ºr solche Objekte werden unter Verwendung einer Sperre ausgef√ºhrt, so dass zu einem bestimmten Zeitpunkt eine √§hnliche Anforderung von nur einem logischen Prozessor verarbeitet werden kann. <br><br><h2>  <font color="#3AC1EF">Der Prozess des Zuweisens von Speicher f√ºr Objekte</font> </h2><br><ul><li>  Wenn die Gr√∂√üe des Objekts 32 KB √ºberschreitet, wird es als gro√ü angesehen. Der Speicher daf√ºr wird direkt von mheap zugewiesen. </li><li>  Wenn die Gr√∂√üe des Objekts weniger als 16 KB betr√§gt, wird der als winziger Allokator bezeichnete mcache-Mechanismus verwendet. </li><li>  Wenn die Gr√∂√üe des Objekts im Bereich von 16 bis 32 KB liegt, stellt sich heraus, welche Gr√∂√üenklasse (sizeClass) verwendet werden soll, und ein geeigneter Block wird in mcache zugewiesen. </li><li>  Wenn in der sizeClass, die mcache entspricht, keine Bl√∂cke verf√ºgbar sind, wird mcentral aufgerufen. </li><li>  Wenn mcentral keine freien Bl√∂cke hat, rufen sie mheap auf und suchen nach dem am besten geeigneten mspan.  Wenn sich herausstellt, dass die von der Anwendung ben√∂tigte Speichergr√∂√üe gr√∂√üer ist als zugeordnet werden kann, wird die angeforderte Speichergr√∂√üe verarbeitet, sodass so viele Seiten zur√ºckgegeben werden k√∂nnen, wie vom Programm ben√∂tigt werden, nachdem eine neue mspan-Struktur gebildet wurde. </li><li>  Wenn der virtuelle Speicher der Anwendung immer noch nicht ausreicht, wird f√ºr einen neuen Satz von Seiten auf das Betriebssystem zugegriffen (mindestens 1 MB Speicher wird angefordert). </li></ul><br>  Tats√§chlich fordert Go auf Betriebssystemebene die Zuweisung noch gr√∂√üerer Speicherelemente, die als Arenen bezeichnet werden.  Durch die gleichzeitige Zuweisung gro√üer Speicherfragmente k√∂nnen Sie einen Kompromiss zwischen der der Anwendung zugewiesenen Speichermenge und dem kostspieligen Zugriff auf das Betriebssystem in Bezug auf die Leistung finden. <br><br>  Der auf dem Heap angeforderte Speicher wird von der Arena zugewiesen.  Betrachten Sie diesen Mechanismus. <br><br><h2>  <font color="#3AC1EF">Virtueller Speicher gehen</font> </h2><br>  Sehen Sie sich die Speichernutzung mit einem einfachen Programm an, das in Go geschrieben wurde: <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">Programmprozessinformationen</font></i> <br><br>  Der virtuelle Adressraum selbst eines solchen einfachen Programms betr√§gt ungef√§hr 100 MB, w√§hrend der RSS-Index nur 696 KB betr√§gt.  Versuchen wir zun√§chst, den Grund f√ºr diese Diskrepanz herauszufinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">Karten- und Smap-Informationen</font></i> <br><br>  Hier sehen Sie die Speicherbereiche, deren Gr√∂√üe ungef√§hr 2 MB, 64 MB, 32 MB entspricht.  Was ist das f√ºr eine Erinnerung? <br><br><h3>  <font color="#3AC1EF">‚ñçArena</font> </h3><br>  Es stellt sich heraus, dass der virtuelle Speicher in Go aus einer Reihe von Arenen besteht.  Die anf√§ngliche Speichergr√∂√üe f√ºr den Heap entspricht einer Arena, dh - 64 MB (dies ist relevant f√ºr Go 1.11.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">Aktuelle Arena-Gr√∂√üe in verschiedenen Systemen</font></i> <br><br>  Infolgedessen wird der f√ºr die aktuellen Anforderungen des Programms ben√∂tigte Speicher in kleinen Teilen zugewiesen.  Dieser Prozess beginnt mit einer 64-MB-Arena. <br><br>  Diese numerischen Indikatoren, √ºber die wir hier sprechen, sollten nicht f√ºr einige absolute und unver√§nderte Werte herangezogen werden.  Sie k√∂nnen sich √§ndern.  Fr√ºher hat Go beispielsweise einen kontinuierlichen virtuellen Speicherplatz im Voraus reserviert. Auf 64-Bit-Systemen betrug die Arena-Gr√∂√üe 512 GB (es ist interessant zu √ºberlegen, was passiert, wenn der reale Speicherbedarf so gro√ü ist, dass die entsprechende Anforderung von mmap abgelehnt wird?). <br><br>  Tats√§chlich nennen wir eine Reihe von Arenen eine Reihe.  In Go werden Arenen als Speicherfragmente wahrgenommen, die in Bl√∂cke mit einer Gr√∂√üe von 8192 Bytes (8 KB) unterteilt sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">Eine 64 MB Arena</font></i> <br><br>  Go hat noch ein paar verschiedene Arten von Bl√∂cken - Span und Bitmap.  Der Speicher f√ºr sie wird au√üerhalb des Heaps zugewiesen, sie speichern Arena-Metadaten.  Sie werden haupts√§chlich in der M√ºllabfuhr verwendet. <br>  Hier finden Sie eine allgemeine √úbersicht √ºber die Funktionsweise der Speicherzuweisungsmechanismen in Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">Allgemeiner √úberblick √ºber die Speicherzuweisungsmechanismen in Go</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Im Allgemeinen kann angemerkt werden, dass wir in diesem Material die Subsysteme f√ºr die Arbeit mit Go-Speicher sehr allgemein beschrieben haben.  Die Hauptidee des Speichersubsystems in Go besteht darin, Speicher mithilfe verschiedener Strukturen und Caches auf verschiedenen Ebenen zuzuweisen.  Dies ber√ºcksichtigt die Gr√∂√üe der Objekte, denen Speicher zugewiesen ist. <br><br>  Die Darstellung eines einzelnen Blocks kontinuierlicher Speicheradressen, die vom Betriebssystem in Form einer mehrstufigen Struktur empfangen werden, erh√∂ht die Effizienz des Speicherzuweisungsmechanismus aufgrund der Tatsache, dass dieser Ansatz das Blockieren vermeidet.  Die Zuweisung von Ressourcen unter Ber√ºcksichtigung der Gr√∂√üe der Objekte, die im Speicher gespeichert werden m√ºssen, verringert die Fragmentierung und erm√∂glicht es Ihnen, nach dem Freigeben des Speichers die Speicherbereinigung zu beschleunigen. <br><br>  <b>Liebe Leser!</b>  Haben Sie Probleme mit Speicherfehlern in in Go geschriebenen Programmen festgestellt? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442648/">https://habr.com/ru/post/de442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442638/index.html">Kubernetes Anwendungsskalierung basierend auf Metriken von Prometheus</a></li>
<li><a href="../de442640/index.html">Perfekter Fehler: Verwenden von Typverwirrung in Flash. Teil 1</a></li>
<li><a href="../de442642/index.html">Was Sie im M√§rz lesen sollten: 22 neue B√ºcher f√ºr Vermarkter, Manager, Entwickler und Designer</a></li>
<li><a href="../de442644/index.html">Die meisten Nicht-Programmierkenntnisse erh√∂hen den Entwicklerwert</a></li>
<li><a href="../de442646/index.html">Kubernetes Networks: Ingress</a></li>
<li><a href="../de442650/index.html">Analyse und Optimierung von React-Anwendungen</a></li>
<li><a href="../de442652/index.html">Verwenden von Fastify und Preact zum schnellen Prototypen von Webanwendungen</a></li>
<li><a href="../de442654/index.html">Wechseln Sie zu Next.js und beschleunigen Sie das Laden der Manifold.co-Homepage um das 7,5-fache</a></li>
<li><a href="../de442658/index.html">8 Tricks f√ºr die Arbeit mit CSS: Parallaxe, Sticky Footer und andere</a></li>
<li><a href="../de442660/index.html">Mathematik vers√∂hnt Newton mit der Quantenwelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>