<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏿 🙍🏿 👌🏻 Go-Zuweisungsmechanismen 🕐 ☝️ 🤾🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich zum ersten Mal versuchte zu verstehen, wie die Speicherzuweisungswerkzeuge in Go funktionieren, schien mir das, was ich herausfinden wollte, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go-Zuweisungsmechanismen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442648/">  Als ich zum ersten Mal versuchte zu verstehen, wie die Speicherzuweisungswerkzeuge in Go funktionieren, schien mir das, was ich herausfinden wollte, wie eine mysteriöse Black Box.  Wie bei jeder anderen Technologie ist das Wichtigste hier hinter vielen Abstraktionsebenen verborgen, durch die Sie hindurch müssen, um etwas zu verstehen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br>  Der Autor des Materials, dessen Übersetzung wir veröffentlichen, hat beschlossen, die Mittel zur Speicherzuweisung in Go auf den Grund zu gehen und darüber zu sprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Physischer und virtueller Speicher</font> </h2><br>  Alle Mittel zum Zuweisen von Speicher müssen mit dem Adressraum des virtuellen Speichers arbeiten, der vom Betriebssystem gesteuert wird.  Lassen Sie uns einen Blick darauf werfen, wie Speicher funktioniert, beginnend auf der untersten Ebene - mit Speicherzellen. <br>  So stellen Sie sich eine RAM-Zelle vor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">Speicherzellenlayout</font></i> <br><br>  Wenn wir uns auf sehr vereinfachte Weise eine Speicherzelle vorstellen und was sie umgibt, erhalten wir Folgendes: <br><br><ol><li>  Die Adressleitung (der Transistor fungiert als Schalter) ermöglicht den Zugang zum Kondensator (Datenleitung). </li><li>  Wenn ein Signal in der Adresszeile (rote Linie) erscheint, können Sie über die Datenleitung Daten in die Speicherzelle schreiben, dh den Kondensator aufladen, wodurch ein logischer Wert entsprechend 1 darin gespeichert werden kann. </li><li> Wenn in der Adressleitung (grüne Leitung) kein Signal vorhanden ist, ist der Kondensator isoliert und seine Ladung ändert sich nicht.  Um in Zelle 0 zu schreiben, müssen Sie ihre Adresse auswählen und eine logische 0 über die Datenleitung senden, dh die Datenleitung mit einem Minus verbinden, wodurch der Kondensator entladen wird. </li><li>  Wenn der Prozessor den Wert aus dem Speicher lesen muss, wird das Signal entlang der Adressleitung gesendet (der Schalter schließt).  Wenn der Kondensator geladen ist, geht das Signal durch die Datenleitung (1 wird gelesen), andernfalls geht das Signal nicht durch die Datenleitung (0 wird gelesen). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">Das Schema der Interaktion von physischem Speicher und Prozessor</font></i> <br><br>  Der Datenbus ist für den Transport von Daten zwischen dem Prozessor und dem physischen Speicher verantwortlich. <br><br>  Lassen Sie uns nun über die Adresszeile und die adressierbaren Bytes sprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">Busadressleitungen zwischen Prozessor und physischem Speicher</font></i> <br><br><ol><li>  Jedem Byte im RAM wird eine eindeutige numerische Kennung (Adresse) zugewiesen.  Es ist zu beachten, dass die Anzahl der im Speicher vorhandenen physischen Bytes nicht gleich der Anzahl der Adressleitungen ist. </li><li>  Jede Adresszeile kann einen 1-Bit-Wert angeben, sodass ein Bit in der Adresse eines bestimmten Bytes angegeben wird. </li><li>  Unsere Schaltung hat 32 Adressleitungen.  Infolgedessen verwendet jedes adressierbare Byte eine 32-Bit-Nummer als Adresse.  [00000000000000000000000000000000] - die niedrigste Speicheradresse.  [11111111111111111111111111111111] - die höchste Speicheradresse. </li><li>  Da jedes Byte eine 32-Bit-Adresse hat, besteht unser Adressraum aus 2 <sup>32</sup> adressierbaren Bytes (4 GB). </li></ol><br>  Als Ergebnis stellt sich heraus, dass die Anzahl der adressierbaren Bytes von der Gesamtzahl der Adressleitungen abhängt.  Wenn beispielsweise 64 Adressleitungen (x86-64-Prozessoren) vorhanden sind, können Sie 2 <sup>64</sup> Byte (16 Exabyte) Speicher adressieren. Die meisten Architekturen, die 64-Bit-Zeiger verwenden, verwenden jedoch tatsächlich 48-Bit-Adressleitungen (AMD64). und 42-Bit-Adressleitungen (Intel), mit denen Computer theoretisch mit 256 Terabyte physischem Speicher ausgestattet werden können (Linux ermöglicht auf der x86-64-Architektur bei Verwendung von Adressseiten der Ebene 4, Prozessen Prozesse mit bis zu 128 TB Adressraum zuzuweisen, mit Windows können Sie bis zu 128 TB Adressraum zuweisen 192 TB). <br>  Da die Größe des physischen Arbeitsspeichers begrenzt ist, wird jeder Prozess in einer eigenen "Sandbox" ausgeführt - im sogenannten "virtuellen Adressraum", dem so genannten virtuellen Speicher. <br><br>  Die Byteadressen im virtuellen Adressraum stimmen nicht mit den Adressen überein, die der Prozessor für den Zugriff auf den physischen Speicher verwendet.  Daher benötigen wir ein System, mit dem wir virtuelle Adressen in physische Adressen konvertieren können.  Sehen Sie sich an, wie Adressen des virtuellen Speichers aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">Darstellung des virtuellen Adressraums</font></i> <br><br>  Wenn der Prozessor einen Befehl ausführt, der sich auf eine Speicheradresse bezieht, besteht der erste Schritt darin, die logische Adresse in eine lineare Adresse zu übersetzen.  Diese Konvertierung wird von der Speicherverwaltungseinheit durchgeführt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">Vereinfachte Darstellung der Beziehung zwischen virtuellem und physischem Speicher</font></i> <br><br>  Da logische Adressen zu groß sind, um separat damit arbeiten zu können (dies hängt von verschiedenen Faktoren ab), ist der Speicher in Strukturen organisiert, die als Seiten bezeichnet werden.  In diesem Fall ist der virtuelle Adressraum in kleine Bereiche unterteilt, Seiten, die in den meisten Betriebssystemen 4 KB groß sind, obwohl diese Größe normalerweise geändert werden kann.  Dies ist die kleinste Einheit der Speicherverwaltung im virtuellen Speicher.  Der virtuelle Speicher speichert nichts, sondern stellt lediglich die Entsprechung zwischen dem Adressraum des Programms und dem physischen Speicher ein. <br><br>  Prozesse sehen nur Adressen des virtuellen Speichers.  Was passiert, wenn ein Programm mehr dynamischen Speicher benötigt (auch Heapspeicher oder „Heap“ genannt)?  Hier ist ein Beispiel für einfachen Assembler-Code, in dem zusätzlicher dynamisch zugewiesener Speicher vom System angefordert wird: <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br>  So kann es in Form eines Diagramms dargestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">Erhöhen Sie den dynamisch zugewiesenen Speicher</font></i> <br><br>  Das Programm fordert über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brk</a> -Systemaufruf (sbrk / mmap usw.) zusätzlichen Speicher an.  Der Kernel aktualisiert die Informationen zum virtuellen Speicher, aber neue Seiten wurden noch nicht im physischen Speicher angezeigt, und hier gibt es einen Unterschied zwischen virtuellem und physischem Speicher. <br><br><h2>  <font color="#3AC1EF">Speicherzuordnung</font> </h2><br>  Nachdem wir allgemein über die Arbeit mit dem virtuellen Adressraum gesprochen und darüber gesprochen haben, wie zusätzlicher dynamischer Speicher (Speicher auf dem Heap) angefordert werden kann, wird es für uns einfacher sein, über Mittel zum Zuweisen von Speicher zu sprechen. <br><br>  Wenn der Heap über genügend Speicher verfügt, um unsere Codeanforderungen zu erfüllen, kann der Speicherzuweiser diese Anforderungen ausführen, ohne auf den Kernel zuzugreifen.  Andernfalls muss er den Heap mithilfe eines Systemaufrufs (z. B. brk) vergrößern und gleichzeitig einen großen Speicherblock anfordern.  Im Fall von malloc bedeutet "groß" die durch den Parameter <code>MMAP_THRESHOLD</code> Größe, die standardmäßig 128 <code>MMAP_THRESHOLD</code> beträgt. <br><br>  Ein Speicherzuweiser hat jedoch mehr Verantwortlichkeiten als nur das Zuweisen von Speicher.  Eine seiner wichtigsten Aufgaben ist es, die interne und externe Speicherfragmentierung zu reduzieren und Speicherblöcke so schnell wie möglich zuzuweisen.  Angenommen, unser Programm führt nacheinander Anforderungen zum Zuweisen fortlaufender Speicherblöcke unter Verwendung einer Funktion des Formulars <code>malloc(size)</code> , wonach dieser Speicher mithilfe einer Funktion des Formulars <code>free(pointer)</code> freigegeben wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">Demonstration der externen Fragmentierung</font></i> <br><br>  Im vorherigen Diagramm haben wir in Schritt p4 nicht genügend sequenziell angeordnete Speicherblöcke, um die Anforderung der Zuweisung von sechs solchen Blöcken zu erfüllen, obwohl die Gesamtmenge an freiem Speicher dies zulässt.  Diese Situation führt zu einer Speicherfragmentierung. <br><br>  Wie kann die Speicherfragmentierung reduziert werden?  Die Antwort auf diese Frage hängt vom spezifischen Speicherzuweisungsalgorithmus ab, auf dem die Basisbibliothek für die Arbeit mit dem Speicher verwendet wird. <br><br>  Jetzt schauen wir uns das TCMalloc-Speicherzuweisungstool an, auf dem die Go-Speicherzuweisungsmechanismen basieren. <br><br><h2>  <font color="#3AC1EF">TCMalloc</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TCMalloc</a> basiert auf der Idee, den Speicher in mehrere Ebenen zu unterteilen, um die Speicherfragmentierung zu verringern.  In TCMalloc ist die Speicherverwaltung in zwei Teile unterteilt: Arbeiten mit dem Thread-Speicher und Arbeiten mit dem Heap. <br><br><h3>  <font color="#3AC1EF">▍ Thread-Speicher</font> </h3><br>  Jede Speicherseite ist in eine Folge von Fragmenten bestimmter Größen unterteilt, die gemäß den Größenklassen ausgewählt werden.  Dies reduziert die Fragmentierung.  Infolgedessen verfügt jeder Thread über einen Cache für kleine Objekte, der eine sehr effiziente Speicherzuweisung für Objekte mit einer Größe von 32 KB oder weniger ermöglicht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">Stream-Cache</font></i> <br><br><h3>  <font color="#3AC1EF">»Bündel</font> </h3><br>  Ein von TCMalloc verwalteter Heap ist eine Sammlung von Seiten, in denen eine Reihe aufeinanderfolgender Seiten als Seitenbereich (Bereich) dargestellt werden kann.  Wenn Sie Speicher für ein Objekt zuweisen müssen, das größer als 32 KB ist, wird Heap zum Zuweisen von Speicher verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">Haufen und arbeiten mit Seiten</font></i> <br><br>  Wenn nicht genügend Speicherplatz vorhanden ist, um kleine Objekte im Speicher abzulegen, wenden sie sich an den Heap für den Speicher.  Wenn der Heap nicht über genügend freien Speicher verfügt, wird vom Betriebssystem zusätzlicher Speicher angefordert. <br><br>  Infolgedessen unterstützt das vorgestellte Modell der Arbeit mit Speicher den Speicherpool für den Benutzerbereich, da seine Verwendung die Effizienz beim Zuweisen und Freigeben von Speicher erheblich verbessert. <br><br>  Es ist zu beachten, dass das Go-Speicherzuweisungstool ursprünglich auf TCMalloc basierte, sich jedoch geringfügig davon unterscheidet. <br><br><h2>  <font color="#3AC1EF">Gehen Sie Speicherzuordnung</font> </h2><br>  Wir wissen, dass die Go-Laufzeit plant, Goroutinen auf logischen Prozessoren auszuführen.  In ähnlicher Weise unterteilt die von Go verwendete Version von TCMalloc Speicherseiten in Blöcke, deren Größe bestimmten Größenklassen entspricht, von denen 67 existieren. <br><br>  Wenn Sie mit dem Go-Scheduler nicht vertraut sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> darüber lesen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">Gehen Sie Größenklassen</font></i> <br><br>  Da die minimale Seitengröße in Go 8192 Bytes (8 KB) beträgt, erhalten wir 8 solcher Blöcke, wenn eine solche Seite in Blöcke von 1 KB unterteilt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">Eine Seitengröße von 8 KB ist in Blöcke unterteilt, die einer Klassengröße von 1 KB entsprechen</font></i> <br><br>  Ähnliche Seitenfolgen in Go werden mithilfe einer Struktur namens mspan gesteuert. <br><br><h3>  <font color="#3AC1EF">▍Struktur mspan</font> </h3><br>  Die mspan-Struktur ist eine doppelt verknüpfte Liste, ein Objekt, das die Startadresse der Seite, Informationen zur Seitengröße und die Anzahl der darin enthaltenen Seiten enthält. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Mspan Struktur</font></i> <br><br><h3>  <font color="#3AC1EF">▍ mcache-Struktur</font> </h3><br>  Wie TCMalloc stellt Go jedem logischen Prozessor einen lokalen Thread-Cache zur Verfügung, der als mcache bezeichnet wird.  Wenn Goroutine Speicher benötigt, kann er diesen direkt aus mcache abrufen.  Dazu müssen Sie keine Sperren durchführen, da zu einem bestimmten Zeitpunkt nur ein Goroutin auf einem logischen Prozessor ausgeführt wird. <br><br>  Die mcache-Struktur enthält in Form eines Caches mspan-Strukturen verschiedener Größenklassen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">Interaktion zwischen logischem Prozessor, mcache und mspan in Go</font></i> <br><br>  Da jeder logische Prozessor über einen eigenen mcache verfügt, sind beim Zuweisen von Speicher aus mcache keine Sperren erforderlich. <br><br>  Jede Größenklasse kann durch eines der folgenden Objekte dargestellt werden: <br><br><ul><li>  Ein Scanobjekt ist ein Objekt, das einen Zeiger enthält. </li><li>  Ein Noscan-Objekt ist ein Objekt, in dem es keinen Zeiger gibt. </li></ul><br>  Eine der Stärken dieses Ansatzes besteht darin, dass Noscan-Objekte bei der Speicherbereinigung nicht umgangen werden müssen, da sie keine Objekte enthalten, denen Speicher zugewiesen ist. <br><br>  Was kommt in mcache?  Objekte, deren Größe 32 KB nicht überschreitet, werden mit mspan der entsprechenden Größenklasse direkt an mcache übergeben. <br><br>  Was passiert, wenn mcache keine freie Zelle hat?  Dann erhalten sie einen neuen mspan der gewünschten Größenklasse aus der Liste der mspan-Objekte mit dem Namen mcentral. <br><br><h3>  <font color="#3AC1EF">▍Zentrale Struktur</font> </h3><br>  Die zentrale Struktur sammelt alle Seitenbereiche einer bestimmten Größenklasse.  Jedes mcentral-Objekt enthält zwei Listen von mspan-Objekten. <br><br><ol><li>  Liste der mspan-Objekte, in denen keine freien Objekte vorhanden sind, oder der mspan-Objekte, die sich im mcache befinden. </li><li>  Liste der mspan-Objekte mit freien Objekten. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">Mcentrale Struktur</font></i> <br><br>  Jede zentrale Struktur existiert innerhalb der mheap-Struktur. <br><br><h3>  <font color="#3AC1EF">HeaHaufenstruktur</font> </h3><br>  Die mheap-Struktur wird durch ein Objekt dargestellt, das die Heap-Verwaltung in Go übernimmt.  Es gibt nur ein solches globales Objekt, das einen virtuellen Adressraum besitzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">Mheap Struktur</font></i> <br><br>  Wie Sie dem obigen Diagramm entnehmen können, enthält die mheap-Struktur ein Array von mcentral-Strukturen.  Dieses Array enthält zentrale Strukturen für alle Größenklassen. <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br>  Da wir für jede Größenklasse eine mcentral-Struktur haben, wird auf mcentral-Ebene eine Sperre angewendet, wenn mcache die mspan-Struktur von mcentral anfordert. Infolgedessen können Anforderungen von anderen mcache-anfordernden mspan-Strukturen anderer Größen gleichzeitig bedient werden. <br><br>  Durch die Ausrichtung (Pad) wird sichergestellt, dass die zentralen Strukturen durch die Anzahl der Bytes, die dem <code>CacheLineSize</code> Wert entsprechen, <code>CacheLineSize</code> sind.  Infolgedessen verfügt jede <code>mcentral.lock</code> über eine eigene Cache-Zeile, wodurch die Probleme vermieden werden, die mit einer falschen Speicherfreigabe verbunden sind. <br><br>  Was passiert, wenn die mcentral-Liste leer ist?  Dann empfängt mcentral eine Folge von Seiten von mheap, um Speicherfragmente der erforderlichen Größenklasse zuzuweisen. <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code> ist ein Array von spanList.  Die mspan-Struktur in jeder spanList besteht aus 1 ~ 127 (_MaxMHeapList - 1) Seiten.  Zum Beispiel ist free [3] eine verknüpfte Liste von mspan-Strukturen mit 3 Seiten.  Das Wort "frei" zeigt in diesem Fall an, dass es sich um eine leere Liste handelt, in der kein Speicher zugeordnet ist.  Eine Liste kann im Gegensatz zu einer leeren Liste eine Liste sein, in der Speicher zugewiesen ist (belegt). </li><li>  <code>freelarge mSpanList</code> ist eine Liste der freien mspan-Strukturen.  Die Anzahl der Seiten pro Element (dh mspan) beträgt mehr als 127. Zur Unterstützung dieser Liste wird die mtreap-Datenstruktur verwendet.  Die Liste der ausgelasteten mspan-Strukturen wird als Busylarge bezeichnet. </li></ul><br>  Objekte, die größer als 32 KB sind, werden als große Objekte betrachtet. Der Speicher für sie wird direkt von mheap zugewiesen.  Anforderungen zum Zuweisen von Speicher für solche Objekte werden unter Verwendung einer Sperre ausgeführt, so dass zu einem bestimmten Zeitpunkt eine ähnliche Anforderung von nur einem logischen Prozessor verarbeitet werden kann. <br><br><h2>  <font color="#3AC1EF">Der Prozess des Zuweisens von Speicher für Objekte</font> </h2><br><ul><li>  Wenn die Größe des Objekts 32 KB überschreitet, wird es als groß angesehen. Der Speicher dafür wird direkt von mheap zugewiesen. </li><li>  Wenn die Größe des Objekts weniger als 16 KB beträgt, wird der als winziger Allokator bezeichnete mcache-Mechanismus verwendet. </li><li>  Wenn die Größe des Objekts im Bereich von 16 bis 32 KB liegt, stellt sich heraus, welche Größenklasse (sizeClass) verwendet werden soll, und ein geeigneter Block wird in mcache zugewiesen. </li><li>  Wenn in der sizeClass, die mcache entspricht, keine Blöcke verfügbar sind, wird mcentral aufgerufen. </li><li>  Wenn mcentral keine freien Blöcke hat, rufen sie mheap auf und suchen nach dem am besten geeigneten mspan.  Wenn sich herausstellt, dass die von der Anwendung benötigte Speichergröße größer ist als zugeordnet werden kann, wird die angeforderte Speichergröße verarbeitet, sodass so viele Seiten zurückgegeben werden können, wie vom Programm benötigt werden, nachdem eine neue mspan-Struktur gebildet wurde. </li><li>  Wenn der virtuelle Speicher der Anwendung immer noch nicht ausreicht, wird für einen neuen Satz von Seiten auf das Betriebssystem zugegriffen (mindestens 1 MB Speicher wird angefordert). </li></ul><br>  Tatsächlich fordert Go auf Betriebssystemebene die Zuweisung noch größerer Speicherelemente, die als Arenen bezeichnet werden.  Durch die gleichzeitige Zuweisung großer Speicherfragmente können Sie einen Kompromiss zwischen der der Anwendung zugewiesenen Speichermenge und dem kostspieligen Zugriff auf das Betriebssystem in Bezug auf die Leistung finden. <br><br>  Der auf dem Heap angeforderte Speicher wird von der Arena zugewiesen.  Betrachten Sie diesen Mechanismus. <br><br><h2>  <font color="#3AC1EF">Virtueller Speicher gehen</font> </h2><br>  Sehen Sie sich die Speichernutzung mit einem einfachen Programm an, das in Go geschrieben wurde: <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">Programmprozessinformationen</font></i> <br><br>  Der virtuelle Adressraum selbst eines solchen einfachen Programms beträgt ungefähr 100 MB, während der RSS-Index nur 696 KB beträgt.  Versuchen wir zunächst, den Grund für diese Diskrepanz herauszufinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">Karten- und Smap-Informationen</font></i> <br><br>  Hier sehen Sie die Speicherbereiche, deren Größe ungefähr 2 MB, 64 MB, 32 MB entspricht.  Was ist das für eine Erinnerung? <br><br><h3>  <font color="#3AC1EF">▍Arena</font> </h3><br>  Es stellt sich heraus, dass der virtuelle Speicher in Go aus einer Reihe von Arenen besteht.  Die anfängliche Speichergröße für den Heap entspricht einer Arena, dh - 64 MB (dies ist relevant für Go 1.11.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">Aktuelle Arena-Größe in verschiedenen Systemen</font></i> <br><br>  Infolgedessen wird der für die aktuellen Anforderungen des Programms benötigte Speicher in kleinen Teilen zugewiesen.  Dieser Prozess beginnt mit einer 64-MB-Arena. <br><br>  Diese numerischen Indikatoren, über die wir hier sprechen, sollten nicht für einige absolute und unveränderte Werte herangezogen werden.  Sie können sich ändern.  Früher hat Go beispielsweise einen kontinuierlichen virtuellen Speicherplatz im Voraus reserviert. Auf 64-Bit-Systemen betrug die Arena-Größe 512 GB (es ist interessant zu überlegen, was passiert, wenn der reale Speicherbedarf so groß ist, dass die entsprechende Anforderung von mmap abgelehnt wird?). <br><br>  Tatsächlich nennen wir eine Reihe von Arenen eine Reihe.  In Go werden Arenen als Speicherfragmente wahrgenommen, die in Blöcke mit einer Größe von 8192 Bytes (8 KB) unterteilt sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">Eine 64 MB Arena</font></i> <br><br>  Go hat noch ein paar verschiedene Arten von Blöcken - Span und Bitmap.  Der Speicher für sie wird außerhalb des Heaps zugewiesen, sie speichern Arena-Metadaten.  Sie werden hauptsächlich in der Müllabfuhr verwendet. <br>  Hier finden Sie eine allgemeine Übersicht über die Funktionsweise der Speicherzuweisungsmechanismen in Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">Allgemeiner Überblick über die Speicherzuweisungsmechanismen in Go</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Im Allgemeinen kann angemerkt werden, dass wir in diesem Material die Subsysteme für die Arbeit mit Go-Speicher sehr allgemein beschrieben haben.  Die Hauptidee des Speichersubsystems in Go besteht darin, Speicher mithilfe verschiedener Strukturen und Caches auf verschiedenen Ebenen zuzuweisen.  Dies berücksichtigt die Größe der Objekte, denen Speicher zugewiesen ist. <br><br>  Die Darstellung eines einzelnen Blocks kontinuierlicher Speicheradressen, die vom Betriebssystem in Form einer mehrstufigen Struktur empfangen werden, erhöht die Effizienz des Speicherzuweisungsmechanismus aufgrund der Tatsache, dass dieser Ansatz das Blockieren vermeidet.  Die Zuweisung von Ressourcen unter Berücksichtigung der Größe der Objekte, die im Speicher gespeichert werden müssen, verringert die Fragmentierung und ermöglicht es Ihnen, nach dem Freigeben des Speichers die Speicherbereinigung zu beschleunigen. <br><br>  <b>Liebe Leser!</b>  Haben Sie Probleme mit Speicherfehlern in in Go geschriebenen Programmen festgestellt? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442648/">https://habr.com/ru/post/de442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442638/index.html">Kubernetes Anwendungsskalierung basierend auf Metriken von Prometheus</a></li>
<li><a href="../de442640/index.html">Perfekter Fehler: Verwenden von Typverwirrung in Flash. Teil 1</a></li>
<li><a href="../de442642/index.html">Was Sie im März lesen sollten: 22 neue Bücher für Vermarkter, Manager, Entwickler und Designer</a></li>
<li><a href="../de442644/index.html">Die meisten Nicht-Programmierkenntnisse erhöhen den Entwicklerwert</a></li>
<li><a href="../de442646/index.html">Kubernetes Networks: Ingress</a></li>
<li><a href="../de442650/index.html">Analyse und Optimierung von React-Anwendungen</a></li>
<li><a href="../de442652/index.html">Verwenden von Fastify und Preact zum schnellen Prototypen von Webanwendungen</a></li>
<li><a href="../de442654/index.html">Wechseln Sie zu Next.js und beschleunigen Sie das Laden der Manifold.co-Homepage um das 7,5-fache</a></li>
<li><a href="../de442658/index.html">8 Tricks für die Arbeit mit CSS: Parallaxe, Sticky Footer und andere</a></li>
<li><a href="../de442660/index.html">Mathematik versöhnt Newton mit der Quantenwelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>