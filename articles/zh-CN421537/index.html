<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈲 ⭐️ 🥊 JS：年轻战士课程中的高阶函数 📙 👣 🤛🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文适用于在学习JavaScript的棘手道路上迈出怯first第一步的人。 尽管事实上在2018年，我还是使用ES5语法，以便正在HTML学院学习JavaScript Level 1课程的年轻Padawans可以理解本文。 

 将JS与许多其他编程语言区分开的功能之一是，在该语言中，函数是“一流...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS：年轻战士课程中的高阶函数</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421537/">  <i>本文适用于在学习JavaScript的棘手道路上迈出怯first第一步的人。</i>  <i>尽管事实上在2018年，我还是使用ES5语法，以便正在HTML学院学习JavaScript Level 1课程的年轻Padawans可以理解本文。</i> <br><br> 将JS与许多其他编程语言区分开的功能之一是，在该语言中，函数是“一流的对象”。 或者，在俄语中，功能就是含义。 与数字，字符串或对象相同。 我们可以将函数写入变量，可以将其放入数组或对象属性中。 我们甚至可以添加两个功能。 实际上，这没有任何意义，但是事实上-我们可以！ <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">world</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hello + world); <span class="hljs-comment"><span class="hljs-comment">//  ,  ,   //   ,    </span></span></code> </pre> <br> 最有趣的是，我们可以创建对其他函数进行操作的函数-接受它们作为参数或将它们返回为值。 这些函数称为<i>高阶函数</i> 。 今天，我们的男孩和女孩，将谈论如何使这一机会适应国民经济的需求。 在此过程中，您将了解有关JS函数的一些有用功能的更多信息。 <br><a name="habracut"></a><br><h3> 流水线 </h3><br> 假设我们有一件事情需要您做很多事情。 假设某个用户上传了一个文本文件，该文件以JSON格式存储数据，而我们想处理其内容。 首先，我们需要修剪多余的空白字符，这些空白字符可能会由于用户操作或操作系统而“增长”。 然后检查文本中是否没有恶意代码（谁知道这些用户）。 然后使用<code>JSON.parse</code>方法从文本转换为对象。 然后从该对象中删除我们需要的数据。 最后-将这些数据发送到服务器。 您得到的是这样的： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trim</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extractData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textFromFile = getTextFromFile(); send(extractData(parse(sanitize(trim(testFromFile))));</code> </pre><br> 看起来很同意。 此外，您可能没有注意到缺少一个结束括号。 当然，IDE会告诉您这一点，但是仍然存在问题。 为了解决这个问题，最近提出了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新的运算符|&gt;</a> 。 实际上，它不是新事物，而是从功能语言中诚实地借用的，但这不是重点。 使用此运算符，可以将最后一行重写如下： <br><br><pre> <code class="javascript hljs">textFromFile |&gt; trim |&gt; sanitize |&gt; parse |&gt; extractData |&gt; send;</code> </pre><br>  |&gt;运算符将其左操作数作为参数传递给右操作数。 例如， <code>"Hello" |&gt; console.log</code>等效于<code>console.log("Hello")</code> 。 恰好在沿着链调用多个函数的情况下，这非常方便。 但是，在引入此运算符之前，将花费很多时间（如果完全接受此建议），但是您现在必须以某种方式生活。 因此，我们可以为<s>自行车</s>编写<s>一个</s>模拟此行为<s>的</s>函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = args.shift(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(args.length){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = args.shift(); result = f(result); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } pipe( textFromFile, trim, sanitize, parse, extractData, send );</code> </pre><br> 如果您是新手javascript专家（javascript？Javascript？），则函数的第一行对您来说似乎很难理解。 很简单：在函数内部，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">arguments</a>关键字访问包含传递给函数的所有参数的类似数组的对象。 当我们事先不知道她会有多少论点时，这非常方便。 大型对象就像一个数组，但不尽相同。 因此，我们使用<code>Array.from</code>方法将其转换为普通数组。 我希望进一步的代码已经很容易理解：我们从左到右开始从数组中提取元素，并以与|&gt;运算符相同的方式将它们彼此应用。 <br><br><h3> 记录中 </h3><br> 这是另一个接近现实生活的例子。 假设我们已经有一个函数<code>f</code> ，它确实有用。 在测试我们的代码的过程中，我们想了解更多有关<code>f</code>是如何执行的信息。 在什么时候被调用，传递给它什么参数，返回什么值。 <br><br> 当然，对于每个函数调用，我们都可以这样编写： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = f(a, b); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" f     "</span></span> + a + <span class="hljs-string"><span class="hljs-string">"  "</span></span> + b + <span class="hljs-string"><span class="hljs-string">"   "</span></span> + result); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" : "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now());</code> </pre><br> 但是，首先，这很麻烦。 其次，很容易忘记它。 有一天，我们将简单地写下<code>f(a, b)</code> ，从那时起，无知的黑暗就会沉入我们的脑海。 它将随着每个新的挑战<code>f</code>而扩展，我们对此一无所知。 <br><br> 理想情况下，我希望日志自动发生。 这样，每次调用<code>f</code> ，我们需要的所有内容都会写入控制台。 而且，幸运的是，我们有办法做到这一点。 满足新的更高阶功能！ <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = f.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" "</span></span> + f.name + <span class="hljs-string"><span class="hljs-string">"     "</span></span> + args.join() + <span class="hljs-string"><span class="hljs-string">"    "</span></span> + result + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sumWithLogging = addLogger(sum); sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   sumWithLogging(1, 2) // </span></span></code> </pre><br> 函数接受一个函数并返回一个函数，该函数在创建函数时调用传递给该函数的函数。 抱歉，我无法停止写这篇文章。 现在以俄语显示： <code>addLogger</code>函数围绕作为参数传递给它的函数创建一个<code>addLogger</code> 。 包装也是一种功能。 当被调用时，它以与前面的示例相同的方式收集其参数数组。 然后，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apply</a>方法，它将调用具有相同参数的包装函数并记住结果。 之后，包装器将所有内容写入控制台。 <br><br> 这里有经典的中间人攻击案例。 如果使用包装器而不是<code>f</code> ，那么从使用包装器的代码的角度来看，实际上没有什么区别。 该代码可以假定它直接与<code>f</code>通信。 同时，包装人员将所有情况报告给少校同志。 <br><br><h3>  Eins，Zwei，Drei，Vier ... </h3><br> 还有一项接近实践的任务。 假设我们需要编号一些实体。 每次出现新实体时，我们都会为其获取一个新编号，该编号比前一个多。 为此，我们启动以下形式的函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastNumber = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNewNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lastNumber++; }</code> </pre><br> 然后我们有了一种新的实体。 说，在此之前，我们给兔子编号了，现在也有兔子了。 如果您同时使用一个函数和其他函数，则发给兔子的每个数字都会在发给兔子的一系列数字中产生“空洞”。 因此，我们需要第二个函数，并带有第二个变量： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastHareNumber = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNewHareNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lastHareNumber++; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastRabbitNumber = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNewRabbitNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lastRabbitNumber++; }</code> </pre><br> 您觉得这段代码难闻吗？ 我想要更好的东西。 首先，我希望能够在不重复代码的情况下声明此类函数。 其次，我想以某种方式将函数使用的变量“打包”到函数本身中，以免再次阻塞命名空间。 <br><br><div class="spoiler">  <b class="spoiler_title">然后一个男人突然熟悉OOP的概念，说道：</b> <div class="spoiler_text">  “小学，沃森。” 有必要使数字生成器不是对象，而是对象。 对象只是设计用来存储与数据一起使用的功能以及这些数据。 然后，我们可以编写如下内容： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberGenerator(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = numberGenerator.get();</code> </pre><br> 我将回答： <br>  -老实说，我完全同意你的看法。 原则上，这是比我现在提供的方法更正确的方法。 但是这里我们有一篇关于函数的文章，而不是关于OOP的文章。 那么，您可以保持安静一段时间，让我结束吗？ <br></div></div><br> 在这里（惊奇！）高阶函数将再次为我们提供帮助。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createNumberGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getNewHareNumber = createNumberGenerator(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getNewRabbitNumber = createNumberGenerator(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( getNewHareNumber(), getNewHareNumber(), getNewHareNumber(), getNewRabbitNumber(), getNewRabbitNumber(), ); <span class="hljs-comment"><span class="hljs-comment">//    0, 1, 2, 0, 1</span></span></code> </pre><br> 在这里有些人甚至可能以淫秽的形式提出一个问题：到底发生了什么？ 为什么我们要创建一个函数本身不使用的变量？ 如果外部函数很早就完成了执行，内部函数将如何访问它？ 为什么两个创建的引用相同变量的函数得到不同的结果？ 对所有这些问题的答案之一就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关闭</a> 。 <br><br> 每次<code>createNumberGenerator</code>函数时，JS解释器都会创建一个神奇的东西，称为“执行上下文”。 粗略地说，这是一个对象，其中存储了在此函数中声明的所有变量。 我们不能作为普通的javascript对象来访问它，但是确实如此。 <br><br> 如果函数是“简单的”（例如，加上数字），那么在工作结束后，执行上下文将变得无用。 您知道JS中不必要的数据会发生什么情况吗？ 他们被一个名为垃圾收集器的贪得无厌的恶魔吞噬。 但是，如果该功能“复杂”，则即使执行了该功能，也可能有人仍需要其上下文。 在这种情况下，垃圾收集器会饶恕他，并且他仍会挂在他的记忆中，以便那些需要他的人仍然可以使用他。 <br><br> 因此，由<code>createNumberGenerator</code>返回的<code>createNumberGenerator</code>将始终有权访问其自己的变量<code>n</code>副本。 您可以将其视为D＆D的“手提袋”。 您将手放在包里，发现自己在一个个人的多维“口袋”中，可以存放所需的所有物品。 <br><br><h3> 去抖 </h3><br> 有一种“消除反弹”的东西。 这是我们不希望某些函数被频繁调用的时候。 假设有一个按钮，单击该按钮将启动“昂贵”（耗时长，或占用大量内存，或Internet，或牺牲处女）过程。 不耐烦的用户可能开始以超过十赫兹的频率单击此按钮。 此外，上述过程具有这样的性质：连续运行十次没有任何意义，因为最终结果不会改变。 然后就是我们应用“消除抖动”。 <br><br> 它的本质非常简单：我们不是立即执行功能，而是在一段时间后执行。 如果在此时间之前，函数再次被调用，我们将“重置计时器”。 因此，用户可以单击按钮至少一千次-牺牲只需要一次。 但是，更少的单词，更多的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debounce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, delay</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastTimeout; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lastTimeout){ clearTimeout(lastTimeout); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); lastTimeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ f.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); }, delay); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sacrifice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name + <span class="hljs-string"><span class="hljs-string">"     * *"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sacrificeDebounced</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debounce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sacrifice, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sacrificeDebounced</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sacrificeDebounced</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sacrificeDebounced</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">);</span></span></code> </pre><br>  Lena将在半秒内牺牲，而Katya和Sveta将得益于我们的神奇功能而幸存下来。 <br><br> 如果您仔细阅读了前面的示例，则应该对这里的所有工作方式有很好的了解。 通过<code>debounce</code>创建的包装函数使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">setTimeout</a>触发原始函数的延迟执行。 在这种情况下，超时标识符存储在lastTimeout变量中，由于关闭，包装程序可以访问该变量。 如果超时标识符已经在此变量中，则包装器使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">clearTimeout</a>取消此超时。 如果先前的超时已经完成，则什么都不会发生。 如果没有，那么对他来说更糟。 <br><br> 到此，也许我将结束。 我希望今天您学到了很多新东西，最重要的是，您了解了所学到的一切。 再见。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421537/">https://habr.com/ru/post/zh-CN421537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421527/index.html">广播“云中的服务器”项目的启动</a></li>
<li><a href="../zh-CN421529/index.html">Netflix，Uber，Google和您参加MBLT DEV 2018</a></li>
<li><a href="../zh-CN421531/index.html">如何使用Globus网络的示例在后端自动生成模板，从而将ReactJS集成到1C-Bitrix中</a></li>
<li><a href="../zh-CN421533/index.html">选择一种编程语言：Apple程序员的3个技巧</a></li>
<li><a href="../zh-CN421535/index.html">冒险-电子产品。 在IT世界中飞速发展</a></li>
<li><a href="../zh-CN421543/index.html">使用移动应用程序克隆非接触式卡</a></li>
<li><a href="../zh-CN421545/index.html">PocketBook 616的评论-具有背光功能的最经济实惠的2018袖珍本</a></li>
<li><a href="../zh-CN421547/index.html">独立数据中心验收</a></li>
<li><a href="../zh-CN421549/index.html">我们正在编写技术文档：外行指南</a></li>
<li><a href="../zh-CN421551/index.html">精通Vuex-从零到英雄</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>