<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìë üîÜ üë©üèº‚Äçü§ù‚Äçüë©üèª Eine andere M√∂glichkeit, Docker-Images f√ºr Java-Anwendungen zu optimieren üö∂üèª üíá ü§õüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte der Bildoptimierung f√ºr Java-Anwendungen begann mit dem Spring-Blog-Artikel Spring Boot in a Container . Es wurden verschiedene Aspekte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine andere M√∂glichkeit, Docker-Images f√ºr Java-Anwendungen zu optimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458260/"><p> Die Geschichte der Bildoptimierung f√ºr Java-Anwendungen begann mit dem Spring-Blog-Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Boot in a Container</a> .  Es wurden verschiedene Aspekte beim Erstellen von Docker-Images f√ºr Spring-Boot-Anwendungen er√∂rtert, einschlie√ülich eines so interessanten Problems wie der Reduzierung der Gr√∂√üe von Images.  F√ºr unsere Teams war dies aus mehreren Gr√ºnden relevant, daher haben wir beschlossen, diese L√∂sung auf unsere Anwendungen anzuwenden. </p><br><p>  Wie so oft hat sich nicht alles beim ersten Mal gel√∂st, es gab Nuancen bei Projekten mit mehreren Modulen und den Versuch, all dies auf dem CI-System voranzutreiben. In diesem Artikel finden Sie eine L√∂sung f√ºr diese Probleme. </p><br><p>  Ziel der Optimierung ist es, den <em>Unterschied</em> zwischen den resultierenden Bildern von Baugruppe zu Baugruppe zu verringern. Dies f√ºhrt zu einem guten Ergebnis bei der kontinuierlichen Lieferung. Wenn Sie also die Gr√∂√üe des Bilds als solches minimieren m√∂chten, k√∂nnen Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> auf dem Hub verweisen </p><br><p>  Wenn Sie nicht erkl√§ren m√ºssen, warum Sie etwas mit einer Multimeter-Startanwendung tun sollten, bevor Sie sie in das Image einf√ºgen, k√∂nnen Sie sofort mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung des Optimierungsansatzes fortfahren</a> .  Wenn Sie den Artikel aus dem Fr√ºhjahrsblog kennengelernt haben, k√∂nnen Sie mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">L√∂sung der gefundenen Probleme</a> fortfahren. </p><a name="habracut"></a><br><h1 id="zachem-eto-vse-ili-obratnaya-storona-fat-jara">  Warum ist das alles oder die Kehrseite des fetten Glases? </h1><br><p>  Standardm√§√üig ist das von Spring Boot erzeugte JAR eine ausf√ºhrbare JAR-Datei, die den Anwendungscode und alle seine Abh√§ngigkeiten enth√§lt. </p><br><p> Der Vorteil dieses Ansatzes liegt auf der Hand: Es ist praktisch, mit einer Datei zu arbeiten. Sie enth√§lt alles, was Sie zum Ausf√ºhren von <code>java -jar &lt;myapp&gt;.jar</code> ben√∂tigen.  Dockerfile ist trivial und nicht von Interesse. </p><br><p>  Der Nachteil ist ineffiziente Speicherung.  In einer klassischen Boot-Anwendung spricht das Verh√§ltnis von Code und Bibliotheken eindeutig nicht f√ºr unseren Code.  Eine leere Anwendung mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webpart</a> und Bibliotheken f√ºr die Arbeit mit der Datenbank, die √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">start.spring.io</a> generiert werden kann, ben√∂tigt beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">20</a> MB, von denen 98% Bibliotheken sind.  Und dieses Verh√§ltnis √§ndert sich w√§hrend des Entwicklungsprozesses nicht wesentlich. </p><br><p>  Wir erfassen die Anwendung jedoch mehrmals, jedoch regelm√§√üig auf dem CI-Server, und stellen sie dann in einer Reihe von Umgebungen bereit.  Somit wachsen 10 Baugruppen bei 200 MB und 100 bei 2 GB, von denen √Ñnderungen nur sehr wenig ben√∂tigen. </p><br><p>  Es kann argumentiert werden, dass dies f√ºr die aktuellen Speicherkosten l√§cherliche Zahlen sind und Sie keine Zeit mit solchen Optimierungen verschwenden k√∂nnen, aber alles h√§ngt von der Gr√∂√üe der Organisation und der Anzahl der Anwendungen ab, deren Bilder gespeichert werden m√ºssen.  Die Bereitstellungsbedingungen k√∂nnen auch stark motivieren: Wenn sich die Registrierung und der Server in der N√§he befinden, ist selbst ein Unterschied von 100 MB nicht sehr auff√§llig. In verteilten Systemen kann dies jedoch viel wichtiger sein, insbesondere wenn Sie in bestimmten L√§ndern wie China mit seiner Firewall und instabilen Kan√§len bereitstellen m√ºssen nach au√üen. </p><br><p>  Wenn die Gr√ºnde herausgefunden sind, ist es Zeit zu optimieren. </p><br><h1 id="anchoroptimizinganchor-optimiziruem-sborku-ili-chto-mozhno-pocherpnut-iz-springovogo-bloga"><a name="optimizing"></a>  Wir optimieren die Montage oder Was kann man dem Fr√ºhlingsblog entnehmen? </h1><br><p>  Der Artikel bietet eine vern√ºnftige L√∂sung: Anstelle einer einzelnen Ebene, die mit dem <code>COPY my-jar.jar app.jar</code> generiert wird, m√ºssen mehrere Ebenen erstellt werden. <br>  Eine Ebene enth√§lt Bibliotheken, die zweite ist unser eigener Code.  Dazu m√ºssen Sie die JAR-Datei entpacken und den Inhalt auf verschiedene Bildebenen kopieren. </p><br><p>  Das Skript zum Vorbereiten der JAR-Datei sieht folgenderma√üen aus: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh set -e path_to_jar=$1 dir=$(dirname "${path_to_jar}") jar_name=$(basename "${path_to_jar}") mkdir -p "${dir}/docker-dist" &amp;&amp; cd "${dir}/docker-dist" jar -xf ../"${jar_name}"</span></span></code> </pre> <br><p>  Eine Docker-Datei mit einem mehrstufigen Build k√∂nnte folgenderma√üen aussehen </p><br><pre> <code class="plaintext hljs">FROM openjdk:8-jdk-alpine as build WORKDIR /wd COPY prepare_for_docker.sh /usr/local/bin/prepare_for_docker COPY target/demo.jar /wd/app.jar RUN prepare_for_docker /wd/app.jar FROM openjdk:8-jdk-alpine COPY --from=build /wd/docker-dist/BOOT-INF/lib /app/lib COPY --from=build /wd/docker-dist/META-INF /app/META-INF COPY --from=build /wd/docker-dist/BOOT-INF/classes /app ENTRYPOINT ["java","-cp","app:app/lib/*","com.example.demo.DemoApplication"]</code> </pre> <br><p>  In der ersten Phase kopieren wir alles, was wir brauchen, f√ºhren unser Skript aus, um die JAR-Datei zu entpacken, und in der zweiten Phase legen wir separate Bibliotheken und unseren Code separat in Ebenen an. </p><br><p>  Es ist einfach, die Funktionsf√§higkeit sicherzustellen: </p><br><ol><li>  Zum ersten Mal sammeln </li><li>  Nehmen Sie √Ñnderungen an unserem Code vor. </li><li>  Wir starten <code>docker build</code> erneut und sehen die gesch√§tzten Zeilen <code>Using cache</code> beim Kopieren des gesamten lib-Verzeichnisses <br><pre> <code class="plaintext hljs">... Step 5/10 : RUN prepare_for_docker app.jar ---&gt; Running in c8e422491eb2 Removing intermediate container c8e422491eb2 ---&gt; c7dcec4ae18a Step 6/10 : FROM openjdk:8-jdk-alpine ---&gt; a3562aa0b991 Step 7/10 : COPY --from=build /wd/docker-dist/BOOT-INF/lib /app/lib ---&gt; Using cache ---&gt; 01b600d7e350 Step 8/10 : COPY --from=build /wd/docker-dist/META-INF /app/META-INF ---&gt; Using cache ---&gt; 5c0c03a3c8f1 Step 9/10 : COPY --from=build /wd/docker-dist/BOOT-INF/classes /app ---&gt; 5ffed6ee5696 Step 10/10 : ENTRYPOINT ["java","-cp","app:app/lib/*","com.example.demo.DemoApplication"] ---&gt; Running in 99957250fe5d Removing intermediate container 99957250fe5d ---&gt; 6735799d9f32 Successfully built 6735799d9f32 Successfully tagged boot2-sample:latest</code> </pre> </li></ol><br><p>  Eine naheliegende M√∂glichkeit, diesen Ansatz zu verbessern, besteht darin, ein kleines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Basisimage</a> mit einem Skript zu erstellen, um es nicht von Projekt zu Projekt zu ziehen.  Dadurch wird die erste Schicht pr√§gnanter. </p><br><pre> <code class="plaintext hljs">FROM zeldigas/java-layered-builder as build COPY target/demo.jar app.jar RUN prepare_for_docker app.jar</code> </pre> <br><h1 id="anchorimprovementsanchordorabatyvaem-reshenie"><a name="improvements"></a>  Wir stellen die L√∂sung fertig </h1><br><p>  Wie bereits am Anfang des Artikels erw√§hnt, funktioniert die L√∂sung, aber w√§hrend der Operation wurden einige Probleme gefunden, die sp√§ter besprochen werden. </p><br><h2 id="ne-vse-fayly-v-lib-odinakovo-bibliotechny">  Nicht alle Dateien in <code>lib</code> gleicherma√üen bibliothekarisch </h2><br><p>  Wenn Ihr Projekt aus mehreren Modulen besteht (zumindest gibt es Modul A, von dem Modul B abh√§ngt, das als Federfettglas zusammengebaut ist) und eine Originall√∂sung darauf anwendet, werden Sie feststellen, dass kein Layer-Caching auftritt.  Was ist schief gelaufen? </p><br><p>  Die Sache ist in zus√§tzlichen Modulen: Sie sind Quellen f√ºr st√§ndige √Ñnderungen f√ºr die Ebene, auch wenn Sie keine √Ñnderungen am Modulcode vornehmen.  Dies liegt an der Besonderheit, Maven-JAR-Dateien zu erstellen (bei Gradle ist die Situation etwas besser, aber nicht sicher).  Die Aufgabe, reproduzierbare Artefakte zu erhalten, ist nicht das Thema dieses Artikels (obwohl dies nat√ºrlich interessant und erreichbar ist), daher werden wir zu einer ziemlich einfachen L√∂sung √ºbergehen. </p><br><p>  Wir verteilen den Inhalt von <code>lib</code> nach dem Entpacken in 2 Verzeichnisse und trennen die Projektmodule von anderen Bibliotheken.  Lassen Sie uns das Skript zum Auspacken des fetten Glases fertigstellen: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh set -e path_to_jar=$1 shift #(1) app_modules=$* #(2) dir=$(dirname "${path_to_jar}") jar_name=$(basename "${path_to_jar}") mkdir -p "${dir}/docker-dist" &amp;&amp; cd "${dir}/docker-dist" jar -xf ../"${jar_name}" if [ -n "${app_modules}" ]; then #(3) mkdir app-lib for i in $app_modules; do mv "BOOT-INF/lib/$i"* app-lib #(4) done fi</span></span></code> </pre> <br><p>  Infolgedessen begann das Skript, die √úbertragung zus√§tzlicher Parameter zu unterst√ºtzen (siehe 1 und 2).  Wenn zus√§tzliche Argumente (3) √ºbergeben werden, wird jedes von ihnen als Pr√§fix f√ºr den Namen der Datei betrachtet, die wir (4) in ein separates Verzeichnis verschieben. </p><br><p>  Dockerfile-Beispiel f√ºr ein Szenario mit einem zus√§tzlichen.  <code>shared-module</code> und Version <code>1.0-SNAPSHOT</code> </p><br><pre> <code class="plaintext hljs">FROM openjdk:8-jdk-alpine as build COPY target/demo.jar /wd/app.jar RUN prepare_for_docker /wd/app.jar shared-module-1.0 FROM openjdk:8-jdk-alpine COPY --from=build /wd/docker-dist/BOOT-INF/lib /app/lib COPY --from=build /wd/docker-dist/app-lib /app/lib COPY --from=build /wd/docker-dist/META-INF /app/META-INF COPY --from=build /wd/docker-dist/BOOT-INF/classes /app ENTRYPOINT ["java","-cp","app:app/lib/*","com.example.demo.DemoApplication"]</code> </pre> <br><h2 id="zapuskaem-na-ci-servere">  Auf dem CI-Server ausf√ºhren </h2><br><p>  Nachdem wir alles lokal getestet und mit dem Ergebnis zufrieden waren, begannen wir mit der Ausf√ºhrung auf dem CI-Server und stellten anhand der Build-Protokolle fest, dass kein Wunder eingetreten war oder die Ergebnisse nicht konstant waren: In einigen F√§llen wurde das Caching durchgef√ºhrt und das n√§chste Mal waren alle Ebenen neu. </p><br><p>  Infolgedessen wurde der Schuldige entdeckt - der Docker-Cache bzw. dessen Abwesenheit bei verschiedenen Agenten (unsere Baugruppe ist nicht an einen bestimmten Agenten des CI-Systems gebunden).  Wie sich herausstellte, werden Ebenen mit einer anderen Pr√ºfsumme aus demselben Dateisatz abgerufen, wenn sich keine geeigneten Ebenen im Docker-Cache befinden.  Sie k√∂nnen dies lokal √ºberpr√ºfen, indem Sie den Build mit der Option <code>--no-cache</code> ausf√ºhren oder <code>--no-cache</code> zweites Mal erstellen, indem Sie zuerst das Image und alle Zwischenebenen l√∂schen.  Als Ergebnis erhalten Sie eine v√∂llig andere Pr√ºfsummenebene, die alle vorherigen Bem√ºhungen negiert. </p><br><p><img src="https://habrastorage.org/webt/k6/v0/ea/k6v0eaq02yvlokvcopiwp3fkwdm.png" alt="Ohne den richtigen Cache erhalten wir verschiedene Ebenen"></p><br><p>  Es gibt verschiedene M√∂glichkeiten, um das Problem zu l√∂sen: </p><br><ol><li>  Wenn Ihr CI-System dies sofort unterst√ºtzt (z. B. hat Circle CI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Plan-Teil</a> eine integrierte Unterst√ºtzung f√ºr den gemeinsam genutzten Cache w√§hrend Assemblys). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mischen eines Abschnitts</a> mit einem Docker-Cache zwischen Agenten </li><li>  Nutzen Sie den integrierten Cache-Management-Docker ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>--cache-from</code></a> ) </li></ol><br><p>  Wir sind den dritten Weg gegangen, da es in unserem Fall der einfachste war.  Mit dieser Option k√∂nnen Sie dem Docker-Daemon mitteilen, welche Images ber√ºcksichtigt werden sollen, und versuchen, sie w√§hrend der Assembly f√ºr das Caching zu verwenden.  Sie k√∂nnen so viele Bilder angeben, wie Sie f√ºr erforderlich halten. Hauptsache, sie befinden sich im Dateisystem.  Wenn das angegebene Image nicht vorhanden ist, wird es einfach ignoriert, sodass Sie es vor dem Erstellen ziehen m√ºssen. </p><br><p>  So sieht die Container-Baugruppe mit diesem Ansatz aus: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e version=... <span class="hljs-comment"><span class="hljs-comment">#      docker pull registy.example.com/my-image:latest || true #         docker build -t registry.example.com/my-image:$version --cache-from registry.example.com/my-image:latest . #   registry    latest docker tag registry.example.com/my-image:$version registry.example.com/my-image:latest docker push registry.example.com/my-image:$version docker push registry.example.com/my-image:latest</span></span></code> </pre> <br><p>  Wir versuchen, Ebenen nur aus dem neuesten Image wiederzuverwenden, was oft genug ist, aber niemand st√∂rt sich daran, komplexere Logik aufzuwickeln und einige Versionen zur√ºckzuverfolgen oder sich auf die ID von vcs-Commits zu verlassen. </p><br><p>  Wir passen diesen Ansatz an die Funktionen Ihres CI an und erhalten eine zuverl√§ssige Wiederverwendung von Ebenen mit Bibliotheken. </p><br><h1 id="itogo">  Insgesamt </h1><br><p>  Die L√∂sung zeigt gute Ergebnisse, insbesondere bei Projekten mit einem aktiven Entwicklungsstadium und einer optimierten CD-Pipeline.  Die folgende Grafik zeigt das Ergebnis der Anwendung der Optimierung auf eine der Anwendungen.  Es ist deutlich zu sehen, dass sich das lineare Wachstum ab der 70. Baugruppe zu krampfhaft ver√§ndert hat (Fehler in den 60er Jahren h√§ngen genau mit den Debugging-Arbeiten an Build-Agenten zusammen).  Emissionen nach sind mit der Aktualisierung des Basisimages (hoch) und der Bibliotheken (niedriger) verbunden. </p><br><p><img src="https://habrastorage.org/webt/ja/dj/en/jadjennx5loozk5x7iz_nxrct1o.png"></p><br><p>  Die Speicheroptimierung ist in unserem Fall ein angenehmer, aber eher sekund√§rer Bonus.  Viel erfreulicher ist die Beschleunigung der Bereitstellung der neuen Version gegen√ºber der alten in mehreren Regionen. </p><br><p>  Es sollte beachtet werden, dass diese Technik durchaus mit anderen Ans√§tzen kompatibel ist, die darauf abzielen, die Gr√∂√üe eines einzelnen Bildes zu reduzieren (alpine und andere leichte Grundbilder, benutzerdefinierte Laufzeit f√ºr die Anwendung).  Die Hauptsache ist, die allgemeinen Regeln f√ºr das Zusammenstellen des Bildes in Bezug auf das Caching zu befolgen und sicherzustellen, dass das Ergebnis reproduzierbar ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458260/">https://habr.com/ru/post/de458260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458246/index.html">Zuf√§llige Zuf√§lle im Leben oder wie sich herausstellte, dass Ihnen in einer Traktorenfabrik ein Kuchen pr√§sentiert wurde</a></li>
<li><a href="../de458248/index.html">Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator</a></li>
<li><a href="../de458250/index.html">BTRFS f√ºr die Kleinsten</a></li>
<li><a href="../de458252/index.html">Mathematisches Modell eines superlangen Radioteleskops</a></li>
<li><a href="../de458256/index.html">Ist es nicht Zeit f√ºr eine Gehirnw√§sche?</a></li>
<li><a href="../de458262/index.html">Online-Designer des Besprechungsraums - Auswahl der optimalen L√∂sung f√ºr die Videokonferenz</a></li>
<li><a href="../de458264/index.html">10 Prinzipien des selbstdokumentierenden Codes</a></li>
<li><a href="../de458268/index.html">Automatische Segmentierung der Atemwege</a></li>
<li><a href="../de458270/index.html">√úber Fehler, die aus dem Nichts auftauchen und an denen niemand schuld ist: Das Ph√§nomen des Verschmierens von Verantwortung</a></li>
<li><a href="../de458272/index.html">Meine G√ºte! f√ºr Reisende - die Geschichte eines Heimprojekts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>