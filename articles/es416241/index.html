<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ü üññüèª üçÖ Recuperando niveles de Super Mario Bros usando Python üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üë¶üèæ ‚õ∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Para un nuevo proyecto, necesitaba extraer datos de nivel del cl√°sico videojuego de 1985 Super Mario Bros (SMB) . M√°s espec√≠ficamente, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recuperando niveles de Super Mario Bros usando Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416241/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br><h2>  Introduccion </h2><br>  Para un nuevo proyecto, necesitaba extraer datos de nivel del cl√°sico videojuego de 1985 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Super Mario Bros (SMB)</a> .  M√°s espec√≠ficamente, quer√≠a extraer los gr√°ficos de fondo de cada nivel del juego sin una interfaz, mover sprites, etc. <br><br>  Por supuesto, podr√≠a pegar las im√°genes del juego y, posiblemente, automatizar el proceso utilizando t√©cnicas de visi√≥n artificial.  Pero me pareci√≥ m√°s interesante el m√©todo descrito a continuaci√≥n, que le permite explorar los elementos de nivel que no se pueden obtener con capturas de pantalla. <br><br>  En la primera etapa del proyecto, aprenderemos el lenguaje ensamblador 6502 y un emulador escrito en Python.  El c√≥digo fuente completo est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><a name="habracut"></a><br><h2>  An√°lisis de c√≥digo fuente </h2><br>  La ingenier√≠a inversa de cualquier programa es mucho m√°s simple si tiene su c√≥digo fuente, y tenemos fuentes SMB en forma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">17 mil l√≠neas de c√≥digo ensamblador 6502 (procesador NES)</a> publicado por doppelganger.  Dado que Nintendo nunca lanz√≥ un lanzamiento de fuente oficial, el c√≥digo fue creado al desarmar el c√≥digo de m√°quina SMB, descifrar dolorosamente el significado de cada parte, agregar comentarios y nombres simb√≥licos significativos. <br><br>  Despu√©s de realizar una b√∫squeda r√°pida en el archivo, encontr√© algo similar a los datos de nivel que necesit√°bamos: <br><br> <code>;level 1-1 <br> L_GroundArea6: <br> .db $50, $21 <br> .db $07, $81, $47, $24, $57, $00, $63, $01, $77, $01 <br> .db $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83 <br> .db $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02 <br> .db $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06 <br> .db $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20 <br> .db $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33 <br> .db $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3 <br> .db $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61 <br> .db $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20 <br> .db $39, $f1, $5f, $38, $6d, $c1, $af, $26 <br> .db $fd</code> <br> <br>  Si no est√° familiarizado con el ensamblador, explicar√©: todo esto simplemente significa "insertar un conjunto de bytes en el programa compilado y luego permitir que otras partes del programa lo consulten utilizando el s√≠mbolo <code>L_GroundArea6</code> ".  Puede tomar este fragmento como una matriz en la que cada elemento es un byte. <br><br>  Lo primero que puede notar es que el volumen de datos es muy peque√±o (aproximadamente 100 bytes).  Por lo tanto, excluimos todos los tipos de codificaci√≥n, lo que le permite colocar bloques arbitrariamente en el nivel.  Despu√©s de buscar un poco, descubr√≠ que estos datos se leen (despu√©s de varias operaciones de direccionamiento indirecto) en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AreaParserCore</a> .  Este subprocedimiento, a su vez, invoca muchos otros subprocedimientos, invocando subprocedimientos espec√≠ficos para cada tipo de objeto permitido en la escena (por ejemplo, <code>StaircaseObject</code> , <code>VerticalPipe</code> , <code>RowOfBricks</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/385/954/4e538595409be651da11d5166c97b130.png"></div><br>  <i>Gr√°fico de llamada <code>AreaParserCore</code> para <code>AreaParserCore</code></i> <br><br>  El procedimiento escribe en <code>MetatileBuffer</code> : una secci√≥n de memoria de 13 bytes, que es una columna de bloques en un nivel, cada uno de los cuales representa un bloque separado.  Un metatile es un bloque de 16x16 del que se componen los fondos de un juego SMB: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c27/d0b/bd9/c27d0bbd9fdce9bf86b56ce181b2747d.png"></div><br>  <i>Nivelar con rect√°ngulos en c√≠rculos alrededor de metatiles</i> <br><br>  Se llaman metaarchivos, porque cada uno consta de cuatro mosaicos de 8x8 p√≠xeles, pero m√°s sobre eso a continuaci√≥n. <br><br>  El hecho de que el decodificador funcione con objetos predefinidos explica el peque√±o tama√±o del nivel: los datos de nivel deben referirse solo a los tipos de objetos y su ubicaci√≥n, por ejemplo, "coloque la tuber√≠a en el punto (20, 16), varios bloques en el punto (10, 5), ... ".  Sin embargo, esto significa que se necesita mucho c√≥digo para convertir los datos de nivel sin procesar en metaarchivos. <br><br>  Portar esta cantidad de c√≥digo para crear su propio desempacador de nivel llevar√≠a demasiado tiempo, as√≠ que intentemos un enfoque diferente. <br><br><h2>  py65emu </h2><br>  Si tuvi√©ramos una interfaz entre Python y el lenguaje ensamblador 6502, podr√≠amos llamar al subprocedimiento <code>AreaParserCore</code> para cada columna de nivel, y luego usar Python m√°s comprensible para convertir la informaci√≥n del bloque en la imagen deseada. <br><br>  Luego aparece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">py65emu</a> en escena: un emulador conciso 6502 con una interfaz Python.  As√≠ es como se configura la misma configuraci√≥n de memoria en py65emu que en NES: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.cpu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CPU <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.mmu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MMU <span class="hljs-comment"><span class="hljs-comment">#  ROM  (..  ) with open("program.bin", "rb") as f: prg_rom = f.read() #   . mmu = MMU([ #  2K ,    0x0. (0x0, 2048, False, []), #  ROM   0x8000. (0x8000, len(prg_rom), True, list(prg_rom)) ]) #     ,       0x8000 cpu = CPU(mmu, 0x8000)</span></span></code> </pre> <br>  Despu√©s de eso, podemos ejecutar instrucciones individuales usando el m√©todo <code>cpu.step()</code> , examinar la memoria usando <code>mmu.read()</code> , estudiar los registros de la m√°quina usando <code>cpu.ra</code> , <code>cpu.r.pc</code> , etc.  Adem√°s, podemos escribir en la memoria usando <code>mmu.write()</code> . <br><br>  Vale la pena se√±alar que esto es solo un emulador de procesador NES: no emula otro hardware, como PPU (unidad de procesamiento de im√°genes), por lo que no se puede usar para emular todo el juego.  Sin embargo, deber√≠a ser suficiente para llamar al subproceso de an√°lisis, ya que no utiliza ning√∫n otro dispositivo de hardware, excepto la CPU y la memoria. <br><br>  El plan es configurar la CPU como se muestra arriba, y luego para cada columna de nivel, inicializar las particiones de memoria con los valores de entrada requeridos para <code>AreaParserCore</code> , llamar a <code>AreaParserCore</code> y luego leer los datos de la columna.  Despu√©s de completar estas operaciones, usamos Python para ensamblar el resultado en una imagen terminada. <br><br>  Pero antes de eso, necesitamos compilar el listado en lenguaje ensamblador en c√≥digo m√°quina. <br><br><h2>  x816 </h2><br>  Como se indica en el c√≥digo fuente, el ensamblador se compila utilizando x816.  x816 es un ensamblador de MS-DOS 6502 utilizado por la comunidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">homebrew</a> para piratas inform√°ticos NES y ROM.  Funciona muy bien en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DOSBox</a> . <br><br>  Junto con la ROM del programa, que es necesario para py65emu, el ensamblador x816 crea un archivo de caracteres que asigna los caracteres a su ubicaci√≥n en la memoria en el espacio de direcciones de la CPU.  Aqu√≠ hay un fragmento del archivo: <br><br> <code>AREAPARSERCORE = $0093FC ; &lt;&gt; 37884, statement #3154 <br> AREAPARSERTASKCONTROL = $0086E6 ; &lt;&gt; 34534, statement #1570 <br> AREAPARSERTASKHANDLER = $0092B0 ; &lt;&gt; 37552, statement #3035 <br> AREAPARSERTASKNUM = $00071F ; &lt;&gt; 1823, statement #141 <br> AREAPARSERTASKS = $0092C8 ; &lt;&gt; 37576, statement #3048</code> <br> <br>  Aqu√≠ vemos que se puede acceder a la funci√≥n <code>AreaParserCore</code> en el c√≥digo fuente en <code>0x93fc</code> . <br><br>  Por conveniencia, escrib√≠ un analizador de archivos de s√≠mbolos que coincide con los nombres y las direcciones de los s√≠mbolos: <br><br><pre> <code class="python hljs">sym_file = SymbolFile(<span class="hljs-string"><span class="hljs-string">'SMBDIS.SYM'</span></span>) print(<span class="hljs-string"><span class="hljs-string">"0x{:x}"</span></span>.format(sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])) <span class="hljs-comment"><span class="hljs-comment">#  0x93fc print(sym_file.lookup_address(0x93fc)) #  "AREAPARSERCORE"</span></span></code> </pre> <br><h2>  Subprocedimientos </h2><br>  Como se indic√≥ en el plan anterior, queremos aprender c√≥mo llamar al subprocedimiento <code>AreaParserCore</code> desde Python. <br><br>  Para comprender la mec√°nica de un subprocedimiento, examinemos un subprocedimiento breve y su desaf√≠o correspondiente: <br><br><pre> <code class="python hljs">WritePPUReg1: sta PPU_CTRL_REG1 ;  A   <span class="hljs-number"><span class="hljs-number">1</span></span> PPU sta Mirror_PPU_CTRL_REG1 ;    rts ... jsr WritePPUReg1</code> </pre> <br>  La <code>jsr</code> (saltar a subrutina, "saltar a subrutina") <code>jsr</code> registro de <code>jsr</code> PC a la pila y le asigna el valor de direcci√≥n al que se refiere <code>WritePPUReg1</code> .  El registro de la PC le indica al procesador la direcci√≥n de la siguiente instrucci√≥n que se cargar√°, de modo que la siguiente instrucci√≥n ejecutada despu√©s de la instrucci√≥n <code>jsr</code> es la primera l√≠nea de <code>WritePPUReg1</code> . <br><br>  Al final de la subrutina, se <code>rts</code> instrucci√≥n <code>rts</code> (retorno de subrutina, "retorno de subrutina").  Este comando elimina el valor almacenado de la pila y lo almacena en el registro de la PC, lo que obliga a la CPU a ejecutar la instrucci√≥n despu√©s de la llamada <code>jsr</code> . <br><br>  Una gran caracter√≠stica de los subprocedimientos es que puede crear llamadas en l√≠nea, es decir, llamadas de subprocedimiento dentro de subprocedimientos.  Las direcciones de retorno se insertar√°n en la pila y se mostrar√°n en el orden correcto, de la misma manera que con las llamadas a funciones en idiomas de alto nivel. <br><br>  Aqu√≠ est√° el c√≥digo para ejecutar la subrutina desde Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute_subroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, addr)</span></span></span><span class="hljs-function">:</span></span> s_before = cpu.rs cpu.JSR(addr) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> cpu.rs != s_before: cpu.step() execute_subroutine(cpu, sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])</code> </pre> <br>  El c√≥digo guarda el valor actual de los registros de puntero de la pila, emula una llamada <code>jsr</code> y luego ejecuta las instrucciones hasta que la pila vuelva a su altura original, lo que ocurre solo despu√©s del retorno del primer subprocedimiento.  Esto ser√° √∫til, porque ahora tenemos una manera de llamar directamente a las subrutinas 6502 desde Python. <br><br>  Sin embargo, olvidamos algo: ¬øc√≥mo pasar los valores de entrada para este subprocedimiento?  Necesitamos decirle al procedimiento qu√© nivel queremos representar y qu√© columna debemos analizar. <br><br>  A diferencia de las funciones en lenguajes de alto nivel, las subrutinas del lenguaje ensamblador 6502 no pueden recibir datos de entrada especificados expl√≠citamente.  En cambio, la entrada se transmite especificando ubicaciones de memoria en alg√∫n lugar antes de la llamada, que luego se leen dentro de la llamada del subprocedimiento.  Dado el tama√±o de <code>AreaParserCore</code> , la ingenier√≠a inversa de la entrada requerida simplemente mirando el c√≥digo fuente ser√° muy compleja y propensa a errores. <br><br><h2>  Valgrind para NES? </h2><br>  Para encontrar una manera de determinar los valores de entrada de <code>AreaParserCore</code> , utilic√© la herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memcheck</a> para Valgrind como ejemplo.  Memcheck reconoce las operaciones de acceso a la memoria no inicializada almacenando memoria paralela en paralelo con cada fragmento de la memoria asignada real.  La memoria de sombra registra si la grabaci√≥n se realiz√≥ en la memoria real correspondiente.  Si el programa lee en la direcci√≥n en la que nunca escribi√≥, se genera un error de memoria no inicializado.  Podemos ejecutar <code>AreaParserCore</code> con una herramienta que nos dice qu√© entrada debe establecerse antes de invocar el subprocedimiento. <br><br>  De hecho, escribir una versi√≥n simple de memcheck para py65emu es muy f√°cil: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: symbol_name = sym_file.lookup_address(addr) s = <span class="hljs-string"><span class="hljs-string">"0x{:04x} ({}):"</span></span>.format(addr, symbol_name) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: s = <span class="hljs-string"><span class="hljs-string">"0x{:04x}:"</span></span>.format(addr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemCheckMMU</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MMU)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._uninitialized = array.array(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">2048</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr)</span></span></span><span class="hljs-function">:</span></span> val = super().read(addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._uninitialized[addr]: print(<span class="hljs-string"><span class="hljs-string">"Uninitialized read! {}"</span></span>.format(format_addr(addr))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr, val)</span></span></span><span class="hljs-function">:</span></span> super().write(addr, val) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: self._uninitialized[addr] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Aqu√≠ envolvemos la unidad de administraci√≥n de memoria (MMU) de py65emu.  Esta clase contiene una matriz <code>_uninitialized</code> , <code>_uninitialized</code> elementos nos dicen si alguna vez se ha escrito en el byte correspondiente de RAM emulada.  En el caso de una lectura no inicializada, se muestran la direcci√≥n de la operaci√≥n de lectura no v√°lida y el nombre del car√°cter correspondiente. <br><br>  Estos son los resultados de la MMU <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> cuando se llama a <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> : <br><br> <code>Uninitialized read! 0x0728 (BACKLOADINGFLAG): <br> Uninitialized read! 0x0742 (BACKGROUNDSCENERY): <br> Uninitialized read! 0x0741 (FOREGROUNDSCENERY): <br> Uninitialized read! 0x074e (AREATYPE): <br> Uninitialized read! 0x075f (WORLDNUMBER): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x0727 (TERRAINCONTROL): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x074e (AREATYPE): <br> ...</code> <br> <br>  Al mirar el c√≥digo, puede ver que muchos de estos valores est√°n establecidos por el subprocedimiento <code>InitializeArea</code> , as√≠ que ejecutemos el script nuevamente, llamando a esta funci√≥n primero.  Repitiendo este proceso, llegamos a la siguiente secuencia de llamadas, que requiere solo el n√∫mero mundial y el n√∫mero de √°rea: <br><br><pre> <code class="python hljs">mmu.write(sym_file[<span class="hljs-string"><span class="hljs-string">'WORLDNUMBER'</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    1 mmu.write(sym_file['AREANUMBER'], 0) #    1 execute_subroutine(sym_file['LOADAREAPOINTER']) execute_subroutine(sym_file['INITIALIZEAREA']) metatile_data = [] for column_pos in range(48): execute_subroutine(sym_file['AREAPARSERCORE']) metatile_data.append([mmu.read_no_debug(sym_file['METATILEBUFFER'] + i) for i in range(13)]) execute_subroutine(sym_file['INCREMENTCOLUMNPOS'])</span></span></code> </pre> <br>  El c√≥digo escribe las primeras 48 columnas del nivel Mundial 1-1 en <code>metatile_data</code> , utilizando el subprocedimiento <code>IncrementColumnPos</code> para aumentar las variables internas necesarias para rastrear la columna actual. <br><br>  Y aqu√≠ est√° el contenido de <code>metatile_data</code> superpuesto en las capturas de pantalla del juego (no se muestran los bytes con un valor de 0): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br>  Obviamente, <code>metatile_data</code> coincide claramente con la informaci√≥n de fondo. <br><br><h2>  Meta Graphics </h2><br>  (Para ver el resultado final, puede pasar inmediatamente a la secci√≥n "Conectar todo"). <br><br>  Ahora veamos c√≥mo convertir el n√∫mero recibido de metaarchivos en im√°genes reales.  Los pasos que se describen a continuaci√≥n se inventaron analizando las fuentes y leyendo la documentaci√≥n con el incre√≠ble <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nesdev Wiki</a> . <br><br>  Para entender c√≥mo renderizar cada metatile, primero debemos hablar sobre las paletas de colores NES.  La consola PPU de NES generalmente puede generar 64 colores diferentes, pero el negro se duplica varias veces (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nesdev</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">obtener m√°s detalles</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/997/328/cdf9973289e05f09899c36ca04cb6a4d.png"></div><br>  Cada nivel de Mario puede usar solo 10 de estos 64 colores para el fondo, divididos en 4 paletas de cuatro colores;  El primer color es siempre el mismo.  Aqu√≠ hay cuatro paletas para el Mundo 1-1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/15d/821/69915d821a10f3e7c668abe2894bc7a3.png"></div><br>  Veamos ahora un ejemplo binario de un n√∫mero de metaarchivo.  Aqu√≠ est√° el n√∫mero de metatile de azulejos de piedra agrietados, que es tierra de nivel 1-1 del mundo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85f/1a1/9ae/85f1a19aea1e39a511dc2bfe31e72d05.png"></div><br>  El √≠ndice de paleta nos dice qu√© paleta usar al renderizar el metatile (en nuestro caso, paleta 1).  El √≠ndice de paleta tambi√©n es el √≠ndice de las siguientes dos matrices: <br><br> <code>MetatileGraphics_Low: <br> .db &lt;Palette0_MTiles, &lt;Palette1_MTiles, &lt;Palette2_MTiles, &lt;Palette3_MTiles <br> <br> MetatileGraphics_High: <br> .db &gt;Palette0_MTiles, &gt;Palette1_MTiles, &gt;Palette2_MTiles, &gt;Palette3_MTiles</code> <br> <br>  La combinaci√≥n de estos dos arreglos nos da una direcci√≥n de 16 bits, que en nuestro ejemplo apunta a <code>Palette1_Mtiles</code> : <br><br> <code>Palette1_MTiles: <br> .db $a2, $a2, $a3, $a3 ;vertical rope <br> .db $99, $24, $99, $24 ;horizontal rope <br> .db $24, $a2, $3e, $3f ;left pulley <br> .db $5b, $5c, $24, $a3 ;right pulley <br> .db $24, $24, $24, $24 ;blank used for balance rope <br> .db $9d, $47, $9e, $47 ;castle top <br> .db $47, $47, $27, $27 ;castle window left <br> .db $47, $47, $47, $47 ;castle brick wall <br> .db $27, $27, $47, $47 ;castle window right <br> .db $a9, $47, $aa, $47 ;castle top w/ brick <br> .db $9b, $27, $9c, $27 ;entrance top <br> .db $27, $27, $27, $27 ;entrance bottom <br> .db $52, $52, $52, $52 ;green ledge stump <br> .db $80, $a0, $81, $a1 ;fence <br> .db $be, $be, $bf, $bf ;tree trunk <br> .db $75, $ba, $76, $bb ;mushroom stump top <br> .db $ba, $ba, $bb, $bb ;mushroom stump bottom <br> .db $45, $47, $45, $47 ;breakable brick w/ line <br> .db $47, $47, $47, $47 ;breakable brick <br> .db $45, $47, $45, $47 ;breakable brick (not used) <br> .db $b4, $b6, $b5, $b7 ;cracked rock terrain &lt;--- This is the 20th line <br> .db $45, $47, $45, $47 ;brick with line (power-up) <br> .db $45, $47, $45, $47 ;brick with line (vine) <br> .db $45, $47, $45, $47 ;brick with line (star) <br> .db $45, $47, $45, $47 ;brick with line (coins) <br> ...</code> <br> <br>  Cuando multiplica el √≠ndice de metatile por 4, se convierte en el √≠ndice de esta matriz.  Los datos est√°n formateados en 4 registros por l√≠nea, por lo que nuestro metatile de ejemplo se refiere a la vig√©sima l√≠nea, marcada con un comentario de <code>cracked rock terrain</code> . <br><br>  Las cuatro entradas de esta l√≠nea son en realidad identificadores de mosaico: cada metatile consta de cuatro mosaicos de 8x8 p√≠xeles dispuestos en el siguiente orden: superior izquierdo, inferior izquierdo, superior derecho e inferior derecho.  Estos identificadores se pasan directamente a la consola NES PPU.  El identificador se refiere a 16 bytes de datos en la consola CHR-ROM, y cada registro comienza con la direcci√≥n <code>0x1000 + 16 * &lt; &gt;</code> : <br><br> <code>0x1000 + 16 * 0xb4: 0b01111111 0x1000 + 16 * 0xb5: 0b11011110 <br> 0x1001 + 16 * 0xb4: 0b10000000 0x1001 + 16 * 0xb5: 0b01100001 <br> 0x1002 + 16 * 0xb4: 0b10000000 0x1002 + 16 * 0xb5: 0b01100001 <br> 0x1003 + 16 * 0xb4: 0b10000000 0x1003 + 16 * 0xb5: 0b01100001 <br> 0x1004 + 16 * 0xb4: 0b10000000 0x1004 + 16 * 0xb5: 0b01110001 <br> 0x1005 + 16 * 0xb4: 0b10000000 0x1005 + 16 * 0xb5: 0b01011110 <br> 0x1006 + 16 * 0xb4: 0b10000000 0x1006 + 16 * 0xb5: 0b01111111 <br> 0x1007 + 16 * 0xb4: 0b10000000 0x1007 + 16 * 0xb5: 0b01100001 <br> 0x1008 + 16 * 0xb4: 0b10000000 0x1008 + 16 * 0xb5: 0b01100001 <br> 0x1009 + 16 * 0xb4: 0b01111111 0x1009 + 16 * 0xb5: 0b11011111 <br> 0x100a + 16 * 0xb4: 0b01111111 0x100a + 16 * 0xb5: 0b11011111 <br> 0x100b + 16 * 0xb4: 0b01111111 0x100b + 16 * 0xb5: 0b11011111 <br> 0x100c + 16 * 0xb4: 0b01111111 0x100c + 16 * 0xb5: 0b11011111 <br> 0x100d + 16 * 0xb4: 0b01111111 0x100d + 16 * 0xb5: 0b11111111 <br> 0x100e + 16 * 0xb4: 0b01111111 0x100e + 16 * 0xb5: 0b11000001 <br> 0x100f + 16 * 0xb4: 0b01111111 0x100f + 16 * 0xb5: 0b11011111 <br> <br> 0x1000 + 16 * 0xb6: 0b10000000 0x1000 + 16 * 0xb7: 0b01100001 <br> 0x1001 + 16 * 0xb6: 0b10000000 0x1001 + 16 * 0xb7: 0b01100001 <br> 0x1002 + 16 * 0xb6: 0b11000000 0x1002 + 16 * 0xb7: 0b11000001 <br> 0x1003 + 16 * 0xb6: 0b11110000 0x1003 + 16 * 0xb7: 0b11000001 <br> 0x1004 + 16 * 0xb6: 0b10111111 0x1004 + 16 * 0xb7: 0b10000001 <br> 0x1005 + 16 * 0xb6: 0b10001111 0x1005 + 16 * 0xb7: 0b10000001 <br> 0x1006 + 16 * 0xb6: 0b10000001 0x1006 + 16 * 0xb7: 0b10000011 <br> 0x1007 + 16 * 0xb6: 0b01111110 0x1007 + 16 * 0xb7: 0b11111110 <br> 0x1008 + 16 * 0xb6: 0b01111111 0x1008 + 16 * 0xb7: 0b11011111 <br> 0x1009 + 16 * 0xb6: 0b01111111 0x1009 + 16 * 0xb7: 0b11011111 <br> 0x100a + 16 * 0xb6: 0b11111111 0x100a + 16 * 0xb7: 0b10111111 <br> 0x100b + 16 * 0xb6: 0b00111111 0x100b + 16 * 0xb7: 0b10111111 <br> 0x100c + 16 * 0xb6: 0b01001111 0x100c + 16 * 0xb7: 0b01111111 <br> 0x100d + 16 * 0xb6: 0b01110001 0x100d + 16 * 0xb7: 0b01111111 <br> 0x100e + 16 * 0xb6: 0b01111111 0x100e + 16 * 0xb7: 0b01111111 <br> 0x100f + 16 * 0xb6: 0b11111111 0x100f + 16 * 0xb7: 0b01111111</code> <br> <br>  CHR-ROM es una memoria de solo lectura a la que solo PPU puede acceder.  Est√° separado del PRG-ROM, que almacena el c√≥digo del programa.  Por lo tanto, los datos anteriores no est√°n disponibles en el c√≥digo fuente y deben obtenerse del volcado de la ROM del juego. <br><br>  16 bytes para cada mosaico forman un mosaico de 2 bits 8x8: el primer bit son los primeros 8 bytes, y el segundo son los segundos 8 bytes: <br><br> <code>21111111 13211112 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23132223 <br> 12222222 23233332 <br> 12222222 23111113 <br> 12222222 23122223 <br> <br> 12222222 23122223 <br> 12222222 23122223 <br> 33222222 31222223 <br> 11332222 31222223 <br> 12113333 12222223 <br> 12221113 12222223 <br> 12222223 12222233 <br> 23333332 13333332</code> <br> <br>  Vincula estos datos a la paleta 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02e/32a/ad5/02e32aad5717393bd296dd35983e294b.png"></div><br>  ... y combina las piezas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/950/86a/103/95086a103b16d361c72c0250781ebfd5.png"></div><br>  Finalmente obtuvimos un mosaico renderizado. <br><br><h2>  Poniendo todo junto </h2><br>  Repitiendo este procedimiento para cada metaarchivo, obtenemos un nivel completamente renderizado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/45d/a3b/32245da3b8b4707764cef5231e040474.png"></div><br>  ¬°Y gracias a esto, pudimos extraer gr√°ficos de nivel SMB usando Python! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416241/">https://habr.com/ru/post/es416241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416229/index.html">10 libros sobre marketing y temas relacionados que un dise√±ador debe leer</a></li>
<li><a href="../es416231/index.html">Monitoreo de habitaciones Zadarma Zabbix</a></li>
<li><a href="../es416235/index.html">Crear componentes personalizados para Bootstrap 4</a></li>
<li><a href="../es416237/index.html">Convertirse en dise√±ador: desde trabajar como freelance desde un albergue hasta trabajar con las principales empresas y lanzar su producto</a></li>
<li><a href="../es416239/index.html">El papel y las funciones de PMO en las empresas de dise√±o.</a></li>
<li><a href="../es416243/index.html">Alternativas al cobalto, este diamante sangriento de bater√≠as</a></li>
<li><a href="../es416245/index.html">Creamos un bot en Aimylogic para automatizar la tienda en l√≠nea.</a></li>
<li><a href="../es416247/index.html">¬øC√≥mo prepararse para un viaje de negocios? Consejos de ISPsystem bizdedev</a></li>
<li><a href="../es416251/index.html">Impresi√≥n 3D en camisetas</a></li>
<li><a href="../es416253/index.html">Sketchfab, Unity, Blend4Web, PlayCanvas y ahora Verge3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>