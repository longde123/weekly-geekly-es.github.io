<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 😹 🏗️ Wir schreiben einen Online-Chat auf Websockets mit Swoole 🐍 💇🏾 ⚰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Thema Websockets wurde bei Habré bereits wiederholt angesprochen, insbesondere wurden Optionen für die Implementierung in PHP in Betracht gezogen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben einen Online-Chat auf Websockets mit Swoole</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427589/"><img src="https://habrastorage.org/webt/8p/gc/di/8pgcdiztceoyeqy2os69qvw8rmq.png"><br><br>  Das Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Websockets wurde</a> bei Habré bereits wiederholt angesprochen, insbesondere wurden Optionen für die Implementierung in PHP in Betracht gezogen.  Seit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel</a> mit einem Überblick über verschiedene Technologien ist jedoch mehr als ein Jahr vergangen, und die PHP-Welt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat im</a> Laufe der Zeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">etwas zu</a> bieten. <br><br>  In diesem Artikel möchte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swoole</a> der russischsprachigen Community <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorstellen</a> - Asynchrones Open Source-Framework für PHP, geschrieben in C und geliefert als Pecl-Erweiterung. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen zu Github</a> . <br><a name="habracut"></a><br><h2>  Warum stürzen? </h2><br>  Sicherlich wird es Leute geben, die grundsätzlich gegen die Verwendung von PHP für solche Zwecke sind, aber sie können oft zugunsten von PHP spielen: <br><br><ul><li>  Widerwillen, einen Zoo in verschiedenen Sprachen im Projekt zu züchten </li><li>  Möglichkeit, eine bereits entwickelte Codebasis zu verwenden (wenn das Projekt in PHP ausgeführt wird). </li></ul><br>  Selbst im Vergleich zu node.js / go / erlang und anderen Sprachen, die nativ ein asynchrones Modell bieten, kann Swoole - ein in C geschriebenes Framework, das eine niedrige Einstiegsschwelle und leistungsstarke Funktionen kombiniert - ein guter Kandidat sein. <br><br>  <b>Merkmale des Frameworks:</b> <br><br><ul><li>  Ereignis, asynchrones Programmiermodell </li><li>  Asynchrone TCP / UDP / HTTP / Websocket / HTTP2-Client / Server-APIs </li><li>  Unterstützt IPv4 / IPv6 / Unixsocket / TCP / UDP und SSL / TLS </li><li>  Schnelle Serialisierung / Deserialisierung von Daten </li><li>  Hohe Leistung, Erweiterbarkeit und Unterstützung für bis zu 1 Million gleichzeitige Verbindungen </li><li>  Millisekunden-Taskplaner </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Source</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coroutines-Unterstützung</a> </li></ul><br>  <b>Mögliche Anwendungsfälle:</b> <br><br><ul><li>  Microservices </li><li>  Spieleserver </li><li>  Internet der Dinge </li><li>  Live-Kommunikationssysteme </li><li>  WEB API </li><li>  Alle anderen Dienste, die eine sofortige Antwort / hohe Geschwindigkeit / asynchrone Ausführung erfordern </li></ul><br>  Beispiele für Code finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptseite der Website</a> .  Im Dokumentationsabschnitt finden Sie detailliertere Informationen zu allen Funktionen des Frameworks. <br><br><h2>  Fangen wir an </h2><br>  Im Folgenden werde ich den Prozess des Schreibens eines einfachen Websocket-Servers für den Online-Chat und die möglichen Schwierigkeiten damit beschreiben. <br><br>  Bevor Sie beginnen: Weitere Informationen zu den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swoole_websocket_server</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swoole_server</a> (Die zweite Klasse erbt von der ersten). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen des Chats selbst.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Framework installieren</b> <div class="spoiler_text"><code>Linux users <br> <br> #!/bin/bash <br> pecl install swoole <br> <br> Mac users <br> <br> # get a list of avaiable packages <br> brew install swoole <br> #!/bin/bash <br> brew install homebrew/php/php71-swoole <br></code> <br></div></div><br>  Um die automatische Vervollständigung in der IDE zu verwenden, wird vorgeschlagen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ide-helper zu verwenden</a> <br><br>  <b>Minimale Websocket-Server-Vorlage:</b> <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> swoole_websocket_server(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">9502</span></span>); $server-&gt;on(<span class="hljs-string"><span class="hljs-string">'open'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($server, $req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"connection open: {$req-&gt;fd}\n"</span></span>; }); $server-&gt;on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($server, $frame)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"received message: {$frame-&gt;data}\n"</span></span>; $server-&gt;push($frame-&gt;fd, json_encode([<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>])); }); $server-&gt;on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($server, $fd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"connection close: {$fd}\n"</span></span>; }); $server-&gt;start();</code> </pre><br>  $ fd ist die Verbindungskennung. <br>  Aktuelle Verbindungen abrufen: <br><br><pre> <code class="php hljs">$server-&gt;connections;</code> </pre> <br>  $ Frame enthält alle gesendeten Daten.  Hier ist ein Beispiel für ein Objekt, das in die Funktion onMessage aufgenommen wurde: <br><br><pre> <code class="plaintext hljs">Swoole\WebSocket\Frame Object ( [fd] =&gt; 20 [data] =&gt; {"type":"login","username":"new user"} [opcode] =&gt; 1 [finish] =&gt; 1 )</code> </pre><br>  Daten werden über die Funktion an den Client gesendet <br><br><pre> <code class="php hljs">Server::push($fd, $data, $opcode=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, $finish=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu</a> Frames und Opcodes in russischer Sprache finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">learn.javascript</a> .  Abschnitt "Datenformat" <br><br>  So viel wie möglich über das Websocket-Protokoll - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC</a> <br><br>  <b>Und wie speichere ich die Daten, die auf den Server kamen?</b> <br>  Swoole bietet Funktionen für die asynchrone Arbeit mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MySQL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redis</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datei-E /</a> A. <br><br>  Sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swoole_buffer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swoole_channel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swoole_table</a> <br>  Ich denke, die Unterschiede sind aus der Dokumentation nicht schwer zu verstehen.  Um Benutzernamen zu speichern, habe ich swoole_table ausgewählt.  Die Nachrichten selbst werden in MySQL gespeichert. <br><br>  Also, Initialisierung der Benutzernamen-Tabelle: <br><br><pre> <code class="php hljs">$users_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> swoole_table(<span class="hljs-number"><span class="hljs-number">131072</span></span>); $users_table-&gt;column(<span class="hljs-string"><span class="hljs-string">'id'</span></span>, swoole_table::TYPE_INT, <span class="hljs-number"><span class="hljs-number">5</span></span>); $users_table-&gt;column(<span class="hljs-string"><span class="hljs-string">'username'</span></span>, swoole_table::TYPE_STRING, <span class="hljs-number"><span class="hljs-number">64</span></span>); $users_table-&gt;create();</code> </pre><br>  Das Füllen mit Daten ist wie folgt: <br><br><pre> <code class="php hljs">$count = count($messages_table); $dateTime = time(); $row = [<span class="hljs-string"><span class="hljs-string">'username'</span></span> =&gt; $username, <span class="hljs-string"><span class="hljs-string">'message'</span></span> =&gt; $data-&gt;message, <span class="hljs-string"><span class="hljs-string">'date_time'</span></span> =&gt; $dateTime]; $messages_table-&gt;set($count, $row);</code> </pre><br>  Um mit MySQL zu arbeiten, habe ich mich entschieden, das asynchrone Modell noch nicht zu verwenden, sondern auf standardmäßige Weise vom Web-Socket-Server über PDO darauf zuzugreifen <br><br><div class="spoiler">  <b class="spoiler_title">Appell an die Basis</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> Message[] */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $stmt = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;pdo-&gt;query(<span class="hljs-string"><span class="hljs-string">'SELECT * from messages'</span></span>); $messages = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($stmt-&gt;fetchAll() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $row) { $messages[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Message( $row[<span class="hljs-string"><span class="hljs-string">'username'</span></span>], $row[<span class="hljs-string"><span class="hljs-string">'message'</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTime($row[<span class="hljs-string"><span class="hljs-string">'date_time'</span></span>]) ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $messages; }</code> </pre> <br></div></div><br>  Websocket-Server, es wurde beschlossen, in Form einer Klasse auszugeben und es im Konstruktor zu starten: <br><br><div class="spoiler">  <b class="spoiler_title">Konstruktor</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> swoole_websocket_server(<span class="hljs-string"><span class="hljs-string">'0.0.0.0'</span></span>, <span class="hljs-number"><span class="hljs-number">9502</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ws-&gt;on(<span class="hljs-string"><span class="hljs-string">'open'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ws, $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;onConnection($request); }); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ws-&gt;on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ws, $frame)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;onMessage($frame); }); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ws-&gt;on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ws, $id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;onClose($id); }); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ws-&gt;on(<span class="hljs-string"><span class="hljs-string">'workerStart'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(swoole_websocket_server $ws)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;onWorkerStart($ws); }); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ws-&gt;start(); }</code> </pre> <br></div></div><br>  <b>Probleme aufgetreten:</b> <br><br><ol><li>  Ein mit dem Chat verbundener Benutzer trennt die Verbindung nach 60 Sekunden, wenn kein Paketaustausch stattfindet (d. H. Der Benutzer hat nichts gesendet oder empfangen). </li><li>  Der Webserver verliert die Verbindung zu MySQL, wenn längere Zeit keine Interaktion stattfindet </li></ol><br>  Lösung: <br><br>  In beiden Fällen benötigen wir eine Implementierung der Ping-Funktion, die im ersten Fall den Client alle n Sekunden und im zweiten die MySQL-Datenbank ständig pingt. <br><br>  Da beide Funktionen asynchron arbeiten müssen, müssen sie in den untergeordneten Prozessen des Servers aufgerufen werden. <br><br>  Dazu können sie mit dem Ereignis "workerStart" initialisiert werden.  Wir haben es bereits im Konstruktor definiert, und mit diesem Ereignis wird die Methode $ this-&gt; onWorkerStart bereits aufgerufen: <br>  Das Websocket-Protokoll unterstützt sofort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ping-Pong</a> .  Unten sehen Sie die Implementierung auf Swoole. <br><br><div class="spoiler">  <b class="spoiler_title">onWorkerStart</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onWorkerStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(swoole_websocket_server $ws)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;messagesRepository = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessagesRepository(); $ws-&gt;tick(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::PING_DELAY_MS, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ws)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ws-&gt;connections <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $id) { $ws-&gt;push($id, <span class="hljs-string"><span class="hljs-string">'ping'</span></span>, WEBSOCKET_OPCODE_PING); } }); }</code> </pre> <br></div></div><br>  Als nächstes implementierte ich eine einfache Funktion zum Pingen eines MySQL-Servers alle N Sekunden mit swoole \ Timer: <br><br><div class="spoiler">  <b class="spoiler_title">DatabaseHelper</b> <div class="spoiler_text">  Der Timer selbst startet in initPdo, falls er noch nicht aktiviert ist: <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Init new Connection, and ping DB timer function */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initPdo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$timerId === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || (!Timer::exists(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$timerId))) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$timerId = Timer::tick(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::MySQL_PING_INTERVAL, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::ping(); }); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$pdo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDO(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DSN, DBConfig::USER, DBConfig::PASSWORD, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::OPT); } <span class="hljs-comment"><span class="hljs-comment">/** * Ping database to maintain the connection */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$pdo-&gt;query(<span class="hljs-string"><span class="hljs-string">'SELECT 1'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (PDOException $e) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::initPdo(); } }</code> </pre><br></div></div><br>  Der Hauptteil der Arbeit bestand darin, Logik zum Hinzufügen, Speichern, Senden von Nachrichten (nicht komplizierter als die übliche CRUD) zu schreiben und dann einen großen Spielraum für Verbesserungen zu schaffen. <br><br>  Bisher habe ich meinen Code in eine mehr oder weniger lesbare Form und einen objektorientierten Stil gebracht. Ich habe ein paar Funktionen implementiert: <br><br>  - Login mit Namen; <br><br><div class="spoiler">  <b class="spoiler_title">- Stellen Sie sicher, dass der Name nicht belegt ist</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $username * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isUsernameCurrentlyTaken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $username)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;usersRepository-&gt;getByIds(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ws-&gt;connection_list()) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $user) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($user-&gt;getUsername() == $username) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">- Spam-Begrenzer</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Helpers</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Swoole</span></span>\<span class="hljs-title"><span class="hljs-title">Channel</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestLimiter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Channel */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $userIds; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_RECORDS_COUNT = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_REQUESTS_BY_USER = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Channel(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">64</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/** * Check if there are too many requests from user * and make a record of request from that user * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $userId * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkIsRequestAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $userId)</span></span></span><span class="hljs-function"> </span></span>{ $requestsCount = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getRequestsCountByUser($userId); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addRecord($userId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($requestsCount &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::MAX_REQUESTS_BY_USER) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $userId * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> int */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRequestsCountByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $userId)</span></span></span><span class="hljs-function"> </span></span>{ $channelRecordsCount = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userIds-&gt;stats()[<span class="hljs-string"><span class="hljs-string">'queue_num'</span></span>]; $requestsCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $channelRecordsCount; $i++) { $userIdFromChannel = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userIds-&gt;pop(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userIds-&gt;push($userIdFromChannel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($userIdFromChannel === $userId) { $requestsCount++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $requestsCount; } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $userId */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $userId)</span></span></span><span class="hljs-function"> </span></span>{ $recordsCount = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userIds-&gt;stats()[<span class="hljs-string"><span class="hljs-string">'queue_num'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($recordsCount &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::MAX_RECORDS_COUNT) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userIds-&gt;pop(); } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userIds-&gt;push($userId); } }</code> </pre> <br>  PS: Ja, die Überprüfung erfolgt über die Verbindungs-ID.  Vielleicht ist es sinnvoll, es in diesem Fall beispielsweise durch die IP-Adresse des Benutzers zu ersetzen. <br><br>  Ich bin mir auch nicht sicher, ob in dieser Situation swoole_channel am besten geeignet war.  Ich denke später, um diesen Moment zu überarbeiten. <br></div></div><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einfacher</a> XSS-Schutz mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ezyang / htmlpurifier</a> <br><br><div class="spoiler">  <b class="spoiler_title">- Einfacher Spamfilter</b> <div class="spoiler_text">  Mit der Möglichkeit, in Zukunft zusätzliche Prüfungen hinzuzufügen. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Helpers</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpamFilter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string[] errors */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $errors = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $text * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkIsMessageTextCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $text)</span></span></span><span class="hljs-function"> </span></span>{ $isCorrect = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>(trim($text))) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;errors[] = <span class="hljs-string"><span class="hljs-string">'Empty message text'</span></span>; $isCorrect = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $isCorrect; } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string[] errors */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;errors; } }</code> </pre> <br></div></div><br>  Frontend-Chat ist immer noch sehr roh, weil  Das Backend zieht mich mehr an, aber wenn mehr Zeit bleibt, werde ich versuchen, es angenehmer zu gestalten. <br><br><h2>  Wo kann man Informationen erhalten und Neuigkeiten über das Framework erhalten? </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Englische offizielle Seite</a> - nützliche Links, aktuelle Dokumentation, wenige Kommentare von Benutzern </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> - aktuelle Nachrichten, nützliche Links, interessante Artikel </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Issue Tracker (Github)</a> - Fehler, Fragen, Kommunikation mit den Erstellern des Frameworks.  Sie antworten sehr klug (sie beantworteten meine Frage in ein paar Stunden mit einer Frage, die bei der Implementierung von Pingloop half). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geschlossene Ausgaben</a> - ich rate auch.  Eine große Datenbank mit Fragen von Benutzern und Antworten der Ersteller des Frameworks. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von Entwicklern geschriebene Tests</a> - Fast jedes Modul aus der Dokumentation enthält in PHP geschriebene Tests, die Anwendungsfälle zeigen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chinesisches Wiki-Framework</a> - alle Informationen wie auf Englisch, aber viel mehr Kommentare von Nutzern (Google Übersetzer hilft). </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Dokumentation</a> - eine Beschreibung einiger Klassen und Funktionen des Frameworks in einer recht praktischen Form. <br><br><h3>  Zusammenfassung </h3><br>  Es scheint mir, dass Swoole sich im letzten Jahr sehr aktiv entwickelt hat, es ist aus dem Stadium herausgekommen, in dem es als "roh" bezeichnet werden könnte, und jetzt steht es in vollem Wettbewerb mit der Verwendung von node.js / go hinsichtlich der asynchronen Programmierung und Implementierung von Netzwerkprotokollen. <br><br>  Ich freue mich über unterschiedliche Meinungen zu diesem Thema und Feedback von denen, die bereits Erfahrung mit Swoole haben <br><br>  Sie können im beschriebenen Chatraum über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> chatten <br>  Quellen sind auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> verfügbar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427589/">https://habr.com/ru/post/de427589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427579/index.html">Anwendungsverteilung für iOS innerhalb des Unternehmens (Enterprise Distribute iOS App inhouse)</a></li>
<li><a href="../de427581/index.html">Testen von Zyxel vs Ubiquiti Access Points</a></li>
<li><a href="../de427583/index.html">Wir kommunizieren mit einflussreichen PR-Journalisten: Es sind 10 Geheimnisse, die die Wahrscheinlichkeit erhöhen, Ihren Artikel zu veröffentlichen</a></li>
<li><a href="../de427585/index.html">Das Rezept für ein beliebtes und erfolgreiches MMO-Spiel.</a></li>
<li><a href="../de427587/index.html">Konzentriertes Java für eineinhalbtausend Menschen. Wie war Joker 2018?</a></li>
<li><a href="../de427591/index.html">Architektur als Belastung</a></li>
<li><a href="../de427593/index.html">Schnellbefehlsmagie in Vivaldi 2.1</a></li>
<li><a href="../de427595/index.html">Versuchen Sie Micronaut oder Darling, ich habe das Framework reduziert</a></li>
<li><a href="../de427601/index.html">5 + 1 Fall, in dem die REST-API-Spezifikation eine große Rolle spielt</a></li>
<li><a href="../de427603/index.html">Wie man endlich anfängt, Tests zu schreiben und es nicht bereut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>