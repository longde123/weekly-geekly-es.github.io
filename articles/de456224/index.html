<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîâ üßë üòì Ank√ºndigung der .NET Core 3.0-Vorschau 6 üë®‚Äçüë©‚Äçüë¶ üì¨ üíñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute k√ºndigen wir .NET Core 3.0 Preview 6 an . Es enth√§lt Updates zum Kompilieren von Assemblys f√ºr einen verbesserten Start und zur Optimierung der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ank√ºndigung der .NET Core 3.0-Vorschau 6</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/456224/"><p>  Heute k√ºndigen wir <a href="" rel="nofollow">.NET Core 3.0 Preview 6 an</a> .  Es enth√§lt Updates zum Kompilieren von Assemblys f√ºr einen verbesserten Start und zur Optimierung der Gr√∂√üe von Anwendungen mit Linker- und EventPipe-Verbesserungen.  Wir haben auch neue Docker-Images f√ºr Alpine auf ARM64 ver√∂ffentlicht. </p><br><ul><li><p>  <a href="" rel="nofollow">Laden Sie .NET Core 3.0 Preview 6</a> jetzt unter Windows, MacOS und Linux <a href="" rel="nofollow">herunter</a> . </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versionshinweise wurden</a> bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnet / core ver√∂ffentlicht</a> .  Ein <a href="">API-Unterschied zwischen Vorschau 5 und 6</a> ist ebenfalls verf√ºgbar. </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ASP.NET Core</a> und EF Core ver√∂ffentlichen heute ebenfalls Updates. </p></li><li><p>  Wenn Sie es verpasst haben, lesen Sie die Verbesserungen, die wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">.NET Core 3.0 Preview 5</a> vom letzten Monat ver√∂ffentlicht haben. </p></li></ul><br><img src="https://habrastorage.org/webt/m8/il/ym/m8ilymhs6vkajgs1wfbpnzud3lw.jpeg"><a name="habracut"></a><br><br><h2>  WPF- und Windows Forms-Update </h2><br><p>  Das WPF-Team hat nun die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ver√∂ffentlichung des gr√∂√üten Teils der WPF-Codebasis auf GitHub abgeschlossen</a> .  Tats√§chlich haben sie gerade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Quelle f√ºr f√ºnfzehn Versammlungen ver√∂ffentlicht</a> .  F√ºr alle, die mit WPF vertraut sind, sollten die Baugruppennamen sehr vertraut sein. </p><br><p>  In einigen F√§llen befinden sich noch Tests im R√ºckstand, um bei oder vor 3.0 GA ver√∂ffentlicht zu werden.  Das Vorhandensein dieses gesamten Codes sollte es der WPF-Community jedoch erm√∂glichen, sich uneingeschr√§nkt an √Ñnderungen in WPF zu beteiligen.  Aus dem Lesen einiger GitHub-Probleme geht hervor, dass die Community √ºber einen eigenen R√ºckstand verf√ºgt, auf dessen Realisierung sie gewartet hat.  Dunkles Thema vielleicht? </p><br><h2>  Alpine Docker Bilder </h2><br><p>  Docker-Images sind jetzt sowohl f√ºr .NET Core als auch f√ºr ASP.NET Core auf ARM64 verf√ºgbar.  Sie waren bisher nur f√ºr x64 verf√ºgbar. </p><br><p> Die folgenden Bilder k√∂nnen in einer <code>Dockerfile</code> oder mit <code>docker pull</code> , wie unten gezeigt: </p><br><ul><li> <code>docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8</code> </li> <li> <code>docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8</code> </li> </ul><br><h2>  Verbesserungen der Ereignisleitung </h2><br><p>  Event Pipe unterst√ºtzt jetzt mehrere Sitzungen.  Dies bedeutet, dass Sie Ereignisse mit EventListener in-proc konsumieren und gleichzeitig nicht prozessbedingte Event-Pipe-Clients haben k√∂nnen. </p><br><p>  Neue Perf Counters hinzugef√ºgt: </p><br><ul><li>  % Zeit in GC </li><li>  Gen 0 Heap Size </li><li>  Gen 1 Heap Size </li><li>  Gen 2 Heap Size </li><li>  LOH Heap Size </li><li>  Zuteilungsrate </li><li>  Anzahl der geladenen Baugruppen </li><li>  Anzahl der ThreadPool-Threads </li><li>  √úberwachungssperrkonfliktrate </li><li>  ThreadPool Work Items Queue </li><li>  ThreadPool-Rate abgeschlossener Arbeitselemente </li></ul><br><p>  Profiler Attach wird jetzt mit derselben Event Pipe-Infrastruktur implementiert. </p><br><p>  Unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Spielen mit Z√§hlern</a> von David Fowler erhalten Sie eine Vorstellung davon, was Sie mit Event Pipe tun k√∂nnen, um Ihre eigenen Leistungsuntersuchungen durchzuf√ºhren oder einfach den Anwendungsstatus zu √ºberwachen. </p><br><p>  <a href="">Informationen</a> zum Installieren des Dotnet-Z√§hlertools finden Sie unter Punktnetzz√§hler. </p><br><h2>  Optimieren Sie Ihre .NET Core-Apps mit ReadyToRun-Images </h2><br><p>  Sie k√∂nnen die Startzeit Ihrer .NET Core-Anwendung verbessern, indem Sie Ihre Anwendungsassemblys im ReadyToRun-Format (R2R) kompilieren.  R2R ist eine Form der AOT-Kompilierung. </p><br><p>  R2R-Bin√§rdateien verbessern die Startleistung, indem sie den Arbeitsaufwand reduzieren, den die JIT beim Laden Ihrer Anwendung leisten muss.  Die Bin√§rdateien enthalten √§hnlichen nativen Code wie die JIT, wodurch die JIT ein bisschen Urlaub bekommt, wenn die Leistung am wichtigsten ist (beim Start).  R2R-Bin√§rdateien sind gr√∂√üer, da sie sowohl IL-Code (Intermediate Language) enthalten, der f√ºr einige Szenarien noch ben√∂tigt wird, als auch die native Version desselben Codes, um den Start zu verbessern. </p><br><p>  R2R wird mit .NET Core 3.0 unterst√ºtzt.  Es kann nicht mit fr√ºheren Versionen von .NET Core verwendet werden. </p><br><h3>  Beispielleistungszahlen </h3><br><p>  Im Folgenden sind die Leistungszahlen aufgef√ºhrt, die mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel-WPF-Anwendung</a> erfasst wurden.  Die Anwendung wurde als eigenst√§ndig ver√∂ffentlicht und verwendete nicht den Assembly-Linker (der sp√§ter in diesem Beitrag behandelt wird). </p><br><p>  Nur-IL-Anwendung: </p><br><ul><li>  Startzeit: 1,9 Sekunden </li><li>  Speichernutzung: 69,1 MB </li><li>  Anwendungsgr√∂√üe: 150 MB </li></ul><br><p>  Mit ReadyToRun-Bildern: </p><br><ul><li>  Startzeit: 1,3 Sekunden. </li><li>  Speichernutzung: 55,7 MB </li><li>  Anwendungsgr√∂√üe: 156 MB </li></ul><br><h2>  ReadyToRun-Bilder, erkl√§rt </h2><br><p>  Sie k√∂nnen R2R sowohl Bibliotheken als auch Anwendungsbin√§rdateien kompilieren.  Derzeit k√∂nnen Bibliotheken nur als Teil einer Anwendung R2R-kompiliert werden, nicht als NuGet-Paket.  Wir m√∂chten mehr Feedback dar√ºber, ob dieses Szenario wichtig ist. </p><br><p>  AOT-Kompilierungsassemblys sind seit langem als Konzept f√ºr .NET verf√ºgbar und gehen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">.NET Framework und NGEN zur√ºck</a> .  NGEN hat einen entscheidenden Nachteil: Die Kompilierung muss auf Client-Computern mit dem NGEN-Tool durchgef√ºhrt werden.  Es ist nicht m√∂glich, NGEN-Images als Teil Ihres Anwendungsbuilds zu generieren. </p><br><p>  Geben Sie .NET Core ein.  Es wird mit <a href="">crossgen geliefert</a> , das native Bilder in einem neueren Format namens <a href="">ReadyToRun erzeugt</a> .  Der Name beschreibt sein prim√§res Wertversprechen: Diese nativen Images k√∂nnen als Teil Ihres Builds erstellt werden und sind ohne zus√§tzliche Arbeit auf Client-Computern "betriebsbereit".  Das ist eine gro√üe Verbesserung und auch ein wichtiger Gewinn f√ºr den Klimawandel. </p><br><p>  In Bezug auf die Kompatibilit√§t √§hneln ReadyToRun-Images IL-Assemblys mit einigen wesentlichen Unterschieden. </p><br><ul><li>  IL-Assemblys enthalten nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">IL-Code</a> .  Sie k√∂nnen zu jeder Laufzeit ausgef√ºhrt werden, die das angegebene Zielframework f√ºr diese Assembly unterst√ºtzt.  Beispielsweise kann eine <code>netstandard2.0</code> Assembly unter .NET Framework 4.6+ und .NET Core 2.0+ unter jedem unterst√ºtzten Betriebssystem (Windows, macOS, Linux) und jeder Architektur (Intel, ARM, 32-Bit, 64-Bit) ausgef√ºhrt werden. </li><li>  R2R-Assemblys enthalten IL und nativen Code.  Sie werden f√ºr eine bestimmte minimale .NET Core-Laufzeitversion und Laufzeitumgebung (RID) kompiliert.  Beispielsweise kann eine <code>netstandard2.0</code> Assembly R2R f√ºr .NET Core 3.0 und Linux x64 kompiliert werden.  Es kann nur in dieser oder einer kompatiblen Konfiguration (wie .NET Core 3.1 oder .NET Core 5.0 unter Linux x64) verwendet werden, da es nativen Code enth√§lt, der nur in dieser Laufzeitumgebung verwendet werden kann. </li></ul><br><h3>  Anleitung </h3><br><p>  Die ReadyToRun-Kompilierung ist eine reine Ver√∂ffentlichungsoption.  Wir haben eine Vorschau-Version mit .NET Core 3.0 Preview 5 ver√∂ffentlicht. </p><br><p>  Um die ReadyToRun-Kompilierung zu aktivieren, m√ºssen Sie: </p><br><ul><li>  Setzen Sie die <code>PublishReadyToRun</code> Eigenschaft auf <code>true</code> . </li><li>  Ver√∂ffentlichen Sie mit einem expliziten <code>RuntimeIdentifier</code> . </li></ul><br><p>  Hinweis: Wenn die Anwendungsassemblys kompiliert werden, ist der erzeugte native Code plattform- und architekturspezifisch (weshalb Sie beim Ver√∂ffentlichen einen g√ºltigen RuntimeIdentifier angeben m√ºssen). </p><br><p>  Hier ist ein Beispiel: </p><br><pre> <code class="cs hljs">&lt;Project Sdk=<span class="hljs-string"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span>&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3<span class="hljs-number"><span class="hljs-number">.0</span></span>&lt;/TargetFramework&gt; &lt;PublishReadyToRun&gt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>&lt;/PublishReadyToRun&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt;</code> </pre> <br><p>  Und ver√∂ffentlichen Sie mit dem folgenden Befehl: </p><br><pre> <code class="cs hljs">dotnet publish -r win-x64 -c Release</code> </pre> <br><p>  Hinweis: Der <code>RuntimeIdentifier</code> kann auch in der Projektdatei festgelegt werden. </p><br><p>  Hinweis: ReadyToRun wird derzeit nur f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">eigenst√§ndige Apps unterst√ºtzt</a> .  Es wird in einer sp√§teren Vorschau f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Framework-abh√§ngige Apps</a> aktiviert. </p><br><p>  Die native Symbolgenerierung kann aktiviert werden, indem die <code>PublishReadyToRunEmitSymbols</code> Eigenschaft in Ihrem Projekt auf <code>true</code> .  Sie m√ºssen keine nativen Symbole f√ºr Debugging-Zwecke generieren.  Diese Symbole sind nur f√ºr Profilierungszwecke n√ºtzlich. </p><br><p>  Das SDK unterst√ºtzt derzeit eine M√∂glichkeit, bestimmte Assemblys von der Kompilierung in ReadyToRun-Images auszuschlie√üen.  Dies kann in F√§llen n√ºtzlich sein, in denen bestimmte Baugruppen nicht wirklich f√ºr die Leistung optimiert werden m√ºssen.  Dies kann dazu beitragen, die Gr√∂√üe der Anwendung zu reduzieren.  Dies kann auch eine n√ºtzliche Problemumgehung f√ºr F√§lle sein, in denen der ReadyToRun-Compiler eine bestimmte Assembly nicht kompilieren kann.  Der Ausschluss erfolgt √ºber die Elementgruppe PublishReadyToRunExclude.  Beispiel: </p><br><pre> <code class="cs hljs">&lt;ItemGroup&gt; &lt;PublishReadyToRunExclude Include=<span class="hljs-string"><span class="hljs-string">"FilenameOfAssemblyToExclude.dll"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><h2>  Plattform√ºbergreifende / architektonische Zusammenstellungen </h2><br><p>  Der ReadyToRun-Compiler unterst√ºtzt derzeit kein Cross-Targeting.  Sie m√ºssen auf einem bestimmten Ziel kompilieren.  Wenn Sie beispielsweise R2R-Images f√ºr Windows x64 m√∂chten, m√ºssen Sie den Ver√∂ffentlichungsbefehl in dieser Umgebung ausf√ºhren. </p><br><p>  Ausnahmen hiervon: </p><br><ul><li>  Windows x64 kann zum Kompilieren von Windows ARM32-, ARM64- und x86-Images verwendet werden. </li><li>  Windows x86 kann zum Kompilieren von Windows ARM32-Images verwendet werden. </li><li>  Linux x64 kann zum Kompilieren von Linux ARM32- und ARM64-Images verwendet werden. </li></ul><br><h2>  Baugruppenverkn√ºpfung </h2><br><p>  Das .NET Core 3.0 SDK enth√§lt ein Tool, mit dem Sie die Gr√∂√üe von Apps reduzieren k√∂nnen, indem Sie IL analysieren und nicht verwendete Assemblys k√ºrzen. </p><br><p>  Mit .NET Core war es immer m√∂glich, eigenst√§ndige Apps zu ver√∂ffentlichen, die alles enthalten, was zum Ausf√ºhren Ihres Codes erforderlich ist, ohne dass .NET auf dem Bereitstellungsziel installiert werden muss.  In einigen F√§llen ben√∂tigt die App nur eine kleine Teilmenge des Frameworks, um zu funktionieren, und kann m√∂glicherweise erheblich verkleinert werden, indem nur die verwendeten Bibliotheken einbezogen werden. </p><br><p>  Wir verwenden den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IL-Linker</a> , um die IL Ihrer Anwendung zu scannen, um festzustellen, welcher Code tats√§chlich ben√∂tigt wird, und um dann nicht verwendete Framework-Bibliotheken zu k√ºrzen.  Dies kann die Gr√∂√üe einiger Apps erheblich reduzieren.  In der Regel profitieren kleine werkzeug√§hnliche Konsolen-Apps am meisten, da sie in der Regel relativ kleine Teilmengen des Frameworks verwenden und sich normalerweise besser zuschneiden lassen. </p><br><p>  Um dieses Tool zu verwenden, setzen Sie <code>PublishTrimmed=true</code> in Ihrem Projekt und ver√∂ffentlichen Sie eine eigenst√§ndige App: </p><br><pre> <code class="cs hljs">dotnet publish -r &lt;rid&gt; -c Release</code> </pre> <br><p>  Die Ver√∂ffentlichungsausgabe enth√§lt eine Teilmenge der Framework-Bibliotheken, je nachdem, was der Anwendungscode aufruft.  Bei einer Helloworld-App reduziert der Linker die Gr√∂√üe von ~ 68 MB auf ~ 28 MB. </p><br><p>  Anwendungen oder Frameworks (einschlie√ülich ASP.NET Core und WPF), die Reflektion oder verwandte dynamische Funktionen verwenden, werden beim Trimmen h√§ufig unterbrochen, da der Linker dieses dynamische Verhalten nicht kennt und normalerweise nicht bestimmen kann, welche Framework-Typen f√ºr die Reflektion erforderlich sind zur Laufzeit.  Um solche Apps zu k√ºrzen, m√ºssen Sie dem Linker alle Typen mitteilen, die durch Reflektion in Ihrem Code und in allen Paketen oder Frameworks, von denen Sie abh√§ngig sind, ben√∂tigt werden.  Testen Sie Ihre Apps nach dem Zuschneiden. </p><br><p>  Weitere Informationen zum IL Linker finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dokumentation</a> oder im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mono / Linker</a> Repo. </p><br><p>  Hinweis: In fr√ºheren Versionen von .NET Core wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ILLink.Tasks</a> als externes NuGet-Paket ausgeliefert und bot weitgehend die gleiche Funktionalit√§t.  Es wird nicht mehr unterst√ºtzt - bitte aktualisieren Sie auf das neueste 3.0 SDK und probieren Sie die neue Erfahrung aus! </p><br><h2>  Linker und ReadToRun zusammen verwenden </h2><br><p>  Der Linker und der ReadyToRun-Compiler k√∂nnen f√ºr dieselbe Anwendung verwendet werden.  Im Allgemeinen verkleinert der Linker Ihre Anwendung, und der sofort einsatzbereite Compiler macht sie wieder etwas gr√∂√üer, jedoch mit einem erheblichen Leistungsgewinn.  Es lohnt sich, in verschiedenen Konfigurationen zu testen, um die Auswirkungen der einzelnen Optionen zu verstehen. </p><br><p>  Hinweis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnet / sdk # 3257</a> verhindert, dass der Linker und ReadyToRun zusammen f√ºr WPF- und Windows Forms-Anwendungen verwendet werden.  Wir arbeiten daran, dies im Rahmen der .NET Core 3.0-Version zu beheben. </p><br><h2>  Native Hosting-Beispiel </h2><br><p>  Das Team hat k√ºrzlich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Native Hosting-Beispiel ver√∂ffentlicht</a> .  Es zeigt einen Best-Practice-Ansatz f√ºr das Hosten von .NET Core in einer nativen Anwendung. </p><br><p>  Als Teil von .NET Core 3.0 stellen wir nun allgemeine Funktionen f√ºr native .NET Core-Hosts bereit, die zuvor nur f√ºr von .NET Core verwaltete Anwendungen √ºber die offiziell bereitgestellten .NET Core-Hosts verf√ºgbar waren.  Die Funktionalit√§t bezieht sich haupts√§chlich auf das Laden von Baugruppen.  Diese Funktionalit√§t sollte es einfacher machen, native Hosts zu erstellen, die alle Funktionen von .NET Core nutzen k√∂nnen. </p><br><h2>  HTTP / 2-Unterst√ºtzung in HttpClient </h2><br><p>  HTTP / 2 ist eine wichtige √úberarbeitung des HTTP-Protokolls.  Einige der bemerkenswerten Funktionen von HTTP / 2 sind die Unterst√ºtzung der Header-Komprimierung und vollst√§ndig gemultiplexter Streams √ºber dieselbe Verbindung.  W√§hrend HTTP / 2 die Semantik von HTTP (HTTP-Header, -Methoden usw.) beibeh√§lt, ist es eine √Ñnderung von HTTP / 1.x, wie Daten gerahmt und √ºber das Kabel gesendet werden. </p><br><p>  <code>HttpClient</code> jetzt Unterst√ºtzung f√ºr HTTP / 2-Anforderungen.  W√§hrend die Standardeinstellung HTTP / 1.1 bleibt, k√∂nnen Sie sich f√ºr die Verwendung von HTTP / 2 entscheiden, indem Sie die Version in Ihrer HTTP-Anforderungsnachricht festlegen. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// HTTP/1.1 request using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); } // HTTP/2 request using (var request = new HttpRequestMessage(HttpMethod.Get, "/") { Version = new Version(2, 0) }) using (var response = await client.SendAsync(request)) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Alternativ k√∂nnen Sie standardm√§√üig HTTP / 2-Anforderungen senden, indem Sie die <code>DefaultRequestVersion</code> Eigenschaft in <code>HttpClient</code> <code>DefaultRequestVersion</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>), DefaultRequestVersion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Version(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// Defaults to HTTP/2 using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Infolge dieser √Ñnderung des Framings m√ºssen Server und Clients die verwendete Protokollversion aushandeln.  Application-Layer Protocol Negotiation (ALPN) ist eine TLS-Erweiterung, mit der Server und Client die Protokollversion aushandeln k√∂nnen, die im Rahmen ihres TLS-Handshakes verwendet wird.  W√§hrend es m√∂glich ist, Vorkenntnisse zwischen dem Server und dem Client √ºber das Protokoll zu haben, unterst√ºtzen die meisten Server nur ALPN als einzige M√∂glichkeit, eine HTTP / 2-Verbindung herzustellen.  Daher wird HTTP / 2 von <code>HttpClient</code> nur √ºber eine TLS-Verbindung ausgehandelt. </p><br><p>  In Entwicklungsszenarien, in denen Server und Client von vornherein wissen, dass beide unverschl√ºsselt HTTP / 2 sprechen, k√∂nnen Sie eine HTTP / 2-Verbindung √ºber Klartext herstellen, indem Sie einen <code>AppContext</code> Schalter oder eine Umgebungsvariable ( <code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT=1</code> ) <code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT=1</code> . </p><br><pre> <code class="cs hljs">AppContext.SetSwitch(<span class="hljs-string"><span class="hljs-string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><h2>  Schlie√üen </h2><br><p>  Bitte probieren Sie die neuen Funktionen aus.  Bitte reichen Sie Probleme f√ºr die Fehler oder herausfordernden Erfahrungen ein, die Sie finden.  Wir wollen das Feedback!  Sie k√∂nnen auch Feature-Anfragen einreichen, aber diese m√ºssen wahrscheinlich warten, bis sie bis zur n√§chsten Version implementiert werden. </p><br><p>  Wir stehen kurz vor der Fertigstellung der Funktionen f√ºr .NET Core 3.0 und verlagern den Fokus des Teams jetzt auf die Qualit√§t der Version.  Wir haben ein paar Monate Zeit, um Fehler zu beheben und die Leistung zu verbessern.  Wir freuen uns √ºber Ihr Feedback, wenn wir diesen Prozess ebenfalls durcharbeiten. </p><br><p>  In diesem Sinne werden wir bald die Hauptzweige von .NET Core-Repos auf die n√§chste Hauptversion umstellen, wahrscheinlich bei oder kurz nach der Preview 7-Version (Juli). </p><br><p>  Vielen Dank, dass Sie die Vorschau von .NET Core 3.0 ausprobiert haben.  Wir bedanken uns f√ºr Ihre Hilfe.  An diesem Punkt konzentrieren wir uns darauf, eine endg√ºltige Ver√∂ffentlichung in Ihre H√§nde zu bekommen. </p><br><hr><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Richard Lander</a> <br>  PM, .NET-Team </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456224/">https://habr.com/ru/post/de456224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456214/index.html">Verwenden Sie __main__.py</a></li>
<li><a href="../de456216/index.html">Machen Sie ein Retro-Spiel aus den 80ern oder wie man Modelle f√ºr das Laserschneiden kocht</a></li>
<li><a href="../de456218/index.html">.NET Core 3.0 (Vorschau 6) ver√∂ffentlicht</a></li>
<li><a href="../de456220/index.html">Verallgemeinerung des Brokar-Problems</a></li>
<li><a href="../de456222/index.html">Die Gentechnik menschlicher Embryonen wird in zwei Jahren sicher und wirksam</a></li>
<li><a href="../de456226/index.html">Vorhersage der Fu√üballergebnisse</a></li>
<li><a href="../de456230/index.html">Iobroker-Suche nach Quests in Reality-Spielen</a></li>
<li><a href="../de456232/index.html">Anleitung: Aktualisieren von Schnittstellen mit Standardmitgliedern in C # 8.0</a></li>
<li><a href="../de456234/index.html">Warum kauft Cisco Splunk nicht oder spricht nicht dar√ºber, wie die Cisco-Plattform f√ºr die Bedrohungssuche funktioniert?</a></li>
<li><a href="../de456236/index.html">Peter - Insider Dev Tour: Insiderkonferenz f√ºr Entwickler von Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>