<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏼 👩🏾‍🤝‍👩🏽 👩🏻‍🎤 5 + 1情况，REST API规范起着重要作用 👰🏽 🧜🏽 😤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文将重点介绍为REST API项目编写和支持有用且相关的规范，该规范将节省大量额外的代码，并从整体上提高整个项目的完整性，可靠性和透明度。 
 什么是RESTful API？ 



 这是一个神话。 


 认真地说，如果您认为您的项目具有RESTful API，那么几乎可以肯定会弄错。 RES...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 + 1情况，REST API规范起着重要作用</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427601/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b1/dg/ob/b1dgobh5dxfw3q-firfz-77qu-0.png"></div><br><p> 本文将重点介绍为REST API项目编写和支持有用且相关的规范，该规范将节省大量额外的代码，并从整体上提高整个项目的完整性，可靠性和透明度。 </p><br><h3 id="chto-takoe-restful-api"> 什么是RESTful API？ </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/ee8/857/ddeee88570832b82d7a7ff7231255c3f.png"></div><br><p> 这是一个神话。 </p><br><p> 认真地说，如果您认为您的项目具有RESTful API，那么几乎可以肯定会弄错。  RESTful的想法是构建一个在所有方面都符合REST样式描述的体系结构规则和限制的API，但是在实际情况下，这<em>几乎是不可能的</em> 。 </p><a name="habracut"></a><br><p> 一方面，REST包含太多模糊不清的定义。 例如，HTTP方法和状态码词典中的某些术语在实践中并未按预期目的使用，而其中许多根本没有使用。 </p><br><p> 另一方面，REST创造了太多的限制。 例如，现实世界中资源的原子使用对于移动应用程序使用的API是不合理的。 完全拒绝在请求之间存储状态实质上是对许多API中使用的用户会话机制的禁止。 </p><br><p>  <strong>但是，等等，并不是所有的事情都那么糟糕！</strong> </p><br><h3 id="zachem-nuzhna-specifikaciya-rest-api"> 为什么我们需要REST API规范？ </h3><br><p> 尽管存在这些缺点，但采用合理的方法，REST仍然是设计真正出色的API的良好基础。 这样的API应该具有内部统一性，清晰的结构，方便的文档记录和良好的单元测试覆盖范围。 所有这些都可以通过为您的API制定质量<strong>规范</strong>来实现。 </p><br><p> 通常，REST API <em>规范</em>与其<em>文档</em>相关联。 与第一个文档不同（后者是API的正式描述），该文档旨在供人们阅读：例如，使用API​​的移动或Web应用程序的开发人员。 </p><br><p> 但是，除了实际创建文档外，正确的API描述仍然可以带来很多好处。 在本文中，我想分享一些示例，说明如何有效使用规范，您可以： </p><br><ul><li> 使单元测试更简单，更可靠； </li><li> 配置输入数据的预处理和验证； </li><li> 自动序列化并确保响应的完整性； </li><li> 甚至利用静态类型。 </li></ul><br><h3 id="openapi">  Openapi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/222/aae/af9/222aaeaf95adf9cb50af1ed7702d4c9b.png" width="500"></div><br><p> 今天，描述REST API的公认格式是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>OpenAPI</strong></a> ，也称为<em>Swagger</em> 。 该规范是JSON或YAML格式的单个文件，由三个部分组成： </p><br><ul><li> 标头，其中包含API的名称，说明和版本，以及其他信息； </li><li> 对所有资源的描述，包括其标识符，HTTP方法，所有输入参数以及响应主体的代码和格式，以及指向定义的链接； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>JSON模式</strong></a>格式的对象的所有定义，都可以在输入参数和响应中使用。 </li></ul><br><p>  OpenAPI有一个严重的缺点- <em>结构复杂，通常还有冗余</em> 。 对于一个小型项目，规范JSON文件的内容可以迅速增长到几千行。 无法以这种形式手动维护此文件。 随着API的发展，这对维护最新规范的想法构成了严重威胁。 </p><br><p> 有许多可视化编辑器可让您描述API并形成最终的OpenAPI规范。 反过来，其他服务和云解决方案也基于它们，例如<em>Swagger</em> ， <em>Apiary</em> ， <em>Stoplight</em> ， <em>Restlet</em>等。 </p><br><p> 但是，对我来说，由于难以快速编辑规范并将其与代码编写过程结合在一起，因此此类服务并不是很方便。 另一个缺点是对每个特定服务功能集的依赖。 例如，几乎不可能仅通过云服务来实施全面的单元测试。 尽管看起来很有可能，但是代码生成甚至为端点创建“插件”实际上都没有用。 </p><br><h3 id="tinyspec">  Tinyspec </h3><br><p> 在本文中，我将使用基于本地REST API描述格式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>-tinyspec的示例</strong></a> 。 格式是小的文件，这些文件以直观的语法描述了项目中使用的端点和数据模型。 文件存储在代码旁边，可让您在编写文件时对其进行检查和编辑。 同时，tinyspec会自动编译为成熟的OpenAPI，可立即在项目中使用。 现在该告诉您确切的方法了。 </p><br><p> 在本文中，我将提供Node.js（koa，express）和Ruby on Rails中的示例，尽管这些实践适用于大多数技术，包括Python，PHP和Java。 </p><br><h2 id="kogda-eschyo-specifikaciya-okazyvaetsya-neveroyatno-poleznoy"> 当规范非常有用时 </h2><br><h3 id="1-unit-testy-endpointov">  1.端点的单元测试 </h3><br><p>  <em>行为驱动开发（BDD）是</em>开发REST API的理想选择。 编写单元测试的最方便方法不是针对单个类，模型和控制器，而是针对特定端点。 在每个测试中，您都模拟一个真实的HTTP请求并检查服务器响应。 在Node.js中，为了模拟测试请求，在Ruby on Rails- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">airborne</a>中提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">supertest</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://www.chaijs.com/plugins/chai-">chai-http</a> 。 </p><br><p>假设我们有一个<code>User</code>模式和一个返回所有用户的<code>GET /users</code>端点。 这是tinyspec语法，对此进行了描述： </p><br><ol><li>  <em>User.models.tinyspec</em>文件： </li></ol><br><pre> <code class="python hljs">User {name, isAdmin: b, age?: i}</code> </pre> <br><ol><li> 文件<em>users.endpoints.tinyspec</em> ： </li></ol><br><pre> <code class="python hljs">GET /users =&gt; {users: User[]}</code> </pre> <br><p> 这是我们的测试结果： </p><br><h4 id="nodejs">  Node.js </h4><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].name).to.be(<span class="hljs-string"><span class="hljs-string">'string'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].isAdmin).to.be(<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].age).to.be.oneOf([<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]); }); });</code> </pre> <br><h4 id="ruby-on-rails">  Ruby on Rails </h4><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect_json_types(<span class="hljs-string"><span class="hljs-string">'users.*'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">isAdmin:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:integer_or_null</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p> 当我们有描述服务器响应格式的规范时，我们可以简化测试，并仅<em>根据该规范检查响应</em> 。 为此，我们将利用我们的tinyspec模型被转换为OpenAPI定义这一事实，该定义又对应于JSON Schema格式。 </p><br><p> 可以测试JS中的任何<em>文字对象</em> （或Ruby中的<code>Hash</code> ，Python中的<code>dict</code> ，PHP中<em>的关联数组</em> ，甚至Java中的<code>Map</code> ）是否符合JSON方案。 甚至还有用于测试框架的相应插件，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RSpec的jest-ajv</a> （npm）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">chai-ajv-json-schema</a> （npm）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">json_matchers</a> （rubygem）。 </p><br><p> 使用方案之前，必须将它们连接到项目。 首先，我们将基于tinyspec生成openapi.json规范文件（此操作可以在每次测试运行之前自动执行）： </p><br><pre> <code class="bash hljs">tinyspec -j -o openapi.json</code> </pre> <br><h4 id="nodejs-1">  Node.js </h4><br><p> 现在，我们可以在项目中使用接收到的JSON，并从中获取<code>definitions</code>键，其中包含所有JSON方案。 方案可以包含交叉引用（ <code>$ref</code> ），因此，如果我们有嵌套方案（例如<code>Blog {posts: Post[]}</code> ），则需要“扩展”它们以便在验证中使用它们。 为此，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">json-schema-deref-sync</a> （npm）。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deref <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'json-schema-deref-sync'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./openapi.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schemas = deref(spec).definitions; describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Chai expect(users[0]).to.be.validWithSchema(schemas.User); // Jest expect(users[0]).toMatchSchema(schemas.User); }); });</span></span></code> </pre> <br><h4 id="ruby-on-rails-1">  Ruby on Rails </h4><br><p>  <code>json_matchers</code>可以处理<code>$ref</code>链接，但是需要以某种方式在文件系统中使用带有方案的单独文件，因此首先您必须将<code>swagger.json</code> “拆分”为许多小文件（有关更多信息，请<code>swagger.json</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> ）： </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./spec/support/json_schemas.rb require 'json' require 'json_matchers/rspec' JsonMatchers.schema_root = 'spec/schemas' # Fix for json_matchers single-file restriction file = File.read 'spec/schemas/openapi.json' swagger = JSON.parse(file, symbolize_names: true) swagger[:definitions].keys.each do |key| File.open("spec/schemas/#{key}.json", 'w') do |f| f.write(JSON.pretty_generate({ '$ref': "swagger.json#/definitions/#{key}" })) end end</span></span></code> </pre> <br><p> 之后，我们可以这样编写测试： </p><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect(result[<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]).to match_json_schema(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p> 注意：用这种方式编写测试非常方便。 特别是在您的IDE支持运行测试和调试（例如WebStorm，RubyMine和Visual Studio）的情况下。 因此，您完全不能使用任何其他软件，并且该API的整个开发周期缩短为3个连续的步骤： </p><br><ol><li> 规范设计（例如在tinyspec中）; </li><li> 为添加/更改的端点编写一套完整的测试； </li><li> 开发满足所有测试要求的代码。 </li></ol><br><h3 id="2-validaciya-vhodnyh-dannyh">  2.输入验证 </h3><br><p>  OpenAPI不仅描述了响应的格式，而且还描​​述了输入数据的格式。 这使我们可以在请求期间<em>验证</em>从用户权限接收<em>的数据</em> 。 </p><br><p> 假设我们具有以下描述更新用户数据以及所有可更改字段的规范： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># user.models.tinyspec UserUpdate !{name?, age?: i} # users.endpoints.tinyspec PATCH /users/:id {user: UserUpdate} =&gt; {success: b}</span></span></code> </pre> <br><p> 之前我们看过测试中用于验证的插件，但是对于更一般的情况，有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ajv</a> （npm）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">json-schema</a> （rubygem）验证模块，让我们使用它们并编写一个带有验证的控制器。 </p><br><h4 id="nodejs-koa">  Node.js（Koa） </h4><br><p> 这是Express的后继者<strong>Koa的</strong>一个示例，但是对于Express，代码将看起来相似。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ajv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ajv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); <span class="hljs-comment"><span class="hljs-comment">// Standard resource update action in Koa. router.patch('/:id', async (ctx) =&gt; { const updateData = ctx.body.user; // Validation using JSON schema from API specification. await validate(schemas.UserUpdate, updateData); const user = await User.findById(ctx.params.id); await user.update(updateData); ctx.body = { success: true }; }); async function validate(schema, data) { const ajv = new Ajv(); if (!ajv.validate(schema, data)) { const err = new Error(); err.errors = ajv.errors; throw err; } }</span></span></code> </pre> <br><p> 在此示例中，如果输入数据不符合规范，则服务器将向客户端返回<code>500 Internal Server Error</code>响应。 为了防止这种情况的发生，我们可以拦截验证器错误并形成自己的响应，该响应将包含有关尚未通过测试的特定字段的更详细信息，并且还应<em>符合规范</em> 。 </p><br><p> 在<code>FieldsValidationError</code>文件中添加<code>FieldsValidationError</code>模型的描述： </p><br><pre> <code class="python hljs">Error {error: b, message} InvalidField {name, message} FieldsValidationError &lt; Error {fields: InvalidField[]}</code> </pre> <br><p> 现在，我们将其指示为端点的可能答案之一： </p><br><pre> <code class="python hljs">PATCH /users/:id {user: UserUpdate} =&gt; <span class="hljs-number"><span class="hljs-number">200</span></span> {success: b} =&gt; <span class="hljs-number"><span class="hljs-number">422</span></span> FieldsValidationError</code> </pre> <br><p> 这种方法将允许您编写单元测试，以使用从客户端接收到的不正确数据来验证错误形成的正确性。 </p><br><h3 id="3-serializaciya-modeley">  3.模型的序列化 </h3><br><p> 几乎所有现代服务器框架都<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以一种</a>或另<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一种</a>方式使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ORM</a> 。 这意味着系统内部API中使用的大多数资源都以模型，其实例和集合的形式呈现。 </p><br><p> 生成这些实体的JSON表示形式以在API响应中传输的过程称为<em>序列化</em> 。 有许多用于执行序列化功能的不同框架的插件，例如： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sequelize-to-json</a> （npm）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">acts_as_api</a> （rubygem）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">jsonapi-rails</a> （rubygem）。 实际上，这些插件允许特定的模型指定必须包含在JSON对象中的字段列表以及其他规则，例如重命名它们或动态计算值。 </p><br><p> 当我们需要使用同一模型的几种不同的JSON表示形式，或者当一个对象包含嵌套实体（关联）时，就会出现困难。 需要<em>继承，重用和链接序列化程序</em> 。 </p><br><p> 不同的模块以不同的方式解决这些问题，但是让我们想想，规范可以再次为我们提供帮助吗？ 实际上，事实上，有关JSON表示的要求的所有信息，所有可能的字段组合（包括嵌套实体）都已包含在其中。 因此，我们可以编写一个自动序列化器。 </p><br><p> 我提请您注意一个小模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sequelize-serialize</a> （npm），它使您可以对Sequelize模型进行此操作。 它采用模型或数组的实例以及所需的电路，并考虑所有必需的字段并为关联实体使用嵌套电路，以迭代方式构造一个序列化对象。 </p><br><p> 因此，假设我们需要从API中返回所有拥有博客帖子的用户，包括对这些帖子的评论。 我们使用以下规范对此进行描述： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.tinyspec Comment {authorId: i, message} Post {topic, message, comments?: Comment[]} User {name, isAdmin: b, age?: i} UserWithPosts &lt; User {posts: Post[]} # blogUsers.endpoints.tinyspec GET /blog/users =&gt; {users: UserWithPosts[]}</span></span></code> </pre> <br><p> 现在，我们可以使用Sequelize构建查询并返回与上述规范完全匹配的序列化对象： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serialize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sequelize-serialize'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/blog/users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findAll({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">association</span></span>: User.posts, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [Post.comments] }] }); ctx.body = serialize(users, schemas.UserWithPosts); });</code> </pre> <br><p> 几乎是魔术，对不对？ </p><br><h3 id="4-staticheskaya-tipizaciya">  4.静态打字 </h3><br><p> 如果您太酷了，以至于正在使用TypeScript或Flow，您可能已经想知道， <em>“亲爱的静态类型呢？！”</em>  。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sw2dts</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">swagger-to-flowtype模块，</a>您可以基于JSON方案生成所有必要的定义，并将它们用于测试，输入数据和序列化程序的静态类型。 </p><br><pre> <code class="bash hljs">tinyspec -j sw2dts ./swagger.json -o Api.d.ts --namespace Api</code> </pre> <br><p> 现在我们可以在控制器中使用类型： </p><br><pre> <code class="hljs pgsql">router.patch(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>, async (ctx) =&gt; { // Specify <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request data <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> const userData: Api.UserUpdate = ctx.request.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; // Run spec validation await <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.UserUpdate, userData); // Query the <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = await <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.findById(ctx.params.id); await <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(userData); // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> serialized result const serialized: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = serialize(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); ctx.body = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: serialized }; });</code> </pre> <br><p> 在测试中： </p><br><pre> <code class="hljs pgsql">it(<span class="hljs-string"><span class="hljs-string">'Update user'</span></span>, async () =&gt; { // Static <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> data. const updateData: Api.UserUpdate = { <span class="hljs-type"><span class="hljs-type">name</span></span>: MODIFIED }; const res = await request.patch(<span class="hljs-string"><span class="hljs-string">'/users/1'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: updateData }); // <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> helper <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request response: const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = res.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.be.validWithSchema(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.containSubset(updateData); });</code> </pre> <br><p> 请注意，生成的类型定义不仅可以在API项目本身中使用，而且可以在客户端应用程序项目中使用，以描述API工作的功能类型。  Angular客户开发人员将对此礼物特别满意。 </p><br><h3 id="5-privedenie-tipov-query-string">  5.查询字符串的类型转换 </h3><br><p> 如果由于某种原因您的API接受MIME类型为<code>application/x-www-form-urlencoded</code>而不是<code>application/json</code>的请求，则请求正文将如下所示： </p><br><pre> <code class="python hljs">param1=value&amp;param2=<span class="hljs-number"><span class="hljs-number">777</span></span>&amp;param3=false</code> </pre> <br><p> 这同样适用于查询参数（例如，在GET请求中）。 在这种情况下，Web服务器将无法自动识别类型-所有数据都将以字符串形式（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a> qpm npm模块存储库中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的讨论</a> ），因此在解析之后，您将获得以下对象： </p><br><pre> <code class="python hljs">{ param1: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, param2: <span class="hljs-string"><span class="hljs-string">'777'</span></span>, param3: <span class="hljs-string"><span class="hljs-string">'false'</span></span> }</code> </pre> <br><p> 在这种情况下，将不会根据方案验证请求，这意味着有必要手动验证每个参数的格式正确，并将其转换为所需的类型。 </p><br><p> 您可能会猜到，这可以使用我们规范中所有相同的方案来完成。 想象一下，我们有这样一个端点和方案： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># posts.endpoints.tinyspec GET /posts?PostsQuery # post.models.tinyspec PostsQuery { search, limit: i, offset: i, filter: { isRead: b } }</span></span></code> </pre> <br><p> 这是对此类端点的请求示例 </p><br><pre> <code class="python hljs">GET /posts?search=needle&amp;offset=<span class="hljs-number"><span class="hljs-number">10</span></span>&amp;limit=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;filter[isRead]=true</code> </pre> <br><p> 让我们编写一个<code>castQuery</code>函数，它将所有参数<code>castQuery</code>为我们所需的类型。 它看起来像这样： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query, schema</span></span></span><span class="hljs-function">) </span></span>{ _.mapValues(query, (value, key) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type } = schema.properties[key] || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value || !type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'integer'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-string"><span class="hljs-string">'false'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }); }</code> </pre> <br><p> 它的更完整的实现支持嵌套模式，数组和<code>null</code>类型，可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模式转换</a> （npm）中使用。 现在我们可以在代码中使用它： </p><br><pre> <code class="javascript hljs">router.get(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Cast parameters to expected types const query = castQuery(ctx.query, schemas.PostsQuery); // Run spec validation await validate(schemas.PostsQuery, query); // Query the database const posts = await Post.search(query); // Return serialized result ctx.body = { posts: serialize(posts, schemas.Post) }; });</span></span></code> </pre> <br><p> 注意端点代码的四行，以及规范中的三种使用方案。 </p><br><h2 id="luchshie-praktiki"> 最佳实务 </h2><br><h3 id="otdelnye-shemy-dlya-sozdaniya-i-izmeneniya"> 用于创建和修改的单独方案 </h3><br><p> 通常，描述服务器响应的方案与描述用于创建和修改模型的输入的方案不同。 例如，应严格限制<code>POST</code>和<code>PATCH</code>请求的可用字段列表，而在<code>PATCH</code>请求中，通常将方案的所有字段都设为可选。 确定答案的方案可能更免费。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tinyspec CRUDL</a>端点的自动<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生成</a>使用“ <code>New</code>和“ <code>Update</code>后缀。  <code>User*</code>可以定义如下： </p><br><pre> <code class="python hljs">User {id, email, name, isAdmin: b} UserNew !{email, name} UserUpdate !{email?, name?}</code> </pre> <br><p> 尽量不要对不同类型的操作使用相同的方案，以避免由于重用或继承旧方案而导致意外的安全问题。 </p><br><h3 id="semantika-v-nazvaniyah-shem"> 模式名称中的语义 </h3><br><p> 同一模型的内容可能在不同的端点中有所不同。 在架构名称中使用<code>With*</code>和<code>For*</code>后缀以显示它们之间的区别以及它们的用途。 在tinyspec模型中，模型也可以彼此继承。 例如： </p><br><pre> <code class="python hljs">User {name, surname} UserWithPhotos &lt; User {photos: Photo[]} UserForAdmin &lt; User {id, email, lastLoginAt: d}</code> </pre> <br><p> 后缀可以更改并组合。 最主要的是，它们的名称反映了本质，并简化了对文档的熟悉。 </p><br><h3 id="razdelenie-endpointov-po-tipu-klienta"> 按客户端类型分隔端点 </h3><br><p> 通常，根据客户端的类型或访问端点的用户角色，相同的端点会返回不同的数据。 例如，对于您的移动应用程序的用户和后台管理人员， <code>GET /users</code>和<code>GET /messages</code>的端点可能会非常不同。 同时，更改端点本身的名称可能会非常复杂。 </p><br><p> 要多次描述同一端点，可以在路径后的方括号中添加其类型。 此外，使用标签很有用：这将有助于将端点的文档分为几组，每组将针对API的特定客户端组而设计。 例如： </p><br><pre> <code class="python hljs">Mobile app: GET /users (mobile) =&gt; UserForMobile[] CRM admin panel: GET /users (admin) =&gt; UserForAdmin[]</code> </pre> <br><h2 id="dokumentaciya-rest-api">  REST API文档 </h2><br><p> 一旦有了tinyspec或OpenAPI格式的规范，就可以使用HTML生成漂亮的文档，并将其发布给使用API​​的开发人员。 </p><br><p> 除了前面提到的云服务之外，还有一些CLI工具可将OpenAPI 2.0转换为HTML和PDF，之后您可以将其下载到任何静态主机。 范例： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bootprint-openapi</a> （npm，在tinyspec中默认使用） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">swagger2markup-cli</a> （jar，有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个use的示例</a> ，它将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tinyspec Cloud中使用</a> ） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">redoc-cli</a> （npm） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维德欣</a> （npm） </li></ul><br><p>  <em>您知道更多示例吗？</em>  <em>在评论中分享它们。</em> </p><br><p> 不幸的是，一年前发布的OpenAPI 3.0仍然得不到很好的支持，我找不到基于它的有价值的文档示例：无论是在云解决方案中，还是在CLI工具中。 由于相同的原因，tinyspec中尚不支持OpenAPI 3.0。 </p><br><h3 id="publikaciya-v-github"> 发布到GitHub </h3><br><p> 发布文档最简单的方法之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub Pages</a> 。 只需在存储库设置中为<code>/docs</code>目录启用静态页面支持，并将HTML文档存储在此文件夹中。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/09b/5ad/775/09b5ad7757239f4405cb370cb59c6a7b.png"></p><br><p> 您可以在<code>package.json</code> <code>scripts</code>中添加命令通过tinyspec或另一个CLI工具生成文档，并在每次提交时更新文档： </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"tinyspec -h -o docs/"</span></span>, <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs"</span></span> }</code> </pre> <br><h3 id="continuous-integration"> 持续整合 </h3><br><p> 您可以在CI周期中包含文档生成并将其发布，例如，根据环境或API版本在不同地址下的Amazon S3中发布，例如： <code>/docs/2.0</code> <code>/docs/stable</code> <code>/docs/2.0</code> ， <code>/docs/staging</code> 。 </p><br><h3 id="tinyspec-cloud">  Tinyspec云 </h3><br><p> 如果您喜欢tinyspec语法，则可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tinyspec.cloud上</a>注册为早期采用者。 我们将在其基础上构建云服务和CLI，以自动发布具有多种模板的文档，并具有开发自己的模板的能力。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 开发REST API可能是在现代Web和移动服务上工作的过程中最有趣的活动。 没有浏览器，操作系统和屏幕尺寸的动物园，一切都在我们的控制之下-“唾手可得”。 </p><br><p> 同时提供各种自动化形式来保持当前的规格和奖金，使此过程变得更加令人愉悦。 这样的API变得结构化，透明和可靠。 </p><br><p>  <em>确实，实际上，即使我们从事神话的创造，但为什么我们不使它变得美丽呢？</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427601/">https://habr.com/ru/post/zh-CN427601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN427587/index.html">Java集中供一千五百人使用。 Joker 2018怎么样</a></li>
<li><a href="../zh-CN427589/index.html">我们使用Swoole在Websockets上进行在线聊天</a></li>
<li><a href="../zh-CN427591/index.html">建筑成为负担</a></li>
<li><a href="../zh-CN427593/index.html">Vivaldi 2.1中的快速命令魔术</a></li>
<li><a href="../zh-CN427595/index.html">尝试Micronaut或Darling，我简化了框架</a></li>
<li><a href="../zh-CN427603/index.html">如何最终开始编写测试而不后悔</a></li>
<li><a href="../zh-CN427605/index.html">Yandex众包平台如何帮助培训无人机并评估服务质量</a></li>
<li><a href="../zh-CN427607/index.html">瑞士的数据中心：像发条一样工作</a></li>
<li><a href="../zh-CN427609/index.html">在没有蛮力的情况下用整数除法求解方程</a></li>
<li><a href="../zh-CN427611/index.html">我如何在iOS或地图，金钱，2个Mappits上更新Yandex MapKit的故事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>