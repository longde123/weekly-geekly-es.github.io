<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏽 🔐 👏 Primeiro Modelo: Conjunto de Dados Fashion MNIST 👨🏼‍🏫 🏢 🌟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O curso completo em russo pode ser encontrado neste link . 
 O curso de inglês original está disponível neste link . 

 Novas palestras são agendadas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeiro Modelo: Conjunto de Dados Fashion MNIST</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454034/">  O curso completo em russo pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br>  O curso de inglês original está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br><img src="https://habrastorage.org/webt/ry/3a/55/ry3a55ljajwq9gp5jwwhztrxyxo.png"><br>  <i>Novas palestras são agendadas a cada 2-3 dias.</i> <br><a name="habracut"></a><br><h2>  Entrevista com Sebastian Trun, CEO da Udacity </h2><br>  "Então, ainda estamos com você e conosco, como antes, Sebastian."  Nós apenas queremos discutir camadas totalmente conectadas, essas mesmas camadas densas.  Antes disso, eu gostaria de fazer uma pergunta.  Quais são os limites e quais são os principais obstáculos que atrapalharão o aprendizado profundo e terão maior impacto nos próximos 10 anos?  Tudo muda tão rápido!  O que você acha que será a próxima "grande coisa"? <br>  Eu diria duas coisas.  A primeira é a IA geral para mais de uma tarefa.  Isso é ótimo!  As pessoas podem resolver mais de um problema e nunca devem fazer a mesma coisa.  O segundo é trazer a tecnologia ao mercado.  Para mim, a peculiaridade do aprendizado de máquina é que ele fornece aos computadores a capacidade de observar e encontrar padrões nos dados, ajudando as pessoas a se tornarem melhores no campo - no nível de especialista!  O aprendizado de máquina pode ser usado em leis, medicina e carros autônomos.  Desenvolva esses aplicativos porque eles podem gerar uma enorme quantia de dinheiro, mas o mais importante é que você tem a oportunidade de tornar o mundo um lugar muito melhor. <br>  “Gosto muito da maneira como você diz tudo em uma única imagem do aprendizado profundo e de sua aplicação - essa é apenas uma ferramenta que pode ajudá-lo a resolver um problema específico. <br>  Sim, exatamente!  Ferramenta incrível, certo? <br>  - Sim, sim, concordo plenamente com você! <br>  "Quase como um cérebro humano!" <br>  - Você mencionou aplicações médicas em nossa primeira entrevista, na primeira parte do curso em vídeo.  Em quais aplicações, na sua opinião, o uso da aprendizagem profunda causa o maior prazer e surpresa? <br>  Muito!  Muito!  A medicina está na pequena lista de áreas que usam ativamente o aprendizado profundo.  Perdi minha irmã há alguns meses, ela estava com câncer, o que é muito triste.  Eu acho que existem muitas doenças que podem ser detectadas mais cedo - nos estágios iniciais, tornando possível curá-las ou retardar o processo de seu desenvolvimento.  A idéia, de fato, é transferir algumas ferramentas para a casa (casa inteligente), para que seja possível detectar tais desvios na saúde muito antes do momento em que a própria pessoa os vê.  Eu também acrescentaria - tudo é repetido, qualquer trabalho de escritório, no qual você executa o mesmo tipo de ações repetidamente, por exemplo, contabilidade.  Até eu, como CEO, faço muitas ações repetitivas.  Seria ótimo automatizá-los, até trabalhar com correspondência por email! <br>  - Eu não posso discordar de você!  Nesta lição, apresentaremos aos alunos um curso com uma camada de rede neural chamada camada densa.  Você poderia nos dizer com mais detalhes o que pensa sobre as camadas totalmente conectadas? <br>  - Então, vamos começar com o fato de que cada rede pode ser conectada de maneiras diferentes.  Alguns deles podem ter conectividade muito estreita, o que permite obter alguns benefícios no dimensionamento e na "vitória" contra grandes redes.  Às vezes, você não sabe quantas conexões precisa e conecta tudo com tudo - isso é chamado de camada totalmente conectada.  Acrescento que essa abordagem tem muito mais poder e potencial do que algo mais estruturado. <br>  - Concordo plenamente com você!  Obrigado por nos ajudar a aprender um pouco mais sobre as camadas totalmente conectadas.  Estou ansioso pelo momento em que finalmente começamos a implementá-los e escrever código. <br>  - Divirta-se!  Vai ser muito divertido! <br><br><h2>  1. Introdução </h2><br>  - Bem vindo de volta!  Na última lição, você descobriu como construir sua primeira rede neural usando o TensorFlow e Keras, como as redes neurais funcionam e como o processo de treinamento (treinamento) funciona.  Em particular, vimos como treinar o modelo para converter graus Celsius em graus Fahrenheit. <br><br><img src="https://habrastorage.org/webt/7h/jc/jq/7hjcjqzg5rz1qzpbncjes5ipor8.jpeg"><br><br>  - Também nos familiarizamos com o conceito de camadas totalmente conectadas (camadas densas), a camada mais importante nas redes neurais.  Mas nesta lição, faremos coisas muito mais legais!  Nesta lição, desenvolveremos uma rede neural capaz de reconhecer elementos e imagens de roupas.  Como mencionamos anteriormente, o aprendizado de máquina usa entradas chamadas "recursos" e saídas chamadas "rótulos", pelas quais o modelo aprende e encontra um algoritmo de transformação.  Portanto, em primeiro lugar, precisaremos de muitos exemplos para treinar a rede neural para reconhecer vários elementos da roupa.  Deixe-me lembrá-lo de que um exemplo de treinamento é um par de valores - um recurso de entrada e um rótulo de saída, que são alimentados na entrada de uma rede neural.  Em nosso novo exemplo, a entrada será uma imagem e a etiqueta de saída deve ser a categoria de roupa à qual o item de roupa mostrado na imagem pertence.  Felizmente, esse conjunto de dados já existe.  Chama-se Moda MNIST.  Examinaremos mais de perto esse conjunto de dados na próxima parte. <br><br><h2>  Conjunto de dados MNIST de moda </h2><br>  Bem-vindo ao mundo do conjunto de dados MNIST!  Portanto, nosso conjunto consiste em imagens de 28x28, cada pixel representando um tom de cinza. <br><br><img src="https://habrastorage.org/webt/ua/mr/f6/uamrf6n8gci7qi2c1t_ganxtai8.jpeg"><br><br>  O conjunto de dados contém imagens de camisetas, blusas, sandálias e até botas.  Aqui está uma lista completa do que o nosso conjunto de dados MNIST contém: <br><br><img src="https://habrastorage.org/webt/3i/ce/7n/3ice7nwlkok2g_n-trodker5s7e.jpeg"><br><br>  Cada imagem de entrada corresponde a um dos rótulos acima.  O conjunto de dados Fashion MNIST contém 70.000 imagens, portanto, temos um local para começar e trabalhar.  Desses 70.000, usaremos 60.000 para treinar a rede neural. <br><br><img src="https://habrastorage.org/webt/4b/ur/60/4bur602odizkfsdpt0fds-3fnxk.png"><br><br>  E usaremos os 10.000 elementos restantes para verificar até que ponto nossa rede neural aprendeu a reconhecer elementos da roupa.  Mais tarde, explicaremos por que dividimos o conjunto de dados em um conjunto de treinamento e um conjunto de testes. <br><br>  Então, aqui está o nosso conjunto de dados do Fashion MNIST. <br><br><img src="https://habrastorage.org/webt/mx/lw/dz/mxlwdzjrfhviwmgsliwdcy6tbwq.png"><br><br>  Lembre-se de que cada imagem no conjunto de dados é uma imagem de tamanho 28x28 em tons de cinza, o que significa que cada imagem tem 784 bytes de tamanho.  Nossa tarefa é criar uma rede neural, que receba esses 784 bytes na entrada e na saída retorne a qual categoria de roupas dentre 10 disponíveis, o elemento aplicado na entrada pertence. <br><br><h2>  Rede neural </h2><br>  Nesta lição, usaremos uma rede neural profunda que aprende a classificar imagens do conjunto de dados Fashion MNIST. <br><br><img src="https://habrastorage.org/webt/xg/cr/h_/xgcrh_cowdhfz-owx34wp-kqzi0.png"><br><br>  A imagem acima mostra como será nossa rede neural.  Vamos dar uma olhada em mais detalhes. <br><br>  O valor de entrada da nossa rede neural é uma matriz unidimensional com um comprimento de 784, uma matriz exatamente desse comprimento pelo motivo de cada imagem ter 28x28 pixels (= 784 pixels no total na imagem), que converteremos em uma matriz unidimensional.  O processo de conversão de uma imagem 2D em um vetor é chamado nivelamento e é implementado através de uma camada de nivelamento - uma camada de nivelamento. <br><br><img src="https://habrastorage.org/webt/7d/wu/d_/7dwud_tt2qctnaigzc8my3pz1j0.png"><br><br>  Você pode executar a suavização criando a camada apropriada: <br><br><pre><code class="python hljs">tf.keras.layers.Flatten(input_shape=[<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre> <br>  Essa camada converte uma imagem 2D de 28x28 pixels (1 byte para tons de cinza para cada pixel) em uma matriz 1D de 784 pixels. <br><br>  Os valores de entrada serão totalmente associados à nossa primeira camada de rede <code>dense</code> , cujo tamanho escolhemos igual a 128 neurônios. <br><br><img src="https://habrastorage.org/webt/mk/n_/3w/mkn_3wrocxruhbwhil0fmh5wh_8.png"><br><br>  Aqui está como será a criação dessa camada no código: <br><br><pre> <code class="python hljs">tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, activation=tf.nn.relu)</code> </pre><br>  Pare com isso!  O que é um <code>tf.nn.relu</code> ?  Não usamos isso em nosso exemplo anterior de rede neural ao converter graus Celsius em graus Fahrenheit!  O ponto principal é que a tarefa atual é muito mais complicada do que a que foi usada como exemplo de descoberta de fatos - a conversão de graus Celsius em graus Fahrenheit. <br><br>  <code>ReLU</code> é uma função matemática que adicionamos à nossa camada totalmente conectada e que dá mais poder à nossa rede.  De fato, essa é uma pequena extensão para nossa camada totalmente conectada, o que permite que nossa rede neural resolva problemas mais complexos.  Não entraremos em detalhes, mas informações um pouco mais detalhadas podem ser encontradas abaixo. <br><br>  Finalmente, nossa última camada, também conhecida como camada de saída, consiste em 10 neurônios.  Consiste em 10 neurônios porque nosso conjunto de dados Fashion MNIST contém 10 categorias de roupas.  Cada um desses 10 valores de saída representará a probabilidade de a imagem de entrada estar nessa categoria de roupas.  Em outras palavras, esses valores refletem a “confiança” do modelo na correção da previsão e correlação da imagem arquivada com uma de 10 categorias de roupas específicas na saída.  Por exemplo, qual é a probabilidade de a imagem mostrar um vestido, tênis, sapatos etc. <br><br><img src="https://habrastorage.org/webt/fo/2b/3v/fo2b3vakws6ubmiwtj9rrctltla.png"><br><br>  Por exemplo, se uma imagem de camisa é enviada para a entrada da nossa rede neural, o modelo pode nos fornecer resultados como os que você vê na imagem acima - a probabilidade da imagem de entrada corresponder ao rótulo de saída. <br><br>  Se você prestar atenção, notará que a maior probabilidade - 0,85 refere-se à etiqueta 6, que corresponde à camisa.  O modelo tem 85% de certeza de que a imagem na camiseta.  Normalmente, coisas que parecem camisas também terão uma alta probabilidade e coisas menos semelhantes terão uma menor probabilidade. <br><br>  Como todos os 10 valores de saída correspondem a probabilidades, ao somar todos esses valores, obtemos 1. Esses 10 valores também são chamados de distribuição de probabilidade. <br><br>  Agora precisamos de uma camada de saída para calcular as próprias probabilidades para cada etiqueta. <br><br><img src="https://habrastorage.org/webt/v5/tt/hk/v5tthkilik-9reer8owxjpv-x3m.png"><br><br>  E faremos isso com o seguinte comando: <br><br><pre> <code class="python hljs">tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=tf.nn.softmax)</code> </pre><br>  De fato, sempre que criamos redes neurais que resolvem problemas de classificação, sempre usamos uma camada totalmente conectada como a última camada de uma rede neural.  A última camada da rede neural deve conter o número de neurônios igual ao número de classes, às quais determinamos a <code>softmax</code> e usamos a função de ativação do softmax. <br><br><h3>  <code>ReLU</code> - função de ativação de neurônios </h3><br>  Nesta lição, falamos sobre a <code>ReLU</code> como algo que amplia os recursos de nossa rede neural e lhe fornece energia adicional. <br><br>  <code>ReLU</code> é uma função matemática que se parece com isso: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/691/c04/e7b/691c04e7b270706458daf61c4b38cf22.png" alt="imagem"><br><br>  A função <code>ReLU</code> retorna 0 se o valor de entrada for um valor negativo ou zero; em todos os outros casos, a função retornará o valor de entrada original. <br><br>  <code>ReLU</code> torna possível resolver problemas não lineares. <br><br>  Converter graus Celsius em graus Fahrenheit é uma tarefa linear, porque a expressão <code>f = 1.8*c + 32</code> é a equação da reta - <code>y = m*x + b</code> .  Mas a maioria das tarefas que queremos resolver é não linear.  Nesses casos, adicionar a função de ativação ReLU à nossa camada totalmente conectada pode ajudar nesse tipo de tarefa. <br><br>  <code>ReLU</code> é apenas um tipo de função de ativação.  Existem funções de ativação, como sigmoid, ReLU, ELU, tanh, no entanto, é o <code>ReLU</code> que <code>ReLU</code> mais frequentemente usado como a função de ativação padrão.  Para criar e usar modelos que incluem ReLU, você não precisa entender como ele funciona internamente.  Se você ainda deseja entender melhor, recomendamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> . <br><br>  Vamos revisar os novos termos introduzidos nesta lição: <br><br><ul><li>  <b>Suavização</b> - o processo de conversão de uma imagem 2D em um vetor 1D; </li><li>  <b>ReLU</b> é uma função de ativação que permite ao modelo resolver problemas não lineares; </li><li>  <b>Softmax</b> - uma função que calcula as probabilidades para cada classe de saída possível; </li><li>  <b>Classificação</b> - uma classe de tarefas de aprendizado de máquina usadas para determinar as diferenças entre duas ou mais categorias (classes). </li></ul><br><h2>  Treinamento e teste </h2><br>  Ao treinar um modelo, qualquer modelo no aprendizado de máquina, é sempre necessário dividir o conjunto de dados em pelo menos dois conjuntos diferentes - o conjunto de dados usado para treinamento e o conjunto de dados usado para teste.  Nesta parte, entenderemos por que vale a pena fazer isso. <br><br>  Vamos lembrar como distribuímos nosso conjunto de dados do Fashion MNIST, composto por 70.000 cópias. <br><br><img src="https://habrastorage.org/webt/4b/ur/60/4bur602odizkfsdpt0fds-3fnxk.png"><br><br>  Propusemos dividir 70.000 em duas partes - na primeira parte, deixamos 60.000 para treinamento e na segunda parte 10.000 para testes.  A necessidade dessa abordagem é causada pelo seguinte fato: após o modelo ter sido treinado em 60.000 cópias, é necessário verificar os resultados e a eficácia de seu trabalho em exemplos que ainda não estavam no conjunto de dados em que o modelo foi treinado. <br><br>  À sua maneira, assemelha-se a passar em um exame na escola.  Antes de passar no exame, você está empenhado em resolver problemas de uma classe específica.  Em seguida, no exame, você encontra a mesma classe de problemas, mas com dados de entrada diferentes.  Não faz sentido enviar os mesmos dados que estavam durante o treinamento; caso contrário, a tarefa será reduzida a lembrar decisões e não procurar um modelo de solução.  É por isso que nos exames você se depara com tarefas que não estavam anteriormente no currículo.  Somente dessa maneira podemos verificar se o modelo aprendeu a solução geral ou não. <br><br>  O mesmo acontece com o aprendizado de máquina.  Você mostra alguns dados que representam uma determinada classe de tarefas que você deseja aprender a resolver.  No nosso caso, com um conjunto de dados do Fashion MNIST, queremos que a rede neural seja capaz de determinar a categoria à qual o elemento vestuário na imagem pertence.  É por isso que treinamos nosso modelo em 60.000 exemplos que contêm todas as categorias de itens de vestuário.  Após o treinamento, queremos verificar a eficácia do modelo, para alimentar os 10.000 itens restantes de roupas que o modelo ainda não “viu”.  Se decidíssemos não fazer isso, não testar com 10.000 exemplos, não poderíamos dizer com certeza se nosso modelo foi realmente treinado para determinar a classe do item de vestuário ou se ela se lembrava de todos os pares de valores de entrada + saída. <br><br>  É por isso que no aprendizado de máquina sempre temos um conjunto de dados para treinamento e um conjunto de dados para teste. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O TensorFlow</a> é uma coleção de dados de treinamento prontos para uso. <br><br>  Os conjuntos de dados geralmente são divididos em vários blocos, cada um dos quais é usado em um determinado estágio do treinamento e teste da eficácia da rede neural.  Nesta parte, falamos sobre: <br><br><ul><li>  <b>conjunto de dados de treinamento</b> : um conjunto de dados destinado ao treinamento de uma rede neural; </li><li>  <b>conjunto de dados de teste</b> : um conjunto de dados projetado para verificar a eficiência de uma rede neural; </li></ul><br>  Considere outro conjunto de dados, que eu chamo de conjunto de dados de validação.  Este conjunto de dados não é usado <b>para</b> treinar o modelo, apenas <b>durante o</b> treinamento.  Assim, depois que nosso modelo passou por vários ciclos de treinamento, alimentamos nosso conjunto de dados de teste e analisamos os resultados.  Por exemplo, se durante o treinamento o valor da função de perda diminuir e a precisão se deteriorar no conjunto de dados de teste, isso significa que nosso modelo simplesmente se lembra dos pares de valores de entrada e saída. <br><br>  O conjunto de dados de verificação é reutilizado no final do treinamento para medir a precisão final das previsões do modelo. <br><br>  Para obter mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">informações sobre conjuntos de dados de treinamento e teste, consulte o curso de falha do Google</a> . <br><br><h2>  Parte prática no CoLab </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link para o CoLab original em inglês</a> e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para o Russian CoLab</a> . <br><br><h2>  Classificação de imagens de itens de vestuário </h2><br>  Nesta parte da lição, construiremos e treinaremos uma rede neural para classificar imagens de elementos de vestuário, como vestidos, tênis, camisas, camisetas, etc. <br><br>  Tudo bem se alguns momentos não estiverem claros.  O objetivo deste curso é apresentar o TensorFlow e ao mesmo tempo explicar os algoritmos de seu trabalho e desenvolver um entendimento comum de projetos usando o TensorFlow, em vez de investigar os detalhes da implementação. <br><br>  Nesta parte, usamos o <code>tf.keras</code> , uma API de alto nível para criar e treinar modelos no TensorFlow. <br><br><h3>  Instalando e Importando Dependências </h3><br>  Vamos precisar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um conjunto de dados TensorFlow</a> , uma API que simplifique o carregamento e o acesso a conjuntos de dados fornecidos por vários serviços.  Também precisaremos de algumas bibliotecas auxiliares. <br><br><pre> <code class="python hljs">!pip install -U tensorflow_datasets</code> </pre><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-comment"><span class="hljs-comment">#  TensorFlow    TensorFlow import tensorflow as tf import tensorflow_datasets as tfds tf.logging.set_verbosity(tf.logging.ERROR) #   import math import numpy as np import matplotlib.pyplot as plt #    import tqdm import tqdm.auto tqdm.tqdm = tqdm.auto.tqdm print(tf.__version__) tf.enable_eager_execution()</span></span></code> </pre><br><h3>  Importar o conjunto de dados Fashion MNIST </h3><br>  Este exemplo usa o conjunto de dados Fashion MNIST, que contém 70.000 imagens de itens de vestuário em 10 categorias em escala de cinza.  As imagens contêm itens de vestuário em baixa resolução (28x28 pixels), conforme mostrado abaixo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18d/2c1/da3/18d2c1da3b5c7dbff14ea81077d9ed24.png" alt="imagem"><br><br>  O Fashion MNIST é usado como um substituto para o conjunto de dados clássico do MNIST - geralmente usado como "Olá, Mundo!"  em aprendizado de máquina e visão computacional.  O conjunto de dados MNIST contém imagens de números escritos à mão (0, 1, 2 etc.) no mesmo formato que os itens de vestuário em nosso exemplo. <br><br>  Em nosso exemplo, usamos o Fashion MNIST por causa da variedade e porque esta tarefa é mais interessante do ponto de vista da implementação do que resolver um problema típico no conjunto de dados MNIST.  Ambos os conjuntos de dados são pequenos o suficiente, portanto, são usados ​​para verificar a operacionalidade correta do algoritmo.  Ótimos conjuntos de dados para iniciar o aprendizado de máquina, teste e código de depuração. <br><br>  Usaremos 60.000 imagens para treinar a rede e 10.000 imagens para testar a precisão do treinamento e da classificação de imagens.  Você pode acessar diretamente o conjunto de dados Fashion MNIST através do TensorFlow usando a API: <br><br><pre> <code class="python hljs">dataset, metadata = tfds.load(<span class="hljs-string"><span class="hljs-string">'fashion_mnist'</span></span>, as_supervised=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, with_info=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) train_dataset, test_dataset = dataset[<span class="hljs-string"><span class="hljs-string">'train'</span></span>], dataset[<span class="hljs-string"><span class="hljs-string">'test'</span></span>]</code> </pre><br>  Ao carregar um conjunto de dados, obtemos metadados, um conjunto de dados de treinamento e um conjunto de dados de teste. <br><br><ul><li>  O modelo é treinado em um conjunto de dados de `train_dataset` </li><li>  O modelo é testado em um conjunto de dados de `test_dataset` </li></ul><br>  As imagens são matrizes bidimensionais de <code>2828</code> , onde os valores em cada célula podem estar no intervalo <code>[0, 255]</code> .  Etiquetas - uma matriz de números inteiros, onde cada valor está no intervalo <code>[0, 9]</code> .  Esses rótulos correspondem à classe de imagem de saída da seguinte maneira: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Etiqueta </th><th>  Class </th></tr><tr><td>  0 0 </td><td>  Camiseta / top </td></tr><tr><td>  1 </td><td>  Calções </td></tr><tr><td>  2 </td><td>  Camisola </td></tr><tr><td>  3 </td><td>  Vestido </td></tr><tr><td>  4 </td><td>  Manto </td></tr><tr><td>  5 </td><td>  Sandálias </td></tr><tr><td>  6 </td><td>  Camisa </td></tr><tr><td>  7 </td><td>  Sapatilha </td></tr><tr><td>  8 </td><td>  Bag </td></tr><tr><td>  9 </td><td>  Boot </td></tr></tbody></table></div><br><br>  Cada imagem pertence a uma tag.  Como os nomes das classes não estão contidos no conjunto de dados original, vamos salvá-los para uso futuro quando desenharmos as imagens: <br><br><pre> <code class="python hljs">class_names = [<span class="hljs-string"><span class="hljs-string">' / '</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]</code> </pre><br><h4>  Pesquisamos dados </h4><br>  Vamos estudar o formato e a estrutura dos dados apresentados no conjunto de treinamento antes de treinar o modelo.  O código a seguir mostrará que 60.000 imagens estão no conjunto de dados de treinamento e 10.000 imagens no conjunto de dados de teste: <br><br><pre> <code class="python hljs">num_train_examples = metadata.splits[<span class="hljs-string"><span class="hljs-string">'train'</span></span>].num_examples num_test_examples = metadata.splits[<span class="hljs-string"><span class="hljs-string">'test'</span></span>].num_examples print(<span class="hljs-string"><span class="hljs-string">'  : {}'</span></span>.format(num_train_examples)) print(<span class="hljs-string"><span class="hljs-string">'  : {}'</span></span>.format(num_test_examples))</code> </pre><br><h3>  Pré-processamento de dados </h3><br>  O valor de cada pixel na imagem está no intervalo <code>[0,255]</code> .  Para que o modelo funcione corretamente, esses valores devem ser normalizados - reduzidos a valores no intervalo <code>[0,1]</code> .  Portanto, um pouco menor, declaramos e implementamos a função de normalização e, em seguida, aplicamos a cada imagem nos conjuntos de dados de treinamento e teste. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images, labels)</span></span></span><span class="hljs-function">:</span></span> images = tf.cast(images, tf.float32) images /= <span class="hljs-number"><span class="hljs-number">255</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> images, labels <span class="hljs-comment"><span class="hljs-comment">#  map         #      train_dataset = train_dataset.map(normalize) test_dataset = test_dataset.map(normalize)</span></span></code> </pre><br><h4>  Estudamos os dados processados </h4><br>  Vamos desenhar uma imagem para dar uma olhada nela: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#          #   reshape() for image, label in test_dataset.take(1): break; image = image.numpy().reshape((28, 28)) #   plt.figure() plt.imshow(image, cmap=plt.cm.binary) plt.colorbar() plt.grid(False) plt.show()</span></span></code> </pre><br><img src="https://habrastorage.org/webt/ce/se/hw/cesehwjbca_ol0s1dcpxnaxyu2i.png"><br><br>  Exibimos as 25 primeiras imagens do conjunto de dados de treinamento e, em cada imagem, indicamos a qual classe pertence. <br><br>  Verifique se os dados estão no formato correto e se estamos prontos para começar a criar e treinar a rede. <br><br><pre> <code class="python hljs">plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>)) i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (image, label) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_dataset.take(<span class="hljs-number"><span class="hljs-number">25</span></span>): image = image.numpy().reshape((<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>)) plt.subplot(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,i+<span class="hljs-number"><span class="hljs-number">1</span></span>) plt.xticks([]) plt.yticks([]) plt.grid(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) plt.imshow(image, cmap=plt.cm.binary) plt.xlabel(class_names[label]) i += <span class="hljs-number"><span class="hljs-number">1</span></span> plt.show()</code> </pre><br><img src="https://habrastorage.org/webt/4h/_v/s7/4h_vs7mj97mmqknia5mpnzaqfis.png"><br><br><h4>  Construindo um modelo </h4><br>  Construir uma rede neural requer camadas de ajuste e, em seguida, montar um modelo com funções de otimização e perda. <br><br><h4>  Personalizar camadas </h4><br>  O elemento básico na construção de uma rede neural é a camada.  A camada extrai a visualização dos dados que entraram em sua entrada.  O resultado do trabalho de várias camadas conectadas, temos uma visão que faz sentido para resolver o problema. <br><br>  Na maioria das vezes, aprendendo profundamente, você criará links entre camadas simples.  A maioria das camadas, por exemplo, como tf.keras.layers.Dense, possui um conjunto de parâmetros que podem ser "ajustados" durante o processo de aprendizado. <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Flatten(input_shape=(<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, activation=tf.nn.relu), tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=tf.nn.softmax) ])</code> </pre><br>  A rede consiste em três camadas: <br><br><ul><li>  <b>entrada</b> <code>tf.keras.layers.Flatten</code> - essa camada converte imagens de 28 x 28 pixels em um array 1D com o tamanho 784 (28 * 28).  Nesta camada, não temos parâmetros para treinamento, pois essa camada lida apenas com a conversão de dados de entrada. </li><li>  <b>camada oculta</b> <code>tf.keras.layers.Dense</code> - uma camada firmemente conectada de 128 neurônios.  Cada neurônio (nó) pega todos os 784 valores da camada anterior como entrada, altera os valores de entrada de acordo com os pesos e deslocamentos internos durante o treinamento e retorna um único valor para a próxima camada. </li><li>  <b>camada de saída</b> <code>ts.keras.layers.Dense</code> - <code>ts.keras.layers.Dense</code> - <code>softmax</code> consiste em 10 neurônios, cada um dos quais representa uma classe específica de elemento de vestuário.  Como na camada anterior, cada neurônio recebe os valores de entrada de todos os 128 neurônios da camada anterior.  Os pesos e deslocamentos de cada neurônio nesta camada mudam durante o treinamento, de modo que o valor resultante esteja no intervalo <code>[0,1]</code> e represente a probabilidade de a imagem pertencer a essa classe.  A soma de todos os valores de saída de 10 neurônios é 1. </li></ul><br><h4>  Compilar o modelo </h4><br>  Antes de começarmos a treinar o modelo, vale mais algumas configurações.  Essas configurações são feitas durante a montagem do modelo quando o método de compilação é chamado: <br><br><ul><li>  <b>função de perda</b> - um algoritmo para medir a distância entre o valor desejado e o previsto. </li><li>  <b>função de otimização</b> - um algoritmo para “ajustar” os parâmetros internos (pesos e compensações) do modelo para minimizar a função de perda; </li><li>  <b>métricas</b> - usadas para monitorar o processo de treinamento e testes.  O exemplo abaixo usa métricas como <code></code> , a porcentagem de imagens que foram classificadas corretamente. </li></ul><br><pre> <code class="python hljs">model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'adam'</span></span>, loss=<span class="hljs-string"><span class="hljs-string">'sparse_categorical_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>])</code> </pre><br><h3>  Treinamos o modelo </h3><br>  Primeiramente, determinamos a sequência de ações durante o treinamento em um conjunto de dados de treinamento: <br><br><ol><li>  Repita o conjunto de dados de entrada um número infinito de vezes usando o método <code>dataset.repeat()</code> (o parâmetro <code>epochs</code> , descrito abaixo, determina o número de todas as iterações de treinamento a serem executadas) </li><li>  O método <code>dataset.shuffle(60000)</code> todas as imagens para que o treinamento do nosso modelo não seja afetado pela ordem de entrada dos dados de entrada. </li><li>  O método <code>dataset.batch(32)</code> informa ao <code>model.fit</code> treinamento <code>model.fit</code> usar blocos de 32 imagens e rótulos sempre que as variáveis ​​internas do modelo são atualizadas. </li></ol><br>  O treinamento ocorre chamando o método <code>model.fit</code> : <br><br><ul><li>  Envia <code>train_dataset</code> para a entrada do modelo. </li><li>  O modelo aprende a combinar a imagem de entrada com a etiqueta. </li><li>  O parâmetro <code>epochs=5</code> limita o número de sessões de treinamento a 5 iterações completas de treinamento em um conjunto de dados, o que nos dá treinamento em 5 * 60.000 = 300.000 exemplos. </li></ul><br>  (você pode ignorar o parâmetro <code>steps_per_epoch</code> , em breve esse parâmetro será excluído do método). <br><br><pre> <code class="python hljs">BATCH_SIZE = <span class="hljs-number"><span class="hljs-number">32</span></span> train_dataset = train_dataset.repeat().shuffle(num_train_examples).batch(BATCH_SIZE) test_dataset = test_dataset.batch(BATCH_SIZE)</code> </pre><br><pre> <code class="python hljs">model.fit(train_dataset, epochs=<span class="hljs-number"><span class="hljs-number">5</span></span>, steps_per_epoch=math.ceil(num_train_examples/BATCH_SIZE))</code> </pre><br>  E aqui está a conclusão: <br><br> <code>Epoch 1/5 <br> 1875/1875 [==============================] - 26s 14ms/step - loss: 0.4921 - acc: 0.8267 <br> Epoch 2/5 <br> 1875/1875 [==============================] - 20s 11ms/step - loss: 0.3652 - acc: 0.8686 <br> Epoch 3/5 <br> 1875/1875 [==============================] - 20s 11ms/step - loss: 0.3341 - acc: 0.8782 <br> Epoch 4/5 <br> 1875/1875 [==============================] - 19s 10ms/step - loss: 0.3111 - acc: 0.8858 <br> Epoch 5/5 <br> 1875/1875 [==============================] - 16s 8ms/step - loss: 0.2911 - acc: 0.8922 <br></code> <br>  Durante o treinamento do modelo, o valor da função de perda e a métrica de precisão são exibidos para cada iteração de treinamento.  Este modelo atinge uma precisão de cerca de 0,88 (88%) nos dados de treinamento. <br><br><h4>  Verifique a precisão </h4><br>  Vamos verificar a precisão que o modelo produz nos dados de teste.  Usaremos todos os exemplos que temos no conjunto de dados de teste para verificar a precisão. <br><br><pre> <code class="python hljs">test_loss, test_accuracy = model.evaluate(test_dataset, steps=math.ceil(num_test_examples/BATCH_SIZE)) print(<span class="hljs-string"><span class="hljs-string">"    : "</span></span>, test_accuracy)</code> </pre><br>  Conclusão: <br><br> <code>313/313 [==============================] - 1s 5ms/step - loss: 0.3440 - acc: 0.8793 <br>     : 0.8793 <br></code> <br><br>  Como você pode ver, a precisão no conjunto de dados de teste acabou sendo menor que a precisão no conjunto de dados de treinamento.  Isso é normal, pois o modelo foi treinado em dados train_dataset.  Quando um modelo descobre imagens que nunca viu antes (do conjunto de dados train_dataset), é óbvio que a eficiência da classificação diminuirá. <br><br><h3>  Preveja e explore </h3><br>  Podemos usar o modelo treinado para obter previsões para algumas imagens. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test_images, test_labels <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_dataset.take(<span class="hljs-number"><span class="hljs-number">1</span></span>): test_images = test_images.numpy() test_labels = test_labels.numpy() predictions = model.predict(test_images)</code> </pre><br><pre> <code class="python hljs">predictions.shape</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão: </font><font style="vertical-align: inherit;">No exemplo acima, o modelo previu rótulos para cada imagem de entrada de teste. </font><font style="vertical-align: inherit;">Vejamos a primeira previsão:</font></font><br><br> <code>(32, 10) <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="python hljs">predictions[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusão: </font></font><br><br><pre> <code class="python hljs">array([<span class="hljs-number"><span class="hljs-number">3.1365351e-05</span></span>, <span class="hljs-number"><span class="hljs-number">9.0029374e-08</span></span>, <span class="hljs-number"><span class="hljs-number">5.0016739e-03</span></span>, <span class="hljs-number"><span class="hljs-number">6.3597057e-05</span></span>, <span class="hljs-number"><span class="hljs-number">6.8342477e-02</span></span>, <span class="hljs-number"><span class="hljs-number">1.0856857e-08</span></span>, <span class="hljs-number"><span class="hljs-number">9.2655218e-01</span></span>, <span class="hljs-number"><span class="hljs-number">1.8982398e-09</span></span>, <span class="hljs-number"><span class="hljs-number">8.4999456e-06</span></span>, <span class="hljs-number"><span class="hljs-number">1.0296091e-09</span></span>], dtype=float32)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que as previsões do modelo são uma matriz de 10 valores. </font><font style="vertical-align: inherit;">Esses valores descrevem a “confiança” do modelo de que a imagem de entrada pertence a uma determinada classe (item de vestuário). </font><font style="vertical-align: inherit;">Podemos ver o valor máximo da seguinte maneira:</font></font><br><br><pre> <code class="python hljs">np.argmax(predictions[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusão: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso significa que o modelo estava mais confiante de que esta imagem pertence à classe rotulada 6 (class_names [6]). </font><font style="vertical-align: inherit;">Podemos verificar e garantir que o resultado seja verdadeiro e correto:</font></font><br><br><pre> <code class="python hljs">test_labels[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos exibir todas as imagens de entrada e as previsões de modelo correspondentes para 10 classes: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, predictions_array, true_labels, images)</span></span></span><span class="hljs-function">:</span></span> predictions_array, true_label, img = predictions_array[i], true_label[i], images[i] plt.grid(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) plt.xticks([]) plt.yticks([]) plt.imshow(img[...,<span class="hljs-number"><span class="hljs-number">0</span></span>], cmap=plt.cm.binary) predicted_label = np.argmax(predictions_array) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> predicted_label == true_label: color = <span class="hljs-string"><span class="hljs-string">'blue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: color = <span class="hljs-string"><span class="hljs-string">'red'</span></span> plt.xlabel(<span class="hljs-string"><span class="hljs-string">"{} {:2.0f}% ({})"</span></span>.format(class_names[predicted_label], <span class="hljs-number"><span class="hljs-number">100</span></span> * np.max(predictions_array), class_names[true_label]), color=color) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot_value_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, predictions_array, true_label)</span></span></span><span class="hljs-function">:</span></span> predictions_array, true_label = predictions_array[i], true_label[i] plt.grid(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) plt.xticks([]) plt.yticks([]) thisplot = plt.bar(range(<span class="hljs-number"><span class="hljs-number">10</span></span>), predictions_array, color=<span class="hljs-string"><span class="hljs-string">"#777777"</span></span>) plt.ylim([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) predicted_label = np.argmax(predictions_array) thisplot[predicted_label].set_color(<span class="hljs-string"><span class="hljs-string">'red'</span></span>) thisplot[true_label].set_color(<span class="hljs-string"><span class="hljs-string">'blue'</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos dar uma olhada na 0ª imagem, o resultado da previsão do modelo e a matriz de previsões. </font></font><br><br><pre> <code class="python hljs">i = <span class="hljs-number"><span class="hljs-number">0</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)) plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) plot_image(i, predictions, test_labels, test_images) plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) plot_value_array(i, predictions, test_labels)</code> </pre><br><img src="https://habrastorage.org/webt/fc/7i/ef/fc7iefucuvtopx4_avluy-rq1ei.png"><br><br><pre> <code class="python hljs">i = <span class="hljs-number"><span class="hljs-number">12</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)) plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) plot_image(i, predictions, test_labels, test_images) plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) plot_value_array(i, predictions, test_labels)</code> </pre><br><img src="https://habrastorage.org/webt/n0/2y/tj/n02ytjjdkeubvkqvjdusbkwoemy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos agora exibir algumas imagens com suas respectivas previsões. </font><font style="vertical-align: inherit;">As previsões corretas são azuis, as previsões incorretas são vermelhas. </font><font style="vertical-align: inherit;">O valor abaixo da imagem reflete a porcentagem de confiança de que a imagem de entrada corresponde a esta classe. </font><font style="vertical-align: inherit;">Observe que o resultado pode estar incorreto mesmo se o valor de "confiança" for alto.</font></font><br><br><pre> <code class="python hljs">num_rows = <span class="hljs-number"><span class="hljs-number">5</span></span> num_cols = <span class="hljs-number"><span class="hljs-number">3</span></span> num_images = num_rows * num_cols plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>*num_cols, <span class="hljs-number"><span class="hljs-number">2</span></span>*num_rows)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(num_images): plt.subplot(num_rows, <span class="hljs-number"><span class="hljs-number">2</span></span>*num_cols, <span class="hljs-number"><span class="hljs-number">2</span></span>*i + <span class="hljs-number"><span class="hljs-number">1</span></span>) plot_image(i, predictions, test_labels, test_images) plt.subplot(num_rows, <span class="hljs-number"><span class="hljs-number">2</span></span>*num_cols, <span class="hljs-number"><span class="hljs-number">2</span></span>*i + <span class="hljs-number"><span class="hljs-number">2</span></span>) plot_value_array(i, predictions, test_labels)</code> </pre><br><img src="https://habrastorage.org/webt/m1/11/je/m111jevw7ptxblu2ccmlwmtonva.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use o modelo treinado para prever o rótulo para uma única imagem: </font></font><br><br><pre> <code class="python hljs">img = test_images[<span class="hljs-number"><span class="hljs-number">0</span></span>] print(img.shape)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusão: </font></font><br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os modelos são </font></font><code>tf.keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otimizados para previsões por blocos (coleções). </font><font style="vertical-align: inherit;">Portanto, apesar de usarmos um único elemento, você precisa adicioná-lo à lista:</font></font><br><br><pre> <code class="python hljs">img = np.array([img]) print(img.shape)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão: </font></font><br><br> <code>(1, 28, 28, 1)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos prever o resultado:</font></font><br><br><pre> <code class="python hljs">predictions_single = model.predict(img) print(predictions_single)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusão: </font></font><br><br><pre> <code class="python hljs">[[<span class="hljs-number"><span class="hljs-number">3.1365438e-05</span></span> <span class="hljs-number"><span class="hljs-number">9.0029722e-08</span></span> <span class="hljs-number"><span class="hljs-number">5.0016833e-03</span></span> <span class="hljs-number"><span class="hljs-number">6.3597123e-05</span></span> <span class="hljs-number"><span class="hljs-number">6.8342514e-02</span></span> <span class="hljs-number"><span class="hljs-number">1.0856857e-08</span></span> <span class="hljs-number"><span class="hljs-number">9.2655218e-01</span></span> <span class="hljs-number"><span class="hljs-number">1.8982469e-09</span></span> <span class="hljs-number"><span class="hljs-number">8.4999692e-06</span></span> <span class="hljs-number"><span class="hljs-number">1.0296091e-09</span></span>]]</code> </pre><br><pre> <code class="python hljs">plot_value_array(<span class="hljs-number"><span class="hljs-number">0</span></span>, predictions_single, test_labels) _ = plt.xticks(range(<span class="hljs-number"><span class="hljs-number">10</span></span>), class_names, rotation=<span class="hljs-number"><span class="hljs-number">45</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/eo/vw/sl/eovwslxcn_ldtj2abz870ninw4g.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O método model.predict retorna uma lista de listas (uma matriz de matrizes), cada uma para uma imagem de um bloco de entrada. </font><font style="vertical-align: inherit;">Obtemos o único resultado para nossa imagem de entrada única:</font></font><br><br><pre> <code class="python hljs">np.argmax(predictions_single[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusão: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como anteriormente, o modelo previu a etiqueta 6 (camisa). </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercícios </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimente modelos diferentes e veja como a precisão mudará. </font><font style="vertical-align: inherit;">Em particular, tente alterar as seguintes configurações:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> defina o parâmetro epochs como 1; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> altere o número de neurônios na camada oculta, por exemplo, de um valor baixo de 10 a 512 e veja como a precisão do modelo de previsão mudará; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adicione camadas adicionais entre a camada achatada (camada de suavização) e a camada densa final; experimente o número de neurônios nessa camada; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não normalize os valores de pixel e veja o que acontece. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de ativar a GPU para que todos os cálculos sejam mais rápidos ( </font></font><code>Runtime -&gt; Change runtime type -&gt; Hardware accelertor -&gt; GPU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Além disso, se você encontrar problemas durante a operação, tente redefinir as configurações do ambiente global:</font></font><br><br><ul><li> <code>Edit -&gt; Clear all outputs</code> </li> <li> <code>Runtime -&gt; Reset all runtimes</code> </li> </ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graus Celsius VS MNIST </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Nesta fase, já encontramos dois tipos de redes neurais. Nossa primeira rede neural aprendeu a converter graus Celsius em graus Frenheit, retornando um valor único que pode estar em uma ampla gama de valores numéricos. </font></font><br><br><img src="https://habrastorage.org/webt/o8/ag/_t/o8ag_trkedahoa0ftg3pstkirt4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa segunda rede neural retorna 10 valores de probabilidade que refletem a confiança da rede de que a imagem de entrada corresponde a uma determinada classe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redes neurais podem ser usadas para resolver vários problemas. </font></font><br><br><img src="https://habrastorage.org/webt/no/0v/jo/no0vjoulnrva_-bky0uauc3tesi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira classe de problemas que resolvemos com a previsão de um único valor é chamada de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regressão</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Converter graus Celsius em graus Fahrenheit é um exemplo da tarefa desta classe. Outro exemplo dessa classe de tarefas pode ser a tarefa de determinar o valor de uma casa pelo número de cômodos, área total, localização e outras características. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda classe de tarefas que examinamos nesta lição, classificando imagens em categorias disponíveis, é chamada de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classificação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . De acordo com os dados de entrada, o modelo retornará a distribuição de probabilidade (a “confiança” do modelo de que o valor de entrada pertence a essa classe). Nesta lição, desenvolvemos uma rede neural que classificou os elementos de vestuário em 10 categorias e, na próxima lição, aprenderemos a determinar quem é mostrado na fotografia - um cachorro ou um gato, essa tarefa também pertence à tarefa de classificação.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos resumir e observar a diferença entre essas duas classes de problemas - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regressão</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classificação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/_c/wj/qu/_cwjquy9ivk-s3zma34qamyakoq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parabéns, você estudou dois tipos de redes neurais! Prepare-se para a próxima palestra, onde estudaremos um novo tipo de redes neurais - redes neurais convolucionais (CNN).</font></font><br><br><h3>  Sumário </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta lição, treinamos a rede neural para classificar imagens com elementos de vestuário. Para fazer isso, usamos o conjunto de dados Fashion MNIST, que contém 70.000 imagens de itens de vestuário. 60.000 dos quais costumávamos treinar a rede neural e os 10.000 restantes para testar a eficácia de seu trabalho. Para enviar essas imagens para a entrada de nossa rede neural, precisávamos convertê-las (suavizadas) de um formato 2D de 28x28 para um formato 1D de 784 elementos. Nossa rede consistia em uma camada totalmente conectada de 128 neurônios e uma camada de saída de 10 neurônios, correspondendo ao número de etiquetas (classes, categorias de itens de vestuário). Esses 10 valores de saída representaram a distribuição de probabilidade para cada classe. </font><i><font style="vertical-align: inherit;">Função de</font></i><font style="vertical-align: inherit;"> ativação </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Softmax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contou a distribuição de probabilidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também aprendemos sobre as diferenças entre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regressão</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classificação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regressão</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : um modelo que retorna um único valor, como o valor de uma casa.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : um modelo que retorna a distribuição de probabilidade entre várias categorias. </font><font style="vertical-align: inherit;">Por exemplo, em nossa tarefa com o Fashion MNIST, os valores de saída eram 10 valores de probabilidade, cada um dos quais associado a uma classe específica (categoria de item de vestuário). </font><font style="vertical-align: inherit;">Lembro que usamos a função de ativação </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">softmax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apenas para obter uma distribuição de probabilidade na última camada.</font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versão em vídeo do artigo</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O vídeo sai alguns dias após a publicação e é adicionado ao artigo. </font></font><br></div></div><br>  ... e call to action padrão - inscreva-se, coloque um plus e compartilhe :) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube</font></font></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Telegram</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VKontakte</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454034/">https://habr.com/ru/post/pt454034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454018/index.html">iOS Digest No. 6 (17 a 30 de maio)</a></li>
<li><a href="../pt454024/index.html">Controlador de carga MPPT em STM32F334C8T6</a></li>
<li><a href="../pt454028/index.html">Esboços com PHP Rússia 2019: código limpo, magia negra</a></li>
<li><a href="../pt454030/index.html">Odigest: interessante para designers da semana</a></li>
<li><a href="../pt454032/index.html">Roteador e dados passando a arquitetura Clean Swift</a></li>
<li><a href="../pt454036/index.html">6 maneiras de ir para o inferno de soluções prontas e diminuir um milhão ou dois</a></li>
<li><a href="../pt454038/index.html">Ilya Zverev: Ao longo dos anos, o OpenStreetMap ganhou uma infraestrutura tão séria que você pode desenhar um mapa sem sair de casa</a></li>
<li><a href="../pt454042/index.html">Pague o que quiser: como esse modelo se mostrou na música e quem tentou ganhar dinheiro assim</a></li>
<li><a href="../pt454044/index.html">Criatividade no iPad e iPhone</a></li>
<li><a href="../pt454046/index.html">Motivação Faça você mesmo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>