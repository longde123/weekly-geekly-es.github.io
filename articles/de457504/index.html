<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóΩ üèûÔ∏è ‚ñ´Ô∏è Warum sollten Sie Ihr React Data Grid im Jahr 2019 schreiben? üêã üò¥ ü•ù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich bin an der Entwicklung eines ECM-Systems beteiligt. Und in einer kurzen Artikelserie m√∂chte ich unsere Erfahrungen und die Geschichte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum sollten Sie Ihr React Data Grid im Jahr 2019 schreiben?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457504/"><p>  Hallo Habr!  Ich bin an der Entwicklung eines ECM-Systems beteiligt.  Und in einer kurzen Artikelserie m√∂chte ich unsere Erfahrungen und die Geschichte der Entwicklung meines React Data Grid (im Folgenden einfach ein Grid) teilen, n√§mlich: </p><br><ul><li>  warum wir die fertigen Komponenten aufgegeben haben </li><li>  Auf welche Probleme und Aufgaben sind wir bei der Entwicklung unseres Netzes gesto√üen? </li><li>  Welchen Gewinn bringt die Entwicklung Ihres Netzes? </li></ul><br><h3 id="predystoriya">  Hintergrund </h3><br><p>  Unser System verf√ºgt √ºber eine Webanwendung, in der Benutzer mit Dokumentenlisten, Suchergebnissen und Verzeichnissen arbeiten.  Dar√ºber hinaus k√∂nnen die Listen entweder klein (10 Mitarbeiter) oder sehr gro√ü (50.000 Auftragnehmer) sein.  Um diese Listen anzuzeigen, haben wir ein eigenes Raster entwickelt: </p><br><p><img src="https://habrastorage.org/webt/1m/v3/py/1mv3pyhnf7emxc6xs2h8lcv8dis.png" alt="Bild"></p><a name="habracut"></a><br><p>  Als wir mit der Entwicklung einer Webanwendung begannen, wollten wir eine vorgefertigte Bibliothek f√ºr die Anzeige von Rastern finden, die alles kann, was wir brauchen: Datens√§tze sortieren und gruppieren, Spalten ziehen und ablegen, mit Mehrfachauswahlen arbeiten, Spaltensummen abschnittsweise filtern und berechnen Laden Sie Daten vom Server herunter und zeigen Sie Zehntausende von Datens√§tzen an. </p><br><p>  Ich werde die letzte Anforderung "Zehntausende von Datens√§tzen anzeigen" erl√§utern.  In Grids wird diese Anforderung auf verschiedene Arten implementiert: Paging, Infinity-Scrolling, virtuelles Scrollen. </p><br><p>  Die Paging- und Infinity-Scrolling-Ans√§tze sind auf Websites √ºblich. Sie werden t√§glich verwendet.  Beispiel: Paging in Google: </p><br><p><img src="https://habrastorage.org/webt/v5/5q/vz/v55qvz8wjlhqmp-jfzievdnjvxe.png" alt="Bild"></p><br><p>  Oder Unendlichkeits-Scrollen in demselben Google f√ºr Bilder, wobei der n√§chste Teil der Bilder geladen wird, wenn Sie durch den ersten Teil bis zum Ende scrollen: </p><br><p><img src="https://habrastorage.org/webt/bs/r7/qk/bsr7qkhgokj6ezk3qlagzkkgdaq.png" alt="Bild"></p><br><p>  Virtuelles Scrollen (im Folgenden als virtuelles Scrollen bezeichnet) wird im Web jedoch selten verwendet. Der Hauptunterschied zum unendlichen Scrollen besteht in der M√∂glichkeit, √ºberall schnell durch sehr gro√üe Listen zu scrollen.  In diesem Fall werden nur die f√ºr den Benutzer sichtbaren Daten heruntergeladen und angezeigt. </p><br><p><img src="https://habrastorage.org/webt/wf/j8/ct/wfj8ctaao00cbfi1txsytvpqwae.png" alt="Bild"></p><br><p>  F√ºr unsere Webanwendung wollte ich das virtuelle Scrollen verwenden.  Ich bin damit einverstanden, dass das Scrollen zu einer beliebigen Stelle in der Liste von 10.000 Eintr√§gen ein ziemlich erfundener Fall ist.  Das zuf√§llige Scrollen innerhalb von 500‚Äì1000 Datens√§tzen ist jedoch ein Live-Fall. </p><br><p>  Wenn sie das virtuelle Scrollen implementieren, implementieren sie h√§ufig die Software-API zum Verwalten dieses Bildlaufs.  Dies ist ein sehr wichtiges Merkmal.  Software-Scrolling wird beispielsweise verwendet, um den ausgew√§hlten Datensatz beim √ñffnen des Verzeichnisses in der Mitte des Bildschirms zu positionieren: </p><br><p><img src="https://habrastorage.org/webt/ny/up/na/nyupnajuldvlpnb294u203xvy-w.png" alt="Bild"></p><br><p>  Zur√ºck zu den Anforderungen.  Was brauchten wir noch: </p><br><ul><li>  Virtual Scrolling Management API </li><li>  Anpassung des Erscheinungsbilds des Rasters (Zeilen, Spalten, Kontextmen√º), damit das Raster in unserer Anwendung nicht fremd aussieht </li><li>  Unterst√ºtzung f√ºr die von uns verwendeten Technologien: React, Redux und Flexbox </li><li>  Dass das Gitter in ie11 funktioniert hat </li></ul><br><p>  Im Allgemeinen gab es viele Anforderungen. </p><br><h3 id="popytka-pervaya-2016-god-devextreme-javascript-data-grid">  Der erste Versuch (2016).  DevExtreme JavaScript-Datenraster </h3><br><p>  Wir haben uns nicht lange mit vorhandenen Bibliotheken befasst und sind auf das DevExtreme JavaScript Data Grid gesto√üen.  Aufgrund der funktionalen Anforderungen deckte dieses Raster alle unsere Anforderungen ab und hatte ein sehr ansehnliches Erscheinungsbild.  Es war jedoch nicht f√ºr technologische Anforderungen geeignet (nicht reagieren, nicht reduzieren, nicht flexboxen).  Zu diesem Zeitpunkt hatte DevExtreme kein Reaktionsraster. </p><br><p>  Nun, lassen Sie es nicht reagieren, wir haben beschlossen, weil das Gitter sch√∂n und funktional ist, werden wir es verwenden.  Und sie haben die Bibliothek zu ihrem Projekt hinzugef√ºgt.  Es stellte sich heraus, dass wir 3 MB Skripte hinzugef√ºgt haben. </p><br><p>  F√ºr ein paar Wochen haben wir das Raster in unsere Webanwendung integriert und die Grundfunktionen erweitert: </p><br><ul><li>  Wickelte ein Gitter ein, um sich mit React und Redux anzufreunden </li><li>  Erh√∂htes virtuelles Scrollen und teilweises Laden von Daten von unserem Webserver </li><li>  Sortierung und Auswahl implementiert </li></ul><br><p>  Beim Verschrauben des Gitters wurden zwei schwerwiegende Probleme und eine ganze Reihe weniger schwerwiegender Probleme deutlich. </p><br><h3 id="pervaya-sereznaya-problema">  Erstes ernstes Problem </h3><br><p>  DevExtreme JavaScript Data Grid mit Redux sehr schwierig zu machen.  Wir haben es geschafft, die Spalteneinstellungen zu steuern und Datens√§tze durch Redux hervorzuheben, aber teilweise geladene Daten in Redux zu speichern und CRUD-Operationen mit ihnen durch Redux durchzuf√ºhren - dies ist unrealistisch.  Ich musste eine Kr√ºcke bauen, die unter Umgehung von Redux die Gitterdaten manipulierte.  Die Kr√ºcke erwies sich als komplex und zerbrechlich.  Dies war die erste Alarmglocke, bei der das Gitter nicht zu uns passte, aber wir schraubten weiter daran. </p><br><h3 id="vtoraya-sereznaya-problema">  Zweites ernstes Problem </h3><br><p>  Es gibt keine virtuelle Bildlaufverwaltungs-API.  Wir konnten die Softwaresteuerung des Bildlaufs nicht ablehnen. Wir mussten die DevExtreme-Quellen wiederholen und die interne API f√ºr die Bildlaufsteuerung finden.  Nat√ºrlich hatte diese API eine Reihe von Einschr√§nkungen, da sie f√ºr den internen Gebrauch konzipiert wurde.  Infolgedessen ist es uns gelungen, die interne API mehr oder weniger f√ºr unsere F√§lle geeignet zu machen, aber auch hier, um Redux und wieder ein paar Kr√ºcken zu umgehen. </p><br><h3 id="menee-sereznye-problemy">  Weniger ernsthafte Probleme </h3><br><p>  Es traten immer weniger schwerwiegende Probleme auf, da die standardm√§√üige DevExtreme JavaScript Data Grid-Funktionalit√§t f√ºr uns nicht vollst√§ndig geeignet war und wir versuchten, sie zu korrigieren: </p><br><ol><li>  Das Strecken des DevExtreme-Rasters in der H√∂he funktioniert nicht.  Ich musste einen Hack schreiben, um DevExtreme beizubringen, wie das geht (vielleicht gibt es in den letzten Versionen kein Problem damit). </li><li>  Wenn der Fokus nicht im Raster liegt, ist es unm√∂glich, die Auswahl der Linien √ºber die Tastatur zu steuern (und wir brauchten sie).  Ich musste meine Tastatursteuerung schreiben. </li><li>  Beim √Ñndern der Zusammensetzung der Spalten und der Daten hatten wir das Problem, dass Daten blinken (bei aktiviertem virtuellen Bildlauf). </li><li>  Das Problem einer gro√üen Anzahl von Anfragen bei der ersten Anzeige des Rasters.  Dies machte sich besonders bemerkbar, als wir das Scrollen durch die interne API kontrollierten. </li><li>  Es ist schwierig, einige Teile des UI-Rasters anzupassen.  Beispielsweise bestand √ºber der ausgew√§hlten Gitterlinie der Wunsch, Linienverwaltungsaktionen zu zeichnen (Linie l√∂schen, kopieren, Karte √∂ffnen).  Aber wie man dies in DevExtreme einschraubt, war nicht klar, und selbst mit React: <br><img src="https://habrastorage.org/webt/yo/zv/9b/yozv9boc174n-rxmbdsxoham4g8.png" alt="Bild"></li><li>  Es ist schwierig, die Sortierung zu katalysieren (wir wollten nach Daten sortieren, die nicht im Raster angezeigt und nicht in Spalten abgebildet werden). </li><li>  Kr√ºcken sind erforderlich, um die Reaktionskomponente in die Gitterzellen einzuschrauben (schlie√ülich befindet sich das Gitter nicht in der Reaktion). </li><li>  Keine Eingabe von DevExtreme-Code (Flow / Typoskript). </li><li>  Geschwindigkeitsproblem beim langen virtuellen Scrollen. </li><li>  Geschwindigkeitsproblem beim Strecken / Neuanordnen von Spalten (nach l√§ngerem virtuellem Scrollen). </li><li>  Die Gr√∂√üe der Grid-Skripte betr√§gt 3 MB. </li></ol><br><p>  Das DevExtreme-Funktionsraster enthielt zwar alles, was wir brauchten, aber ich wollte fast alle Standardfunktionen neu schreiben.  W√§hrend seiner Verwendung wurden Hunderte von Codezeilen hinzugef√ºgt, die schwer zu verstehen waren und versuchten, die Probleme der Interaktion mit Redux zu l√∂sen und zu reagieren. Es war schwierig, ein nicht reagierendes Gitter in einer Reaktionsanwendung zu verwenden. </p><br><h3 id="otkaz-ot-devextreme-poisk-alternativ">  Ablehnung von DevExtreme.  Suche nach Alternativen </h3><br><p>  Nach einiger Zeit mit DevExtreme wurde beschlossen, es aufzugeben.  Werfen Sie alle Hacks, komplexen Code sowie 3 MB DevExtreme-Skripte weg.  Und finde oder schreibe ein neues Gitter. </p><br><p>  Dieses Mal konzentrieren wir uns mehr auf das Studium bestehender Netze.  MS Fabric DetailsList, ReactVirtualized Grid, DevExtreme React Grid, Telerik Grid und KendoUI Grid wurden untersucht. <br>  Die Anforderungen blieben gleich, aber sie nahmen bereits in einer Liste Gestalt an, die wir verstanden haben. </p><br><p>  Technologische Anforderungen: </p><br><ul><li>  reagieren </li><li>  Redux </li><li>  Flexbox </li></ul><br><p>  Funktionsanforderungen: </p><br><ul><li>  Virtuelles Scrollen (mit der F√§higkeit, Zehntausende von Datens√§tzen anzuzeigen) </li><li>  Scrolling Management API </li><li>  Speichern von Daten und Rastereinstellungen in Redux </li><li>  Laden von Daten von einem Webserver </li><li>  Spaltenverwaltung (Dehnung / Neuanordnung / Sichtbarkeitskontrolle) </li><li>  Spaltensortierung + Filterung </li><li>  Mehrfachauswahl </li><li>  Like-Suche mit Hintergrundbeleuchtung </li><li>  Horizontales Scrollen </li><li>  Tastatur </li><li>  Kontextmen√º (in einer Zeile, in einem leeren Bereich, in Spalten) </li><li>  Unterst√ºtzung dh11, Rand, Chrom, ff, Safari </li></ul><br><p>  Zu diesem Zeitpunkt war die erste Version von DevExtreme React Grid bereits erschienen, wir haben sie jedoch aus folgenden Gr√ºnden sofort gel√∂scht: </p><br><ul><li>  Virtuelles Scrollen wird in ie11 nicht unterst√ºtzt </li><li>  Das virtuelle Scrollen funktioniert nicht in Verbindung mit dem Batch-Herunterladen von Daten vom Server (obwohl es einige Problemumgehungen zu geben scheint). </li><li>  Und vor allem wollte ich nicht auf denselben Rechen treten, wenn ich die H√§lfte der Standardfunktionalit√§t eines Drittanbieter-Grids neu schreiben wollte. </li></ul><br><p>  Die Analyse bestehender L√∂sungen ergab, dass es keine ‚ÄûSilberkugel‚Äú gibt.  Ein Raster, das alle unsere Anforderungen abdeckt, existiert nicht.  Es wurde beschlossen, ein eigenes Raster zu schreiben, das wir in Bezug auf die Funktionalit√§t in die von uns ben√∂tigte Richtung entwickeln und mit den von unserem Produkt ben√∂tigten Technologien befreundet sein werden. </p><br><h3 id="razrabotka-svoego-react-data-grid">  Entwickeln Ihres React Data Grid </h3><br><p>  Die Entwicklung des Rasters begann mit Prototypen, bei denen die schwierigsten Themen f√ºr uns getestet wurden: </p><br><ul><li>  virtuelles Scrollen </li><li>  Speicherung aller Grid-Daten in Redux </li></ul><br><h3 id="virtual-scrolling">  Virtuelles Scrollen </h3><br><p>  Am schwierigsten stellte sich das virtuelle Scrollen heraus.  Zum gr√∂√üten Teil wird es auf drei Arten hergestellt: </p><br><p>  <strong>1. Seitenvirtualisierung</strong> <br>  Daten werden in Teilen - Seiten gezeichnet.  Beim Scrollen werden sichtbare Seiten hinzugef√ºgt, unsichtbare gel√∂scht.  Die Seite besteht aus 20-60 Zeilen (normalerweise ist die Gr√∂√üe anpassbar).  Hier gingen die Produkte hin: DevExtreme JavaScript Data Grid, MS Fabric DetailsList. </p><br><p><img src="https://habrastorage.org/webt/h7/tf/5l/h7tf5lynlgmje6wunlcowkeabqa.png" alt="Bild"></p><br><p>  <strong>2. Zeile f√ºr Zeile Virtualisierung</strong> <br>  Es werden nur sichtbare Linien gezeichnet.  Sobald eine Zeile den Bildschirm verl√§sst, wird sie sofort gel√∂scht.  Die Produkte gingen diesen Weg: ReactVirtualized Grid, DevExtreme React Grid, Telerik Grid. </p><br><p><img src="https://habrastorage.org/webt/9j/zs/bh/9jzsbhqw0_up5gnkt2g7cw3uth0.png" alt="Bild"></p><br><p>  <strong>3. Leinwand</strong> <br>  Alle Linien und deren Inhalt werden mit Canvas gezeichnet.  Dies hat Google Text &amp; Tabellen getan. </p><br><p><img src="https://habrastorage.org/webt/12/f_/hd/12f_hdydog5ponrdm9filxne_1u.png" alt="Bild"></p><br><p>  Bei der Entwicklung des Rasters haben wir Prototypen f√ºr alle drei Virtualisierungsoptionen (auch f√ºr Canvas) erstellt.  Und sie entschieden sich f√ºr eine seitenweise Virtualisierung. </p><br><h3 id="pochemu-otkazalis-ot-drugih-variantov">  Warum andere Optionen aufgeben? </h3><br><p>  Die zeilenweise Virtualisierung hatte Probleme mit der Rendergeschwindigkeit im Prototyp.  Sobald der Inhalt der Zeilen komplizierter wurde (viel Text, Hervorheben, Zuschneiden, Symbole, eine gro√üe Anzahl von Spalten und √ºberall Flexbox), wurde es teuer, Zeilen mehrmals pro Sekunde hinzuzuf√ºgen / zu entfernen.  Nat√ºrlich h√§ngen die Ergebnisse auch vom Browser ab (wir haben Unterst√ºtzung geleistet, einschlie√ülich f√ºr ie11, edge): </p><br><p><img src="https://habrastorage.org/webt/fe/4v/xh/fe4vxhw7r5zjwqqezc7rmxubmmm.png" alt="Bild"></p><br><p>  Die Canvas-Option war sehr verf√ºhrerisch in der Rendergeschwindigkeit, aber m√ºhsam.  Es wurde vorgeschlagen, alles zu zeichnen: Text, Textumbruch, Texttrimmen, Hervorheben, Symbole, Trennlinien, Hervorheben, Einr√ºcken.  Reagieren Sie auf das Klicken mit der Maus auf der Leinwand und markieren Sie die Linien, wenn Sie den Mauszeiger dar√ºber halten.  Gleichzeitig sollten einige Dom-Elemente (mit Hinweisen, ‚ÄûPopup-Aktionen‚Äú in der Zeile) √ºber Canvas angewendet werden.  Es war immer noch notwendig, das Problem des Verwischens von Text und Symbolen in Canvas zu l√∂sen.  All dies ist lang und schwierig zu tun.  Obwohl wir den Prototyp gemeistert haben.  Gleichzeitig w√ºrde jede Anpassung von Zeilen und Zellen in der Zukunft zu einer gro√üen M√ºhsal f√ºr uns f√ºhren. </p><br><h4 id="plyusy-postranichnoy-virtualizacii">  Die Vorteile von Paging </h4><br><p>  Die ausgew√§hlte seitenweise Virtualisierung hatte Vorteile gegen√ºber der zeilenweisen Virtualisierung, die ihre Wahl bestimmte: </p><br><ul><li>  Wenn die Seite bereits gerendert ist, ist das Scrollen innerhalb der Seite billig (der DOM-Baum √§ndert sich beim Scrollen nicht).  Die zeilenweise Virtualisierung f√ºr kleinere Bildl√§ufe erfordert das √Ñndern des DOM-Baums. Dies ist teuer, wenn der DOM-Baum komplex ist und √ºberall Flexbox verwendet wird. </li><li>  Bei kleinen Listen (&lt;200 Eintr√§ge) k√∂nnen Seiten nicht gel√∂scht werden. F√ºgen Sie einfach hinzu.  Fr√ºher oder sp√§ter werden alle Seiten erstellt und das Scrollen ist v√∂llig kostenlos (in Bezug auf die Renderzeit). </li></ul><br><h4 id="vybor-razmera-stranicy">  Auswahl der Seitengr√∂√üe </h4><br><p>  Ein separates Problem ist die Wahl der Seitengr√∂√üe.  Ich habe oben geschrieben, dass die Gr√∂√üe anpassbar ist und normalerweise 20-60 Zeilen betr√§gt.  Eine gro√üe Seite wird lange gezeichnet, eine kleine Seite f√ºhrt beim Scrollen zu einer h√§ufigen Anzeige eines "wei√üen Bildschirms".  Experimentell wurde eine Seitengr√∂√üe von 25 Zeilen ausgew√§hlt.  F√ºr dh11 wurde die Gr√∂√üe jedoch auf 5 Zeilen reduziert.  Es scheint, dass die Benutzeroberfl√§che im IE schneller reagiert, wenn Sie viele kleine Seiten mit kleinen Verz√∂gerungen zeichnen als eine gro√üe mit gro√üer Verz√∂gerung. </p><br><h4 id="react-i-virtual-scrolling">  Reagieren und virtuelles Scrollen </h4><br><p>  Die Seitenvirtualisierung musste mithilfe von React implementiert werden.  Dazu sollten mehrere Aufgaben gel√∂st werden: </p><br><p>  <strong>Aufgabe 1. Wie f√ºge ich Seiten hinzu, indem ich beim Scrollen reagiere?</strong> </p><br><p>  Um dieses Problem zu l√∂sen, wurden folgende Konzepte eingef√ºhrt: </p><br><ul><li>  Seitenmodell </li><li>  Seitenaufruf </li></ul><br><p>  Ein Modell ist eine Information, auf der eine Ansicht erstellt werden soll.  Eine Ansicht ist eine Reaktionskomponente. </p><br><p><img src="https://habrastorage.org/webt/ud/da/qi/uddaqigdtketfoh6cwk6lnklcpo.png" alt="Bild"></p><br><p>  Tats√§chlich bestand die Aufgabe der Virtualisierung danach darin, Seitenmodelle zu bearbeiten: Speichern Sie eine Liste von Seitenmodellen, f√ºgen Sie beim Scrollen Modelle hinzu und entfernen Sie sie.  Und schon aus der Liste der Modelle durch React Build / Rebuild das Display: </p><br><p><img src="https://habrastorage.org/webt/4m/sr/g0/4msrg0gy9qwsv9u-8ljjqhzllwa.png" alt="Bild"></p><br><p>  Im Zuge der Implementierung wurden die Regeln f√ºr die Arbeit mit Seitenmodellen festgelegt: </p><br><ul><li>  Seiten sollten einzeln hinzugef√ºgt werden.  Geben Sie nach jeder Zugabe Zeit zum Zeichnen.  Es ist akzeptabel, alle 300-500 ms 1 Seite hinzuzuf√ºgen - dies ist eine schnelle Bildlaufsituation.  Wenn Sie beispielsweise 5 Seiten gleichzeitig hinzuf√ºgen, h√§ngt die Benutzeroberfl√§che von ihrer Konstruktion ab. </li><li>  Seiten m√ºssen nicht in Dutzenden gehalten werden.  Ein Beispiel f√ºr eine Problemsituation: 20 Seiten werden angezeigt, der Benutzer wechselt zu einer anderen Liste und alle 20 Seiten m√ºssen gleichzeitig gel√∂scht werden.  Das Entfernen einer gro√üen Anzahl von Seiten ist ein teurer Vorgang. Das Bereinigen des DOM-Baums dauert 1 Sekunde.  Um dies zu vermeiden, ist es besser, nicht mehr als 10 Seiten gleichzeitig zu behalten. </li><li>  Bei jeder Spaltenmanipulation (Neuanordnung, Hinzuf√ºgen, L√∂schen, Strecken) ist es besser, Seiten zu l√∂schen, die f√ºr den Benutzer nicht im Voraus sichtbar sind.  Dadurch wird eine teure Neuerstellung aller gerenderten Seiten vermieden. </li></ul><br><p>  <strong>Aufgabe 2. Wie wird die Bildlaufleiste angezeigt?</strong> </p><br><p>  Beim virtuellen Scrollen wird davon ausgegangen, dass eine Bildlaufleiste verf√ºgbar ist, die die Gr√∂√üe der Liste ber√ºcksichtigt und es Ihnen erm√∂glicht, zu einem beliebigen Ort zu scrollen: </p><br><p><img src="https://habrastorage.org/webt/lo/rc/ut/lorcutgz7bcopbjltcnziudkgks.png" alt="Bild"></p><br><p>  Wie kann man eine solche Bildlaufleiste anzeigen?  Die einfachste L√∂sung besteht darin, anstelle von realen Daten ein unsichtbares Div der erforderlichen Gr√∂√üe zu zeichnen.  Und schon oben auf diesem Div zeigen wir die sichtbaren Seiten an: </p><br><p><img src="https://habrastorage.org/webt/pp/_x/vg/pp_xvgowd1qtrnyigxnszou0xnw.png" alt="Bild"></p><br><p>  <strong>Aufgabe 3. Wie kann die Gr√∂√üe des Ansichtsfensters √ºberwacht werden?</strong> </p><br><p>  Das Ansichtsfenster ist der sichtbare Datenbereich des Rasters.  Warum ihre Gr√∂√üe im Auge behalten?  Berechnung der Anzahl der Seiten, die dem Benutzer angezeigt werden m√ºssen.  Angenommen, wir haben eine kleine Seitengr√∂√üe (5 Zeilen) und eine gro√üe Bildschirmaufl√∂sung (1920 x 1080).  Wie viele Seiten muss der Benutzer anzeigen, um das gesamte Ansichtsfenster zu schlie√üen? </p><br><p><img src="https://habrastorage.org/webt/tt/g3/sx/ttg3sxfvvuf320ydcwe6esbukp4.png" alt="Bild"></p><br><p>  Sie k√∂nnen dieses Problem l√∂sen, wenn Sie die H√∂he des Ansichtsfensters und die H√∂he einer Seite kennen.  Lassen Sie uns nun die Aufgabe komplizieren. Nehmen wir an, der Benutzer √§ndert die Skalierung im Browser stark - setzt 50%: </p><br><p><img src="https://habrastorage.org/webt/s8/47/mt/s847mtipiappdqe0qqsli_yvj14.png" alt="Bild"></p><br><p>  Die Situation mit der Skala zeigt, dass es nicht ausreicht, die Gr√∂√üe des Ansichtsfensters einmal zu ermitteln. Sie m√ºssen die Gr√∂√üe √ºberwachen.  Und jetzt erschweren wir die Aufgabe vollst√§ndig: HTML-Elemente haben kein Gr√∂√üen√§nderungsereignis, das Sie abonnieren und die Gr√∂√üe √ºberwachen k√∂nnen.  Nur das Fensterobjekt hat die Gr√∂√üe ge√§ndert. </p><br><p>  Das erste, was mir in den Sinn kommt, ist die Verwendung eines Timers und die st√§ndige Abfrage der H√∂he des HTML-Elements.  Es gibt jedoch eine noch bessere L√∂sung, die wir im DevExtreme JavaScript-Datenraster gesehen haben: Erstellen Sie einen unsichtbaren Iframe, dehnen Sie ihn auf die Rastergr√∂√üe aus und abonnieren Sie das Gr√∂√üen√§nderungsereignis von iframe.contentWindow: </p><br><p><img src="https://habrastorage.org/webt/fa/gi/ta/fagitaw870f5ahtworjownk__mk.png" alt="Bild"></p><br><p><img src="https://habrastorage.org/webt/dd/m9/tq/ddm9tqblgsmpwepcc7_gq7g32sm.png" alt="Bild"></p><br><h3 id="rezyume">  Zusammenfassung </h3><br><p>  PS Dies ist nicht das Ende.  Im n√§chsten Artikel werde ich erz√§hlen, wie wir uns mit Redux angefreundet haben. </p><br><p>  Um ein vollst√§ndiges virtuelles Scrollen zu erhalten, mussten viele andere Aufgaben gel√∂st werden.  Aber die oben beschriebenen waren die interessantesten.  Hier sind einige andere Aufgaben, die ebenfalls angezeigt werden: </p><br><ul><li>  Ber√ºcksichtigen Sie beim Hinzuf√ºgen / Entfernen von Seiten die Richtung und Geschwindigkeit des Bildlaufs. </li><li>  Ber√ºcksichtigen Sie Daten√§nderungen, um die Neuerstellung von Seitenmodellen zu minimieren.  Wenn Sie beispielsweise eine Zeile gel√∂scht oder eine Zeile hinzugef√ºgt haben, was tun Sie mit bereits gerenderten Seiten?  Alles wegwerfen oder etwas zur√ºcklassen?  Es gibt Raum f√ºr Optimierungen. </li><li>  Ordnen Sie beim √Ñndern der Auswahl die minimal erforderliche Anzahl von Seiten neu an. </li></ul><br><p>  Wenn Sie Fragen zur Implementierung haben, k√∂nnen Sie diese in die Kommentare schreiben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457504/">https://habr.com/ru/post/de457504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457476/index.html">Reduzieren der Gr√∂√üe eines Docker-Images mit einer Spring-Boot-Anwendung</a></li>
<li><a href="../de457480/index.html">Erstellen einer Abh√∂ranwendung zum Anzeigen des mobilen MMORPG-Verkehrs</a></li>
<li><a href="../de457490/index.html">Aisioshechka aus Zuckerberg - kurz und im Fall Waage</a></li>
<li><a href="../de457494/index.html">"Und wenn ich Mathe nicht kenne, bin ich dann hoffnungslos?" - Spezialisten beantworten h√§ufig gestellte Fragen zu Berufen in Data Science</a></li>
<li><a href="../de457496/index.html">"Finde die f√ºnf Unterschiede." Skalierbarer und Generierungsunterschied - Neue Testreihe</a></li>
<li><a href="../de457508/index.html">Elternschaft gegen maschinelles Lernen: Vergleicht eine junge Mutter</a></li>
<li><a href="../de457510/index.html">Verwenden Sie mcrouter, um memcached horizontal zu skalieren</a></li>
<li><a href="../de457512/index.html">Logische Replikation zwischen PostgreSQL-Versionen</a></li>
<li><a href="../de457514/index.html">Nevanger</a></li>
<li><a href="../de457516/index.html">Schreiben eines Bedrohungsmodells</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>