<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèº ü•ê üßù Una peque√±a descripci√≥n de SIMD en .NET / C # üëäüèæ üïß üì≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aqu√≠ hay un vistazo r√°pido a las capacidades de vectorizaci√≥n de algoritmos en .NET Framework y .NET Core. Este art√≠culo es para aquellos que no saben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una peque√±a descripci√≥n de SIMD en .NET / C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467689/"><p>  Aqu√≠ hay un vistazo r√°pido a las capacidades de vectorizaci√≥n de algoritmos en .NET Framework y .NET Core.  Este art√≠culo es para aquellos que no saben nada sobre estas t√©cnicas.  Tambi√©n mostrar√© que .NET no se queda atr√°s de los lenguajes "compilados reales" para el desarrollo nativo. </p><a name="habracut"></a><br><p> Estoy empezando a aprender t√©cnicas de vectorizaci√≥n.  Por lo tanto, agradecer√© si los miembros de la comunidad encuentran errores claros o sugieren mejoras en los algoritmos descritos. </p><br><h2 id="some-history">  Algo de historia </h2><br><p>  SIMD apareci√≥ en .NET Framework 4.6 en 2015. Fue entonces cuando se agregaron los tipos Matrix3x2, Matrix4x4, Plane, Quaternion, Vector2, Vector3 y Vector4.  Permitieron c√°lculos vectorizados.  El siguiente fue el tipo Vector &lt;T&gt; que dio m√°s oportunidades para vectorizar algoritmos.  Sin embargo, muchos programadores todav√≠a estaban insatisfechos ya que estos tipos restring√≠an los flujos de ideas de los codificadores y no permit√≠an usar toda la capacidad de las instrucciones SIMD en los procesadores modernos.  Ahora en .NET Core 3.0 Preview, tenemos el espacio de nombres System.Runtime.Intrinsics que da mucha libertad en la elecci√≥n de instrucciones.  Para obtener la m√°xima velocidad, debe usar RyuJit y recurrir al ensamblaje x64 o desactivar Prefer 32-bit y elegir el ensamblaje AnyCPU.  Ejecut√© todos los puntos de referencia en la computadora con CPU Intel Core i7-6700 3.40 GHz (Skylake). </p><br><h2 id="summing-array-elements">  Suma de elementos de matriz </h2><br><p>  Decid√≠ comenzar con una tarea cl√°sica que generalmente viene primero si hay una vectorizaci√≥n involucrada.  Se trata de encontrar la suma de los elementos de la matriz.  Escribamos cuatro implementaciones de esta tarea para sumar los elementos de Array. </p><br><p>  La implementaci√≥n m√°s obvia: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Implementaci√≥n basada en LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  La implementaci√≥n basada en vectores de System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  La implementaci√≥n basada en el c√≥digo del espacio de nombres System.Runtime.Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Compar√© esos 4 m√©todos en mi computadora y obtuve los siguientes resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  ItemsCount </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10 </td><td>  3.531 ns </td><td>  0.0336 ns </td><td>  0.0314 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  76,925 ns </td><td>  0.4166 ns </td><td>  0.3897 ns </td><td>  21,79 </td></tr><tr><td>  Vectores </td><td>  10 </td><td>  2.750 ns </td><td>  0.0210 ns </td><td>  0,0196 ns </td><td>  0,78 </td></tr><tr><td>  Intr√≠nseca </td><td>  10 </td><td>  6.513 ns </td><td>  0.0623 ns </td><td>  0,0582 ns </td><td>  1,84 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100 </td><td>  47,982 ns </td><td>  0.3975 ns </td><td>  0.3524 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  590.414 ns </td><td>  3.8808 ns </td><td>  3.4402 ns </td><td>  12,31 </td></tr><tr><td>  Vectores </td><td>  100 </td><td>  10.122 ns </td><td>  0.0747 ns </td><td>  0.0699 ns </td><td>  0,21 </td></tr><tr><td>  Intr√≠nseca </td><td>  100 </td><td>  14,277 ns </td><td>  0.0566 ns </td><td>  0.0529 ns </td><td>  0,30 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1000 </td><td>  569.910 ns </td><td>  2.8297 ns </td><td>  2.6469 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  5,658.570 ns </td><td>  31.7465 ns </td><td>  29.6957 ns </td><td>  9,93 </td></tr><tr><td>  Vectores </td><td>  1000 </td><td>  79.598 ns </td><td>  0.3498 ns </td><td>  0.3272 ns </td><td>  0,14 </td></tr><tr><td>  Intr√≠nseca </td><td>  1000 </td><td>  66,970 ns </td><td>  0.3937 ns </td><td>  0.3682 ns </td><td>  0,12 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  10,000 </td><td>  5.637.571 ns </td><td>  37.5050 ns </td><td>  29.2814 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  56.498.987 ns </td><td>  294.8776 ns </td><td>  275.8287 ns </td><td>  10.02 </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  772.900 ns </td><td>  2.6802 ns </td><td>  2.5070 ns </td><td>  0,14 </td></tr><tr><td>  Intr√≠nseca </td><td>  10,000 </td><td>  579.152 ns </td><td>  2.8371 ns </td><td>  2.6538 ns </td><td>  0,10 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  56,352.865 ns </td><td>  230.7916 ns </td><td>  215.8826 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  562,610.571 ns </td><td>  3.775,7631 ns </td><td>  3.152,9332 ns </td><td>  9,98 </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  8.389.647 ns </td><td>  165.9590 ns </td><td>  227.1666 ns </td><td>  0,15 </td></tr><tr><td>  Intr√≠nseca </td><td>  100,000 </td><td>  7.261.334 ns </td><td>  89.6468 ns </td><td>  69.9903 ns </td><td>  0,13 </td></tr></tbody></table></div><br><p>  Est√° claro que las soluciones con vectores e intr√≠nsecos son mucho m√°s r√°pidas que las soluciones obvias y basadas en LINQ.  Ahora tenemos que descubrir qu√© sucede en estos dos m√©todos. </p><br><p>  Consideremos el m√©todo de vectores m√°s de cerca: </p><br><div class="spoiler">  <b class="spoiler_title">Vectores</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vector &lt;int&gt; .Count;  - la cantidad de n√∫meros de 4 bytes que podemos colocar en un vector.  Si se usa la aceleraci√≥n de hardware, este valor muestra cu√°ntos n√∫meros de 4 bytes podemos poner en un registro SIMD.  De hecho, muestra cu√°ntos elementos de este tipo se pueden manejar simult√°neamente; </li><li>  accVector es un vector que acumula el resultado de la funci√≥n; </li><li>  var v = nuevo Vector &lt;int&gt; (matriz, i);  - los datos de la matriz se cargan en un nuevo vector v, comenzando desde el √≠ndice i.  El vectorSize de datos se cargar√° exactamente; </li><li>  accVector = Vector.Add (accVector, v);  - se suman dos vectores. <br>  Por ejemplo, hay 8 n√∫meros en la matriz: {0, 1, 2, 3, 4, 5, 6, 7} y vectorSize == 4. <br>  Luego, durante la iteraci√≥n del primer ciclo accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3} y despu√©s de la adici√≥n accVector mantendr√°: {0, 0, 0, 0} + {0, 1 , 2, 3} = {0, 1, 2, 3}. <br>  Durante la segunda iteraci√≥n v = {4, 5, 6, 7} y despu√©s de la adici√≥n accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  Ahora solo necesitamos obtener la suma de todos los elementos vectoriales.  Para hacer esto, podemos usar la multiplicaci√≥n escalar por un vector lleno de unos: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Luego obtenemos: {4, 6, 8, 10} * {1, 1, 1, 1} = 4 * 1 + 6 * 1 + 8 * 1 + 10 * 1 = 28. </li><li>  Si es necesario, los n√∫meros que no se ajustan al √∫ltimo vector se sumar√°n al final. </li></ul><br><p>  Veamos el c√≥digo intr√≠nseco: </p><br><div class="spoiler">  <b class="spoiler_title">Intr√≠nseca</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Podemos ver que es como Vectores con una excepci√≥n: </p><br><ul><li>  vectorSize se especifica mediante una constante.  Esto se debe a que este m√©todo utiliza expl√≠citamente las instrucciones de Avx2 que funcionan con registros de 256 bits.  Una aplicaci√≥n real debe incluir una comprobaci√≥n de si un procesador actual es compatible con Avx2.  Si no, se debe llamar a otro c√≥digo.  Se ve as√≠: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector se declara como un vector de 256 bits lleno de ceros. </li><li>  fixed (int * ptr = Array): el puntero a la matriz se coloca en ptr. </li><li>  Las siguientes son las mismas operaciones que en Vectores: cargar datos en un vector y agregar dos vectores. </li><li>  La suma de elementos vectoriales utiliza el siguiente m√©todo: <br><ul><li>  crear una matriz en la pila: var temp = stackalloc int [vectorSize]; </li><li>  cargar un vector en esta matriz: Avx2.Store (temp, accVector); </li><li>  Elementos de la matriz de suma durante el ciclo. </li></ul></li><li>  A continuaci√≥n, se resumen los elementos que no se ajustan al √∫ltimo vector. </li></ul><br><h2 id="comparing-two-arrays">  Comparar dos matrices </h2><br><p>  Necesitamos comparar dos matrices de bytes.  Es exactamente esta tarea la que me hizo estudiar SIMD en .NET.  Nuevamente, escribamos varios m√©todos para la evaluaci√≥n comparativa y comparemos dos matrices: ArrayA y ArrayB. </p><br><p>  La soluci√≥n m√°s obvia: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Soluci√≥n basada en LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  La soluci√≥n basada en la funci√≥n MemCmp: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  La soluci√≥n basada en vectores de System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt;= ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Soluci√≥n basada en intr√≠nseca: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt;= ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Los resultados de ejecutar el benchmark en mi computadora: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  ItemsCount </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10,000 </td><td>  7.033,8 ns </td><td>  50.636 ns </td><td>  47.365 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  64.841,4 ns </td><td>  289.157 ns </td><td>  270.478 ns </td><td>  9.22 </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  504.0 ns </td><td>  2.406 ns </td><td>  2.251 ns </td><td>  0,07 </td></tr><tr><td>  Memcmp </td><td>  10,000 </td><td>  368,1 ns </td><td>  2.637 ns </td><td>  2.466 ns </td><td>  0,05 </td></tr><tr><td>  Intr√≠nseca </td><td>  10,000 </td><td>  283,6 ns </td><td>  1.135 ns </td><td>  1.061 ns </td><td>  0,04 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  85,214.4 ns </td><td>  903.868 ns </td><td>  845.478 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  702,279.4 ns </td><td>  2,846.609 ns </td><td>  2,662.720 ns </td><td>  8.24 </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  5.179,2 ns </td><td>  45,337 ns </td><td>  42,409 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  100,000 </td><td>  4,510.5 ns </td><td>  24.292 ns </td><td>  22.723 ns </td><td>  0,05 </td></tr><tr><td>  Intr√≠nseca </td><td>  100,000 </td><td>  2,957.0 ns </td><td>  11.452 ns </td><td>  10.712 ns </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1,000,000 </td><td>  844,006.1 ns </td><td>  3,552.478 ns </td><td>  3.322,990 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6.483.079,3 ns </td><td>  42,641.040 ns </td><td>  39,886.455 ns </td><td>  7.68 </td></tr><tr><td>  Vectores </td><td>  1,000,000 </td><td>  54,180.1 ns </td><td>  357.258 ns </td><td>  334,180 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  1,000,000 </td><td>  49,480.1 ns </td><td>  515.675 ns </td><td>  457.133 ns </td><td>  0,06 </td></tr><tr><td>  Intr√≠nseca </td><td>  1,000,000 </td><td>  36,633.9 ns </td><td>  680.525 ns </td><td>  636.564 ns </td><td>  0,04 </td></tr></tbody></table></div><br><p>  Supongo que el c√≥digo de estos m√©todos es claro, excepto por dos l√≠neas en Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  En la primera l√≠nea, se comparan dos vectores para la igualdad y el resultado se guarda en un vector areEqual en el que todos los bits del elemento en una posici√≥n particular se establecen en 1 si los elementos correspondientes en va y vb son iguales.  Entonces, resulta que si los vectores de bytes va y vb son iguales, todos los elementos en areEquals deber√≠an ser iguales a 255 (11111111b).  Como Avx2.CompareEqual es un contenedor sobre _mm256_cmpeq_epi8, podemos ir al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio web de Intel</a> y ver el pseudoc√≥digo de esta operaci√≥n: <br>  El m√©todo MoveMask crea un n√∫mero de 32 bits a partir de un vector.  Los bits superiores de cada 32 elementos de un byte en un vector son los valores de bits en el resultado de MoveMask.  El pseudoc√≥digo est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Por lo tanto, si algunos bytes en va y vb no coinciden, los bytes correspondientes en areEqual ser√°n 0. Por lo tanto, los bits superiores de estos bytes tambi√©n ser√°n 0.  Esto significa que los bits correspondientes en la respuesta Avx2.MoveMask tambi√©n ser√°n 0 y areEqual no ser√° igual a equalsMask. </p><br><p>  Veamos un ejemplo suponiendo que la longitud del vector es de 8 bytes (para escribir menos): </p><br><ul><li>  Deje va = {100, 10, 20, 30, 100, 40, 50, 100} y vb = {100, 20, 10, 30, 100, 40, 80, 90}. </li><li>  Entonces areEquals ser√° {255, 0, 0, 255, 255, 255, 0, 0}. </li><li>  El m√©todo MoveMask devolver√° 10011100b que se debe comparar con la m√°scara 11111111b.  Como estas m√°scaras no son iguales, los vectores va y vb tampoco lo son. </li></ul><br><h2 id="counting-the-times-an-element-occurs-in-a-collection">  Contando las veces que ocurre un elemento en una colecci√≥n. </h2><br><p>  Algunas veces necesita contar las ocurrencias de un elemento en particular, por ejemplo, enteros, en una colecci√≥n.  Tambi√©n podemos acelerar este algoritmo.  Para comparar, escribamos varios m√©todos para buscar el elemento Item en Array. </p><br><p>  El m√°s obvio: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Usando LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  Usando vectores de System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Usando intr√≠nsecos: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { temp[j] = Item; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = Avx2.LoadVector256(temp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Los resultados de ejecutar el benchmark en mi computadora: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  ItemsCount </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10 </td><td>  8.844 ns </td><td>  0,0772 ns </td><td>  0.0603 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  87.456 ns </td><td>  0.9496 ns </td><td>  0.8883 ns </td><td>  9,89 </td></tr><tr><td>  Vectores </td><td>  10 </td><td>  3.140 ns </td><td>  0,0406 ns </td><td>  0.0380 ns </td><td>  0,36 </td></tr><tr><td>  Intr√≠nseca </td><td>  10 </td><td>  13.813 ns </td><td>  0.0825 ns </td><td>  0,0772 ns </td><td>  1,56 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100 </td><td>  107,310 ns </td><td>  0,6975 ns </td><td>  0.6183 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  626.285 ns </td><td>  5.7677 ns </td><td>  5.3951 ns </td><td>  5.83 </td></tr><tr><td>  Vectores </td><td>  100 </td><td>  11.844 ns </td><td>  0.2113 ns </td><td>  0.1873 ns </td><td>  0,11 </td></tr><tr><td>  Intr√≠nseca </td><td>  100 </td><td>  19,616 ns </td><td>  0.1018 ns </td><td>  0,0903 ns </td><td>  0,18 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1000 </td><td>  1,032.466 ns </td><td>  6.3799 ns </td><td>  5.6556 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  6.266,605 ns </td><td>  42.6585 ns </td><td>  39.9028 ns </td><td>  6.07 </td></tr><tr><td>  Vectores </td><td>  1000 </td><td>  83,417 ns </td><td>  0.5393 ns </td><td>  0.4780 ns </td><td>  0,08 </td></tr><tr><td>  Intr√≠nseca </td><td>  1000 </td><td>  88.358 ns </td><td>  0.4921 ns </td><td>  0.4603 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  10,000 </td><td>  9,942.503 ns </td><td>  47,9732 ns </td><td>  40.0598 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  62,305.598 ns </td><td>  643.8775 ns </td><td>  502.6972 ns </td><td>  6.27 </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  914.967 ns </td><td>  7.2959 ns </td><td>  6.8246 ns </td><td>  0,09 </td></tr><tr><td>  Intr√≠nseca </td><td>  10,000 </td><td>  931.698 ns </td><td>  6.3444 ns </td><td>  5.9346 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  94,834.804 ns </td><td>  793.8585 ns </td><td>  703.7349 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  626,620.968 ns </td><td>  4,696.9221 ns </td><td>  4,393.5038 ns </td><td>  6.61 </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  9,000.827 ns </td><td>  179.5351 ns </td><td>  192.1005 ns </td><td>  0,09 </td></tr><tr><td>  Intr√≠nseca </td><td>  100,000 </td><td>  8.690.771 ns </td><td>  101.7078 ns </td><td>  95.1376 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1,000,000 </td><td>  959,302.249 ns </td><td>  4.268.2488 ns </td><td>  3.783,6914 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6.218.681.888 ns </td><td>  31,321.9277 ns </td><td>  29,298.5506 ns </td><td>  6.48 </td></tr><tr><td>  Vectores </td><td>  1,000,000 </td><td>  99,778.488 ns </td><td>  1,975.6001 ns </td><td>  4,252.6877 ns </td><td>  0,10 </td></tr><tr><td>  Intr√≠nseca </td><td>  1,000,000 </td><td>  96,449.350 ns </td><td>  1,171.8067 ns </td><td>  978.5116 ns </td><td>  0,10 </td></tr></tbody></table></div><br><p>  Los vectores y los m√©todos intr√≠nsecos coinciden completamente en l√≥gica pero difieren en la implementaci√≥n de operaciones particulares.  La idea es la siguiente: </p><br><ul><li>  crear un vector de m√°scara en el que se almacena un n√∫mero requerido en cada elemento; </li><li>  cargar la parte de una matriz en v vector y comparar esta parte con una m√°scara.  Como resultado, todos los bits se establecer√°n en elementos iguales de areEqual.  Como areEqual es una matriz de enteros, si establecemos todos los bits de un elemento, obtendremos -1 en este elemento ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  reste el vector areEqual del accVector.  Luego, accVector mantendr√° el recuento de cu√°ntas veces se produjo el elemento elemento en todos los vectores v para cada posici√≥n (menos por menos es un m√°s). </li></ul><br><p>  Todo el c√≥digo del art√≠culo est√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </p><br><h2 id="conclusion">  Conclusi√≥n </h2><br><p>  Describ√≠ solo una peque√±a parte de las capacidades de .NET para la vectorizaci√≥n de c√≥mputo.  Para ver la lista actualizada completa de todos los intr√≠nsecos disponibles en .NET Core en x86, consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo fuente</a> .  Es conveniente que el resumen de cada intr√≠nseco en archivos C # contenga su nombre en C world.  Esto ayuda a comprender el prop√≥sito de este intr√≠nseco y la transferencia de algoritmos C ++ / C existentes a .NET.  La documentaci√≥n de System.Numerics.Vector est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">msdn</a> . </p><br><p>  Creo que .NET tiene una gran ventaja sobre C ++.  Como la compilaci√≥n JIT ya se produce en una m√°quina cliente, un compilador puede optimizar el c√≥digo para un procesador de cliente en particular, dando el m√°ximo rendimiento.  Al mismo tiempo, un programador puede permanecer dentro de un idioma y las mismas tecnolog√≠as para escribir c√≥digo r√°pido. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467689/">https://habr.com/ru/post/467689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467675/index.html">Modelado del estado de la aplicaci√≥n utilizando objetos Store en SwiftUI</a></li>
<li><a href="../467677/index.html">Pruebas o tipos</a></li>
<li><a href="../467679/index.html">PyCrunch: ejecuci√≥n de prueba inteligente y cobertura de c√≥digo visual en el IDE</a></li>
<li><a href="../467681/index.html">Vulnerabilidad de desv√≠os de enrutamiento SOAP</a></li>
<li><a href="../467683/index.html">Tratando de componer lo no composable: esquemas de acoplamiento</a></li>
<li><a href="../467691/index.html">Intel Nervana NNP-T y NNP-I: chips especializados para IA</a></li>
<li><a href="../467693/index.html">Resumen de eventos de TI de septiembre (segunda parte)</a></li>
<li><a href="../467697/index.html">¬øEs cierto que GOPATH y GOROOT ya no son necesarios?</a></li>
<li><a href="../467699/index.html">C√≥mo no hacer el m√°s r√°pido y encontrar un defecto en la comunidad de Visual Studio 2019</a></li>
<li><a href="../467701/index.html">Categor√≠as en lugar de directorios. Una herramienta para el almacenamiento conveniente de archivos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>