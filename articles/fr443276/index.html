<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’†ğŸ¼ ğŸ›… ğŸ”© Planificateur de requÃªtes surprise dans la base de donnÃ©es PostgreSQL âª ğŸ€ ğŸš´ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Graphiques, rapports et analyses - tout cela est en quelque sorte prÃ©sent dans le back-office de toute entreprise, mÃªme trÃ¨s petite. Lorsqu'elles sont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Planificateur de requÃªtes surprise dans la base de donnÃ©es PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/443276/">  Graphiques, rapports et analyses - tout cela est en quelque sorte prÃ©sent dans le back-office de toute entreprise, mÃªme trÃ¨s petite.  Lorsqu'elles sont encombrÃ©es dans des tableaux rÃ©guliers dans Excel / Numbers / Libre, mais que les donnÃ©es ne sont toujours pas trÃ¨s volumineuses, les solutions traditionnelles pour les besoins internes de l'entreprise sont souvent construites Ã  l'aide de bases de donnÃ©es relationnelles telles que PostgreSQL, MySQL ou MariaDB. <br><br>  Ces bases de donnÃ©es sont gratuites, grÃ¢ce Ã  SQL, elles peuvent facilement s'intÃ©grer Ã  d'autres composants du systÃ¨me, elles sont populaires et la plupart des dÃ©veloppeurs et des analystes peuvent travailler avec elles.  La charge (trafic et volumes) qu'ils peuvent digÃ©rer est suffisamment volumineuse pour tenir facilement jusqu'Ã  ce que l'entreprise puisse se permettre des solutions plus complexes (et coÃ»teuses) pour les analyses et les rapports. <br><a name="habracut"></a><br><h4>  Position de dÃ©part </h4><br>  Cependant, mÃªme dans une technologie qui a Ã©tÃ© Ã©tudiÃ©e Ã  plusieurs reprises, il y a toujours diffÃ©rentes nuances qui peuvent soudainement ajouter aux soucis des ingÃ©nieurs.  En plus de la fiabilitÃ©, le problÃ¨me le plus frÃ©quemment mentionnÃ© avec les bases de donnÃ©es est leur performance.  De toute Ã©vidence, avec une augmentation de la quantitÃ© de donnÃ©es, le taux de rÃ©ponse DB diminue, mais si cela se produit de maniÃ¨re prÃ©visible et est cohÃ©rent avec l'augmentation de la charge, alors ce n'est pas si mal.  Vous pouvez toujours voir Ã  l'avance quand la base de donnÃ©es commence Ã  exiger de l'attention et planifier une mise Ã  niveau ou une transition vers une base de donnÃ©es fondamentalement diffÃ©rente.  Bien pire si les performances de la base de donnÃ©es se dÃ©gradent de maniÃ¨re imprÃ©visible. <br><br>  Le sujet de l'amÃ©lioration des performances des bases de donnÃ©es est aussi ancien que le monde et trÃ¨s vaste, et dans cet article, je voudrais me concentrer sur une seule direction.  Ã€ savoir, sur l'Ã©valuation de l'efficacitÃ© des plans de requÃªte dans une base de donnÃ©es PostgreSQL, ainsi que sur la modification de cette efficacitÃ© au fil du temps pour rendre le comportement du planificateur de base de donnÃ©es plus prÃ©visible. <br><br>  MalgrÃ© le fait que bon nombre des Ã©lÃ©ments qui seront discutÃ©s s'appliquent Ã  toutes les versions rÃ©centes de cette base de donnÃ©es, les exemples ci-dessous correspondent Ã  la version 11.2, cette derniÃ¨re pour le moment. <br>  Avant de plonger dans les dÃ©tails, il est logique de faire une digression et de dire quelques mots sur l'origine des problÃ¨mes de performances dans les bases de donnÃ©es relationnelles.  De quoi s'occupe exactement la base de donnÃ©es lorsqu'elle "ralentit"?  Le manque de mÃ©moire (un grand nombre d'accÃ¨s au disque ou au rÃ©seau), un processeur faible, ce sont tous des problÃ¨mes Ã©vidents avec des solutions claires, mais quoi d'autre peut affecter la vitesse d'exÃ©cution des requÃªtes? <br><br><h4>  RafraÃ®chissez vos souvenirs </h4><br>  Pour que la base de donnÃ©es rÃ©ponde Ã  la requÃªte SQL, elle doit crÃ©er un plan de requÃªte (dans quelles tables et colonnes pour voir quels index sont nÃ©cessaires, quoi choisir Ã  partir de lÃ , avec quoi comparer, combien de mÃ©moire est requise, etc.).  Ce plan est formÃ© sous la forme d'un arbre, dont les nÅ“uds ne sont que quelques opÃ©rations typiques, avec une complexitÃ© de calcul diffÃ©rente.  En voici quelques-unes, par exemple (N est le nombre de lignes avec lesquelles effectuer l'opÃ©ration): <br><br><table><thead><tr><th>  <nobr>Fonctionnement</nobr> </th><th>  Que fait-on </th><th>  CoÃ»t </th></tr></thead><tbody><tr><td colspan="3">  <i><font color="#999">SELECT ... WHERE ... opÃ©rations de rÃ©cupÃ©ration de donnÃ©es</font></i> </td></tr><tr><td>  <nobr>Scan Seq</nobr> </td><td>  Nous chargeons chaque ligne du tableau et vÃ©rifions l'Ã©tat. </td><td>  O (N) </td></tr><tr><td>  <nobr>Balayage d'index</nobr> <br>  (indice b-tree) </td><td>  Les donnÃ©es sont directement dans l'index, nous recherchons donc par condition les Ã©lÃ©ments nÃ©cessaires de l'index et prenons les donnÃ©es Ã  partir de lÃ . </td><td>  O (log (N)), recherche un Ã©lÃ©ment dans une arborescence triÃ©e. </td></tr><tr><td>  <nobr>Balayage d'index</nobr> <br>  (indice de hachage) </td><td>  Les donnÃ©es sont directement dans l'index, nous recherchons donc par condition les Ã©lÃ©ments nÃ©cessaires de l'index et prenons les donnÃ©es Ã  partir de lÃ . </td><td>  O (1), recherche d'un Ã©lÃ©ment dans une table de hachage, Ã  l'exclusion du coÃ»t de crÃ©ation de hachages </td></tr><tr><td>  Analyse de tas de bitmap </td><td>  Nous sÃ©lectionnons les numÃ©ros des lignes nÃ©cessaires par index, puis nous chargeons uniquement les lignes nÃ©cessaires et effectuons avec eux des contrÃ´les supplÃ©mentaires. </td><td>  Scan Index + Scan Seq (M), <br>  OÃ¹ M est le nombre de lignes trouvÃ©es aprÃ¨s le balayage d'index.  On suppose que M &lt;&lt; N, c'est-Ã -dire  index est plus utile que Seq Scan. </td></tr><tr><td colspan="3">  <i><font color="#999">OpÃ©rations de jointure (JOIN, SELECT Ã  partir de plusieurs tables)</font></i> </td></tr><tr><td>  Boucle imbriquÃ©e </td><td>  Pour chaque ligne du tableau de gauche, recherchez une ligne appropriÃ©e dans le tableau de droite. </td><td>  O (N <sup>2</sup> ). <br>  Mais si l'un des tableaux est beaucoup plus petit que l'autre (dictionnaire) et ne croÃ®t pratiquement pas avec le temps, alors le coÃ»t rÃ©el peut diminuer jusqu'Ã  O (N). </td></tr><tr><td>  Hash Join </td><td>  Pour chaque ligne des tableaux de gauche et de droite, nous considÃ©rons le hachage, ce qui rÃ©duit le nombre de recherches d'options de connexion possibles. </td><td>  O (N), mais dans le cas d'une fonction de hachage trÃ¨s inefficace ou d'un grand nombre de champs identiques pour la connexion, il peut y avoir O (N <sup>2</sup> ) </td></tr><tr><td>  Fusionner la jointure </td><td>  Par condition, nous trions les tableaux de gauche et de droite, aprÃ¨s quoi nous combinons les deux listes triÃ©es </td><td>  O (N * log (N)) <br>  CoÃ»ts de tri + parcourir la liste. </td></tr><tr><td colspan="3">  <i><font color="#999">OpÃ©rations d'agrÃ©gation (GROUP BY, DISTINCT)</font></i> </td></tr><tr><td>  AgrÃ©gat de groupe </td><td>  Nous trions la table en fonction de la condition d'agrÃ©gation, puis dans la liste triÃ©e, nous groupons les lignes adjacentes. </td><td>  O (N * log (N)) </td></tr><tr><td>  AgrÃ©gat de hachage </td><td>  Nous considÃ©rons le hachage pour la condition d'agrÃ©gation pour chaque ligne.  Pour les lignes avec le mÃªme hachage, nous effectuons une agrÃ©gation. </td><td>  O (N) </td></tr></tbody></table><br>  Comme vous pouvez le voir, le coÃ»t d'une requÃªte dÃ©pend beaucoup de la faÃ§on dont les donnÃ©es sont situÃ©es dans les tables et de la faÃ§on dont cet ordre correspond aux opÃ©rations de hachage utilisÃ©es.  La boucle imbriquÃ©e, malgrÃ© son coÃ»t en O (N <sup>2</sup> ), peut Ãªtre plus rentable que Hash Join ou Merge Join lorsque l'une des tables jointes dÃ©gÃ©nÃ¨re en une ou plusieurs lignes. <br><br>  En plus des ressources CPU, le coÃ»t comprend Ã©galement l'utilisation de la mÃ©moire.  Les deux Ã©tant des ressources limitÃ©es, le planificateur de requÃªtes doit trouver un compromis.  Si deux tables sont mathÃ©matiquement plus rentables Ã  joindre via une jointure par hachage, mais qu'il n'y a tout simplement pas de place en mÃ©moire pour une si grande table de hachage, la base de donnÃ©es peut Ãªtre forcÃ©e d'utiliser la fusion par jointure, par exemple.  Une boucle imbriquÃ©e "lente" ne nÃ©cessite gÃ©nÃ©ralement pas de mÃ©moire supplÃ©mentaire et est prÃªte Ã  produire des rÃ©sultats juste aprÃ¨s le lancement. <br><br>  Le coÃ»t relatif de ces opÃ©rations apparaÃ®t plus clairement sur le graphique.  Ce ne sont pas des nombres absolus, juste un rapport approximatif de diffÃ©rentes opÃ©rations. <br><br><img src="https://habrastorage.org/webt/9f/p_/mx/9fp_mx7mhhd5kgokxbqeu-kxpfa.png"><br><br>  Le graphique de boucle imbriquÃ©e "commence" ci-dessous, car  il ne nÃ©cessite pas de calculs supplÃ©mentaires, d'allocation de mÃ©moire ou de copie de donnÃ©es intermÃ©diaires, mais il a un coÃ»t O (N <sup>2</sup> ).  Merge Join et Hash Join ont des coÃ»ts initiaux plus Ã©levÃ©s, cependant, aprÃ¨s quelques valeurs N, ils commencent Ã  battre Nested Loop Ã  temps.  L'ordonnanceur essaie de choisir le plan avec le coÃ»t le plus bas et sur le graphique ci-dessus adhÃ¨re Ã  diffÃ©rentes opÃ©rations avec diffÃ©rents N (flÃ¨che verte en pointillÃ©s).  Avec le nombre de lignes jusqu'Ã  N1, il est plus rentable d'utiliser la boucle imbriquÃ©e, de N1 Ã  N2, il est plus rentable de fusionner la jointure, puis aprÃ¨s N2, il devient plus rentable pour Hash Join, mais Hash Join nÃ©cessite de la mÃ©moire pour crÃ©er des tables de hachage.  Et lorsque vous atteignez N3, cette mÃ©moire devient insuffisante, ce qui conduit Ã  l'utilisation forcÃ©e de Fusionner Join. <br><br>  Lors du choix d'un plan, le planificateur estime le coÃ»t de chaque opÃ©ration dans le plan en utilisant un ensemble de coÃ»ts relatifs de certaines opÃ©rations Â«atomiquesÂ» dans la base de donnÃ©es.  Comme, par exemple, des calculs, des comparaisons, le chargement d'une page en mÃ©moire, etc.  Voici une liste de certains de ces paramÃ¨tres de la configuration par dÃ©faut, il n'y en a pas beaucoup: <br><br><table><thead><tr><th>  CoÃ»t relatif constant </th><th>  Valeur par dÃ©faut </th></tr></thead><tbody><tr><td>  seq_page_cost </td><td>  1.0 </td></tr><tr><td>  random_page_cost </td><td>  4,0 </td></tr><tr><td>  cpu_tuple_cost </td><td>  0,01 </td></tr><tr><td>  cpu_index_tuple_cost </td><td>  0,005 </td></tr><tr><td>  cpu_operator_cost </td><td>  0,0025 </td></tr><tr><td>  parallel_tuple_cost </td><td>  0,1 </td></tr><tr><td>  parallel_setup_cost </td><td>  1000,0 </td></tr></tbody></table><br>  Certes, ces constantes seules sont peu nombreuses, vous devez toujours connaÃ®tre le Â«NÂ», c'est-Ã -dire exactement combien de lignes des rÃ©sultats prÃ©cÃ©dents devront Ãªtre traitÃ©es dans chacune de ces opÃ©rations.  La limite supÃ©rieure est Ã©vidente ici - la base de donnÃ©es "sait" combien de donnÃ©es se trouve dans n'importe quelle table et peut toujours calculer "au maximum".  Par exemple, si vous avez deux tables de 100 lignes chacune, les joindre peut produire de 0 Ã  10 000 lignes dans la sortie.  En consÃ©quence, la prochaine opÃ©ration d'entrÃ©e peut avoir jusqu'Ã  10 000 lignes. <br><br>  Mais si vous connaissez au moins un peu la nature des donnÃ©es des tableaux, ce nombre de lignes peut Ãªtre prÃ©dit avec plus de prÃ©cision.  Par exemple, pour deux tables de 100 lignes de l'exemple ci-dessus, si vous savez Ã  l'avance que la jointure ne produira pas 10 000 lignes, mais les 100 mÃªmes, le coÃ»t estimÃ© de la prochaine opÃ©ration est considÃ©rablement rÃ©duit.  Dans ce cas, ce plan pourrait Ãªtre plus efficace que d'autres. <br><br><h4>  Optimisation prÃªte Ã  l'emploi </h4><br>  Pour que l'ordonnanceur puisse prÃ©dire plus prÃ©cisÃ©ment la taille des rÃ©sultats intermÃ©diaires, PostgreSQL utilise la collecte de statistiques sur les tables, qui est accumulÃ©e dans pg_statistic, ou dans sa version plus lisible - dans pg_stats.  Il est mis Ã  jour automatiquement au dÃ©marrage du vide, ou explicitement avec la commande ANALYSER.  Ce tableau stocke une variÃ©tÃ© d'informations sur les donnÃ©es et le type de nature contenus dans les tableaux.  En particulier, histogrammes de valeurs, pourcentage de champs vides et autres informations.  Le planificateur utilise tout cela pour prÃ©dire avec plus de prÃ©cision la quantitÃ© de donnÃ©es pour chaque opÃ©ration dans l'arborescence du plan, et ainsi calculer plus prÃ©cisÃ©ment le coÃ»t des opÃ©rations et le plan dans son ensemble. <br><br>  Prenons par exemple la requÃªte: <br><pre><code class="plaintext hljs">SELECT t1.important_value FROM t1 WHERE t1.a &gt; 100</code> </pre> <br><br>  Supposons que l'histogramme des valeurs de la colonne Â«t1.aÂ» rÃ©vÃ¨le que des valeurs supÃ©rieures Ã  100 se trouvent dans environ 1% des lignes du tableau.  Nous pouvons alors prÃ©dire qu'un tel Ã©chantillon renverra environ un centiÃ¨me de toutes les lignes du tableau Â«t1Â». <br>  La base de donnÃ©es vous donne la possibilitÃ© de consulter le coÃ»t prÃ©vu du plan via la commande EXPLAIN et l'heure rÃ©elle de son fonctionnement - en utilisant EXPLAIN ANALYZE. <br><br>  Il semble qu'avec les statistiques automatiques, tout devrait bien se passer maintenant, mais il peut y avoir des difficultÃ©s.  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon article</a> Ã  ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Citus Data</a> , avec un exemple de l'inefficacitÃ© des statistiques automatiques et de la collecte de statistiques supplÃ©mentaires Ã  l'aide de CREATE STATISTICS (disponible avec PG 10.0). <br><br>  Ainsi, pour l'ordonnanceur, il existe deux sources d'erreurs dans le calcul des coÃ»ts: <br><br><ol><li>  Le coÃ»t relatif des opÃ©rations primitives (seq_page_cost, cpu_operator_cost, etc.) par dÃ©faut peut Ãªtre trÃ¨s diffÃ©rent de la rÃ©alitÃ© (coÃ»t du processeur 0,01, coÃ»t de chargement de la page srq - 1 ou 4 pour le chargement de page alÃ©atoire).  Loin du fait que 100 comparaisons seront Ã©gales Ã  1 page de chargement. </li><li>  Erreur lors de la prÃ©vision du nombre de lignes dans les opÃ©rations intermÃ©diaires.  Le coÃ»t rÃ©el de l'opÃ©ration dans ce cas peut Ãªtre trÃ¨s diffÃ©rent de la prÃ©vision. </li></ol><br>  Dans les requÃªtes complexes, l'Ã©laboration et la prÃ©vision de tous les plans possibles peuvent prendre beaucoup de temps en soi.  Quelle est l'utilitÃ© de renvoyer des donnÃ©es en 1 seconde si la base de donnÃ©es ne prÃ©voyait qu'une minute de requÃªte?  PostgreSQL dispose d'un optimiseur Geqo pour cette situation; c'est un planificateur qui ne construit pas tous les plans possibles, mais commence par quelques plans alÃ©atoires et complÃ¨te les meilleurs, en prÃ©disant les moyens de rÃ©duire les coÃ»ts.  Tout cela n'amÃ©liore pas non plus la prÃ©cision des prÃ©visions, bien qu'il accÃ©lÃ¨re la recherche d'au moins un plan plus ou moins optimal. <br><br><h4>  Plans soudains - concurrents </h4><br>  Si tout se passe bien, votre demande est satisfaite dans les plus brefs dÃ©lais.  Ã€ mesure que la quantitÃ© de donnÃ©es augmente, la vitesse d'exÃ©cution des requÃªtes dans la base de donnÃ©es augmente progressivement, et aprÃ¨s un certain temps, en l'observant, vous pouvez prÃ©dire Ã  peu prÃ¨s quand il sera nÃ©cessaire d'augmenter la mÃ©moire ou le nombre de cÅ“urs de processeur ou d'Ã©tendre le cluster, etc. <br><br>  Mais nous devons tenir compte du fait que le plan optimal a des concurrents avec des coÃ»ts d'exÃ©cution proches, ce que nous ne voyons pas.  Et si la base de donnÃ©es change soudainement le plan de requÃªte en un autre, cela surprend.  C'est bien si la base de donnÃ©es passe Ã  un plan plus efficace.  Et sinon?  Regardons l'image, par exemple.  Il s'agit du coÃ»t prÃ©vu et en temps rÃ©el de la mise en Å“uvre de deux plans (rouge et vert): <br><br><img src="https://habrastorage.org/webt/an/0e/t1/an0et1smgdhh60caqa4yltzgiu4.png"><br><br>  Ici, un plan est affichÃ© en vert et son Â«concurrentÂ» le plus proche en rouge.  La ligne pointillÃ©e montre un graphique des coÃ»ts projetÃ©s, la ligne continue est le temps rÃ©el.  La flÃ¨che grise en pointillÃ©s montre la sÃ©lection du planificateur. <br><br>  Supposons qu'un beau vendredi soir, le nombre prÃ©vu de lignes dans une opÃ©ration intermÃ©diaire atteigne N1 et la prÃ©vision Â«rougeÂ» commence Ã  surpasser la prÃ©vision Â«verteÂ».  Le planificateur commence Ã  l'utiliser.  Le temps d'exÃ©cution rÃ©el de la requÃªte saute immÃ©diatement (passage d'une ligne continue verte Ã  une ligne rouge), c'est-Ã -dire que le calendrier de dÃ©gradation de la base de donnÃ©es prend la forme d'une Ã©tape (ou peut-Ãªtre d'un Â«murÂ»).  En pratique, un tel Â«murÂ» peut augmenter le temps d'exÃ©cution des requÃªtes d'un ordre de grandeur ou plus. <br><br>  Il convient de noter que cette situation est probablement plus typique pour le back-office et l'analyse que pour le front-end, car ce dernier est gÃ©nÃ©ralement adaptÃ© Ã  des requÃªtes plus simultanÃ©es et, par consÃ©quent, utilise des requÃªtes plus simples dans la base de donnÃ©es, oÃ¹ l'erreur dans les prÃ©visions de plan est moindre.  S'il s'agit d'une base de donnÃ©es pour le reporting ou l'analyse, les requÃªtes peuvent Ãªtre arbitrairement complexes. <br><br><h4>  Comment vivre avec Ã§a? </h4><br>  La question se pose: Ã©tait-il possible d'une maniÃ¨re ou d'une autre de prÃ©voir de tels plans invisibles Â«sous-marinsÂ»?  AprÃ¨s tout, le problÃ¨me n'est pas qu'ils ne sont pas optimaux, mais que le passage Ã  un autre plan peut se produire de maniÃ¨re imprÃ©visible et, selon la loi de la mÃ©chancetÃ©, au moment le plus malheureux pour cela. <br><br>  Malheureusement, vous ne pouvez pas les voir directement, mais vous pouvez rechercher des plans alternatifs en modifiant les poids rÃ©els selon lesquels ils sont sÃ©lectionnÃ©s.  Le sens de cette approche est de supprimer de la vue le plan actuel, que l'ordonnanceur considÃ¨re optimal, de sorte qu'un de ses plus proches concurrents devienne optimal, et ainsi, il pourrait Ãªtre vu Ã  travers l'Ã©quipe EXPLAIN.  En vÃ©rifiant pÃ©riodiquement les changements de coÃ»ts dans ces Â«concurrentsÂ» et dans le plan principal, vous pouvez Ã©valuer la probabilitÃ© que la base de donnÃ©es Â«passeÂ» bientÃ´t Ã  un autre plan. <br><br>  En plus de collecter des donnÃ©es sur les prÃ©visions de plans alternatifs, vous pouvez les exÃ©cuter et mesurer leurs performances, ce qui donne Ã©galement une idÃ©e du Â«bien-ÃªtreÂ» interne de la base de donnÃ©es. <br>  Voyons quels outils nous avons pour de telles expÃ©riences. <br><br>  Tout d'abord, vous pouvez explicitement Â«interdireÂ» des opÃ©rations spÃ©cifiques Ã  l'aide de variables de session.  IdÃ©alement, ils n'ont pas besoin d'Ãªtre modifiÃ©s dans la configuration et de recharger la base de donnÃ©es, leur valeur ne change que dans la session ouverte en cours et n'affecte pas les autres sessions, vous pouvez donc expÃ©rimenter directement avec des donnÃ©es rÃ©elles.  Voici une liste d'entre eux avec des valeurs par dÃ©faut.  Presque toutes les opÃ©rations sont incluses: <br><table><thead><tr><th>  OpÃ©rations utilisÃ©es </th><th>  Valeur par dÃ©faut </th></tr></thead><tbody><tr><td>  enable_bitmapscan <br>  enable_hashagg <br>  enable_hashjoin <br>  enable_indexscan <br>  enable_indexonlyscan <br>  enable_material <br>  enable_mergejoin <br>  enable_nestloop <br>  enable_parallel_append <br>  enable_seqscan <br>  enable_sort <br>  enable_tidscan <br>  enable_parallel_hash <br>  enable_partition_pruning </td><td>  sur </td></tr><tr><td>  enable_partitionwise_join <br>  enable_partitionwise_aggregate </td><td>  Ã©teint </td></tr></tbody></table><br>  En interdisant ou en autorisant certaines opÃ©rations, nous forÃ§ons le planificateur Ã  sÃ©lectionner d'autres plans que nous pouvons voir avec la mÃªme commande EXPLAIN.  En fait, l 'Â«interdictionÂ» des opÃ©rations n'interdit pas leur utilisation, mais augmente simplement considÃ©rablement leur coÃ»t.  Dans PostgreSQL, chaque opÃ©ration Â«interditeÂ» empile automatiquement un coÃ»t Ã©gal Ã  10 milliards d'unitÃ©s conventionnelles.  De plus, dans EXPLAIN, le poids total du plan peut s'avÃ©rer prohibitif, mais dans le contexte de ces dizaines de milliards, le poids des opÃ©rations restantes est clairement visible, car il s'inscrit gÃ©nÃ©ralement dans des commandes plus petites. <br><br>  Deux des opÃ©rations suivantes sont particuliÃ¨rement intÃ©ressantes: <br><br><ul><li>  <strong>Hash Join.</strong>  Sa complexitÃ© est O (N), mais avec une erreur avec une prÃ©vision du montant du rÃ©sultat, vous ne pouvez pas tenir en mÃ©moire et vous devrez faire Merge Join, avec un coÃ»t de O (N * log (N)). </li><li>  <strong>Boucle imbriquÃ©e.</strong>  Sa complexitÃ© est O (N <sup>2</sup> ), par consÃ©quent, l'erreur dans la prÃ©vision de taille affecte de maniÃ¨re quadratique la vitesse d'une telle connexion. </li></ul><br>  Par exemple, prenons quelques chiffres rÃ©els Ã  partir de requÃªtes, dont l'optimisation Ã©tait engagÃ©e dans notre entreprise. <br><br>  <strong><u>Plan 1.</u></strong> Avec toutes les opÃ©rations autorisÃ©es, le coÃ»t total du plan le plus optimal Ã©tait de 274962,09 unitÃ©s. <br><br>  <strong><u>Plan 2.</u></strong> Avec la boucle imbriquÃ©e Â«interditeÂ», le coÃ»t est passÃ© Ã  40000534153.85.  Ces 40 milliards qui constituent l'essentiel du coÃ»t reprÃ©sentent 4 fois la boucle imbriquÃ©e utilisÃ©e, malgrÃ© l'interdiction.  Et les 534153.85 restants - c'est prÃ©cisÃ©ment la prÃ©vision du coÃ»t de toutes les autres opÃ©rations du plan.  Il est, comme nous le voyons, environ 2 fois plus Ã©levÃ© que le coÃ»t du plan optimal, c'est-Ã -dire qu'il est assez proche de lui. <br><br>  <strong><u>Plan 3.</u></strong> Avec le Hash Join Â«interditÂ», le coÃ»t Ã©tait de 383253,77.  Le plan a vraiment Ã©tÃ© fait sans utiliser l'opÃ©ration Hash Join, car nous ne voyons aucun milliard.  Son coÃ»t est cependant 30% plus Ã©levÃ© que celui de l'optimum, qui est Ã©galement trÃ¨s proche. <br><br>  En rÃ©alitÃ©, les temps d'exÃ©cution des requÃªtes Ã©taient les suivants: <br><br>  <strong><u>Plan 1</u></strong> (toutes les opÃ©rations autorisÃ©es) terminÃ© en ~ 9 minutes. <br>  <strong><u>Plan 2</u></strong> (avec la boucle imbriquÃ©e Â«interditeÂ») terminÃ© en 1,5 seconde. <br>  <strong><u>Le plan 3</u></strong> (avec une jointure de hachage Â«interditeÂ») a Ã©tÃ© achevÃ© en ~ 5 minutes. <br><br>  La raison, comme vous pouvez le voir, est la prÃ©vision erronÃ©e du coÃ»t de la boucle imbriquÃ©e.  En effet, en comparant EXPLAIN avec EXPLAIN ANALYZE, une erreur y est dÃ©tectÃ©e avec la dÃ©finition de ce N malheureux dans l'opÃ©ration intermÃ©diaire.  Au lieu d'une seule ligne prÃ©dite, la boucle imbriquÃ©e a rencontrÃ© plusieurs milliers de lignes, ce qui a entraÃ®nÃ© une augmentation du couple d'exÃ©cution de la requÃªte de quelques ordres de grandeur. <br><br>  Les Ã©conomies rÃ©alisÃ©es avec la jointure de hachage Â«interditeÂ» sont associÃ©es au remplacement du hachage par le tri et la fusion de jointure, qui fonctionnaient plus rapidement dans ce cas que la jointure de hachage.  A noter que ce plan 2 est en rÃ©alitÃ© presque deux fois plus rapide que le plan "optimal" 1. Bien qu'il ait Ã©tÃ© prÃ©vu qu'il sera plus lent. <br><br>  En pratique, si votre demande soudainement (aprÃ¨s une mise Ã  niveau de la base de donnÃ©es ou tout simplement) a commencÃ© Ã  s'exÃ©cuter beaucoup plus longtemps qu'auparavant, essayez d'abord de refuser la jointure par hachage ou la boucle imbriquÃ©e et voyez comment cela affecte la vitesse de la requÃªte.  Dans un cas rÃ©ussi, vous pourrez au moins interdire un nouveau plan non optimal et revenir au prÃ©cÃ©dent rapidement. <br><br>  Pour ce faire, vous n'avez pas besoin de modifier les fichiers de configuration de PostgreSQL avec un redÃ©marrage de la base de donnÃ©es, il est assez simple dans n'importe quelle console de changer la valeur de la variable souhaitÃ©e pour une session ouverte Ã  partir de la base de donnÃ©es.  Les sessions restantes ne seront pas affectÃ©es, la configuration ne changera que pour votre session actuelle.  Par exemple, comme ceci: <br><br><pre> <code class="plaintext hljs">SET enable_hashjoin='on'; SET enable_nestloop='off'; SELECT â€¦ FROM â€¦ (    )</code> </pre><br>  La deuxiÃ¨me faÃ§on d'influencer le choix du plan consiste Ã  modifier le poids des opÃ©rations de bas niveau.  Il n'y a pas de recette universelle ici, mais, par exemple, si vous avez une base de donnÃ©es avec un cache Â«rÃ©chauffÃ©Â» et que toutes les donnÃ©es sont stockÃ©es en mÃ©moire, il est probable que le coÃ»t du chargement de page sÃ©quentiel ne diffÃ¨re pas du coÃ»t de chargement d'une page alÃ©atoire.  Alors que dans la configuration par dÃ©faut, random est 4 fois plus cher que sÃ©quentiel. <br><br>  Ou, un autre exemple, le coÃ»t conditionnel de l'exÃ©cution du traitement parallÃ¨le est de 1000 par dÃ©faut, tandis que le coÃ»t de chargement d'une page est de 1,0.  Il est logique de commencer par modifier un seul des paramÃ¨tres Ã  la fois pour dÃ©terminer si cela affecte le choix du plan.  Le moyen le plus simple consiste Ã  commencer par dÃ©finir le paramÃ¨tre sur 0 ou sur une valeur Ã©levÃ©e (1 million). <br><br>  Cependant, gardez Ã  l'esprit qu'en amÃ©liorant les performances d'une demande, vous pouvez les dÃ©grader dans une autre.  En gÃ©nÃ©ral, il existe un large champ d'expÃ©riences.  Il vaut mieux essayer de les changer un Ã  la fois, un Ã  la fois. <br><br><h4>  Options alternatives de traitement </h4><br>  Une histoire sur un planificateur serait incomplÃ¨te sans mentionner au moins deux extensions PostgreSQL. <br><br>  Le premier est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SR_PLAN</a> , pour enregistrer le plan calculÃ© et forcer son utilisation ultÃ©rieure.  Cela permet de rendre le comportement de la base de donnÃ©es plus prÃ©visible en termes de choix de plan. <br><br>  Le second est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Adaptive Query Optimizer</a> , qui implÃ©mente le feedback au planificateur Ã  partir de l'exÃ©cution en temps rÃ©el de la requÃªte, c'est-Ã -dire que le planificateur mesure les rÃ©sultats rÃ©els de la requÃªte exÃ©cutÃ©e et ajuste ses plans Ã  l'avenir en gardant cela Ã  l'esprit.  La base de donnÃ©es est ainsi "auto-ajustÃ©e" pour des donnÃ©es et des requÃªtes spÃ©cifiques. <br><br><h4>  Que fait d'autre la base de donnÃ©es lorsqu'elle ralentit? </h4><br>  Maintenant que nous avons plus ou moins triÃ© la planification des requÃªtes, nous verrons ce qui peut Ãªtre amÃ©liorÃ© Ã  la fois dans la base de donnÃ©es elle-mÃªme et dans les applications qui l'utilisent pour en tirer le maximum de performances. <br><br>  Supposons que le plan de requÃªte soit dÃ©jÃ  optimal.  Si nous excluons les problÃ¨mes les plus Ã©vidents (mÃ©moire insuffisante ou disque / rÃ©seau lent), il y a encore des coÃ»ts pour le calcul des hachages.  Il existe probablement de grandes opportunitÃ©s pour de futures amÃ©liorations de PostgreSQL (en utilisant le GPU ou mÃªme les instructions SSE2 / SSE3 / AVX du CPU), mais jusqu'Ã  prÃ©sent, cela n'a pas Ã©tÃ© fait et les calculs de hachage n'utilisent presque jamais les capacitÃ©s matÃ©rielles du matÃ©riel.  Vous pouvez aider un peu dans cette base de donnÃ©es. <br><br>  Si vous remarquez, par dÃ©faut, les index dans PostgreSQL sont crÃ©Ã©s en tant que b-tree.  Leur utilitÃ© est qu'ils sont assez polyvalents.  Un tel indice peut Ãªtre utilisÃ© Ã  la fois avec des conditions d'Ã©galitÃ© et avec des conditions de comparaison (plus ou moins).  Trouver un Ã©lÃ©ment dans un tel index est un coÃ»t logarithmique.  Mais si votre requÃªte contient uniquement une condition d'Ã©galitÃ©, des index peuvent Ã©galement Ãªtre crÃ©Ã©s en tant qu'index de hachage, dont le coÃ»t est constant. <br><br>  De plus, vous pouvez toujours essayer de modifier la demande afin d'utiliser son exÃ©cution parallÃ¨le.  Pour comprendre exactement comment le rÃ©Ã©crire, il est prÃ©fÃ©rable de vous familiariser avec la liste des cas oÃ¹ le parallÃ©lisme est automatiquement interdit par le planificateur et d'Ã©viter de telles situations.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le manuel</a> sur ce sujet dÃ©crit briÃ¨vement toutes les situations, il est donc inutile de les rÃ©pÃ©ter ici. <br><br>  Que faire si la demande ne parvient toujours pas Ã  faire le parallÃ¨le?  Il est trÃ¨s triste de voir comment, dans votre puissante base de donnÃ©es multicÅ“ur, oÃ¹ vous Ãªtes le seul client, un cÅ“ur est occupÃ© Ã  100% et tous les autres noyaux le regardent.  Dans ce cas, vous devez aider la base de donnÃ©es du cÃ´tÃ© de l'application.  Ã‰tant donnÃ© que chaque session est affectÃ©e Ã  son propre noyau, vous pouvez en ouvrir plusieurs et diviser la requÃªte gÃ©nÃ©rale en parties, en effectuant des sÃ©lections plus courtes et plus rapides, en les combinant en un rÃ©sultat commun dÃ©jÃ  dans l'application.  Cela occupera le maximum de ressources CPU disponibles dans la base de donnÃ©es PostgreSQL. <br><br>  En conclusion, je voudrais noter que les capacitÃ©s de diagnostic et d'optimisation ci-dessus ne sont que la pointe de l'iceberg, mais elles sont assez faciles Ã  utiliser et peuvent vous aider Ã  identifier rapidement le problÃ¨me directement sur les donnÃ©es opÃ©rationnelles sans risquer de gÃ¢cher la configuration ou de perturber le fonctionnement d'autres applications. <br><br>  EnquÃªtes rÃ©ussies, avec des plans prÃ©cis et courts. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443276/">https://habr.com/ru/post/fr443276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443266/index.html">Comment nous avons contribuÃ© Ã  transformer le travail de comptabilitÃ© dans une grande entreprise Ã©nergÃ©tique</a></li>
<li><a href="../fr443268/index.html">Post mortem: suivez le middleware ou comment nous avons rompu les commentaires</a></li>
<li><a href="../fr443270/index.html">L'annonce de Sony Xperia 1: un nouveau concept phare</a></li>
<li><a href="../fr443272/index.html">Le mythe des parasites nichromes</a></li>
<li><a href="../fr443274/index.html">Compilation de nouvelles sur l'industrie du jeu du 8 mars au dimanche</a></li>
<li><a href="../fr443278/index.html">Le crypto-Ã©change Coinbase perd des utilisateurs en raison de l'achat d'une startup pour les crÃ©ateurs de logiciels espions de la Hacking Team</a></li>
<li><a href="../fr443280/index.html">L'histoire de la faÃ§on dont j'ai assemblÃ© un home cinÃ©ma de 120 pouces Ã  partir de tuyaux, de cordes, d'un Ã©cran pliant et de velours noir</a></li>
<li><a href="../fr443282/index.html">Que devons-nous construire une blockchain?</a></li>
<li><a href="../fr443284/index.html">Index dans PostgreSQL - 4 (Btree)</a></li>
<li><a href="../fr443286/index.html">TDMS Fairway. MÃ©canisme de remplissage automatique pour les principales inscriptions sur les dessins et les dÃ©tails des documents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>