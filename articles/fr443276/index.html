<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜüèº üõÖ üî© Planificateur de requ√™tes surprise dans la base de donn√©es PostgreSQL ‚è™ üéÄ üö¥üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Graphiques, rapports et analyses - tout cela est en quelque sorte pr√©sent dans le back-office de toute entreprise, m√™me tr√®s petite. Lorsqu'elles sont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Planificateur de requ√™tes surprise dans la base de donn√©es PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/443276/">  Graphiques, rapports et analyses - tout cela est en quelque sorte pr√©sent dans le back-office de toute entreprise, m√™me tr√®s petite.  Lorsqu'elles sont encombr√©es dans des tableaux r√©guliers dans Excel / Numbers / Libre, mais que les donn√©es ne sont toujours pas tr√®s volumineuses, les solutions traditionnelles pour les besoins internes de l'entreprise sont souvent construites √† l'aide de bases de donn√©es relationnelles telles que PostgreSQL, MySQL ou MariaDB. <br><br>  Ces bases de donn√©es sont gratuites, gr√¢ce √† SQL, elles peuvent facilement s'int√©grer √† d'autres composants du syst√®me, elles sont populaires et la plupart des d√©veloppeurs et des analystes peuvent travailler avec elles.  La charge (trafic et volumes) qu'ils peuvent dig√©rer est suffisamment volumineuse pour tenir facilement jusqu'√† ce que l'entreprise puisse se permettre des solutions plus complexes (et co√ªteuses) pour les analyses et les rapports. <br><a name="habracut"></a><br><h4>  Position de d√©part </h4><br>  Cependant, m√™me dans une technologie qui a √©t√© √©tudi√©e √† plusieurs reprises, il y a toujours diff√©rentes nuances qui peuvent soudainement ajouter aux soucis des ing√©nieurs.  En plus de la fiabilit√©, le probl√®me le plus fr√©quemment mentionn√© avec les bases de donn√©es est leur performance.  De toute √©vidence, avec une augmentation de la quantit√© de donn√©es, le taux de r√©ponse DB diminue, mais si cela se produit de mani√®re pr√©visible et est coh√©rent avec l'augmentation de la charge, alors ce n'est pas si mal.  Vous pouvez toujours voir √† l'avance quand la base de donn√©es commence √† exiger de l'attention et planifier une mise √† niveau ou une transition vers une base de donn√©es fondamentalement diff√©rente.  Bien pire si les performances de la base de donn√©es se d√©gradent de mani√®re impr√©visible. <br><br>  Le sujet de l'am√©lioration des performances des bases de donn√©es est aussi ancien que le monde et tr√®s vaste, et dans cet article, je voudrais me concentrer sur une seule direction.  √Ä savoir, sur l'√©valuation de l'efficacit√© des plans de requ√™te dans une base de donn√©es PostgreSQL, ainsi que sur la modification de cette efficacit√© au fil du temps pour rendre le comportement du planificateur de base de donn√©es plus pr√©visible. <br><br>  Malgr√© le fait que bon nombre des √©l√©ments qui seront discut√©s s'appliquent √† toutes les versions r√©centes de cette base de donn√©es, les exemples ci-dessous correspondent √† la version 11.2, cette derni√®re pour le moment. <br>  Avant de plonger dans les d√©tails, il est logique de faire une digression et de dire quelques mots sur l'origine des probl√®mes de performances dans les bases de donn√©es relationnelles.  De quoi s'occupe exactement la base de donn√©es lorsqu'elle "ralentit"?  Le manque de m√©moire (un grand nombre d'acc√®s au disque ou au r√©seau), un processeur faible, ce sont tous des probl√®mes √©vidents avec des solutions claires, mais quoi d'autre peut affecter la vitesse d'ex√©cution des requ√™tes? <br><br><h4>  Rafra√Æchissez vos souvenirs </h4><br>  Pour que la base de donn√©es r√©ponde √† la requ√™te SQL, elle doit cr√©er un plan de requ√™te (dans quelles tables et colonnes pour voir quels index sont n√©cessaires, quoi choisir √† partir de l√†, avec quoi comparer, combien de m√©moire est requise, etc.).  Ce plan est form√© sous la forme d'un arbre, dont les n≈ìuds ne sont que quelques op√©rations typiques, avec une complexit√© de calcul diff√©rente.  En voici quelques-unes, par exemple (N est le nombre de lignes avec lesquelles effectuer l'op√©ration): <br><br><table><thead><tr><th>  <nobr>Fonctionnement</nobr> </th><th>  Que fait-on </th><th>  Co√ªt </th></tr></thead><tbody><tr><td colspan="3">  <i><font color="#999">SELECT ... WHERE ... op√©rations de r√©cup√©ration de donn√©es</font></i> </td></tr><tr><td>  <nobr>Scan Seq</nobr> </td><td>  Nous chargeons chaque ligne du tableau et v√©rifions l'√©tat. </td><td>  O (N) </td></tr><tr><td>  <nobr>Balayage d'index</nobr> <br>  (indice b-tree) </td><td>  Les donn√©es sont directement dans l'index, nous recherchons donc par condition les √©l√©ments n√©cessaires de l'index et prenons les donn√©es √† partir de l√†. </td><td>  O (log (N)), recherche un √©l√©ment dans une arborescence tri√©e. </td></tr><tr><td>  <nobr>Balayage d'index</nobr> <br>  (indice de hachage) </td><td>  Les donn√©es sont directement dans l'index, nous recherchons donc par condition les √©l√©ments n√©cessaires de l'index et prenons les donn√©es √† partir de l√†. </td><td>  O (1), recherche d'un √©l√©ment dans une table de hachage, √† l'exclusion du co√ªt de cr√©ation de hachages </td></tr><tr><td>  Analyse de tas de bitmap </td><td>  Nous s√©lectionnons les num√©ros des lignes n√©cessaires par index, puis nous chargeons uniquement les lignes n√©cessaires et effectuons avec eux des contr√¥les suppl√©mentaires. </td><td>  Scan Index + Scan Seq (M), <br>  O√π M est le nombre de lignes trouv√©es apr√®s le balayage d'index.  On suppose que M &lt;&lt; N, c'est-√†-dire  index est plus utile que Seq Scan. </td></tr><tr><td colspan="3">  <i><font color="#999">Op√©rations de jointure (JOIN, SELECT √† partir de plusieurs tables)</font></i> </td></tr><tr><td>  Boucle imbriqu√©e </td><td>  Pour chaque ligne du tableau de gauche, recherchez une ligne appropri√©e dans le tableau de droite. </td><td>  O (N <sup>2</sup> ). <br>  Mais si l'un des tableaux est beaucoup plus petit que l'autre (dictionnaire) et ne cro√Æt pratiquement pas avec le temps, alors le co√ªt r√©el peut diminuer jusqu'√† O (N). </td></tr><tr><td>  Hash Join </td><td>  Pour chaque ligne des tableaux de gauche et de droite, nous consid√©rons le hachage, ce qui r√©duit le nombre de recherches d'options de connexion possibles. </td><td>  O (N), mais dans le cas d'une fonction de hachage tr√®s inefficace ou d'un grand nombre de champs identiques pour la connexion, il peut y avoir O (N <sup>2</sup> ) </td></tr><tr><td>  Fusionner la jointure </td><td>  Par condition, nous trions les tableaux de gauche et de droite, apr√®s quoi nous combinons les deux listes tri√©es </td><td>  O (N * log (N)) <br>  Co√ªts de tri + parcourir la liste. </td></tr><tr><td colspan="3">  <i><font color="#999">Op√©rations d'agr√©gation (GROUP BY, DISTINCT)</font></i> </td></tr><tr><td>  Agr√©gat de groupe </td><td>  Nous trions la table en fonction de la condition d'agr√©gation, puis dans la liste tri√©e, nous groupons les lignes adjacentes. </td><td>  O (N * log (N)) </td></tr><tr><td>  Agr√©gat de hachage </td><td>  Nous consid√©rons le hachage pour la condition d'agr√©gation pour chaque ligne.  Pour les lignes avec le m√™me hachage, nous effectuons une agr√©gation. </td><td>  O (N) </td></tr></tbody></table><br>  Comme vous pouvez le voir, le co√ªt d'une requ√™te d√©pend beaucoup de la fa√ßon dont les donn√©es sont situ√©es dans les tables et de la fa√ßon dont cet ordre correspond aux op√©rations de hachage utilis√©es.  La boucle imbriqu√©e, malgr√© son co√ªt en O (N <sup>2</sup> ), peut √™tre plus rentable que Hash Join ou Merge Join lorsque l'une des tables jointes d√©g√©n√®re en une ou plusieurs lignes. <br><br>  En plus des ressources CPU, le co√ªt comprend √©galement l'utilisation de la m√©moire.  Les deux √©tant des ressources limit√©es, le planificateur de requ√™tes doit trouver un compromis.  Si deux tables sont math√©matiquement plus rentables √† joindre via une jointure par hachage, mais qu'il n'y a tout simplement pas de place en m√©moire pour une si grande table de hachage, la base de donn√©es peut √™tre forc√©e d'utiliser la fusion par jointure, par exemple.  Une boucle imbriqu√©e "lente" ne n√©cessite g√©n√©ralement pas de m√©moire suppl√©mentaire et est pr√™te √† produire des r√©sultats juste apr√®s le lancement. <br><br>  Le co√ªt relatif de ces op√©rations appara√Æt plus clairement sur le graphique.  Ce ne sont pas des nombres absolus, juste un rapport approximatif de diff√©rentes op√©rations. <br><br><img src="https://habrastorage.org/webt/9f/p_/mx/9fp_mx7mhhd5kgokxbqeu-kxpfa.png"><br><br>  Le graphique de boucle imbriqu√©e "commence" ci-dessous, car  il ne n√©cessite pas de calculs suppl√©mentaires, d'allocation de m√©moire ou de copie de donn√©es interm√©diaires, mais il a un co√ªt O (N <sup>2</sup> ).  Merge Join et Hash Join ont des co√ªts initiaux plus √©lev√©s, cependant, apr√®s quelques valeurs N, ils commencent √† battre Nested Loop √† temps.  L'ordonnanceur essaie de choisir le plan avec le co√ªt le plus bas et sur le graphique ci-dessus adh√®re √† diff√©rentes op√©rations avec diff√©rents N (fl√®che verte en pointill√©s).  Avec le nombre de lignes jusqu'√† N1, il est plus rentable d'utiliser la boucle imbriqu√©e, de N1 √† N2, il est plus rentable de fusionner la jointure, puis apr√®s N2, il devient plus rentable pour Hash Join, mais Hash Join n√©cessite de la m√©moire pour cr√©er des tables de hachage.  Et lorsque vous atteignez N3, cette m√©moire devient insuffisante, ce qui conduit √† l'utilisation forc√©e de Fusionner Join. <br><br>  Lors du choix d'un plan, le planificateur estime le co√ªt de chaque op√©ration dans le plan en utilisant un ensemble de co√ªts relatifs de certaines op√©rations ¬´atomiques¬ª dans la base de donn√©es.  Comme, par exemple, des calculs, des comparaisons, le chargement d'une page en m√©moire, etc.  Voici une liste de certains de ces param√®tres de la configuration par d√©faut, il n'y en a pas beaucoup: <br><br><table><thead><tr><th>  Co√ªt relatif constant </th><th>  Valeur par d√©faut </th></tr></thead><tbody><tr><td>  seq_page_cost </td><td>  1.0 </td></tr><tr><td>  random_page_cost </td><td>  4,0 </td></tr><tr><td>  cpu_tuple_cost </td><td>  0,01 </td></tr><tr><td>  cpu_index_tuple_cost </td><td>  0,005 </td></tr><tr><td>  cpu_operator_cost </td><td>  0,0025 </td></tr><tr><td>  parallel_tuple_cost </td><td>  0,1 </td></tr><tr><td>  parallel_setup_cost </td><td>  1000,0 </td></tr></tbody></table><br>  Certes, ces constantes seules sont peu nombreuses, vous devez toujours conna√Ætre le ¬´N¬ª, c'est-√†-dire exactement combien de lignes des r√©sultats pr√©c√©dents devront √™tre trait√©es dans chacune de ces op√©rations.  La limite sup√©rieure est √©vidente ici - la base de donn√©es "sait" combien de donn√©es se trouve dans n'importe quelle table et peut toujours calculer "au maximum".  Par exemple, si vous avez deux tables de 100 lignes chacune, les joindre peut produire de 0 √† 10 000 lignes dans la sortie.  En cons√©quence, la prochaine op√©ration d'entr√©e peut avoir jusqu'√† 10 000 lignes. <br><br>  Mais si vous connaissez au moins un peu la nature des donn√©es des tableaux, ce nombre de lignes peut √™tre pr√©dit avec plus de pr√©cision.  Par exemple, pour deux tables de 100 lignes de l'exemple ci-dessus, si vous savez √† l'avance que la jointure ne produira pas 10 000 lignes, mais les 100 m√™mes, le co√ªt estim√© de la prochaine op√©ration est consid√©rablement r√©duit.  Dans ce cas, ce plan pourrait √™tre plus efficace que d'autres. <br><br><h4>  Optimisation pr√™te √† l'emploi </h4><br>  Pour que l'ordonnanceur puisse pr√©dire plus pr√©cis√©ment la taille des r√©sultats interm√©diaires, PostgreSQL utilise la collecte de statistiques sur les tables, qui est accumul√©e dans pg_statistic, ou dans sa version plus lisible - dans pg_stats.  Il est mis √† jour automatiquement au d√©marrage du vide, ou explicitement avec la commande ANALYSER.  Ce tableau stocke une vari√©t√© d'informations sur les donn√©es et le type de nature contenus dans les tableaux.  En particulier, histogrammes de valeurs, pourcentage de champs vides et autres informations.  Le planificateur utilise tout cela pour pr√©dire avec plus de pr√©cision la quantit√© de donn√©es pour chaque op√©ration dans l'arborescence du plan, et ainsi calculer plus pr√©cis√©ment le co√ªt des op√©rations et le plan dans son ensemble. <br><br>  Prenons par exemple la requ√™te: <br><pre><code class="plaintext hljs">SELECT t1.important_value FROM t1 WHERE t1.a &gt; 100</code> </pre> <br><br>  Supposons que l'histogramme des valeurs de la colonne ¬´t1.a¬ª r√©v√®le que des valeurs sup√©rieures √† 100 se trouvent dans environ 1% des lignes du tableau.  Nous pouvons alors pr√©dire qu'un tel √©chantillon renverra environ un centi√®me de toutes les lignes du tableau ¬´t1¬ª. <br>  La base de donn√©es vous donne la possibilit√© de consulter le co√ªt pr√©vu du plan via la commande EXPLAIN et l'heure r√©elle de son fonctionnement - en utilisant EXPLAIN ANALYZE. <br><br>  Il semble qu'avec les statistiques automatiques, tout devrait bien se passer maintenant, mais il peut y avoir des difficult√©s.  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon article</a> √† ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Citus Data</a> , avec un exemple de l'inefficacit√© des statistiques automatiques et de la collecte de statistiques suppl√©mentaires √† l'aide de CREATE STATISTICS (disponible avec PG 10.0). <br><br>  Ainsi, pour l'ordonnanceur, il existe deux sources d'erreurs dans le calcul des co√ªts: <br><br><ol><li>  Le co√ªt relatif des op√©rations primitives (seq_page_cost, cpu_operator_cost, etc.) par d√©faut peut √™tre tr√®s diff√©rent de la r√©alit√© (co√ªt du processeur 0,01, co√ªt de chargement de la page srq - 1 ou 4 pour le chargement de page al√©atoire).  Loin du fait que 100 comparaisons seront √©gales √† 1 page de chargement. </li><li>  Erreur lors de la pr√©vision du nombre de lignes dans les op√©rations interm√©diaires.  Le co√ªt r√©el de l'op√©ration dans ce cas peut √™tre tr√®s diff√©rent de la pr√©vision. </li></ol><br>  Dans les requ√™tes complexes, l'√©laboration et la pr√©vision de tous les plans possibles peuvent prendre beaucoup de temps en soi.  Quelle est l'utilit√© de renvoyer des donn√©es en 1 seconde si la base de donn√©es ne pr√©voyait qu'une minute de requ√™te?  PostgreSQL dispose d'un optimiseur Geqo pour cette situation; c'est un planificateur qui ne construit pas tous les plans possibles, mais commence par quelques plans al√©atoires et compl√®te les meilleurs, en pr√©disant les moyens de r√©duire les co√ªts.  Tout cela n'am√©liore pas non plus la pr√©cision des pr√©visions, bien qu'il acc√©l√®re la recherche d'au moins un plan plus ou moins optimal. <br><br><h4>  Plans soudains - concurrents </h4><br>  Si tout se passe bien, votre demande est satisfaite dans les plus brefs d√©lais.  √Ä mesure que la quantit√© de donn√©es augmente, la vitesse d'ex√©cution des requ√™tes dans la base de donn√©es augmente progressivement, et apr√®s un certain temps, en l'observant, vous pouvez pr√©dire √† peu pr√®s quand il sera n√©cessaire d'augmenter la m√©moire ou le nombre de c≈ìurs de processeur ou d'√©tendre le cluster, etc. <br><br>  Mais nous devons tenir compte du fait que le plan optimal a des concurrents avec des co√ªts d'ex√©cution proches, ce que nous ne voyons pas.  Et si la base de donn√©es change soudainement le plan de requ√™te en un autre, cela surprend.  C'est bien si la base de donn√©es passe √† un plan plus efficace.  Et sinon?  Regardons l'image, par exemple.  Il s'agit du co√ªt pr√©vu et en temps r√©el de la mise en ≈ìuvre de deux plans (rouge et vert): <br><br><img src="https://habrastorage.org/webt/an/0e/t1/an0et1smgdhh60caqa4yltzgiu4.png"><br><br>  Ici, un plan est affich√© en vert et son ¬´concurrent¬ª le plus proche en rouge.  La ligne pointill√©e montre un graphique des co√ªts projet√©s, la ligne continue est le temps r√©el.  La fl√®che grise en pointill√©s montre la s√©lection du planificateur. <br><br>  Supposons qu'un beau vendredi soir, le nombre pr√©vu de lignes dans une op√©ration interm√©diaire atteigne N1 et la pr√©vision ¬´rouge¬ª commence √† surpasser la pr√©vision ¬´verte¬ª.  Le planificateur commence √† l'utiliser.  Le temps d'ex√©cution r√©el de la requ√™te saute imm√©diatement (passage d'une ligne continue verte √† une ligne rouge), c'est-√†-dire que le calendrier de d√©gradation de la base de donn√©es prend la forme d'une √©tape (ou peut-√™tre d'un ¬´mur¬ª).  En pratique, un tel ¬´mur¬ª peut augmenter le temps d'ex√©cution des requ√™tes d'un ordre de grandeur ou plus. <br><br>  Il convient de noter que cette situation est probablement plus typique pour le back-office et l'analyse que pour le front-end, car ce dernier est g√©n√©ralement adapt√© √† des requ√™tes plus simultan√©es et, par cons√©quent, utilise des requ√™tes plus simples dans la base de donn√©es, o√π l'erreur dans les pr√©visions de plan est moindre.  S'il s'agit d'une base de donn√©es pour le reporting ou l'analyse, les requ√™tes peuvent √™tre arbitrairement complexes. <br><br><h4>  Comment vivre avec √ßa? </h4><br>  La question se pose: √©tait-il possible d'une mani√®re ou d'une autre de pr√©voir de tels plans invisibles ¬´sous-marins¬ª?  Apr√®s tout, le probl√®me n'est pas qu'ils ne sont pas optimaux, mais que le passage √† un autre plan peut se produire de mani√®re impr√©visible et, selon la loi de la m√©chancet√©, au moment le plus malheureux pour cela. <br><br>  Malheureusement, vous ne pouvez pas les voir directement, mais vous pouvez rechercher des plans alternatifs en modifiant les poids r√©els selon lesquels ils sont s√©lectionn√©s.  Le sens de cette approche est de supprimer de la vue le plan actuel, que l'ordonnanceur consid√®re optimal, de sorte qu'un de ses plus proches concurrents devienne optimal, et ainsi, il pourrait √™tre vu √† travers l'√©quipe EXPLAIN.  En v√©rifiant p√©riodiquement les changements de co√ªts dans ces ¬´concurrents¬ª et dans le plan principal, vous pouvez √©valuer la probabilit√© que la base de donn√©es ¬´passe¬ª bient√¥t √† un autre plan. <br><br>  En plus de collecter des donn√©es sur les pr√©visions de plans alternatifs, vous pouvez les ex√©cuter et mesurer leurs performances, ce qui donne √©galement une id√©e du ¬´bien-√™tre¬ª interne de la base de donn√©es. <br>  Voyons quels outils nous avons pour de telles exp√©riences. <br><br>  Tout d'abord, vous pouvez explicitement ¬´interdire¬ª des op√©rations sp√©cifiques √† l'aide de variables de session.  Id√©alement, ils n'ont pas besoin d'√™tre modifi√©s dans la configuration et de recharger la base de donn√©es, leur valeur ne change que dans la session ouverte en cours et n'affecte pas les autres sessions, vous pouvez donc exp√©rimenter directement avec des donn√©es r√©elles.  Voici une liste d'entre eux avec des valeurs par d√©faut.  Presque toutes les op√©rations sont incluses: <br><table><thead><tr><th>  Op√©rations utilis√©es </th><th>  Valeur par d√©faut </th></tr></thead><tbody><tr><td>  enable_bitmapscan <br>  enable_hashagg <br>  enable_hashjoin <br>  enable_indexscan <br>  enable_indexonlyscan <br>  enable_material <br>  enable_mergejoin <br>  enable_nestloop <br>  enable_parallel_append <br>  enable_seqscan <br>  enable_sort <br>  enable_tidscan <br>  enable_parallel_hash <br>  enable_partition_pruning </td><td>  sur </td></tr><tr><td>  enable_partitionwise_join <br>  enable_partitionwise_aggregate </td><td>  √©teint </td></tr></tbody></table><br>  En interdisant ou en autorisant certaines op√©rations, nous for√ßons le planificateur √† s√©lectionner d'autres plans que nous pouvons voir avec la m√™me commande EXPLAIN.  En fait, l '¬´interdiction¬ª des op√©rations n'interdit pas leur utilisation, mais augmente simplement consid√©rablement leur co√ªt.  Dans PostgreSQL, chaque op√©ration ¬´interdite¬ª empile automatiquement un co√ªt √©gal √† 10 milliards d'unit√©s conventionnelles.  De plus, dans EXPLAIN, le poids total du plan peut s'av√©rer prohibitif, mais dans le contexte de ces dizaines de milliards, le poids des op√©rations restantes est clairement visible, car il s'inscrit g√©n√©ralement dans des commandes plus petites. <br><br>  Deux des op√©rations suivantes sont particuli√®rement int√©ressantes: <br><br><ul><li>  <strong>Hash Join.</strong>  Sa complexit√© est O (N), mais avec une erreur avec une pr√©vision du montant du r√©sultat, vous ne pouvez pas tenir en m√©moire et vous devrez faire Merge Join, avec un co√ªt de O (N * log (N)). </li><li>  <strong>Boucle imbriqu√©e.</strong>  Sa complexit√© est O (N <sup>2</sup> ), par cons√©quent, l'erreur dans la pr√©vision de taille affecte de mani√®re quadratique la vitesse d'une telle connexion. </li></ul><br>  Par exemple, prenons quelques chiffres r√©els √† partir de requ√™tes, dont l'optimisation √©tait engag√©e dans notre entreprise. <br><br>  <strong><u>Plan 1.</u></strong> Avec toutes les op√©rations autoris√©es, le co√ªt total du plan le plus optimal √©tait de 274962,09 unit√©s. <br><br>  <strong><u>Plan 2.</u></strong> Avec la boucle imbriqu√©e ¬´interdite¬ª, le co√ªt est pass√© √† 40000534153.85.  Ces 40 milliards qui constituent l'essentiel du co√ªt repr√©sentent 4 fois la boucle imbriqu√©e utilis√©e, malgr√© l'interdiction.  Et les 534153.85 restants - c'est pr√©cis√©ment la pr√©vision du co√ªt de toutes les autres op√©rations du plan.  Il est, comme nous le voyons, environ 2 fois plus √©lev√© que le co√ªt du plan optimal, c'est-√†-dire qu'il est assez proche de lui. <br><br>  <strong><u>Plan 3.</u></strong> Avec le Hash Join ¬´interdit¬ª, le co√ªt √©tait de 383253,77.  Le plan a vraiment √©t√© fait sans utiliser l'op√©ration Hash Join, car nous ne voyons aucun milliard.  Son co√ªt est cependant 30% plus √©lev√© que celui de l'optimum, qui est √©galement tr√®s proche. <br><br>  En r√©alit√©, les temps d'ex√©cution des requ√™tes √©taient les suivants: <br><br>  <strong><u>Plan 1</u></strong> (toutes les op√©rations autoris√©es) termin√© en ~ 9 minutes. <br>  <strong><u>Plan 2</u></strong> (avec la boucle imbriqu√©e ¬´interdite¬ª) termin√© en 1,5 seconde. <br>  <strong><u>Le plan 3</u></strong> (avec une jointure de hachage ¬´interdite¬ª) a √©t√© achev√© en ~ 5 minutes. <br><br>  La raison, comme vous pouvez le voir, est la pr√©vision erron√©e du co√ªt de la boucle imbriqu√©e.  En effet, en comparant EXPLAIN avec EXPLAIN ANALYZE, une erreur y est d√©tect√©e avec la d√©finition de ce N malheureux dans l'op√©ration interm√©diaire.  Au lieu d'une seule ligne pr√©dite, la boucle imbriqu√©e a rencontr√© plusieurs milliers de lignes, ce qui a entra√Æn√© une augmentation du couple d'ex√©cution de la requ√™te de quelques ordres de grandeur. <br><br>  Les √©conomies r√©alis√©es avec la jointure de hachage ¬´interdite¬ª sont associ√©es au remplacement du hachage par le tri et la fusion de jointure, qui fonctionnaient plus rapidement dans ce cas que la jointure de hachage.  A noter que ce plan 2 est en r√©alit√© presque deux fois plus rapide que le plan "optimal" 1. Bien qu'il ait √©t√© pr√©vu qu'il sera plus lent. <br><br>  En pratique, si votre demande soudainement (apr√®s une mise √† niveau de la base de donn√©es ou tout simplement) a commenc√© √† s'ex√©cuter beaucoup plus longtemps qu'auparavant, essayez d'abord de refuser la jointure par hachage ou la boucle imbriqu√©e et voyez comment cela affecte la vitesse de la requ√™te.  Dans un cas r√©ussi, vous pourrez au moins interdire un nouveau plan non optimal et revenir au pr√©c√©dent rapidement. <br><br>  Pour ce faire, vous n'avez pas besoin de modifier les fichiers de configuration de PostgreSQL avec un red√©marrage de la base de donn√©es, il est assez simple dans n'importe quelle console de changer la valeur de la variable souhait√©e pour une session ouverte √† partir de la base de donn√©es.  Les sessions restantes ne seront pas affect√©es, la configuration ne changera que pour votre session actuelle.  Par exemple, comme ceci: <br><br><pre> <code class="plaintext hljs">SET enable_hashjoin='on'; SET enable_nestloop='off'; SELECT ‚Ä¶ FROM ‚Ä¶ (    )</code> </pre><br>  La deuxi√®me fa√ßon d'influencer le choix du plan consiste √† modifier le poids des op√©rations de bas niveau.  Il n'y a pas de recette universelle ici, mais, par exemple, si vous avez une base de donn√©es avec un cache ¬´r√©chauff√©¬ª et que toutes les donn√©es sont stock√©es en m√©moire, il est probable que le co√ªt du chargement de page s√©quentiel ne diff√®re pas du co√ªt de chargement d'une page al√©atoire.  Alors que dans la configuration par d√©faut, random est 4 fois plus cher que s√©quentiel. <br><br>  Ou, un autre exemple, le co√ªt conditionnel de l'ex√©cution du traitement parall√®le est de 1000 par d√©faut, tandis que le co√ªt de chargement d'une page est de 1,0.  Il est logique de commencer par modifier un seul des param√®tres √† la fois pour d√©terminer si cela affecte le choix du plan.  Le moyen le plus simple consiste √† commencer par d√©finir le param√®tre sur 0 ou sur une valeur √©lev√©e (1 million). <br><br>  Cependant, gardez √† l'esprit qu'en am√©liorant les performances d'une demande, vous pouvez les d√©grader dans une autre.  En g√©n√©ral, il existe un large champ d'exp√©riences.  Il vaut mieux essayer de les changer un √† la fois, un √† la fois. <br><br><h4>  Options alternatives de traitement </h4><br>  Une histoire sur un planificateur serait incompl√®te sans mentionner au moins deux extensions PostgreSQL. <br><br>  Le premier est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SR_PLAN</a> , pour enregistrer le plan calcul√© et forcer son utilisation ult√©rieure.  Cela permet de rendre le comportement de la base de donn√©es plus pr√©visible en termes de choix de plan. <br><br>  Le second est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Adaptive Query Optimizer</a> , qui impl√©mente le feedback au planificateur √† partir de l'ex√©cution en temps r√©el de la requ√™te, c'est-√†-dire que le planificateur mesure les r√©sultats r√©els de la requ√™te ex√©cut√©e et ajuste ses plans √† l'avenir en gardant cela √† l'esprit.  La base de donn√©es est ainsi "auto-ajust√©e" pour des donn√©es et des requ√™tes sp√©cifiques. <br><br><h4>  Que fait d'autre la base de donn√©es lorsqu'elle ralentit? </h4><br>  Maintenant que nous avons plus ou moins tri√© la planification des requ√™tes, nous verrons ce qui peut √™tre am√©lior√© √† la fois dans la base de donn√©es elle-m√™me et dans les applications qui l'utilisent pour en tirer le maximum de performances. <br><br>  Supposons que le plan de requ√™te soit d√©j√† optimal.  Si nous excluons les probl√®mes les plus √©vidents (m√©moire insuffisante ou disque / r√©seau lent), il y a encore des co√ªts pour le calcul des hachages.  Il existe probablement de grandes opportunit√©s pour de futures am√©liorations de PostgreSQL (en utilisant le GPU ou m√™me les instructions SSE2 / SSE3 / AVX du CPU), mais jusqu'√† pr√©sent, cela n'a pas √©t√© fait et les calculs de hachage n'utilisent presque jamais les capacit√©s mat√©rielles du mat√©riel.  Vous pouvez aider un peu dans cette base de donn√©es. <br><br>  Si vous remarquez, par d√©faut, les index dans PostgreSQL sont cr√©√©s en tant que b-tree.  Leur utilit√© est qu'ils sont assez polyvalents.  Un tel indice peut √™tre utilis√© √† la fois avec des conditions d'√©galit√© et avec des conditions de comparaison (plus ou moins).  Trouver un √©l√©ment dans un tel index est un co√ªt logarithmique.  Mais si votre requ√™te contient uniquement une condition d'√©galit√©, des index peuvent √©galement √™tre cr√©√©s en tant qu'index de hachage, dont le co√ªt est constant. <br><br>  De plus, vous pouvez toujours essayer de modifier la demande afin d'utiliser son ex√©cution parall√®le.  Pour comprendre exactement comment le r√©√©crire, il est pr√©f√©rable de vous familiariser avec la liste des cas o√π le parall√©lisme est automatiquement interdit par le planificateur et d'√©viter de telles situations.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le manuel</a> sur ce sujet d√©crit bri√®vement toutes les situations, il est donc inutile de les r√©p√©ter ici. <br><br>  Que faire si la demande ne parvient toujours pas √† faire le parall√®le?  Il est tr√®s triste de voir comment, dans votre puissante base de donn√©es multic≈ìur, o√π vous √™tes le seul client, un c≈ìur est occup√© √† 100% et tous les autres noyaux le regardent.  Dans ce cas, vous devez aider la base de donn√©es du c√¥t√© de l'application.  √âtant donn√© que chaque session est affect√©e √† son propre noyau, vous pouvez en ouvrir plusieurs et diviser la requ√™te g√©n√©rale en parties, en effectuant des s√©lections plus courtes et plus rapides, en les combinant en un r√©sultat commun d√©j√† dans l'application.  Cela occupera le maximum de ressources CPU disponibles dans la base de donn√©es PostgreSQL. <br><br>  En conclusion, je voudrais noter que les capacit√©s de diagnostic et d'optimisation ci-dessus ne sont que la pointe de l'iceberg, mais elles sont assez faciles √† utiliser et peuvent vous aider √† identifier rapidement le probl√®me directement sur les donn√©es op√©rationnelles sans risquer de g√¢cher la configuration ou de perturber le fonctionnement d'autres applications. <br><br>  Enqu√™tes r√©ussies, avec des plans pr√©cis et courts. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443276/">https://habr.com/ru/post/fr443276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443266/index.html">Comment nous avons contribu√© √† transformer le travail de comptabilit√© dans une grande entreprise √©nerg√©tique</a></li>
<li><a href="../fr443268/index.html">Post mortem: suivez le middleware ou comment nous avons rompu les commentaires</a></li>
<li><a href="../fr443270/index.html">L'annonce de Sony Xperia 1: un nouveau concept phare</a></li>
<li><a href="../fr443272/index.html">Le mythe des parasites nichromes</a></li>
<li><a href="../fr443274/index.html">Compilation de nouvelles sur l'industrie du jeu du 8 mars au dimanche</a></li>
<li><a href="../fr443278/index.html">Le crypto-√©change Coinbase perd des utilisateurs en raison de l'achat d'une startup pour les cr√©ateurs de logiciels espions de la Hacking Team</a></li>
<li><a href="../fr443280/index.html">L'histoire de la fa√ßon dont j'ai assembl√© un home cin√©ma de 120 pouces √† partir de tuyaux, de cordes, d'un √©cran pliant et de velours noir</a></li>
<li><a href="../fr443282/index.html">Que devons-nous construire une blockchain?</a></li>
<li><a href="../fr443284/index.html">Index dans PostgreSQL - 4 (Btree)</a></li>
<li><a href="../fr443286/index.html">TDMS Fairway. M√©canisme de remplissage automatique pour les principales inscriptions sur les dessins et les d√©tails des documents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>