<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìò ‚å®Ô∏è üå∂Ô∏è Suche mit 1 TB / s üé® üî´ ü§π</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR: Vor vier Jahren verlie√ü ich Google mit der Idee eines neuen Tools zur √úberwachung von Servern. Die Idee war, die normalerweise isolierten Funk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suche mit 1 TB / s</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445456/"> TL; DR: Vor vier Jahren verlie√ü ich Google mit der Idee eines neuen Tools zur √úberwachung von Servern.  Die Idee war, die normalerweise isolierten Funktionen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sammelns</a> und Analysierens von Protokollen, Sammeln von Metriken, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warnungen</a> und eines Dashboards in einem Dienst zu kombinieren.  Eines der Prinzipien - der Service sollte sehr <i>schnell sein</i> und den Entwicklern einen einfachen, interaktiven und unterhaltsamen Job bieten.  Dies erfordert die Verarbeitung von Datens√§tzen mit mehreren Gigabyte in Sekundenbruchteilen, ohne das Budget zu √ºberschreiten.  Bestehende Tools f√ºr die Arbeit mit Protokollen sind oft langsam und ungeschickt, daher standen wir vor einer guten Aufgabe: ein Tool richtig zu entwickeln, um den Benutzern neue Empfindungen bei der Arbeit zu vermitteln. <br><br>  Dieser Artikel beschreibt, wie wir bei Scalyr dieses Problem gel√∂st haben, indem wir die Methoden der alten Schule, den Brute-Force-Ansatz, die Beseitigung redundanter Schichten und die Vermeidung komplexer Datenstrukturen angewendet haben.  Sie k√∂nnen diese Lektionen auf Ihre eigenen technischen Aufgaben anwenden. <br><a name="habracut"></a><br><h1>  Die St√§rke der alten Schule </h1><br>  Die Protokollanalyse beginnt normalerweise mit einer Suche: Finden Sie alle Nachrichten, die einer bestimmten Vorlage entsprechen.  In Scalyr sind dies Dutzende oder Hunderte von Gigabyte an Protokollen von vielen Servern.  Moderne Ans√§tze beinhalten in der Regel den Aufbau einer komplexen Datenstruktur, die f√ºr die Suche optimiert ist.  Nat√ºrlich habe ich das bei Google gesehen, wo sie in solchen Dingen ziemlich gut sind.  Wir haben uns jedoch f√ºr einen viel gr√∂beren Ansatz entschieden: das lineare Scannen von Protokollen.  Und es hat funktioniert - wir bieten eine Schnittstelle mit einer um eine Gr√∂√üenordnung schnelleren Suche als die der Konkurrenz (siehe Animation am Ende). <br><br>  Die wichtigste Erkenntnis ist, dass moderne Prozessoren in einfachen und unkomplizierten Vorg√§ngen sehr schnell sind.  Dies wird in komplexen, mehrschichtigen Systemen, die von der E / A-Geschwindigkeit und dem Netzwerkbetrieb abh√§ngen, leicht √ºbersehen, und solche Systeme sind heutzutage sehr verbreitet.  Aus diesem Grund haben wir ein Design entwickelt, das die Anzahl der Schichten und den √ºbersch√ºssigen M√ºll minimiert.  Bei mehreren parallelen Prozessoren und Servern erreicht die Suchgeschwindigkeit 1 TB pro Sekunde. <br><br>  Wichtigste Ergebnisse aus diesem Artikel: <br><br><ul><li>  Grobe Suche ist ein praktikabler Ansatz zur L√∂sung realer, gro√üer Probleme. <br></li><li>  Brute Force ist eine Designtechnik, keine Befreiung von der Arbeit.  Wie jede Technik ist sie f√ºr einige Probleme besser geeignet als f√ºr andere und kann schlecht oder gut implementiert werden. <br></li><li>  Brute Force ist besonders gut f√ºr eine <i>stabile</i> Leistung. <br></li><li>  Der effektive Einsatz von Brute Force erfordert eine Codeoptimierung und den rechtzeitigen Einsatz ausreichender Ressourcen.  Dies ist geeignet, wenn Ihre Server einer hohen Arbeitsbelastung durch Nichtbenutzer ausgesetzt sind und Benutzervorg√§nge weiterhin Priorit√§t haben. <br></li><li>  Die Leistung h√§ngt vom Design des gesamten Systems ab und nicht nur vom internen Schleifenalgorithmus. </li></ul><br>  (In diesem Artikel wird beschrieben, wie nach Daten im Speicher gesucht wird. In den meisten F√§llen, wenn ein Benutzer nach Protokollen sucht, haben Scalyr-Server diese bereits zwischengespeichert. Im n√§chsten Artikel wird die Suche nach nicht zwischengespeicherten Protokollen erl√§utert. Es gelten dieselben Prinzipien: Effizienter Code, Brute-Force-Methode mit gro√üem Rechenaufwand Ressourcen). <br><br><h1>  Brute-Force-Methode </h1><br>  Traditionell wird eine Suche in einem gro√üen Datensatz mithilfe eines Schl√ºsselwortindex durchgef√ºhrt.  In Bezug auf Serverprotokolle bedeutet dies, nach jedem eindeutigen Wort im Protokoll zu suchen.  F√ºr jedes Wort m√ºssen Sie eine Liste aller Einschl√ºsse erstellen.  Dies macht es einfach, alle Nachrichten mit diesem Wort zu finden, z. B. "Fehler", "Firefox" oder "Transaktion_16851951" - schauen Sie einfach in den Index. <br><br>  Ich habe diesen Ansatz bei Google verwendet und er hat gut funktioniert.  In Scalyr suchen wir in den Protokollen nach Byte f√ºr Byte. <br><br>  Warum?  Aus abstrakter algorithmischer Sicht sind Keyword-Indizes viel effektiver als eine grobe Suche.  Wir verkaufen jedoch keine Algorithmen, sondern Leistung.  Und Leistung ist nicht nur Algorithmen, sondern auch Systemtechnik.  Wir m√ºssen alles ber√ºcksichtigen: die Datenmenge, die Art der Suche, die verf√ºgbare Hardware und den Softwarekontext.  Wir haben entschieden, dass f√ºr unser spezielles Problem eine Option wie 'grep' besser ist als ein Index. <br><br>  Indizes sind gro√üartig, haben aber Einschr√§nkungen.  Ein Wort ist leicht zu finden.  Das Auffinden von Nachrichten mit wenigen W√∂rtern wie "googlebot" und "404" ist jedoch bereits viel komplizierter.  Die Suche nach Phrasen wie "nicht erfasste Ausnahme" erfordert einen umst√§ndlicheren Index, der nicht nur alle Nachrichten mit diesem Wort, sondern auch die spezifische Position des Wortes aufzeichnet. <br><br>  Die eigentliche Schwierigkeit entsteht, wenn Sie nicht nach Worten suchen.  Angenommen, Sie m√∂chten sehen, wie viel Verkehr von Bots kommt.  Der erste Gedanke ist, die Protokolle nach dem Wort "Bot" zu durchsuchen.  So finden Sie einige Bots: Googlebot, Bingbot und viele andere.  Aber hier ist 'Bot' kein Wort, sondern ein Teil davon.  Wenn wir im Index nach "bot" suchen, finden wir keine Nachrichten mit dem Wort "Googlebot".  Wenn Sie jedes Wort im Index √ºberpr√ºfen und dann den Index nach den gefundenen Schl√ºsselw√∂rtern durchsuchen, wird die Suche erheblich verlangsamt.  Infolgedessen erlauben einige Programme zum Arbeiten mit Protokollen nicht die Suche in Teilen eines Wortes oder (bestenfalls) die Verwendung einer speziellen Syntax mit geringerer Leistung.  Das wollen wir vermeiden. <br><br>  Ein weiteres Problem ist die Zeichensetzung.  <code>50.168.29.7</code> Sie alle Anfragen von <code>50.168.29.7</code> ?  Was ist mit dem Debuggen von Protokollen, die <code>[error]</code> ?  Indizes √ºberspringen normalerweise die Interpunktion. <br><br>  Schlie√ülich lieben Ingenieure leistungsstarke Werkzeuge, und manchmal kann ein Problem nur mit einem regul√§ren Ausdruck gel√∂st werden.  Der Keyword-Index ist daf√ºr nicht sehr geeignet. <br><br>  Dar√ºber hinaus sind Indizes <i>komplex</i> .  Jede Nachricht muss mehreren Keyword-Listen hinzugef√ºgt werden.  Diese Listen sollten immer in einem suchfreundlichen Format aufbewahrt werden.  Abfragen mit Phrasen, Wortfragmenten oder regul√§ren Ausdr√ºcken m√ºssen in Operationen mit mehreren Listen √ºbersetzt und die Ergebnisse gescannt und kombiniert werden, um eine Ergebnismenge zu erhalten.  Im Kontext eines umfangreichen Mehrbenutzerdienstes f√ºhrt diese Komplexit√§t zu Leistungsproblemen, die bei der Analyse der Algorithmen nicht sichtbar sind. <br><br>  Schl√ºsselwortindizes nehmen ebenfalls viel Platz ein, und Speicher ist das Hauptkostenelement im Protokollverwaltungssystem. <br><br>  Andererseits kann f√ºr jede Suche viel Rechenleistung aufgewendet werden.  Unsere Benutzer sch√§tzen die schnelle Suche nach eindeutigen Abfragen, aber solche Abfragen sind relativ selten.  F√ºr typische Suchanfragen, zum Beispiel f√ºr das Dashboard, verwenden wir spezielle Techniken (wir werden sie im n√§chsten Artikel beschreiben).  Andere Abfragen sind recht selten, sodass Sie selten mehr als eine Abfrage gleichzeitig verarbeiten m√ºssen.  Dies bedeutet jedoch nicht, dass unsere Server nicht ausgelastet sind: Sie sind damit besch√§ftigt, neue Nachrichten zu empfangen, zu analysieren und zu komprimieren, Warnungen auszuwerten, alte Daten zu komprimieren usw.  Somit verf√ºgen wir √ºber ein ziemlich umfangreiches Angebot an Prozessoren, mit denen Anforderungen erf√ºllt werden k√∂nnen. <br><br><h1>  Brute Force funktioniert, wenn Sie ein Brute Force-Problem haben (und viel Gewalt). </h1><br>  Brute Force eignet sich am besten f√ºr einfache Aufgaben mit kleinen internen Schleifen.  Oft k√∂nnen Sie die innere Schleife optimieren, um mit sehr hohen Geschwindigkeiten zu arbeiten.  Wenn der Code komplex ist, ist es viel schwieriger, ihn zu optimieren. <br><br>  Anfangs hatte unser Suchcode eine ziemlich gro√üe innere Schleife.  Wir speichern Nachrichten auf 4K-Seiten.  Jede Seite enth√§lt einige Nachrichten (in UTF-8) und Metadaten f√ºr jede Nachricht.  Metadaten sind eine Struktur, in der die L√§nge des Werts, die interne Nachrichten-ID und andere Felder codiert sind.  Die Suchschleife sah folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/700/659/eb8/700659eb85e63ee1b7493c995ed8b235.png"><br><br>  Dies ist eine vereinfachte Option im Vergleich zum tats√§chlichen Code.  Aber auch hier sehen Sie mehrere Objektplatzierungen, Datenkopien und Funktionsaufrufe.  Die JVM optimiert Funktionsaufrufe ziemlich gut und weist kurzlebige Objekte zu, sodass dieser Code besser funktioniert hat, als wir es verdient haben.  W√§hrend des Tests haben Clients es ziemlich erfolgreich verwendet.  Aber am Ende sind wir auf eine neue Ebene gegangen. <br><br>  (Sie fragen sich m√∂glicherweise, warum wir Nachrichten in diesem Format mit 4K-Seiten, Text und Metadaten speichern, anstatt direkt mit den Protokollen zu arbeiten. Es gibt viele Gr√ºnde, warum die interne Scalyr-Engine eher einer verteilten Datenbank √§hnelt als Dateisystem Die Textsuche wird h√§ufig mit DBMS-Stilfiltern in den Feldern nach der Protokollanalyse kombiniert. Wir k√∂nnen viele tausend Protokolle gleichzeitig durchsuchen, und einfache Textdateien eignen sich nicht f√ºr unsere transaktionale, replizierte und verteilte Transaktionssteuerung  Daten). <br><br>  Anfangs schien ein solcher Code f√ºr die Optimierung nach der Brute-Force-Methode nicht sehr geeignet zu sein.  Der ‚Äûechte Job‚Äú in <code>String.indexOf()</code> dominierte nicht einmal das CPU-Profil.  Das hei√üt, eine Optimierung nur dieser Methode w√ºrde keinen signifikanten Effekt bringen. <br><br>  So kam es, dass wir Metadaten am Anfang jeder Seite speichern und der Text aller Nachrichten in UTF-8 am anderen Ende gepackt wird.  Aus diesem Grund haben wir die Suchschleife auf der gesamten Seite auf einmal neu geschrieben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc2/c88/cf3/cc2c88cf34b05cdc752c2a117fde8079.png"><br><br>  Diese Version arbeitet direkt mit der <code>raw byte[]</code> Ansicht <code>raw byte[]</code> und sucht auf der gesamten 4K-Seite gleichzeitig nach allen Nachrichten. <br><br>  Dies ist viel einfacher f√ºr Brute Force zu optimieren.  Der interne Suchzyklus wird gleichzeitig f√ºr die gesamte 4K-Seite und nicht f√ºr jede Nachricht separat aufgerufen.  Es gibt kein Kopieren von Daten, keine Auswahl von Objekten.  Und komplexere Operationen mit Metadaten werden nur mit einem positiven Ergebnis und nicht f√ºr jede Nachricht aufgerufen.  Auf diese Weise haben wir eine Menge Overhead eliminiert, und der Rest der Last konzentriert sich auf einen kleinen internen Suchzyklus, der f√ºr die weitere Optimierung gut geeignet ist. <br><br>  Unser eigentlicher Suchalgorithmus basiert auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üartigen Idee von Leonid Volnitsky</a> .  Es √§hnelt dem Boyer-Moore-Algorithmus, bei dem bei jedem Schritt die L√§nge der Suchzeichenfolge √ºbersprungen wird.  Der Hauptunterschied besteht darin, dass zwei Bytes gleichzeitig √ºberpr√ºft werden, um falsche √úbereinstimmungen zu minimieren. <br><br>  Unsere Implementierung erfordert das Erstellen einer 64K-Nachschlagetabelle f√ºr jede Suche. Dies ist jedoch Unsinn im Vergleich zu den Gigabyte an Daten, nach denen wir suchen.  Die innere Schleife verarbeitet mehrere Gigabyte pro Sekunde auf einem einzelnen Kern.  In der Praxis liegt die stabile Leistung auf jedem Kern bei etwa 1,25 GB pro Sekunde, und es besteht Verbesserungspotenzial.  Sie k√∂nnen einen Teil des Overheads au√üerhalb der inneren Schleife eliminieren, und wir planen, mit der inneren Schleife in C anstelle von Java zu experimentieren. <br><br><h1>  Kraft anwenden </h1><br>  Wir haben diskutiert, dass Protokollsuchen "grob" implementiert werden k√∂nnen, aber wie viel "Leistung" haben wir?  Viel. <br><br>  <b>1 Kern</b> : Bei korrekter Verwendung ist ein Kern eines modernen Prozessors an sich sehr leistungsf√§hig. <br><br>  <b>8 Kerne</b> : Wir arbeiten derzeit an Amazon hi1.4xlarge- und i2.4xlarge-SSD-Servern mit jeweils 8 Kernen (16 Threads).  Wie oben erw√§hnt, sind diese Kernel normalerweise mit Hintergrundoperationen besch√§ftigt.  Wenn der Benutzer eine Suche durchf√ºhrt, werden die Hintergrundvorg√§nge angehalten, wodurch alle 8 Kerne f√ºr die Suche freigegeben werden.  Die Suche wird normalerweise in Sekundenbruchteilen abgeschlossen, danach wird die Hintergrundarbeit fortgesetzt (das Controller-Programm stellt sicher, dass eine Flut von Suchanfragen wichtige Hintergrundarbeiten nicht beeintr√§chtigt). <br><br>  <b>16 Kerne</b> : Aus Gr√ºnden der Zuverl√§ssigkeit organisieren wir Server in Master / Slave-Gruppen.  Jeder Master hat einen SSD-Server und einen untergeordneten EBS.  Wenn der Hauptserver abst√ºrzt, tritt der Server auf der SSD sofort an seine Stelle.  Fast immer funktionieren Master und Slave einwandfrei, sodass jeder Datenblock auf zwei verschiedenen Servern durchsucht werden kann (der Slave-EBS-Server verf√ºgt √ºber einen schwachen Prozessor, daher wird dies nicht ber√ºcksichtigt).  Wir teilen die Aufgabe zwischen ihnen auf, so dass insgesamt 16 Kerne zur Verf√ºgung stehen. <br><br>  <b>Viele Kerne</b> : In naher Zukunft werden wir die Daten auf die Server verteilen, damit alle an der Verarbeitung jeder nicht trivialen Anfrage teilnehmen.  Jeder Kern wird funktionieren.  [Hinweis: <i>Wir haben den Plan implementiert und die Suchgeschwindigkeit auf 1 TB / s erh√∂ht, siehe Hinweis am Ende des Artikels</i> ]. <br><br><h1>  Einfachheit sorgt f√ºr Zuverl√§ssigkeit </h1><br>  Ein weiterer Vorteil der Brute Force ist ihre relativ stabile Leistung.  In der Regel reagiert die Suche nicht zu empfindlich auf die Details der Aufgabe und des Datensatzes (ich denke, deshalb wird sie als "unh√∂flich" bezeichnet). <br><br>  Der Keyword-Index f√ºhrt manchmal zu unglaublich schnellen Ergebnissen, in anderen F√§llen jedoch nicht.  Angenommen, Sie haben 50 GB Protokolle, in denen der Begriff "customer_5987235982" genau dreimal vorkommt.  Eine Suche nach diesem Begriff z√§hlt drei Stellen direkt aus dem Index und endet sofort.  Eine komplexe Platzhaltersuche kann jedoch Tausende von Schl√ºsselw√∂rtern scannen und viel Zeit in Anspruch nehmen. <br><br>  Andererseits werden Brute-Force-Suchen nach Abfragen mit mehr oder weniger derselben Geschwindigkeit durchgef√ºhrt.  Die Suche nach langen W√∂rtern ist besser, aber selbst die Suche nach einem einzelnen Zeichen ist schnell genug. <br><br>  Die Einfachheit der Brute-Force-Methode bedeutet, dass ihre Produktivit√§t nahe am theoretischen Maximum liegt.  Es gibt weniger Optionen f√ºr unerwartete Festplatten√ºberlastung, Sperrkonflikte, Zeigerjagden und Tausende anderer Gr√ºnde f√ºr Fehler.  Ich habe mir gerade die Anfragen angesehen, die Scalyr-Benutzer letzte Woche auf unserem am st√§rksten frequentierten Server gestellt haben.  Es gab 14.000 Anfragen.  Genau acht von ihnen brauchten mehr als eine Sekunde;  99% wurden innerhalb von 111 Millisekunden ausgef√ºhrt (wenn Sie die Protokollanalysetools nicht verwendet haben, glauben Sie mir: <i>Dies ist schnell</i> ). <br><br>  Eine stabile, zuverl√§ssige Leistung ist wichtig f√ºr die Benutzerfreundlichkeit des Dienstes.  Wenn es regelm√§√üig langsamer wird, wird es von Benutzern als unzuverl√§ssig empfunden und es wird nur ungern verwendet. <br><br><h1>  Protokollsuche in Aktion </h1><br>  Hier ist eine kleine Animation, die zeigt, wie Scalyr in Aktion sucht.  Wir haben ein Demo-Konto, in das wir jedes Ereignis in jedes √∂ffentliche Github-Repository importieren.  In dieser Demo studiere ich die Daten f√ºr die Woche: ungef√§hr 600 MB Rohprotokolle. <br><br>  Das Video wurde ohne besondere Vorbereitung live auf meinem Desktop aufgezeichnet (ca. 5000 Kilometer vom Server entfernt).  Die Leistung, die Sie sehen werden, ist haupts√§chlich auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung des Webclients</a> sowie auf das schnelle und zuverl√§ssige Backend zur√ºckzuf√ºhren.  Immer wenn es eine Pause ohne die Anzeige "Laden" gibt, pausiere ich sie, damit Sie lesen k√∂nnen, auf was ich klicken werde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/159/bf8/c90/159bf8c9074eb627d27e7b5876e57740.gif"><br><br><h1>  Abschlie√üend </h1><br>  Bei der Verarbeitung gro√üer Datenmengen ist es wichtig, einen guten Algorithmus zu w√§hlen, aber ‚Äûgut‚Äú bedeutet nicht ‚Äûausgefallen‚Äú.  √úberlegen Sie, wie Ihr Code in der Praxis funktioniert.  Einige Faktoren, die in der realen Welt von gro√üer Bedeutung sein k√∂nnen, fallen aus der theoretischen Analyse von Algorithmen heraus.  Einfachere Algorithmen sind einfacher zu optimieren und in Grenzsituationen stabiler. <br><br>  Denken Sie auch an den Kontext, in dem der Code ausgef√ºhrt wird.  In unserem Fall ben√∂tigen wir ausreichend leistungsf√§hige Server, um Hintergrundaufgaben zu verwalten.  Benutzer initiieren relativ selten eine Suche, sodass wir eine ganze Gruppe von Servern f√ºr den kurzen Zeitraum ausleihen k√∂nnen, der f√ºr die Durchf√ºhrung jeder Suche erforderlich ist. <br><br>  Mit Brute Force haben wir eine schnelle, zuverl√§ssige und flexible Suche in einer Reihe von Protokollen implementiert.  Wir hoffen, dass diese Ideen f√ºr Ihre Projekte n√ºtzlich sind. <br><br>  Bearbeiten: <i>Titel und Text wurden von "Suche mit 20 GB pro Sekunde" in "Suche mit 1 TB pro Sekunde" ge√§ndert, um die Leistungssteigerung in den letzten Jahren widerzuspiegeln.</i>  <i>Diese Geschwindigkeitssteigerung ist haupts√§chlich auf eine √Ñnderung des Typs und der Anzahl der EC2-Server zur√ºckzuf√ºhren, die wir heute erh√∂hen, um den erweiterten Kundenstamm zu bedienen.</i>  <i>In naher Zukunft werden √Ñnderungen erwartet, die zu einer weiteren deutlichen Steigerung der Arbeitseffizienz f√ºhren werden, und wir freuen uns auf die Gelegenheit, dar√ºber zu berichten.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445456/">https://habr.com/ru/post/de445456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445446/index.html">Wie wir die verz√∂gerte Replikation f√ºr die Notfallwiederherstellung mit PostgreSQL verwendet haben</a></li>
<li><a href="../de445448/index.html">Konfigurieren des automatischen Empfangs von Letsencrypt-Zertifikaten mit Docker unter Linux</a></li>
<li><a href="../de445450/index.html">Browser-Erweiterung f√ºr toster.ru</a></li>
<li><a href="../de445452/index.html">N√ºtzliche Repositories mit Eloquent?</a></li>
<li><a href="../de445454/index.html">Himbeer Pi Zero Inside Handy Tech Active Star 40 Braillezeile</a></li>
<li><a href="../de445458/index.html">Electronic Arts wird 350 Mitarbeiter besch√§ftigen und seine Pr√§senz in Russland reduzieren</a></li>
<li><a href="../de445460/index.html">Gadget-freie Interaktivit√§t</a></li>
<li><a href="../de445464/index.html">Verringerung der Stichprobengr√∂√üe experimenteller Daten ohne Informationsverlust</a></li>
<li><a href="../de445466/index.html">Herzlichen Gl√ºckwunsch Imagine Cup EMEA Regional Final Champions: Team Finderr aus Gro√übritannien! Das russische Team ist Dritter</a></li>
<li><a href="../de445468/index.html">Ein Team aus Russland belegte beim Imagine Cup-Wettbewerb in Europa, Afrika und im Nahen Osten den dritten Platz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>