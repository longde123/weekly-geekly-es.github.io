<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💟 ⛹🏻 👩🏾‍💻 Bash Shell简介 😦 👨🏿‍⚖️ 💃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 这是RedHat RHCE考试准备书的翻译。 我认为，关于bash的基础知识非常容易理解。 

 Shell脚本本身就是一门科学。 在不深入探讨“幕后”发生的所有事情的情况下，您将学习如何使用基本元素来编写自己的脚本，并分析第三方Shell脚本中发生的情况。 



 了解Shell脚本的基...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bash Shell简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471242/"> 大家好 这是RedHat RHCE考试准备书的翻译。 我认为，关于bash的基础知识非常容易理解。 <br><br>  Shell脚本本身就是一门科学。 在不深入探讨“幕后”发生的所有事情的情况下，您将学习如何使用基本元素来编写自己的脚本，并分析第三方Shell脚本中发生的情况。 <br><br><img src="https://habrastorage.org/webt/8w/vx/z3/8wvxz3nzeh5uaiubay0ezgvrbwm.jpeg"><br><a name="habracut"></a><br><h2> 了解Shell脚本的基本元素 </h2><br> 实际上，shell脚本是顺序执行的命令的列表，以及一些仅允许在特定条件下执行代码的逻辑。 <br><br> 要了解复杂的Shell脚本，建议您从基本脚本开始。 <br><br> 以下是一个非常简单的脚本： <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # #This is a script that greets the world # Usage: ./hello clear echo hello world exit 0</span></span></code> </pre> <br> 它包含几个应在所有脚本中使用的元素。 对于初学者，有shebang-这是行＃！/ Bin / bash。 从父外壳启动脚本时，它将打开一个子外壳，在该子外壳中执行脚本中指定的命令。 <br><br> 这些命令可以以多种方式解释。 为了准确理解它们应该如何解释，使用了shebang。 在上面的示例中，shebang明确指出该脚本必须由bash shell执行。 <br><br> 也可以指示其他外壳。 例如，如果您的脚本包含Perl代码，则shebang应该为＃！/ Usr / bin / perl。 与shebang一起启动脚本是一个好习惯。 如果省略，脚本代码将由用于运行脚本的同一shell执行。 <br><br> 在爆炸之后，立即有一部分解释了脚本的含义。 在每个方案的开头都添加一些注释行是一个好主意。 在一个简短的脚本中，通常会很清楚它的作用，但是随着脚本的变长，以及越来越多的人参与编写和支持它，作者的意图变得越来越不清楚。 <br><br> 为避免这种情况，请确保添加以每个＃字符开头的注释行。 注释不仅可以在第一行中，而且可以在脚本每个小节的开头。 如果您在几个月后阅读脚本，这肯定会有所帮助！ <br><br> 您不仅可以在小节中评论，还可以在个别行中评论。 <br><br> 无论使用什么位置，从＃字符到行尾的所有内容都是注释。 <br><br> 在注释块之后，找到了脚本主体。 在上面的示例中，这些是顺序执行的几个命令。  Shell脚本的主体可能随着其发展而增加。 <br><br> 在脚本的最后，我包括了<b>exit 0</b>语句。  exit语句告诉父外壳脚本是否成功。 脚本中最后一个命令的退出状态是脚本本身的退出状态，除非在脚本末尾使用了<b>exit 0</b> 。 <br><br> 知道您可以与<b>exit</b>一起使用来告诉父shell情况如何是很有用的。 <br><blockquote> 在父shell中引入了echo $?。 允许您查询上一个正在运行的脚本的退出状态。 <br></blockquote> 创建脚本后，请确保可以执行该脚本。 最常见的方法是对其应用运行位。 因此，如果脚本文件名是hello，请使用<b>chmod + x ./hello命令</b>使其可执行。 <br><br> 该脚本也可以作为bash命令的参数执行。 在这种情况下，输入<b>bash ./hello</b>来运行hello脚本。 如果脚本作为bash命令的参数运行，则脚本文件不必是可执行文件。 <br><br> 实际上，您可以将脚本存储在任何位置，但是如果要将其存储在$ PATH变量未包含的目录中，则需要在脚本名称前使用./来执行该脚本。 <br><br> 键入<b>./hello</b>来运行脚本，或将其放在$ PATH变量中包含的标准目录中，例如/ usr / local / bin。 <br><br> 您也可以将脚本放置在/ bin目录中，然后在文件系统中的任何位置输入文件名，脚本就会执行。 <br><br>  <b>例子</b> <br><br> 使用<b>vi / bin /</b> datetime在/ bin目录中创建一个名为datetime的文件。 将此内容粘贴到创建的文件中： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #    .     ,      date who</span></span></code> </pre><br> 保存文件后，输入<b>chmod + x / bin / datetime</b>授予文件执行权限。 例如，使用<b>cd〜命令</b>更改到主目录，只需输入<b>datetime</b> 。 <br><br> 例如，转到cd〜home目录，然后输入datetime。 <br><br><pre> <code class="bash hljs">[root@localhost ~]<span class="hljs-comment"><span class="hljs-comment"># datetime Sat Sep 28 00:33:41 EDT 2019 root tty1 2019-09-25 20:28 root pts/0 2019-09-27 20:07 (comp.corp.domain.ru)</span></span></code> </pre><br><h2> 使用变量和输入 </h2><br>  bash脚本不仅仅是顺序执行的命令列表。 脚本的优点之一是它们可以使用变量和输入来使脚本灵活。 在本节中，您将学习如何与他们合作。 <br><br><h3> 使用位置参数 </h3><br> 运行脚本时，可以使用参数。 参数是您在脚本命令后加上的所有内容。 可以使用参数使脚本更加灵活。 采取<b>useradd lisa</b>命令。 在此示例中，命令为<b>useradd</b> ，其参数<b>lisa</b>指示需要执行的操作。 <br><br> 作为这样的命令的结果，应该创建一个名为lisa的用户。 <br><br> 在脚本中，第一个参数是<b>$ 1</b> ，第二个参数是<b>$ 2，</b>依此类推，清单1显示了如何使用这些参数。 通过将任何用户名指定为参数来尝试运行此代码。 <br><br>  <b>清单1</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo The first argument is $1 echo The second argument is $2 echo The third argument is $3</span></span></code> </pre><br> 参数表示在运行脚本之前输入数据。 在这种情况下，我在参数脚本名称之后指定了<b>lisa</b> ， <b>lori</b>和<b>bob</b>作为参数： <br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># ./argument lisa lori bob The first argument is lisa The second argument is lori The third argument is bob [root@server1 ~]#</span></span></code> </pre><br> 如果您尝试运行示例代码，您可能会注意到其内容并不完美。 如果在执行清单1中的脚本时使用三个参数，它将很好地工作。 如果仅使用两个参数，则输出第三个参数而没有值$ 3。 <br><br> 如果使用四个参数，则永远不会显示第四个值（将存储在$ 4中）。 因此，如果要使用参数，则最好使用更灵活的方法。 <br><br>  <b>清单2</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo you have entered $# arguments for i in $@ do echo $i done exit 0</span></span></code> </pre><br>  <b>清单2显示了两个与参数相关的新元素：</b> <br><br><ul><li>  $＃是一个计数器，显示在运行脚本时使用了多少个参数。 </li><li>  $ @是运行脚本时使用的所有参数的列表。 </li></ul><br> 要列出运行此脚本时使用的参数，请使用<b>for</b>循环。 在<b>for</b>循环中，只要条件为真，就会执行指令。 在这种情况下， <b>$ @中i</b>的条件表示“对于每个参数”。 每次脚本通过循环时，变量<b>$ @</b>的值<b>都会</b>分配给变量<b>$ i</b> 。 <br><br> 因此，只要有参数，脚本的主体就会执行。 <br><br>  for循环的主体始终以<b>do</b>开头，并以<b>done结束</b> ，并且要执行的命令在这两个关键字之间列出。 因此，示例脚本将使用<b>echo</b>来显示每个参数的值，并在没有更多可用参数时停止显示。 <br><br>  <b>在这个示例中，让我们尝试清单2中的脚本：</b> <br><br><ol><li> 键入<b>vi参数</b>创建参数文件，并将清单2中脚本的内容复制到该文件。 </li><li> 保存文件并使其可执行。 </li><li> 运行命令<b>./argument abc</b> 。 您将看到显示三行。 </li><li> 运行命令<b>./argument abcdef</b> 。 您将看到除abc外，还将显示de f。 </li></ol><br><h2> 变数 </h2><br> 变量是一个标签，用于指示内存中包含特定值的特定位置。 可以使用NAME = value静态定义变量，也可以动态定义变量。 动态定义变量有两种解决方案： <br><br><ul><li> 在脚本中使用<b>read</b>关键字可从运行脚本的用户请求数据。 </li><li> 使用命令替换来使用命令的结果并将其分配给变量。 例如，命令<b>日期+％d-％m-％y</b>以日-月-年格式显示当前日期。 为此，可以使用<b>TODAY = $（date +％d-％m-％y）</b> 。 要替换命令，只需将要使用其结果的命令放在方括号之间。 </li></ul><br> 在上一章有关位置参数的部分中，您学习了如何在运行脚本时将参数分配给变量。 在某些情况下，当您发现缺少实质性内容时，请求信息可能会更有效。 下面的脚本显示了如何执行此操作。 <br><br>  <b>清单3.</b>使用<b>read</b>命令的示例脚本 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash if [ -z $1 ]; then echo enter a text read TEXT else TEXT=$1 fi echo you have entered the text $TEXT exit 0</span></span></code> </pre><br> 在清单3的脚本中， <b>if ... then ... else ... fi</b>运算符用于测试<b>$ 1</b>参数的存在。 这是使用<b>test</b>完成的（test是一个单独的命令）。 测试命令可以通过两种方式编写*： <b>test</b>或<b>[...]</b> 。 在此示例中，执行<b>if [-z $ 1] ...行</b>以查看测试（检查） <b>-z $ 1</b> 。 <br><br>  * <i>-实际上是三个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> （大约翻译器）</i> <br><br>  <b>-z测试</b>检查<b>$ 1是否</b>存在。 换句话说， <b>if [-z $ 1]行</b>检查<b>$ 1是否为</b>空，这意味着在运行此脚本时未提供任何参数。 如果是这样，则执行<b>then</b>语句之后的命令。 <br><br> 请注意，在使用方括号编写<b>测试</b>命令时，请务必在左括号和右括号之前使用空格，没有空格的命令将不起作用。 <br><br> 注意<b>then</b>语句紧跟在<b>test之后</b> 。 这是可能的，因为使用了分号（;）。 分号是命令分隔符，可以替换脚本中的新行。 <br><br>  <b>then</b>语句执行两个命令： <b>echo</b>命令（在屏幕上显示消息）和<b>read</b>命令。 <br><br>  <b>read</b>命令将停止脚本，以便可以处理用户输入并将其存储在TEXT变量中。 因此， <b>read TEXT</b>将所有用户输入放入TEXT变量，该变量将在脚本的后面使用。 <br><br> 下一部分由<b>else语句表示</b> 。 在所有其他情况下， <b>else语句</b>之后的命令<b>都</b>将执行，在这种情况下，其含义是“否则，如果提供了参数”。 如果是这样，则确定TEXT变量并将<b>$ 1</b>的当前值分配给它。 <br><br> 注意变量的定义方式：在变量名后紧跟有一个=号，后跟$ 1。 请注意，定义变量时切勿使用空格。 <br><br> 然后，使用<b>fi</b>运算符关闭if条件。  if条件完成后，您肯定会知道TEXT变量已定义且具有值。 脚本的倒数第二行读取TEXT变量的值，并使用<b>echo</b>命令将此值映射到STDOUT。 请注意，要请求变量的当前值，它引用变量的名称，以其前面的$符号开头。 <br><br>  <b>您可以在使用输入时练习使用此示例。</b> <br><br><ol><li> 打开编辑器并创建一个名为text的文件。 将清单3中的代码内容输入此文件。 </li><li> 将文件写入磁盘并执行<b>chmod + x文本</b>以使其可执行。 </li><li> 通过运行<b>./text且不</b>使用其他参数来运行脚本。 您将看到它要求输入。 </li><li> 使用“ <b>hello</b> ”作为参数运行脚本（./text hello）。 结果将在STDOUT中显示“您已输入文字问候”。 </li></ol><br><h2> 使用条件和循环 </h2><br> 如您所见，条件语句可以在脚本中使用。 这些条件语句仅在满足特定条件时才执行。 <br><br>  bash中经常使用一些条件语句和循环。 <br><br><ul><li>  <b>if ... then ... else-</b>如果满足特定条件，则用于执行代码 </li><li>  for-用于执行一系列值的命令 </li><li>  <b>while-</b>用于在满足特定条件时执行代码 </li><li>  <b>之前</b> -用于执行代码直到满足特定条件 </li><li>  <b>大小写</b> -用于评估有限数量的特定值 </li></ul><br><h3> 如果那样的话 </h3><br>  <b>if then else构造</b>通常用于评估特定条件。 您已经看到了他的榜样。 此条件语句通常与<b>test</b>命令一起使用。 此命令使您可以检查许多事情：例如，不仅文件是否存在，而且还比较文件，比较整数等等。 <br><blockquote> 您可以在参考手册中使用命令man test来了解有关test的更多信息。 </blockquote><br> 基本的<b>if</b>构造是<b>if ... then ... fi</b> 。 <br><br> 它比较一个条件，如以下示例所示： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no value provided <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br> 在清单3中，您了解了如何评估两个条件，包括表达式中的<b>其他</b>条件。 清单4显示了如何评估从<b>if</b>到<b>else的</b>几个条件。 如果您需要检查许多不同的值，这将很有用。 <br><br> 请注意，此示例还使用了几个<b>测试</b>命令。 <br><br>  <b>清单4</b> 。  <b>如果然后否则的</b>示例 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with one argument # the goal is to find out if the argument is a file or a directory if [ -f $1 ] then echo "$1 is a file" elif [ -d $1 ] then echo "$1 is a directory" else echo "I do not know what \$1 is" fi exit 0</span></span></code> </pre> <br><h3>  || 和&amp;&amp; </h3><br> 您可以使用逻辑运算符<b>||</b>代替编写complete <b>if ...语句。</b> 以及<b>&amp;&amp;</b> 。  <b>||</b> 是逻辑“或”，并且仅在第一部分不为真时才执行语句的第二部分；  <b>&amp;&amp;</b>是逻辑“ AND”，仅在第一部分为true时才执行语句的第二部分。 <br><br>  <b>考虑以下两行：</b> <br><br><pre> <code class="bash hljs">[ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no argument provided</code> </pre> <br><pre> <code class="bash hljs">ping -c 1 8.8.8.8 2&gt;/dev/null || <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> node is not available</code> </pre><br> 第一个示例检查<b>$ 1是否为</b>空。 如果此检查正确（基本上意味着该命令以退出代码0结尾），则执行第二个命令。 <br><br> 在第二个示例中，使用<b>ping</b>命令检查主机可用性。 <br> 在<b>ping</b>命令失败的情况下，此示例使用逻辑“或”显示文本“节点不可用”。 <br><br> 您会经常发现这种情况，而不是有条件的<b>if语句</b> ， <b>&amp;&amp;</b>和<b>||。</b>  。 在下面的练习中，您可以练习使用条件语句，方法是使用<b>if ... then ... else</b>或<b>&amp;&amp;</b>和<b>||。</b>  。 <br><br>  <b>锻炼身体</b> 。 使用<b>if ... then ... else</b> <br><br> 在本练习中，您将处理一个脚本，该脚本检查什么是文件和什么是目录。 <br><br><ol><li> 启动编辑器并创建一个名为filechk的脚本。 </li><li> 将清单4的内容复制到此脚本中。 </li><li> 用它运行几个测试，例如<b>./filechk / etc / hosts</b> ， <b>./filechck/usr</b> 、. <b>/</b> <b>filechk non-existing-file</b> 。 </li></ol><br><h2> 对于循环 </h2><br>  <b>for</b>循环是处理数据范围的绝佳解决方案。 在清单5中，您可以看到带有的第一个示例，其中在该范围中有原始值的情况下确定并处理了范围。 <br><br>  <b>清单5</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # for (( COUNTER=100; COUNTER&gt;1; COUNTER-- )); do echo $COUNTER done exit 0</span></span></code> </pre> <br>  <b>for</b>循环始终以for关键字开头，后跟需要检查的条件。 后面紧跟着<b>do</b>关键字，接着是必须执行的命令，如果条件为true，则循环使用<b>done</b>关键字终止。 <br><br> 在清单5的示例中，您可以看到条件是分配给COUNTER变量的括号内的数字范围。 <br><br>  <b>一点解释</b> <br><br> 内部<b>（（...））</b>算术表达式被计算并返回其结果。 例如，在最简单的情况下，结构a = $（（5 + 3））将为变量“ a”分配表达式“ 5 + 3”或8的值。此外，双括号允许使用C语言风格的变量。 <br><br> 首先，将变量初始化为100，只要该值大于1，就在每次迭代中将其减去1，只要条件为真，就使用<b>echo</b>命令显示$ COUNTER变量的值。 <br><br> 在清单6中，您可以看到带有的我最喜欢的单行代码<b>之一</b> 。 这次将范围定义为一个数字序列，从100开始到104。 <br><br>  <b>清单6</b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {100..104}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ping –c 1 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt;/dev/null &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> is up; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br> 请注意如何确定范围：首先指定第一个数字，然后指定两个点并指示范围中的最后一个数字。 此外， <b>对于i in，</b>对于这些数字中的每一个， <b>都</b>分配变量<b>i</b> 。 这些数字中的每一个都分配给变量<b>i</b> ，然后执行<b>ping</b>命令，其中<b>-c 1</b>选项确保仅发送一个请求。 <br><br>  <b>ping</b>命令的结果未考虑在内，因此其输出重定向到/ dev / null。 根据<b>ping</b>命令的输出状态，执行<b>&amp;&amp;</b>表达式的一部分。 因此，如果主机可用，则会显示一行以表明主机正在运行。 <br><br><h2> 了解何时和直到 </h2><br> 如果您刚刚阅读的for语句对于处理元素范围非常有用，那么当您要跟踪诸如流程可访问性之类的内容时， <b>while</b>语句将非常有用。 还有一条<b>直到</b>语句，只要所检查的条件为假，就执行该语句。 在清单7中，您可以了解如何使用<b>while</b>来监视流程活动。 <br><blockquote> 注意事项 我不明白该脚本的作用。 就我而言，使用CentOS 7，默认情况下没有监视器，尽管脚本明确指出： <pre> 用法：监视&lt;进程名&gt; </pre> 在某个地方呆了半个小时，我用Google搜索了CetOS的监控程序，但没有找到。 通常，如果使用ps aux，则不清楚这是什么侧面监视器。 无论如何，我都不了解该脚本的作用。 帮助解决此问题的一大要求是调整文本和/或脚本。 </blockquote>  <b>清单7</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # usage: monitor &lt;processname&gt; while ps aux | grep $1 | grep -v grep &gt; /dev/tty11 do sleep 5 done clear echo your process has stopped logger $1 is no longer present mail -s "process $1 has stopped" root &lt; .</span></span></code> </pre> <br> 清单7中的脚本由两部分组成。 首先，有一个<b>while循环</b> 。 其次，当<b>while循环</b>不再被评估为true时，需要做的所有事情。 <br><br>  <b>while循环</b>的核心是<b>ps</b>命令，其值为<b>$ 1</b> 。 <br><br> 注意使用了<b>grep -v grep</b> ，它从结果中排除了包含<b>grep命令的</b>行。 请记住， <b>ps</b>命令将包括<b>ps</b>命令输出传递到的所有正在运行的进程，包括<b>grep命令</b> 。 这可能会导致误判匹配。 <br><br>  <b>ps aux</b>命令的输出重定向到/ dev / tty11。 这使您可以在以后从tty11中读取结果，但默认情况下不会显示它们。 <br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句</font><font style="vertical-align: inherit;">后面是如果要检查的条件为true则必须执行的命令。在这种情况下，它是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep 5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">，它将脚本执行暂停5秒钟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只要</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句的条件为</font><font style="vertical-align: inherit;">true，循环就继续执行。如果条件为假（在这种情况下意味着该过程不再可用），则循环停止，并且可以执行其后的命令。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您应该熟悉所有这些命令，除了最后一个。在行</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-s中，“进程$ 1已停止”根&lt;。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">邮件使用内部邮件系统发送给root用户，该内部邮件系统默认在Linux *上运行。</font><b><font style="vertical-align: inherit;">邮件</font></b><font style="vertical-align: inherit;">命令</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-s选项</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定的消息主题作为第一个参数</font><font style="vertical-align: inherit;">。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*-至少在CentOS上默认情况下有效。 （在翻译器中）</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在团队结束时。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，</font><font style="vertical-align: inherit;">在交互模式下</font><font style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令时</font><font style="vertical-align: inherit;">，会打开一个编辑器，您可以在其中编写消息正文。该编辑器已关闭，提供的行只有一个句点。在此命令中，通过重定向STDIN提供一个点。这样就可以在无需任何其他用户活动要求的情况下处理消息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">周期</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -该周期的相反</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它的一个例子示于表8。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始一个迭代，直到条件变为真为止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在清单8中，它用于</font><font style="vertical-align: inherit;">通过</font><b><font style="vertical-align: inherit;">$ 1</font></b><font style="vertical-align: inherit;">的出现</font><font style="vertical-align: inherit;">来过滤</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">users</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令的输出</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将是用户名。</font><font style="vertical-align: inherit;">在此命令正确之前，迭代将继续。</font><font style="vertical-align: inherit;">在用户输出中找到用户名后，迭代将关闭，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到直到</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环之后，</font><font style="vertical-align: inherit;">其余命令才会执行。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单8</font></font></b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # until users | grep $1 &gt; /dev/null do echo $1 is not logged in yet sleep 5 done echo $1 has just logged in mail -s "$1 has just logged in" root &lt; .</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 了解案例 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一个重要的迭代循环是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小写</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *。操作员</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的情况下</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被用来评估许多预期值。特别是，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">case语句</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Linux启动脚本中很重要，在以前的版本中</font><font style="vertical-align: inherit;">，</font><b><font style="vertical-align: inherit;">case语句</font></b><font style="vertical-align: inherit;">用于启动服务。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*-这是一个周期吗？</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">case语句中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义所需的每个具体参数，如果使用了该参数，则定义要执行的命令。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在清单9中，您可以看到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">case语句</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><b><font style="vertical-align: inherit;">语句</font></b><font style="vertical-align: inherit;">在较早的版本中用于运行几乎所有服务。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单9</font></font></b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start) start;; stop) rm -f <span class="hljs-variable"><span class="hljs-variable">$lockfile</span></span> stop;; restart) restart;; reload) reload;; status) status ;; *) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Usage: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> (start|stop|restart|reload|status)"</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">案件</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有几个特点。首先是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺序情况</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。接下来是需要评估的所有可能值的列表。每个元素用括号封闭</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果使用了特定参数，则后面是要执行的命令列表。命令列表以双分号;;结束。可以在最后一条命令之后立即使用，并且可以在单独的行上使用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另请注意，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适用于先前未指定的所有其他参数。这是一个无所不包的运营商。</font><b><font style="vertical-align: inherit;">案例</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迭代循环</font><font style="vertical-align: inherit;">以</font><b><font style="vertical-align: inherit;">esac语句</font></b><font style="vertical-align: inherit;">结束</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以防万一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的序列</font><font style="vertical-align: inherit;">按顺序执行。</font><font style="vertical-align: inherit;">进行第一个匹配时，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">case语句</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不评估任何内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为评估的一部分，可以使用与模板相似的模板。</font><font style="vertical-align: inherit;">这显示在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">匹配所有内容</font><b><font style="vertical-align: inherit;">的</font></b><font style="vertical-align: inherit;">序列中。</font><font style="vertical-align: inherit;">但是，您也可以使用诸如start | Start | START）之类的序列来匹配另一种</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在Bash中调试脚本 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当脚本无法满足您的期望时，进行一些调试很有用。</font><font style="vertical-align: inherit;">首先，尝试将其作为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bash -x</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令的参数执行</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这将逐行向您显示脚本尝试执行的操作，以及如果脚本无法正常运行的情况下的具体错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单10显示了一个使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bash -x</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的示例</font><font style="vertical-align: inherit;">，在该</font><font style="vertical-align: inherit;">示例中</font><font style="vertical-align: inherit;">，很明显</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grep命令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不知道应该做什么，因为缺少用于其操作的参数。</font></font><br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># bash -x 319.sh + grep Usage: grep [OPTION]... PATTERN [FILE]... Try 'grep --help' for more information. + users + echo is not logged in yet is not logged in yet + sleep 5</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 总结一下 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，您学习了如何编写Shell脚本。</font><font style="vertical-align: inherit;">您已经看了几个示例，现在熟悉了创建成功脚本所需的一些基本元素。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471242/">https://habr.com/ru/post/zh-CN471242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471226/index.html">Linux有很多面孔：如何在任何发行版上工作</a></li>
<li><a href="../zh-CN471228/index.html">Grokay PyTorch</a></li>
<li><a href="../zh-CN471232/index.html">我将LPS331AP连接到Omega Onion2的经验</a></li>
<li><a href="../zh-CN471236/index.html">Seryozha的剂量计。 第三部分 国家辐射计</a></li>
<li><a href="../zh-CN471240/index.html">“ Bitchy Betty”和现代音频接口：为什么它们以女性声音说话？</a></li>
<li><a href="../zh-CN471244/index.html">Rosetta代码：测量大量编程语言中代码的长度，研究语言之间的接近度</a></li>
<li><a href="../zh-CN471248/index.html">美国监管机构禁止分发Telegram开放网络令牌</a></li>
<li><a href="../zh-CN471254/index.html">ITMO大学加速器初创公司-开始机器视觉项目</a></li>
<li><a href="../zh-CN471256/index.html">Vue.js很好，但是比Angular或React更好吗？</a></li>
<li><a href="../zh-CN471258/index.html">数据存储/加载系统</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>