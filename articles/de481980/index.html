<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëî üèë üîë Wie wir Skripte in Unity optimiert haben üëæ üì± üéÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt viele gro√üartige Performance-Artikel und Tutorials zu Unity. Wir versuchen nicht, sie durch diesen Artikel zu ersetzen oder zu verbessern. Die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir Skripte in Unity optimiert haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481980/"> Es gibt viele gro√üartige Performance-Artikel und Tutorials zu Unity.  Wir versuchen nicht, sie durch diesen Artikel zu ersetzen oder zu verbessern. Dies ist nur eine kurze Zusammenfassung der Schritte, die wir nach dem Lesen dieser Artikel unternommen haben, sowie der Schritte, mit denen wir unsere Probleme l√∂sen konnten.  Ich empfehle Ihnen nachdr√ºcklich, zumindest die Materialien unter <a href="https://learn.unity.com/">https://learn.unity.com/</a> zu <a href="https://learn.unity.com/">lesen</a> . <br><br>  W√§hrend der Entwicklung unseres Spiels stie√üen wir auf Probleme, die von Zeit zu Zeit zu einer Hemmung des Spielprozesses f√ºhrten.  Nachdem wir einige Zeit in Unity Profiler verbracht haben, haben wir zwei Arten von Problemen festgestellt: <br><br><ul><li>  Nicht optimierte Shader </li><li>  Nicht optimierte Skripte in C # </li></ul><br>  Die meisten Probleme wurden von der zweiten Gruppe verursacht. Daher habe ich mich in diesem Artikel auf C # -Skripte konzentriert (wahrscheinlich auch, weil ich in meinem Leben keinen einzigen Shader geschrieben habe). <br><br><h1>  Suche nach Schw√§chen </h1><br>  In diesem Artikel wird kein Lernprogramm zur Verwendung eines Profilers verfasst.  Ich wollte nur dar√ºber sprechen, woran wir w√§hrend des Profilierungsprozesses haupts√§chlich interessiert waren. <br><br>  <strong>Unity Profiler ist immer der beste Weg,</strong> um die Ursachen f√ºr Verz√∂gerungen in Skripten zu finden.  Ich empfehle dringend, <strong>das Spiel direkt im Ger√§t</strong> und nicht im Editor zu <strong>profilieren</strong> .  Da unser Spiel f√ºr iOS erstellt wurde, musste ich das Ger√§t verbinden und die im Bild gezeigten Build-Einstellungen verwenden. Danach stellte der Profiler automatisch eine Verbindung her. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c7/fad/0e0/5c7fad0e0596f91c183a80ea3d72d1ae.png"></div><br>  <em>Einstellungen f√ºr die Profilerstellung erstellen</em> <br><br>  Wenn Sie versuchen, "Random Lag in Unity" oder eine andere √§hnliche Anfrage zu googeln, werden Sie feststellen, dass die meisten Leute empfehlen, <strong>sich auf die Garbage Collection zu konzentrieren</strong> , weshalb ich es getan habe.  Jedes Mal, wenn Sie aufh√∂ren, ein Objekt zu verwenden (Klasseninstanz), wird M√ºll erzeugt. Danach bereinigt der Unity-Garbage Collector von Zeit zu Zeit das Chaos und gibt Speicher frei, was unglaublich viel Zeit in Anspruch nimmt und zu einer Verringerung der Framerate f√ºhrt. <br><a name="habracut"></a><br><h2>  Wie finde ich Junk-Skripte im Profiler? </h2><br>  W√§hlen Sie einfach CPU-Auslastung -&gt; Hierarchieansicht ausw√§hlen -&gt; Nach GC-Zuordnung sortieren <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/aed/605/167aed6059ad0276a4275d5edf2179db.png"></div><br>  <em>Profiler-Optionen f√ºr die Garbage Collection</em> <br><br>  Ihre Aufgabe ist es, in der GC-Zuweisungsspalte f√ºr die Gameplay-Szene einige Nullen zu erreichen. <br><br>  Eine andere gute M√∂glichkeit besteht darin, <strong>die Eintr√§ge nach Zeit ms</strong> (Laufzeit) zu <strong>sortieren</strong> und die Skripte so zu optimieren, dass sie so wenig Zeit wie m√∂glich in Anspruch nehmen.  Dieser Schritt hatte gro√üe Auswirkungen auf uns, da eine unserer Komponenten eine <strong>gro√üe for-Schleife</strong> enthielt, die ewig dauerte (ja, wir haben noch keinen Weg gefunden, die Schleife zu beseitigen). Daher war es f√ºr uns unbedingt erforderlich, die Ausf√ºhrungszeit aller Skripten zu optimieren. weil wir bei dieser teuren for-Schleife Laufzeit sparen und gleichzeitig eine stabile Frequenz von 60 fps beibehalten mussten. <br><br>  Basierend auf den Profildaten habe ich die Optimierung in zwei Teile geteilt: <br><br><ul><li>  M√ºll entsorgen </li><li>  Reduzierte Vorlaufzeit </li></ul><br><h1>  Teil 1: Kampf gegen M√ºll </h1><br>  In diesem Teil erz√§hle ich Ihnen, was wir getan haben, um den M√ºll loszuwerden.  Dies ist das grundlegendste Wissen, das jeder Entwickler verstehen sollte.  Sie sind ein wichtiger Bestandteil unserer t√§glichen Analyse bei jeder Pull / Merge-Anfrage. <br><br><h2>  Erste Regel: Keine neuen Objekte in Update-Methoden </h2><br>  Idealerweise sollten die <strong>Update-, FixedUpdate- und LateUpdate-Methoden nicht die "neuen" Schl√ºsselw√∂rter enthalten</strong> .  Sie sollten immer das verwenden, was Sie bereits haben. <br><br>  Manchmal ist das <strong>Erstellen eines neuen Objekts</strong> in einigen internen Unity-Methoden <strong>verborgen</strong> , sodass dies nicht so offensichtlich ist.  Wir werden sp√§ter dar√ºber sprechen. <br><br><h2>  Zweite Regel: einmal erstellen und wiederverwenden! </h2><br>  Im Wesentlichen bedeutet dies, dass Sie f√ºr alles, was Sie in den Methoden Start und Awake k√∂nnen, Speicher zuweisen sollten.  Diese Regel ist der ersten sehr √§hnlich.  Dies ist eigentlich nur eine andere M√∂glichkeit, die "neuen" Schl√ºsselw√∂rter aus den Update-Methoden zu entfernen. <br><br>  Code, dass: <br><br><ul><li>  erstellt neue Instanzen </li><li>  Suche nach irgendwelchen Spielobjekten </li></ul><br>  Sie sollten immer versuchen, von den Update-Methoden zu Start oder Awake zu wechseln. <br><br>  Hier sind Beispiele f√ºr unsere √Ñnderungen: <br><br>  Zuweisung von Speicher f√ºr Listen in der Start-Methode, deren L√∂schen (Clear) und ggf. Wiederverwendung. <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code private List&lt;GameObject&gt; objectsList; void Update() { objectsList = new List&lt;GameObject&gt;(); objectsList.Add(......) } //Better Code private List&lt;GameObject&gt; objectsList; void Start() { objectsList = new List&lt;GameObject&gt;(); } void Update() { objectsList.Clear(); objectsList.Add(......) }</span></span></code> </pre> <br>  Links speichern und wie folgt wiederverwenden: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); foreach(var obstacle in levelObstacles) { ....... } } //Better code private Object[] levelObstacles; void Start() { levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); } void Update() { foreach(var obstacle in levelObstacles) { ....... } }</span></span></code> </pre> <br>  Gleiches gilt f√ºr die FindGameObjectsWithTag-Methode oder eine andere Methode, die ein neues Array zur√ºckgibt. <br><br><h2>  Die dritte Regel: Achten Sie auf Zeichenfolgen und vermeiden Sie deren Verkettung </h2><br>  Wenn es darum geht, M√ºll zu schaffen, sind die Linien schrecklich.  Selbst die einfachsten Zeichenfolgenoperationen k√∂nnen viel M√ºll erzeugen.  Warum?  Strings sind nur Arrays und diese Arrays sind unver√§nderlich.  Dies bedeutet, dass jedes Mal, wenn Sie zwei Zeilen verketten, ein neues Array erstellt wird und das alte in M√ºll verwandelt wird.  Gl√ºcklicherweise kann StringBuilder verwendet werden, um eine solche Speicherbereinigung zu vermeiden oder zu minimieren. <br><br>  Hier ist ein Beispiel, wie Sie die Situation verbessern k√∂nnen: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Start() { text = GetComponent&lt;Text&gt;(); } void Update() { text.text = "Player " + name + " has score " + score.toString(); } //Better code void Start() { text = GetComponent&lt;Text&gt;(); builder = new StringBuilder(50); } void Update() { //StringBuilder has overloaded Append method for all types builder.Length = 0; builder.Append("Player "); builder.Append(name); builder.Append(" has score "); builder.Append(score); text.text = builder.ToString(); }</span></span></code> </pre> <br>  Mit dem oben gezeigten Beispiel ist alles in Ordnung, aber es gibt noch viele M√∂glichkeiten, den Code zu verbessern.  Wie Sie sehen, kann fast die gesamte Zeichenfolge als statisch betrachtet werden.  Wir teilen die Zeichenfolge f√ºr zwei UI.Text-Objekte in zwei Teile auf.  Erstens enth√§lt einer nur den statischen Text <strong>"Spieler" + Name + "hat Punktzahl"</strong> , der in der Startmethode zugewiesen werden kann, und der zweite enth√§lt den Punktzahlwert, der in jedem Frame aktualisiert wird.  <strong>Machen Sie statische Linien immer statisch und generieren Sie sie mit der Methode Start oder Awake</strong> .  Nach dieser Verbesserung ist fast alles in Ordnung, aber beim Aufrufen von Int.ToString (), Float.ToString () usw. wird immer noch ein wenig M√ºll erzeugt. <br><br>  Wir haben dieses Problem gel√∂st, indem wir Speicher f√ºr alle m√∂glichen Zeilen generiert und vorbelegt haben.  Es mag wie eine bl√∂de Verschwendung von Speicher wirken, aber eine solche L√∂sung passt perfekt zu unseren Bed√ºrfnissen und l√∂st das Problem vollst√§ndig.  Am Ende haben wir also ein statisches Array, auf das √ºber Indizes direkt zugegriffen werden kann, um die gew√ºnschte Zeichenfolge f√ºr eine Zahl zu erhalten: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] NUMBERS_THREE_DECIMAL = { <span class="hljs-string"><span class="hljs-string">"000"</span></span>, <span class="hljs-string"><span class="hljs-string">"001"</span></span>, <span class="hljs-string"><span class="hljs-string">"002"</span></span>, <span class="hljs-string"><span class="hljs-string">"003"</span></span>, <span class="hljs-string"><span class="hljs-string">"004"</span></span>, <span class="hljs-string"><span class="hljs-string">"005"</span></span>, <span class="hljs-string"><span class="hljs-string">"006"</span></span>,..........</code> </pre> <br><h2>  Vierte Regel: Von Zugriffsmethoden zur√ºckgegebene Cache-Werte </h2><br>  Dies kann sehr schwierig sein, da selbst eine einfache Zugriffsmethode wie die unten gezeigte M√ºll erzeugt: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { gameObject.tag; //or gameObject.name; }</span></span></code> </pre> <br>  Versuchen Sie, die Verwendung von Zugriffsmethoden in der Update-Methode zu vermeiden.  Rufen Sie die Zugriffsmethode nur einmal in der Start-Methode auf und zwischenspeichern Sie den R√ºckgabewert. <br><br>  Im Allgemeinen empfehle ich, <strong>KEINE String-Zugriffsmethoden oder Array-Zugriffsmethoden in der Update-Methode aufzurufen</strong> .  In den meisten F√§llen reicht es aus <strong>, den Link einmal in der Start-Methode abzurufen</strong> . <br><br>  Hier sind zwei weitere Beispiele f√ºr einen anderen nicht optimierten Zugriffsmethodencode: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { //Allocates new array containing all touches Input.touches[0]; } //Better Code void Update() { Input.GetTouch(0); } //Bad Code void Update() { //Returns new string(garbage) and compare the two strings gameObject.Tag == "MyTag"; } //Better Code void Update() { gameObject.CompareTag("MyTag"); }</span></span></code> </pre> <br><h2>  F√ºnfte Regel: Verwenden Sie Funktionen, die keinen Speicher zuweisen </h2><br>  F√ºr einige Unity-Funktionen k√∂nnen Nicht-Speicher-Alternativen gefunden werden.  In unserem Fall beziehen sich alle diese Funktionen auf die Physik.  Unsere Kollisionserkennung basiert auf <br><br><pre> <code class="cs hljs">Physics2D. CircleCast();</code> </pre> <br>  In diesem speziellen Fall finden Sie eine Nicht-Speicherfunktion namens <br><br><pre> <code class="cs hljs">Physics2D. CircleCastNonAlloc();</code> </pre> <br>  Viele andere Funktionen haben √§hnliche Alternativen. <strong>√úberpr√ºfen Sie</strong> daher <strong>immer die Dokumentation f√ºr NonAlloc-Funktionen</strong> . <br><br><h2>  Sechste Regel: Verwenden Sie nicht LINQ </h2><br>  Tu es einfach nicht.  Ich meine, Sie m√ºssen es in keinem Code verwenden, der h√§ufig ausgef√ºhrt wird.  Ich wei√ü, dass der Code bei Verwendung von LINQ leichter zu lesen ist, aber in vielen F√§llen sind die Leistung und die Speicherzuweisung eines solchen Codes schrecklich.  Nat√ºrlich kann es manchmal verwendet werden, aber um ehrlich zu sein, verwenden wir in unserem Spiel √ºberhaupt kein LINQ. <br><br><h2>  Siebte Regel: Einmal erstellen und wiederverwenden, Teil 2 </h2><br>  Dieses Mal geht es um das Zusammenfassen von Objekten.  Ich werde nicht auf die Details des Poolings eingehen, da dies schon oft gesagt wurde. Studieren Sie beispielsweise dieses Tutorial: <a href="https://learn.unity.com/tutorial/object-pooling">https://learn.unity.com/tutorial/object-pooling</a> <br><br>  In unserem Fall wird das folgende Objektpooling-Skript verwendet.  Wir haben ein generiertes Level mit Hindernissen gef√ºllt, die f√ºr einen bestimmten Zeitraum existieren, bis der Spieler diesen Teil des Levels passiert.  Beispiele f√ºr solche Hindernisse werden aus Fertigteilen erstellt, wenn bestimmte Bedingungen erf√ºllt sind.  Der Code befindet sich in der Update-Methode.  Dieser Code ist in Bezug auf Speicher und Laufzeit v√∂llig ineffizient.  Wir haben das Problem gel√∂st, indem wir einen Pool mit 40 Hindernissen erstellt haben: Falls erforderlich, holen wir Hindernisse aus dem Pool und bringen das Objekt zur√ºck in den Pool, wenn es nicht mehr ben√∂tigt wird. <br><br><h2>  Die achte Regel: aufmerksamer mit Verpackungstransformation (Boxen)! </h2><br>  Boxen erzeugt M√ºll!  Aber was ist Boxen?  Am h√§ufigsten tritt ein Boxing auf, wenn Sie einen Werttyp (int, float, bool usw.) an eine Funktion √ºbergeben, die ein Objekt vom Typ Object erwartet. <br><br>  Hier ist ein Beispiel f√ºr das Boxen, das wir in unserem Projekt beheben m√ºssen: <br><br>  Wir haben im Projekt ein eigenes Messaging-System implementiert.  Jede Nachricht kann eine unbegrenzte Datenmenge enthalten.  Die Daten werden in einem W√∂rterbuch gespeichert, das wie folgt definiert ist: <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data;</code> </pre> <br>  Wir haben auch einen Setter, der Werte in diesem W√∂rterbuch setzt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Action </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attribute, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { data[attribute] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br>  Boxen ist hier ziemlich offensichtlich.  Sie k√∂nnen die Funktion folgenderma√üen aufrufen: <br><br><pre> <code class="cs hljs">SetAttribute(<span class="hljs-string"><span class="hljs-string">"my_int_value"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre> <br>  Dann wird der Wert "12" dem Boxen unterworfen und dies erzeugt M√ºll. <br><br>  Wir haben das Problem gel√∂st, indem wir separate Datencontainer f√ºr jeden primitiven Typ erstellt haben. Der vorherige Objektcontainer wird nur f√ºr Referenztypen verwendet. <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; dataBool; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dataInt; .......</code> </pre> <br>  Wir haben auch separate Setter f√ºr jeden Datentyp: <br><br><pre> <code class="cs hljs">SetBoolAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) SetIntAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  Und all diese Setter sind so implementiert, dass sie dieselbe verallgemeinerte Funktion aufrufen: <br><br><pre> <code class="cs hljs">SetAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, T&gt; dict, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  Das Boxproblem wurde behoben! <br><br>  Weitere Informationen hierzu finden Sie im Artikel <a href="https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing">https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing</a> . <br><br><h2>  Die neunte Regel: Zyklen stehen immer unter Verdacht </h2><br>  Diese Regel ist der ersten und zweiten sehr √§hnlich.  Versuchen Sie einfach, den gesamten optionalen Code aus Leistungs- und Speichergr√ºnden aus den Schleifen zu entfernen. <br><br>  Im Allgemeinen versuchen wir, Schleifen in Update-Methoden zu beseitigen. Wenn wir jedoch nicht auf sie verzichten k√∂nnen, vermeiden wir zumindest die Speicherzuweisung in solchen Schleifen.  Befolgen Sie daher die <strong>Regeln 1 bis 8 und wenden Sie sie</strong> im Allgemeinen <strong>auf Schleifen</strong> an, nicht nur auf Aktualisierungsmethoden. <br><br><h2>  Regel 10: Kein M√ºll in externen Bibliotheken </h2><br>  Wenn sich herausstellt, dass ein Teil des M√ºlls durch aus dem Asset Store heruntergeladenen Code generiert wird, hat dieses Problem viele L√∂sungen.  Bevor Sie jedoch Reverse Engineering und Debugging ausf√ºhren, kehren Sie zum Asset Store zur√ºck und aktualisieren Sie die Bibliothek.  In unserem Fall wurden alle verwendeten Assets weiterhin von Autoren unterst√ºtzt, die weiterhin leistungsverbessernde Updates ver√∂ffentlichten. Dies l√∂ste also alle unsere Probleme.  <strong>Abh√§ngigkeiten m√ºssen relevant sein!</strong>  Ich m√∂chte lieber die Bibliothek loswerden, als nicht unterst√ºtzt zu werden. <br><br><h1>  Teil 2: Maximierung der Laufzeit </h1><br>  Einige der oben genannten Regeln machen einen subtilen Unterschied, wenn der Code selten aufgerufen wird.  In unserem Code gibt es eine gro√üe Schleife, die in jedem Frame ausgef√ºhrt wird, sodass selbst diese kleinen √Ñnderungen eine enorme Auswirkung hatten. <br><br>  Einige dieser √Ñnderungen k√∂nnen bei unsachgem√§√üer Verwendung oder in der falschen Situation zu einer noch schlechteren Laufzeit f√ºhren.  <strong>√úberpr√ºfen Sie den Profiler immer, nachdem Sie jede Optimierung in den Code eingegeben haben, um sicherzustellen, dass Sie sich in die richtige Richtung bewegen</strong> . <br><br>  Ehrlich gesagt f√ºhren einige <strong>dieser Regeln zu viel schlechter lesbarem Code</strong> und <strong>versto√üen</strong> manchmal sogar <strong>gegen Empfehlungen</strong> , z. B. das Einbetten von Code, das in einer der folgenden Regeln erw√§hnt wird. <br><br>  Viele dieser Regeln √ºberschneiden sich mit denen im ersten Teil des Artikels.  In der Regel ist die Leistung von m√ºllgenerierendem Code im Vergleich zu Code ohne m√ºllgenerierenden Code geringer. <br><br><h2>  Die erste Regel: die richtige Ausf√ºhrungsreihenfolge </h2><br>  <strong>Verschieben Sie den Code von den Methoden FixedUpdate, Update, LateUpdate in die Methoden Start und Awake</strong> .  Ich wei√ü, das h√∂rt sich verr√ºckt an, aber glauben Sie mir, wenn Sie sich mit Ihrem Code befassen, werden Sie Hunderte von Codezeilen finden, die in Methoden verschoben werden k√∂nnen, die nur einmal ausgef√ºhrt werden. <br><br>  In unserem Fall ist dieser Code normalerweise mit verkn√ºpft <br><br><ul><li>  Ruft GetComponent &lt;&gt; auf </li><li>  Berechnungen, die in jedem Frame dasselbe Ergebnis liefern </li><li>  Mehrere Instanzen desselben Objekts, normalerweise Listen </li><li>  Suchen Sie nach GameObjects </li><li>  Erhalten von Links zu Transform und Verwenden anderer Zugriffsmethoden </li></ul><br>  Hier ist eine Liste von Beispielcode, den wir von Update-Methoden zu Start-Methoden verschoben haben: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//There must be a good reason to keep GetComponent in Update gameObject.GetComponent&lt;LineRenderer&gt;(); gameObject.GetComponent&lt;CircleCollider2D&gt;(); //Examples of calculations returning same result every frame Mathf.FloorToInt(Screen.width / 2); var width = 2f * mainCamera.orthographicSize * mainCamera.aspect; var castRadius = circleCollider.radius * transform.lossyScale.x; var halfSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x / 2f; //Finding objects var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); var levelCollectibles = FindGameObjectsWithTag("COLLECTIBLE"); //References objectTransform = gameObject.transform; mainCamera = Camera.main;</span></span></code> </pre> <br><h2>  Zweite Regel: Code nur bei Bedarf ausf√ºhren </h2><br>  In unserem Fall betraf dies haupts√§chlich UI-Aktualisierungsskripte.  Hier ist ein Beispiel, wie wir die Implementierung des Codes ge√§ndert haben, der den aktuellen Status der gesammelten Elemente auf der Ebene anzeigt. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code Text text; GameState gameState; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); } void Update() { text.text = gameState.CollectedCollectibles.ToString(); }</span></span></code> </pre> <br>  Da auf jeder Ebene nur wenige Elemente gesammelt werden m√ºssen, ist es nicht sinnvoll, den UI-Text in jedem Frame zu √§ndern.  Daher √§ndern wir den Text nur, wenn sich die Nummer √§ndert. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Better code Text text; GameState gameState; int collectiblesCount; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); collectiblesCount = gameState.CollectedCollectibles; } void Update() { if(collectiblesCount != gameState.CollectedCollectibles) { //This code is ran only about 5 times each level collectiblesCount = gameState.CollectedCollectibles; text.text = collectiblesCount.ToString(); } }</span></span></code> </pre> <br>  Dieser Code ist viel besser, insbesondere wenn die Aktionen viel komplizierter sind als nur das √Ñndern der Benutzeroberfl√§che. <br><br>  Wenn Sie nach einer umfassenderen L√∂sung suchen, empfehle ich die Implementierung <a href="https://en.wikipedia.org/wiki/Observer_pattern">der Observer-Vorlage</a> mithilfe von C # -Ereignissen ( <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/</a> ). <br><br>  Jedenfalls hat uns das noch nicht gereicht, und wir wollten eine vollst√§ndig verallgemeinerte L√∂sung implementieren. <a href="https://facebook.github.io/flux/">Deshalb haben</a> wir eine Bibliothek erstellt, die <a href="https://facebook.github.io/flux/">Flux</a> in Unity implementiert.  Dies f√ºhrte zu einer sehr einfachen L√∂sung, bei der der gesamte Status des Spiels im "Store" -Objekt gespeichert ist und alle UI-Elemente und andere Komponenten benachrichtigt werden, wenn sich der Status √§ndert, und ohne Code in der Update-Methode auf diese √Ñnderung reagieren. <br><br><h2>  Die dritte Regel: Zyklen stehen immer unter Verdacht </h2><br>  Dies ist genau die Regel, die ich im ersten Teil des Artikels erw√§hnt habe.  Wenn der Code eine Art Schleife hat, die eine gro√üe Anzahl von Elementen iterativ umgeht, verwenden Sie beide Regeln aus beiden Teilen des Artikels, um die Leistung der Schleife zu verbessern. <br><br><h2>  Vierte Regel: Besser als Foreach </h2><br>  Die Foreach-Schleife ist sehr einfach zu schreiben, aber "sehr schwierig" auszuf√ºhren.  In der Foreach-Schleife wird Enumerator verwendet, um das Dataset iterativ zu verarbeiten und den Wert zur√ºckzugeben.  Dies ist komplizierter als das Durchlaufen von Indizes in einer einfachen For-Schleife. <br><br>  Daher haben wir in unserem Projekt Foreach-Schleifen nach M√∂glichkeit durch For ersetzt: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code foreach (GameObject obstacle in obstacles) //Better code var count = obstacles.Count; for (int i = 0; i &lt; count; i++) { obstacles[i]; }</span></span></code> </pre> <br>  In unserem Fall mit einer gro√üen for-Schleife ist diese √Ñnderung sehr bedeutend.  <strong>Eine einfache for-Schleife beschleunigt den Code zweimal</strong> . <br><br><h2>  F√ºnfte Regel: Arrays sind besser als Listen </h2><br>  In unserem Code haben wir festgestellt, dass die meisten Listen eine konstante L√§nge haben, oder wir k√∂nnen die maximale Anzahl von Elementen berechnen.  Aus diesem Grund haben wir sie basierend auf Arrays erneut implementiert. In einigen F√§llen f√ºhrte dies zu einer zweifachen Beschleunigung der Dateniterationen. <br><br>  In einigen F√§llen k√∂nnen Listen oder andere komplexe Datenstrukturen nicht vermieden werden.  Es kommt vor, dass Sie h√§ufig Elemente hinzuf√ºgen oder entfernen m√ºssen. In diesem Fall ist es besser, Listen zu verwenden.  Generell sollten <strong>Arrays jedoch immer f√ºr Listen mit fester L√§nge verwendet werden</strong> . <br><br><h2>  Sechste Regel: Float-Operationen sind besser als Vektoroperationen </h2><br>  Dieser Unterschied ist kaum sp√ºrbar, wenn Sie nicht wie in unserem Fall Tausende solcher Vorg√§nge ausf√ºhren, sodass sich f√ºr uns eine erhebliche Produktivit√§tssteigerung herausgestellt hat. <br><br>  Wir haben √§hnliche √Ñnderungen vorgenommen: <br><br><pre> <code class="cs hljs">Vector3 pos1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); Vector3 pos2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Bad code var pos3 = pos1 + pos2; //Better code var pos3 = new Vector3(pos1.x + pos2.x, pos1.y + pos2.y, ......); Vector3 pos1 = new Vector3(1,2,3); //Bad code var pos2 = pos1 * 2f; //Better code var pos2 = new Vector3(pos1.x * 2f, pos1.y * 2f, ......);</span></span></code> </pre> <br><h2>  Siebte Regel: Objekte richtig suchen </h2><br>  √úberlegen Sie immer, ob Sie die GameObject.Find () -Methode wirklich verwenden m√ºssen.  Diese Methode ist schwerf√§llig und dauert wahnsinnig lange.  Sie sollten diese Methode niemals in Update-Methoden verwenden.  Wir haben festgestellt, dass die meisten unserer Find-Aufrufe <strong>durch direkte Links im Editor ersetzt werden k√∂nnen</strong> , was nat√ºrlich viel besser ist. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code GameObject player; void Start() { player = GameObject.Find("PLAYER"); } //Better Code //Assign the reference to the player object in editor [SerializeField] GameObject player; void Start() { }</span></span></code> </pre> <br>  Wenn dies nicht m√∂glich ist, sollten Sie zumindest <strong>die Verwendung von Tags (Tag)</strong> in <strong>Betracht ziehen und mithilfe von GameObject.FindWithTag nach einem Objekt anhand seiner Bezeichnung suchen</strong> . <br><br>  Im allgemeinen Fall also: <strong>Direkter Link&gt; GameObject.FindWithTag ()&gt; GameObject.Find ()</strong> <br><br><h2>  Achte Regel: Nur mit relevanten Objekten arbeiten </h2><br>  In unserem Fall war dies wichtig, um Kollisionen mit RayCast-s (CircleCast usw.) zu erkennen.  Anstatt Kollisionen zu erkennen und zu entscheiden, welche davon im Code wichtig sind, haben <strong>wir die Spielobjekte auf die entsprechenden Ebenen verschoben,</strong> sodass wir Kollisionen nur f√ºr die erforderlichen Objekte berechnen k√∂nnen. <br><br>  Hier ist ein Beispiel <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void DetectCollision() { var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance); for (int i = 0; i &lt; count; i++) { var obj = results[i].collider.transform.gameObject; if(obj.CompareTag("FOO")) { ProcessCollision(results[i]); } } } //Better Code //We added all objects with tag FOO into the same layer void DetectCollision() { //8 is number of the desired layer var mask = 1 &lt;&lt; 8; var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance, mask); for (int i = 0; i &lt; count; i++) { ProcessCollision(results[i]); } }</span></span></code> </pre> <br><h2>  Die neunte Regel: Verwenden Sie Etiketten richtig </h2><br>  Es besteht kein Zweifel, dass Beschriftungen sehr n√ºtzlich sind und die Codeleistung verbessern k√∂nnen. Denken Sie jedoch daran, dass <strong>es nur eine richtige Methode zum Vergleichen von Objektbeschriftungen gibt</strong> ! <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code gameObject.Tag == "MyTag"; //Better Code gameObject.CompareTag("MyTag");</span></span></code> </pre> <br><h2>  Die zehnte Regel: Vorsicht vor Tricks mit der Kamera! </h2><br>  Es ist so einfach, <strong>Camera.main</strong> zu verwenden, aber die Leistung dieser Aktion ist sehr schlecht.  Der Grund daf√ºr ist, dass die Unity-Engine hinter den Kulissen jedes Aufrufs von Camera.main tats√§chlich das FindGameObjectsWithTag () -Ergebnis ausf√ºhrt, sodass wir bereits verstehen, dass Sie es nicht oft aufrufen m√ºssen. Es ist am besten, dieses Problem durch <strong>Zwischenspeichern des Links in der Start-Methode</strong> zu l√∂sen oder wach. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { Camera.main.orthographicSize //Some operation with camera } //Better Code private Camera cam; void Start() { cam = Camera.main; } void Update() { cam.orthographicSize //Some operation with camera }</span></span></code> </pre> <br><h2>  Elfte Regel: LocalPosition ist besser als Position </h2><br>  <strong>Verwenden Sie nach M√∂glichkeit Transform.LocalPosition f√ºr Getter und Setter anstelle von Transform.Position</strong> .  Innerhalb jedes Transform.Position-Aufrufs werden viel mehr Operationen ausgef√ºhrt, beispielsweise das Berechnen der globalen Position im Fall eines Getter-Aufrufs oder das Berechnen der lokalen Position aus der globalen Position im Fall eines Setter-Aufrufs.  In unserem Projekt stellte sich heraus, dass Sie LocalPositions in 99% der F√§lle mit Transform.Position verwenden k√∂nnen und keine weiteren √Ñnderungen im Code vornehmen m√ºssen. <br><br><h2>  Zw√∂lfte Regel: Verwenden Sie LINQ nicht </h2><br>  Dies wurde bereits im ersten Teil besprochen.  Benutz es einfach nicht, das ist alles. <br><br><h2>  Dreizehnte Regel: Hab (manchmal) keine Angst, die Regeln zu brechen </h2><br>  Manchmal kann sogar das Aufrufen einer einfachen Funktion zu kostspielig sein.  In diesem Fall sollten Sie immer √ºberlegen, Code einzubetten (Code Inlining).  Was bedeutet das?  Tats√§chlich nehmen wir einfach den Code aus der Funktion und kopieren ihn direkt an die Stelle, an der wir die Funktion verwenden m√∂chten, um den Aufruf zus√§tzlicher Methoden zu vermeiden. <br><br>  In den meisten F√§llen hat dies keine Auswirkung, da das Einbetten des Codes bereits in der Kompilierungsphase automatisch erfolgt. Der Compiler entscheidet jedoch nach bestimmten Regeln, ob der Code eingebettet werden soll (virtuelle Methoden werden beispielsweise nie eingebettet. Weitere Informationen finden Sie unter <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html">https: //docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html</a> ).  √ñffnen Sie einfach den Profiler, starten Sie das Spiel auf dem Zielger√§t und pr√ºfen Sie, ob etwas verbessert werden kann. <br><br>  In unserem Fall gab es mehrere Funktionen, die wir integriert haben, um die Leistung zu verbessern, insbesondere in der gro√üen for-Schleife. <br><br><h1>  Fazit </h1><br>  Unter Anwendung der im Artikel aufgef√ºhrten Regeln haben wir im Spiel f√ºr iOS problemlos stabile 60 fps erreicht, auch auf dem iPhone 5S.  Vielleicht sind einige der Regeln nur f√ºr unser Projekt spezifisch, aber ich denke, dass die meisten davon beachtet werden sollten, wenn Code geschrieben oder √ºberpr√ºft wird, um k√ºnftige Probleme zu vermeiden.  Es ist immer besser, st√§ndig auf der Leistung basierenden Code zu schreiben, als sp√§ter gro√üe Codeteile neu zu faktorisieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481980/">https://habr.com/ru/post/de481980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481960/index.html">2. Elastic Stack: Analyse von Sicherheitsprotokollen. Logstash</a></li>
<li><a href="../de481964/index.html">So organisieren Sie eine Ver√∂ffentlichung</a></li>
<li><a href="../de481970/index.html">‚ÄûVergessene Audioformate und -medien‚Äú: Der Beginn der √Ñra von Compact Audio oder ‚ÄûFirst Change‚Äú f√ºr Bobbins</a></li>
<li><a href="../de481974/index.html">Testen von Wassermelonen mit neuronalen Netzen: Full Dev. Wechseln Sie vom Prototyping zur App. bei google play</a></li>
<li><a href="../de481978/index.html">So organisieren Sie die effektive Arbeit eines verteilten Layout-Teams</a></li>
<li><a href="../de481988/index.html">Warum ist Koji die perfekte Ressource f√ºr Anf√§nger KaiOS App-Ersteller</a></li>
<li><a href="../de481990/index.html">Zehn Jahre Malware: 2010 die gr√∂√üten Botnets</a></li>
<li><a href="../de481992/index.html">Tekton-Pipeline - Kubernetes-native Pipelines</a></li>
<li><a href="../de481996/index.html">Habra Detektiv am Wochenende 2. Neues Level</a></li>
<li><a href="../de481998/index.html">Turing-Maschine als Modell von Automatenprogrammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>