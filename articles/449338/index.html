<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßì üí® ‚óÄÔ∏è Julia Servicios web üòÇ ‚¨õÔ∏è ‚úäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seguimos considerando las tecnolog√≠as de Julia. Y hoy hablaremos de paquetes dise√±ados para crear servicios web. No es ning√∫n secreto que el nicho pri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia Servicios web</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449338/"><p><img src="https://habrastorage.org/webt/ez/8k/mw/ez8kmwwtsavwdve31oj9__-kj6e.png"></p><br><p>  Seguimos considerando las tecnolog√≠as de Julia.  Y hoy hablaremos de paquetes dise√±ados para crear servicios web.  No es ning√∫n secreto que el nicho principal del lenguaje Julia es la inform√°tica de alto rendimiento.  Por lo tanto, un paso bastante l√≥gico es crear directamente servicios web capaces de realizar estos c√°lculos a pedido.  Por supuesto, los servicios web no son la √∫nica forma de comunicarse en un entorno en red.  Pero, dado que ahora son los m√°s utilizados en sistemas distribuidos, consideraremos la creaci√≥n de servicios que atiendan solicitudes HTTP. </p><br><p>  Tenga en cuenta que debido a la juventud de Julia, hay un conjunto de paquetes competitivos.  Por lo tanto, trataremos de descubrir c√≥mo y por qu√© usarlos.  En el camino, comparamos la implementaci√≥n del mismo servicio web JSON con su ayuda. </p><a name="habracut"></a><br><p>  La infraestructura de Julia se ha desarrollado activamente en el √∫ltimo a√±o o dos.  Y, en este caso, esta no es solo una frase en l√≠nea inscrita para un hermoso comienzo del texto, sino un √©nfasis en el hecho de que todo est√° cambiando intensamente y que lo que era relevante hace un par de a√±os ahora est√° desactualizado.  Sin embargo, intentaremos resaltar paquetes estables y dar recomendaciones sobre c√≥mo implementar servicios web con su ayuda.  Para mayor claridad, crearemos un servicio web que acepte una solicitud POST con datos JSON en el siguiente formato: </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span> }</code> </pre> <br><p>  Asumimos que el servicio que creamos no es RESTful.  Nuestra tarea principal es considerar con precisi√≥n los m√©todos para describir rutas y manejadores de solicitudes. </p><br><h2 id="paket-httpjl">  Paquete HTTP.jl </h2><br><p>  Este paquete es la implementaci√≥n principal del protocolo HTTP en Julia y est√° gradualmente cubierto de nuevas caracter√≠sticas.  Adem√°s de implementar estructuras y funciones t√≠picas para ejecutar solicitudes de clientes HTTP, este paquete tambi√©n implementa funciones para crear servidores HTTP.  Al mismo tiempo, a medida que se desarrolla, el paquete ha recibido funciones que hacen que sea muy conveniente para el programador registrar controladores y, por lo tanto, crear servicios t√≠picos.  Adem√°s, en las √∫ltimas versiones, hay soporte incorporado para el protocolo WebSocket, cuya implementaci√≥n se realiz√≥ previamente como parte de un paquete separado WebSocket.jl.  Es decir, HTTP.jl, en la actualidad, puede satisfacer la mayor√≠a de las necesidades de un programador.  Veamos un par de ejemplos con m√°s detalle. </p><br><h3 id="klient-http">  Cliente HTTP </h3><br><p>  Comenzamos la implementaci√≥n con el c√≥digo del cliente, que usaremos para verificar la operatividad. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import HTTP import JSON.json const PORT = "8080" const HOST = "127.0.0.1" const NAME = "Jemand" #    struct Document title::String body::String end #         Base.show(r::HTTP.Messages.Response) = println(r.status == 200 ? String(r.body) : "Error: " * r.status) #    r = HTTP.get("http://$(HOST):$(PORT)") show(r) #   /user/:name r = HTTP.get("http://$(HOST):$(PORT)/user/$(NAME)"; verbose=1) show(r) #  JSON- POST- doc = Document("Some document", "Test document with some content.") r = HTTP.post( "http://$(HOST):$(PORT)/resource/process", [("Content-Type" =&gt; "application/json")], json(doc); verbose=3) show(r)</span></span></code> </pre> <br><p>  El paquete HTTP proporciona m√©todos que coinciden con los nombres de los comandos del protocolo HTTP.  En este caso, usamos <code>get</code> y <code>post</code> .  El argumento opcional con nombre <code>verbose</code> permite establecer la cantidad de informaci√≥n de depuraci√≥n que se generar√°.  Entonces, por ejemplo, <code>verbose=1</code> producir√°: </p><br><pre> <code class="plaintext hljs">GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1)</code> </pre> <br><p>  Y en el caso de <code>verbose=3</code> ya obtenemos un conjunto completo de datos transmitidos y recibidos: </p><br><pre> <code class="plaintext hljs">DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "POST /resource/process HTTP/1.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Content-Type: application/json\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Host: 127.0.0.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Content-Length: 67\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 e1c6 Ô∏è-&gt; "{\"title\":\"Some document\",\"body\":\"Test document with some content.\"}" (unsafe_write) DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "HTTP/1.1 200 OK\r\n" (readuntil) DEBUG: "Content-Type: application/json\r\n" DEBUG: "Transfer-Encoding: chunked\r\n" DEBUG: "\r\n" DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "5d\r\n" (readuntil) DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "{\"body\":\"Test document with some content.\",\"server_mark\":\"confirmed\",\"title\":\"Some document\"}" (unsafe_read) DEBUG: 2019-04-21T22:40:40.968 eb4f Ô∏è&lt;- "\r\n" (readuntil) DEBUG: "0\r\n" DEBUG: 2019-04-21T22:40:40.968 eb4f Ô∏è&lt;- "\r\n" (readuntil)</code> </pre> <br><p>  En el futuro, usaremos solo <code>verbose=1</code> para ver informaci√≥n m√≠nima sobre lo que est√° sucediendo. </p><br><p>  Algunos comentarios sobre el c√≥digo. </p><br><pre> <code class="julia hljs">doc = Document(<span class="hljs-string"><span class="hljs-string">"Some document"</span></span>, <span class="hljs-string"><span class="hljs-string">"Test document with some content."</span></span>)</code> </pre> <br><p>  Como declaramos previamente la estructura del documento (adem√°s, inmutable), un constructor est√° disponible de forma predeterminada, cuyos argumentos corresponden a los campos declarados de la estructura.  Para convertirlo a JSON, utilizamos el paquete <code>JSON.jl</code> y su m√©todo <code>json(doc)</code> . <br>  Presta atenci√≥n al fragmento: </p><br><pre> <code class="julia hljs">r = HTTP.post( <span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(HOST)</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(PORT)</span></span></span><span class="hljs-string">/resource/process"</span></span>, [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)], json(doc); verbose=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Como estamos pasando JSON, debe especificar expl√≠citamente el tipo <code>application/json</code> en el encabezado <code>Content-Type</code> .  Los encabezados se pasan al m√©todo <code>HTTP.post</code> (sin embargo, como todos los dem√°s) utilizando una matriz (de tipo Vector, pero no Dict) que contiene el nombre del encabezado - pares de valores. </p><br><p>  Para una prueba de salud, realizaremos tres consultas: </p><br><ul><li>  OBTENER solicitud a la ruta ra√≠z; </li><li>  Solicitud GET en el formato / usuario / nombre, donde nombre es el nombre transmitido; </li><li>  Solicitud POST / recurso / proceso con un objeto JSON pasado.  Esperamos recibir el mismo documento, pero con el campo <code>server_mark</code> agregado. </li></ul><br><p>  Usaremos este c√≥digo de cliente para probar todas las opciones de implementaci√≥n del servidor. </p><br><h3 id="server-http">  Servidor HTTP </h3><br><p>  Despu√©s de descubrir el cliente, es hora de comenzar a implementar el servidor.  Para comenzar, haremos el servicio solo con la ayuda de <code>HTTP.jl</code> para mantenerlo como una opci√≥n b√°sica, que no requiere la instalaci√≥n de otros paquetes.  Le recordamos que todos los dem√°s paquetes usan <code>HTTP.jl</code> </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import Sockets import HTTP import JSON #    #    index(req::HTTP.Request) = HTTP.Response(200, "Hello World") #     function welcome_user(req::HTTP.Request) # dump(req) user = "" if (m = match( r".*/user/([[:alpha:]]+)", req.target)) != nothing user = m[1] end return HTTP.Response(200, "Hello " * user) end #  JSON function process_resource(req::HTTP.Request) # dump(req) message = JSON.parse(String(req.body)) @info message message["server_mark"] = "confirmed" return HTTP.Response(200, JSON.json(message)) end #      const ROUTER = HTTP.Router() HTTP.@register(ROUTER, "GET", "/", index) HTTP.@register(ROUTER, "GET", "/user/*", welcome_user) HTTP.@register(ROUTER, "POST", "/resource/process", process_resource) HTTP.serve(ROUTER, Sockets.localhost, 8080)</span></span></code> </pre> <br><p>  En el ejemplo, debe prestar atenci√≥n al siguiente c√≥digo: </p><br><pre> <code class="julia hljs">dump(req)</code> </pre> <br><p>  imprime en la consola todo lo que el objeto conoce.  Incluyendo tipos de datos, valores, as√≠ como todos los campos anidados y sus valores.  Este m√©todo es √∫til tanto para la investigaci√≥n de bibliotecas como para la depuraci√≥n. </p><br><p>  Cadena </p><br><pre> <code class="julia hljs">(m = match( <span class="hljs-string"><span class="hljs-string">r".*/user/([[:alpha:]]+)"</span></span>, req.target))</code> </pre> <br><p>  es una expresi√≥n regular que analiza la ruta en la que est√° registrado el controlador.  El paquete <code>HTTP.jl</code> no proporciona formas autom√°ticas de identificar un patr√≥n en una ruta. </p><br><p>  Dentro del controlador <code>process_resource</code> , analizamos el JSON que acepta el servicio. </p><br><pre> <code class="julia hljs">message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req.body))</code> </pre> <br><p>  Se accede a los datos a trav√©s del campo <code>req.body</code> .  Tenga en cuenta que los datos vienen en un formato de matriz de bytes.  Por lo tanto, para trabajar con ellos como una cadena, se realiza una conversi√≥n expl√≠cita a una cadena.  El m√©todo <code>JSON.parse</code> es un m√©todo de paquete <code>JSON.jl</code> que deserializa los datos y crea un objeto.  Dado que el objeto en este caso es una matriz asociativa (Dict), podemos agregarle f√°cilmente una nueva clave.  Cadena </p><br><pre> <code class="julia hljs">message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span></code> </pre> <br><p>  agrega la clave <code>server_mark</code> con el valor <code>confirmed</code> . </p><br><p>  El servicio se <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> cuando se <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> l√≠nea <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> . </p><br><p>  La respuesta de control para el servicio basada en HTTP.jl (obtenida al ejecutar el c√≥digo del cliente con <code>verbose=1</code> ): </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  En el contexto de la informaci√≥n de depuraci√≥n con <code>verbose=1</code> , podemos ver claramente las l√≠neas: <code>Hello World</code> , <code>Hello Jemand</code> , <code>"server_mark":"confirmed"</code> . </p><br><p>  Despu√©s de ver el c√≥digo de servicio, surge una pregunta natural: ¬øpor qu√© necesitamos todos los dem√°s paquetes, si todo es tan simple en HTTP?  Hay una respuesta muy simple a esto.  HTTP: permite registrar controladores din√°micos, pero incluso una implementaci√≥n elemental de leer un archivo de imagen est√°tico desde un directorio requiere una implementaci√≥n separada.  Por lo tanto, tambi√©n consideramos paquetes que se centran en la creaci√≥n de aplicaciones web. </p><br><h2 id="paket-muxjl">  Paquete Mux.jl </h2><br><p>  Este paquete se posiciona como una capa intermedia para aplicaciones web implementadas en Julia.  Su implementaci√≥n es muy ligera.  El objetivo principal es proporcionar una manera f√°cil de describir los controladores.  Esto no quiere decir que el proyecto no se est√© desarrollando, sino que se est√° desarrollando lentamente.  Sin embargo, mire el c√≥digo de nuestro servicio que sirve las mismas rutas. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Mux using JSON @app test = ( Mux.defaults, page(respond("&lt;h1&gt;Hello World!&lt;/h1&gt;")), page("/user/:user", req -&gt; "&lt;h1&gt;Hello, $(req[:params][:user])!&lt;/h1&gt;"), route("/resource/process", req -&gt; begin message = JSON.parse(String(req[:data])) @info message message["server_mark"] = "confirmed" return Dict( :body =&gt; JSON.json(message), :headers =&gt; [("Content-Type" =&gt; "application/json")] ) end), Mux.notfound() ) serve(test, 8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Aqu√≠ las rutas se describen utilizando el m√©todo de <code>page</code> .  La aplicaci√≥n web se declara utilizando la macro <code>@app</code> .  Los argumentos del m√©todo de <code>page</code> son la ruta y el controlador.  Un controlador puede especificarse como una funci√≥n que acepta una solicitud como entrada, o puede especificarse como una funci√≥n lambda en su lugar.  De las funciones √∫tiles adicionales, <code>Mux.notfound()</code> presente para enviar la respuesta <code>Not found</code> especificada.  Y el resultado que debe enviarse al cliente no necesita empaquetarse en <code>HTTP.Response</code> . <code>HTTP.Response</code> , como hicimos en el ejemplo anterior, ya que Mux lo har√° √©l mismo.  Sin embargo, a√∫n tiene que hacer el an√°lisis JSON usted mismo, al igual que serializar el objeto para la respuesta: <code>JSON.json(message)</code> . </p><br><pre> <code class="julia hljs"> message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req[:data])) message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>( :body =&gt; JSON.json(message), :headers =&gt; [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)] )</code> </pre> <br><p>  La respuesta se env√≠a como una matriz asociativa con los campos <code>:body</code> <code>:headers</code> . </p><br><p>  Iniciar el servidor con el m√©todo de <code>serve(test, 8080)</code> es as√≠ncrono, por lo que una de las opciones en Julia para organizar la espera de finalizaci√≥n es llamar al c√≥digo: </p><br><pre> <code class="julia hljs">Base.JLOptions().isinteractive == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; wait()</code> </pre> <br><p>  De lo contrario, el servicio hace lo mismo que la versi√≥n anterior en <code>HTTP.jl</code> </p><br><p>  Respuesta de control para el servicio: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) &lt;h1&gt;Hello World!&lt;/h1&gt; GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) &lt;h1&gt;Hello, Jemand!&lt;/h1&gt; POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><h2 id="paket-bukdujl">  Paquete Bukdu.jl </h2><br><p>  El paquete se desarroll√≥ bajo la influencia del marco Phoenix, que, a su vez, se implementa en Elixir y es la implementaci√≥n de ideas de construcci√≥n web de la comunidad Ruby en proyecci√≥n sobre Elixir.  El proyecto se est√° desarrollando de manera bastante activa y se posiciona como una herramienta para crear una API RESTful y aplicaciones web livianas.  Hay funciones para simplificar la serializaci√≥n y deserializaci√≥n de JSON.  Esto falta en <code>HTTP.jl</code> y <code>Mux.jl</code>  Veamos la implementaci√≥n de nuestro servicio web. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Bukdu using JSON #   struct WelcomeController &lt;: ApplicationController conn::Conn end #   index(c::WelcomeController) = render(JSON, "Hello World") welcome_user(c::WelcomeController) = render(JSON, "Hello " * c.params.user) function process_resource(c::WelcomeController) message = JSON.parse(String(c.conn.request.body)) @info message message["server_mark"] = "confirmed" render(JSON, message) end #   routes() do get("/", WelcomeController, index) get("/user/:user", WelcomeController, welcome_user, :user =&gt; String) post("/resource/process", WelcomeController, process_resource) end #   Bukdu.start(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Lo primero a lo que debe prestar atenci√≥n es a la declaraci√≥n de la estructura para almacenar el estado del controlador. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WelcomeController &lt;: ApplicationController conn::Conn <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  En este caso, es un tipo concreto creado como descendiente del tipo abstracto <code>ApplicationController</code> . </p><br><p>  Los m√©todos para el controlador se declaran de manera similar con respecto a implementaciones anteriores.  Hay una ligera diferencia en el controlador de nuestro objeto JSON. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> process_resource(c::WelcomeController) message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(c.conn.request.body)) <span class="hljs-meta"><span class="hljs-meta">@info</span></span> message message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> render(JSON, message) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Como puede ver, la deserializaci√≥n tambi√©n se realiza de forma independiente utilizando el m√©todo <code>JSON.parse</code> , pero el m√©todo de <code>render(JSON, message)</code> <code>JSON.parse</code> se utiliza para serializar la respuesta. </p><br><p>  La declaraci√≥n de rutas se lleva a cabo en el estilo tradicional para los rubistas, incluido el uso del bloque <code>do...end</code> . </p><br><pre> <code class="julia hljs">routes() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, WelcomeController, index) get(<span class="hljs-string"><span class="hljs-string">"/user/:user"</span></span>, WelcomeController, welcome_user, :user =&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) post(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, WelcomeController, process_resource) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Adem√°s, de la manera tradicional para los rubistas, se declara un segmento en la l√≠nea de ruta <code>/user/:user</code> .  En otras palabras, la parte variable de la expresi√≥n, cuyo acceso puede realizarse mediante el nombre especificado en la plantilla.  Se designa sint√°cticamente como un representante de tipo <code>Symbol</code> .  Por cierto, para Julia, el tipo <code>Symbol</code> significa, en esencia, lo mismo que para Ruby: esta es una cadena inmutable, representada en la memoria por una sola instancia. </p><br><p>  En consecuencia, despu√©s de declarar una ruta con una parte variable, y tambi√©n indicar el tipo de esta parte variable, podemos referirnos a los datos ya analizados por el nombre asignado.  En el m√©todo que procesa la solicitud, simplemente accedemos al campo a trav√©s de un punto en el formulario <code>c.params.user</code> . </p><br><pre> <code class="julia hljs">welcome_user(c::WelcomeController) = render(JSON, <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> * c.params.user)</code> </pre> <br><p>  Respuesta de control para el servicio: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) "Hello World" GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) "Hello Jemand" POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Conclusi√≥n del servicio a la consola: </p><br><pre> <code class="plaintext hljs">&gt;./bukdu_json.jl INFO: Bukdu Listening on 127.0.0.1:8080 INFO: GET WelcomeController index 200 / INFO: GET WelcomeController welcome_user 200 /user/Jemand INFO: Dict{String,Any}("body"=&gt;"Test document with some content.","title"=&gt;"Some document") INFO: POST WelcomeController process_resource200 /resource/process</code> </pre> <br><h2 id="paket-geniejl">  Paquete Genie.jl </h2><br><p>  Un ambicioso proyecto posicionado como un marco web MVC.  En su enfoque, los "carriles" en Julia son claramente visibles, incluida la estructura de directorios creada por el generador.  El proyecto se est√° desarrollando, sin embargo, por razones desconocidas, este paquete no est√° incluido en el repositorio de paquetes de Julia.  Es decir, su instalaci√≥n solo es posible desde el repositorio git con el comando: </p><br><pre> <code class="julia hljs">julia&gt;] <span class="hljs-comment"><span class="hljs-comment"># switch to pkg&gt; mode pkg&gt; add https://github.com/essenciary/Genie.jl</span></span></code> </pre> <br><p>  El c√≥digo de nuestro servicio en Genie es el siguiente (no utilizamos generadores): </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. #     import Genie import Genie.Router: route, @params, POST import Genie.Requests: jsonpayload, rawpayload import Genie.Renderer: json! #      route("/") do "Hello World!" end route("/user/:user") do "Hello " * @params(:user) end route("/resource/process", method = POST) do message = jsonpayload() # if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end #   Genie.AppServer.startup(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Aqu√≠ debe prestar atenci√≥n al formato de la declaraci√≥n. </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Este c√≥digo es muy familiar para los programadores de Ruby.  El bloque <code>do...end</code> como manejador y la ruta como argumento del m√©todo.  Tenga en cuenta que para Julia este c√≥digo puede reescribirse en la forma: </p><br><pre> <code class="julia hljs">route(req -&gt; <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>)</code> </pre> <br><p>  Es decir, la funci√≥n del controlador est√° en primer lugar, la ruta est√° en el segundo.  Pero para nuestro caso, dejemos el estilo rub√≠. </p><br><p>  Genie empaqueta autom√°ticamente el resultado de la ejecuci√≥n en una respuesta HTTP.  En el caso m√≠nimo, solo necesitamos devolver el resultado del tipo correcto, por ejemplo String.  De los servicios adicionales, se implementa una verificaci√≥n autom√°tica del formato de entrada y su an√°lisis.  Por ejemplo, para JSON, solo necesita llamar al m√©todo <code>jsonpayload()</code> . </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, method = POST) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> message = jsonpayload() <span class="hljs-comment"><span class="hljs-comment"># if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end</span></span></code> </pre> <br><p>  Presta atenci√≥n al fragmento de c√≥digo comentado aqu√≠.  El m√©todo <code>jsonpayload()</code> <code>nothing</code> devuelve <code>nothing</code> si por alguna raz√≥n el formato de entrada no se reconoce como JSON.  Tenga en cuenta que solo por esto, el encabezado <code>[("Content-Type" =&gt; "application/json")]</code> agrega a nuestro cliente HTTP, porque de lo contrario Genie ni siquiera comenzar√° a analizar los datos como JSON.  En caso de que algo incomprensible haya llegado, es √∫til mirar <code>rawpayload()</code> para saber qu√© es.  Sin embargo, dado que esta es solo una fase de depuraci√≥n, no debe dejarla en el c√≥digo. </p><br><p>  Adem√°s, debe prestar atenci√≥n a devolver el resultado en el <code>message |&gt; json!</code> formato <code>message |&gt; json!</code>  .  El m√©todo <code>json!(str)</code> se coloca aqu√≠ en √∫ltimo lugar.  Proporciona la serializaci√≥n de datos en formato JSON y tambi√©n garantiza que Genie agregue el tipo de <code>Content-Type</code> correcto.  Adem√°s, preste atenci√≥n al hecho de que la palabra <code>return</code> en la mayor√≠a de los casos en los ejemplos anteriores es redundante.  Julia, como Ruby, por ejemplo, siempre devuelve el resultado de la √∫ltima operaci√≥n o el valor de la √∫ltima expresi√≥n especificada.  Es decir, la palabra <code>return</code> es opcional. </p><br><p>  Las capacidades de Genie no terminan ah√≠, pero no las necesitamos para implementar un servicio web. </p><br><p>  Respuesta de control para el servicio: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World! GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Conclusi√≥n del servicio a la consola: </p><br><pre> <code class="plaintext hljs">&gt;./genie_json.jl [ Info: Ready! 2019-04-24 17:18:51:DEBUG:Main: Web Server starting at http://127.0.0.1:8080 2019-04-24 17:18:51:DEBUG:Main: Web Server running at http://127.0.0.1:8080 2019-04-24 17:19:21:INFO:Main: / 200 2019-04-24 17:19:21:INFO:Main: /user/Jemand 200 2019-04-24 17:19:22:INFO:Main: /resource/process 200</code> </pre> <br><h2 id="paket-juliawebapijl">  Paquete JuliaWebAPI.jl </h2><br><p>  Este paquete se posicion√≥ como una capa intermedia para crear aplicaciones web en aquellos d√≠as en que HTTP.jl era solo una biblioteca que implementa el protocolo.  El autor de este paquete tambi√©n implement√≥ un generador de c√≥digo de servidor basado en la especificaci√≥n Swagger (OpenAPI y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://editor.swagger.io/</a> ) - vea el proyecto <a href="">https://github.com/JuliaComputing/Swagger.jl</a> , y este generador us√≥ JuliaWebAPI .jl.  Sin embargo, el problema con JuliaWebAPI.jl es que no implementa la capacidad de procesar el cuerpo de la solicitud (por ejemplo, JSON) enviada al servidor a trav√©s de una solicitud POST.  El autor cree que pasar par√°metros en un formato clave-valor es adecuado para todas las ocasiones ... El futuro de este paquete no est√° claro.  Todas sus funciones ya est√°n implementadas en muchos otros paquetes, incluido HTTP.jl.  El paquete Swagger.jl tampoco lo usa m√°s. </p><br><h2 id="websocketsjl">  WebSockets.jl </h2><br><p>  Una implementaci√≥n temprana del protocolo WebSocket.  El paquete se ha utilizado durante mucho tiempo como la implementaci√≥n principal de este protocolo, sin embargo, en la actualidad, su implementaci√≥n est√° incluida en el paquete HTTP.jl.  El paquete WebSockets.jl usa HTTP.jl para establecer una conexi√≥n, sin embargo, ahora no vale la pena usarlo en nuevos desarrollos.  Debe considerarse como un paquete de compatibilidad. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Esta revisi√≥n muestra varias formas de implementar un servicio web en Julia.  La forma m√°s f√°cil y universal es usar directamente el paquete HTTP.jl.  Adem√°s, los paquetes Bukdu.jl y Genie.jl son muy √∫tiles.  Como m√≠nimo, su desarrollo debe ser monitoreado.  Con respecto al paquete Mux.jl, sus ventajas ahora se est√°n disolviendo en el contexto de HTTP.jl.  Por lo tanto, la opini√≥n personal es no usarlo.  Genie.jl es un marco muy prometedor.  Sin embargo, antes de comenzar a usarlo, al menos debe comprender por qu√© el autor no lo registra como un paquete oficial. </p><br><p>  Tenga en cuenta que el c√≥digo de deserializaci√≥n JSON en los ejemplos se utiliz√≥ sin manejo de errores.  En todos los casos, excepto Genie, es necesario manejar los errores de an√°lisis e informar al usuario sobre esto.  Un ejemplo de dicho c√≥digo para HTTP.jl: </p><br><pre> <code class="julia hljs"> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> message = <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-built_in"><span class="hljs-built_in">IOBuffer</span></span>(HTTP.payload(req)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> message = JSON.parse(body) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> err <span class="hljs-meta"><span class="hljs-meta">@error</span></span> err.msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTTP.Response(<span class="hljs-number"><span class="hljs-number">400</span></span>, string(err.msg)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  En general, podemos decir que ya hay suficientes fondos para crear servicios web en Julia.  Es decir, no hay necesidad de "reinventar la rueda" para escribirlos.  El siguiente paso es evaluar c√≥mo Julia puede soportar la carga en los puntos de referencia existentes, si alguien est√° listo para tomarla.  Sin embargo, por ahora deteng√°monos en esta revisi√≥n. </p><br><h2 id="ssylki">  Referencias </h2><br><ul><li>  <a href="">https://github.com/JuliaWeb/HTTP.jl</a> </li><li>  <a href="">https://github.com/JuliaWeb/Mux.jl</a> </li><li>  <a href="">https://github.com/wookay/Bukdu.jl</a> </li><li>  <a href="">https://github.com/essenciary/Genie.jl</a> </li><li>  <a href="">https://github.com/JuliaComputing/Swagger.jl</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449338/">https://habr.com/ru/post/449338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449324/index.html">Cargas, tel√©fonos inteligentes, compa√±√≠as gigantes: programa Piter Heisenbug 2019</a></li>
<li><a href="../449326/index.html">WebRTC y video vigilancia: c√≥mo vencimos el retraso del video de las c√°maras</a></li>
<li><a href="../449330/index.html">M√≥dulos √≥pticos coherentes CFP2-ACO / CFP2-DCO WDM (100G / 200G) y su aplicaci√≥n en sistemas DWDM</a></li>
<li><a href="../449334/index.html">C√≥mo la traducci√≥n t√©cnica se convierte en mini detective</a></li>
<li><a href="../449336/index.html">VIH: tratamientos desde el primer medicamento hasta hoy</a></li>
<li><a href="../449340/index.html">Bloque or√°culo basado en or√°culo aleatorio basado en firma digital</a></li>
<li><a href="../449342/index.html">Or√°culo aleatorio basado en la firma digital blockchain</a></li>
<li><a href="../449344/index.html">Kodim - pizza</a></li>
<li><a href="../449346/index.html">MODX Digest # 4 (8 al 22 de abril de 2019)</a></li>
<li><a href="../449348/index.html">Buildroot - parte 2. Crear la configuraci√≥n de su placa; aplicaci√≥n de √°rbol externo, rootfs-overlay, scripts posteriores a la compilaci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>