<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   DIY clicker   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, un amigo me pidi贸 que ayudara con una tarea: controlar una computadora con un reproductor de audio instalado en una computadora port谩ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY clicker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422203/"><p>  Recientemente, un amigo me pidi贸 que ayudara con una tarea: controlar una computadora con un reproductor de audio instalado en una computadora port谩til con Windows usando un peque帽o control remoto de hardware.  Ped铆 todo tipo de controles remotos IR que no ofrecieran.  Y para hacer el AVR-e, del que le queda un n煤mero considerable, es necesario conectarlo lentamente. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Declaraci贸n del problema. </h2><br><p>  La tarea, obviamente, se divide en dos partes: </p><br><ul><li>  Hardware de microcontrolador, y </li><li>  Software que se ejecuta en una computadora y controla lo que contiene. </li></ul><br><p>  Dado que estamos trabajando con AVR, 驴por qu茅 no Arduino? </p><br><p>  Nosotros planteamos el problema. <br>  Plataforma de hardware: <br>  HW1.  La gesti贸n se realiza mediante botones sin fijaci贸n; <br>  HW2.  Servimos 3 botones (en general, a cu谩ntos no les importa); <br>  HW3.  Al presionar se considera que se mantiene presionado el bot贸n durante al menos 100 milisegundos; <br>  HW4.  Las prensas m谩s largas se ignoran.  No se procesa m谩s de 1 bot贸n a la vez; <br>  HW5.  Cuando se presiona un bot贸n, se inicia una determinada acci贸n en la computadora; <br>  HW6.  Proporcione una interfaz de comunicaci贸n con una computadora a trav茅s del convertidor serial / USB incorporado; <br>  Plataforma de software: <br>  SW1.  Proporcionar una interfaz de comunicaci贸n con una computadora a trav茅s de un puerto serie seleccionable; <br>  SW2.  Convierta los comandos que llegan a trav茅s de la interfaz de comunicaci贸n a los eventos del sistema operativo entregados al reproductor de audio deseado. <br>  SW3.  Pausa el procesamiento del comando.  Incluyendo un comando desde el control remoto. </p><br><p>  Bueno, hay un requisito adicional: si esto no introduce una inversi贸n de tiempo seria, haga que las soluciones sean lo m谩s universales posible. </p><br><h2 id="proektirovanie-i-reshenie">  Dise帽o y soluci贸n </h2><br><h3 id="hw1">  Hw1 </h3><br><p>  Los botones del bot贸n permanecen en la posici贸n "presionada" por un corto tiempo.  Adem谩s, los botones pueden sonar (es decir, generar muchos desencadenantes en un corto per铆odo de tiempo debido a un contacto inestable). <br>  No tiene sentido conectarlos a las interrupciones: se necesitan tiempos de respuesta incorrectos para molestarse con esto.  Leeremos su estado de pines digitales.  Para garantizar una lectura estable del bot贸n en el estado no comprimido, es necesario conectar el pin de entrada a tierra (pull-down) o al poder (pull-up) a trav茅s de una resistencia pull-up.  Usando la resistencia pull-up incorporada, no crearemos un elemento discreto adicional en el circuito.  Por un lado, conectamos el bot贸n a nuestra entrada, el otro, al suelo.  Aqu铆 est谩 el resultado: <br><img src="https://habrastorage.org/webt/7p/_o/so/7p_osowau3spzfyc9oob6bi4gku.png" alt="Diagrama de conexi贸n de botones"><br>  Y as铆, para cada bot贸n. </p><br><h3 id="hw2">  Hw2 </h3><br><p> Hay varios botones, por lo que necesitamos una cierta cantidad de registros uniformes sobre c贸mo sondear los botones y qu茅 hacer si se presiona.  Miramos hacia la encapsulaci贸n y hacemos la clase <code>Button</code> del <code>Button</code> , que contiene el n煤mero del pin desde el que se realiza la encuesta (y la inicializa), y el comando que debe enviarse al puerto.  Nos ocuparemos de c贸mo es el equipo m谩s adelante. </p><br><p>  La clase de bot贸n se ver谩 as铆: </p><br><div class="spoiler">  <b class="spoiler_title">C贸digo de clase de bot贸n</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Button(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pin, ::Command command) : pin(pin), command(command) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(pin, INPUT); digitalWrite(pin, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !digitalRead(pin); } ::<span class="hljs-function"><span class="hljs-function">Command </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> command; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pin; ::Command command; };</code> </pre> </div></div><br><p>  Despu茅s de este paso, nuestros botones se han vuelto universales y sin rostro, pero puede trabajar con ellos de la misma manera. </p><br><p>  Junte los botones y as铆gneles los pines: </p><br><pre> <code class="cpp hljs">Button buttons[] = { Button(A0, Command::Previous), Button(A1, Command::PauseResume), Button(A2, Command::Next), };</code> </pre> <br><p>  La inicializaci贸n de todos los botones se realiza llamando al m茅todo <code>Begin()</code> para cada bot贸n: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;button : buttons) { button.Begin(); }</code> </pre> <br><p>  Para determinar qu茅 bot贸n se presiona, iteraremos sobre los botones y verificaremos si se presiona algo.  Retornamos el 铆ndice del bot贸n, o uno de los valores especiales: "no se presiona nada" y "se presiona m谩s de un bot贸n".  Los valores especiales, por supuesto, no pueden superponerse con n煤meros de bot贸n v谩lidos. </p><br><div class="spoiler">  <b class="spoiler_title">GetPressed ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = PressedNothing; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ButtonsCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons[i].IsPressed()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == PressedNothing) { index = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PressedMultiple; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index; }</code> </pre> </div></div><br><h3 id="hw3">  Hw3 </h3><br><p>  Los botones se sondear谩n con un cierto per铆odo (por ejemplo, 10 ms), y asumiremos que la presi贸n se produjo si se mantuvo el mismo bot贸n (y exactamente uno) durante un n煤mero determinado de ciclos de sondeo.  Divida el tiempo de fijaci贸n (100 ms) por el per铆odo de sondeo (10 ms), obtenemos 10. <br>  Comenzaremos un contador de decremento, en el que escribiremos 10 en la primera fijaci贸n de prensado, y decremento en cada per铆odo.  Tan pronto como pasa de 1 a 0, comenzamos a procesar (ver HW5) </p><br><h3 id="hw4">  Hw4 </h3><br><p>  Si el contador ya es 0, no se toman medidas. </p><br><h3 id="hw5">  Hw5 </h3><br><p>  Como se mencion贸 anteriormente, un comando ejecutable est谩 asociado con cada bot贸n.  Debe transmitirse a trav茅s de la interfaz de comunicaci贸n. </p><br><p>  En esta etapa, puede implementar una estrategia de teclado. </p><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n del bucle principal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleButtons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentButton = PressedNothing; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte counter; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> button = GetPressed(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button == PressedMultiple || button == PressedNothing) { CurrentButton = button; counter = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button == CurrentButton) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--counter == <span class="hljs-number"><span class="hljs-number">0</span></span>) { InvokeCommand(buttons[button]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CurrentButton = button; counter = PressInterval / TickPeriod; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HandleButtons(); delay(TickPeriod); }</code> </pre> </div></div><br><h3 id="hw6">  Hw6 </h3><br><p>  La interfaz de comunicaci贸n debe ser clara tanto para el remitente como para el destinatario.  Dado que la interfaz en serie tiene una unidad de transferencia de datos de 1 byte y tiene sincronizaci贸n de bytes, tiene poco sentido cercar algo complicado y limitarnos a transmitir un byte por comando.  Para facilitar la depuraci贸n, transferiremos un car谩cter ASCII por comando. </p><br><h3 id="realizaciya-na-arduino">  Implementaci贸n Arduino </h3><br><p>  Ahora recogemos.  El c贸digo de implementaci贸n completo se muestra a continuaci贸n debajo del spoiler.  Para expandirlo, es suficiente especificar el c贸digo ASCII del nuevo comando y adjuntarle un bot贸n. <br>  Por supuesto, ser铆a posible indicar expl铆citamente un c贸digo de s铆mbolo para cada bot贸n, pero no haremos esto: el nombramiento de comandos nos ser谩 煤til al implementar un cliente para una PC. </p><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n completa</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TickPeriod = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ms const int PressInterval = 100; //ms enum class Command : char { None = 0, Previous = 'P', Next = 'N', PauseResume = 'C', SuspendResumeCommands = '/', }; class Button { public: Button(uint8_t pin, Command command) : pin(pin), command(command) {} void Begin() { pinMode(pin, INPUT); digitalWrite(pin, 1); } bool IsPressed() { return !digitalRead(pin); } Command GetCommand() const { return command; } private: uint8_t pin; Command command; }; Button buttons[] = { Button(A0, Command::Previous), Button(A1, Command::PauseResume), Button(A2, Command::Next), Button(12, Command::SuspendResumeCommands), }; const byte ButtonsCount = sizeof(buttons) / sizeof(buttons[0]); void setup() { for (auto &amp;button : buttons) { button.Begin(); } Serial.begin(9600); } enum { PressedNothing = -1, PressedMultiple = -2, }; int GetPressed() { int index = PressedNothing; for (byte i = 0; i &lt; ButtonsCount; ++i) { if (buttons[i].IsPressed()) { if (index == PressedNothing) { index = i; } else { return PressedMultiple; } } } return index; } void InvokeCommand(const class Button&amp; button) { Serial.write((char)button.GetCommand()); } void HandleButtons() { static int CurrentButton = PressedNothing; static byte counter; int button = GetPressed(); if (button == PressedMultiple || button == PressedNothing) { CurrentButton = button; counter = -1; return; } if (button == CurrentButton) { if (counter &gt; 0) { if (--counter == 0) { InvokeCommand(buttons[button]); return; } } } else { CurrentButton = button; counter = PressInterval / TickPeriod; } } void loop() { HandleButtons(); delay(TickPeriod); }</span></span></code> </pre> </div></div><br><p>  Y s铆, hice otro bot贸n para poder pausar la transferencia de comandos al cliente. </p><br><h3 id="klient-dlya-pk">  Cliente para PC </h3><br><p>  Pasamos a la segunda parte. <br>  Dado que no necesitamos una interfaz compleja y vinculante para Windows, podemos ir de diferentes maneras, como desee: WinAPI, MFC, Delphi, .NET (Windows Forms, WPF, etc.) o consolas en las mismas plataformas ( bueno, excepto para MFC). </p><br><h3 id="sw1">  SW1 </h3><br><p>  Este requisito se cierra mediante la comunicaci贸n con el puerto serie en la plataforma de software seleccionada: conectarse al puerto, leer bytes, procesar bytes. </p><br><h3 id="sw2">  SW2 </h3><br><p>  Quiz谩s todos vieron teclados con teclas multimedia.  Cada tecla del teclado, incluida la multimedia, tiene su propio c贸digo.  La soluci贸n m谩s simple a nuestro problema es simular las pulsaciones de teclas multimedia en el teclado.  Los c贸digos clave se pueden encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente original: MSDN</a> .  Queda por aprender c贸mo enviarlos al sistema.  Esto tampoco es dif铆cil: hay una funci贸n SendInput en WinAPI. <br>  Cada pulsaci贸n de tecla es dos eventos: presionar y soltar. <br>  Si usamos C / C ++, simplemente podemos incluir los archivos de encabezado.  En otros idiomas, el reenv铆o de llamadas debe hacerse.  Entonces, por ejemplo, cuando desarrolle en .NET deber谩 importar la funci贸n especificada y describir los argumentos.  Eleg铆 .NET por la conveniencia de desarrollar una interfaz. <br>  Seleccion茅 del proyecto solo la parte sustantiva, que se reduce a una clase: <code>Internals</code> . <br>  Aqu铆 est谩 su c贸digo: </p><br><div class="spoiler">  <b class="spoiler_title">C贸digo interno de clase</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Internals</span></span> { [StructLayout(LayoutKind.Sequential)] [DebuggerDisplay(<span class="hljs-string"><span class="hljs-string">"{Type} {Data}"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> INPUT { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Type; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KEYBDINPUT Data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Keyboard = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size = Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(INPUT)); } [StructLayout(LayoutKind.Sequential)] [DebuggerDisplay(<span class="hljs-string"><span class="hljs-string">"Vk={Vk} Scan={Scan} Flags={Flags} Time={Time} ExtraInfo={ExtraInfo}"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> KEYBDINPUT { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> Vk; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> Scan; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Time; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr ExtraInfo; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> spare; } [DllImport(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span>, SetLastError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberOfInputs, INPUT[] inputs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeOfInputStructure</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> INPUT[] inputs = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> INPUT { Type = INPUT.Keyboard, Data = { Flags = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// Push } }, new INPUT { Type = INPUT.Keyboard, Data = { Flags = 2 // Release } } }; public static void SendKey(Keys key) { inputs[0].Data.Vk = (ushort) key; inputs[1].Data.Vk = (ushort) key; SendInput(2, inputs, INPUT.Size); } }</span></span></code> </pre> </div></div><br><p>  Primero, describe las estructuras de datos (solo lo que est谩 relacionado con la entrada del teclado se corta, ya que lo simulamos), y la importaci贸n <code>SendInput</code> . <br>  El campo de <code>inputs</code> es una matriz de dos elementos que se utilizar谩n para generar eventos de teclado.  No tiene sentido asignarlo din谩micamente si la arquitectura de la aplicaci贸n supone que <code>SendKey</code> no se <code>SendKey</code> en varios subprocesos. <br>  En realidad, el asunto t茅cnico es a煤n m谩s: completamos los campos de estructura correspondientes con el c贸digo de clave virtual y lo enviamos a la cola de entrada del sistema operativo. </p><br><h3 id="sw3">  SW3 </h3><br><p>  El requisito se cierra de manera muy simple.  Se levanta la bandera y se procesa otro comando de una manera especial: la bandera cambia al estado l贸gico opuesto.  Si est谩 configurado, el resto de los comandos se ignoran. </p><br><h2 id="vmesto-zaklyucheniya">  En lugar de una conclusi贸n </h2><br><p>  La mejora se puede hacer sin fin, pero esa es otra historia.  No presento aqu铆 un proyecto de cliente de Windows, porque proporciona un amplio vuelo de imaginaci贸n. <br>  Para controlar el reproductor multimedia, le enviamos un conjunto de "pulsaciones de teclas", si necesita administrar presentaciones, otro.  Puede crear m贸dulos de control, ensamblarlos est谩ticamente o como complementos.  En general, muchas cosas son posibles.  Lo principal es el deseo. </p><br><p>  Gracias por su atencion </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422203/">https://habr.com/ru/post/es422203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422191/index.html">C贸mo cre茅 una aplicaci贸n de reconocimiento de texto Android rentable</a></li>
<li><a href="../es422195/index.html">El uso de ACS en miner铆a</a></li>
<li><a href="../es422197/index.html">Decimos una palabra sobre el relevo</a></li>
<li><a href="../es422199/index.html">Semana de la seguridad 33: 驴por qui茅n oscila el monitor?</a></li>
<li><a href="../es422201/index.html">China, d茅jame descartar?</a></li>
<li><a href="../es422205/index.html">Richard Hamming: Cap铆tulo 13. Teor铆a de la informaci贸n</a></li>
<li><a href="../es422207/index.html">Monstruos despu茅s de las vacaciones: AMD Threadripper 2990WX 32-Core y 2950X 16-Core (parte 4)</a></li>
<li><a href="../es422209/index.html">Monstruos despu茅s de las vacaciones: AMD Threadripper 2990WX 32-Core y 2950X 16-Core (parte 5)</a></li>
<li><a href="../es422211/index.html">Hermosa estructura de componentes en la nube de Microsoft Azure</a></li>
<li><a href="../es422213/index.html">Un d铆a sin JavaScript: 驴qu茅 podr铆a salir mal?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>