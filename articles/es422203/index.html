<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐽 🏑 💅🏻 DIY clicker 🕋 💪🏿 💩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, un amigo me pidió que ayudara con una tarea: controlar una computadora con un reproductor de audio instalado en una computadora portáti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY clicker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422203/"><p>  Recientemente, un amigo me pidió que ayudara con una tarea: controlar una computadora con un reproductor de audio instalado en una computadora portátil con Windows usando un pequeño control remoto de hardware.  Pedí todo tipo de controles remotos IR que no ofrecieran.  Y para hacer el AVR-e, del que le queda un número considerable, es necesario conectarlo lentamente. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Declaración del problema. </h2><br><p>  La tarea, obviamente, se divide en dos partes: </p><br><ul><li>  Hardware de microcontrolador, y </li><li>  Software que se ejecuta en una computadora y controla lo que contiene. </li></ul><br><p>  Dado que estamos trabajando con AVR, ¿por qué no Arduino? </p><br><p>  Nosotros planteamos el problema. <br>  Plataforma de hardware: <br>  HW1.  La gestión se realiza mediante botones sin fijación; <br>  HW2.  Servimos 3 botones (en general, a cuántos no les importa); <br>  HW3.  Al presionar se considera que se mantiene presionado el botón durante al menos 100 milisegundos; <br>  HW4.  Las prensas más largas se ignoran.  No se procesa más de 1 botón a la vez; <br>  HW5.  Cuando se presiona un botón, se inicia una determinada acción en la computadora; <br>  HW6.  Proporcione una interfaz de comunicación con una computadora a través del convertidor serial / USB incorporado; <br>  Plataforma de software: <br>  SW1.  Proporcionar una interfaz de comunicación con una computadora a través de un puerto serie seleccionable; <br>  SW2.  Convierta los comandos que llegan a través de la interfaz de comunicación a los eventos del sistema operativo entregados al reproductor de audio deseado. <br>  SW3.  Pausa el procesamiento del comando.  Incluyendo un comando desde el control remoto. </p><br><p>  Bueno, hay un requisito adicional: si esto no introduce una inversión de tiempo seria, haga que las soluciones sean lo más universales posible. </p><br><h2 id="proektirovanie-i-reshenie">  Diseño y solución </h2><br><h3 id="hw1">  Hw1 </h3><br><p>  Los botones del botón permanecen en la posición "presionada" por un corto tiempo.  Además, los botones pueden sonar (es decir, generar muchos desencadenantes en un corto período de tiempo debido a un contacto inestable). <br>  No tiene sentido conectarlos a las interrupciones: se necesitan tiempos de respuesta incorrectos para molestarse con esto.  Leeremos su estado de pines digitales.  Para garantizar una lectura estable del botón en el estado no comprimido, es necesario conectar el pin de entrada a tierra (pull-down) o al poder (pull-up) a través de una resistencia pull-up.  Usando la resistencia pull-up incorporada, no crearemos un elemento discreto adicional en el circuito.  Por un lado, conectamos el botón a nuestra entrada, el otro, al suelo.  Aquí está el resultado: <br><img src="https://habrastorage.org/webt/7p/_o/so/7p_osowau3spzfyc9oob6bi4gku.png" alt="Diagrama de conexión de botones"><br>  Y así, para cada botón. </p><br><h3 id="hw2">  Hw2 </h3><br><p> Hay varios botones, por lo que necesitamos una cierta cantidad de registros uniformes sobre cómo sondear los botones y qué hacer si se presiona.  Miramos hacia la encapsulación y hacemos la clase <code>Button</code> del <code>Button</code> , que contiene el número del pin desde el que se realiza la encuesta (y la inicializa), y el comando que debe enviarse al puerto.  Nos ocuparemos de cómo es el equipo más adelante. </p><br><p>  La clase de botón se verá así: </p><br><div class="spoiler">  <b class="spoiler_title">Código de clase de botón</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Button(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pin, ::Command command) : pin(pin), command(command) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(pin, INPUT); digitalWrite(pin, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !digitalRead(pin); } ::<span class="hljs-function"><span class="hljs-function">Command </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> command; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pin; ::Command command; };</code> </pre> </div></div><br><p>  Después de este paso, nuestros botones se han vuelto universales y sin rostro, pero puede trabajar con ellos de la misma manera. </p><br><p>  Junte los botones y asígneles los pines: </p><br><pre> <code class="cpp hljs">Button buttons[] = { Button(A0, Command::Previous), Button(A1, Command::PauseResume), Button(A2, Command::Next), };</code> </pre> <br><p>  La inicialización de todos los botones se realiza llamando al método <code>Begin()</code> para cada botón: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;button : buttons) { button.Begin(); }</code> </pre> <br><p>  Para determinar qué botón se presiona, iteraremos sobre los botones y verificaremos si se presiona algo.  Retornamos el índice del botón, o uno de los valores especiales: "no se presiona nada" y "se presiona más de un botón".  Los valores especiales, por supuesto, no pueden superponerse con números de botón válidos. </p><br><div class="spoiler">  <b class="spoiler_title">GetPressed ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = PressedNothing; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ButtonsCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons[i].IsPressed()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == PressedNothing) { index = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PressedMultiple; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index; }</code> </pre> </div></div><br><h3 id="hw3">  Hw3 </h3><br><p>  Los botones se sondearán con un cierto período (por ejemplo, 10 ms), y asumiremos que la presión se produjo si se mantuvo el mismo botón (y exactamente uno) durante un número determinado de ciclos de sondeo.  Divida el tiempo de fijación (100 ms) por el período de sondeo (10 ms), obtenemos 10. <br>  Comenzaremos un contador de decremento, en el que escribiremos 10 en la primera fijación de prensado, y decremento en cada período.  Tan pronto como pasa de 1 a 0, comenzamos a procesar (ver HW5) </p><br><h3 id="hw4">  Hw4 </h3><br><p>  Si el contador ya es 0, no se toman medidas. </p><br><h3 id="hw5">  Hw5 </h3><br><p>  Como se mencionó anteriormente, un comando ejecutable está asociado con cada botón.  Debe transmitirse a través de la interfaz de comunicación. </p><br><p>  En esta etapa, puede implementar una estrategia de teclado. </p><br><div class="spoiler">  <b class="spoiler_title">Implementación del bucle principal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleButtons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentButton = PressedNothing; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte counter; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> button = GetPressed(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button == PressedMultiple || button == PressedNothing) { CurrentButton = button; counter = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button == CurrentButton) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--counter == <span class="hljs-number"><span class="hljs-number">0</span></span>) { InvokeCommand(buttons[button]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CurrentButton = button; counter = PressInterval / TickPeriod; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HandleButtons(); delay(TickPeriod); }</code> </pre> </div></div><br><h3 id="hw6">  Hw6 </h3><br><p>  La interfaz de comunicación debe ser clara tanto para el remitente como para el destinatario.  Dado que la interfaz en serie tiene una unidad de transferencia de datos de 1 byte y tiene sincronización de bytes, tiene poco sentido cercar algo complicado y limitarnos a transmitir un byte por comando.  Para facilitar la depuración, transferiremos un carácter ASCII por comando. </p><br><h3 id="realizaciya-na-arduino">  Implementación Arduino </h3><br><p>  Ahora recogemos.  El código de implementación completo se muestra a continuación debajo del spoiler.  Para expandirlo, es suficiente especificar el código ASCII del nuevo comando y adjuntarle un botón. <br>  Por supuesto, sería posible indicar explícitamente un código de símbolo para cada botón, pero no haremos esto: el nombramiento de comandos nos será útil al implementar un cliente para una PC. </p><br><div class="spoiler">  <b class="spoiler_title">Implementación completa</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TickPeriod = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ms const int PressInterval = 100; //ms enum class Command : char { None = 0, Previous = 'P', Next = 'N', PauseResume = 'C', SuspendResumeCommands = '/', }; class Button { public: Button(uint8_t pin, Command command) : pin(pin), command(command) {} void Begin() { pinMode(pin, INPUT); digitalWrite(pin, 1); } bool IsPressed() { return !digitalRead(pin); } Command GetCommand() const { return command; } private: uint8_t pin; Command command; }; Button buttons[] = { Button(A0, Command::Previous), Button(A1, Command::PauseResume), Button(A2, Command::Next), Button(12, Command::SuspendResumeCommands), }; const byte ButtonsCount = sizeof(buttons) / sizeof(buttons[0]); void setup() { for (auto &amp;button : buttons) { button.Begin(); } Serial.begin(9600); } enum { PressedNothing = -1, PressedMultiple = -2, }; int GetPressed() { int index = PressedNothing; for (byte i = 0; i &lt; ButtonsCount; ++i) { if (buttons[i].IsPressed()) { if (index == PressedNothing) { index = i; } else { return PressedMultiple; } } } return index; } void InvokeCommand(const class Button&amp; button) { Serial.write((char)button.GetCommand()); } void HandleButtons() { static int CurrentButton = PressedNothing; static byte counter; int button = GetPressed(); if (button == PressedMultiple || button == PressedNothing) { CurrentButton = button; counter = -1; return; } if (button == CurrentButton) { if (counter &gt; 0) { if (--counter == 0) { InvokeCommand(buttons[button]); return; } } } else { CurrentButton = button; counter = PressInterval / TickPeriod; } } void loop() { HandleButtons(); delay(TickPeriod); }</span></span></code> </pre> </div></div><br><p>  Y sí, hice otro botón para poder pausar la transferencia de comandos al cliente. </p><br><h3 id="klient-dlya-pk">  Cliente para PC </h3><br><p>  Pasamos a la segunda parte. <br>  Dado que no necesitamos una interfaz compleja y vinculante para Windows, podemos ir de diferentes maneras, como desee: WinAPI, MFC, Delphi, .NET (Windows Forms, WPF, etc.) o consolas en las mismas plataformas ( bueno, excepto para MFC). </p><br><h3 id="sw1">  SW1 </h3><br><p>  Este requisito se cierra mediante la comunicación con el puerto serie en la plataforma de software seleccionada: conectarse al puerto, leer bytes, procesar bytes. </p><br><h3 id="sw2">  SW2 </h3><br><p>  Quizás todos vieron teclados con teclas multimedia.  Cada tecla del teclado, incluida la multimedia, tiene su propio código.  La solución más simple a nuestro problema es simular las pulsaciones de teclas multimedia en el teclado.  Los códigos clave se pueden encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente original: MSDN</a> .  Queda por aprender cómo enviarlos al sistema.  Esto tampoco es difícil: hay una función SendInput en WinAPI. <br>  Cada pulsación de tecla es dos eventos: presionar y soltar. <br>  Si usamos C / C ++, simplemente podemos incluir los archivos de encabezado.  En otros idiomas, el reenvío de llamadas debe hacerse.  Entonces, por ejemplo, cuando desarrolle en .NET deberá importar la función especificada y describir los argumentos.  Elegí .NET por la conveniencia de desarrollar una interfaz. <br>  Seleccioné del proyecto solo la parte sustantiva, que se reduce a una clase: <code>Internals</code> . <br>  Aquí está su código: </p><br><div class="spoiler">  <b class="spoiler_title">Código interno de clase</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Internals</span></span> { [StructLayout(LayoutKind.Sequential)] [DebuggerDisplay(<span class="hljs-string"><span class="hljs-string">"{Type} {Data}"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> INPUT { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Type; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KEYBDINPUT Data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Keyboard = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size = Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(INPUT)); } [StructLayout(LayoutKind.Sequential)] [DebuggerDisplay(<span class="hljs-string"><span class="hljs-string">"Vk={Vk} Scan={Scan} Flags={Flags} Time={Time} ExtraInfo={ExtraInfo}"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> KEYBDINPUT { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> Vk; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> Scan; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Time; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr ExtraInfo; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> spare; } [DllImport(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span>, SetLastError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberOfInputs, INPUT[] inputs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeOfInputStructure</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> INPUT[] inputs = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> INPUT { Type = INPUT.Keyboard, Data = { Flags = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// Push } }, new INPUT { Type = INPUT.Keyboard, Data = { Flags = 2 // Release } } }; public static void SendKey(Keys key) { inputs[0].Data.Vk = (ushort) key; inputs[1].Data.Vk = (ushort) key; SendInput(2, inputs, INPUT.Size); } }</span></span></code> </pre> </div></div><br><p>  Primero, describe las estructuras de datos (solo lo que está relacionado con la entrada del teclado se corta, ya que lo simulamos), y la importación <code>SendInput</code> . <br>  El campo de <code>inputs</code> es una matriz de dos elementos que se utilizarán para generar eventos de teclado.  No tiene sentido asignarlo dinámicamente si la arquitectura de la aplicación supone que <code>SendKey</code> no se <code>SendKey</code> en varios subprocesos. <br>  En realidad, el asunto técnico es aún más: completamos los campos de estructura correspondientes con el código de clave virtual y lo enviamos a la cola de entrada del sistema operativo. </p><br><h3 id="sw3">  SW3 </h3><br><p>  El requisito se cierra de manera muy simple.  Se levanta la bandera y se procesa otro comando de una manera especial: la bandera cambia al estado lógico opuesto.  Si está configurado, el resto de los comandos se ignoran. </p><br><h2 id="vmesto-zaklyucheniya">  En lugar de una conclusión </h2><br><p>  La mejora se puede hacer sin fin, pero esa es otra historia.  No presento aquí un proyecto de cliente de Windows, porque proporciona un amplio vuelo de imaginación. <br>  Para controlar el reproductor multimedia, le enviamos un conjunto de "pulsaciones de teclas", si necesita administrar presentaciones, otro.  Puede crear módulos de control, ensamblarlos estáticamente o como complementos.  En general, muchas cosas son posibles.  Lo principal es el deseo. </p><br><p>  Gracias por su atencion </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422203/">https://habr.com/ru/post/es422203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422191/index.html">Cómo creé una aplicación de reconocimiento de texto Android rentable</a></li>
<li><a href="../es422195/index.html">El uso de ACS en minería</a></li>
<li><a href="../es422197/index.html">Decimos una palabra sobre el relevo</a></li>
<li><a href="../es422199/index.html">Semana de la seguridad 33: ¿por quién oscila el monitor?</a></li>
<li><a href="../es422201/index.html">China, déjame descartar?</a></li>
<li><a href="../es422205/index.html">Richard Hamming: Capítulo 13. Teoría de la información</a></li>
<li><a href="../es422207/index.html">Monstruos después de las vacaciones: AMD Threadripper 2990WX 32-Core y 2950X 16-Core (parte 4)</a></li>
<li><a href="../es422209/index.html">Monstruos después de las vacaciones: AMD Threadripper 2990WX 32-Core y 2950X 16-Core (parte 5)</a></li>
<li><a href="../es422211/index.html">Hermosa estructura de componentes en la nube de Microsoft Azure</a></li>
<li><a href="../es422213/index.html">Un día sin JavaScript: ¿qué podría salir mal?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>