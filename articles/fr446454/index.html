<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😎 👩🏿‍🤝‍👨🏾 🧘🏾 Développement de serveur Web Golang - De facile à complexe 📓 🎃 🏬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a cinq ans, j'ai commencé à développer Gophish , qui a permis d'apprendre le Golang. J'ai réalisé que Go est un langage puissant, dont les capaci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Développement de serveur Web Golang - De facile à complexe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/446454/"><img src="https://habrastorage.org/getpro/habr/post_images/da7/244/1d8/da72441d8fc6c0c8b5a7e735b4d0b506.png"><br><br>  Il y a cinq ans, j'ai commencé à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développer Gophish</a> , qui a permis d'apprendre le Golang.  J'ai réalisé que Go est un langage puissant, dont les capacités sont complétées par de nombreuses bibliothèques.  Go est universel: en particulier, avec son aide, il est possible de développer des applications serveur sans problème. <br><br>  Cet article concerne l'écriture d'un serveur dans Go.  Commençons par des choses simples, comme «Hello world!», Et terminons par une application avec les fonctionnalités suivantes: <br><br>  - Utilisation de Let's Encrypt pour HTTPS. <br>  - Fonctionne comme un routeur API. <br>  - Travailler avec un middleware. <br>  - Traitement des fichiers statiques. <br>  - Arrêt correct. <br><a name="habracut"></a><br><blockquote>  <b>Skillbox recommande:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le cours pratique de Python Developer from scratch</a> . <br><br>  <b>Nous vous rappelons:</b> <i>pour tous les lecteurs de «Habr» - une remise de 10 000 roubles lors de l'inscription à un cours Skillbox en utilisant le code promo «Habr».</i> <br></blockquote><h3>  Bonjour tout le monde! </h3><br>  La création d'un serveur Web sur Go est très rapide.  Voici un exemple d'utilisation d'un gestionnaire qui renvoie le "Bonjour, monde!" Promis ci-dessus. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":80"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  Après cela, si vous démarrez l'application et ouvrez la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">localhost</a> , vous verrez immédiatement le texte "Bonjour, monde!"  (bien sûr, si tout fonctionne correctement). <br><br>  Ensuite, nous utiliserons à plusieurs reprises le gestionnaire, mais d'abord, comprenons comment tout fonctionne. <br><br><h4>  net / http </h4><br>  L'exemple utilise le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://golang.org/pkg/net/"><code>net/http</code></a> , qui est l'outil principal de Go pour développer à la fois des serveurs et des clients HTTP.  Afin de comprendre le code, examinons la signification de trois éléments importants: http.Handler, http.ServeMux et http.Server. <br><br><h4>  Gestionnaires HTTP </h4><br>  Lorsque nous recevons une demande, le gestionnaire l'analyse et forme une réponse.  Les gestionnaires Go sont implémentés comme suit: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ServeHTTP(ResponseWriter, *Request) }</code> </pre> <br>  Le premier exemple utilise la fonction d'assistance http.HandleFunc.  Il encapsule une autre fonction, qui à son tour accepte http.ResponseWriter et http.Request dans ServeHTTP. <br><br>  En d'autres termes, les gestionnaires Golang sont représentés par une interface unique, qui offre de nombreuses opportunités au programmeur.  Ainsi, par exemple, le middleware est implémenté à l'aide d'un gestionnaire, où ServeHTTP fait d'abord quelque chose, puis appelle la méthode ServeHTTP d'un autre gestionnaire. <br><br>  Comme mentionné ci-dessus, les gestionnaires génèrent simplement des réponses aux demandes.  Mais quel gestionnaire particulier doit être utilisé à un moment donné? <br><br><h4>  Acheminement des demandes </h4><br>  Pour faire le bon choix, utilisez le multiplexeur HTTP.  On l'appelle muxer ou routeur dans un certain nombre de bibliothèques, mais c'est tout de même.  La fonction du multiplexeur consiste à analyser le chemin de demande et à sélectionner le gestionnaire approprié. <br><br>  Si vous avez besoin de prise en charge pour un routage complexe, il est préférable d'utiliser des bibliothèques tierces.  L'une des plus avancées est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gorilla / mux</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-chi / chi</a> , ces bibliothèques permettent d'implémenter sans problème des traitements intermédiaires.  Avec leur aide, vous pouvez configurer le routage générique et effectuer un certain nombre d'autres tâches.  Leur plus est la compatibilité avec les gestionnaires HTTP standard.  En conséquence, vous pouvez écrire du code simple avec la possibilité de sa modification à l'avenir. <br><br>  Travailler avec des cadres complexes dans une situation normale nécessitera des solutions pas tout à fait standard, ce qui complique grandement l'utilisation de gestionnaires par défaut.  Pour créer la grande majorité des applications, une combinaison de la bibliothèque par défaut et d'un simple routeur suffit. <br><br><h4>  Traitement des demandes </h4><br>  De plus, nous avons besoin d'un composant qui «écoutera» les connexions entrantes et redirigera toutes les demandes vers le gestionnaire approprié.  Cette tâche peut facilement être effectuée par http.Server. <br><br>  Ce qui suit montre que le serveur est responsable de toutes les tâches liées au traitement de la connexion.  Cela, par exemple, fonctionne sur le protocole TLS.  Pour implémenter l'appel http.ListenAndServer, un serveur HTTP standard est utilisé. <br><br>  Voyons maintenant des exemples plus complexes. <br><br><h3>  Ajout de Let's Encrypt </h3><br>  Par défaut, notre application s'exécute sur le protocole HTTP, mais il est recommandé d'utiliser le protocole HTTPS.  Dans Go, cela peut se faire sans problème.  Si vous avez reçu un certificat et une clé privée, enregistrez simplement ListenAndServeTLS avec le certificat et les fichiers de clés appropriés. <br><br><pre> <code class="go hljs">http.ListenAndServeTLS(<span class="hljs-string"><span class="hljs-string">":443"</span></span>, <span class="hljs-string"><span class="hljs-string">"cert.pem"</span></span>, <span class="hljs-string"><span class="hljs-string">"key.pem"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  On peut toujours faire mieux. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Let's Encrypt</a> donne des certificats gratuits avec la possibilité de se renouveler automatiquement.  Pour utiliser le service, vous avez besoin du package <code>autocert</code> . <br><br>  Le moyen le plus simple de le configurer consiste à utiliser la méthode autocert.NewListener en combinaison avec http.Serve.  La méthode vous permet de recevoir et de renouveler des certificats TLS, tandis que le serveur HTTP traite les demandes: <br><br><pre> <code class="go hljs">http.Serve(autocert.NewListener(<span class="hljs-string"><span class="hljs-string">"example.com"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Si nous ouvrons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">example.com</a> dans le navigateur, nous obtenons la réponse HTTPS "Bonjour tout le monde!". <br><br>  Si vous avez besoin d'une configuration plus approfondie, vous devez utiliser le gestionnaire autocert.Manager.  Ensuite, nous créons notre propre instance http.Server (jusqu'à présent, nous l'avons utilisé par défaut) et ajoutons le gestionnaire au serveur TLSConfig: <br><br><pre> <code class="go hljs">m := &amp;autocert.Manager{ Cache: autocert.DirCache(<span class="hljs-string"><span class="hljs-string">"golang-autocert"</span></span>), Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(<span class="hljs-string"><span class="hljs-string">"example.org"</span></span>, <span class="hljs-string"><span class="hljs-string">"www.example.org"</span></span>), } server := &amp;http.Server{ Addr: <span class="hljs-string"><span class="hljs-string">":443"</span></span>, TLSConfig: m.TLSConfig(), } server.ListenAndServeTLS(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre> <br>  Il s'agit d'un moyen simple d'implémenter une prise en charge HTTPS complète avec renouvellement automatique des certificats. <br><br><h3>  Ajout d'itinéraires personnalisés </h3><br>  Le routeur par défaut inclus dans la bibliothèque standard est bon, mais il est très simple.  La plupart des applications nécessitent un routage plus complexe, notamment des itinéraires imbriqués et génériques, ou la procédure de définition des modèles et des paramètres de chemin. <br><br>  Dans ce cas, vous devez utiliser les packages <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener noreferrer">gorilla / mux</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener noreferrer">go-chi / chi</a> .  Nous allons apprendre à travailler avec ce dernier - un exemple est illustré ci-dessous. <br><br>  Étant donné le fichier api / v1 / api.go contenant les routes pour notre API: <br><br><pre> <code class="go hljs">/ HelloResponse is the JSON representation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a customized message <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HelloResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"message"`</span></span> } <span class="hljs-comment"><span class="hljs-comment">// HelloName returns a personalized JSON message func HelloName(w http.ResponseWriter, r *http.Request) { name := chi.URLParam(r, "name") response := HelloResponse{ Message: fmt.Sprintf("Hello %s!", name), } jsonResponse(w, response, http.StatusOK) } // NewRouter returns an HTTP handler that implements the routes for the API func NewRouter() http.Handler { r := chi.NewRouter() r.Get("/{name}", HelloName) return r }</span></span></code> </pre> <br>  Nous définissons le préfixe api / vq pour les itinéraires dans le fichier principal. <br><br>  Nous pouvons ensuite le monter sur notre routeur principal sous le préfixe api / v1 / dans notre application principale: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// NewRouter returns a new HTTP handler that implements the main server routes func NewRouter() http.Handler { router := chi.NewRouter() router.Mount("/api/v1/", v1.NewRouter()) return router } http.Serve(autocert.NewListener("example.com"), NewRouter())</span></span></code> </pre> <br>  La simplicité de travailler avec des routes complexes dans Go permet de simplifier la structuration en servant de grandes applications complexes. <br><br><h3>  Travailler avec un middleware </h3><br>  Dans le cas d'un traitement intermédiaire, l'encapsulation d'un gestionnaire HTTP avec un autre est utilisée, ce qui permet d'authentifier rapidement, de compresser, de journaliser et d'autres fonctions. <br><br>  À titre d'exemple, considérons l'interface http.Handler, avec son aide, nous écrivons un gestionnaire avec authentification des utilisateurs du service. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequireAuthentication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isAuthenticated(r) { http.Redirect(w, r, <span class="hljs-string"><span class="hljs-string">"/login"</span></span>, http.StatusTemporaryRedirect) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Assuming authentication passed, run the original handler next.ServeHTTP(w, r) }) }</span></span></code> </pre> <br>  Il existe des routeurs tiers, par exemple chi, qui vous permettent d'étendre les fonctionnalités du traitement intermédiaire. <br><br><h3>  Travailler avec des fichiers statiques </h3><br>  La bibliothèque standard Go comprend des fonctionnalités pour travailler avec du contenu statique, y compris des images, ainsi que des fichiers JavaScript et CSS.  Ils sont accessibles via la fonction http.FileServer.  Il renvoie un gestionnaire qui distribue des fichiers à partir d'un répertoire spécifique. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { router := chi.NewRouter() r.Get(<span class="hljs-string"><span class="hljs-string">"/{name}"</span></span>, HelloName) <span class="hljs-comment"><span class="hljs-comment">//     staticPath, _ := filepath.Abs("../../static/") fs := http.FileServer(http.Dir(staticPath)) router.Handle("/*", fs) return r</span></span></code> </pre> <br>  Il convient de se rappeler que http.Dir affiche le contenu du répertoire s'il ne possède pas le fichier index.html principal.  Dans ce cas, pour éviter que le répertoire ne soit compromis, il vaut la peine d'utiliser le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>unindexed</code></a> . <br><br><h3>  Arrêt correct </h3><br>  Go a également une fonctionnalité telle que l'arrêt correct du serveur HTTP.  Cela peut être fait en utilisant la méthode Shutdown ().  Le serveur démarre en goroutine, puis le canal est écouté pour recevoir un signal d'interruption.  Dès que le signal est reçu, le serveur s'arrête, mais pas immédiatement, mais après quelques secondes. <br><br><pre> <code class="go hljs">handler := server.NewRouter() srv := &amp;http.Server{ Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { srv.Serve(autocert.NewListener(domains...)) }() <span class="hljs-comment"><span class="hljs-comment">// Wait for an interrupt c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) &lt;-c // Attempt a graceful shutdown ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() srv.Shutdown(ctx)</span></span></code> </pre> <br><h3>  En conclusion </h3><br>  Go est un langage puissant avec une bibliothèque standard presque universelle.  Ses capacités par défaut sont très étendues, et vous pouvez les renforcer à l'aide d'interfaces - cela vous permet de développer des serveurs HTTP vraiment fiables. <br><blockquote>  <b>Skillbox recommande:</b> <br><br><ul><li>  Cours pratique de deux ans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Je suis un développeur web PRO</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a> </li><li>  Cours pédagogique en ligne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Profession Java-développeur"</a> . </li><li>  Cours pratique annuel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Développeur PHP de 0 à PRO"</a> . <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446454/">https://habr.com/ru/post/fr446454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446440/index.html">Le livre React Fast. Applications Web dans React, JSX, Redux et GraphQL »</a></li>
<li><a href="../fr446444/index.html">De Skype à WebRTC: comment nous avons organisé la communication vidéo sur le Web</a></li>
<li><a href="../fr446446/index.html">Bases du moteur JavaScript: formulaires généraux et mise en cache en ligne. Partie 1</a></li>
<li><a href="../fr446448/index.html">5 règles de base pour mener des entretiens de problèmes pour identifier les besoins des consommateurs</a></li>
<li><a href="../fr446452/index.html">Mission lunaire "Bereshit" - le 4 avril 2019, la transition vers l'orbite lunaire a été achevée, 7 jours de vol à venir, 6 manœuvres et 1 atterrissage</a></li>
<li><a href="../fr446456/index.html">La substitution des importations dans la pratique. Partie 1. Options</a></li>
<li><a href="../fr446458/index.html">DRO universel basé sur Arduino Nano - shDRO. 2e partie</a></li>
<li><a href="../fr446460/index.html">Food Design Digest mars 2019</a></li>
<li><a href="../fr446462/index.html">Immersion dans le pilote: le principe général de la marche arrière à l'aide de l'exemple de la tâche NeoQUEST-2019</a></li>
<li><a href="../fr446464/index.html">15 perroquets: choisissez un fournisseur d'hébergement pour les serveurs VPS / VDS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>