<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏾 🎗️ 🤩 Membuat modul perangkat lunak untuk programmer XELTEK SuperPro 6100 🤦🏿 👞 🔜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kata Pengantar 
 Dalam artikel sebelumnya, mekanisme perlindungan programmer XELTEK SuperPro 6100 terhadap kloning dipertimbangkan. 

 Artikel ini aka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat modul perangkat lunak untuk programmer XELTEK SuperPro 6100</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430634/"><h4>  Kata Pengantar </h4><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya, mekanisme perlindungan programmer XELTEK SuperPro 6100 terhadap kloning dipertimbangkan. <br><br>  Artikel ini akan menjelaskan pembuatan modul perangkat lunaknya sendiri untuk pemrogram ini, yang, dengan modifikasi kode tertentu, dapat diadaptasi untuk bekerja dengan semua jenis sirkuit mikro lainnya - saat ini tidak didukung atau, seperti dalam kasus kami, hanya dinyatakan secara formal. <br><br><h4>  Latar belakang </h4><br>  Sekali lagi, kami memiliki tugas yang sekilas diselesaikan dengan cukup sederhana - perlu membuat salinan dari satu chip memori flash khusus - mDOC H3 SDED5-512M. <br><br>  Chip ini dikembangkan lebih dari sepuluh tahun yang lalu.  Inilah pdf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(1)</a> dengan uraiannya.  Di bawah ini adalah kutipan singkat dari pengumuman berbahasa Rusia: <br><br>  <i>... msystems telah menyiapkan keluarga mDOC untuk digunakan sebagai solid state drive ...</i> <i><br></i>  <i>Perangkat lunak TrueFFS bawaan, yang bertugas mengelola memori flash mDOC H3, menjalankan modul pengontrolnya sendiri, yang mengubahnya menjadi unit lengkap yang berdiri sendiri, mudah ditambahkan ke berbagai perangkat genggam ....</i> <br><a name="habracut"></a><br>  Dalam daftar SuperPro 6100 yang didukung oleh programmer, chip tersebut terdaftar dan untuk itu bahkan menemukan adaptor DX5057 yang sesuai.  Tetapi setelah merakit seluruh desainer dan memilih chip ini, program menunjukkan gambar berikut dengan item misterius "DimageMain", deskripsi yang tidak ditemukan baik dalam dokumentasi atau di situs web pengembang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/dy/hk/0ldyhknaorevv2x5mjq4cens0qw.jpeg"></div><br>  Setelah mencoba melakukan operasi "DimageMain" tanpa chip di adaptor, sebuah peringatan diterima tentang ketidakhadirannya, dan setelah mengkonfirmasi fakta ini, program menampilkan informasi berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/x4/hk/khx4hkhkb3uu2w5zbpguawdzhh4.jpeg"></div><br>  Dilihat oleh tulisan "mDOC H3 Write Image", "Image" adalah gambar yang dapat ditulis ke dalam chip menggunakan programmer ini.  Tetapi bagaimana cara membaca gambar ini dari microcircuit yang sudah direkam, bagaimana cara menghapusnya, dll? <br><br>  Beberapa saat kemudian di Internet saya menemukan file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(2)</a> dari perusahaan Dataman, yang secara parsial memperlihatkan struktur gambar di atas dan menyebutkan perangkat lunak untuk pembuatannya. <br>  Dengan demikian, upaya lebih lanjut ditujukan untuk mencari utilitas dari M-Systems yang dijelaskan dalam dokumen Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(3)</a> . <br><br>  Permintaan untuk dukungan teknis dari "M-Systems", yang sekarang "SanDisk", tidak memberikan hasil - tidak ada jawaban. <br><br>  Di Internet, adalah mungkin untuk menemukan hanya utilitas lama yang tidak mendukung versi chip H3.  SDK lengkap dari SanDisk juga tidak ditemukan, hanya "fragmen" -nya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(5)</a> dalam hal mengimplementasikan driver untuk Linux. <br><br>  Saat kami mempelajari informasi yang terakumulasi, baris berikut menarik perhatian file Dataman: "File gambar dapat dibuat dengan utilitas SanDisk Docshell atau PG4UW." <br><br>  Utilitas SanDisk Docshell tidak menemukan diri mereka dengan cara apa pun, jadi saya harus mencari tahu bagaimana PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(4)</a> bekerja dengan chip ini.  Mereka tidak menanamkan seluruh SanDisk SDK dalam perangkat lunak mereka, tetapi menciptakan plug-in dengan metode yang diekspor yang diperlukan agar utilitas TrueFFS berfungsi, yang kemudian dipanggil dari program mereka. <br>  Kami akan pergi dengan cara yang sama. <br><br><h4>  Membuat modul perangkat lunak Anda sendiri </h4><br>  Berikut ini adalah penafian tanggung jawab, yaitu bahwa penulis tidak memikul tanggung jawab apa pun atas penggunaan materi oleh Anda oleh artikel ini. <br>  Dengan kata lain - hanya Anda sendiri yang akan bertanggung jawab atas tindakan Anda, yang Anda dapat didorong untuk membiasakan diri dengan materi ini. <br><br>  <em>Kami setuju, seperti dalam artikel sebelumnya, untuk memanggil pemrogram programmer dari SuperPro 6100 hanya "perangkat lunak", dan komputer tempat program ini bekerja adalah "host".</em>  <em>Sekarang kami memiliki program lain yang berfungsi dalam programmer itu sendiri.</em>  <em>Kami akan menyebutnya "modul perangkat lunak".</em> <br><br>  Manual Perangkat Lunak untuk TrueFFS 7.1 manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(3)</a> menjelaskan fungsi yang diterapkan oleh utilitas DOCSHELL, yang termasuk dalam empat kategori berikut: <br><br><ul><li>  DFORMAT - utilitas untuk memformat perangkat mDOC. </li><li>  DINFO - utilitas untuk mendapatkan berbagai informasi tentang perangkat mDOC dan bagian yang ada di dalamnya. </li><li>  DIMAGE - utilitas untuk membaca, menulis, dan membandingkan perangkat mDOC gambar. </li><li>  SPLITIMAGE - utilitas untuk membagi gambar perangkat mDOC menjadi beberapa bagian. </li></ul><br>  Utilitas DOCSHELL dimaksudkan untuk baris perintah, oleh karena itu, antarmuka untuk berkomunikasi dengan plugin DOCSHELL.dll diimplementasikan menggunakan mekanisme perintah teks yang sama. <br>  Sebelum memulai komunikasi dengan "DOCSHELL.dll", perlu untuk memanggil masing-masing metode yang diekspor dan meneruskannya ke fungsi yang diimplementasikan dalam perangkat lunak untuk pertukaran fisik dengan chip mDOC.  Ini adalah menulis dan membaca (dalam beberapa modifikasi), serta metode untuk menerima pesan teks tentang kemajuan operasi saat ini dan metode untuk bekerja dengan file gambar. <br><br>  Salah satu metode mainEntry yang diekspor sebagai argumen input <br>  menerima string ASCIIZ - perintah yang dijelaskan dalam manual Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(3)</a> . <br><br>  Parser di dalam "DOCSHELL.dll" memproses perintah yang diterima dan, tergantung pada perintah dan argumennya, memanggil satu atau beberapa metode lain dari perangkat lunak pemrogram utama menggunakan pointer yang diterima selama inisialisasi awal. <br><br>  Perangkat lunak untuk programmer, kami memutuskan untuk menulis sendiri.  Pendekatan ini, di satu sisi, menyelamatkan kita dari "penggalian" dalam file asli untuk mematuhi perjanjian pertukaran informasi antara host dan programmer, dan di sisi lain, itu sangat memudahkan proses debugging, yang, jika modul diintegrasikan ke dalam perangkat lunak asli, membuatnya tidak mungkin dalam beberapa aspek atau sangat sulit. <br><br>  Antarmuka pengguna asli untuk programmer ditulis dalam C # di Visual Studio 2017. Sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(6)</a> disertakan. <br><br>  Tentu saja, fungsional ada di tempat pertama, jadi tidak ada pertanyaan tentang gertakan penampilan, serta teks dari kode sumber itu sendiri.  Oleh karena itu, "desain" minimalis program adalah sebagai berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/ki/8b/ozki8byinhgupo_k6hvfnzab-oc.jpeg"></div><br>  Di bagian atas jendela utama (dan satu-satunya) adalah menu untuk tombol-tombol yang dapat Anda tetapkan fungsi sewenang-wenang.  Item menu "XILINX" akan dijelaskan nanti. <br><br>  Di bawah ini adalah dua jendela.  Bagian atas menampilkan pesan yang dikirim dari program ke plugin "DOCSHELL.dll" dan diterima darinya. <br><br>  Di jendela bawah, Anda dapat mengetik perintah yang Anda butuhkan dan klik dua kali pada baris yang sesuai. <br><br>  Ketika program dimulai, beberapa perintah akan ditampilkan di dalamnya. <br><br>  <em>Jika Anda tiba-tiba mulai bekerja dengan chip nyata - hati-hati, karena</em>  <em>tidak ada peringatan bahwa Anda mungkin kehilangan semua data saat memformat, dll.</em>  <em>Program tidak diimplementasikan.</em> <br><br>  File "DOCSHELL.dll" ditemukan di direktori dengan program PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(4) yang</a> diinstal dari "Dataman" (dimungkinkan dari "Elnec"). <br><br>  Untuk dapat menggunakan DLL pihak ketiga dalam program Anda, Anda memerlukan file header dengan deskripsi metode yang diekspor dan argumen mereka.  Karena ketidakhadirannya, saya harus memulihkan informasi ini sendiri.  Metode untuk pemulihan tersebut berada di luar cakupan artikel ini, sehingga argumen dari metode yang diekspor dapat ditemukan di sumber terlampir. <br><br>  Dengan antarmuka pengguna dalam hal interaksinya dengan plugin, masalahnya menjadi agak lebih jelas.  Sekarang Anda dapat melanjutkan ke implementasi komunikasi dengan sirkuit mikro di tingkat fisik agar dapat menjalankan perintah baca / tulis dari / ke mDOC yang diterima dari plugin. <br><br>  Modul program untuk programmer ditulis dalam bahasa C dalam IDE "IAR Embedded Workbench for ARM".  Sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(7)</a> terlampir. <br><br>  Proses debug dilakukan dengan menggunakan JTAG J-Link debugger, yang terhubung ke programmer melalui konektor JTAG yang dipasang di sisi case dan dihubungkan ke motherboard dengan kabel datar. <br><br>  <em>JTAG debugger J-Link v9 dibeli di Aliexpress.</em>  <em>Driver yang diinstal dengan "IAR Embedded Workbench for ARM" bekerja sangat baik dengannya, dan bahkan memperbarui firmware asli dari SEGGER berhasil.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/md/5e/vq/md5evqm8gj7khtrvdsucwhd5yac.jpeg"></div><br>  Secara struktural, programmer dibuat dalam bentuk delapan papan yang terletak satu di atas yang lain dan dihubungkan bersama oleh konektor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3v/1n/b6/3v1nb6ntkgimwtwtir0lcekdgmm.jpeg"></div><br>  Konverter DC-DC yang dapat diatur terletak di papan terendah untuk menghasilkan beberapa voltase yang diperlukan untuk bekerja dengan berbagai sirkuit memori. <br>  Di atasnya adalah motherboard tempat mikrokontroler ARM ATMEL AT91SAM9G20, SDRAM, SPI FLASH dengan firmware, ID chip AE801 dengan model programmer dan nomor seri, chip USB ISP1582, konverter digital-to-analog TLC7226 untuk manajemen tegangan konverter DC-DC, sejumlah chip lain dan konektor eksternal untuk menghubungkan catu daya dan kabel USB untuk menghubungkan ke host. <br><br>  Pada papan bawah ketiga adalah chip XILINX XC2S50E, yang mengontrol kaki-kaki chip pada adaptor yang terhubung ke programmer selama prosedur baca / tulis, dll. <br>  Pada lima papan lainnya, register dan rakitan yang dimuat secara berurutan terhubung ke outputnya dengan kunci transistor, yang memungkinkan untuk menerapkan sirkuit mikro ke satu atau beberapa kaki chip yang dibentuk oleh konverter tegangan DC-DC, <br>  termasuk "bumi".  Karena register yang mengendalikan kunci transistor dimuat secara berurutan, dan jumlah kaki yang dikontrol dalam adaptor dapat mencapai 144, dibutuhkan waktu yang cukup lama untuk memuat semua blok kunci.  Oleh karena itu, dengan bantuan sakelar transistor, hanya level statis yang diumpankan ke sirkuit mikro: ground, power, dll.  Dan dengan XILINX - dinamis: alamat, data, CS, OE, RD, WR, dll. <br><br>  Untuk memajukan lebih lanjut, diperlukan, setidaknya, untuk memiliki sarana untuk membuat firmware untuk mikrokontroler XILINX XC2S50E dan diagram sirkuit, jika bukan dari keseluruhan pemrogram, maka setidaknya sebagian dari CPU - FPGA - adaptor - soket. <br><br>  Sedangkan untuk IDE untuk XILINX Spartan-IIE, saya harus menggunakan versi lama dari ISE 10.1, karena  semua IDE berikutnya tidak mendukung model FPGA Spartan-II. <br><br>  Situasi dengan diagram rangkaian ternyata lebih rumit.  Untuk mengidentifikasi senyawa yang menarik bagi kami, kami harus "menghapus" prosesor U4 dan XILINX U12 dari papan untuk mendapatkan akses ke bantalan di bawah kasus BGA mereka, karena  tidak semuanya memiliki saklar ke sisi sebaliknya. <br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/i6/xz/emi6xzfj5g9ks4imtdzvrc9mqa0.jpeg"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/fl/rg/st/flrgstgrxvaicirr108z0ahlphs.jpeg"></div></td></tr></tbody></table>  Tuan rumah berkomunikasi dengan programmer melalui USB melalui beberapa titik akhir (Endpoint).  Tuan rumah selalu bertindak sebagai tuan rumah.  Melalui salah satu titik akhir, tuan rumah mengirimkan perintah ke pemrogram dan melalui itu menerima konfirmasi, <br>  melalui yang lain mereka saling bertukar data. <br><br>  Perintah parsing dari host dalam modul program dilakukan dalam metode USB_ReceiveBuf_EP1RX_Parse (). <br><br>  Paket perintah dijelaskan oleh struktur CMD_PROG dan terdiri dari beberapa bidang.  Jika bidang Cmd berisi 1, maka ini adalah perintah untuk bekerja dengan sirkuit mikro dan bidang ProgProcNum dalam kasus ini adalah indeks dalam larik _progProcedures dari struktur PROG_PROC, di mana salah satu bidang penunjuk ke perintah yang akan dieksekusi disimpan. <br><br>  Dalam direktori dengan program yang diinstal "SUPERPRO 6100N" ada subdirektori "\ lib".  Itu dengan ekstensi "* .bin" menyimpan file firmware XILINX untuk semua jenis chip yang didukung oleh programmer.  Di antara mereka ada dua firmware universal untuk memeriksa kontak kaki-kaki sirkuit mikro dengan kontak soket pada adaptor. <br><br>  Ini adalah "GENERAL ~ .BIN" dengan pull-up internal untuk semua kaki pull-up XILINX dan "GENERAL_.BIN" dengan pull-down pull internal. <br><br>  Memeriksa kontak kaki mikrosirkuit dilakukan dalam metode SOCKET_CkeckInsertIC () pada modul perangkat lunak sebagai berikut. <br><br>  Pertama, firmware “GENERAL_.BIN” dimuat ke XILINX dan dengan bantuannya semua kaki FPGA yang terhubung ke soket dikonfigurasikan untuk output dan logis “1” disediakan untuk mereka.  Kemudian, pada gilirannya, setiap leg FPGA dikonfigurasi ulang untuk input, tingkat logis dibaca dari itu, dan kemudian "1" lagi output ke leg ini. <br><br>  Jika kaki mikrosirkuit memiliki kontak listrik dengan kaki soket yang sesuai, maka "1" harus dibaca darinya (melalui dioda pelindung internal mikrosirkuit dari semua kaki lainnya).  Dan dengan tidak adanya kontak, karena fakta bahwa semua pin FPGA ditarik ke tanah, "0" akan dibaca dari input ini.  Setelah itu, berbagai level logis yang dibaca dengan cara ini dikirim ke host dan diproses di sana.  Selanjutnya, pelaksanaan operasi yang ditentukan berlanjut, atau sebuah pesan ditampilkan tentang non-VKontakte dari kaki-kaki yang sesuai dari rangkaian mikro dalam soket. <br>  Setelah berhasil melewati tes ini, tuan rumah mengirimkan firmware untuk XILINX yang sesuai dengan chip yang dipasang di adaptor ke programmer. <br><br>  Mengkompilasi program untuk FPGA dalam ISE 10.1 (eksekusi berurutan dari prosedur sintesis (Synthesize), implementasi desain (Implement Design) dan pembuatan file pemrograman (Generate Programming File)) menciptakan file konfigurasi biner "xeltek.bin" dari 78756 byte di direktori proyek.  <em>Untuk ini, dalam properti dari proses "Hasilkan File Pemrograman" di jendela "Proses" dalam kategori "Opsi Umum", dua opsi harus ditetapkan: "Buat File Bit" dan "Buat File Konfigurasi Bibary".</em> <br><br>  Tidak diketahui karena alasan apa, tetapi programmer XELTEK memutuskan untuk memodifikasi file yang diperoleh dengan memantulkan semua bit dalam setiap byte. <br><br>  Jika karena alasan tertentu Anda perlu "mirror" file Anda sendiri dengan cara ini, atau "mirror" file dari direktori "\ lib" kembali ke tampilan normal, dalam perangkat lunak dalam menu "XILINX" ada untuk tujuan ini item "Bitstream Converter" (di akhir nama file yang dihasilkan digarisbawahi). <br><br>  Untuk bekerja dengan chip SDED5 pada level fisik, empat metode berikut diimplementasikan dalam modul perangkat lunak: <br><br>  - PROGPROC_FLWRITE_IO_WORD () - merekam kata (16 bit) di alamat yang ditentukan <br>  - PROGPROC_FLREAD_IO_WORD () - baca kata (16 bit) di alamat yang ditentukan <br>  - PROGPROC_hal_blk_write_nor () - tulis satu atau lebih sektor (masing-masing 512 byte) di alamat yang ditentukan <br>  - PROGPROC_hal_blk_read_nor () - baca satu atau lebih sektor (masing-masing 512 byte) di alamat yang ditentukan <br><br>  Untuk berinteraksi dengan FPGA XILINX dalam firmware kami, kami mengidentifikasi empat register (port I / O, dijelaskan dalam file common.h untuk sumber ARM). <br><br>  - _IC_ADDR (0x30000010) <br>  - _IC_DATA (0x30000012) <br>  - _IC_CTRL (0x30000014) // Keluar: 0 - KAMI, 1 - 0E, 2 - CE, 3 - RSTIN;  Dalam: 0 - SIBUK <br>  - _IC_ENABLE (0x30000016) // In: 7 - Izin kerja (0 - aktif, 1 - semua kaki pada soket di Z) <br><br>  _IC_ADDR dan _IC_DATA adalah alamat 16-bit dan register data untuk chip yang dapat diprogram SDED5; <br>  _IC_CTRL - register kontrol 8-bit melalui mana sinyal WE, OE, CE dan RSTIN diatur dan sinyal BUSY dibaca dari SDED5. <br><br>  Modul perangkat lunak asli menggunakan alamat dari 0x30000000 hingga 0x3000000E untuk berkomunikasi dengan FPGA.  CPLD dengan prasasti XELTEK dipasang sebagai decoder alamat di programmer, dan karena kami tidak tahu firmware-nya, kami menggunakan alamat dari 0x30000010 untuk berjaga-jaga jika ada kemungkinan konsekuensi yang tidak diharapkan dari memanifestasikan logika perilaku orang lain ketika menggunakan alamat "standar". <br><br>  Setelah memuat firmware-nya ke dalam FPGA, semua output FPGA yang terhubung ke kaki-kaki sirkuit mikro dalam soket berada dalam status Z dan untuk mulai bekerja dengannya, Anda harus mengaktifkan resolusi dengan menulis nol hingga bit ketujuh dari register _IC_ENABLE. <br><br>  Algoritma dari keseluruhan sistem dapat terlihat sebagai berikut. <br><br><ol><li>  Setelah memulai perangkat lunak pada host, ia memeriksa apakah ada koneksi ke programmer melalui USB dan menampilkan pesan yang sesuai di bilah status di bagian bawah jendela utama <br>  (programmer dapat dihubungkan setelah dimulainya program). </li><li>  Pengguna memilih jenis chip yang akan digunakannya untuk bekerja. </li><li>  Dalam database (dalam kasus paling sederhana, hanya dalam file), rangkaian mikro yang dipilih cocok dengan jenis adaptor yang diperlukan dan permintaan dikirim ke programmer untuk jenis adaptor yang dipasang di dalamnya. </li><li>  Programmer menanyakan jenis adaptor dan mengirimkan informasi ini kembali ke tuan rumah, di mana informasi ini dibandingkan dengan yang ditemukan dalam database, dan jika jenis adaptor cocok, pekerjaan berlanjut. </li><li>  Untuk setiap jenis sirkuit mikro yang dipilih dalam perangkat lunak, menu yang sesuai harus ditampilkan dengan perintah yang tersedia untuk sirkuit mikro tersebut (baca, tulis, periksa kebersihan, perbandingan, dll.). </li><li>  Ketika Anda memilih item menu untuk bekerja dengan sirkuit mikro, perintah yang sesuai dikirim ke programmer, setelah itu programmer terlebih dahulu memeriksa kontak listrik dari kontak soket dengan kaki sirkuit mikro, dan kemudian, jika berhasil, jalankan perintah ini. </li></ol><br>  <em>Dalam kode sumber yang dilampirkan pada artikel, untuk menyederhanakan tugas, poin dari inklusif kedua ke kelima tidak diterapkan.</em> <br><br><h4>  Ringkasan </h4><br>  Kami tidak dihadapkan dengan tugas mengintegrasikan modul perangkat lunak ke dalam perangkat lunak asli, <br>  Oleh karena itu, materi yang dijelaskan dalam artikel ini tidak mengklaim sebagai solusi lengkap. <br>  Kami berharap bahwa informasi yang disajikan di sini akan berguna untuk kategori pembaca tertentu, dan sejauh kemampuan kami dan ketersediaan waktu luang, kami akan mencoba menjawab pertanyaan Anda. <br><br>  Terima kasih atas minat Anda! <br><br><h4>  Sumber daya </h4><br>  1. <a name="ref1"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF - mDOC H3 Embedded Flash Drive (EFD) menampilkan Perangkat Lunak Manajemen Flash TrueFFS Tertanam</a> <br>  2. <a name="ref2"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF - Memprogram Memories Flash H3 mDOC Menggunakan Pemrogram Perangkat Dataman</a> <br>  3. <a name="ref3"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF - Software_Utilities_TrueFFS_7.1</a> <br>  4. <a name="PG4UW"></a>  <a href="">Perangkat Lunak Kontrol Dataman - PG4UW</a> <br>  5. <a name="linux"></a>  <a href="">Implementasi driver mDOC H3 untuk Linux (kinerja tidak diuji)</a> <br>  6. <a name="refSrcHost"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Host file sumber programmer (Visual Studio 2017).</a> <br>  7. <a name="refSrcModule"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber file dari modul perangkat lunak (IAR Embedded Workbench for ARM v8.30.1).</a> <br>  8. <a name="refSrcFPGA"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber file untuk FPGA XILINX XC2S50E (XILINX ISE 10.1).</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430634/">https://habr.com/ru/post/id430634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430618/index.html">Vue.js SSR & Mobile Safari: Masalah Yang Tidak Terlihat Dengan Perangkat Lunak Terlalu Cerdas</a></li>
<li><a href="../id430622/index.html">Pemikiran fungsional. Bagian 5</a></li>
<li><a href="../id430626/index.html">Pengumuman Pertemuan GraphQL Moskow</a></li>
<li><a href="../id430628/index.html">Algoritme Fortune, detail implementasi</a></li>
<li><a href="../id430632/index.html">Layanan dalam bisnis: Bagaimana pengecer asing membuka toko turnkey di Rusia</a></li>
<li><a href="../id430636/index.html">Cerebellum dan inti basal bukan bola kristal: bagaimana otak memprediksi masa depan</a></li>
<li><a href="../id430640/index.html">Laut Merah: mengapa saham Apple dan perusahaan teknologi lainnya jatuh</a></li>
<li><a href="../id430642/index.html">Arahan "Photonics" di Olimpiade "I am a Professional", atau cara mendaftar di magistracy tanpa ujian</a></li>
<li><a href="../id430644/index.html">Kerentanan baru di Facebook menyebabkan kebocoran data pribadi pengguna</a></li>
<li><a href="../id430646/index.html">Serialisasi Binary .Net tanpa merujuk ke rakitan dengan jenis sumber atau cara bernegosiasi dengan BinaryFormatter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>