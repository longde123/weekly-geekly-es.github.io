<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ ‚úã üë®üèæ‚Äç‚öïÔ∏è Fastware üë©üèø‚Äçü§ù‚Äçüë©üèæ üë®üèΩ‚Äçüíº üàØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrei Alexandrescu es una verdadera leyenda viviente. Esta es una persona que ha hecho una contribuci√≥n significativa a la historia de los lenguajes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fastware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/425191/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andrei Alexandrescu</a> es una verdadera leyenda viviente.  Esta es una persona que ha hecho una contribuci√≥n significativa a la historia de los lenguajes de programaci√≥n modernos y las t√©cnicas generalizadas y de metaprogramaci√≥n.  Cu√°ntas copias se rompieron en las discusiones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre el Dise√±o moderno C ++</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Est√°ndares de codificaci√≥n 101</a> (escritos con el Excepcional Escudo de armas C ++ de Sutter) y otros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libros y art√≠culos</a> .  Como coautor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del lenguaje D</a> , tuvo la oportunidad no solo de teorizar, sino tambi√©n de hacer realidad su sue√±o y, lo que es t√≠pico, lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encarn√≥</a> . <br><br>  Ahora tiene en sus manos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> de la conferencia DotNext 2018 Piter, que habla sobre las tecnolog√≠as modernas de optimizaci√≥n.  ¬øQu√© tiene que ver .NET con √©l?  Este es un informe fundamental de una persona que ha estado optimizando toda su vida.  Si el rendimiento es importante para usted, debe verlo (o leer este art√≠culo).  ¬°Bienvenido a cat! <br><br><img width="100%" src="https://habrastorage.org/webt/9_/mg/9m/9_mg9mjeeamxyknlbdqeg4ukoa4.jpeg"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZazBhE1IQd0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  El arte de la evaluaci√≥n comparativa </h1><br>  Me gustar√≠a discutir con usted varios temas relacionados con la evaluaci√≥n comparativa.  Para comenzar, repitamos algunas cosas b√°sicas.  <b>La ley de Amdahl</b> es parte de los cl√°sicos de la inform√°tica, se usa principalmente en la computaci√≥n paralela, pero funciona en cualquier sistema complejo.  Si queremos mejorar el trabajo de cierto sistema, entonces debemos comenzar donde se concentran los principales problemas de este sistema.  La ley en s√≠ es obvia: si un componente es el 20% del sistema, entonces la mejora m√°xima en el rendimiento del sistema que se puede lograr mediante la optimizaci√≥n de la operaci√≥n de solo este componente es del 20%.  Demasiado a menudo tengo que conocer personas (por supuesto, nuestros lectores no les pertenecen) que hacen cosas como optimizar el an√°lisis de la l√≠nea de comandos.  Estas operaciones toman los primeros 10 microsegundos de su programa, y ‚Äã‚Äãlas personas analizan su complejidad algor√≠tmica y se horrorizan si el tiempo es cuadr√°tico. <br><br>  Como probablemente sepa, antes de comenzar la optimizaci√≥n, es necesario perfilar la aplicaci√≥n y seleccionar puntos calientes en ella.  Aqu√≠ deber√≠a decirse sobre la <b>ley de Ladma</b> (este no es un apellido real, y Amdal, le√≠do al rev√©s).  Debe concentrar sus esfuerzos en el componente que conduce a la mayor inversi√≥n de tiempo.  Es necesario moverlo fuera de la aplicaci√≥n, realizar el trabajo necesario, regresar y probar nuevamente.  La raz√≥n por la que necesita hacer esto es porque muy a menudo una mejora del rendimiento del 20% es el resultado de diez mejoras del 2%.  Y en el marco de un sistema grande, es imposible medir una mejora tan peque√±a.  Para esto, el componente debe probarse en un conjunto de pruebas.  Una mejora del 20% en el rendimiento de uno de los componentes principales del sistema puede significar una mejora del 5% para el sistema en su conjunto, y para algunas √°reas este es un excelente resultado.  No olvide que las optimizaciones pueden tener una serie de efectos globales, por lo que, seg√∫n los resultados de la evaluaci√≥n comparativa selectiva, debe tener mucho cuidado al sacar conclusiones sobre el funcionamiento del sistema en su conjunto. <br><br>  Un error que estoy seguro de que nuestros lectores no cometen, pero que generalmente es bastante com√∫n: las personas miden la velocidad de depuraci√≥n del ensamblaje.  Esto nunca debe hacerse.  Esto es similar a estar molesto debido a la baja velocidad del caracol en las carreras: no est√° destinado a tal competencia, tiene otros objetivos en la vida.  Otro error, algo menos obvio: las personas primero miden el rendimiento b√°sico del sistema e inmediatamente despu√©s realizan una evaluaci√≥n comparativa.  Pero despu√©s de recopilar la l√≠nea de base, muchos recursos se calientan.  Por ejemplo, los archivos abiertos se almacenan en el b√∫fer y permanecen en la memoria (al menos en Linux).  Por lo tanto, la segunda prueba ser√° m√°s r√°pida solo porque se inicia despu√©s de la primera.  Esto sucede incluso con llamadas malloc.  Despu√©s de estas llamadas, el sistema no vuelve a su estado original, incluso si se realizan llamadas de liberaci√≥n de memoria.  La configuraci√≥n interna, el almacenamiento en cach√© y las caracter√≠sticas utilizadas por el asignador de memoria permiten que las siguientes llamadas malloc se ejecuten mucho m√°s r√°pido.  Incluso sin tener en cuenta el efecto de la memoria cach√©, Malloc recuerda que, por ejemplo, algunas funciones asignaron memoria para objetos de 4 kilobytes muchas veces, lo que significa que debe tener una lista libre con un tama√±o de elemento de 4 kilobytes.  O otro ejemplo: las b√∫squedas de DNS se almacenan en cach√© para su reutilizaci√≥n despu√©s de la primera consulta.  Si es posible, durante la evaluaci√≥n comparativa, debe reiniciar todo el proceso cada vez, de principio a fin. <br><br>  Por ejemplo, para devolver completamente el sistema a su estado original, en el caso de los archivos, deben abrirse en un disco separado, que, despu√©s del final de la prueba, debe eliminarse (seg√∫n tengo entendido, esto se puede hacer en Windows).  La operaci√≥n no es f√°cil, pero en la mayor√≠a de los casos es necesaria. <br><br>  Continuando con la conversaci√≥n sobre los errores durante la optimizaci√≥n, tuve que lidiar con esos casos cuando los costos de printf se incluyen en los resultados de la prueba.  Hay errores de procedimiento cuando se cambia m√°s de una cosa antes de cada medici√≥n, lo que viola los principios m√°s b√°sicos de un experimento cient√≠fico, ya que no est√° claro qu√© efecto est√° midiendo.  Otro error grave es cuando se optimizan algunos casos raros, lo que conduce a la pesimismo en otras situaciones. <br><br><img src="https://habrastorage.org/webt/rs/fj/lf/rsfjlfl8ndtxzczw96ur5jyeijo.jpeg"><br><br>  Aqu√≠ hay un ejemplo con Stack Overflow.  El autor a menudo clasifica los datos ya ordenados y se sorprende, porque la funci√≥n `is_sorted 'es obviamente mucho m√°s r√°pida que` sort.  ¬øPor qu√© entonces en `sort the first line not is` if is_sorted return?  Est√° optimizando un caso extremadamente raro, datos completamente ordenados, y todos los dem√°s que tengan al menos un elemento no ordenado deber√°n asumir los costos de esta optimizaci√≥n.  Esto no vale la pena hacerlo. <br><br>  Creo que no tengo que demostrar durante mucho tiempo que las arquitecturas de la competencia actual son extremadamente complejas: cambio din√°mico de frecuencia, interrupci√≥n por otros procesos, virtualizaci√≥n, etc.  Por lo tanto, es casi imposible obtener el mismo tiempo al medir, sus indicadores siempre temblar√°n.  Por lo tanto, uno no debe confiar en cosas que parecen obvias.  Digamos que puede parecer obvio que menos instrucciones significan un c√≥digo m√°s r√°pido, y esto no siempre es cierto.  Tambi√©n puede parecer que el uso de datos almacenados siempre ser√° m√°s r√°pido que volver a realizar los c√°lculos, por lo que si almacena los resultados en cach√©, estar√° bien.  Como en el caso anterior, no se puede afirmar de manera inequ√≠voca, al igual que lo contrario no se puede declarar incondicionalmente; todo depende del contexto.  Obviamente, solo debe tener una cosa: todo debe medirse.  Si mide todo, obtendr√° mejores resultados que los expertos con conocimiento que no toman medidas. <br><br>  Hay una serie de pr√°cticas bastante confiables, cuya discusi√≥n puede llevarlo a pensamientos interesantes.  Debemos comenzar con el hecho de que las matem√°ticas no te decepcionar√°n.  Permite mostrar que los sistemas con diferentes velocidades pueden ser equivalentes.  La matem√°tica da reglas para mostrar la equivalencia de ciertas cosas e identificar algunas propiedades, y aunque no est√° sesgada, no importa qu√© cosas son interesantes y cu√°les no.  Muchas personas piensan que la optimizaci√≥n se basa en el conocimiento del c√≥digo de m√°quina y el trabajo con bits, pero de hecho tiene muchas matem√°ticas, porque demuestra que un sistema m√°s r√°pido es equivalente a uno m√°s lento. <br><br>  Otra regla general es que a las computadoras les encanta que las cosas sean aburridas.  ¬øNecesitas multiplicarnos por dos vectores, mil millones de elementos en cada uno?  Esta es una tarea ideal para una computadora, todo el equipo que contiene est√° especialmente afilado para este tipo de tareas.  Para analizar estos datos, bas√°ndome en ellos para construir una expresi√≥n regular, no quiero hacer esto.  A las computadoras no les gustan cosas como ramas, dependencias, llamadas indirectas, en resumen: no les gusta el c√≥digo inteligente, les gusta el c√≥digo aburrido.  A las computadoras no les gusta la grabaci√≥n indirecta, un problema complejo que las personas involucradas en el hierro han estado luchando durante mucho tiempo y no pueden resolver. <br><br>  Otra regla es que debe dar preferencia a las operaciones menos potentes, en otras palabras, prefiera la suma a la multiplicaci√≥n y la multiplicaci√≥n a la exponenciaci√≥n.  Nuevamente, las matem√°ticas son √∫tiles aqu√≠. <br><br>  Finalmente, la √∫ltima regla: cuanto m√°s peque√±a, m√°s bella.  El tama√±o peque√±o permite que las computadoras se den cuenta de sus ventajas, ya que prefieren que los datos, y especialmente las instrucciones, est√©n cerca unos de otros.  Los resultados de varias mediciones de la velocidad de la aplicaci√≥n siempre diferir√°n, tendr√° una distribuci√≥n de los resultados.  Por lo general, solo tomamos el promedio de estos pocos resultados.  Pero el problema es que, debido a las caracter√≠sticas espec√≠ficas de las computadoras, el promedio incluir√° mucho ruido.  Cuando Bill Gates viaja en un autob√∫s, en promedio, cada pasajero en un autob√∫s es multimillonario.  Suena genial, pero es poco confort para una persona sin hogar que viaja en el mismo autob√∫s.  Una situaci√≥n similar ocurre con las interrupciones: la operaci√≥n de multiplicaci√≥n toma nanosegundos, pero cuando toma muchas mediciones de tales operaciones, una de ellas inevitablemente tendr√° una interrupci√≥n de dos milisegundos.  La diferencia es de tres √≥rdenes de magnitud y, sin embargo, los desarrolladores no siempre tienen esto en cuenta. <br><br>  Entonces, repito: el ruido en las computadoras siempre es aditivo;  para las personas, puede parecer insignificante, pero para microbenchmarking es significativo, y la media aritm√©tica incluir√° mucho ruido.  En lugar del promedio, necesita un indicador que mida solo el tiempo en el que puede influir de alguna manera.  Si abordamos este tema desde el punto de vista de las matem√°ticas, veremos que necesitamos encontrar un valor que corresponda al mayor n√∫mero de mediciones que hemos realizado.  En otras palabras, necesitamos un mod.  Esto nos lleva inmediatamente al problema: ¬øqu√© sucede si tomas el mod de clasificaci√≥n r√°pida?  Si el algoritmo es probabil√≠stico o si los datos son aleatorios, casi nunca habr√° una moda.  La densidad de valores ser√° casi la misma en todo el espectro.  En este caso, simplemente descartamos el 5% de las mediciones m√°s grandes y luego tomamos el valor promedio, o el m√°ximo, en el √∫ltimo caso tendremos un techo que no se exceder√° en el 95% de los casos.  Casi siempre habr√° un sujeto sentado en el viejo s√≥tano con un m√≥dem lento, en el que cada p√°gina se cargar√° durante una hora.  Puramente humanos, por supuesto, simpatizamos con √©l, pero t√©cnicamente no podemos ayudar a todos, por lo tanto, el 5% restante de los casos tiene que ser descuidado.  En general, al resolver problemas de red, a menudo nos centramos en el percentil 95, porque es imposible concentrarse en el cent√©simo.  El percentil cien significar√° el resultado m√°s lento de todas las mediciones recopiladas; esto no es informativo. <br><br><h1>  Reemplazar ramas con aritm√©tica </h1><br>  C√≥mo, espero, qued√≥ claro que la medici√≥n no es un problema f√°cil.  Veamos algunos ejemplos y comencemos tratando de reemplazar la ramificaci√≥n con aritm√©tica.  Estamos hablando de casos en los que necesitamos una declaraci√≥n if, pero usarla con demasiada frecuencia no es deseable.  En su lugar, integraremos el resultado de la rama como un valor 0/1.  El c√≥digo se ver√° lineal, la computadora solo tendr√° que revisarlo de principio a fin, sin pensar en qu√© paso debe seguir a continuaci√≥n. <br><br>  Intentemos resolver el siguiente problema: transfiera los m√≠nimos de cada cuartil de la matriz al primer cuartil.  En otras palabras, la matriz se debe dividir en cuatro partes y el valor m√≠nimo de cada parte se debe colocar al comienzo de la matriz. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = p.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; n / <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Arriba est√° el c√≥digo b√°sico.  Por cierto, puedo anunciar con orgullo que traduje estos ejemplos a C # y que se compilaron con √©xito.  El c√≥digo en s√≠ es bastante simple: a `m se le asigna el √≠ndice del menor de los dos valores ubicados en los √≠ndices 'i y` j, y luego una asignaci√≥n similar se repite dos veces m√°s, dependiendo de los otros dos √≠ndices.  Finalmente, el valor en el √≠ndice `m se invierte en la matriz con el valor en el √≠ndice` i.  Como puede ver, omitimos la matriz usando cuatro variables inductivas. <br><br>  El problema de probar dicho algoritmo ser√° interesante y no obvio.  Tendremos que probarlo no en un conjunto de datos, sino en datos que podr√≠an surgir en varios casos.  Por ejemplo, en datos que parecen tubos de un √≥rgano: primero aumenta, luego disminuye;  en datos aleatorios con una distribuci√≥n uniforme;  en un conjunto aleatorio de ceros y unos: a partir de datos aleatorios aqu√≠, la diferencia es que habr√° muchos valores duplicados;  en datos ya ordenados;  finalmente, sobre datos obtenidos por mediciones reales de alg√∫n fen√≥meno f√≠sico.  Este ser√° un enfoque serio para medir la velocidad de un algoritmo, y generalmente se acepta entre las personas que estudian algoritmos. <br><br>  Intentemos mejorar el c√≥digo que acabamos de conocer. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Como primera optimizaci√≥n, intentaremos evitar la repetici√≥n excesiva de operaciones, para esto sacamos varias operaciones de divisi√≥n del bucle: dividiendo `n por 2 y 4 y dividiendo 3 *` n por 4. Pero despu√©s de esta optimizaci√≥n, descubrimos que los c√°lculos no eran para El problema principal es nosotros: el c√≥digo no ser√° m√°s r√°pido, aunque ser√° m√°s compacto.  En el mejor de los casos, lograremos una mejora del medio por ciento. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = q, k = <span class="hljs-number"><span class="hljs-number">2</span></span> * q, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[k] &lt;= p[l] ? k : l; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  El segundo cambio que haremos al c√≥digo es reducir las dependencias.  En la versi√≥n anterior del algoritmo, la asignaci√≥n de 'ma' k o 'l depende del valor asignado a la l√≠nea' m anterior.  Para reducir el n√∫mero de dependencias `m, calculamos por separado` m0 y` m1, y luego las comparamos.  Cuando realic√© esta optimizaci√≥n, esperaba una mejora significativa en la velocidad del algoritmo, pero al final result√≥ ser cero.  Pero, en mi opini√≥n, es importante mantener el n√∫mero de dependencias al m√≠nimo, por eso guard√© el c√≥digo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[i + q] ? i : i + q; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q] &lt;= p[i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q] ? i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q : i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Intentemos ahora reducir el n√∫mero de variables inductivas de cuatro a uno, y calcularemos las tres restantes aritm√©ticamente, ya que est√°n en relaci√≥n constante entre s√≠.  Esto es bastante simple: en lugar de `k, tendremos` i + q, en lugar de las otras dos variables:` i + 2 * q y` i + 3 * q.  Tambi√©n ten√≠a grandes esperanzas para esta optimizaci√≥n, pero, como la anterior, no dio ning√∫n resultado a tiempo.  Esto demuestra nuevamente la importancia de las mediciones: sin ellas podr√≠a presumir de haber mejorado significativamente el funcionamiento del algoritmo y tendr√≠a argumentos muy significativos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2: ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i - q] &lt; p[i] ? i - q : i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + q2] &lt; p[i + q] ? i + q2 ? i + q; Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Como cuarto intento, reestructuramos el ciclo para deshacernos de la multiplicaci√≥n por 3. Esto nos dar√° una mejora del 3%.  El resultado a√∫n no es impresionante.  A continuaci√≥n, intente deshacerse de los operadores ternarios. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: value if flag is true, 0 otherwise static int optional(bool flag, int value) { return -Convert.ToInt32(flag) &amp; value; }</span></span></code> </pre> <br>  Para hacer esto, me gustar√≠a presentarle una nueva funci√≥n: `static int opcional (bool flag, int value).  Convierte el valor booleano de entrada en Int32, lo multiplica por -1 y lo pasa al operador AND a nivel de bits junto con el segundo valor de entrada.  Si el indicador de entrada era falso, en int32 ser√° 0, y despu√©s de todas las conversiones en la salida todav√≠a obtendremos 0. Si el indicador de entrada fue verdadero, en int32 ser√° 1, cuando se multiplica por -1 obtenemos FFFFFFFF, que despu√©s del bit "Y" con cualquier n√∫mero dar√° este segundo n√∫mero.  Tenga en cuenta que no hay una declaraci√≥n if en ning√∫n lado, el c√≥digo no tiene ramificaci√≥n, es aburrido para una computadora (aunque nos parece complicado). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = i - optional(p[i - q] &lt;= p[i], q); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = i + q + optional(p[i + q2] &lt; p[i + q], q); Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Reemplazaremos a los operadores ternarios con esta funci√≥n opcional, la integraremos dentro del c√°lculo.  Lo aplicamos dos veces y, en el tercer caso, dejamos el signo de interrogaci√≥n.  Por lo tanto, en lugar de cuatro controles en este ciclo, solo tendr√© uno. <br><br><img src="https://habrastorage.org/webt/qo/wp/--/qowp---fgvtqsgddipqokwb_k3o.jpeg"><br><br>  A partir de los resultados de medici√≥n que ve en la diapositiva, queda claro cu√°n importante era probar el algoritmo en varios conjuntos de datos diferentes.  En un set no entender√≠amos nada.  En datos aleatorios y reales, tenemos una aceleraci√≥n de m√°s del doble, en tubos de √≥rganos y datos ordenados, tenemos una ligera desaceleraci√≥n.  Esto se debe al hecho de que en el caso de los datos ordenados para el predictor de transici√≥n no habr√° sorpresas, predecir√° con una precisi√≥n del 100%.  En el caso de los tubos de √≥rganos, tendremos una predicci√≥n incorrecta en el medio del conjunto de datos; nuevamente, una precisi√≥n muy alta.  En contraste, con datos aleatorios, la diferencia entre nuestros dos enfoques ser√° enorme.  Reemplazamos todos los cheques impredecibles con l√≥gica simple.  Aqu√≠ volvemos a una verdad simple: las computadoras est√°n dise√±adas para la inform√°tica, como su nombre lo indica (inform√°tica - inform√°tica).  Ramificando, mostrando im√°genes en la pantalla, todo esto se desempe√±a mucho peor.  Realizar bit a bit "Y" para ellos es mucho m√°s simple que pasar la instrucci√≥n if. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = i + optional(p[i + q] &lt; p[i], q); m += optional(p[i + q2] &lt; p[m], q); m += optional(p[i + q2 + q] &lt; p[m], q); Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Habiendo logrado finalmente un resultado positivo de la optimizaci√≥n, intentaremos reemplazar el √∫ltimo operador ternario con nuestra funci√≥n `opcional.  Esta vez la ganancia en velocidad ser√° peque√±a.  Para entender por qu√© sucede esto, debe mirar el c√≥digo generado.  En la versi√≥n anterior del c√≥digo, donde el signo de interrogaci√≥n todav√≠a estaba presente, el compilador ya encontr√≥ una manera de ejecutar el c√≥digo sin bifurcaci√≥n.  Y cuando llega al operador ternario, ya pod√≠a predecirlo.  Reemplazar esta √∫ltima pieza con `opcional dar√° un c√≥digo algo peor.  Por lo tanto, repito, es importante tomar medidas cada vez. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: v1 if flag is true, v2 otherwise static int ifelse(bool flag, int v1, int v2) { return (-Convert.ToInt32(flag) &amp; v1) | ((Convert.ToInt32(flag) - 1) &amp; v2); }</span></span></code> </pre><br>  Otra caracter√≠stica que me gustar√≠a recomendarle es `ifelse sin ramas, que ahora ve en la pantalla.  Es cierto que no pude lograr con √©l las mejoras de rendimiento en nuestro ejemplo.  Si se le pasa 0 como bandera, la primera l√≠nea ser√° 0;  en el segundo, restamos 1 de 0 en Int32 y obtenemos FFFFFFFF, despu√©s de lo cual este valor se pasa al bit "Y" junto con el argumento de funci√≥n `v2, que nos dar√° este argumento en s√≠ mismo sin cambios;  finalmente, la primera y la segunda l√≠nea se pasan al bit "OR", que nuevamente nos dar√° `v2.  Si la bandera es 1, entonces la primera l√≠nea ser√° igual a `v1;  en el segundo, restamos 1 de 1 y obtenemos 0, como resultado de lo cual toda la l√≠nea ser√° 0, y 0 y 'v1 en el bit' OR 'dar√°' v1. <br><br>  Espero que dicha funci√≥n `ifelse sin ramificaci√≥n interese a las personas que est√°n involucradas en el backend; por ahora, los compiladores modernos por alguna raz√≥n no utilizan este enfoque.  Con estas funciones, puede reorganizar los algoritmos para que los compiladores los entiendan por usted, porque usted es m√°s inteligente y creativo que su compilador. <br><br><h1>  Gran conjunto de intersecci√≥n </h1><br>  Cambia un poco el tema de nuestra conversaci√≥n y pasa a la intersecci√≥n de grandes conjuntos.  Hasta ahora, hemos estado hablando de operadores individuales, ahora crearemos nuevos algoritmos, por lo que tendremos que distraernos de los detalles y abrir nuestras mentes a una perspectiva m√°s amplia.  Supongo que est√° familiarizado con la ordenaci√≥n por fusi√≥n, multiplique dos vectores y busque elementos comunes de dos vectores ordenados.  Se atraviesan dos conjuntos ordenados, y cuando hay elementos iguales en ellos, esto se considera una coincidencia.  Si uno de los dos elementos que se compara es m√°s peque√±o, cambia.  Este algoritmo es bastante simple, pero muy com√∫n, probablemente el m√°s utilizado en el mundo.  Se utiliza en todas las consultas de varias palabras, cada consulta es la intersecci√≥n de dos conjuntos.  Este algoritmo, en particular, usa Google, y tambi√©n debe aplicarse en todas las consultas de la base de datos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> || a2.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1[i1] &lt; a2[i2]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a2[i2] &lt; a1[i1]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t[i++] = a1[i1]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length || ++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>: } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Eche un vistazo a la implementaci√≥n b√°sica de este algoritmo.  Si ambos conjuntos de entrada est√°n vac√≠os, entonces, obviamente, devolvemos 0. Luego, comenzamos un ciclo infinito, en el cual, si hay una coincidencia, aumentamos el resultado en 1 y verificamos si el ciclo debe completarse.  En lugar de un bucle infinito, uno podr√≠a usar la instrucci√≥n for y especificar la condici√≥n para finalizar el bucle en ella.  Pero eso significar√≠a trabajo extra.  En la implementaci√≥n que ve en la diapositiva, en la primera rama tenemos `if (a1 [i1] &lt;a2 [i2]), despu√©s de lo cual hay un aumento de` i1 en 1, y solo podemos verificar` i1.  Del mismo modo, en la segunda rama solo necesitamos verificar `i2.  Ambos valores deben verificarse solo en la tercera rama.  Si esta verificaci√≥n fuera al comienzo del ciclo, entonces har√≠amos el trabajo extra. <br><br>  Intentemos mejorar esta implementaci√≥n.  Por el momento, su complejidad algor√≠tmica es lineal, dependiendo de dos argumentos de entrada.  En el aprendizaje autom√°tico, a menudo uno tiene que encontrar la intersecci√≥n de conjuntos que son muy diferentes entre s√≠ en tama√±o o en estad√≠sticas.  Por ejemplo, tiene un vector de entrada largo y un vector de funci√≥n corto con el que est√° comprobando.  En nuestro c√≥digo, puede haber un mill√≥n de registros en `a1 y mil en` a2.  En este caso, no estamos listos para seguir un mill√≥n de pasos para completar este algoritmo.  La mayor carga aqu√≠ estar√° en la siguiente l√≠nea de c√≥digo: `if (++ i1 == a1.length) break.  Justo antes de esto, se produce una comparaci√≥n, y luego en esta l√≠nea hay un incremento del valor;  esto, en esencia, es una b√∫squeda lineal.  Realizamos iteraciones sobre un vector largo en busca de elementos de uno corto.  En el peor de los casos, realizaremos muchas de estas b√∫squedas, movi√©ndonos lentamente a lo largo del vector. <br><br>  Intentemos mejorar este algoritmo.  Bueno, si no es una b√∫squeda lineal, entonces binario es mejor, ¬øverdad?  Usemos binario.  Su ventaja es que da el √≠ndice del m√°s grande de los elementos m√°s peque√±os. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; --m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m] &lt; a1[i1])) t[i++] = a1[i1]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br>  El c√≥digo anterior es una implementaci√≥n de nuestro algoritmo de b√∫squeda binaria.  Pero no es muy efectivo.  La peor situaci√≥n aqu√≠ ser√° cuando la b√∫squeda binaria fallar√° cada vez.  Y surgir√° en escenarios bastante importantes, por ejemplo, cuando ambos conjuntos son id√©nticos.  Usted, como un tonto, corta c√≠rculos con b√∫squeda binaria, mientras que solo ten√≠a que pasar por el primer algoritmo lineal.  ¬øPor qu√© la b√∫squeda binaria, cuando el elemento deseado - cada vez aqu√≠, el primero en la lista? <br><br>  ¬øC√≥mo hacer que el algoritmo funcione con √©xito en datos id√©nticos y diferentes?  Verificar todos los datos ser√° demasiado costoso para los recursos.  Har√© una reserva de que no se trata de datos completamente id√©nticos, sino de datos muy similares, con estad√≠sticas similares, los tama√±os tambi√©n pueden variar.  Puede consultar los siguientes elementos.  La soluci√≥n obvia es reducir su b√∫squeda.  Cuando realizamos una b√∫squeda binaria, luego de haber encontrado alg√∫n elemento, ya no estamos interesados ‚Äã‚Äãen elementos m√°s peque√±os, ya que el segundo vector tambi√©n est√° ordenado.  Por lo tanto, cada vez podemos reducir nuestra √°rea de b√∫squeda, descartando todos los elementos menos del elemento encontrado. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, i2, a2.Length, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == i2) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; a1[i1])) t[i++] = a1[i1]; i2 = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Aqu√≠ est√° la implementaci√≥n de este enfoque.  Ver√° que realizamos una b√∫squeda binaria cada vez de una parte de la matriz original que comienza con `i2 y termina con` a2.length.  Como `i2 aumentar√° con cada b√∫squeda, el √°rea de b√∫squeda se reducir√°. <br><br>  La pr√≥xima optimizaci√≥n que me gustar√≠a implementar aqu√≠ est√° relacionada con el algoritmo de b√∫squeda al galope.  En esencia, esta es una b√∫squeda binaria con un paso diferente.  En el caso de la b√∫squeda binaria, comenzamos cada vez desde el medio, pero pensemos que cuando buscamos un nombre en la gu√≠a telef√≥nica, ¬øno lo abrimos en el medio?  Si el apellido de una persona comienza, digamos, en "B", abriremos el libro m√°s cerca del principio.  Este principio se implementa en una b√∫squeda galopante: comenzamos a rastrear los datos en la direcci√≥n ascendente con un paso que aumenta exponencialmente despu√©s de cada verificaci√≥n: primero 1, luego 2, luego 4. Esto nos da una buena complejidad algor√≠tmica.  Si el paso creciera linealmente, la complejidad ser√≠a cuadr√°tica.  Cuando "saltamos" el elemento que estamos buscando, realizamos una b√∫squeda binaria normal en el segmento restante, que ser√° peque√±o y no afectar√° significativamente el tiempo de ejecuci√≥n del algoritmo.  Por lo tanto, combinamos todas las ventajas de ambos enfoques.  Implementaci√≥n de tal algoritmo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GBsearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = <span class="hljs-number"><span class="hljs-number">1</span></span>;; step *= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i + step &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, J, v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i + step] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + step, v); i += step + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Ahora discutimos la escala, es decir, tratamos de encontrar la intersecci√≥n de m√°s de dos conjuntos.  Para cada b√∫squeda de varias palabras, necesitaremos encontrar la intersecci√≥n de varios conjuntos.  Para hacer esto, podemos, por ejemplo, comparar los dos primeros conjuntos, luego su intersecci√≥n con el tercero y as√≠ sucesivamente.  Pero esta no es una soluci√≥n √≥ptima.  Necesitamos tomar los primeros elementos de todos los conjuntos y encontrar el m√°s peque√±o de ellos, que luego ser√° necesario mover.  Necesitamos una estructura de datos que nos permita encontrar el m√°s peque√±o de los muchos elementos y que tenga una complejidad constante.  Tal estructura de datos es un mont√≥n.  Pero ser√° un grupo extra√±o, no se basar√° en una matriz f√≠sica.  Ser√° imaginario, organizaremos en √©l solo los primeros elementos de nuestros conjuntos.  Una vez que encontramos el elemento m√°s peque√±o en el mont√≥n, a√∫n podemos buscar todos los dem√°s conjuntos. <br><br>  Trabajar en los temas que estamos discutiendo en la pr√°ctica hoy tiene una forma bastante artesanal.  En la pr√°ctica, a menudo tendremos varios conjuntos, no solo dos, y se ha escrito mucho sobre este tema.  El algoritmo cl√°sico aqu√≠ es SVS, en el que agrupamos los conjuntos, tomamos los dos m√°s peque√±os y elegimos el m√°s corto como candidato.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puede encontrar una buena descripci√≥n general sobre este tema.  Los problemas asociados con los conjuntos de intersecci√≥n, el producto escalar de vectores dispersos, la ordenaci√≥n por fusi√≥n, cualquier forma de comparaci√≥n con la imagen a lo largo del tiempo son cada vez m√°s interesantes.  El algoritmo que te mostr√© se ha establecido como muy √∫til.  Gracias por su atencion <br><br><blockquote>  Andrei Alexandrescu no vendr√° a DotNext 2018 Mosc√∫, pero Jeffrey Richter, Greg Young, Pavel Yosifovich y otros estar√°n all√≠.  Los nombres de los oradores y los temas de los informes se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , y las entradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  √önete ahora! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425191/">https://habr.com/ru/post/es425191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425175/index.html">Un poco sobre las tarjetas de sonido con sintetizadores FM OPL2 / 3 para PC ...</a></li>
<li><a href="../es425177/index.html">Aprenda t√°cticas adversas, t√©cnicas y conocimientos comunes (ATT @ CK). T√°cticas empresariales. Parte 3</a></li>
<li><a href="../es425179/index.html">Las estrellas de YouTube comienzan a agotarse en el trabajo: "el atractivo de los trabajos m√°s interesantes se ha desvanecido"</a></li>
<li><a href="../es425181/index.html">Frankie Zapata para The Verge: "El combustible turborreactor ayudar√° a derretir el escepticismo del hormig√≥n armado"</a></li>
<li><a href="../es425187/index.html">Intel PAC con FPGA Stratix 10 SX: acelerador para tareas grandes</a></li>
<li><a href="../es425195/index.html">Las listas negras, blancas y grises protegen la seguridad empresarial</a></li>
<li><a href="../es425197/index.html">Estimaci√≥n de costos de un proyecto de implementaci√≥n de IdM: c√≥mo prever sorpresas</a></li>
<li><a href="../es425199/index.html">Lo que protege a los compradores del fraude de pagos sin contacto</a></li>
<li><a href="../es425201/index.html">"He estado luchando contra el s√≠ndrome del impostor durante tres a√±os" - 10 preguntas para un programador, n√∫mero 7</a></li>
<li><a href="../es425203/index.html">Antigua vulnerabilidad UPnP de una nueva manera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>