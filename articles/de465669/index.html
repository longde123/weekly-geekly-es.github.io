<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüé§ üç∞ ü§∏üèº Z√§hlen der Download-Geschwindigkeit in Ihrer Anwendung ü§¶üèø ‚õπüèΩ üçî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 


 Ich habe ein kleines und gem√ºtliches Haustierprojekt, mit dem Sie Dateien aus dem Internet herunterladen k√∂nnen. Die Dateien sind zusa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Z√§hlen der Download-Geschwindigkeit in Ihrer Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465669/"><h2 id="predystoriya">  Hintergrund </h2><br><p>  Ich habe ein kleines und gem√ºtliches Haustierprojekt, mit dem Sie Dateien aus dem Internet herunterladen k√∂nnen.  Die Dateien sind zusammen gruppiert und dem Benutzer wird nicht jede Datei angezeigt, sondern eine Gruppierung.  Der gesamte Download-Prozess (und die Anzeige dieses Prozesses) war stark von den Daten abh√§ngig.  Die Daten wurden im laufenden Betrieb erhalten, d.h.  Der Benutzer beginnt mit dem Download und es gibt keine Informationen dar√ºber, wie viel Sie in der Realit√§t herunterladen m√ºssen. </p><br><p>  Die naive Implementierung von mindestens einer Art von Information wird vereinfacht - der Download-Fortschritt wird als Verh√§ltnis der Anzahl der heruntergeladenen zur Gesamtzahl angezeigt.  Es gibt nicht viele Informationen f√ºr den Benutzer - nur einen kriechenden Streifen, aber dies ist besser als nichts und es ist merklich besser als der derzeit beliebte Lademechanismus, ohne den Fortschritt anzuzeigen. </p><br><p>  Und hier erscheint ein Benutzer mit einem logischen Problem - in einer gro√üen Gruppe ist nicht klar, warum der Fortschritt kaum schleicht - m√ºssen Sie viele Dateien oder eine niedrige Geschwindigkeit herunterladen?  Wie oben erw√§hnt - die Anzahl der Dateien ist nicht im Voraus bekannt.  Deshalb habe ich beschlossen, einen Geschwindigkeitsz√§hler hinzuzuf√ºgen. </p><br><h2 id="analiz">  Analyse </h2><br><p>  Es ist empfehlenswert, diejenigen zu sehen, die bereits ein √§hnliches Problem gel√∂st haben, um das Rad nicht neu zu erfinden.  Unterschiedliche Software schlie√üt diese unterschiedlichen Aufgaben, aber die Anzeige sieht ziemlich gleich aus: </p><br><div class="scrollable-table"><table><thead><tr><th>  uTorrent </th><th>  Downloadmaster </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/webt/gb/af/1o/gbaf1ooewqcrbnsuyafn1dyxzvk.png" alt="uTorrent"></td><td><img src="https://habrastorage.org/webt/qg/mc/fa/qgmcfangfeegvjjtkcy6w-vloxe.png" alt="Downloadmaster"></td></tr></tbody></table></div><br><p>  Der entscheidende Punkt, den ich f√ºr mich selbst identifiziert habe, ist, dass zum aktuellen Zeitpunkt die erste Anzeige der Geschwindigkeit erforderlich ist.  Nicht welche Geschwindigkeit durchschnittlich war, nicht welche Geschwindigkeit insgesamt von Anfang an durchschnittlich war, n√§mlich was diese Zahl im aktuellen Moment ist.  In der Tat ist dies wichtig, wenn ich zum Code komme - ich werde es separat erkl√§ren. </p><br><p> Wir brauchen also eine einfache Ziffer wie <code>10 MB/s</code> oder so √§hnlich.  Wie berechnen wir das? </p><a name="habracut"></a><br><h2 id="teoriya-i-praktika">  Theorie und Praxis </h2><br><p>  Die vorhandene Download-Implementierung verwendete <code>HttpWebRequest</code> und ich entschied mich, den Download selbst nicht zu wiederholen - ber√ºhren Sie nicht den Arbeitsmechanismus. </p><br><p>  Also die erste Implementierung ohne Berechnung: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = WebRequest.Create(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.GetResponseAsync(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.GetResponseStream().CopyToAsync(ms); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms.ToArray(); }</code> </pre> <br><p>  Auf der Ebene einer solchen API k√∂nnen Sie nur auf einen vollst√§ndigen Download einer Datei reagieren. F√ºr kleine Gruppen (oder sogar f√ºr eine einzelne Datei) k√∂nnen Sie die Geschwindigkeit nicht berechnen.  Wir folgen dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CopyToAsync-Quellcode</a> und kopieren die einfache Logik von dort: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[bufferSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length, cancellationToken).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> destination.WriteAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytesRead, cancellationToken).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Jetzt k√∂nnen wir auf jeden Puffer reagieren, der uns √ºber das Netzwerk zur Verf√ºgung gestellt wird. </p><br><p>  Also, zuerst, was wir anstelle des Boxed CopyToAsync tun: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]&gt; GetBytesAsync(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Stream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">81920</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> memory.WriteAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytesRead).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); NetworkSpeed.AddInfo(bytesRead); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory.ToArray(); } }</code> </pre> <br><p>  Das einzige, was wirklich hinzugef√ºgt wurde, ist <code>NetworkSpeed.AddInfo</code> .  Und das einzige, was wir √ºbertragen, ist die Anzahl der heruntergeladenen Bytes. </p><br><p>  Der Code selbst zum Herunterladen sieht folgenderma√üen aus: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = WebRequest.Create(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.GetResponseAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.GetResponseStream().GetBytesAsync();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Option f√ºr WebClient</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastRecorded = <span class="hljs-number"><span class="hljs-number">0L</span></span>; client.DownloadProgressChanged += (sender, eventArgs) =&gt; { NetworkSpeed.AddInfo(eventArgs.BytesReceived - lastRecorded); lastRecorded = eventArgs.BytesReceived; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.DownloadDataTaskAsync(uri);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Option f√ºr HttpClient</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetStreamAsync(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> content.GetBytesAsync();</code> </pre> </div></div><br><p>  Nun, das halbe Problem ist gel√∂st - wir wissen, <em>wie viel</em> wir heruntergeladen haben.  Wir wenden uns der Geschwindigkeit zu. </p><br><p>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> : </p><br><blockquote>  Daten√ºbertragungsrate - Die pro Zeiteinheit √ºbertragene Datenmenge. </blockquote><br><h3 id="pervyy-naivnyy-podhod">  Erster naiver Ansatz </h3><br><p>  Wir haben ein Volumen.  Die Zeit kann buchst√§blich vom Start genommen werden und den Unterschied mit <code>DateTime.Now</code> .  Nehmen und teilen? <br>  F√ºr Konsolendienstprogramme wie <strong>Curl ist</strong> dies m√∂glich und sinnvoll. <br>  Wenn Ihre Anwendung jedoch etwas komplizierter ist, wird die Pause-Taste Ihr Leben buchst√§blich erheblich verkomplizieren. </p><br><p>  <strong><em>Ein wenig √ºber die Pause</em></strong> <br>  Vielleicht bin ich sehr naiv, oder vielleicht ist die Frage wirklich nicht so einfach - aber die Pause l√§sst mich st√§ndig nachdenken.  Eine Pause beim Herunterladen kann sich auf mindestens drei Arten verhalten: </p><br><ul><li>  Datei-Upload unterbrechen, danach erneut starten </li><li>  Laden Sie die Datei einfach nicht weiter herunter und hoffen Sie, dass der Server danach fortgesetzt wird </li><li>  Laden Sie bereits gestartete Dateien herunter, laden Sie keine neuen herunter, laden Sie danach neue herunter </li></ul><br><p>  Da die ersten beiden zum Verlust bereits heruntergeladener Informationen f√ºhren, verwende ich die dritte. <br>  Etwas h√∂her bemerkte ich, dass Geschwindigkeit genau zu einem bestimmten Zeitpunkt ben√∂tigt wird.  Eine Pause erschwert diese Angelegenheit: </p><br><ul><li>  Sie k√∂nnen die Durchschnittsgeschwindigkeit nicht richtig berechnen, indem Sie nur die Lautst√§rke f√ºr eine Weile messen </li><li>  Eine Pause kann externe Gr√ºnde haben, die die Geschwindigkeit und den Kanal √§ndern (erneutes Verbinden mit dem Netzwerk des Anbieters, Umschalten auf VPN, Beenden von uTorrent, das den gesamten Kanal beansprucht), was zu einer √Ñnderung der tats√§chlichen Geschwindigkeit f√ºhrt <br>  Tats√§chlich unterteilt eine Pause alle Indikatoren in vorher und nachher.  Dies wirkt sich nicht besonders auf den folgenden Code aus, nur eine Minute lustiger Informationen zum Nachdenken. </li></ul><br><h3 id="vtoroy-naivnyy-podhod">  Zweiter naiver Ansatz </h3><br><p>  F√ºgen Sie einen Timer hinzu.  Der Timer erfasst in jedem Zeitraum die neuesten Informationen zum heruntergeladenen Volume und berechnet die Geschwindigkeitsanzeige neu.  Wenn Sie den Timer pro Sekunde einstellen, entsprechen alle f√ºr diese Sekunde empfangenen Informationen √ºber das heruntergeladene Volume der Geschwindigkeit f√ºr diese Sekunde: </p><br><div class="spoiler">  <b class="spoiler_title">Die gesamte Implementierung der NetworkSpeed-Klasse</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NetworkSpeed</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> TotalSpeed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> totalSpeed; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> TimerInterval = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Timer speedTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(state =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> now = <span class="hljs-number"><span class="hljs-number">0L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> added)) now += added; totalSpeed = now; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TimerInterval); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; ReceivedStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> received</span></span></span><span class="hljs-function">)</span></span> { ReceivedStorage.Enqueue(received); } }</code> </pre> </div></div><br><p>  Im Vergleich zur ersten Option reagiert eine solche Implementierung auf eine Pause - die Geschwindigkeit sinkt in der n√§chsten Sekunde auf 0, nachdem die externen Daten eingetroffen sind. <br>  Es gibt aber auch Nachteile.  Wir arbeiten mit einem Puffer von 80 KB, was bedeutet, dass der in einer Sekunde gestartete Download erst in der n√§chsten angezeigt wird.  Und bei einem gro√üen Strom paralleler Downloads zeigen solche Messfehler alles an - ich hatte einen Spread von bis zu 30% der reellen Zahlen.  Ich h√§tte es vielleicht nicht bemerkt, aber mehr als 100 Mbit sahen <em>zu verd√§chtig aus</em> . </p><br><h3 id="tretiy-podhod">  Dritter Ansatz </h3><br><p>  Die zweite Option ist bereits nah genug an der Wahrheit, und sein Fehler wurde zu Beginn des Downloads und nicht w√§hrend des gesamten Lebenszyklus h√§ufiger beobachtet. <br>  Eine einfache L√∂sung besteht daher darin, nicht die Zahl pro Sekunde, sondern den Durchschnitt der letzten drei Sekunden als Indikator zu verwenden.  Drei hier ist eine magische Konstante, die mit dem Auge √ºbereinstimmt.  Einerseits wollte ich eine angenehme Darstellung des Wachstums und des R√ºckgangs der Geschwindigkeit, andererseits - damit die Geschwindigkeit n√§her an der Wahrheit lag. </p><br><p>  Die Implementierung ist etwas kompliziert, aber im Allgemeinen nichts dergleichen: </p><br><div class="spoiler">  <b class="spoiler_title">Die gesamte Implementierung der NetworkSpeed-Klasse</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NetworkSpeed</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> TotalSpeed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> totalSpeed; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Seconds = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> TimerInterval = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Timer speedTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(state =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> now = <span class="hljs-number"><span class="hljs-number">0L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> added)) now += added; LastSpeeds.Enqueue(now); totalSpeed = LastSpeeds.Average(); OnUpdated(totalSpeed); }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TimerInterval); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LimitedConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; LastSpeeds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitedConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(Seconds); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; ReceivedStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LastSpeeds.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> received</span></span></span><span class="hljs-function">)</span></span> { ReceivedStorage.Enqueue(received); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; Updated; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LimitedConcurrentQueue</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ConcurrentQueue</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Limit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Count &gt;= Limit) TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enqueue(item); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LimitedConcurrentQueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit</span></span></span><span class="hljs-function">)</span></span> { Limit = limit; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { Updated?.Invoke(obj); } }</code> </pre> </div></div><br><p>  Ein paar Punkte: </p><br><ul><li>  Zum Zeitpunkt der Implementierung habe ich die fertige Warteschlange mit einer Begrenzung der Anzahl der Elemente nicht gefunden und im Internet verwendet. Im obigen Code ist sie <code>LimitedConcurrentQueue</code> . </li><li>  Anstatt <code>INotifyPropertyChanged</code> aus irgendeinem Grund zu implementieren, ist die Verwendung praktisch dieselbe. Ich erinnere mich nicht an die Gr√ºnde.  Die Logik ist einfach - der Indikator √§ndert sich, Benutzer m√ºssen dar√ºber informiert werden.  Die Implementierung kann eine beliebige sein, auch <code>IObservable</code> , f√ºr die sie bequemer ist. </li></ul><br><h2 id="i-nemnogo-chitabelnosti">  Und ein bisschen Lesbarkeit </h2><br><p>  Die API gibt die Geschwindigkeit in Bytes an. F√ºr die Lesbarkeit ist eine einfache (im Internet verwendete) n√ºtzlich </p><br><div class="spoiler">  <b class="spoiler_title">Konverter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HumanizeByteSize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteCount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] suf = { <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"KB"</span></span>, <span class="hljs-string"><span class="hljs-string">"MB"</span></span>, <span class="hljs-string"><span class="hljs-string">"GB"</span></span>, <span class="hljs-string"><span class="hljs-string">"TB"</span></span>, <span class="hljs-string"><span class="hljs-string">"PB"</span></span>, <span class="hljs-string"><span class="hljs-string">"EB"</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//Longs run out around EB if (byteCount == 0) return "0" + suf[0]; long bytes = Math.Abs(byteCount); int place = Convert.ToInt32(Math.Floor(Math.Log(bytes, 1024))); double num = Math.Round(bytes / Math.Pow(1024, place), 1); return Math.Sign(byteCount) * num + suf[place]; } public static string HumanizeByteSize(this double byteCount) { if (double.IsNaN(byteCount) || double.IsInfinity(byteCount) || byteCount == 0) return string.Empty; return HumanizeByteSize((long)byteCount); }</span></span></code> </pre> </div></div><br><p>  Ich m√∂chte Sie daran erinnern, dass die Geschwindigkeit in Bytes, d. H.  pro 100mbit Kanal sollte nicht mehr als 12,5MB ausgeben. </p><br><p>  Wie es letztendlich aussieht: </p><br><div class="spoiler">  <b class="spoiler_title">Laden Sie das Ubuntu-Bild herunter</b> <div class="spoiler_text"><blockquote>  Aktuelle Geschwindigkeit 904,5 KB / s <br>  Aktuelle Geschwindigkeit 1,8 MB / s <br>  Aktuelle Geschwindigkeit 2,9 MB / s <br>  Aktuelle Geschwindigkeit 3,2 MB / s <br>  Aktuelle Geschwindigkeit 2,9 MB / s <br>  Aktuelle Geschwindigkeit 2,8 MB / s <br>  Aktuelle Geschwindigkeit 3MB / s <br>  Aktuelle Geschwindigkeit 3,1 MB / s <br>  Aktuelle Geschwindigkeit 3,2 MB / s <br>  Aktuelle Geschwindigkeit 3,3 MB / s <br>  Aktuelle Geschwindigkeit 3,5 MB / s <br>  Aktuelle Geschwindigkeit 3,6 MB / s <br>  Aktuelle Geschwindigkeit 3,6 MB / s <br>  Aktuelle Geschwindigkeit 3,6 MB / s <br>  ... </blockquote></div></div><br><div class="spoiler">  <b class="spoiler_title">Nun, mehrere Bilder gleichzeitig</b> <div class="spoiler_text"><blockquote>  Aktuelle Geschwindigkeit 1,2 MB / s <br>  Aktuelle Geschwindigkeit 3,8 MB / s <br>  Aktuelle Geschwindigkeit 7,3 MB / s <br>  Aktuelle Geschwindigkeit 10MB / s <br>  Aktuelle Geschwindigkeit 10,3 MB / s <br>  Aktuelle Geschwindigkeit 10MB / s <br>  Aktuelle Geschwindigkeit 9,7 MB / s <br>  Aktuelle Geschwindigkeit 9,8 MB / s <br>  Aktuelle Geschwindigkeit 10,1 MB / s <br>  Aktuelle Geschwindigkeit 9,8 MB / s <br>  Aktuelle Geschwindigkeit 9,1 MB / s <br>  Aktuelle Geschwindigkeit 8,6 MB / s <br>  Aktuelle Geschwindigkeit 8,4 MB / s <br>  ... </blockquote></div></div><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Es war interessant, sich mit einer scheinbar banalen Aufgabe zu befassen, Geschwindigkeit zu z√§hlen.  Und obwohl der Code funktioniert und einige Zahlen herausgibt, m√∂chte ich Kritikern zuh√∂ren - was ich vermisst habe, wie k√∂nnte ich es besser machen, vielleicht gibt es einige vorgefertigte L√∂sungen. </p><br><p>  Ich m√∂chte mich bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stack Overflow auf Russisch</a> und speziell bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">VladD-exrabbit bedanken</a> - obwohl eine gute Frage die H√§lfte der Antwort enth√§lt, bringen Sie alle Hinweise und jede Hilfe immer weiter. </p><br><p>  Ich m√∂chte Sie daran erinnern, dass dies ein Haustierprojekt ist - deshalb ist die Klasse statisch und √ºberhaupt eine, daher ist die Genauigkeit nicht wirklich.  Ich sehe viele kleine Dinge, die besser gemacht werden k√∂nnten, aber ... es gibt immer etwas anderes zu tun, also denke ich, dass dies die Geschwindigkeit ist und ich denke, dass dies keine schlechte Option ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465669/">https://habr.com/ru/post/de465669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465657/index.html">Parkinson-Gesetz: Sie k√∂nnen es schlagen</a></li>
<li><a href="../de465659/index.html">Antwort auf den Artikel ‚ÄûDie Eroberung Sibiriens durch die Moskauer‚Äú oder 20 Jahre sp√§ter</a></li>
<li><a href="../de465661/index.html">Hast du auch so einen Freund? Oder bist du es vielleicht?</a></li>
<li><a href="../de465663/index.html">Superjob API FAQ (Stellenausschreibung)</a></li>
<li><a href="../de465667/index.html">Spring Cache: Vom Verbindungs-Caching in 1 Minute bis zur flexiblen Konfiguration des Cache-Managers</a></li>
<li><a href="../de465673/index.html">Hedi Lamarr: Erfinder aus Hollywood</a></li>
<li><a href="../de465675/index.html">Wie sich die NASA um die Sicherheit und Intelligenz ihrer Astronauten k√ºmmert</a></li>
<li><a href="../de465677/index.html">Vergessen Sie den Walkman: Es geht nur um die Kopfh√∂rer</a></li>
<li><a href="../de465679/index.html">Was kann eine Uhr neben der Zeitanzeige tun und wie w√§hlt man die erste Uhr aus?</a></li>
<li><a href="../de465681/index.html">Wie das Knistern eines Feuers werden das Knarren von T√ºren und das gew√∂hnlichste Ger√§usch zu Musik und fallen in elektroakustische Spuren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>