<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêé üé± üñ®Ô∏è Textur-Einr√ºckungspixel üé∑ ü§±üèæ üêÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung in den vierten Artikel unserer Reihe zur Arbeit mit 3D-Modellen in Unity. Fr√ºhere Artikel: ‚ÄûFunktionen f√ºr die Arbeit mit Mesh in Unity‚Äú , ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Textur-Einr√ºckungspixel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/451794/">  <i>Einf√ºhrung in den vierten Artikel unserer Reihe zur Arbeit mit 3D-Modellen in Unity.</i>  <i>Fr√ºhere Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûFunktionen f√ºr die Arbeit mit Mesh in Unity‚Äú</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûUnity: prozedurale Bearbeitung von Mesh‚Äú</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûImport von 3D-Modellen in Unity und Fallstricke‚Äú</a> .</i> <br><br>  Im vorherigen Artikel haben wir erw√§hnt, dass der Textur-Scan auf die Angemessenheit der Pixeleinr√ºckung bei einer bestimmten Texturaufl√∂sung √ºberpr√ºft wird.  In dieser Ver√∂ffentlichung beschreiben wir das Wesentliche des Problems bei der Beobachtung der Pixeleinr√ºckung und den Algorithmus f√ºr deren Verfolgung.  Es wird nicht als Code betrachtet, sondern genau das Prinzip, das in jeder Sprache und in jeder Entwicklungsumgebung implementiert werden kann. <br><br><img src="https://habrastorage.org/webt/u_/fw/mc/u_fwmclibgkemvxya6u_lsd8tqu.jpeg"><a name="habracut"></a><br><br><h3>  Problem </h3><br>  Eine Bestellung f√ºr ein 3D-Modell wird normalerweise von einer Anforderung an die Texturaufl√∂sung begleitet.  Aufgrund der diskreten Natur des Rasterbilds muss der 3D-K√ºnstler die Einr√ºckung in Pixel zwischen Teilen des Textur-Scans beobachten.  Das Fehlen der erforderlichen Einr√ºckung f√ºhrt dazu, dass dasselbe Pixel auf dem Modell an v√∂llig unterschiedlichen Stellen angezeigt wird, wenn es nicht ben√∂tigt wird. <br><br>  Es ist besonders wichtig, in den fr√ºhen Arbeitsphasen eine ausreichende Einr√ºckung zu verfolgen.  Am h√§ufigsten besch√§ftigen sich einige Personen mit der Erstellung von Geometrie, einschlie√ülich eines Textur-Scans, und andere mit dem Zeichnen von Texturen.  Der vom 3D-K√ºnstler erkannte Fehler verursacht weniger Probleme als der, den der Texturdesigner findet.  Im letzteren Fall wird die Situation noch komplizierter, wenn das verwendete 3D-Paket keine Werkzeuge zum Zeichnen √ºber Geometrie bereitstellt (z. B. einen Pinsel). <br><br>  Sie sollten auch zwei Nuancen ber√ºcksichtigen, aufgrund derer zwischen den Elementen des Sweeps m√∂glicherweise mehr Platz ben√∂tigt wird.  Die erste ist eine Verringerung der Texturaufl√∂sung w√§hrend des Mipmappings.  Das zweite ist die Verwendung eines <b>Dilatationsfilters</b> beim Erstellen <b>einer Beleuchtungskarte</b> .  Bei der Erstellung eines <b>UV-</b> Scans muss sich ein 3D-K√ºnstler an den Anforderungen f√ºr die Texturaufl√∂sung orientieren und auch die oben aufgef√ºhrten Nuancen ber√ºcksichtigen.  Trotzdem k√∂nnen viele M√§ngel ohne automatische √úberpr√ºfung einfach nicht bemerkt werden. <br><br><img src="https://habrastorage.org/webt/lv/s4/xf/lvs4xfanesl_qwgtr07wluk595a.jpeg"><br>  <i>Ein Beispiel f√ºr das Auftreten von Artefakten mit einer Abnahme der Details</i> <br><br>  F√ºr einfache Modelle kann ein Textur-Scan mit automatischen Werkzeugen erstellt werden.  Sie basieren jedoch auf internen Metriken und ber√ºcksichtigen keine Pixeleinr√ºckungen. Daher befinden sich gemeinsam genutzte Pixel h√§ufig entlang diagonaler R√§nder.  Das √úberpr√ºfen mit Checker-Texturen zeigt nicht alle Fehler an. Au√üerdem haben diese Texturen h√§ufig eine h√∂here Aufl√∂sung als die im Projekt verwendeten. <br><br><img src="https://habrastorage.org/webt/mt/eb/8m/mteb8mngbtpsqlng-3b2l0wcmna.jpeg"><br>  <i>Gemeinsame Pixel</i> <br><br>  Das Problem einer unzureichenden Pixeleinr√ºckung im <b>UV-</b> Scan √§hnelt dem Problem mit √úberlagerungen.  In beiden F√§llen kann es zu sogenannten <b>Blutungen</b> kommen - im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel haben</a> wir beschrieben, welche Artefakte dadurch entstehen. <br><br>  Das Problem mit der Pixeleinr√ºckung h√§ngt jedoch von der Mindestanforderung an die Texturaufl√∂sung ab.  Eine einzige √úberpr√ºfung reicht aus, um die √úberlagerungen zu bestimmen, w√§hrend sich die Anforderungen an die Texturaufl√∂sung in der n√§chsten Entwicklungsstufe √§ndern k√∂nnen.  Die Situation wird durch die Tatsache kompliziert, dass die von uns verwendeten 3D-Pakete keine Tools zum automatischen Erkennen von Fehlern in Bezug auf die N√§he von Teilen des <b>UV-</b> Scans enthalten.  Und vergessen Sie nicht, dass Sie nach dem Betrieb des automatischen Shapers in <b>Unity</b> noch <b>UV2</b> √ºberpr√ºfen <b>m√ºssen</b> . <br><br>  Wir haben uns entschlossen, ein Tool zu erstellen, mit dem Einr√ºckungen in Pixel √ºberpr√ºft und die Stellen potenzieller L√ºcken im Modell markiert werden k√∂nnen.  Die Anforderungen an die Einr√ºckung werden anhand der folgenden Parameter ermittelt: <br><br><ol><li>  Die Basisaufl√∂sung der Textur. </li><li>  Die minimale Aufl√∂sung der Textur, bei der das Flie√üen nicht zul√§ssig ist. </li><li>  Die erforderliche Einr√ºckung auf die minimale Textur. </li></ol><br>  Da die Gr√∂√üe der von uns verwendeten Texturen gleich Zweierpotenzen ist, ist die Formel zur Berechnung der erforderlichen Einr√ºckung bei der Grundaufl√∂sung recht einfach: (Grundaufl√∂sung / Mindestaufl√∂sung) * Einzug in die MinTexture. <br><br>  Offensichtlich h√§ngt die L√∂sung dieses Problems eng mit der Rasterung zusammen.  F√ºr eine klarere Angabe der Anforderungen und die Entwicklung eines Algorithmus f√ºhren wir verschiedene Konzepte ein. <br><br><h3>  Schl√ºsselkonzepte </h3><br>  Betrachten Sie einen <b>UV-</b> Raum und ein einheitliches Gitter mit der Dimension NxM im Bereich von 0,0 bis 1,0.  Zellen mit einer Breite von 1 / N und einer H√∂he von 1 / M bilden eine Aufteilung des <b>UV-</b> Raums. <br><br><img src="https://habrastorage.org/webt/ue/rg/dg/uergdgc7zyh8upqr6g7dylw85r8.jpeg"><br>  <i>NxM-Aufteilung des <b>UV-</b> Raums</i> <br><br>  Wir nehmen zwei beliebige Punkte und bezeichnen Dn als die Anzahl der Pixel, die von der Projektion auf die U-Achse des Segments, das die gegebenen Punkte verbindet, belegt werden.  In √§hnlicher Weise Dm f√ºr die V-Achse. Dann definieren wir den <b>Pixelabstand</b> als das Maximum zwischen Dn und Dm. <br><br><img src="https://habrastorage.org/webt/cp/an/su/cpansumym7jr8f9vw-vi0w6iyj8.jpeg"><br>  <i>Pixelabstand</i> <br><br>  Es ist zu beachten, dass im euklidischen Raum Bewegungsoperationen wie parallele Translation und Rotation keine Bewegungen f√ºr das Netz sind, wenn der <b>Pixelabstand</b> als Metrik verwendet wird.  Diese Nuance hat die Entwicklung unserer L√∂sung etwas erschwert. <br><br><img src="https://habrastorage.org/webt/it/j-/ad/itj-adzmk_tujolsfcrwvhd2nqc.jpeg"><br><br>  Wir nennen ein Quadrat mit einer Seite in K Pixeln den <b>Kern von K.</b>  Dann k√∂nnen zwei beliebige Punkte mit einem <b>Pixelabstand von</b> weniger als K von einem Kernel von K abgedeckt werden. <br><br><img src="https://habrastorage.org/webt/gs/gu/jt/gsgujtv5gbm9o07j7itsrsz4dzo.jpeg"><br>  <i>Beispiele f√ºr Kerne unterschiedlicher Gr√∂√üe</i> <br><br>  Zwei Kanten des Polygons bilden eine <b>Konkavit√§t der Kontur,</b> wenn ihr Mittelpunkt (der Schwerpunkt an vier Eckpunkten) links von diesen Kanten liegt, wenn die Kontur im Uhrzeigersinn umrundet wird.  Bei einer Durchquerung gegen den Uhrzeigersinn muss ein Punkt rechts von den Kanten gefunden werden. <br><br><img src="https://habrastorage.org/webt/di/3m/ye/di3myeeyussyylggsz0bnmdosbm.jpeg"><br>  <i>Ein Paar Rippen, die eine Konkavit√§t der Kontur bilden</i> <br><br><h3>  L√∂sung </h3><br>  Lassen Sie uns nun direkt √ºber das √úberpr√ºfen der Pixeleinr√ºckung sprechen.  Um dies zu implementieren, haben wir einen Algorithmus entwickelt, der aus drei unabh√§ngigen Fragmenten besteht.  Die Reihenfolge der Ausf√ºhrung ist nicht wichtig.  Das Ergebnis jedes der Fragmente ist die NxM-Matrix, die ein Puffer der Zellen der Partition ist, in der einige Zellen markiert sind.  Das Hinzuf√ºgen aller drei Puffer ist das allgemeine Ergebnis. <br><br>  Betrachten Sie zun√§chst das einfachste Snippet.  Es kommt darauf an, Zellen zu finden, die sich in der N√§he von entarteten Dreiecken und Kanten schneiden, deren L√§nge kleiner ist als die Seite des Kerns einer bestimmten Gr√∂√üe.  Alle diese Zellen sind im Puffer markiert. <br><br><img src="https://habrastorage.org/webt/uv/ru/v7/uvruv7eavepfqrtj-kqtah_wy_4.jpeg"><br>  <i>Ergebnis der √úberpr√ºfung der Elementgr√∂√üen</i> <br><br>  Bevor Sie die beiden anderen Fragmente beschreiben, betrachten Sie die allgemeine Logik ihrer Arbeit.  Beide beziehen sich auf die Verarbeitung von Dreiecksclustern, die als <b>Schalen</b> oder Inseln bezeichnet werden.  Shell f√ºr einen 3D-K√ºnstler ist eine zusammenh√§ngende Menge von Polygonen, dh jedes Polygon in dieser Menge hat einen Nachbarn, mit dem es gemeinsame Eckpunkte teilt.  Auch Shell ist ein eigenst√§ndiger √úbungsplatz.  Mit Muschel, Insel und Cluster meinen wir dasselbe. <br><br><img src="https://habrastorage.org/webt/yv/5t/ot/yv5tot5s12wlg7np6lyq6h1196q.jpeg"><br><br>  Um alle Schalen zu finden, verwenden wir den Suchalgorithmus f√ºr alle verbundenen Komponenten des Diagramms, wobei der Scheitelpunkt des Diagramms durch ein Polygon und die Kante durch das Vorhandensein gemeinsamer Scheitelpunkte in einem Paar von Polygonen dargestellt wird.  Da das einzige Polygon in <b>Unity</b> ein Dreieck ist, das durch Scheitelpunktindizes definiert ist, betrachten wir Dreiecke als benachbart, wenn mindestens ein Index des Scheitelpunkts des ersten mit dem Index eines Scheitelpunkts des zweiten √ºbereinstimmt.  Aus der Analogie mit dem Graphen und der Methode zur Bestimmung der Kanten folgt, dass die Menge der Indizes der Eckpunkte eines Clusters die Menge der Eckpunkte des anderen nicht schneidet. <br><br><img src="https://habrastorage.org/webt/ug/lg/t2/uglgt2foiwbustrkinjapehyu2u.jpeg"><br><br>  Mit dem gemeinsamen Teil fertig.  Das zweite Fragment, das wir betrachten werden, bestimmt die Orte potenzieller Fehler, die mit der N√§he oder √úberlappung verschiedener Cluster verbunden sind. <br><br>  Viele Cluster werden der Eingabe in Form von Dreiecks√§tzen im <b>UV-</b> Raum zugef√ºhrt, wobei die Dimension der <b>UV-</b> Aufteilung der Texturaufl√∂sung (NxM) entspricht und der Einr√ºckungswert P die Anzahl der Pixel ist.  F√ºr eine gegebene Partition m√ºssen diejenigen Bereiche gefunden werden, in denen der Abstand in Pixeln zwischen den Clustern kleiner als der erforderliche Einzug ist.  Eine Zelle in der Ergebnismatrix wird markiert, wenn sie in mindestens einen <b>Kern des Werts K = P + 1</b> eintritt, der zwei verschiedene Cluster schneidet. <br><br>  Die Essenz des Fragments ist fast in der Beschreibung des Ergebnisses dargelegt.  Es ist notwendig, alle <b>Kerne der Gr√∂√üe K zu finden</b> , die sich mit Dreiecken aus verschiedenen Schalen schneiden, und dann die Zellen dieser Kerne im Ergebnispuffer zu markieren. <br><br>  In unserer Implementierung werden alle Clusterpaare der Reihe nach ber√ºcksichtigt.  F√ºr jedes Paar wird der Schnittbereich der S√§tze von <b>Kerneln der Gr√∂√üe K bestimmt,</b> die von diesen Clustern abgedeckt werden.  W√§hlen Sie ein Paar und bezeichnen Sie einen Satz als Q. <br><br><img src="https://habrastorage.org/webt/rp/ei/vb/rpeivbpedfexfuvbdsusftpuaha.jpeg"><br><br>  Dann m√ºssen alle Elemente von Q durch das folgende Kriterium √ºberpr√ºft werden: schneidet der gegebene Kernel mindestens ein Dreieck in jedem der Cluster des ausgew√§hlten Paares.  Wenn ja, werden alle Zellen des getesteten Kernels markiert. <br><br><img src="https://habrastorage.org/webt/vz/2q/gt/vz2qgtc62bl_gk99j3b_id2rmj0.jpeg"><br><br>  Der Puffer mit markierten Zellen f√ºr alle Clusterpaare bildet das Ergebnis. <br><br><img src="https://habrastorage.org/webt/mk/cv/h5/mkcvh5g_tms3lmej2cvpere3410.jpeg"><br>  <i>Ergebnis der Clustereinr√ºckung</i> <br><br>  Jetzt werden wir uns mit dem letzten Fragment befassen.  Hier m√ºssen Sie einen Cluster verarbeiten.  Die Eingabe besteht aus einer Reihe von Dreiecken im <b>UV-</b> Raum, der Dimension der <b>UV-</b> Partition entsprechend der Aufl√∂sung der Textur (NxM) und dem Einr√ºckungswert P als Anzahl der Pixel.  Eine Zelle kann in zwei F√§llen markiert werden: Entweder ist der Cluster ung√ºltig oder weist L√∂cher auf, oder der Abstand in Pixel zwischen den Konkavit√§tskanten ist geringer als der erforderliche Einzug. <br><br>  Der innere Teil des Clusters interessiert uns nicht - zun√§chst wird seine Kontur durch eine zusammenh√§ngende Liste von Kanten dargestellt.  Benachbarte Dreiecke duplizieren die Indizes der Scheitelpunkte, sodass die Kante zur Kontur geh√∂rt, wenn ein Paar von Indizes ihrer Scheitelpunkte f√ºr die Menge der Kanten des Clusters eindeutig ist.  Nachdem Sie herausgefunden haben, welche Kanten die Kontur bilden, m√ºssen Sie sie zusammensetzen, damit eine verkn√ºpfte Liste erhalten wird. <br><br>  Wenn nach diesem Schritt nicht alle Kanten der Kontur in die Liste aufgenommen werden, weist der Cluster entweder L√∂cher auf oder es liegt ein Fehler in den Netzdaten vor.  In diesem Fall m√ºssen alle Zellen der vom Cluster geschnittenen Kerne angemessen markiert werden. <br><br>  Wird die Kontur gefunden, wird die Verarbeitung fortgesetzt.  Wir haben die folgende Ergebnisanforderung formuliert.  Lassen Sie das Kantenpaar, das die <b>Konkavit√§t der Kontur bildet,</b> den <b>Kern von K = P + 1</b> schneiden.  Dann m√ºssen die Zellen des Kerns markiert werden, wenn beide Teile der Kontur zwischen den Kanten √ºber diesen Kern hinausgehen. <br><br><img src="https://habrastorage.org/webt/d3/ba/en/d3baeniweyl5_l6uxvougq6__y0.jpeg"><br>  <i>Testergebnis f√ºr Clusterfunktionen</i> <br><br>  Wir haben uns entschlossen, diese Anforderung durch paarweisen Vergleich der Kanten der Kontur umzusetzen.  Wir beginnen mit der Konkavit√§tsbedingung, dann werden f√ºr jedes Paar alle Kernel √ºberpr√ºft, die beide Kanten schneiden.  Um den Kernel zu testen, werden Durchquerungen jedes Teils der Kontur zwischen einem Kantenpaar durchgef√ºhrt.  Wenn jeder Teil mindestens einen Punkt jenseits der Grenzen des Kerns enth√§lt, werden alle Zellen des Kerns markiert. <br><br><img src="https://habrastorage.org/webt/sx/qr/8a/sxqr8aizers5pviq4exzz3sips0.jpeg"><br>  <i>Die Bedingung, unter der die Zellen des √ºberpr√ºften Kernels markiert werden</i> <br><br><h3>  Zusammenfassung </h3><br>  Der obige Algorithmus ist sehr gut f√ºr die Implementierung unter Verwendung von Parallel Computing geeignet.  Die Verarbeitung jedes Paares von Clustern und Kanten erfolgt unabh√§ngig voneinander.  Da die √úberpr√ºfungen auf Rasterung basieren, ist es ratsam, die Funktionen der <b>GPU</b> zu verwenden, wenn Sie die Verarbeitung nicht mit Kantenpaaren, sondern mit Kernen starten. <br><br>  Wir transformieren das Ergebnis des Algorithmus in eine Textur.  Auf diese Weise k√∂nnen Sie bei einer bestimmten Aufl√∂sung die Stellen potenzieller Fehler im <b>UV-</b> Scan grafisch darstellen.  Die resultierende Textur kann auch auf das Modell angewendet werden, um Markierungen direkt auf der Geometrie anzuzeigen. <br><br>  In den folgenden Beispielen haben wir das Kaninchen und Suzanne speziell mit dem automatischen <b>Blender-</b> Werkzeug geschnitten, damit wir mehr Artefakte erhalten.  Die √ºberpr√ºfte Texturaufl√∂sung betr√§gt 256x256, die erforderliche Einr√ºckung ist 1. <br><br>  Blau markierte Zellen bedecken Cluster mit L√∂chern sowie zu kleinen Dreiecken und Kanten.  Gr√ºn zeigt die Zellkerne mit den Eigenschaften jedes Clusters einzeln an.  Kernel, in denen der Einzug zwischen Clustern nicht beobachtet wird, sind rot markiert. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiele</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/no/lc/uinolcm0buuwdwuqbsoufhdkjvw.jpeg"><br><br><img src="https://habrastorage.org/webt/po/up/v_/poupv_vzesyw1jeer6voiu4yens.jpeg"><br></div></div><br>  Im n√§chsten Artikel werden wir einen Algorithmus zur Optimierung von 3D-Modellen in einer Szene betrachten, indem unsichtbare Geometrie entfernt wird.  Bleib bei uns! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451794/">https://habr.com/ru/post/de451794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451782/index.html">Windows Subsystem f√ºr Linux (WSL) Version 2: Wie wird es sein? (FAQ)</a></li>
<li><a href="../de451784/index.html">Hybridlaufwerke f√ºr Enterprise-Speicher. Erfahrung mit Seagate EXOS</a></li>
<li><a href="../de451786/index.html">F√ºhren Sie Instrumententests im Firebase-Testlabor durch. Teil 1: iOS-Projekt</a></li>
<li><a href="../de451790/index.html">Die Gefahren der Datenerfassung im Spiel</a></li>
<li><a href="../de451792/index.html">Vier Javascript-Sniffer, die Sie in Online-Shops fangen</a></li>
<li><a href="../de451796/index.html">Schreiben einer sicheren Browsererweiterung</a></li>
<li><a href="../de451798/index.html">Datenmigration mit mongoDB und Spring Boot</a></li>
<li><a href="../de451800/index.html">Ein einfaches Sonarmodem herstellen</a></li>
<li><a href="../de451802/index.html">Die .Net Community der Raiffeisenbank l√§dt zu UPD mitap Broadcast ein</a></li>
<li><a href="../de451806/index.html">iOS Digest Nr. 5 (27. April - 16. Mai)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>