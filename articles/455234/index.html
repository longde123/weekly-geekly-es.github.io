<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÉ üç† üßìüèø Tipos de referencia anulables en C # 8.0 y an√°lisis est√°tico üöã üë©üèø‚Äçüéì üõë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No es un secreto que Microsoft ha estado trabajando en la octava versi√≥n del lenguaje C # durante bastante tiempo. La nueva versi√≥n del lenguaje (C # ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de referencia anulables en C # 8.0 y an√°lisis est√°tico</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455234/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Cuadro 9"></p><br>  No es un secreto que Microsoft ha estado trabajando en la octava versi√≥n del lenguaje C # durante bastante tiempo.  La nueva versi√≥n del lenguaje (C # 8.0) ya est√° disponible en la versi√≥n reciente de Visual Studio 2019, pero a√∫n est√° en versi√≥n beta.  Esta nueva versi√≥n tendr√° algunas caracter√≠sticas implementadas de una manera algo no obvia, o m√°s bien inesperada.  Los tipos de referencia anulables son uno de ellos.  Esta caracter√≠stica se anuncia como un medio para combatir las Excepciones de referencia nula (NRE). <br><a name="habracut"></a><br>  Es bueno ver evolucionar el lenguaje y adquirir nuevas funciones para ayudar a los desarrolladores.  Por coincidencia, hace alg√∫n tiempo, mejoramos significativamente la capacidad del analizador C # de PVS-Studio para detectar NRE.  Y ahora nos preguntamos si los analizadores est√°ticos en general y PVS-Studio en particular a√∫n deber√≠an molestarse en diagnosticar posibles desreferencias nulas ya que, al menos en el nuevo c√≥digo que har√° uso de Nullable Reference, esas desreferencias ser√°n "imposibles".  Tratemos de aclarar eso. <br><br><h2>  Pros y contras de la nueva caracter√≠stica </h2><br>  Un recordatorio antes de continuar: la √∫ltima versi√≥n beta de C # 8.0, disponible al momento de escribir esta publicaci√≥n, tiene los tipos de referencia anulables deshabilitados de forma predeterminada, es decir, el comportamiento de los tipos de referencia no ha cambiado. <br><br>  Entonces, ¬øqu√© son exactamente los tipos de referencia anulables en C # 8.0 si habilitamos esta opci√≥n?  B√°sicamente son los mismos tipos de referencia antiguos, excepto que ahora tendr√° que agregar '?'  despu√©s del nombre del tipo (por ejemplo, <i>cadena?</i> ), de manera similar a <i>Nullable &lt;T&gt;</i> , es decir, tipos de valores que aceptan valores NULL (por ejemplo, <i>int?</i> ).  Sin el '?', Nuestro tipo de <i>cadena</i> ahora se interpretar√° como referencia no anulable, es decir, un tipo de referencia que no puede asignarse como <i>nulo</i> . <br><br>  La excepci√≥n de referencia nula es una de las excepciones m√°s irritantes para entrar en su programa porque no dice mucho sobre su origen, especialmente si el m√©todo de lanzamiento contiene una serie de operaciones de desreferencia en una fila.  La capacidad de prohibir la asignaci√≥n nula a una variable de un tipo de referencia parece genial, pero ¬øqu√© pasa con los casos en que pasar un <i>nulo</i> a un m√©todo tiene cierta l√≥gica de ejecuci√≥n dependiendo de ello?  En lugar de <i>nulo</i> , podr√≠amos, por supuesto, usar un valor literal, constante o simplemente "imposible" que l√≥gicamente no se puede asignar a la variable en ning√∫n otro lugar.  Pero esto plantea el riesgo de reemplazar un bloqueo del programa con una ejecuci√≥n "silenciosa" pero incorrecta, que a menudo es peor que enfrentar el error de inmediato. <br><br>  ¬øQu√© hay de lanzar una excepci√≥n entonces?  Una excepci√≥n significativa lanzada en un lugar donde algo sali√≥ mal siempre es mejor que una <i>NRE en</i> alg√∫n lugar arriba o abajo de la pila.  Pero solo es bueno en su propio proyecto, donde puede corregir a los consumidores insertando un bloque <i>try-catch</i> y es su exclusiva responsabilidad.  Cuando se desarrolla una biblioteca utilizando (no) referencia anulable, debemos garantizar que un determinado m√©todo siempre devuelva un valor.  Despu√©s de todo, no siempre es posible (o al menos f√°cil), incluso en su propio c√≥digo, reemplazar la devoluci√≥n de <i>nulo</i> con lanzamiento de excepci√≥n (ya que puede afectar demasiado c√≥digo). <br><br>  Nullable Reference puede habilitarse a nivel de proyecto global agregando la propiedad <i>NullableContextOptions</i> con el valor <i>enable,</i> o en el nivel de archivo mediante la directiva de preprocesador: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  La funci√≥n de referencia anulable har√° que los tipos sean m√°s informativos.  La firma del m√©todo le da una pista sobre su comportamiento: si tiene una verificaci√≥n nula o no, si puede devolver <i>nula</i> o no.  Ahora, cuando intente usar una variable de referencia anulable sin verificarla, el compilador emitir√° una advertencia. <br><br>  Esto es bastante conveniente cuando se usan bibliotecas de terceros, pero tambi√©n agrega un riesgo de enga√±ar al usuario de la biblioteca, ya que todav√≠a es posible pasar <i>nulo</i> usando el nuevo operador que perdona nulos (!).  Es decir, agregar solo un signo de exclamaci√≥n puede romper todos los supuestos adicionales sobre la interfaz usando tales variables: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  S√≠, puede argumentar que se trata de una mala programaci√≥n y que nadie escribir√≠a un c√≥digo as√≠ de verdad, pero mientras esto se pueda hacer, no puede sentirse seguro confiando solo en el contrato impuesto por la interfaz de un m√©todo dado ( diciendo que no puede devolver <i>nulo</i> ). <br><br>  Por cierto, ¬°podr√≠as escribir el mismo c√≥digo usando varios <i>!</i>  operadores, ya que C # ahora le permite hacerlo (y dicho c√≥digo es perfectamente compilable): <br><br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Al escribir de esta manera, por as√≠ decirlo, enfatizamos la idea, "¬°mira, esto puede ser <i>nulo</i> !"  (nosotros en nuestro equipo, llamamos a esto programaci√≥n "emocional").  De hecho, al construir el √°rbol de sintaxis, el compilador (de Roslyn) interpreta el <i>!</i>  operador de la misma manera que interpreta los par√©ntesis regulares, lo que significa que puede escribir tantos <i>!</i>  es como quieras, como con par√©ntesis.  Pero si escribe lo suficiente, puede "derribar" el compilador.  Tal vez esto se arregle en la versi√≥n final de C # 8.0. <br><br>  Del mismo modo, puede eludir la advertencia del compilador al acceder a una variable de referencia anulable sin una verificaci√≥n: <br><br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Agreguemos m√°s emociones: <br><br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Sin embargo, casi nunca ver√° una sintaxis como esa en el c√≥digo real.  Al escribir el operador <i>indulgente</i> le decimos al compilador: "Este c√≥digo est√° bien, no es necesario verificarlo".  Al agregar el operador de Elvis, le decimos: ‚ÄúO tal vez no;  vamos a verlo por si acaso ". <br><br>  Ahora, puede preguntarse razonablemente por qu√© todav√≠a puede tener <i>nulo</i> asignado a variables de tipos de referencia no anulables tan f√°cilmente si el concepto mismo de este tipo implica que tales variables no pueden tener el valor <i>nulo</i> .  La respuesta es que "bajo el cap√≥", en el nivel del c√≥digo IL, nuestro tipo de referencia no anulable sigue siendo ... el viejo tipo de referencia "regular", y toda la sintaxis de nulabilidad es en realidad solo una anotaci√≥n para el compilador incorporado analizador (que, creemos, no es muy conveniente de usar, pero lo explicar√© m√°s adelante).  Personalmente, no encontramos una soluci√≥n "ordenada" para incluir la nueva sintaxis como simplemente una anotaci√≥n para una herramienta de terceros (incluso integrada en el compilador) porque el hecho de que esto sea solo una anotaci√≥n puede no ser obvio en absoluto para el programador, ya que esta sintaxis es muy similar a la sintaxis para estructuras anulables pero funciona de una manera totalmente diferente. <br><br>  Volviendo a otras formas de romper los tipos de referencia anulables.  En el momento de escribir este art√≠culo, cuando tiene una soluci√≥n compuesta por varios proyectos, pasando una variable de un tipo de referencia, digamos, <i>Cadena</i> de un m√©todo declarado en un proyecto a un m√©todo en otro proyecto que tiene el <i>NullableContext</i> el compilador asume que se trata de una cadena no anulable y el compilador permanecer√° en silencio.  Y eso a pesar de las toneladas de <i>atributos [Nullable (1)]</i> agregados a cada campo y m√©todo en el c√≥digo IL cuando se habilitan las referencias Nullable <i>.</i>  Estos atributos, por cierto, deben tenerse en cuenta si usa la reflexi√≥n para manejar los atributos y supone que el c√≥digo contiene solo los personalizados. <br><br>  Tal situaci√≥n puede causar problemas adicionales al adaptar una base de c√≥digo grande al estilo de referencia anulable.  Es probable que este proceso se ejecute por un tiempo, proyecto por proyecto.  Si tiene cuidado, por supuesto, puede integrar gradualmente la nueva caracter√≠stica, pero si ya tiene un proyecto en funcionamiento, cualquier cambio en √©l es peligroso e indeseable (si funciona, ¬°no lo toque!).  Es por eso que nos aseguramos de que no tenga que modificar su c√≥digo fuente o marcarlo para detectar <i>NRE</i> potenciales al usar el analizador PVS-Studio.  Para verificar ubicaciones que podr√≠an <i>generar</i> una <i>NullReferenceException,</i> simplemente ejecute el analizador y busque las advertencias V3080.  No es necesario cambiar las propiedades del proyecto o el c√≥digo fuente.  No es necesario agregar directivas, atributos u operadores.  No es necesario cambiar el c√≥digo heredado. <br><br>  Al agregar soporte de referencia anulable a PVS-Studio, tuvimos que decidir si el analizador debe suponer que las variables de tipos de referencia no anulables siempre tienen valores no nulos.  Despu√©s de investigar las formas en que esta garant√≠a podr√≠a romperse, decidimos que PVS-Studio no deber√≠a hacer tal suposici√≥n.  Despu√©s de todo, incluso si un proyecto utiliza tipos de referencia no anulables en todo momento, el analizador podr√≠a agregar a esta caracter√≠stica al detectar esas situaciones espec√≠ficas en las que dichas variables podr√≠an tener el valor <i>nulo</i> . <br><br><h2>  C√≥mo se ve PVS-Studio para excepciones de referencia nula </h2><br>  Los mecanismos de flujo de datos en el analizador C # de PVS-Studio rastrean posibles valores de variables durante el proceso de an√°lisis.  Esto tambi√©n incluye an√°lisis interprocedimiento, es decir, rastrear posibles valores devueltos por un m√©todo y sus m√©todos anidados, y as√≠ sucesivamente.  Adem√°s de eso, PVS-Studio recuerda variables a las que se les puede asignar un valor <i>nulo</i> .  Siempre que vea que dicha variable se desreferencia sin una verificaci√≥n, ya sea en el c√≥digo actual bajo an√°lisis o dentro de un m√©todo invocado en este c√≥digo, emitir√° una advertencia V3080 sobre una posible excepci√≥n de referencia nula. <br><br>  La idea detr√°s de este diagn√≥stico es hacer que el analizador se enoje solo cuando vea una asignaci√≥n <i>nula</i> .  Esta es la principal diferencia entre el comportamiento de nuestro diagn√≥stico y el del analizador integrado del compilador que maneja los tipos de referencia anulables.  El analizador incorporado apuntar√° a todas y cada una de las referencias de una variable de referencia anulable no verificada, dado que no ha sido enga√±ada por el uso de <i>!</i>  operador o incluso simplemente una comprobaci√≥n complicada (sin embargo, debe tenerse en cuenta que absolutamente cualquier analizador est√°tico, PVS-Studio no es una excepci√≥n aqu√≠, puede ser "enga√±ado" de una forma u otra, especialmente si tiene la intenci√≥n de hacerlo). <br><br>  PVS-Studio, por otro lado, solo le advierte si ve un <i>valor nulo</i> (ya sea dentro del contexto local o el contexto de un m√©todo externo).  Incluso si la variable es de un tipo de referencia no anulable, el analizador seguir√° apunt√°ndola si ve una asignaci√≥n <i>nula</i> a esa variable.  Creemos que este enfoque es m√°s apropiado (o al menos m√°s conveniente para el usuario) ya que no exige "difuminar" todo el c√≥digo con comprobaciones nulas para rastrear posibles desreferencias; despu√©s de todo, esta opci√≥n estaba disponible incluso antes de la Referencia Nulable se introdujeron, por ejemplo, mediante el uso de contratos.  Adem√°s, el analizador ahora puede proporcionar un mejor control sobre las variables de referencia no anulables.  Si dicha variable se usa "bastante" y nunca se le asigna <i>nulo</i> , PVS-Studio no dir√° una palabra.  Si la variable se asigna <i>nula</i> y luego se desreferencia sin una verificaci√≥n previa, PVS-Studio emitir√° una advertencia V3080: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br>  Ahora echemos un vistazo a algunos ejemplos que demuestran c√≥mo este diagn√≥stico es activado por el c√≥digo de Roslyn.  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">revisamos este proyecto</a> recientemente, pero esta vez solo veremos las posibles excepciones de referencia nula no mencionadas en los art√≠culos anteriores.  Veremos c√≥mo PVS-Studio detecta los NRE potenciales y c√≥mo se pueden solucionar con la nueva sintaxis de referencia anulable. <br><br>  <i>V3080 [CWE-476] Posible desreferencia nula dentro del m√©todo.</i>  <i>Considere inspeccionar el segundo argumento: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Como puede ver, a la variable <i>chainedTupleType</i> se le puede asignar el valor <i>nulo</i> en una de las ramas de ejecuci√≥n.  Luego se pasa al m√©todo <i>ConstructTupleUnderlyingType</i> y se usa all√≠ despu√©s de una verificaci√≥n <i>Debug.Assert</i> .  Es un patr√≥n muy com√∫n en Roslyn, pero tenga en cuenta que <i>Debug.Assert</i> se elimina en la versi√≥n de lanzamiento.  Es por eso que el analizador todav√≠a considera peligrosa la desreferencia dentro del m√©todo <i>ConstructTupleUnderlyingType</i> .  Aqu√≠ est√° el cuerpo de ese m√©todo, donde tiene lugar la desreferenciaci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  En realidad, es una cuesti√≥n de controversia si el analizador debe tener en cuenta Activos como ese (algunos de nuestros usuarios quieren que lo haga); despu√©s de todo, el analizador toma los contratos de System.Diagnostics.Contracts en cuenta.  Aqu√≠ hay un peque√±o ejemplo de la vida real de nuestra experiencia de usar Roslyn en nuestro propio analizador.  Mientras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregamos compatibilidad con la √∫ltima versi√≥n de Visual Studio</a> recientemente, tambi√©n actualizamos Roslyn a su tercera versi√≥n.  Despu√©s de eso, PVS-Studio comenz√≥ a fallar en cierto c√≥digo que nunca antes se hab√≠a bloqueado.  El bloqueo, acompa√±ado de una excepci√≥n de referencia nula, ocurrir√≠a no en nuestro c√≥digo sino en el c√≥digo de Roslyn.  La depuraci√≥n revel√≥ que el fragmento de c√≥digo donde Roslyn se estaba bloqueando ten√≠a ese tipo de <i>depuraci√≥n.</i> Verificaci√≥n nula basada en <i>Assert</i> varias l√≠neas m√°s arriba, y esa verificaci√≥n obviamente no ayud√≥. <br><br>  Es un ejemplo gr√°fico de c√≥mo puede meterse en problemas con Nullable Reference debido a que el compilador trata <i>Debug.Assert</i> como una verificaci√≥n confiable en cualquier configuraci√≥n.  Es decir, si agrega <i>#nullable enable</i> y marca el argumento <i>chainedTupleTypeOpt</i> como referencia anulable <i>,</i> el compilador no emitir√° ninguna advertencia sobre la desreferencia dentro del m√©todo <i>ConstructTupleUnderlyingType</i> . <br><br>  Pasando a otros ejemplos de advertencias de PVS-Studio. <br><br>  <i>V3080 Posible desreferencia nula.</i>  <i>Considere inspeccionar 'efectivoRuleset'.</i>  <i>RuleSet.cs 146</i> <br><br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Esta advertencia dice que la llamada al m√©todo <i>WithEffectiveAction</i> puede devolver <i>nulo</i> , mientras que el valor de retorno asignado a la variable <i>efectivoRuleset</i> no se verifica antes de su uso ( <i>efectivoRuleset.GeneralDiagnosticOption</i> ).  Aqu√≠ est√° el cuerpo del m√©todo <i>WithEffectiveAction</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  Con Nullable Reference habilitado para el m√©todo <i>GetEffectiveRuleSet</i> , obtendremos dos ubicaciones en las que se debe cambiar el comportamiento del c√≥digo.  Dado que el m√©todo que se muestra arriba puede lanzar una excepci√≥n, es l√≥gico suponer que la llamada est√° envuelta en un bloque <i>try-catch</i> y ser√≠a correcto reescribir el m√©todo para lanzar una excepci√≥n en lugar de devolver <i>nulo</i> .  Sin embargo, si rastrea algunas llamadas, ver√° que el c√≥digo de captura est√° demasiado lejos para predecir de manera confiable las consecuencias.  Echemos un vistazo al consumidor de la variable <i>efectivaRuleset</i> , el m√©todo <i>IsStricterThan</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Como puede ver, es una simple declaraci√≥n de cambio que elige entre dos enumeraciones, con <i>ReportDiagnostic.Default</i> como valor predeterminado.  Por lo tanto, ser√≠a mejor reescribir la llamada de la siguiente manera: <br><br>  La firma de <i>WithEffectiveAction</i> cambiar√°: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  As√≠ se ver√° la llamada: <br><br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  Dado que <i>IsStricterThan</i> solo realiza una comparaci√≥n, la condici√≥n puede reescribirse, por ejemplo, de esta manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Siguiente ejemplo <br><br>  <i>V3080 Posible desreferencia nula.</i>  <i>Considere inspeccionar 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  Para corregir esta advertencia, necesitamos ver qu√© sucede con la variable <i>propertySymbol a</i> continuaci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  El m√©todo <i>GetMemberSymbol</i> tambi√©n puede devolver <i>nulo</i> bajo ciertas condiciones. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Con los tipos de referencia anulables habilitados, la llamada cambiar√° a esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Es bastante f√°cil de arreglar cuando sabes d√≥nde buscar.  El an√°lisis est√°tico puede detectar este error potencial sin esfuerzo al recopilar todos los valores posibles del campo de todas las cadenas de llamadas de procedimiento. <br><br>  <i>V3080 Posible desreferencia nula.</i>  <i>Considere inspeccionar 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  El problema est√° en la l√≠nea con la verificaci√≥n <i>simpleName.Length</i> .  La variable <i>simpleName</i> resulta de ejecutar una larga serie de m√©todos y puede asignarse <i>nulo</i> .  Por cierto, si tiene curiosidad, puede mirar el m√©todo <i>RemoveExtension</i> para ver c√≥mo es diferente de <i>Path.GetFileNameWithoutExtension.</i>  Un <i>simpleName! =</i> Comprobaci√≥n <i>nula</i> ser√≠a suficiente, pero con tipos de referencia no anulables, el c√≥digo cambiar√° a algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  As√≠ es como se ver√≠a la llamada: <br><br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclusi√≥n </h2><br>  Los tipos de referencia anulables pueden ser de gran ayuda cuando se dise√±a arquitectura desde cero, pero la reelaboraci√≥n del c√≥digo existente puede requerir mucho tiempo y cuidado, ya que puede conducir a una serie de errores dif√≠ciles de alcanzar.  Este art√≠culo no tiene como objetivo desalentarlo de usar tipos de referencia anulables.  Consideramos que esta nueva caracter√≠stica generalmente es √∫til, aunque la forma exacta en que se implementa puede ser controvertida. <br><br>  Sin embargo, recuerde siempre las limitaciones de este enfoque y tenga en cuenta que habilitar el modo de referencia anulable no lo protege de las NRE y que, si se usa incorrectamente, podr√≠a convertirse en la fuente de estos errores.  Recomendamos que complemente la funci√≥n de referencia anulable con una herramienta de an√°lisis est√°tico moderna, como PVS-Studio, que admite an√°lisis interprocedimiento para proteger su programa de NRE.  Cada uno de estos enfoques (an√°lisis interprocedural profundo y firmas de m√©todos de anotaci√≥n (que es, de hecho, lo que hace el modo de referencia anulable)) tiene sus ventajas y desventajas.  El analizador le proporcionar√° una lista de ubicaciones potencialmente peligrosas y le permitir√° ver las consecuencias de modificar el c√≥digo existente.  Si hay una asignaci√≥n nula en alguna parte, el analizador apuntar√° a cada consumidor de la variable donde se desreferencia sin una verificaci√≥n. <br><br>  Puede verificar este proyecto o sus propios proyectos en busca de otros defectos: simplemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargue</a> PVS-Studio y pru√©belo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455234/">https://habr.com/ru/post/455234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455218/index.html">Enfoque ecosist√©mico de la tecnolog√≠a empresarial</a></li>
<li><a href="../455224/index.html">Finger Music: Toca cualquier cosa con los SpecDrums de Sphero</a></li>
<li><a href="../455226/index.html">¬øPor qu√© aplicar un ling√ºista aplicado?</a></li>
<li><a href="../455228/index.html">El que resucit√≥ a Duke Nukem: Entrevista con Randy Pitchford, asistente de Gearbox</a></li>
<li><a href="../455230/index.html">Tipos de referencia anulables en C # 8.0 y an√°lisis est√°tico</a></li>
<li><a href="../455236/index.html">Comodo revoca certificados sin motivo</a></li>
<li><a href="../455240/index.html">Uso de la tasa de defectos rechazados para mejorar el informe de errores</a></li>
<li><a href="../455242/index.html">Menos o√≠dos o c√≥mo no estropear el sonido en el juego desde el principio</a></li>
<li><a href="../455244/index.html">Comic "Soldar es f√°cil" en la versi√≥n actualizada (2019)</a></li>
<li><a href="../455246/index.html">La inscripci√≥n para el D√≠a de la Experiencia del Cliente en San Petersburgo est√° abierta el 20 de junio.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>