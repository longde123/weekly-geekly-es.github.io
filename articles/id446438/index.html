<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📦 🎭 🤙🏽 Pengalaman Pembuatan API Gateway Kami 👩🏼‍🎤 🥙 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa perusahaan, termasuk pelanggan kami, mengembangkan produk melalui jaringan afiliasi. Misalnya, toko online besar terintegrasi dengan layanan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman Pembuatan API Gateway Kami</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/446438/">  Beberapa perusahaan, termasuk pelanggan kami, mengembangkan produk melalui jaringan afiliasi.  Misalnya, toko online besar terintegrasi dengan layanan pengiriman - Anda memesan barang dan segera menerima nomor pelacakan untuk paket tersebut.  Contoh lain - bersama dengan tiket pesawat, Anda membeli asuransi atau tiket Aeroexpress. <br><br>  Untuk ini, satu API digunakan, yang harus dikeluarkan untuk mitra melalui API Gateway.  Kami telah memecahkan masalah ini.  Artikel ini akan memberikan detail. <br><br>  Diberikan: ekosistem dan portal API dengan antarmuka tempat pengguna terdaftar, menerima informasi, dll.  Kita perlu membuat Gateway API yang nyaman dan andal.  Dalam prosesnya, kami perlu menyediakan <br><br><ul><li>  Pendaftaran </li><li>  Kontrol koneksi API </li><li>  Memantau bagaimana pengguna menggunakan sistem akhir </li><li>  akuntansi indikator bisnis. </li></ul><br><img src="https://habrastorage.org/webt/op/f3/aa/opf3aadequfubwpkiu4gci8j9nm.png"><br><br>  Dalam artikel ini, kami akan berbicara tentang pengalaman kami dalam membuat API Gateway, di mana kami menyelesaikan tugas-tugas berikut: <br><br><ul><li>  otentikasi pengguna </li><li>  otorisasi pengguna </li><li>  modifikasi permintaan asli, </li><li>  meminta proxy </li><li>  pasca memproses respons. </li></ul><br><a name="habracut"></a><br>  Ada dua jenis manajemen API: <br><br>  1. Standar, yang berfungsi sebagai berikut.  Sebelum menghubungkan, pengguna menguji kemungkinan, kemudian membayar dan menyematkan di situsnya.  Paling sering digunakan dalam bisnis kecil dan menengah. <br><br>  2. Manajemen API B2B yang besar, ketika perusahaan pertama kali membuat keputusan bisnis tentang menghubungkan, menjadi perusahaan mitra dengan kewajiban kontraktual, dan kemudian terhubung ke API.  Dan setelah menyelesaikan semua formalitas, perusahaan mendapatkan akses uji, lulus pengujian dan masuk ke penjualan.  Tapi ini tidak mungkin tanpa keputusan manajemen untuk terhubung. <br><br><img src="https://habrastorage.org/webt/go/qv/oi/goqvoiroiq0yknutwbn9hrt7abe.jpeg"><br><br><h3>  Keputusan kami </h3><br>  Di bagian ini, kita akan berbicara tentang membuat API Gateway. <br><br>  Pengguna akhir dari gateway yang dibuat ke API adalah mitra pelanggan kami.  Untuk masing-masing dari mereka, kami sudah memiliki kontrak yang diperlukan.  Kami hanya perlu memperluas fungsionalitas, dengan memperhatikan akses yang diberikan ke gateway.  Karenanya, koneksi terkontrol dan proses kontrol diperlukan. <br><br>  Tentu saja, seseorang dapat mengambil beberapa solusi siap pakai untuk menyelesaikan tugas Manajemen API dan membuat API Gateway khususnya.  Misalnya, ini bisa menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manajemen API Azure</a> .  Itu tidak cocok untuk kami, karena dalam kasus kami, kami sudah memiliki portal API dan ekosistem besar yang dibangun di sekitarnya.  Semua pengguna telah terdaftar, mereka sudah mengerti di mana dan bagaimana mereka bisa mendapatkan informasi yang diperlukan.  Antarmuka yang diperlukan sudah ada di portal API, kami hanya perlu API Gateway.  Sebenarnya, kami mulai mengembangkannya. <br><br>  Apa yang kami sebut Gateway API adalah sejenis proxy.  Di sini kita lagi punya pilihan - Anda dapat menulis proxy Anda, atau Anda dapat memilih sesuatu yang sudah jadi.  Dalam hal ini, kami pergi ke jalan kedua dan memilih bundel nginx + Lua.  Mengapa  Kami membutuhkan perangkat lunak yang andal dan teruji yang mendukung penskalaan.  Setelah implementasi, kami tidak ingin memeriksa kebenaran logika bisnis dan kebenaran proxy. <br><br>  Server web mana pun memiliki saluran pemroses permintaan.  Dalam kasus nginx, tampilannya seperti ini: <br><br><img src="https://habrastorage.org/webt/7p/bu/9y/7pbu9y7z9ier1gtfhmu5pccawlu.png"><br><br>  (diagram dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub Lua Nginx</a> ) <br><br>  Tujuan kami adalah untuk mengintegrasikan ke dalam pipa ini pada saat kami dapat memodifikasi permintaan asli. <br><br>  Kami ingin membuat proxy transparan sehingga permintaan tetap berfungsi sebagaimana mestinya.  Kami hanya mengontrol akses ke API final, kami membantu permintaan untuk sampai ke sana.  Jika permintaan itu salah, API terakhir harus menunjukkan kesalahan, tetapi bukan kami.  Satu-satunya alasan kami dapat menolak permintaan adalah karena kurangnya akses ke klien. <br><br>  Untuk nginx, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi</a> sudah ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lua</a> .  Lua adalah bahasa scripting, sangat ringan dan mudah dipelajari.  Jadi, kami menerapkan logika yang diperlukan menggunakan Lua. <br><br>  Konfigurasi nginx (analogi dengan rute aplikasi), di mana semua pekerjaan dilakukan, dapat dimengerti.  Yang perlu diperhatikan di sini adalah arahan terakhir - post_action. <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /middleware { <span class="hljs-attribute"><span class="hljs-attribute">more_clear_input_headers</span></span> Accept-Encoding; <span class="hljs-attribute"><span class="hljs-attribute">lua_need_request_body</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">rewrite_by_lua_file</span></span> <span class="hljs-string"><span class="hljs-string">'middleware/rewrite.lua'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">access_by_lua_file</span></span> <span class="hljs-string"><span class="hljs-string">'middleware/access.lua'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> https://someurl.com; <span class="hljs-attribute"><span class="hljs-attribute">body_filter_by_lua_file</span></span> <span class="hljs-string"><span class="hljs-string">'middleware/body_filter.lua'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">post_action</span></span> /process_session; }</code> </pre> <br>  Pertimbangkan apa yang terjadi dalam konfigurasi ini: <br>  <b>more_clear_input_headers</b> - membersihkan nilai header yang ditentukan setelah arahan. <br>  <b>lua_need_request_body</b> - mengontrol apakah akan membaca sumber tubuh permintaan sebelum menjalankan arahan penulisan ulang / akses / access_by_lua atau tidak.  Secara default, nginx tidak membaca isi permintaan klien, dan jika Anda perlu mengaksesnya, arahan ini harus diaktifkan. <br>  <b>rewrite_by_lua_file</b> - path ke skrip, yang menjelaskan logika untuk memodifikasi permintaan <br>  <b>access_by_lua_file</b> - path ke skrip, yang menjelaskan logika yang memeriksa akses ke sumber daya. <br>  <b>proxy_pass</b> - url yang permintaannya akan diproksi. <br>  <b>body_filter_by_lua_file</b> - jalur ke skrip, yang menjelaskan logika untuk memfilter permintaan sebelum kembali ke klien. <br>  Dan, akhirnya, <b>post_action</b> adalah arahan resmi tidak berdokumen yang dapat digunakan untuk melakukan tindakan lain setelah respons diberikan kepada klien. <br><br>  Selanjutnya, kami akan menjelaskan dalam rangka bagaimana kami memecahkan masalah kami. <br><br><h3>  Otorisasi / otentikasi dan modifikasi permintaan </h3><br>  <b>Login</b> <br><br>  Kami membangun otorisasi dan otentikasi menggunakan akses sertifikat.  Ada sertifikat root.  Setiap klien baru dari pelanggan menghasilkan sertifikat pribadinya yang dengannya ia dapat mengakses API.  Sertifikat ini dikonfigurasi di bagian server pengaturan nginx. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">ssl</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /usr/local/openresty/nginx/ssl/cert.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /usr/local/openresty/nginx/ssl/cert.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_client_certificate</span></span> /usr/local/openresty/nginx/ssl/ca.crt; <span class="hljs-attribute"><span class="hljs-attribute">ssl_verify_client</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>;</code> </pre> <br>  <b>Modifikasi</b> <br><br>  Sebuah pertanyaan yang wajar mungkin timbul: apa yang harus dilakukan dengan klien bersertifikasi jika kita tiba-tiba ingin memutuskannya dari sistem?  Jangan menerbitkan ulang sertifikat untuk semua klien lain. <br><br>  Jadi kami lancar dan mendekati tugas berikutnya - modifikasi permintaan asli.  Permintaan klien asli, secara umum, tidak valid untuk sistem final.  Salah satu tugas adalah menambahkan bagian yang hilang ke permintaan untuk membuatnya valid.  Intinya adalah bahwa data yang hilang berbeda untuk setiap klien.  Kami tahu bahwa klien datang kepada kami dengan sertifikat yang darinya kami dapat mengambil sidik jari dan mengekstrak data klien yang diperlukan dari basis data. <br><br>  Jika pada suatu saat Anda perlu memutuskan koneksi klien dari layanan kami, datanya akan hilang dari database dan ia tidak akan dapat melakukan apa pun. <br><br><h3>  Bekerja dengan data pelanggan </h3><br>  Kami perlu memastikan ketersediaan solusi yang tinggi, terutama bagaimana kami mendapatkan data pelanggan.  Kesulitannya adalah bahwa sumber data ini adalah layanan pihak ketiga yang tidak menjamin kecepatan tanpa gangguan dan cukup tinggi. <br><br>  Oleh karena itu, kami perlu memastikan ketersediaan data pelanggan yang tinggi.  Sebagai alat, kami memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hazelcast</a> , yang memberi kami: <br><br><ul><li>  akses cepat ke data </li><li>  kemampuan untuk mengatur sekelompok beberapa node dengan data direplikasi pada node yang berbeda. </li></ul><br>  Kami menggunakan strategi pengiriman cache paling sederhana: <br><br><img src="https://habrastorage.org/webt/u6/f6/72/u6f6729km0g71ge4prl5ww1kes8.png"><br><br>  Bekerja dengan sistem final terjadi dalam kerangka sesi dan ada batasan jumlah maksimum.  Jika klien tidak menutup sesi, kita harus melakukan ini. <br><br>  Data sesi terbuka berasal dari sistem target dan pada awalnya diproses di sisi Lua.  Kami memutuskan untuk menggunakan Hazelcast untuk menyimpan data ini dengan penulis .NET.  Kemudian, pada beberapa interval, kami memeriksa hak untuk menjalani sesi terbuka dan menutup pelanggaran. <br><br><h3>  Akses ke Hazelcast dari Lua dan .NET </h3><br>  Tidak ada klien di Lua yang bekerja dengan Hazelcast, tetapi Hazelcast memiliki REST API, yang kami putuskan untuk digunakan.  Untuk .NET, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien</a> yang kami gunakan untuk mengakses data Hazelcast di sisi .NET.  Tapi itu dia. <br><br><img src="https://habrastorage.org/webt/qr/xn/ip/qrxnipywarywskcoslishyb8xtm.png"><br><br>  Ketika menyimpan data melalui REST dan mengambil melalui klien .NET, serializers / deserializers yang berbeda digunakan.  Oleh karena itu, tidak mungkin untuk memasukkan data melalui REST, tetapi untuk melewati .NET client dan sebaliknya. <br><br>  Jika Anda tertarik, kami akan membicarakan lebih lanjut tentang masalah ini di artikel terpisah.  Spoiler - pada shemka. <br><br><img src="https://habrastorage.org/webt/wh/l8/ra/whl8rayewel52cotktzhfcejmbs.png"><br><br><h3>  Penebangan dan Pemantauan </h3><br>  Standar perusahaan kami untuk masuk melalui .NET adalah Serilog, semua log berakhir di Elasticsearch, kami menganalisisnya melalui Kibana.  Saya ingin melakukan hal serupa dalam kasus ini.  Satu-satunya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien yang</a> bekerja dengan Elastic on Lua yang ditemukan bangkrut pada kebutuhan pertama.  Dan kami menggunakan Fluentd. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fluentd</a> adalah solusi open source untuk menyediakan lapisan logging aplikasi tunggal.  Memungkinkan Anda mengumpulkan log dari berbagai lapisan aplikasi, lalu menerjemahkannya menjadi satu sumber. <br><br>  Gateway API berfungsi di K8S, jadi kami memutuskan untuk menambahkan wadah dengan fluentd ke subtipe yang sama untuk menulis log ke port tcp fluentd terbuka yang ada. <br><br>  Kami juga memeriksa bagaimana fluentd akan berperilaku jika dia tidak memiliki koneksi dengan Elasticsearch.  Selama dua hari, permintaan terus dikirim ke gateway, log dikirim ke fluentd, tetapi IP Elastic dilarang dari fluentd.  Setelah terhubung kembali, fluentd secara sempurna melampaui semua log di Elastic. <br><br><h3>  Kesimpulan </h3><br>  Pendekatan yang dipilih untuk implementasi memungkinkan kami untuk mengirimkan produk yang benar-benar berfungsi ke lingkungan pertempuran hanya dalam 2,5 bulan. <br><br>  Jika Anda pernah melakukan hal-hal seperti itu, kami sarankan Anda terlebih dahulu memahami dengan jelas masalah yang Anda selesaikan dan sumber daya apa yang sudah Anda miliki.  Waspadai kompleksitas pengintegrasian dengan sistem manajemen API yang ada. <br><br>  Pahami sendiri apa yang sebenarnya akan Anda kembangkan - hanya logika bisnis pemrosesan permintaan, atau, seperti yang bisa terjadi dalam kasus kami, seluruh proxy.  Ingatlah bahwa semua yang Anda lakukan sendiri harus diuji secara menyeluruh sesudahnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446438/">https://habr.com/ru/post/id446438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446428/index.html">Bagaimana HR Bumblebee Plant Dibangun</a></li>
<li><a href="../id446430/index.html">Pendinginan partikel nano melayang melalui resonator optik</a></li>
<li><a href="../id446432/index.html">Sebuah seminar tentang manajemen dokumen teknis diadakan di Crimea</a></li>
<li><a href="../id446434/index.html">Zimbra Collaboration Suite Scaling</a></li>
<li><a href="../id446436/index.html">Cara menghasilkan hipotesis tentang kebutuhan konsumen potensial produk masa depan Anda</a></li>
<li><a href="../id446440/index.html">Buku Bereaksi Cepat. Aplikasi web dalam React, JSX, Redux dan GraphQL »</a></li>
<li><a href="../id446444/index.html">Dari Skype ke WebRTC: Bagaimana Kami Mengatur Komunikasi Video Web</a></li>
<li><a href="../id446446/index.html">Dasar-dasar mesin JavaScript: bentuk umum dan cache inline. Bagian 1</a></li>
<li><a href="../id446448/index.html">5 aturan dasar untuk melakukan wawancara masalah untuk mengidentifikasi kebutuhan konsumen</a></li>
<li><a href="../id446452/index.html">Misi Lunar "Bereshit" - 4 April 2019, transisi ke orbit bulan selesai, 7 hari penerbangan di depan, 6 manuver dan 1 pendaratan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>