<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ç üçü üîå Gestion des erreurs unifi√©e (option C ++ pour microcontr√¥leurs) üöπ üêê üîÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors du d√©veloppement de logiciels pour microcontr√¥leurs en C ++, vous pouvez tr√®s souvent rencontrer le fait que l'utilisation de la biblioth√®que sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion des erreurs unifi√©e (option C ++ pour microcontr√¥leurs)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441956/"> Lors du d√©veloppement de logiciels pour microcontr√¥leurs en C ++, vous pouvez tr√®s souvent rencontrer le fait que l'utilisation de la biblioth√®que standard peut entra√Æner des co√ªts de ressources suppl√©mentaires ind√©sirables, √† la fois RAM et ROM.  Par cons√©quent, souvent les classes et les m√©thodes de la biblioth√®que <code>std</code> ne sont pas tout √† fait adapt√©es √† l'impl√©mentation dans le microcontr√¥leur.  Il existe √©galement des restrictions sur l'utilisation de la m√©moire allou√©e dynamiquement, RTTI, exceptions, etc.  En g√©n√©ral, pour √©crire du code compact et rapide, vous ne pouvez pas simplement prendre la biblioth√®que <code>std</code> et commencer √† utiliser, par exemple les op√©rateurs <code>typeid</code> , parce que vous avez besoin de la prise en charge RTTI, et ceci est une surcharge, bien que pas tr√®s grande. <br><br>  Par cons√©quent, il faut parfois r√©inventer la roue pour remplir toutes ces conditions.  Il y a peu de telles t√¢ches, mais elles le sont.  Dans cet article, je voudrais parler d'une t√¢che apparemment simple - √©tendre les codes de retour des sous-syst√®mes existants dans le logiciel du microcontr√¥leur. <br><a name="habracut"></a><br><h2>  D√©fi </h2><br>  Supposons que vous ayez un sous-syst√®me de diagnostic CPU et qu'il ait des codes de retour √©num√©rables, dites ceux-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ;</code> </pre><br>  Si le sous-syst√®me de diagnostic CPU d√©tecte une panne de l'un des modules CPU (par exemple, ALU ou RAM), il devra renvoyer le code correspondant. <br><br>  La m√™me chose pour un autre sous-syst√®me, que ce soit un diagnostic de mesure, v√©rifiant que la valeur mesur√©e est dans la plage et qu'elle est g√©n√©ralement valide (non √©gale √† NAN ou Infinity): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ;</code> </pre> <br>  Pour chaque sous-syst√®me, qu'il y ait une m√©thode <code>GetLastError()</code> qui renvoie le type d'erreur √©num√©r√© de ce sous-syst√®me.  Pour <code>CpuDiagnostic</code> code de type <code>CpuDiagnostic</code> sera retourn√©, pour <code>MeasureDiagnostic</code> code de type <code>Measure_Error</code> . <br><br>  Et il y a un certain journal qui, lorsqu'une erreur se produit, devrait enregistrer le code d'erreur. <br>  Pour comprendre, je vais √©crire ceci sous une forme tr√®s simplifi√©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Logger::Update() { Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(cpuDiagnostic.GetLastError()) ; Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(measureDiagstic.GetLastError()) ; }</code> </pre><br>  Il est clair que lors de la conversion des types √©num√©r√©s en un entier, nous pouvons obtenir la m√™me valeur pour diff√©rents types.  Comment distinguer que le premier code d'erreur est le code d'erreur du sous-syst√®me de diagnostic Cpu et du deuxi√®me sous-syst√®me de mesure? <br><br><h3>  Recherche de solutions </h3><br>  Il serait logique que la m√©thode <code>GetLastError()</code> renvoie un code diff√©rent pour diff√©rents sous-syst√®mes.  L'une des d√©cisions les plus directes sur le front serait d'utiliser diff√©rentes plages de codes pour chaque type √©num√©r√©.  Quelque chose comme √ßa <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ALU = <span class="hljs-number"><span class="hljs-number">0x10000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ROM = <span class="hljs-number"><span class="hljs-number">0x10000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_OUTOF = <span class="hljs-number"><span class="hljs-number">0x01000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_BAD = <span class="hljs-number"><span class="hljs-number">0x01000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu = CPU_ERROR_ALU, Rom = CPU_ERROR_ROM, Ram = CPU_ERROR_RAM } ; ...</code> </pre><br>  Je pense que les inconv√©nients de cette approche sont √©vidents.  Tout d'abord, beaucoup de travail manuel, vous devez d√©terminer manuellement les plages et les codes de retour, ce qui entra√Ænera certainement une erreur humaine.  Deuxi√®mement, il peut y avoir de nombreux sous-syst√®mes, et l'ajout d'√©num√©rations pour chaque sous-syst√®me n'est pas du tout une option. <br><br>  En fait, ce serait formidable s'il √©tait possible de ne pas toucher du tout aux transferts, d'√©tendre leurs codes d'une mani√®re l√©g√®rement diff√©rente, par exemple, pour pouvoir le faire: <br><br><pre> <code class="cpp hljs">ResultCode result = Cpu_Error::Ok ; <span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error result = cpuDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; } //GetLastError()   Measure_Error result = measureDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; }</span></span></code> </pre><br>  Ou alors: <br><br><pre> <code class="cpp hljs">ReturnCode result ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: diagnostics) { <span class="hljs-comment"><span class="hljs-comment">//GetLastError()     result = it.GetLastError() ; if (result) //    { Logger::Log(result) ; //      } }</span></span></code> </pre><br>  Ou alors: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CpuDiagnostic::SomeFunction(ReturnCode errocode) { Cpu_Error status = errorcode ; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CpuError::Alu: <span class="hljs-comment"><span class="hljs-comment">// do something ; break; .... } }</span></span></code> </pre><br>  Comme vous pouvez le voir dans le code, une classe <code>ReturnCode</code> est utilis√©e ici, qui devrait contenir √† la fois le code d'erreur et sa cat√©gorie.  Dans la biblioth√®que standard, il y a une telle classe <code>std::error_code</code> , qui fait en fait presque tout cela.  Tr√®s bien son but est d√©crit ici: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Votre propre std :: code_error</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge des erreurs syst√®me en C ++</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exceptions d√©terministes et gestion des erreurs dans le ¬´C ++ du futur¬ª</a> <br><br>  La principale plainte est que pour utiliser cette classe, nous devons h√©riter de <code>std::error_category</code> , qui est clairement lourdement surcharg√© pour une utilisation dans le firmware des petits microcontr√¥leurs.  M√™me au moins en utilisant std :: string. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CpuErrorCategory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ev)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br>  De plus, vous devrez √©galement d√©crire manuellement la cat√©gorie (nom et message) pour chacun de ses types √©num√©r√©s.  Et aussi le code indiquant l'absence d'erreur dans <code>std::error_code</code> est 0. Et il y a des cas possibles o√π pour chaque type le code d'erreur sera diff√©rent. <br>  J'aimerais ne pas avoir de frais g√©n√©raux, sauf pour ajouter un num√©ro de cat√©gorie. <br><br>  Par cons√©quent, il serait logique d '¬´inventer¬ª quelque chose qui permettrait au d√©veloppeur d'effectuer un minimum de mouvements en termes d'ajout d'une cat√©gorie pour son type √©num√©r√©. <br><br>  Vous devez d'abord cr√©er une classe similaire √† <code>std::error_code</code> , capable de convertir n'importe quel type √©num√©r√© en entier et vice versa d'un entier en un type √©num√©r√©.  De plus √† ces fonctionnalit√©s, afin de pouvoir retourner la cat√©gorie, la valeur r√©elle du code, ainsi que de pouvoir v√©rifier: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   CpuError ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br><h3>  Solution </h3><br>  La classe doit stocker en elle-m√™me un code d'erreur, un code de cat√©gorie et un code correspondant √† l'absence d'erreurs, un op√©rateur de transtypage et un op√©rateur d'affectation.  La classe correspondante est la suivante: <br><br><img src="https://habrastorage.org/webt/v9/s3/nv/v9s3nvtgcu06simqv7mahn0h3fk.png"><br><br><div class="spoiler">  <b class="spoiler_title">Code de classe</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReturnCode() { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; } tU32 GetValue() const { return errorValue; } tU32 GetCategoryValue() const { return errorCategory; } operator bool() const { return (GetValue() != goodCode); } template&lt;class T&gt; ReturnCode&amp; operator=(const T returnCode) { errorValue = static_cast&lt;tU32&gt;(returnCode) ; errorCategory = GetCategory(returnCode) ; goodCode = GetOk(returnCode) ; return *this ; } private: tU32 errorValue = 0U ; tU32 errorCategory = 0U ; tU32 goodCode = 0U ; } ;</span></span></code> </pre><br></div></div><br>  Il faut expliquer un peu ce qui se passe ici.  Pour commencer avec un constructeur de mod√®le <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; }</code> </pre><br><br>  Il vous permet de cr√©er une classe d'objets √† partir de n'importe quel type √©num√©r√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(My_Error::Error1)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpuDiagnostic.GetLatestError())</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Pour garantir que le constructeur ne peut accepter qu'un type √©num√©r√©, <code>static_assert</code> ajout√© √† son corps, qui lors de la compilation v√©rifiera le type transmis au constructeur √† l'aide de <code>std::is_enum</code> et <code>std::is_enum</code> erreur avec du texte clair.  Le vrai code n'est pas g√©n√©r√© ici, c'est tout pour le compilateur.  Donc, en fait, c'est un constructeur vide. <br><br>  Le constructeur initialise √©galement les attributs priv√©s, j'y reviendrai plus tard ... <br>  De plus, l'op√©rateur de distribution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; }</span></span></code> </pre><br>  Il peut √©galement conduire uniquement √† un type √©num√©r√© et nous permet d'effectuer les op√©rations suivantes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Rom)</span></span></span><span class="hljs-function"> </span></span>; Cpu_Error status = errorCode ; returnCode = My_Errror::Error2; My_Errror status1 = returnCode ; returnCode = myDiagnostic.GetLastError() ; MyDiagsonticError status2 = returnCode ;</code> </pre><br>  Eh bien et s√©par√©ment l'op√©rateur bool (): <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (GetValue() != goodCode); }</code> </pre><br>  Cela nous permettra de v√©rifier directement s'il y a une erreur dans le code retour: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br>  C'est essentiellement tout.  La question reste dans les fonctions <code>GetCategory()</code> et <code>GetOkCode()</code> .  Comme vous pouvez le deviner, le premier est destin√© au type √©num√©r√© pour communiquer en quelque sorte sa cat√©gorie √† la classe <code>ReturnCode</code> , et le second au type √©num√©r√© pour indiquer qu'il s'agit d'un bon code retour, car nous allons le comparer avec l'op√©rateur <code>bool()</code> . <br><br>  Il est clair que ces fonctions peuvent √™tre fournies par l'utilisateur, et nous pouvons honn√™tement les appeler dans notre constructeur via le m√©canisme de recherche d√©pendant de l'argument. <br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoryError</span></span></span><span class="hljs-class"> {</span></span> Nv = <span class="hljs-number"><span class="hljs-number">100</span></span>, Cpu = <span class="hljs-number"><span class="hljs-number">200</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom } ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error errorNum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(CategoryError::Cpu); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOkCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(Cpu_Error::Ok); }</code> </pre><br>  Cela n√©cessite un effort suppl√©mentaire de la part du d√©veloppeur.  Nous avons besoin pour chaque type √©num√©r√© que nous voulons classer pour ajouter ces deux m√©thodes et mettre √† jour l'√©num√©ration <code>CategoryError</code> . <br><br>  Cependant, notre souhait est que le d√©veloppeur n'ajoute presque rien au code et ne se soucie pas de la fa√ßon d'√©tendre son type √©num√©r√©. <br>  Que peut-on faire. <br><br><ul><li>  Tout d'abord, c'√©tait formidable que la cat√©gorie soit calcul√©e automatiquement, et le d√©veloppeur <b>n'aurait pas</b> √† fournir une impl√©mentation de la m√©thode <code>GetCategory()</code> pour chaque √©num√©ration. </li><li>  Deuxi√®mement, dans 90% des cas dans notre code, Ok est utilis√© pour renvoyer un bon code.  Par cons√©quent, vous pouvez √©crire une impl√©mentation g√©n√©rale pour ces 90%, et pour 10%, vous devrez faire une sp√©cialisation. </li></ul><br>  Concentrons-nous donc sur la premi√®re t√¢che - le calcul automatique de cat√©gorie.  L'id√©e sugg√©r√©e par mon coll√®gue est que le d√©veloppeur devrait pouvoir enregistrer son type √©num√©r√©.  Cela peut √™tre fait en utilisant un mod√®le avec un nombre variable d'arguments.  D√©clarer une telle structure <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnumTypeRegister</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre><br>  Maintenant, pour enregistrer une nouvelle √©num√©ration, qui devrait √™tre d√©velopp√©e par une cat√©gorie, nous d√©finissons simplement un nouveau type <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error&gt;;</code> </pre><br>  Si, soudain, nous devons ajouter une autre √©num√©ration, ajoutez-la simplement √† la liste des param√®tres du mod√®le: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</code> </pre><br>  De toute √©vidence, la cat√©gorie de nos listes peut √™tre une position dans la liste des param√®tres du mod√®le, c'est-√†-dire  pour <code>Cpu_Error</code> c'est <b>0</b> , pour <code>Measure_Error</code> c'est <b>1</b> , pour <code>My_Error</code> c'est <b>2</b> .  Il reste √† forcer le compilateur √† calculer cela automatiquement.  Pour C ++ 14, nous faisons ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EnumTypeRegister&lt;Type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, <span class="hljs-string"><span class="hljs-string">"     EnumTypeRegister"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tU32(<span class="hljs-number"><span class="hljs-number">0U</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; }</code> </pre><br>  Que se passe-t-il ici.  En bref, la fonction <code>GetEnumPosition&lt;T&lt;&gt;&gt;</code> , avec le param√®tre d'entr√©e √©tant une liste de types √©num√©r√©s <code>EnumTypeRegister</code> , dans notre cas <code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code> , et le param√®tre de mod√®le <b>T</b> est un type √©num√©r√© dont l'index doit √™tre trouv√© dans cette liste, parcourt la liste et si T correspond √† l'un des types de la liste, retourne son index, sinon le message "Type n'est pas enregistr√© dans la liste EnumTypeRegister" s'affiche <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//..    constexpr EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt; list //  GetEnumPosition&lt;Measure_Error&gt;(list) //   1 -    Measure_Error   .</span></span></code> </pre><br>  Analysons plus en d√©tail.  Fonction la plus basse <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(TypeRegister&lt;Types...&gt;()) ; }</code> </pre><br>  Ici, la branche <code>std::enable_if_t&lt; <b>!std::is_same</b> ..</code> v√©rifie si le type demand√© correspond au premier type dans la liste des mod√®les, sinon, le type retourn√© de la fonction <code>GetEnumPosition</code> sera <code>tU32</code> puis le corps de la fonction est ex√©cut√©, √† savoir, un appel r√©cursif de la m√™me fonction √† nouveau , tandis que le nombre d'arguments de mod√®le diminue de <b>1</b> et la valeur de retour augmente de <b>1</b> .  Autrement dit, √† chaque it√©ration, il y aura quelque chose de similaire √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, 1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) //Iteration 2, 1+1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) //Iteration 3, 1+1+1: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;My_Error&gt;)</span></span></code> </pre><br>  Une fois tous les types de la liste termin√©s, <code>std::enable_if_t</code> ne pourra pas d√©duire le type de la valeur de retour de la fonction <code>GetEnumPosition()</code> , et √† cette it√©ration se terminera: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         GetEnumPosition&lt;T&gt;(TypeRegister&lt;&gt;) template &lt;typename QueriedType, typename Type&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type&gt;) { static_assert(std::is_same&lt;Type, QueriedType&gt;::value, "     EnumTypeRegister"); return tU32(0U) ; }</span></span></code> </pre><br>  Que se passe-t-il si le type est sur la liste.  Dans ce cas, une autre branche fonctionnera, la branche c <code>std::enable_if_t&lt; <b>std::is_same</b> ..</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; }</code> </pre><br>  Ici, il y a une v√©rification de la co√Øncidence des types <code>std::enable_if_t&lt; <b>std::is_same</b> ...</code> Et si, disons √† l'entr√©e il y a un type <code>Measure_Error</code> , alors la s√©quence suivante sera obtenue: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) { return 1U + GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) } //Iteration 2: tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) { return 0 ; }</span></span></code> </pre><br>  √Ä la deuxi√®me it√©ration, l'appel de fonction r√©cursive se termine et nous obtenons 1 (√† partir de la premi√®re it√©ration) + 0 (√† partir de la seconde) = <b>1</b> √† la sortie - il s'agit d'un index de type Measure_Error dans la liste <code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code> <br><br>  Comme il s'agit d'une fonction <code>constexpr,</code> tous les calculs sont effectu√©s au stade de la compilation et aucun code n'est r√©ellement g√©n√©r√©. <br><br>  Tout cela ne pouvait pas √™tre √©crit, √™tre √† la disposition de C ++ 17.  Malheureusement, mon compilateur IAR ne prend pas enti√®rement en charge C ++ 17, et il a donc √©t√© possible de remplacer l'int√©gralit√© de la footcloth par le code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//for C++17 template &lt;typename QueriedType, typename Type, typename... Types&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { //        if constexpr (std::is_same&lt;Type, QueriedType&gt;::value) { return 0U ; } else { return 1U + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; } }</span></span></code> </pre><br>  Il reste maintenant √† cr√©er les m√©thodes de mod√®le <code>GetCategory()</code> et <code>GetOk()</code> , qui appellent <code>GetEnumPosition</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(GetEnumPosition&lt;T&gt;(categoryDictionary)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(T::Ok); }</code> </pre><br>  C‚Äôest tout.  Voyons maintenant ce qui se passe avec cette construction d'objet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Measure_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Revenons au constructeur de la classe <code>ReturnCode</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"The type have to be enum"</span></span>) ; }</code> </pre><br>  Il s'agit d'un mod√®le, et si <code>T</code> est une <code>Measure_Error</code> ce qui signifie que l'instanciation du mod√®le de m√©thode <code>GetCategory(Measure_Error)</code> est appel√©e, pour le type <code>Measure_Error</code> , qui √† son tour appelle <code>GetEnumPosition</code> avec le type <code>Measure_Error</code> , <code>GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;)</code> qui renvoie la position de <code>Measure_Error</code> dans la liste.  La position est <b>1</b> .  Et en fait, le code constructeur entier √† l'instanciation du type <code>Measure_Error</code> remplac√© par le compilateur avec: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Measure_Error initReturnCode)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><h3>  R√©sum√© </h3><br>  Pour un d√©veloppeur qui <code>ReturnCode</code> utiliser <code>ReturnCode</code> il n'y a qu'une seule chose √† faire: <br>  Enregistrez votre type √©num√©r√© dans la liste. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add enum in the category using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</span></span></code> </pre><br>  Et pas de mouvements inutiles, le code existant ne bouge pas, et pour l'extension il vous suffit d'enregistrer le type dans la liste.  De plus, tout cela se fera au stade de la compilation, et le compilateur calculera non seulement toutes les cat√©gories, mais vous avertira √©galement si vous avez oubli√© d'enregistrer le type, ou si vous avez essay√© de passer un type qui n'est pas non √©num√©rable. <br><br>  En toute honn√™tet√©, il convient de noter que dans ces 10% du code o√π les √©num√©rations ont un nom diff√©rent au lieu du code Ok, vous devrez faire votre propre sp√©cialisation pour ce type. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 GetOk&lt;MyError&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyError) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(MyError::Good) ; } ;</code> </pre><br>  J'ai post√© un petit exemple ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple de code</a> <br><br>  En g√©n√©ral, voici une application: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">My_Error</span></span></span><span class="hljs-class"> {</span></span> Error1, Error2, Error3, Error4, Ok } ; <span class="hljs-comment"><span class="hljs-comment">// Add enum in the category list using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;; Cpu_Error CpuCheck() { return Cpu_Error::Ram; } My_Error MyCheck() { return My_Error::Error4; } int main() { ReturnCode result(CpuCheck()); //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; if (result) //if something wrong { result = MyCheck() ; // cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; } result = Measure_Error::BadCode ; //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; result = Measure_Error::Ok ; if (!result) //if all is Ok { Measure_Error mError = result ; if (mError == Measure_Error::Ok) { // cout &lt;&lt; "mError: "&lt;&lt; tU32(mError) &lt;&lt; endl; } } return 0; }</span></span></code> </pre> <br>  Imprimez les lignes suivantes: <br><blockquote>  Code retour: 3 Cat√©gorie retour: 0 <br>  Code retour: 3 Cat√©gorie de retour: 2 <br>  Code retour: 2 Cat√©gorie de retour: 1 <br>  mError: 1 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441956/">https://habr.com/ru/post/fr441956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441944/index.html">Pourquoi nous avons choisi la Lexus RX450h</a></li>
<li><a href="../fr441946/index.html">API REST sur Laravel en 100 lignes de code</a></li>
<li><a href="../fr441950/index.html">Eclipse Che 7 est d√©j√† l√†</a></li>
<li><a href="../fr441952/index.html">Choisir un syst√®me de stockage de fichiers pour le travail d'√©quipe</a></li>
<li><a href="../fr441954/index.html">R√©compense utilisateur aux auteurs de Habr</a></li>
<li><a href="../fr441962/index.html">Index dans PostgreSQL - 1</a></li>
<li><a href="../fr441964/index.html">Trucs et astuces Kubernetes: d√©placement des ressources de cluster vers Helm 2</a></li>
<li><a href="../fr441966/index.html">Kit de d√©marrage des tests de s√©curit√© Web</a></li>
<li><a href="../fr441968/index.html">D√©veloppement d'une nouvelle branche produit: comment se d√©barrasser de l'impraticable et rester utile</a></li>
<li><a href="../fr441970/index.html">Analyse FinFisher Butkit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>