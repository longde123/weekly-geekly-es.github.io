<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÆ üë©üèø‚Äçü§ù‚Äçüë®üèª üê¶ N√≥s bombeamos ganchos React usando FRP üåÜ üßúüèº üöß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tendo dominado os ganchos, muitos desenvolvedores do React experimentaram euforia, obtendo finalmente um kit de ferramentas simples e conveniente que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√≥s bombeamos ganchos React usando FRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445214/"><p>  Tendo dominado os ganchos, muitos desenvolvedores do React experimentaram euforia, obtendo finalmente um kit de ferramentas simples e conveniente que permite implementar tarefas com significativamente menos c√≥digo.  Mas isso significa que os ganchos useState e useReducer padr√£o oferecidos imediatamente s√£o tudo o que precisamos para gerenciar o estado? </p><br><p>  Na minha opini√£o, em sua forma bruta, seu uso n√£o √© muito conveniente, √© mais prov√°vel que eles sejam considerados a base para a cria√ß√£o de ganchos de gerenciamento de estado realmente convenientes.  Os pr√≥prios desenvolvedores de rea√ß√£o incentivam fortemente o desenvolvimento de ganchos personalizados, ent√£o por que n√£o faz√™-lo?  Sob o corte, veremos um exemplo muito simples e compreens√≠vel, o que h√° de errado com os ganchos comuns e como eles podem ser melhorados, tanto que eles se recusam completamente a us√°-los em sua forma pura. </p><a name="habracut"></a><br><p>  Existe um determinado campo para entrada, condicionalmente, de um nome.  E h√° um bot√£o clicando no qual devemos fazer uma solicita√ß√£o ao servidor com o nome digitado (uma determinada pesquisa).  Parece que poderia ser mais f√°cil?  No entanto, a solu√ß√£o est√° longe de ser √≥bvia.  A primeira implementa√ß√£o ing√™nua: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  O que h√° de errado aqui?  Se o usu√°rio, digitando algo no campo, enviar o formul√°rio duas vezes, apenas a primeira solicita√ß√£o funcionar√° para n√≥s, porque  no segundo clique, a solicita√ß√£o n√£o ser√° alterada e useEffect n√£o funcionar√°.  Se imaginarmos que nosso aplicativo √© um servi√ßo de pesquisa de tickets, e o usu√°rio poder√°, em alguns intervalos, enviar o formul√°rio repetidamente sem fazer altera√ß√µes, essa implementa√ß√£o n√£o funcionar√° para n√≥s!  Usar o nome como uma depend√™ncia para useEffect tamb√©m √© inaceit√°vel; caso contr√°rio, o formul√°rio ser√° enviado imediatamente quando o texto for alterado.  Bem, voc√™ tem que mostrar engenhosidade. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Agora, a cada clique, mudaremos o significado da solicita√ß√£o para o oposto, o que atingir√° o comportamento desejado.  √â uma muleta muito pequena e inocente, mas torna o c√≥digo um pouco confuso de entender.  Talvez agora pare√ßa a voc√™ que sugo o problema do meu dedo e inflo sua escala.  Bem, para responder se √© verdade ou n√£o, voc√™ precisa comparar esse c√≥digo com outras implementa√ß√µes que oferecem uma abordagem mais expressiva. </p><br><p>  Vejamos este exemplo em um n√≠vel te√≥rico usando a abstra√ß√£o de threads.  √â muito conveniente para descrever o status das interfaces do usu√°rio.  Portanto, temos dois fluxos: dados inseridos no campo de texto (nome $) e um fluxo de cliques no bot√£o enviar do formul√°rio (clique em $).  A partir deles, precisamos criar um terceiro fluxo combinado de solicita√ß√µes para o servidor. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Aqui est√° o comportamento que precisamos alcan√ßar.  Cada fluxo possui dois aspectos: o valor que possui e o momento em que os valores fluem atrav√©s dele.  Em v√°rias situa√ß√µes, podemos precisar de um ou outro aspecto, ou ambos.  Voc√™ pode comparar isso com o ritmo e a harmonia da m√∫sica.  Fluxos para os quais apenas o tempo de resposta √© essencial tamb√©m s√£o chamados de sinais. </p><br><p>  No nosso caso, clicar em $ √© um sinal puro: n√£o importa qual valor flui atrav√©s dele (indefinido / verdadeiro / Evento / o que for), s√≥ √© importante quando isso acontece.  Nome do caso $ <br>  o oposto: suas mudan√ßas de modo algum implicam mudan√ßas no sistema, mas podemos precisar do seu significado em algum momento.  E a partir desses dois fluxos, precisamos criar o terceiro, tirando da primeira vez, do segundo valor. </p><br><p>  No caso do Rxjs, temos um operador quase pronto para isso: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  No entanto, o uso pr√°tico de Rx no React pode ser bastante inconveniente.  Uma op√ß√£o mais adequada √© a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mrr</a> , constru√≠da com os mesmos princ√≠pios reativos funcionais que o Rx, mas especialmente adaptada para uso com o React no princ√≠pio de "reatividade total" e conectado como um gancho. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  A interface useMrr √© semelhante a useState ou useReducer: retorna um objeto de estado (valores de todos os threads) e um setter para inserir valores em threads.  Mas por dentro, tudo √© um pouco diferente: cada campo de estado (= fluxo), exceto aqueles em que colocamos valores diretamente dos eventos DOM, √© descrito por uma fun√ß√£o e uma lista de threads pai, cuja altera√ß√£o far√° com que o filho seja recalculado.  Nesse caso, os valores dos encadeamentos pai ser√£o substitu√≠dos na fun√ß√£o  Se queremos apenas obter o valor do fluxo, mas n√£o responder √† sua altera√ß√£o, escrevemos um "menos" na frente do nome, como no caso do nome. </p><br><p>  Temos o comportamento desejado, em ess√™ncia, em uma linha.  Mas isso n√£o √© apenas brevidade.  Vamos comparar os resultados obtidos com mais detalhes e, em primeiro lugar, com rela√ß√£o a um par√¢metro como legibilidade e clareza do c√≥digo resultante. </p><br><p>  Em mrr, voc√™ poder√° separar quase completamente a "l√≥gica" do "modelo": n√£o ser√° necess√°rio escrever manipuladores imperativos complexos em JSX.  Tudo √© extremamente declarativo: simplesmente mapeamos o evento DOM para o fluxo correspondente, praticamente sem convers√£o (para campos de entrada, o valor e.target.value √© extra√≠do automaticamente, a menos que voc√™ especifique o contr√°rio), e j√° na estrutura useMrr, descrevemos como os fluxos base s√£o formados subsidi√°rias.  Assim, no caso de transforma√ß√µes de dados s√≠ncronas e ass√≠ncronas, sempre podemos rastrear facilmente como nosso valor √© formado. </p><br><p>  Comparando com Px: nem precis√°vamos usar operadores adicionais: se, como resultado, as fun√ß√µes de srr receberem uma promessa, ele aguardar√° automaticamente at√© que seja resolvido e coloque os dados recebidos no fluxo.  Al√©m disso, em vez de withLatestFrom, usamos <br>  escuta passiva (sinal de menos), o que √© mais conveniente.  Imagine que, al√©m do nome, precisaremos enviar outros campos.  Em seguida, no sr. Adicionaremos outro fluxo de escuta passiva: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  E no Rx, voc√™ precisa esculpir mais um com o √öltimo de um mapa ou combinar primeiro o nome e o sobrenome em um fluxo. </p><br><p>  Mas voltando aos ganchos e mrr.  Um registro mais leg√≠vel de depend√™ncias, que sempre mostra como os dados s√£o formados, √© talvez uma das principais vantagens.  A interface atual useEffect basicamente n√£o permite responder a fluxos de sinais, e √© por isso que <br>  Eu tenho que pensar em diferentes reviravoltas. </p><br><p>  Outro ponto √© que a op√ß√£o de ganchos comuns carrega renderiza√ß√µes extras.  Se o usu√°rio acabou de clicar no bot√£o, isso ainda n√£o implica nenhuma altera√ß√£o na interface do usu√°rio que a rea√ß√£o precise desenhar.  No entanto, uma renderiza√ß√£o ser√° chamada.  Na variante com mrr, o estado retornado ser√° atualizado apenas quando uma resposta do servidor j√° tiver chegado.  Economizando nas partidas, voc√™ diz?  Bem, talvez.  Mas para mim, pessoalmente, o princ√≠pio de "retribuir-se em qualquer situa√ß√£o incompreens√≠vel", que √© a base de ganchos b√°sicos, causa rejei√ß√£o. </p><br><p>  Renderiza√ß√µes extras significam uma nova forma√ß√£o de manipuladores de eventos.  A prop√≥sito, aqui os ganchos comuns s√£o todos ruins.  Os manipuladores n√£o apenas s√£o imperativos, mas tamb√©m precisam ser regenerados toda vez que renderizam.  E n√£o ser√° poss√≠vel usar totalmente o cache aqui, porque  muitos manipuladores devem estar bloqueados para vari√°veis ‚Äã‚Äãinternas do componente.  Os manipuladores de mrr s√£o mais declarativos e o cache j√° est√° incorporado no mrr: set ('name') ser√° gerado apenas uma vez e ser√° substitu√≠do no cache por renderiza√ß√µes subsequentes. </p><br><p>  Com um aumento na base de c√≥digo, os manipuladores imperativos podem se tornar ainda mais pesados.  Digamos que tamb√©m precisamos mostrar o n√∫mero de envios de formul√°rios feitos pelo usu√°rio. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  N√£o √© muito bonito.  Obviamente, voc√™ pode renderizar o manipulador como uma fun√ß√£o separada dentro do componente.  A legibilidade aumentar√°, mas o problema de regenerar a fun√ß√£o com cada renderiza√ß√£o permanecer√°, assim como o problema de imperatividade.  Em ess√™ncia, esse √© um c√≥digo processual regular, apesar da cren√ßa generalizada de que a API do React est√° gradualmente mudando para uma abordagem funcional. </p><br><p>  Para aqueles a quem a escala do problema parece exagerada, posso responder que, por exemplo, os desenvolvedores do React est√£o conscientes do problema da gera√ß√£o excessiva de manipuladores, oferecendo-nos imediatamente uma muleta na forma de useCallback. </p><br><p>  Em mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  Uma alternativa mais conveniente √© useReducer, permitindo que voc√™ abandone o imperativo dos manipuladores.  Mas outros problemas importantes permanecem: a falta de trabalho com sinais (j√° que o mesmo useEffect ser√° respons√°vel por efeitos colaterais) e a pior legibilidade durante convers√µes ass√≠ncronas (em outras palavras, √© mais dif√≠cil rastrear o relacionamento entre os campos da loja, devido ao mesmo useEffect )  Se em mrr o gr√°fico de depend√™ncia entre os campos de estado (threads) for imediatamente vis√≠vel, em ganchos, voc√™ precisar√° olhar um pouco para cima e para baixo. </p><br><p>  Al√©m disso, o compartilhamento de useState e useReducer no mesmo componente n√£o √© muito conveniente (novamente haver√° manipuladores imperativos complexos que mudar√£o algo em useState <br>  e a√ß√£o de despacho), pelo qual, provavelmente, antes de desenvolver o componente, voc√™ precisar√° aceitar uma ou outra op√ß√£o. </p><br><p>  Obviamente, a considera√ß√£o de todos os aspectos ainda pode ser continuada.  Para n√£o ir al√©m do escopo do artigo, abordarei alguns pontos menos importantes na √≠ntegra. </p><br><p>  Registro centralizado, depura√ß√£o.  Como no mrr todos os fluxos est√£o contidos em um hub, para depura√ß√£o √© suficiente adicionar um sinalizador: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  Depois disso, todas as altera√ß√µes nos threads ser√£o exibidas no console.  Para acessar todo o estado (ou seja, os valores atuais de todos os segmentos), existe um pseudo-stream $ state: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Portanto, se voc√™ precisar ou estiver muito acostumado ao estilo editorial, poder√° escrever no estilo editor em mrr, retornando um novo valor de campo com base no evento e em todo o estado anterior.  Mas o oposto (escrever sobre useReducer ou um editor no estilo mrr) n√£o funcionar√°, devido √† falta de reatividade neles. </p><br><p>  Trabalhe com o tempo.  Lembra de dois aspectos dos fluxos: significado e tempo de resposta, harmonia e ritmo?  Portanto, trabalhar com o primeiro em ganchos comuns √© bastante simples e conveniente, mas com o segundo - n√£o.  Ao trabalhar com o tempo, quero dizer a forma√ß√£o de fluxos filho, cujo "ritmo" √© diferente do pai.  Isso √© basicamente todos os tipos de filtros, debowns, trotl etc.  Tudo isso voc√™ provavelmente ter√° que se implementar.  No srr, voc√™ pode usar instru√ß√µes prontas prontas para uso.  O conjunto de cavalheiros mrr √© inferior √† variedade de operadores Rx, mas possui nomes mais intuitivos. </p><br><p>  Intera√ß√£o entre componentes.  Lembro que no Editor foi considerado uma boa pr√°tica criar apenas uma hist√≥ria.  Se usarmos useReducer em muitos componentes, <br>  Pode haver um problema com a organiza√ß√£o da intera√ß√£o entre as partes.  No mrr, os fluxos podem "fluir" livremente de um componente para outro, para cima ou para baixo na hierarquia, mas isso n√£o criar√° problemas devido √† abordagem declarativa.  Mais detalhes <br>  Este t√≥pico, bem como outros recursos da API mrr, s√£o descritos no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atores + FRP no React</a> </p><br><h3 id="vyvody">  Conclus√µes </h3><br><p>  Os novos ganchos de rea√ß√£o s√£o √≥timos e simplificam nossas vidas, mas eles t√™m algumas falhas que um gancho de uso geral de n√≠vel superior (gerenciamento de estado) pode corrigir.  O UseMrr da biblioteca de mrr funcional-reativo foi proposto e considerado como tal. </p><br><p>  Problemas e suas solu√ß√µes: </p><br><ul><li>  recontagens desnecess√°rias de dados em cada renderiza√ß√£o (em mrr est√£o ausentes devido √† reatividade baseada em push) </li><li>  renderiza√ß√µes extras quando uma mudan√ßa de estado n√£o implica uma mudan√ßa na interface do usu√°rio </li><li>  baixa legibilidade do c√≥digo com convers√µes ass√≠ncronas (comparadas √†s s√≠ncronas).  Em mrr, o c√≥digo ass√≠ncrono n√£o √© inferior ao s√≠ncrono em legibilidade e expressividade.  A maioria dos problemas discutidos em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo recente sobre useEffect</a> no mrr √© basicamente imposs√≠vel </li><li>  manipuladores imperativos que nem sempre s√£o armazenados em cache (em mrr, eles s√£o armazenados automaticamente em cache, quase sempre podem ser armazenados em cache, declarativos) </li><li>  usar useState e useReducer ao mesmo tempo pode criar c√≥digo estranho </li><li>  falta de ferramentas para converter fluxos ao longo do tempo (desacelera√ß√£o, acelerador, condi√ß√£o de corrida) </li></ul><br><p>  Em muitos pontos, pode-se argumentar que eles podem ser resolvidos por ganchos personalizados.  Mas √© exatamente isso que est√° sendo proposto, mas, em vez de implementa√ß√µes d√≠spares, para cada tarefa separada, √© proposta uma solu√ß√£o hol√≠stica e consistente. </p><br><p>  Muitos problemas tornaram-se familiares demais para que possamos ser claramente reconhecidos.  Por exemplo, as convers√µes ass√≠ncronas sempre pareciam mais complicadas e confusas do que as s√≠ncronas, e os ganchos nesse sentido n√£o s√£o piores do que as abordagens anteriores (eds, etc.).  Para perceber isso como um problema, voc√™ deve primeiro ver outras abordagens que ofere√ßam uma solu√ß√£o melhor. </p><br><p>  Este artigo n√£o pretende impor nenhuma vis√£o espec√≠fica, mas chamar a aten√ß√£o para o problema.  Estou certo de que existem ou est√£o sendo criadas outras solu√ß√µes que podem se tornar uma alternativa v√°lida, mas ainda n√£o se tornaram amplamente conhecidas.  A pr√≥xima API do React Cache tamb√©m pode fazer uma grande diferen√ßa.  Ficarei feliz em receber cr√≠ticas e discuss√µes nos coment√°rios. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os</a> interessados ‚Äã‚Äãtamb√©m podem assistir a uma apresenta√ß√£o sobre este t√≥pico no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kyivjs</a> em 28 de mar√ßo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445214/">https://habr.com/ru/post/pt445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445204/index.html">Convers√£o de fluxo de dados do Firebird 2.5 para o formato ODS12 (Firebird 3.0)</a></li>
<li><a href="../pt445206/index.html">Reduza o tempo de inatividade ao atualizar o Zimbra</a></li>
<li><a href="../pt445208/index.html">N√≠veis de maturidade da TI corporativa</a></li>
<li><a href="../pt445210/index.html">Col√¥nia de Criptomoedas</a></li>
<li><a href="../pt445212/index.html">NetBIOS nas m√£os de um hacker</a></li>
<li><a href="../pt445220/index.html">AMD Radeon VII: chip de √∫ltima gera√ß√£o (parte 3)</a></li>
<li><a href="../pt445222/index.html">Receba uma oferta em 1 dia para a equipe de back-end no Dia da Cosmon√°utica</a></li>
<li><a href="../pt445226/index.html">O desenvolvimento de um foguete capaz de atingir a lua custar√° √† R√∫ssia 740 bilh√µes de rublos</a></li>
<li><a href="../pt445228/index.html">Criptografia em Java. Classe Mac</a></li>
<li><a href="../pt445230/index.html">As inscri√ß√µes para a II confer√™ncia de TI para iniciantes SMARTRHINO-2019 come√ßaram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>