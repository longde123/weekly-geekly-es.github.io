<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚ÄçüöÄ üî∑ üôÜüèΩ Hello World Analysis üë©üèº‚Äçüîß üöü üêû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Hello World √© um dos primeiros programas que escrevemos em qualquer linguagem de programa√ß√£o. 

 Para C, o hello world parece simples e curto: 



#...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hello World Analysis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438044/">  O Hello World √© um dos primeiros programas que escrevemos em qualquer linguagem de programa√ß√£o. <br><br>  Para C, o hello world parece simples e curto: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void main() { printf("Hello World!\n"); }</span></span></span></span></code> </pre> <br>  Como o programa √© t√£o curto, deve ser fundamental explicar o que est√° acontecendo "sob o cap√¥". <br><a name="habracut"></a><br>  Primeiro, vamos ver o que acontece ao compilar e vincular: <br> <code>gcc --save-temps hello.c -o hello</code> <br> <br>  <code>--save-temps</code> adicionado para que o gcc deixe o <code>hello.s</code> , um arquivo de c√≥digo de montagem. <br><br>  Aqui est√° o c√≥digo do assembler de exemplo que recebi: <br><br><pre> <code class="plaintext hljs"> .file "hello.c" .section .rodata .LC0: .string "Hello World!" .text .globl main .type main, @function main: pushq %rbp movq %rsp, %rbp movl $.LC0, %edi call puts popq %rbp ret</code> </pre> <br>  Como voc√™ pode ver na lista do assembler, n√£o √© <code>printf</code> que √© chamado, mas <code>puts</code> .  A fun√ß√£o <code>puts</code> tamb√©m √© definida no arquivo <code>stdio.h</code> e est√° comprometida em imprimir uma linha e quebra de linha. <br><br>  Bem, entendemos que fun√ß√£o nosso c√≥digo realmente chama.  Mas onde √© implementado o <code>puts</code> ? <br><br>  Para determinar qual biblioteca implementa as <code>puts</code> , usamos <code>ldd</code> , que exibe depend√™ncias da biblioteca, e <code>nm</code> , que exibe os caracteres do arquivo de objeto. <br><br><pre> <code class="plaintext hljs">$ ldd hello libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003e4da00000) $ nm /lib64/libc.so.6 | grep " puts" 0000003e4da6dd50 W puts</code> </pre> <br>  A fun√ß√£o est√° localizada em uma biblioteca chamada <code>libc</code> e localizada em <code>/lib64/libc.so.6</code> no meu sistema (Fedora 19).  No meu caso, <code>/lib64</code> √© um link simb√≥lico para <code>/usr/lib64</code> e <code>/usr/lib64/libc.so.6</code> √© um link simb√≥lico para <code>/usr/lib64/libc-2.17.so</code> .  Este arquivo cont√©m todas as fun√ß√µes. <br><br>  Descobrimos a vers√£o do <code>libc</code> executando o arquivo como se fosse execut√°vel: <br><br><pre> <code class="plaintext hljs">$ /usr/lib64/libc-2.17.so GNU C Library (GNU libc) stable release version 2.17, by Roland McGrath et al. ...</code> </pre> <br>  Como resultado, nosso programa chama a fun√ß√£o de <code>glibc</code> da <code>glibc</code> vers√£o 2.17.  Vamos agora ver o que a fun√ß√£o <code>glibc-2.17</code> faz na <code>glibc-2.17</code> . <br><br>  O c√≥digo glibc √© dif√≠cil de navegar devido ao uso generalizado de macros e scripts de pr√©-processador.  Observando o c√≥digo, vemos o seguinte em <code>libio/ioputs.c</code> : <br><br><pre> <code class="cpp hljs">weak_alias (_IO_puts, <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>)</code> </pre> <br>  Na glibc, isso significa que, ao chamar <code>_IO_puts</code> , <code>_IO_puts</code> √© realmente chamado.  Esta fun√ß√£o √© descrita no mesmo arquivo e a parte principal da fun√ß√£o √© semelhante a esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IO_puts (str) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; { <span class="hljs-comment"><span class="hljs-comment">//... _IO_sputn (_IO_stdout, str, len) //... }</span></span></code> </pre> <br>  Joguei todo o lixo em torno do importante desafio para n√≥s.  Agora <code>_IO_sputn</code> √© o nosso elo atual na cadeia de chamadas hello world.  Encontramos uma defini√ß√£o, esse nome √© uma macro definida em <code>libio/libioP.h</code> , que chama outra macro, que novamente ... A √°rvore de macro cont√©m o seguinte: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//... #define _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N) //... #define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2) //... # define _IO_JUMPS_FUNC(THIS) \ (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS ((struct _IO_FILE_plus *) (THIS)) + (THIS)-&gt;_vtable_offset)) //... #define _IO_JUMPS(THIS) (THIS)-&gt;vtable</span></span></span></span></code> </pre> <br>  Que diabos est√° acontecendo aqui?  Vamos expandir todas as macros para ver o c√≥digo final: <br><br><pre> <code class="cpp hljs"> ((*(struct _IO_jump_t **) ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) &amp;((struct _IO_FILE_plus *) (((_IO_FILE*)(&amp;_IO_2_1_stdout_)) ) )-&gt;vtable+(((_IO_FILE*)(&amp;_IO_2_1_stdout_)) )-&gt;_vtable_offset))-&gt;__xsputn ) (((_IO_FILE*)(&amp;_IO_2_1_stdout_)), str, len)</code> </pre><br>  Olhos doem.  Deixe-me explicar o que est√° acontecendo aqui.  Glibc usa jump-table para chamar fun√ß√µes.  No nosso caso, a tabela est√° em uma estrutura chamada <code>_IO_2_1_stdout_</code> , e a fun√ß√£o que precisamos √© chamada <code>__xsputn</code> . <br><br>  A estrutura √© declarada no arquivo <code>libio/libio.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IO_FILE_plus</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IO_2_1_stdout_</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  E no arquivo <code>libio/libioP.h</code> defini√ß√µes da estrutura, tabela e seu campo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IO_FILE_plus</span></span></span><span class="hljs-class"> {</span></span> _IO_FILE file; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IO_jump_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vtable</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//... struct _IO_jump_t { //... JUMP_FIELD(_IO_xsputn_t, __xsputn); //... JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); //... };</span></span></code> </pre> <br>  Se aprofundarmos ainda mais, veremos que a tabela <code>_IO_2_1_stdout_</code> inicializada no arquivo <code>libio/stdfiles.c</code> , e as implementa√ß√µes <code>libio/stdfiles.c</code> das fun√ß√µes da tabela s√£o definidas em <code>libio/fileops.c</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* from libio/stdfiles.c */</span></span> DEF_STDFILE(_IO_2_1_stdout_, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;_IO_2_1_stdin_, _IO_NO_READS); <span class="hljs-comment"><span class="hljs-comment">/* from libio/fileops.c */</span></span> <span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IO_new_file_xsputn _IO_file_xsputn </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//... const struct _IO_jump_t _IO_file_jumps = { //... JUMP_INIT(xsputn, _IO_file_xsputn), //... JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), //... };</span></span></span></span></code> </pre> <br>  Tudo isso significa que, se usarmos a tabela de salto associada ao <code>stdout</code> , chamaremos a fun√ß√£o <code>_IO_new_file_xsputn</code> .  J√° est√° mais perto, certo?  Essa fun√ß√£o lan√ßa dados em buffers e chama <code>new_do_write</code> quando o conte√∫do do buffer pode ser gerado.  √â assim que <code>new_do_write</code> parece: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _<span class="hljs-function"><span class="hljs-function">IO_size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_do_write</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fp, data, to_do)</span></span></span><span class="hljs-function"> _IO_FILE *fp</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data; _IO_size_t to_do; { _IO_size_t count; .. count = _IO_SYSWRITE (fp, data, to_do); .. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  Obviamente, a macro √© chamada.  Atrav√©s do mesmo mecanismo de tabela de salto que vimos para <code>__xsputn</code> , <code>__write</code> √© <code>__write</code> .  Para arquivos <code>__write</code> , <code>__write</code> mapeado para <code>_IO_new_file_write</code> .  Essa fun√ß√£o √© chamada em √∫ltima an√°lise.  Vamos olhar para ela? <br><br><pre> <code class="cpp hljs">_IO_ssize_t _IO_new_file_write (f, data, n) _IO_FILE *f; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data; _IO_ssize_t n; { _IO_ssize_t to_do = n; _IO_ssize_t count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (to_do &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. write (f-&gt;_fileno, data, to_do)); // .. }</span></span></code> </pre> <br>  Finalmente, uma fun√ß√£o que chama algo que n√£o come√ßa com um sublinhado!  A fun√ß√£o de <code>write</code> √© conhecida e definida em <code>unistd.h</code> .  Essa √© uma maneira bastante padr√£o de gravar bytes em um arquivo usando um descritor de arquivo.  A fun√ß√£o de <code>write</code> √© definida na pr√≥pria glibc, portanto, precisamos encontrar o c√≥digo. <br><br>  Encontrei o c√≥digo de <code>write</code> em <code>sysdeps/unix/syscalls.list</code> .  A maioria das chamadas de sistema envolvidas no glibc s√£o geradas a partir desses arquivos.  O arquivo cont√©m o nome da fun√ß√£o e os argumentos necess√°rios.  O corpo da fun√ß√£o √© criado a partir de um padr√£o de chamada do sistema comum. <br><br><pre> <code class="plaintext hljs"># File name Caller Syscall name Args Strong name Weak names ... write - write Ci:ibn __libc_write __write write ...</code> </pre> <br>  Quando o c√≥digo glibc chama <code>write</code> ( <code>__libcwrite</code> ou <code>__write</code> ), syscall ocorre no kernel.  O c√≥digo do kernel √© muito mais leg√≠vel que o glibc.  O ponto de entrada para a <code>write</code> syscall est√° em <code>fs/readwrite.c</code> : <br><br><pre> <code class="cpp hljs">SYSCALL_DEFINE3(write, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, fd, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *, buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, count) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fd</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fdget</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fd</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> ret = -EBADF; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f.file) { <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = file_pos_read(f.file); ret = vfs_write(f.file, buf, count, &amp;pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) file_pos_write(f.file, pos); fdput(f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Primeiro, a estrutura correspondente ao descritor de arquivo √© encontrada e, em seguida, a fun√ß√£o <code>vfs_write</code> √© <code>vfs_write</code> no subsistema do sistema de arquivos virtual (vfs).  A estrutura no nosso caso corresponder√° ao arquivo <code>stdout</code> .  D√™ uma olhada em <code>vfs_write</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> vfs_write(struct file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count, <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> *pos) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br>  A fun√ß√£o delega a execu√ß√£o da fun√ß√£o de <code>write</code> pertencente a um arquivo espec√≠fico.  No Linux, isso geralmente √© implementado no c√≥digo do driver, portanto, voc√™ precisa descobrir qual driver √© chamado no nosso caso. <br><br>  Eu uso o Fedora 19 com o Gnome 3. Para experimentos, isso significa que meu terminal √© o <code>gnome-terminal</code> por padr√£o.  Execute este terminal e fa√ßa o seguinte: <br><br><pre> <code class="bash hljs">~$ tty /dev/pts/0 ~$ ls -l /proc/self/fd total 0 lrwx------ 1 kos kos 64 okt. 15 06:37 0 -&gt; /dev/pts/0 lrwx------ 1 kos kos 64 okt. 15 06:37 1 -&gt; /dev/pts/0 lrwx------ 1 kos kos 64 okt. 15 06:37 2 -&gt; /dev/pts/0 ~$ ls -la /dev/pts total 0 drwxr-xr-x 2 root root 0 okt. 10 10:14 . drwxr-xr-x 21 root root 3580 okt. 15 06:21 .. crw--w---- 1 kos tty 136, 0 okt. 15 06:43 0 c--------- 1 root root 5, 2 okt. 10 10:14 ptmx</code> </pre> <br>  O comando <code>tty</code> imprime o nome de um arquivo vinculado √† entrada padr√£o e, como voc√™ pode ver na lista de arquivos em <code>/proc</code> , o mesmo arquivo est√° associado √† sa√≠da e ao fluxo de erros.  Esses arquivos de dispositivo em <code>/dev/pts</code> s√£o chamados pseudo-terminais, mais precisamente, s√£o pseudo-terminais escravos.  Quando um processo grava um pseudo-terminal no escravo, os dados v√£o para o pseudo-terminal mestre.  O pseudo-terminal mestre √© um dispositivo <code>/dev/ptmx</code> . <br><br>  O driver do pseudo-terminal est√° localizado no kernel do Linux no <code>drivers/tty/pty.c</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unix98_pty_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... pts_driver-&gt;driver_name = "pty_slave"; pts_driver-&gt;name = "pts"; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = 0; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; //... tty_set_operations(pts_driver, &amp;pty_unix98_ops); //... /* Now create the /dev/ptmx special device */ tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); //... } static const struct tty_operations pty_unix98_ops = { //... .open = pty_open, .close = pty_close, .write = pty_write, //... };</span></span></code> </pre> <br>  Ao escrever em <code>pts</code> , <code>pty_write</code> √© <code>pty_write</code> , que se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pty_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tty_struct *tty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tty_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tty</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">link</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;stopped) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Stuff the data into the input queue of the other end */</span></span> c = tty_insert_flip_string(to-&gt;port, buf, c); <span class="hljs-comment"><span class="hljs-comment">/* And shovel */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br>  Os coment√°rios ajudam a entender que os dados est√£o na fila de entrada do pseudo-terminal principal.  Mas quem est√° lendo essa linha? <br><br><pre> <code class="bash hljs">~$ lsof | grep ptmx gnome-ter 13177 kos 11u CHR 5,2 0t0 1133 /dev/ptmx gdbus 13177 13178 kos 11u CHR 5,2 0t0 1133 /dev/ptmx dconf 13177 13179 kos 11u CHR 5,2 0t0 1133 /dev/ptmx gmain 13177 13182 kos 11u CHR 5,2 0t0 1133 /dev/ptmx ~$ ps 13177 PID TTY STAT TIME COMMAND 13177 ? Sl 0:04 /usr/libexec/gnome-terminal-server</code> </pre> <br>  O processo <code>gnome-terminal-server</code> gera todos <code>gnome-terminal</code> e cria novos pseudo-terminais.  √â ele quem ouve o pseudo-terminal principal e, no final, recebe nossos dados, que √© <code>"Hello World"</code> .  O servidor do <code>gnome-terminal</code> recebe a string e a exibe na tela.  Em geral, n√£o havia tempo suficiente para uma an√°lise detalhada do <code>gnome-terminal</code> :) <br><br><h3>  Conclus√£o </h3><br>  O caminho geral da nossa linha "Hello World": <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0.</span></span> hello: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>) <span class="hljs-number"><span class="hljs-number">1.</span></span> glibc: <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>() <span class="hljs-number"><span class="hljs-number">2.</span></span> glibc: _IO_puts() <span class="hljs-number"><span class="hljs-number">3.</span></span> glibc: _IO_new_file_xsputn() <span class="hljs-number"><span class="hljs-number">4.</span></span> glibc: new_do_write() <span class="hljs-number"><span class="hljs-number">5.</span></span> glibc: _IO_new_file_write() <span class="hljs-number"><span class="hljs-number">6.</span></span> glibc: syscall write <span class="hljs-number"><span class="hljs-number">7.</span></span> kernel: vfs_write() <span class="hljs-number"><span class="hljs-number">8.</span></span> kernel: pty_write() <span class="hljs-number"><span class="hljs-number">9.</span></span> gnome_terminal: read() <span class="hljs-number"><span class="hljs-number">10.</span></span> gnome_terminal: show to user</code> </pre> <br>  Parece um <i>pequeno</i> fracasso para uma opera√ß√£o t√£o simples.  √â bom que apenas quem realmente queira o veja. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438044/">https://habr.com/ru/post/pt438044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438020/index.html">Caterpillar Introduz Escavadeira El√©trica de 26 Ton com Bateria Gigante de 300 kWh</a></li>
<li><a href="../pt438022/index.html">Como o tamanho do c√≥digo depende do minificador, coletor e idioma. Atualiza√ß√£o inesperada do webpack</a></li>
<li><a href="../pt438028/index.html">Voc√™ n√£o precisa de blockchain: 8 casos de usu√°rios populares e por que eles n√£o funcionam</a></li>
<li><a href="../pt438034/index.html">Android, Rx e Kotlin, ou como fazer uma garra de Lego encolher. Parte 1</a></li>
<li><a href="../pt438036/index.html">3blue1brown e MIT em russo</a></li>
<li><a href="../pt438048/index.html">Removemos recursos e produtos desnecess√°rios para melhorar os neg√≥cios.</a></li>
<li><a href="../pt438052/index.html">Interator, Padr√£o de Opera√ß√£o</a></li>
<li><a href="../pt438058/index.html">"An√°lise de dados em Python" em duas partes</a></li>
<li><a href="../pt438060/index.html">Estimativa da orienta√ß√£o espacial ou Como n√£o ter medo dos filtros Mahoney e Majwik</a></li>
<li><a href="../pt438062/index.html">Meu endere√ßo n√£o √© uma casa ou rua, meu endere√ßo √© a Uni√£o Sovi√©tica?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>