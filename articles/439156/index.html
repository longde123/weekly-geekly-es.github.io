<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêΩ üêî üçπ t1ha = Hash positivo r√°pido üõ´ üêù üç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Casi la funci√≥n hash port√°til de 64 bits m√°s r√°pida con una calidad decente. 


 Esta es una traducci√≥n del art√≠culo original de Leonid Yuriev . 
 En ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = Hash positivo r√°pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  Casi la funci√≥n hash port√°til de 64 bits m√°s r√°pida con una calidad decente. </p><br><p> Esta es una traducci√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">En lugar de un descargo de responsabilidad</b> <div class="spoiler_text"><p>  Omitir√© la definici√≥n de funciones hash junto con la lista detallada de las propiedades y requisitos para su aplicaci√≥n criptogr√°fica, y supondr√© que el lector tiene el conocimiento m√≠nimo necesario o lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leer√°</a> .  Tambi√©n se debe tener en cuenta que, en lo sucesivo, hablar√© sobre funciones hash no criptogr√°ficas (no adecuadas para la criptograf√≠a), a menos que se indique expl√≠citamente lo contrario. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banalidades</b> <div class="spoiler_text"><p>  El hash se usa en muchos algoritmos, y casi siempre se requiere el procesamiento de datos m√°s eficiente (r√°pido), junto con un cierto nivel m√≠nimo de calidad de hash.  Aqu√≠ el t√©rmino "calidad" significa, en primer lugar, una especie de "aleatoriedad" (estocasticidad) en relaci√≥n con los datos iniciales.  Con menos frecuencia se imponen requisitos adicionales, como resistencia a la generaci√≥n deliberada de colisiones o irreversibilidad. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Para ser un poco m√°s tedioso</b> <div class="spoiler_text"><p>  Para mayor claridad, es necesario definir el concepto de "calidad" de la funci√≥n hash y el resto de los requisitos con un poco m√°s de detalle: <br>  Calidad de l√≠nea de base y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">efecto de avalancha</a> : cambiar uno o m√°s bits arbitrarios en un conjunto arbitrario de datos de origen hace que cada bit del resultado cambie con una probabilidad de ¬Ω. </p><br><ul><li>  Irreversibilidad o primera resistencia previa a la imagen: la imposibilidad de obtener los datos originales o bits individuales del resultado de hash. </li><li>  Resistencia a colisiones de primer orden y / o resistencia previa a la segunda imagen: la dificultad de encontrar / ajustar el conjunto de datos original para obtener un resultado espec√≠fico o parte de √©l, incluso cuando se conoce el conjunto de datos inicial. </li><li>  Resistencia a colisiones de segundo orden: la dificultad de encontrar / ajustar dos conjuntos de datos diferentes que dar√≠an el mismo resultado o una coincidencia de una parte significativa. </li></ul></div></div><br><p>  Omitiendo largas citas de las matem√°ticas subyacentes, se puede resumir: </p><br><ul><li>  Satisfacer todos los requisitos anteriores al tiempo que garantiza un alto rendimiento es un problema bastante dif√≠cil, resolver lo que nos dar√≠a una buena funci√≥n hash criptogr√°fica.  Pero todav√≠a no vamos a hacer esto. </li><li>  Proporcionar calidad b√°sica requiere un n√∫mero suficientemente grande de operaciones de ALU.  En pocas palabras, la calidad siempre compromete con la velocidad. </li><li>  La obtenci√≥n de un resultado de alta calidad con un ancho de bits mayor que el ancho de bits de las operaciones de ALU requiere un aumento de varias veces en el n√∫mero de mezclas y, por lo tanto, operaciones b√°sicas de ALU. </li><li>  En general, <em>crear una funci√≥n hash r√°pida implica lograr un compromiso ponderado entre velocidad, calidad y bitness de resultado</em> . </li></ul><br><p>  Por lo tanto, puedo decir que <strong>t1ha</strong> apareci√≥ como resultado de la b√∫squeda de un compromiso entre calidad y velocidad, al mismo tiempo teniendo en cuenta las capacidades de los procesadores modernos y los m√©todos ya encontrados (combinaciones l√≥gico-aritm√©ticas) de mezclar y distribuir dependencias ( efecto avalancha). </p><br><p>  La versi√≥n b√°sica de <strong>t1ha</strong> es una de las funciones hash port√°tiles m√°s r√°pidas para construir tablas hash y otras aplicaciones relacionadas.  La versi√≥n b√°sica de <strong>t1ha</strong> se centra en arquitecturas little-endian de 64 bits, toma un valor de sal (semilla) de 64 bits y produce un resultado de 64 bits, que incluye el fortalecimiento por longitud de clave y semilla.  Vale la pena se√±alar que <strong>t1ha</strong> est√° dise√±ado intencionalmente para devolver 0 para datos de entrada cero (una clave de tama√±o cero y cero semilla). </p><br><div class="spoiler">  <b class="spoiler_title">Respondiendo las preguntas m√°s populares</b> <div class="spoiler_text"><p>  <strong>Operaciones de 64 bits</strong> : Quiz√°s se debe tener en cuenta que son las operaciones de 64 bits las que proporcionan velocidad y calidad sin perjudicar la portabilidad.  De hecho, cuanto mayor es la capacidad de d√≠gitos de las operaciones aritm√©ticas, m√°s efecto de avalancha producen y mejor mezclan los datos.  Adem√°s, el procesamiento de datos, en igualdad de condiciones, es ciertamente m√°s r√°pido en 8 bytes que en 4. Por otro lado, las operaciones de 64 bits est√°n disponibles de forma nativa en muchos procesadores modernos y pueden traducirse m√°s o menos adecuadamente a 32- los mordidos  Todas las dem√°s opciones, incluidas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las</a> operaciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SIMD</a> , nos obligan a sacrificar en gran medida la portabilidad y / o velocidad en plataformas no nativas. </p><br><p>  <strong>Resultado de 64 bits</strong> : para construir tablas hash, en muchos casos, un resultado de ancho de bits m√°s peque√±o es suficiente.  Incluso 32 bits pueden ser m√°s que suficientes.  Sin embargo, cuando se utilizan operaciones de 64 bits, el resultado de 64 bits es algo natural.  Al mismo tiempo, un resultado hash de 64 bits de calidad suficientemente alta le permite realizar r√°pidamente una comparaci√≥n para determinar la no igualdad, y con buena precisi√≥n para comparar la igualdad. </p><br><p>  La "magia" anterior de reemplazar las comparaciones puede parecer poco clara e innecesaria, o puede <strong>aumentar la velocidad de hash en un orden de magnitud</strong> solo por medio de la localidad de los datos, es decir, menos contaminaci√≥n de la memoria cach√© de la CPU.  En pocas palabras, se puede construir una estructura de tabla hash de tal manera que los valores hash calculados se encuentren uno al lado del otro (empaquetados en l√≠neas de cach√©).  La CPU solo tomar√≠a los datos reales si los valores hash coincidieran.  Y en este caso, los <em>64 bits de t1ha permiten obtener el mejor resultado posible</em> .  Dicho esto, 128 bits ya no proporcionar√°n una ventaja, mientras que tomar menos de 64 bits siempre es posible. </p><br><p>  <strong>Comparaci√≥n con HighwayHash</strong> : Tengo sentimientos encontrados sobre este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto no oficial de los empleados de Google</a> . </p><br><ol><li>  Por un lado, tiene un buen c√≥digo y una excelente implementaci√≥n t√©cnica.  Por otro lado, <em>HighwayHash</em> se posiciona como <em>posiblemente</em> criptogr√°ficamente fuerte (al menos igual a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SipHash</a> ).  Dentro de HighwayHash hay bastantes manipulaciones que nos permiten esperar que el resultado no sea malo.  Sin embargo, no hay pruebas que nos permitan decir eso de manera confiable.  La prueba provista de "fuerza" se reduce a los resultados de las pruebas estad√≠sticas, pero sin capacidad de reproducirlos (en un punto incluso me permit√≠ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comentario</a> algo superfluo). </li><li>  HighwayHash es realmente r√°pido solo en x86_64 con AVX2 o SSE41.  ¬øNo es m√°s f√°cil simplemente usar la aceleraci√≥n AES-NI o ‚Äã‚ÄãSHA? </li></ol><br><p>  Si todo va bien, se agregar√°n opciones adicionales a la suite t1ha (principalmente para el bitness resultante) y se optimizar√°n para E2K.  Con esto me gustar√≠a cerrar el tema de las comparaciones con HighwayHash. </p></div></div><br><hr><br><h2 id="quality">  Calidad </h2><br><p>  Evaluar la calidad de una funci√≥n hash en todos los aspectos puede ser bastante dif√≠cil.  Se puede hacer anal√≠ticamente o implementando varias pruebas estad√≠sticas.  Desafortunadamente, el enfoque anal√≠tico no es muy efectivo para evaluar las funciones hash con un compromiso entre calidad y velocidad.  Adem√°s, una evaluaci√≥n anal√≠tica comparativa de tales funciones tiende a ser subjetiva. </p><br><p>  En contraste, las pruebas estad√≠sticas pueden proporcionar estimaciones cuantitativas claras.  Para tales fines, hay paquetes de prueba bien probados, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMHasher</a> .  Para <em>t1ha</em> , los resultados son simples: todas <strong>las opciones de t1ha</strong> pasan todas las pruebas sin ning√∫n comentario.  Por otro lado, no se debe suponer que t1ha tiene propiedades superiores a las necesarias para la aplicaci√≥n de destino (creaci√≥n de tablas hash). </p><br><p>  El n√∫mero de colisiones en todos los niveles (variantes) de <strong>t1ha</strong> corresponde a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paradoja del cumplea√±os</a> .  Para formularlo estrictamente, la probabilidad de colisi√≥n en <strong>t1ha</strong> corresponde a la probabilidad de coincidencia de valores discretos aleatorios con el bitness correspondiente. <br>  Se observa una probabilidad similar de colisiones en todas las funciones hash de alta calidad.  Sin embargo, esto es solo una probabilidad, por lo que el n√∫mero real de colisiones puede variar para cada conjunto de datos espec√≠fico. </p><br><p> Despu√©s de que este art√≠culo se publicara por primera vez, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yves Orton descubri√≥</a> que el primer <code>t1ha1()</code> no siempre cumple con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estricto criterio de avalancha</a> .  Este inconveniente es insignificante para aplicaciones espec√≠ficas de <code>t1ha1()</code> e imperceptible desde un punto de vista pr√°ctico.  Sin embargo, esta desventaja se elimina en el siguiente nivel / variante <code>t1ha2()</code> , que originalmente se plane√≥ para proporcionar una calidad ligeramente superior.  En los nuevos procesadores, que usan versiones actuales de compiladores, <code>t1ha2()</code> es en promedio un ciclo m√°s r√°pido que <code>t1ha1()</code> , y en el resto de los casos puede ser un ciclo m√°s lento.  Vale la pena se√±alar que <code>t1ha2()</code> tambi√©n ofrece el modo hash de flujo y un resultado de 128 bits. </p><br><p>  Los lectores sin duda apreciar√°n un an√°lisis exhaustivo y profundo de la calidad y / o resistencia de <strong>t1ha</strong> .  Sin embargo, seg√∫n las √°reas de aplicaci√≥n de <strong>t1ha</strong> objetivo, esto parece redundante.  En pocas palabras, la velocidad era m√°s importante para nosotros, incluso para las teclas cortas.  Por lo tanto, no se consider√≥ la mezcla multi-ronda.  La versi√≥n actual de <em>t1ha</em> ahorra en ciclos y ofrece un resultado de 64 bits: es pr√°cticamente in√∫til medir el compromiso encontrado de otra manera que no sea estad√≠sticamente, y sus resultados son simplemente buenos. </p><br><div class="spoiler">  <b class="spoiler_title">De hecho</b> <div class="spoiler_text"><p>  Acabo de seguir a mis colegas de Google en c√≥mo proporcionan su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba estad√≠stica</a> </p></div></div><br><hr><br><h2 id="benchmarks">  Puntos de referencia </h2><br><p>  En cuanto a la afirmaci√≥n de ser " <em>el m√°s r√°pido</em> ".  Es importante tener en cuenta que obviamente no es probable que haya una funci√≥n hash que sea al mismo tiempo √∫til y m√°s r√°pida en todas las plataformas / arquitecturas.  Los diferentes procesadores tienen diferentes conjuntos de instrucciones disponibles y ejecutan instrucciones similares con diferentes eficiencias.  Obviamente, la funci√≥n " <em>universalmente m√°s r√°pida</em> " probablemente no se puede crear.  Sin embargo, parece aceptable usar el t√©rmino "el <br>  m√°s r√°pido ¬ªpara una funci√≥n que es port√°til y al mismo tiempo la m√°s r√°pida, al menos en la plataforma m√°s com√∫n (x86_64), mientras que tiene pocas posibilidades de perder en cualquier procesador moderno con un compilador decente de optimizaci√≥n. </p><br><p>  El c√≥digo fuente del proyecto incluye una prueba que verifica la exactitud del resultado y mide la velocidad de cada variante implementada.  Al mismo tiempo, en x86, dependiendo de las capacidades del procesador (y del compilador), se pueden verificar variantes adicionales de funciones, y las mediciones se realizan en ciclos de procesador. </p><br><p>  Adem√°s, el sitio web del proyecto contiene tablas con los resultados de las mediciones de rendimiento a trav√©s de una versi√≥n modificada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMHasher de Reini Urban</a> .  Uno puede verificar todas las cifras y / u obtener resultados en un procesador espec√≠fico utilizando un compilador espec√≠fico. </p><br><p>  Aqu√≠ puede comparar t1ha con algunos de sus competidores m√°s cercanos. </p><br><p>  <strong>Hashing teclas cortas</strong> (promedio de 1..31 bytes). <br>  <em>Mire la columna derecha "Ciclos / Hash" (m√°s peque√±o es mejor)</em> : </p><br><table><thead><tr><th>  Funci√≥n </th><th>  MiB / Segundo </th><th>  Ciclos / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Fasthash64 </td><td>  5578,06 </td><td>  43,42 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Metrohash </td><td>  11808.92 </td><td>  46,33 </td></tr></tbody></table><br><p>  <strong>Hashing claves largas</strong> (256 Kb). <br>  <em>Mire la columna central "MiB / Second" (m√°s grande es mejor)</em> : </p><br><table><thead><tr><th>  Funci√≥n </th><th>  MiB / Segundo </th><th>  Ciclos / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60,12 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Espeluznante64 </td><td>  11820.20 </td><td>  60,39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Variantes de t1ha </h2><br><p>  Desarrollo de <strong>t1ha</strong> El primero de estos objetivos era obtener una funci√≥n port√°til r√°pida de calidad suficientemente alta para construir tablas hash. </p><br><p>  Luego, quer√≠amos tener la versi√≥n m√°s r√°pida de la funci√≥n hash que ofreciera un resultado de calidad comparable pero que se adaptara a la plataforma objetivo tanto como fuera posible.  Por ejemplo, la versi√≥n b√°sica de <strong>t1ha</strong> funciona con el orden de bytes little-endian, debido a lo cual es necesaria una conversi√≥n para arquitecturas big-endian con p√©rdida inevitable de rendimiento.  Entonces, ¬øpor qu√© no deshacerse de las operaciones innecesarias en una plataforma de destino espec√≠fica?  De esta manera, se agregaron varias opciones m√°s: </p><br><ul><li>  Versi√≥n simplificada para plataformas de 32 bits, tanto peque√±as como big endian. </li><li>  Variante que utiliza instrucciones AES-NI, pero sin AVX. </li><li>  Dos variantes utilizando las instrucciones AES-NI y AVX. </li></ul><br><p>  M√°s tarde se hizo evidente que se necesitar√≠an m√°s opciones dise√±adas para diversas aplicaciones, incluidos los diferentes resultados de ancho de bits, calidad y requisitos de durabilidad.  Tal diversidad requer√≠a una sistematizaci√≥n adecuada.  Esto se logr√≥ cambiando el esquema de nomenclatura, en el que el sufijo num√©rico indica el "nivel" de la funci√≥n: </p><br><ul><li>  <code>t1ha0()</code> : es la opci√≥n m√°s r√°pida para el procesador actual. </li><li>  <code>t1ha1()</code> : es la versi√≥n b√°sica port√°til de 64 bits de t1ha. </li><li>  <code>t1ha2()</code> : es una versi√≥n port√°til de 64 bits con un poco m√°s de preocupaci√≥n por la calidad. </li><li>  <code>t1ha3()</code> - es una versi√≥n port√°til r√°pida de 128 bits para <code>t1ha3()</code> huellas digitales. </li><li>  etc. </li></ul><br><p>  En este esquema, se supone que <code>t1ha0()</code> es un despachador que implementa la redirecci√≥n dependiendo de la plataforma y las capacidades del procesador actual.  Adem√°s, se puede introducir el uso de los sufijos "_le" y "_be" para una elecci√≥n expl√≠cita entre las variantes little-endian y big-endian.  Por lo tanto, bajo el letrero "t1ha" ahora hay varias funciones hash, y esta familia crecer√° en el futuro, incluida una versi√≥n optimizada para E2K ruso "Elbrus". </p><br><p>  Una idea general del conjunto actual de funciones y sus propiedades se puede captar mirando la salida de prueba incorporada ( <code>make check</code> ).  Vale la pena se√±alar que todas las funciones pasan todas las pruebas de SM Hasher, y el rendimiento de las variantes AES-NI var√≠a mucho seg√∫n el modelo de procesador: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Un poco sobre la estructura interna.</b> <div class="spoiler_text"><p>  Para ahondar un poco m√°s en los detalles, <strong>t1ha</strong> se construye de acuerdo con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esquema Merkle-Damg√•rd</a> (versi√≥n "wipe-pipe") con el fortalecimiento del tama√±o de los datos y el valor de la semilla.  Dentro del bucle de compresi√≥n principal, se utiliza un estado de 256 bits, con el mismo tama√±o del bloque de entrada.  Adem√°s, para cada operando de datos hay dos puntos de inyecci√≥n con polinizaci√≥n cruzada.  Al finalizar el ciclo de compresi√≥n, el estado de 256 bits se comprime a 128 bits. </p><br><p>  Al realizar las acciones anteriores, se utilizan operaciones de 64 bits, combinadas en los mezcladores ARX (Add-Rotate-Xor) y MUX / MRX (Mul-Rotate-Xor).  Es importante que todos estos c√°lculos se construyan de tal manera que se garantice la posibilidad de ejecuci√≥n paralela de la mayor√≠a de las operaciones y el empaquetamiento estrecho de las operaciones u tanto en la tuber√≠a como en las unidades de ejecuci√≥n x86_64.  Debido a esto, se logra una calidad suficientemente buena con una tasa de hash casi m√°xima para claves largas. </p><br><p>  Vale la pena se√±alar que el bucle de compresi√≥n se ejecuta solo para bloques de tama√±o suficiente.  Si hay menos datos, el estado intermedio de 128 bits consistir√° solo en el tama√±o de la clave y el valor de sal. </p><br><p>  Luego, la cola restante de los datos se mezcla en porciones de 64 bits alternativamente a las mitades del estado de 128 bits.  Finalmente, el estado se mezcla y se comprime simult√°neamente a un resultado de 64 bits.  Una caracter√≠stica importante de t1ha aqu√≠ es el uso de un mezclador basado en una multiplicaci√≥n amplia (producto de 128 bits de dos multiplicadores de 64 bits).  Esto permite una mezcla de buena calidad con un buen efecto de avalancha y menos operaciones.  Aunque la multiplicaci√≥n amplia es una operaci√≥n relativamente costosa, menos operaciones de este tipo permiten que t1ha procese teclas cortas en un n√∫mero de ciclos de procesador con un registro bajo. </p><br><p>  Cabe se√±alar que el mezclador basado en multiplicaci√≥n amplia y OR exclusivo no es perfecto.  Aunque <em>t1ha</em> pasa todas las pruebas <em>SMHasher</em> , el autor comprende las consecuencias de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no inyectividad</a> ).  Sin embargo, la calidad resultante parece ser racionalmente suficiente, y los planes de desarrollo para la l√≠nea t1ha ya reflejan la intenci√≥n de proporcionar opciones de calidad ligeramente superiores. </p></div></div><br><p>  Puede encontrar m√°s informaci√≥n y c√≥digo fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  <em>Gracias por leer!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439156/">https://habr.com/ru/post/439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439142/index.html">Dise√±ar modelos de madurez</a></li>
<li><a href="../439148/index.html">Trabaje con nRF51822 utilizando ST-Link y Clion + OpenOCD</a></li>
<li><a href="../439150/index.html">¬øQui√©n debe pagar los costos de transacci√≥n?</a></li>
<li><a href="../439152/index.html">Salarios en TI en la segunda mitad de 2018: seg√∫n la calculadora de salarios "My Circle"</a></li>
<li><a href="../439154/index.html">C√≥mo viven los freelancers: dise√±o de portadas de libros, producci√≥n propia de mochilas y viajes</a></li>
<li><a href="../439158/index.html">DataArt lanza el servicio gratuito de mejora de curr√≠culum CV Duck</a></li>
<li><a href="../439160/index.html">Estado del algoritmo: ¬øqu√© les sucede a los desarrolladores independientes en Steam?</a></li>
<li><a href="../439162/index.html">C√≥mo depurar frontend y backend: instrucciones paso a paso</a></li>
<li><a href="../439166/index.html">mmWave en camino a la comercializaci√≥n en el formato de tel√©fono inteligente</a></li>
<li><a href="../439168/index.html">Sistemas de an√°lisis de clientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>