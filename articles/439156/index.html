<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐽 🐔 🍹 t1ha = Hash positivo rápido 🛫 🐝 🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Casi la función hash portátil de 64 bits más rápida con una calidad decente. 


 Esta es una traducción del artículo original de Leonid Yuriev . 
 En ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = Hash positivo rápido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  Casi la función hash portátil de 64 bits más rápida con una calidad decente. </p><br><p> Esta es una traducción del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">En lugar de un descargo de responsabilidad</b> <div class="spoiler_text"><p>  Omitiré la definición de funciones hash junto con la lista detallada de las propiedades y requisitos para su aplicación criptográfica, y supondré que el lector tiene el conocimiento mínimo necesario o lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leerá</a> .  También se debe tener en cuenta que, en lo sucesivo, hablaré sobre funciones hash no criptográficas (no adecuadas para la criptografía), a menos que se indique explícitamente lo contrario. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banalidades</b> <div class="spoiler_text"><p>  El hash se usa en muchos algoritmos, y casi siempre se requiere el procesamiento de datos más eficiente (rápido), junto con un cierto nivel mínimo de calidad de hash.  Aquí el término "calidad" significa, en primer lugar, una especie de "aleatoriedad" (estocasticidad) en relación con los datos iniciales.  Con menos frecuencia se imponen requisitos adicionales, como resistencia a la generación deliberada de colisiones o irreversibilidad. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Para ser un poco más tedioso</b> <div class="spoiler_text"><p>  Para mayor claridad, es necesario definir el concepto de "calidad" de la función hash y el resto de los requisitos con un poco más de detalle: <br>  Calidad de línea de base y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">efecto de avalancha</a> : cambiar uno o más bits arbitrarios en un conjunto arbitrario de datos de origen hace que cada bit del resultado cambie con una probabilidad de ½. </p><br><ul><li>  Irreversibilidad o primera resistencia previa a la imagen: la imposibilidad de obtener los datos originales o bits individuales del resultado de hash. </li><li>  Resistencia a colisiones de primer orden y / o resistencia previa a la segunda imagen: la dificultad de encontrar / ajustar el conjunto de datos original para obtener un resultado específico o parte de él, incluso cuando se conoce el conjunto de datos inicial. </li><li>  Resistencia a colisiones de segundo orden: la dificultad de encontrar / ajustar dos conjuntos de datos diferentes que darían el mismo resultado o una coincidencia de una parte significativa. </li></ul></div></div><br><p>  Omitiendo largas citas de las matemáticas subyacentes, se puede resumir: </p><br><ul><li>  Satisfacer todos los requisitos anteriores al tiempo que garantiza un alto rendimiento es un problema bastante difícil, resolver lo que nos daría una buena función hash criptográfica.  Pero todavía no vamos a hacer esto. </li><li>  Proporcionar calidad básica requiere un número suficientemente grande de operaciones de ALU.  En pocas palabras, la calidad siempre compromete con la velocidad. </li><li>  La obtención de un resultado de alta calidad con un ancho de bits mayor que el ancho de bits de las operaciones de ALU requiere un aumento de varias veces en el número de mezclas y, por lo tanto, operaciones básicas de ALU. </li><li>  En general, <em>crear una función hash rápida implica lograr un compromiso ponderado entre velocidad, calidad y bitness de resultado</em> . </li></ul><br><p>  Por lo tanto, puedo decir que <strong>t1ha</strong> apareció como resultado de la búsqueda de un compromiso entre calidad y velocidad, al mismo tiempo teniendo en cuenta las capacidades de los procesadores modernos y los métodos ya encontrados (combinaciones lógico-aritméticas) de mezclar y distribuir dependencias ( efecto avalancha). </p><br><p>  La versión básica de <strong>t1ha</strong> es una de las funciones hash portátiles más rápidas para construir tablas hash y otras aplicaciones relacionadas.  La versión básica de <strong>t1ha</strong> se centra en arquitecturas little-endian de 64 bits, toma un valor de sal (semilla) de 64 bits y produce un resultado de 64 bits, que incluye el fortalecimiento por longitud de clave y semilla.  Vale la pena señalar que <strong>t1ha</strong> está diseñado intencionalmente para devolver 0 para datos de entrada cero (una clave de tamaño cero y cero semilla). </p><br><div class="spoiler">  <b class="spoiler_title">Respondiendo las preguntas más populares</b> <div class="spoiler_text"><p>  <strong>Operaciones de 64 bits</strong> : Quizás se debe tener en cuenta que son las operaciones de 64 bits las que proporcionan velocidad y calidad sin perjudicar la portabilidad.  De hecho, cuanto mayor es la capacidad de dígitos de las operaciones aritméticas, más efecto de avalancha producen y mejor mezclan los datos.  Además, el procesamiento de datos, en igualdad de condiciones, es ciertamente más rápido en 8 bytes que en 4. Por otro lado, las operaciones de 64 bits están disponibles de forma nativa en muchos procesadores modernos y pueden traducirse más o menos adecuadamente a 32- los mordidos  Todas las demás opciones, incluidas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las</a> operaciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SIMD</a> , nos obligan a sacrificar en gran medida la portabilidad y / o velocidad en plataformas no nativas. </p><br><p>  <strong>Resultado de 64 bits</strong> : para construir tablas hash, en muchos casos, un resultado de ancho de bits más pequeño es suficiente.  Incluso 32 bits pueden ser más que suficientes.  Sin embargo, cuando se utilizan operaciones de 64 bits, el resultado de 64 bits es algo natural.  Al mismo tiempo, un resultado hash de 64 bits de calidad suficientemente alta le permite realizar rápidamente una comparación para determinar la no igualdad, y con buena precisión para comparar la igualdad. </p><br><p>  La "magia" anterior de reemplazar las comparaciones puede parecer poco clara e innecesaria, o puede <strong>aumentar la velocidad de hash en un orden de magnitud</strong> solo por medio de la localidad de los datos, es decir, menos contaminación de la memoria caché de la CPU.  En pocas palabras, se puede construir una estructura de tabla hash de tal manera que los valores hash calculados se encuentren uno al lado del otro (empaquetados en líneas de caché).  La CPU solo tomaría los datos reales si los valores hash coincidieran.  Y en este caso, los <em>64 bits de t1ha permiten obtener el mejor resultado posible</em> .  Dicho esto, 128 bits ya no proporcionarán una ventaja, mientras que tomar menos de 64 bits siempre es posible. </p><br><p>  <strong>Comparación con HighwayHash</strong> : Tengo sentimientos encontrados sobre este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto no oficial de los empleados de Google</a> . </p><br><ol><li>  Por un lado, tiene un buen código y una excelente implementación técnica.  Por otro lado, <em>HighwayHash</em> se posiciona como <em>posiblemente</em> criptográficamente fuerte (al menos igual a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SipHash</a> ).  Dentro de HighwayHash hay bastantes manipulaciones que nos permiten esperar que el resultado no sea malo.  Sin embargo, no hay pruebas que nos permitan decir eso de manera confiable.  La prueba provista de "fuerza" se reduce a los resultados de las pruebas estadísticas, pero sin capacidad de reproducirlos (en un punto incluso me permití un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comentario</a> algo superfluo). </li><li>  HighwayHash es realmente rápido solo en x86_64 con AVX2 o SSE41.  ¿No es más fácil simplemente usar la aceleración AES-NI o ​​SHA? </li></ol><br><p>  Si todo va bien, se agregarán opciones adicionales a la suite t1ha (principalmente para el bitness resultante) y se optimizarán para E2K.  Con esto me gustaría cerrar el tema de las comparaciones con HighwayHash. </p></div></div><br><hr><br><h2 id="quality">  Calidad </h2><br><p>  Evaluar la calidad de una función hash en todos los aspectos puede ser bastante difícil.  Se puede hacer analíticamente o implementando varias pruebas estadísticas.  Desafortunadamente, el enfoque analítico no es muy efectivo para evaluar las funciones hash con un compromiso entre calidad y velocidad.  Además, una evaluación analítica comparativa de tales funciones tiende a ser subjetiva. </p><br><p>  En contraste, las pruebas estadísticas pueden proporcionar estimaciones cuantitativas claras.  Para tales fines, hay paquetes de prueba bien probados, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMHasher</a> .  Para <em>t1ha</em> , los resultados son simples: todas <strong>las opciones de t1ha</strong> pasan todas las pruebas sin ningún comentario.  Por otro lado, no se debe suponer que t1ha tiene propiedades superiores a las necesarias para la aplicación de destino (creación de tablas hash). </p><br><p>  El número de colisiones en todos los niveles (variantes) de <strong>t1ha</strong> corresponde a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paradoja del cumpleaños</a> .  Para formularlo estrictamente, la probabilidad de colisión en <strong>t1ha</strong> corresponde a la probabilidad de coincidencia de valores discretos aleatorios con el bitness correspondiente. <br>  Se observa una probabilidad similar de colisiones en todas las funciones hash de alta calidad.  Sin embargo, esto es solo una probabilidad, por lo que el número real de colisiones puede variar para cada conjunto de datos específico. </p><br><p> Después de que este artículo se publicara por primera vez, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yves Orton descubrió</a> que el primer <code>t1ha1()</code> no siempre cumple con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estricto criterio de avalancha</a> .  Este inconveniente es insignificante para aplicaciones específicas de <code>t1ha1()</code> e imperceptible desde un punto de vista práctico.  Sin embargo, esta desventaja se elimina en el siguiente nivel / variante <code>t1ha2()</code> , que originalmente se planeó para proporcionar una calidad ligeramente superior.  En los nuevos procesadores, que usan versiones actuales de compiladores, <code>t1ha2()</code> es en promedio un ciclo más rápido que <code>t1ha1()</code> , y en el resto de los casos puede ser un ciclo más lento.  Vale la pena señalar que <code>t1ha2()</code> también ofrece el modo hash de flujo y un resultado de 128 bits. </p><br><p>  Los lectores sin duda apreciarán un análisis exhaustivo y profundo de la calidad y / o resistencia de <strong>t1ha</strong> .  Sin embargo, según las áreas de aplicación de <strong>t1ha</strong> objetivo, esto parece redundante.  En pocas palabras, la velocidad era más importante para nosotros, incluso para las teclas cortas.  Por lo tanto, no se consideró la mezcla multi-ronda.  La versión actual de <em>t1ha</em> ahorra en ciclos y ofrece un resultado de 64 bits: es prácticamente inútil medir el compromiso encontrado de otra manera que no sea estadísticamente, y sus resultados son simplemente buenos. </p><br><div class="spoiler">  <b class="spoiler_title">De hecho</b> <div class="spoiler_text"><p>  Acabo de seguir a mis colegas de Google en cómo proporcionan su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba estadística</a> </p></div></div><br><hr><br><h2 id="benchmarks">  Puntos de referencia </h2><br><p>  En cuanto a la afirmación de ser " <em>el más rápido</em> ".  Es importante tener en cuenta que obviamente no es probable que haya una función hash que sea al mismo tiempo útil y más rápida en todas las plataformas / arquitecturas.  Los diferentes procesadores tienen diferentes conjuntos de instrucciones disponibles y ejecutan instrucciones similares con diferentes eficiencias.  Obviamente, la función " <em>universalmente más rápida</em> " probablemente no se puede crear.  Sin embargo, parece aceptable usar el término "el <br>  más rápido »para una función que es portátil y al mismo tiempo la más rápida, al menos en la plataforma más común (x86_64), mientras que tiene pocas posibilidades de perder en cualquier procesador moderno con un compilador decente de optimización. </p><br><p>  El código fuente del proyecto incluye una prueba que verifica la exactitud del resultado y mide la velocidad de cada variante implementada.  Al mismo tiempo, en x86, dependiendo de las capacidades del procesador (y del compilador), se pueden verificar variantes adicionales de funciones, y las mediciones se realizan en ciclos de procesador. </p><br><p>  Además, el sitio web del proyecto contiene tablas con los resultados de las mediciones de rendimiento a través de una versión modificada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMHasher de Reini Urban</a> .  Uno puede verificar todas las cifras y / u obtener resultados en un procesador específico utilizando un compilador específico. </p><br><p>  Aquí puede comparar t1ha con algunos de sus competidores más cercanos. </p><br><p>  <strong>Hashing teclas cortas</strong> (promedio de 1..31 bytes). <br>  <em>Mire la columna derecha "Ciclos / Hash" (más pequeño es mejor)</em> : </p><br><table><thead><tr><th>  Función </th><th>  MiB / Segundo </th><th>  Ciclos / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Fasthash64 </td><td>  5578,06 </td><td>  43,42 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Metrohash </td><td>  11808.92 </td><td>  46,33 </td></tr></tbody></table><br><p>  <strong>Hashing claves largas</strong> (256 Kb). <br>  <em>Mire la columna central "MiB / Second" (más grande es mejor)</em> : </p><br><table><thead><tr><th>  Función </th><th>  MiB / Segundo </th><th>  Ciclos / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60,12 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Espeluznante64 </td><td>  11820.20 </td><td>  60,39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Variantes de t1ha </h2><br><p>  Desarrollo de <strong>t1ha</strong> El primero de estos objetivos era obtener una función portátil rápida de calidad suficientemente alta para construir tablas hash. </p><br><p>  Luego, queríamos tener la versión más rápida de la función hash que ofreciera un resultado de calidad comparable pero que se adaptara a la plataforma objetivo tanto como fuera posible.  Por ejemplo, la versión básica de <strong>t1ha</strong> funciona con el orden de bytes little-endian, debido a lo cual es necesaria una conversión para arquitecturas big-endian con pérdida inevitable de rendimiento.  Entonces, ¿por qué no deshacerse de las operaciones innecesarias en una plataforma de destino específica?  De esta manera, se agregaron varias opciones más: </p><br><ul><li>  Versión simplificada para plataformas de 32 bits, tanto pequeñas como big endian. </li><li>  Variante que utiliza instrucciones AES-NI, pero sin AVX. </li><li>  Dos variantes utilizando las instrucciones AES-NI y AVX. </li></ul><br><p>  Más tarde se hizo evidente que se necesitarían más opciones diseñadas para diversas aplicaciones, incluidos los diferentes resultados de ancho de bits, calidad y requisitos de durabilidad.  Tal diversidad requería una sistematización adecuada.  Esto se logró cambiando el esquema de nomenclatura, en el que el sufijo numérico indica el "nivel" de la función: </p><br><ul><li>  <code>t1ha0()</code> : es la opción más rápida para el procesador actual. </li><li>  <code>t1ha1()</code> : es la versión básica portátil de 64 bits de t1ha. </li><li>  <code>t1ha2()</code> : es una versión portátil de 64 bits con un poco más de preocupación por la calidad. </li><li>  <code>t1ha3()</code> - es una versión portátil rápida de 128 bits para <code>t1ha3()</code> huellas digitales. </li><li>  etc. </li></ul><br><p>  En este esquema, se supone que <code>t1ha0()</code> es un despachador que implementa la redirección dependiendo de la plataforma y las capacidades del procesador actual.  Además, se puede introducir el uso de los sufijos "_le" y "_be" para una elección explícita entre las variantes little-endian y big-endian.  Por lo tanto, bajo el letrero "t1ha" ahora hay varias funciones hash, y esta familia crecerá en el futuro, incluida una versión optimizada para E2K ruso "Elbrus". </p><br><p>  Una idea general del conjunto actual de funciones y sus propiedades se puede captar mirando la salida de prueba incorporada ( <code>make check</code> ).  Vale la pena señalar que todas las funciones pasan todas las pruebas de SM Hasher, y el rendimiento de las variantes AES-NI varía mucho según el modelo de procesador: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Un poco sobre la estructura interna.</b> <div class="spoiler_text"><p>  Para ahondar un poco más en los detalles, <strong>t1ha</strong> se construye de acuerdo con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esquema Merkle-Damgård</a> (versión "wipe-pipe") con el fortalecimiento del tamaño de los datos y el valor de la semilla.  Dentro del bucle de compresión principal, se utiliza un estado de 256 bits, con el mismo tamaño del bloque de entrada.  Además, para cada operando de datos hay dos puntos de inyección con polinización cruzada.  Al finalizar el ciclo de compresión, el estado de 256 bits se comprime a 128 bits. </p><br><p>  Al realizar las acciones anteriores, se utilizan operaciones de 64 bits, combinadas en los mezcladores ARX (Add-Rotate-Xor) y MUX / MRX (Mul-Rotate-Xor).  Es importante que todos estos cálculos se construyan de tal manera que se garantice la posibilidad de ejecución paralela de la mayoría de las operaciones y el empaquetamiento estrecho de las operaciones u tanto en la tubería como en las unidades de ejecución x86_64.  Debido a esto, se logra una calidad suficientemente buena con una tasa de hash casi máxima para claves largas. </p><br><p>  Vale la pena señalar que el bucle de compresión se ejecuta solo para bloques de tamaño suficiente.  Si hay menos datos, el estado intermedio de 128 bits consistirá solo en el tamaño de la clave y el valor de sal. </p><br><p>  Luego, la cola restante de los datos se mezcla en porciones de 64 bits alternativamente a las mitades del estado de 128 bits.  Finalmente, el estado se mezcla y se comprime simultáneamente a un resultado de 64 bits.  Una característica importante de t1ha aquí es el uso de un mezclador basado en una multiplicación amplia (producto de 128 bits de dos multiplicadores de 64 bits).  Esto permite una mezcla de buena calidad con un buen efecto de avalancha y menos operaciones.  Aunque la multiplicación amplia es una operación relativamente costosa, menos operaciones de este tipo permiten que t1ha procese teclas cortas en un número de ciclos de procesador con un registro bajo. </p><br><p>  Cabe señalar que el mezclador basado en multiplicación amplia y OR exclusivo no es perfecto.  Aunque <em>t1ha</em> pasa todas las pruebas <em>SMHasher</em> , el autor comprende las consecuencias de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no inyectividad</a> ).  Sin embargo, la calidad resultante parece ser racionalmente suficiente, y los planes de desarrollo para la línea t1ha ya reflejan la intención de proporcionar opciones de calidad ligeramente superiores. </p></div></div><br><p>  Puede encontrar más información y código fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  <em>Gracias por leer!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439156/">https://habr.com/ru/post/439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439142/index.html">Diseñar modelos de madurez</a></li>
<li><a href="../439148/index.html">Trabaje con nRF51822 utilizando ST-Link y Clion + OpenOCD</a></li>
<li><a href="../439150/index.html">¿Quién debe pagar los costos de transacción?</a></li>
<li><a href="../439152/index.html">Salarios en TI en la segunda mitad de 2018: según la calculadora de salarios "My Circle"</a></li>
<li><a href="../439154/index.html">Cómo viven los freelancers: diseño de portadas de libros, producción propia de mochilas y viajes</a></li>
<li><a href="../439158/index.html">DataArt lanza el servicio gratuito de mejora de currículum CV Duck</a></li>
<li><a href="../439160/index.html">Estado del algoritmo: ¿qué les sucede a los desarrolladores independientes en Steam?</a></li>
<li><a href="../439162/index.html">Cómo depurar frontend y backend: instrucciones paso a paso</a></li>
<li><a href="../439166/index.html">mmWave en camino a la comercialización en el formato de teléfono inteligente</a></li>
<li><a href="../439168/index.html">Sistemas de análisis de clientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>