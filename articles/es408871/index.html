<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïô üê∞ üñêüèª Sesi√≥n de video transmisi√≥n de sonido a trav√©s del agua con exposici√≥n üë®üèæ‚Äçü§ù‚Äçüë®üèª üçª üë®üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Äú¬°El Se√±or Todopoderoso! ¬°Parece que acabo de matar al Sr. May! ... Pero sea como sea, continuamos ‚Äù(C) J. Clarkson 
 En este art√≠culo, le dir√© c√≥mo t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sesi√≥n de video transmisi√≥n de sonido a trav√©s del agua con exposici√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408871/"><blockquote>  ‚Äú¬°El Se√±or Todopoderoso!  ¬°Parece que acabo de matar al Sr. May! ... Pero sea como sea, continuamos ‚Äù(C) J. Clarkson </blockquote><br>  En este art√≠culo, le dir√© c√≥mo transferir video (bueno, casi video) usando sonido a trav√©s del agua usando una computadora port√°til com√∫n, un cable, dos conectores de 3,5 mm y dos piezo tweeter.  Tambi√©n explicar√© por qu√© y c√≥mo funciona, contar√© una historia divertida sobre c√≥mo se nos ocurri√≥ esto.  Y como guinda de un pastel, se adjunta un art√≠culo sobre C # con c√≥digos fuente para que todos los interesados ‚Äã‚Äãpuedan probarlo ellos mismos, porque el conocimiento cient√≠fico es verificable, ¬øno? <br><a name="habracut"></a><br>  Si de repente el lector quiere profundizar un poco m√°s en los temas del sonar, le sugiero que se familiarice con nuestras publicaciones anteriores, donde hablamos sobre nuestros proyectos de una manera que revela las dificultades de transmitir informaci√≥n a trav√©s del agua: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GPS subacu√°tico desde cero por a√±o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GPS subacu√°tico: continuaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Navegaci√≥n bajo el agua: b√∫squeda de direcci√≥n: no busque direcci√≥n, est√° condenado al √©xito</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sobre el efecto de las cianobacterias en las funciones del habla del presidente</a> <br><br>  En general, se debe aprender una verdad simple: el video a trav√©s del agua a cualquier distancia significativa (bueno, al menos cientos de metros) no se puede transmitir utilizando la ac√∫stica.  El punto es la banda de frecuencia disponible extremadamente estrecha y la fuerte desigualdad de la atenuaci√≥n de las diferentes frecuencias con la distancia.  Las ventajas son el ruido, la propagaci√≥n por trayectos m√∫ltiples, la reverberaci√≥n, el cambio en la velocidad del sonido en el medio de la densidad (es decir, la presi√≥n, la temperatura y la salinidad), el efecto Doppler, que por cierto no funciona del todo como en las comunicaciones por radio. <br><br>  Los l√≠mites de velocidad para los m√≥dems de sonda m√°s avanzados est√°n muy lejos de poder transmitir video.  Hasta donde yo s√©, el registro pertenece a EvoLogics y asciende a 62.5 kbps con una distancia m√°xima establecida de 300 metros.  Adem√°s, las palabras sobre la imposibilidad de transmitir sonido de video a trav√©s del agua (a distancias razonables) solo pertenecen a Konstantin Georgievich, fundador y director de EvoLogics. <br><br>  Cuando era investigador en el Instituto de Investigaci√≥n de Hidrocomunicaci√≥n, completamente inconsciente, quer√≠a grandes logros, <s>victorias en el norte y en el sur, gran aflojamiento de los suelos</s> (no, todav√≠a los quiero, pero no estaba cargado de experiencia y conocimiento). todo parec√≠a casi m√°gico y fabuloso).  En nuestro equipo de esa √©poca (parte del cual es el m√≠o real), a menudo fantaseamos con algunos proyectos de sonar poco realistas, hurgamos en un <s>vertedero</s> y tratamos de utilizar todo tipo de artefactos de una gran civilizaci√≥n antigua en fila, de los cuales este instituto de investigaci√≥n est√° tratando en parte de comprender el tao de la comunicaci√≥n sonar. . <br><br>  La inmersi√≥n en esos recuerdos evoca sentimientos conflictivos en m√≠.  Entonces nada pareci√≥ y nadie pudo detenernos: noqueamos una fresadora china del director para la creaci√≥n de prototipos de productos, ensamblamos cuerpos normob√°ricos de las tuber√≠as de agua holandesas Van De Lande, cuyo fabricante incluso escribi√≥ una carta sobre el tema: "¬øHas verificado accidentalmente qu√© ¬øSus tuber√≠as soportan la presi√≥n externa?  Recogieron modelos de placas de pan por su propio dinero en contenedores para el desayuno y salieron a prueba en secreto para obtener orientaci√≥n, recolectar taladros de hielo y trineos para colegas y parientes, e incluso compraron un bote chino de PVC en Auchan por un colapso.  Mirando hacia atr√°s, siento c√≥mo mi coraz√≥n se llena de horror, nostalgia y temor. <br><br>  Para ser justos, vale la pena se√±alar que todo este tiempo recibimos un gran apoyo de algunos de nuestros l√≠deres, en palabras y hechos, y como resultado, todos nuestros oficios se legalizaron en OCD (que significa trabajo de dise√±o experimental y no trastorno obsesivo-compulsivo), que fue incluso presentado en el sal√≥n naval internacional en 2013.  S√≠, s√≠, condujimos al sal√≥n nuestras tuber√≠as de agua, ¬°pintamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">StDmitirev</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">nuestra</a> mano en naranja brillante!  Aqu√≠ est√°n, en maletas: <br><br><img src="https://habrastorage.org/webt/-7/jk/ii/-7jkii7tkq9yhpbwuvb1dw6ah2g.jpeg"><br><br>  Un d√≠a, mi amigo y colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">StDmitirev,</a> en medio de una conversaci√≥n sobre espectros y espectrogramas, pronunci√≥ la siguiente oraci√≥n: <br><br><blockquote>  "Pero ser√≠a divertido crear un sistema as√≠: el submarinista se sienta en el submarino y mira el monitor, en el que se mueve suavemente el espectrograma, en el que las letras y los n√∫meros se escriben como el dedo de <s>otro submarino</s> en la ventana de niebla de <s>otro submarino</s> ". <br></blockquote><br>  Todos se rieron, desarrollaron este tema, parece que incluso el mismo d√≠a dibujaron una carita sonriente en el espectrograma y escucharon c√≥mo suena.  Realmente quer√≠a llevar esto a un aspecto pr√°ctico. <br><br>  Ahora es dif√≠cil de recordar (fue en 2012).  Ten√≠a una computadora que funcionaba con una c√°mara web, varios artefactos-antenas y un "refuerzo de sonar de balde" especial (VG-1-P) con agua.  Lo llamaron un paso adelante debido al hecho de que le mostr√© a todos sus jefes el trabajo de diferentes modelos de equipos en √©l, lo que llev√≥ a mi ascenso a investigador senior. <br><br>  No estoy obligado por ninguna obligaci√≥n, el m√©todo en s√≠ mismo se ha publicado durante mucho tiempo en el dominio p√∫blico, y los resultados se han informado repetidamente en conferencias. <br><br>  Entonces, te digo c√≥mo, en esp√≠ritu, c√≥mo transmitir un video a trav√©s del agua: <br><br><h3>  ¬øC√≥mo generar una se√±al? </h3><br>  Recordamos que la idea se basa en "dibujar en un espectrograma", es decir, la imagen transmitida es el espectrograma de la se√±al.  Para convertir una se√±al del dominio del tiempo al dominio de la frecuencia y viceversa, es conveniente usar (bueno, por ejemplo) la transformada de Fourier, o mejor dicho, la transformada r√°pida de Fourier, por brevedad, llamada FFT o, m√°s com√∫nmente, FFT (Transformada r√°pida de Fourier). <br><br>  Dado que necesitamos convertir una imagen (cuadro de video) en una se√±al de audio que pueda emitir la tarjeta de sonido de cualquier computadora, obviamente utilizaremos la transformaci√≥n inversa, IFFT, para formarla.  Emitiremos una imagen en columnas, y se formar√° una se√±al para una columna como en el siguiente diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wi/3t/l4wi3t5t4mk3vq5zo_-bmau-dne.png"></div><br>  = <br>  Suponga que el tama√±o de la ventana FFT es N y hay una matriz de tama√±o N. Si lo consideramos como el espectro de la se√±al, entonces su elemento cero corresponde a la frecuencia cero (constante), y el recuento con √≠ndice N-1 corresponde a la frecuencia de muestreo Frecuencia de muestreo.  Es necesario seleccionar tales tama√±os de cuadro de imagen y tama√±o de ventana FFT para que, por un lado, todo se parezca al video (transferir un cuadro tomar√≠a un tiempo razonable), y por otro lado, la banda de frecuencia utilizada era adecuada en principio y adecuada para el equipo disponible. .  Ahora, si ingresamos los valores de brillo de la columna de la imagen (cuadro de color) de alg√∫n recuento favorito (de abajo hacia arriba en el diagrama), y luego realizamos la FFT inversa, la salida recibir√° una se√±al que codifica una columna de la imagen.  Ahora nos queda por formar las se√±ales de la misma manera para las columnas restantes de la imagen y emitirlas alternativamente usando una tarjeta de sonido. <br><br>  Vale la pena se√±alar que la FFT en la salida proporciona una serie de valores complejos, por lo que nuestra se√±al es la parte real.  Por supuesto, la se√±al resultante en las columnas se reduce a enteros con signo de 16 bits (de esta forma, generalmente se almacena una se√±al de audio digital) y se normaliza. <br><br>  De hecho, al comienzo de la imagen tambi√©n ingreso algunas columnas de brillo m√°ximo, luego en el lado del receptor esto determinar√° la respuesta de frecuencia de la ruta del transceptor (y el canal de transmisi√≥n), que, cuando se invierte y se suaviza ligeramente, nos ayudar√° a mejorar el marco recibido. <br><br>  En mi opini√≥n, la forma m√°s f√°cil de demostrar el dispositivo del transmisor es con un fragmento de c√≥digo, aqu√≠ est√° (m√©todo de codificaci√≥n de la clase de codificador): <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize * frameSize.Width]; alglib.complex[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sampleIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colsCount = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startRow = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endRow = startRow + frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colsCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = startRow; y &lt; endRow; y++) slice[y].x = (frame.GetPixel(x, frameSize.Height - (y - startRow) - <span class="hljs-number"><span class="hljs-number">1</span></span>).R / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) slice[y].x *= randomizerMask[y]; alglib.fftc1dinv(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> slice); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; slice.Length; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(slice[y].x) &gt; maxSlice) maxSlice = Math.Abs(slice[y].x); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slice.Length; i++) { samples[sampleIndex] = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)Math.Round(slice[i].x * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue / maxSlice); sampleIndex++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples; }</code> </pre> <br>  El c√≥digo, naturalmente, no pretende nada y fue escrito a toda prisa solo para demostraci√≥n. <br><br><h3>  Entonces, ¬øqu√© pasa con la velocidad de transmisi√≥n? </h3><br>  ¬øY c√≥mo evaluarlo?  Nos las arreglamos ( <s>del mal,</s> no del mal) para mantener la intriga durante unos dos meses, y algunos de nuestros camaradas y l√≠deres superiores en su tiempo libre lograron escribir un mont√≥n de papel, pregunt√°ndose c√≥mo podr√≠a resultar una velocidad de transferencia tan loca. <br><br>  Por ejemplo, si la frecuencia de muestreo es de 96 kHz, y tomamos el tama√±o de la ventana FFT a 512, enviaremos 120 x 120 p√≠xeles (8 bits por p√≠xel) a la entrada del transmisor, entonces el tiempo que tarda en transmitir un cuadro de imagen es: <br><br>  <i>120 * 512/96000 = 0.64 segundos</i> <br><br>  La tasa de bits deber√≠a parecer ser: <br><br>  <i>120x120 * 8 / 0.64 = 180,000 bits por segundo!</i> <br><br>  <s>El hijo del director estaba encantado en ese momento, s√≠, ¬°ya puedes usar protocolos de Internet!</s>  <s>Este es un gran avance!</s> <br><br>  Como mostrar√© a continuaci√≥n, es muy f√°cil caer en una idea err√≥nea.  ¬øQu√© est√° mal aqu√≠?  Despu√©s de todo, ¬°todo es tan simple y elegante! <br><br>  De hecho, tal c√°lculo de velocidad no es aplicable a este m√©todo, as√≠ como, por ejemplo, no es aplicable a una se√±al de televisi√≥n anal√≥gica, ¬øcu√°ntos bits por p√≠xel hay?  =) ¬øY qu√© hay del receptor detector m√°s simple?  =)) <br><br>  El m√©todo de transmisi√≥n descrito es esencialmente <i>ANAL√ìGICO</i> y los conceptos de "bit" y "pixel" no le son aplicables: en la misma imagen, en teor√≠a, no puede tomar 8 bits por brillo de pixel, pero 16 y "velocidad" se duplicar√°n autom√°ticamente. <br><br>  Es hora de mostrar los primeros resultados de nuestro "avance": <br><br><img src="https://habrastorage.org/webt/a5/ji/pv/a5jipvfgywxfxpy7p9jwl34v-ze.gif"><br><br>  La foto de arriba fue tomada por nosotros en el invierno de 2012 en el r√≠o Pichuga.  La distancia de transmisi√≥n fue de 700 metros.  S√≠, por desgracia, mi querido lector, esto no es en absoluto HD y ni siquiera se basa en el CamRip m√°s vergonzoso.  No recuerdo qui√©n ya, pero alguien not√≥ con mucha precisi√≥n que todos nuestros "videos" son como enviar se√±ales de ayuda desde un planeta moribundo. <br><br>  Lo que es notable, con un estiramiento, esto se puede caracterizar como una especie de OFDM: los datos se transmiten en subportadoras ortogonales, lo que significa una buena resistencia a la interferencia tonal y de otra banda estrecha; en este caso, las "l√≠neas" individuales de la imagen est√°n distorsionadas.  El ruido de impulso, por el contrario, distorsiona una o un grupo de columnas.  La caracter√≠stica "banda" de las im√°genes es causada por el llamado  desvanecimiento selectivo de frecuencia debido a la propagaci√≥n por trayectos m√∫ltiples, pero hablar√© de esto en otro momento. <br><br><h3>  ¬øC√≥mo se organiza el receptor? </h3><br>  Har√© una reserva de inmediato para que para probar este m√©todo en un cubo o incluso en una piscina peque√±a, basten dos piezas de una hora (como las redondas) con un conector para una tarjeta de sonido soldada.  Para el transmisor, puede tomar un cable bastante largo (2-3-4-5 metros) y sin blindaje, sellando el elemento piezoel√©ctrico con barniz de zapon o una peque√±a capa de sellador, suficiente para varias veces.  La antena de sonda resultante (¬øno, bueno, qu√©?) Se inserta en la toma de auriculares. <br><br>  La foto a continuaci√≥n muestra varias piezas que estaban a mano en el momento de la escritura.  Todos los elementos piezoel√©ctricos que se muestran son bastante adecuados para "probar" y generalmente hay una tienda de radio en cualquier <s>vertedero de basura</s> .  Pyatak no tiene un efecto piezoel√©ctrico y est√° presente en la imagen para la escala. <br><br><img src="https://habrastorage.org/webt/5v/r6/xq/5vr6xqryjht0yd5tqz7sdvmbd3a.jpeg"><br><br>  Para el receptor, es mejor tomar un cable de micr√≥fono blindado con el mismo conector y un piezo con un sellador o barniz al final.  Insertamos esta antena en el conector del micr√≥fono. <br><br>  Para los experimentos en un estanque, es mejor tomar alg√∫n tipo de anillo piezoel√©ctrico como transmisor y alimentarlo con uno amplificado (un amplificador en un TDA2030 con un transformador correctamente enrollado durar√° varios cientos de metros en un buen estanque <s>o se pueden</s> enrollar <s>otros 5 giros</s> ).  Para el receptor, en este caso, tambi√©n se requiere un preamplificador y preferiblemente un filtro de paso de banda.  Si los lectores estar√°n interesados ‚Äã‚Äãen aprender m√°s sobre esto, cu√©ntanoslo en los comentarios y trataremos de hacer un art√≠culo sobre la creaci√≥n de amplificadores de potencia, preamplificadores y antenas para la comunicaci√≥n sonar. <br><br><h3>  Entonces, volviendo al receptor, m√°s precisamente a su parte de software </h3><br>  Lo m√°s importante en la comunicaci√≥n es la sincronizaci√≥n y determinaci√≥n de la presencia de una se√±al √∫til.  En nuestro ejemplo, la detecci√≥n se realiza por la energ√≠a en la banda: se determinan los lugares donde aumenta bruscamente (comienzo del marco) y donde cae bruscamente (final del marco), con la condici√≥n de que de adelante hacia abajo debe haber al menos la duraci√≥n del marco. <br><br>  A pesar de su simplicidad, funciona sorprendentemente bien. <br><br>  Los datos de la tarjeta de sonido se recopilan de acuerdo con las muestras de FFTSize, la FFT se realiza inmediatamente en ellos y se almacenan como "cortes" separados, esperando el momento en que ser√°n procesados ‚Äã‚Äãpor el procedimiento de b√∫squeda, aqu√≠ est√° su c√≥digo (M√©todo de b√∫squeda en la clase Receiver): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameWidth = encoder.FrameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSlicesToSearch = Convert.ToInt32((frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceSize = encoder.FFTSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((slices.Count &gt; minSlicesToSearch) &amp;&amp; (sliceIndex &lt; slices.Count)) { weight = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sliceSize; i++) weight += Math.Abs(slices[sliceIndex][i]); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ratio = weight / previousWeight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ratio &gt;= risePeekRatio) &amp;&amp; (sliceIndex - prevRisePosition &gt; frameWidth)) { prevRisePosition = lastRisePosition; lastRisePosition = sliceIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastRisePosition + (frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt; slices.Count) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { samples[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[sliceSize]; Array.Copy(slices[lastRisePosition + i], samples[i], sliceSize); } slices.RemoveRange(<span class="hljs-number"><span class="hljs-number">0</span></span>, sliceIndex); lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FrameReceived != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) FrameReceived(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameReceivedEventArgs(encoder.DecodeEx(samples, <span class="hljs-number"><span class="hljs-number">5</span></span>))); lastRisePosition = sliceIndex; } } sliceIndex++; previousWeight = weight; } Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> isSearching); }</code> </pre> <br>  Y aqu√≠ hay un c√≥digo que se encarga de decodificar la imagen (Encoder.DecodeEx): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureCols</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colCount = samples.Length / fftSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colCount == frameSize.Width + measureCols) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowCount = frameSize.Height; Bitmap temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(colCount, rowCount); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize]; alglib.complex[] sliceC = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> samplesCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> component; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeStart = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeEnd = startLine + rowCount; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) { slice[y] = samples[samplesCount]; samplesCount++; } alglib.fftr1d(slice, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sliceC); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alglib.math.abscomplex(sliceC[y].x) &gt; maxSlice) maxSlice = alglib.math.abscomplex(sliceC[y].x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = temp.Height + decodeStart - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) { component = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">255.0</span></span> * alglib.math.abscomplex(sliceC[y].x) / maxSlice); temp.SetPixel(x, offset - y, Color.FromArgb(component, component, component)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">"Specified array length error"</span></span>); } }</code> </pre><br>  Y ahora me propongo mirar los resultados de los experimentos sobre la transmisi√≥n de "video", realizados en diferentes momentos en diferentes dep√≥sitos. <br><br>  Ambas im√°genes (abajo) fueron grabadas en el sal√≥n naval internacional en San Petersburgo en 2013 en nuestro (entonces) puesto a trav√©s de dos computadoras port√°tiles y un acuario. <br><br>  No es posible distinguir lo que est√° escrito en la insignia <br><br><img src="https://habrastorage.org/webt/xp/wx/sq/xpwxsqvxyyqwrzrjh0n5wr0tm-q.gif"><br><br><img src="https://habrastorage.org/webt/w7/9y/zb/w79yzbz7caic4fre7xftuh_tq00.gif"><br><br>  Y aqu√≠ hay dos "videos" grabados por nosotros en una de las bah√≠as del lago Ladoga en Karelia, son una especie de registro para este m√©todo (simplemente nunca lo intentamos y es poco probable que lo sea): el primero de ellos se obtuvo a una distancia de 500 y el segundo hasta 1000 metros : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transmisi√≥n de video a trav√©s del agua, distancia 500 m (archivo 8.7 mb)</a> <br><br><img src="https://habrastorage.org/webt/ek/c_/sv/ekc_svi18z7oupqlmckhziofpy8.gif"><br><br>  Dado que el "video" se grab√≥ en tiempo real usando una c√°mara web, varias cosas extra√±as cayeron en el marco.  Ser√° muy interesante si alguien adivina y escribe en un comentario lo que est√° en el fondo en el √∫ltimo "video"). <br><br>  Para respaldar el hecho de que el m√©todo se public√≥ hace mucho tiempo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro art√≠culo</a> ya es para 2013 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Us√©</a> la maravillosa biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AForge</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capturar im√°genes de la c√°mara web</a> . <br><br>  Las funciones de n√∫mero complejo y FFT se utilizan de la excelente biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AlgLib</a> . <br><br>  Y, como promet√≠, todo el proyecto en C # (VS2012) se adjunta al art√≠culo como material para el trabajo "en casa".  Por conveniencia, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos binarios est√°n</a> separados. <br>  La demostraci√≥n proporciona la capacidad de cambiar (mover) la banda de frecuencia ocupada, as√≠ como la correcci√≥n gamma del cuadro de salida (todo se puede cambiar en tiempo real). <br><br><h3>  PS </h3><br>  No he recogido C # durante mucho tiempo y es muy dif√≠cil encontrar el tiempo en el horario de trabajo, as√≠ que me disculpo de antemano por la confusi√≥n y la prisa del c√≥digo. <br><br><h3>  PPS </h3><br>  No adjunto un pedazo de cable, dos conectores y dos piezas al art√≠culo, no es suficiente para todos. <br><br><h3>  Errata y Ap√©ndice </h3><br>  - En algunas tarjetas de sonido en la entrada hay un filtro de paso bajo que corta tr√°gicamente todo por encima de ~ 15 kHz (¬øpor qu√© ???). <br><br>  - Por defecto, el proyecto de demostraci√≥n funciona con una frecuencia de muestreo de 96 kHz, pero no todas las tarjetas de sonido modernas lo admiten (¬øPor qu√© ???).  Si el equipo no puede 96 kHz, entonces debe establecer 48 kHz en la configuraci√≥n, de lo contrario, 44100 es compatible en todas partes, sin embargo, la duraci√≥n de transmisi√≥n de un cuadro ser√° correspondientemente m√°s larga. <br><br>  Aqu√≠ hay una lista de computadoras port√°tiles y tarjetas de sonido que pueden considerarse equipos de sonar j√≥venes: <br><br><ul><li>  Lenovo ideapad Y510P con sonido JBL </li><li>  Asus n55s </li><li>  Asus K501U </li><li>  tarjeta de sonido externa Sound Blaster X-Fi Surround 5.1 (modelo no. SB 1095) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es408871/">https://habr.com/ru/post/es408871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es408857/index.html">Revista de prensa de Oc√© Technology</a></li>
<li><a href="../es408859/index.html">KidPRO - La historia de una ardilla que ayuda a los ni√±os</a></li>
<li><a href="../es408861/index.html">Nueva bioimpresora ayuda a tratar la diabetes tipo 1</a></li>
<li><a href="../es408863/index.html">Escaneo 3D de autom√≥viles en tuning y reparaci√≥n</a></li>
<li><a href="../es408865/index.html">Eliminamos el ruso de nuestro ingl√©s</a></li>
<li><a href="../es408873/index.html">Revisi√≥n de video de la fresadora CNC 3Dtool AMAN</a></li>
<li><a href="../es408875/index.html">Rodillo para la espalda</a></li>
<li><a href="../es408879/index.html">Objetivo intrigante para trabajar mucho menos</a></li>
<li><a href="../es408881/index.html">Pero, ¬øqu√© pasa si vivimos en el futuro y el pasado al mismo tiempo? ¬øY cu√°l es nuestro universo?</a></li>
<li><a href="../es408883/index.html">Video 3Dtool Hercules Strong 2017 Revisi√≥n de la impresora 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>