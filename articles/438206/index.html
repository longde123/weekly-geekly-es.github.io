<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèîÔ∏è üßò ‚õ¥Ô∏è 26 recomendaciones para usar el tipo var en Java üëâüèª üåÅ üëáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La Inferencia de tipo variable local de Java (LVTI) o, brevemente, el tipo var (el identificador var no es una palabra clave, sino un nombre de tipo r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>26 recomendaciones para usar el tipo var en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438206/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/mq/zq/0cmqzquxmzrie0s3ryftj5dqvga.png"></div><br><p>  <strong>La Inferencia de tipo variable local de Java (LVTI)</strong> o, brevemente, el tipo <strong>var</strong> (el identificador <strong>var</strong> no es una palabra clave, sino un nombre de tipo reservado) se agreg√≥ a Java 10 usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 286: Inferencia de tipo variable local</a> .  Al ser una funci√≥n de compilaci√≥n del 100%, no afecta el c√≥digo de bytes, el tiempo de ejecuci√≥n o el rendimiento.  B√°sicamente, el compilador verifica el lado derecho del operador de asignaci√≥n y, en base a √©l, determina el tipo espec√≠fico de la variable y luego lo reemplaza con <strong>var</strong> . </p><br><p> Adem√°s, es √∫til para reducir la verbosidad del c√≥digo repetitivo, y tambi√©n acelera el proceso de programaci√≥n en s√≠.  Por ejemplo, es muy conveniente escribir <strong><code>var evenAndOdd =...</code></strong> lugar de <strong><code>Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd =...</code></strong> </p><br><p>  La aparici√≥n de <strong>var</strong> no significa que siempre sea conveniente usarlo en todas partes, a veces ser√° m√°s pr√°ctico hacerlo con herramientas est√°ndar. </p><br><p>  En este art√≠culo, veremos 26 situaciones, con ejemplos de cu√°ndo puede usar <strong>var</strong> y cu√°ndo no vale la pena. </p><a name="habracut"></a><br><h2 id="punkt-1-staraytes-davat-osmyslennye-imena-lokalnym-peremennym">  Punto 1: intente dar nombres significativos a las variables locales </h2><br><p>  Por lo general, nos enfocamos en dar los nombres correctos a los campos de las clases, pero no prestamos la misma atenci√≥n a los nombres de las variables locales.  Cuando nuestros m√©todos se implementan perfectamente, contienen poco c√≥digo y tienen buenos nombres, muy a menudo no prestamos atenci√≥n a las variables locales, ni siquiera reducimos por completo sus nombres. </p><br><p>  Cuando usamos <strong>var en</strong> lugar de escribir tipos expl√≠citos, el compilador los detecta autom√°ticamente y sustituye <strong>var</strong> .  Pero, por otro lado, como resultado de esto, se hace m√°s dif√≠cil para las personas leer y comprender el c√≥digo, ya que el uso de <strong>var</strong> puede complicar su legibilidad y comprensi√≥n.  En la mayor√≠a de los casos, esto se debe a que tendemos a ver el tipo de una variable como informaci√≥n primaria y su nombre como secundario.  Aunque deber√≠a ser todo lo contrario. </p><br><h3 id="primer-1">  Ejemplo 1: </h3><br><p>  Muchos probablemente estar√°n de acuerdo en que en el siguiente ejemplo, los nombres de las variables locales son demasiado cortos: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// HAVING public boolean callDocumentationTask() { DocumentationTool dtl = ToolProvider.getSystemDocumentationTool(); DocumentationTask dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Cuando se usan nombres cortos, junto con <strong>var</strong> , el c√≥digo se vuelve a√∫n menos claro: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public boolean callDocumentationTask() { var dtl = ToolProvider.getSystemDocumentationTool(); var dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Opci√≥n m√°s preferida: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public boolean callDocumentationTask() { var documentationTool = ToolProvider.getSystemDocumentationTool(); var documentationTask = documentationTool.getTask(...); return documentationTask.call(); }</span></span></code> </pre> <br><h3 id="primer-2">  Ejemplo 2 </h3><br><p>  Evite nombrar variables como esta: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public List&lt;Product&gt; fetchProducts(long userId) { var u = userRepository.findById(userId); var p = u.getCart(); return p; }</span></span></code> </pre> <br><p>  Use nombres m√°s significativos: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public List&lt;Product&gt; fetchProducts(long userId) { var user = userRepository.findById(userId); var productList = user.getCart(); return productList; }</span></span></code> </pre> <br><h3 id="primer-3">  Ejemplo 3 </h3><br><p>  En un esfuerzo por dar nombres m√°s comprensibles a las variables locales, no vaya a extremos: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteArrayOutputStream = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  En cambio, puede usar una opci√≥n m√°s corta, pero no menos comprensible: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var outputStream = new ByteArrayOutputStream(); // or var outputStreamOfFoo = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  ¬øSab√≠a que Java tiene una clase interna llamada: <br>  <strong>InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonWindowNotFocusedState</strong> </p><br><p>  Bueno, nombrar variables con este tipo puede ser complicado :) </p><br><h2 id="punkt-2-ispolzuyte-literaly-chtoby-pomoch-var-tochno-opredelit-tip-primitiva-int-long-float-double">  Punto 2: use literales para ayudar a var a determinar el tipo de primitivo (int, long, float, double) </h2><br><p>  Sin el uso de literales para tipos primitivos, podemos encontrar que los tipos esperados e impl√≠citos pueden diferir.  Esto es causado por la conversi√≥n de tipo impl√≠cita utilizada por las variables <strong>var</strong> . </p><br><p>  Por ejemplo, los siguientes dos fragmentos de c√≥digo se comportan como se esperaba.  Aqu√≠ declaramos expl√≠citamente los tipos <strong>booleano</strong> y <strong>char</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type boolean char a = 'a'; // this is of type char</span></span></code> </pre> <br><p>  Ahora usamos <strong>var</strong> , en lugar de declarar expl√≠citamente los tipos: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is inferred as boolean var a = 'a'; // this is inferred as char</span></span></code> </pre> <br><p>  Hasta ahora todo bien.  Ahora haga lo mismo para los tipos <strong>int</strong> , <strong>long</strong> , <strong>float</strong> y <strong>double</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> intNumber = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type int long longNumber = 20; // this is of type long float floatNumber = 20; // this is of type float, 20.0 double doubleNumber = 20; // this is of type double, 20.0</span></span></code> </pre> <br><p>  Aunque el fragmento de c√≥digo anterior es simple y directo, ahora usemos <strong>var en</strong> lugar de especificar expl√≠citamente los tipos. </p><br><p>  Evitar </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var intNumber = 20; // this is inferred as int var longNumber = 20; // this is inferred as int var floatNumber = 20; // this is inferred as int var doubleNumber = 20; // this is inferred as int</span></span></code> </pre> <br><p>  Las cuatro variables se mostrar√°n como <strong>int</strong> .  Para corregir este comportamiento, necesitamos usar literales Java: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var intNumber = 20; // this is inferred as int var longNumber = 20L; // this is inferred as long var floatNumber = 20F; // this is inferred as float, 20.0 var doubleNumber = 20D; // this is inferred as double, 20.0</span></span></code> </pre> <br><p>  Pero, ¬øqu√© sucede si declaramos un n√∫mero decimal? </p><br><p>  Evite esto si espera obtener una variable de tipo <strong>float</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID, IF THIS IS A FLOAT var floatNumber = 20.5; // this is inferred as double</span></span></code> </pre> <br><p>  Para evitar sorpresas, use el literal apropiado: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER, IF THIS IS A FLOAT var floatNumber = 20.5F; // this is inferred as float</span></span></code> </pre> <br><h2 id="punkt-3-v-nekotoryh-sluchayah-var-i-neyavnye-privedeniya-tipov-mogut-uprostit-podderzhku-koda">  Punto 3: en algunos casos, las conversiones de tipo var e impl√≠cito pueden simplificar el soporte de c√≥digo </h2><br><p>  Por ejemplo, supongamos que nuestro c√≥digo est√° entre dos m√©todos.  Un m√©todo obtiene un carrito de compras con diferentes productos y calcula el mejor precio.  Para hacer esto, compara varios precios en el mercado y devuelve el precio total en forma de tipo <strong>flotante</strong> .  Otro m√©todo simplemente deduce este precio de la tarjeta. </p><br><p>  Primero, veamos un m√©todo que calcula el mejor precio: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> price = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre> <br><p>  En segundo lugar, echemos un vistazo al m√©todo que funciona con el mapa: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Ahora ponemos nuestro c√≥digo entre estos dos m√©todos de servicio externo como cliente.  Nuestros usuarios pueden elegir los productos para comprar, y calculamos el mejor precio para ellos, y luego cancelamos los fondos de la tarjeta: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public void purchaseCart(long customerId) { ... float price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><p>  Despu√©s de un tiempo, la compa√±√≠a propietaria de la API decide abandonar la representaci√≥n material de los precios a favor del decimal (en lugar de <strong>flotante</strong> , ahora se usa <strong>int</strong> ).  Entonces, modificaron el c√≥digo API de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> realprice = ...; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> price = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) realprice; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  El hecho es que nuestro c√≥digo usa una declaraci√≥n expl√≠cita de una variable <strong>flotante</strong> como precio.  En su forma actual, recibiremos un error en el momento de la compilaci√≥n.  Pero si hubi√©ramos previsto tal situaci√≥n y hubi√©ramos utilizado <strong>var en</strong> lugar de <strong>flotante</strong> , nuestro c√≥digo continuar√≠a funcionando sin problemas, gracias a la conversi√≥n de tipo impl√≠cita: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public void purchaseCart(long customerId) { ... var price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><h2 id="punkt-4-kogda-literaly-ne-yavlyayutsya-podhodyaschim-resheniem-to-ispolzuyte-yavnoe-privedenie-tipov-ili-otkazhites-ot-var">  Punto 4: cuando los literales no son una soluci√≥n adecuada, use una conversi√≥n expl√≠cita o descarte var </h2><br><p>  Algunos tipos primitivos en Java no tienen literales especiales, por ejemplo, <strong>byte</strong> y tipos <strong>cortos</strong> .  En este caso, usando la designaci√≥n de tipo expl√≠cito, podemos crear variables sin ning√∫n problema. </p><br><p>  Use esto en lugar de <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS INSTEAD OF USING VAR byte byteNumber = 45; // this is of type byte short shortNumber = 4533; // this is of type short</span></span></code> </pre> <br><p>  Pero, ¬øpor qu√© en esta situaci√≥n da preferencia a la notaci√≥n de tipo expl√≠cito en lugar de simplemente usar <strong>var</strong> ?  Bueno, escribamos este c√≥digo usando <strong>var</strong> .  Tenga en cuenta que en ambos casos, el compilador asumir√° que necesita variables de tipo <strong>int</strong> . </p><br><p>  Evita este error: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteNumber = 45; // this is inferred as int var shortNumber = 4533; // this is inferred as int</span></span></code> </pre> <br><p>  Aqu√≠ no hay literales que nos ayuden, por lo tanto, nos vemos obligados a utilizar la conversi√≥n expl√≠cita de tipo descendente.  Personalmente, evitar√© tales situaciones, porque no veo ninguna ventaja aqu√≠. </p><br><p>  Solo use esta entrada si realmente quiere usar <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS ONLY IF YOU WANT TO USE VAR var byteNumber = (byte) 45; // this is inferred as byte var shortNumber = (short) 4533; // this is inferred as short</span></span></code> </pre> <br><h2 id="punkt-5-izbegayte-ispolzovaniya-var-esli-nazvaniya-peremennyh-ne-soderzhat-dostatochnoy-informacii-o-tipe-dlya-ponimaniya-koda">  Punto 5: evite usar var si los nombres de las variables no contienen suficiente informaci√≥n de tipo para comprender el c√≥digo </h2><br><p>  La ventaja de usar <strong>var</strong> es escribir c√≥digo m√°s conciso.  Por ejemplo, en el caso de usar constructores, podemos evitar la necesidad de repetir el nombre de la clase y, por lo tanto, eliminar la redundancia de c√≥digo. </p><br><p>  Evita lo siguiente: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID MemoryCacheImageInputStream inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  Use en su lugar: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  Para la construcci√≥n a continuaci√≥n, <strong>var</strong> tambi√©n ser√° una buena manera de simplificar el c√≥digo sin perder informaci√≥n. </p><br><p>  Evitar </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fm = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Utiliza el siguiente c√≥digo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var compiler = ToolProvider.getSystemJavaCompiler(); var fileManager = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Entonces, ¬øpor qu√© nos sentimos m√°s c√≥modos trabajando con <strong>var</strong> en los ejemplos presentados?  Porque toda la informaci√≥n necesaria est√° contenida en los nombres de las variables.  Pero si <strong>var</strong> , en combinaci√≥n con un nombre de variable, reduce la claridad del c√≥digo, es mejor negarse a usarlo. </p><br><p>  Evitar </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public File fetchCartContent() { return new File(...); } // As a human, is hard to infer the "cart" type without // inspecting the fetchCartContent() method var cart = fetchCartContent();</span></span></code> </pre> <br><p>  Uso: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public File fetchCartContent() { return new File(...); } File cart = fetchCartContent();</span></span></code> </pre> <br><p>  Considere, por ejemplo, el uso de la clase <strong><code>java.nio.channels.Selector</code></strong> .  Esta clase tiene un m√©todo est√°tico <strong><code>open()</code></strong> que devuelve un nuevo selector y lo abre.  Pero aqu√≠ puede pensar f√°cilmente que el m√©todo <strong><code>Selector.open()</code></strong> puede devolver un tipo <strong>booleano</strong> , dependiendo del √©xito de abrir un selector existente, o incluso devolver un <strong>vac√≠o</strong> .  El uso de <strong>var</strong> aqu√≠ conducir√° a la p√©rdida de informaci√≥n y la confusi√≥n en el c√≥digo. </p><br><h2 id="punkt-6-tip-var-garantiruet-bezopasnost-vo-vremya-kompilyacii">  Punto 6: el tipo var garantiza la seguridad en tiempo de compilaci√≥n </h2><br><p>  Esto significa que no podemos compilar una aplicaci√≥n que intente realizar asignaciones incorrectas.  Por ejemplo, el siguiente c√≥digo no se compila: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var items = 10; items = "10 items"; // incompatible types: String cannot be converted to int</span></span></code> </pre> <br><p>  Pero este compila: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-number"><span class="hljs-number">10</span></span>; items = <span class="hljs-number"><span class="hljs-number">20</span></span>;</code> </pre> <br><p>  Y este c√≥digo compila con √©xito: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-string"><span class="hljs-string">"10"</span></span>; items = <span class="hljs-string"><span class="hljs-string">"10 items"</span></span>;</code> </pre> <br><p>  Una vez que el compilador ha definido el valor de la variable <strong>var</strong> , no podemos asignar nada m√°s que este tipo. </p><br><h2 id="punkt-7-var-ne-mozhet-ispolzovatsya-dlya-sozdaniya-ekzemplyara-konkretnogo-tipa-i-naznacheniya-ego-peremennoy-tipa-interfeysa">  Punto 7: var no se puede usar para crear instancias de un tipo espec√≠fico y asignarlo a una variable de tipo de interfaz </h2><br><p>  En Java, utilizamos el enfoque de "programaci√≥n con interfaces".  Por ejemplo, creamos una instancia de la clase ArrayList, asoci√°ndola con una abstracci√≥n (interfaz): </p><br><pre> <code class="java hljs">List&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  Y evitamos cosas como vincular un objeto a una variable del mismo tipo: </p><br><pre> <code class="java hljs">ArrayList&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  Esta es la pr√°ctica m√°s com√∫n y deseable, ya que podemos reemplazar f√°cilmente la implementaci√≥n de la interfaz con cualquier otra.  Para esto, solo es necesario declarar una variable de tipo de interfaz. </p><br><p>  No podremos seguir este concepto usando variables var, como  siempre se muestra un tipo espec√≠fico para ellos.  Por ejemplo, en el siguiente fragmento de c√≥digo, el compilador determinar√° el tipo de la variable como <strong><code>ArrayList&lt;String&gt;</code></strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  Hay varios argumentos de defensa que explican este comportamiento: </p><br><ul><li><p>  <strong>var se</strong> usa para variables locales, donde, en la mayor√≠a de los casos, la programaci√≥n usando interfaces se usa menos que en los casos con par√°metros de m√©todo devueltos por valores o campos </p><br></li><li><p>  El alcance de las variables locales debe ser peque√±o, por lo que resolver los problemas causados ‚Äã‚Äãpor cambiar a otra implementaci√≥n no deber√≠a ser muy dif√≠cil. </p><br></li><li><p>  <strong>var</strong> trata el c√≥digo de la derecha como el inicializador utilizado para determinar el tipo real.  Si, en alg√∫n momento, se cambia el inicializador, entonces el tipo que se est√° definiendo tambi√©n puede cambiar, causando problemas en el c√≥digo que se basa en esta variable. </p><br></li></ul><br><h2 id="punkt-8-veroyatnost-vyvoda-neozhidaemogo-tipa">  P√°rrafo 8: la probabilidad de la conclusi√≥n de un tipo inesperado </h2><br><p>  El uso de var en combinaci√≥n con un <strong>operador de diamante</strong> (&lt;&gt;) en ausencia de informaci√≥n para identificar el tipo puede conducir a resultados inesperados. </p><br><p>  Antes de Java 7, se usaba la inferencia de tipo expl√≠cita para las colecciones: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicitly specifying generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;String&gt;();</span></span></code> </pre> <br><p>  Comenzando con Java 7, se introdujo el <strong>operador de diamantes</strong> .  En este caso, el compilador derivar√° independientemente el tipo necesario: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferring generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;&gt;();</span></span></code> </pre> <br><p>  ¬øQu√© tipo se mostrar√° en el siguiente c√≥digo? </p><br><p>  Debe evitar tales construcciones: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var productList = new ArrayList&lt;&gt;(); // is inferred as ArrayList&lt;Object&gt;</span></span></code> </pre> <br><p>  El tipo se definir√° como <strong><code>ArrayList&lt;Object&gt;</code></strong> .  Esto se debe a que no se proporciona la informaci√≥n necesaria para determinar correctamente el tipo.  Esto lleva al hecho de que se seleccionar√° el tipo m√°s cercano, que puede ser compatible con el contexto de lo que est√° sucediendo.  En este caso, <strong><code>Object</code></strong> . </p><br><p>  Por lo tanto, <strong>var</strong> solo se puede usar si proporcionamos la informaci√≥n necesaria para determinar el tipo esperado.  El tipo se puede especificar directamente o pasar como argumento. </p><br><p>  Especifique directamente el tipo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var productList = new ArrayList&lt;String&gt;(); // inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  Pase argumentos del tipo requerido: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;String&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(productStack); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><pre> <code class="java hljs">Product p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); Product p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listOfProduct = List.of(p1, p2); <span class="hljs-comment"><span class="hljs-comment">// inferred as List&lt;Product&gt; // DON'T DO THIS var listofProduct = List.of(); // inferred as List&lt;Object&gt; listofProduct.add(p1); listofProduct.add(p2);</span></span></code> </pre> <br><h2 id="punkt-9-prisvoenie-massiva-k-var-peremennoy-ne-trebuet-skobok--">  Elemento 9: asignar una matriz a una variable var no requiere corchetes [] </h2><br><p>  Todos sabemos c√≥mo declarar matrices en Java: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// or, less preferred int numbers[] = new int[5];</span></span></code> </pre> <br><p>  ¬øQu√© tal usar <strong>var</strong> cuando se trabaja con matrices?  En este caso, no es necesario usar soportes en el lado izquierdo. </p><br><p>  Evite lo siguiente (esto ni siquiera se compila): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var[] numbers = new int[5]; // or var numbers[] = new int[5];</span></span></code> </pre> <br><p>  Uso: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var numbers = new int[5]; // inferred as array of int numbers[0] = 2; // work numbers[0] = 2.2; // doesn't work numbers[0] = "2"; // doesn't work</span></span></code> </pre> <br><p>  El siguiente c√≥digo usando <strong>var</strong> tambi√©n falla al compilar.  Esto se debe a que el compilador no puede determinar el tipo desde el lado derecho: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type work as expected int[] numbers = {1, 2, 3}; // IT DOESN'T COMPILE var numbers = {1, 2, 3}; var numbers[] = {1, 2, 3}; var[] numbers = {1, 2, 3};</span></span></code> </pre> <br><h2 id="punkt-10-var-nelzya-ispolzovat-pri-obyavlenii-neskolkih-peremennyh-v-odnoy-stroke">  Elemento 10: var no se puede usar al declarar m√∫ltiples variables en la misma l√≠nea </h2><br><p>  Si desea declarar variables del mismo tipo a la vez, debe saber que <strong>var</strong> no <strong>es</strong> adecuado para esto.  El siguiente c√≥digo no se compila: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: 'var' is not allowed in a compound declaration var hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  Use en su lugar: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  O es: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var hello = "hello"; var bye = "bye"; var welcome = "welcome";</span></span></code> </pre> <br><h2 id="punkt-11-lokalnye-peremennye-dolzhny-stremitsya-k-minimizacii-svoey-oblasti-vidimosti-tip-var-usilivaet-eto-utverzhdenie">  Punto 11: las variables locales deben esforzarse por minimizar su alcance.  El tipo var refuerza esta afirmaci√≥n. </h2><br><p>  Mantenga un peque√±o alcance para las variables locales: estoy seguro de que escuch√≥ esta declaraci√≥n antes de la <strong>var</strong> . </p><br><p>  La legibilidad y la correcci√≥n r√°pida de errores son argumentos a favor de este enfoque.  Por ejemplo, definamos una pila de la siguiente manera: </p><br><p>  Evita esto: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // George, Tyllen, Martin, Kelly stack.forEach(...); ...</span></span></code> </pre> <br><p>  Tenga en cuenta que estamos llamando al m√©todo <strong><code>forEach()</code></strong> , que se hereda de <strong><code>java.util.Vector</code></strong> .  Este m√©todo pasar√° por la pila como cualquier otro vector y esto es lo que necesitamos.  Pero ahora decidimos usar <strong><code>ArrayDeque</code></strong> lugar de <strong><code>Stack</code></strong> .  Cuando hacemos esto, el m√©todo <strong><code>forEach()</code></strong> recibir√° una implementaci√≥n de ArrayDeque que atravesar√° la pila como una pila est√°ndar (LIFO) </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new ArrayDeque&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // Kelly, Martin, Tyllen, George stack.forEach(...); ...</span></span></code> </pre> <br><p>  Esto no es lo que queremos.  Es demasiado dif√≠cil rastrear el error aqu√≠, porque el c√≥digo que contiene la parte <strong><code>forEach()</code></strong> no se encuentra al lado del c√≥digo en el que se realizaron los cambios.  Para aumentar la velocidad de b√∫squeda y correcci√≥n de errores, es mucho mejor escribir c√≥digo usando la variable <strong><code>stack</code></strong> , lo m√°s cerca posible de la declaraci√≥n de esta variable. </p><br><p>  Esto se hace mejor de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // George, Tyllen, Martin, Kelly stack.forEach(...); ... // 50 lines of code that doesn't use stack</span></span></code> </pre> <br><p>  Ahora, cuando el desarrollador cambie de <strong><code>Stack</code></strong> a <strong><code>ArrayQueue</code></strong> , podr√° notar r√°pidamente el error y solucionarlo. </p><br><h2 id="punkt-12-tip-var-uproschaet-ispolzovanie-razlichnyh-tipov-v-ternarnyh-operatorah">  Cl√°usula 12: el tipo var simplifica el uso de varios tipos en operadores ternarios </h2><br><p>  Podemos usar diferentes tipos de operandos en el lado derecho del operador ternario. </p><br><p>  Al especificar expl√≠citamente los tipos, el siguiente c√≥digo no se compila: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE List code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // or Set code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10);</span></span></code> </pre> <br><p>  Sin embargo, podemos hacer esto: </p><br><pre> <code class="java hljs">Collection code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); Object code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  El siguiente c√≥digo tampoco se compila: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE int code = intOrString ? 12112 : "12112"; String code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  Pero puedes usar tipos m√°s generales: </p><br><pre> <code class="java hljs">Serializable code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>; Object code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>;</code> </pre> <br><p>  En todos estos casos, es mejor preferir <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // inferred as Collection&lt;Integer&gt; var code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // inferred as Serializable var code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  De estos ejemplos no se deduce que el tipo <strong>var</strong> define tipos de objetos en tiempo de ejecuci√≥n.  ¬°Esto no es as√≠! </p><br><p>  Y, por supuesto, el tipo <strong>var</strong> funcionar√° correctamente con los mismos tipos de ambos operandos: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferred as float var code = oneOrTwoDigits ? 1211.2f : 1211.25f;</span></span></code> </pre> <br><h2 id="punkt-13-tip-var-mozhet-byt-ispolzovan-vnutri-ciklov">  Punto 13: el tipo var se puede usar dentro de los bucles </h2><br><p>  Podemos reemplazar f√°cilmente la declaraci√≥n expl√≠cita de tipos en bucles <strong>for</strong> con el tipo <strong>var</strong> . </p><br><p>  Cambiar un tipo <strong>int</strong> expl√≠cito a <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type for (int i = 0; i &lt; 5; i++) { ... } // using var for (var i = 0; i &lt; 5; i++) { // i is inferred of type int ... }</span></span></code> </pre> <br><p>  Cambiar el tipo expl√≠cito de <strong><code>Order</code></strong> a <strong>var</strong> : </p><br><pre> <code class="java hljs">List&lt;Order&gt; orderList = ...; <span class="hljs-comment"><span class="hljs-comment">// explicit type for (Order order : orderList) { ... } // using var for (var order : orderList) { // order type is inferred as Order ... }</span></span></code> </pre> <br><h2 id="punkt-14-var-otlichno-rabotaet-s-potokami-stream-v-java-8">  Punto 14: var funciona bien con flujos en Java 8 </h2><br><p>  Es muy simple usar var de Java 10 con secuencias que aparecieron en Java 8. </p><br><p>  Simplemente puede reemplazar la declaraci√≥n expl√≠cita de tipo <strong>Stream</strong> con <strong>var</strong> : </p><br><h3 id="primer-1-1">  Ejemplo 1: </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 4, 5); numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println); // using var var numbers = Stream.of(1, 2, 3, 4, 5); // inferred as Stream&lt;Integer&gt; numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println);</span></span></code> </pre> <br><h3 id="primer-2-1">  Ejemplo 2 </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit types Stream&lt;String&gt; paths = Files.lines(Path.of("...")); List&lt;File&gt; files = paths.map(p -&gt; new File(p)).collect(toList()); // using var var paths = Files.lines(Path.of("...")); // inferred as Stream&lt;String&gt; var files = paths.map(p -&gt; new File(p)).collect(toList()); // inferred as List&lt;File&gt;</span></span></code> </pre><br><h2 id="punkt-15-var-mozhno-ispolzovat-pri-obyavlenii-lokalnyh-peremennyh-prednaznachennyh-dlya-razbieniya-bolshih-cepochek-vyrazheniy-na-chasti">  Cl√°usula 15: var se puede usar al declarar variables locales destinadas a dividir grandes cadenas de expresiones en partes </h2><br><p>  Las expresiones con una gran cantidad de anidamiento se ven impresionantes y generalmente parecen alg√∫n tipo de c√≥digo inteligente e importante.  En el caso de que sea necesario facilitar la legibilidad del c√≥digo, se recomienda dividir una expresi√≥n grande utilizando variables locales.  Pero a veces escribir muchas variables locales parece un trabajo muy agotador que me gustar√≠a evitar. </p><br><p>  Un ejemplo de una gran expresi√≥n: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// AVOID int result = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)) .values() .stream() .max(Comparator.comparing(List::size)) .orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  Es mejor dividir el c√≥digo en sus componentes: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); Optional&lt;List&lt;Integer&gt;&gt; evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); int sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  La segunda versi√≥n del c√≥digo parece m√°s legible y simple, pero la primera versi√≥n tambi√©n tiene derecho a existir.  Es absolutamente normal que nuestra mente se adapte a la comprensi√≥n de expresiones tan grandes y las prefiera a las variables locales.  Sin embargo, usar el tipo <strong>var</strong> puede ayudar a dividir estructuras grandes al reducir el esfuerzo para declarar variables locales: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER var evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); var evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); var sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><h2 id="punkt-16-var-ne-mozhet-byt-ispolzovan-kak-tip-vozvraschaemogo-znacheniya-ili-kak-tip-argumenta-metoda">  Cl√°usula 16: var no se puede usar como un tipo de retorno o como un tipo de argumento de m√©todo </h2><br><p>  Los dos fragmentos de c√≥digo que se muestran a continuaci√≥n no se compilar√°n. </p><br><p>  Usando <strong>var</strong> como el tipo de retorno: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public var countItems(Order order, long timestamp) { ... }</span></span></code> </pre> <br><p>  Usando <strong>var</strong> como un tipo de argumento de m√©todo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public int countItems(var order, var timestamp) { ... }</span></span></code> </pre> <br><h2 id="punkt-17-lokalnye-peremennye-tipa-var-mogut-byt-peredany-kak-parametry-metoda-ili-mogut-prinimat-vozvraschaemoe-metodom-znachenie">  Cl√°usula 17: las variables locales de tipo var pueden pasarse como par√°metros de un m√©todo o pueden tomar un valor de retorno </h2><br><p>  Los siguientes fragmentos de c√≥digo se compilar√°n y funcionar√°n correctamente: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Order order, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// an Order instance var timestamp = ...; // a long representing a timestamp var itemsNr = countItems(order, timestamp); // inferred as int type ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;A, B&gt; <span class="hljs-function"><span class="hljs-function">B </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A container, B tocontain)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// Order instance var product = ...; // Product instance var resultProduct = contains(order, product); // inferred as Product type</span></span></code> </pre> <br><h2 id="punkt-18-peremennye-var-mogut-byt-ispolzovany-s-anonimnymi-klassami">  18:  var       </h2><br><p>    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; Product product = ...; // a Product instance int weight = weighter.getWeight(product);</span></span></code> </pre> <br><p>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; var product = ...; // a Product instance var weight = weighter.getWeight(product);</span></span></code> </pre> <br><h2 id="punkt-19-peremennye-tipa-var-mogut-ispolzovatsya-v-kachestve-effectively-final-peremennyh">  19:   var     effectively final  </h2><br><p> , : </p><br><blockquote> <em>‚Ä¶   Java SE 8,           ,   final  effectively final.   ,        ,  effectively final</em> . </blockquote><p>  ,   <strong>var</strong>   effectively final.      . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID int ratio = 5; // this is effectively final Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var ratio = 5; // this is effectively final var weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><h2 id="punkt-20-var-peremennye-mogut-byt-final-peremennymi">  20: var-   final- </h2><br><p>   <strong>var</strong>     ( ,     effectively final).     ,  <strong>final</strong> . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID // IT DOESN'T COMPILE public void discount(int price) { final int limit = 2000; final int discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // IT DOESN'T COMPILE public void discount(int price) { final var limit = 2000; final var discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><h2 id="punkt-21-lyambda-vyrazheniyam-i-ssylkam-na-metody-nuzhny-yavnye-tipy">  21:          </h2><br><p>  <strong>var</strong>   ,     .          ,   <strong>var</strong> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // lambda expression needs an explicit target-type var f = x -&gt; x + 1; // method reference needs an explicit target-type var exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Supplier&lt;IllegalArgumentException&gt; exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   Java 11   <strong>var</strong> -    .      Java 11: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 11 (var x, var y) -&gt; x + y // or (@Nonnull var x, @Nonnull var y) -&gt; x + y</span></span></code> </pre> <br><h2 id="punkt-22-inicializirovat-var-nullem-zaprescheno">  22:  var null'  </h2><br><p>   <strong>var</strong> -  . </p><br><p>     (  <strong>null</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message = null; // result in an error of type: variable initializer is 'null'</span></span></code> </pre> <br><p>      ( ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message; // result in: cannot use 'var' on variable without initializer ... message = "hello";</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String message = null; // or String message; ... message = "hello";</span></span></code> </pre> <br><h2 id="punkt-23-tip-var-nelzya-ispolzovat-v-polyah-klassa">  23:  var      </h2><br><p>    <strong>var</strong>   ,      . </p><br><p>      : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public class Product { private var price; // error: 'var' is not allowed here private var name; // error: 'var' is not allowed here ... }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public class Product { private int price; private String name; ... }</span></span></code> </pre> <br><h2 id="punkt-24-var-nelzya-ispolzovat-v-bloke-catch">  24: var     catch </h2><br><p>   ,    try-with-resources </p><br><h3 id="blok-catch">  catch </h3><br><p>    ,    ,   . </p><br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE try { TimeUnit.NANOSECONDS.sleep(5000); } catch (var ex) { ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER try { TimeUnit.NANOSECONDS.sleep(5000); } catch (InterruptedException ex) { ... }</span></span></code> </pre> <br><h3 id="try-with-resources"> Try-with-resources </h3><br><p> , <strong>var</strong>     <strong>try-with-resources</strong> . </p><br><p> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type try (PrintWriter writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><p>     <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var try (var writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><h2 id="punkt-25-tip-var-mozhno-ispolzovat-s-dzhenerikami">  25:  var     </h2><br><p> ,     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ T temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>   ,  <strong>var</strong>    ,       <strong>T</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>     ,      <strong>var</strong> : </p><br><pre> <code class="java hljs">codepublic &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)); numbers.add((T) Double.valueOf(<span class="hljs-number"><span class="hljs-number">3.9</span></span>)); numbers.add(t); numbers.add(<span class="hljs-string"><span class="hljs-string">"5"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><p>     <strong>List&lt;T&gt;</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(); <span class="hljs-comment"><span class="hljs-comment">// DON'T DO THIS, DON'T FORGET THE, T var numbers = new ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(3)); numbers.add((T) Double.valueOf(3.9)); numbers.add(t); numbers.add("5"); // error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><h2 id="punkt-26-budte-vnimatelny-s-tipom-var-pri-ispolzovanii-wildcards--kovariantov-i-kontrvariantov">  26:     var   Wildcards (?),    </h2><br><h3 id="ispolzovanie--wildcards"> ? Wildcards </h3><br><p>    <strong>var</strong>  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;?&gt; clazz = Integer.class; // use var var clazz = Integer.class;</span></span></code> </pre> <br><p>    <strong>Foo&lt;?&gt;</strong>  <strong>var</strong>  ,      ,    <strong>var</strong>    . </p><br><p>     ,   , , ,    .       ,     <strong>ArrayList</strong>  ,     <strong>Collection&lt;?&gt;</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Collection&lt;?&gt; stuff = new ArrayList&lt;&gt;(); stuff.add("hello"); // compile time error stuff.add("world"); // compile time error // use var, this will remove the error, but I don't think that this is // what you had in mind when you wrote the above code var stuff = new ArrayList&lt;&gt;(); strings.add("hello"); // no error strings.add("world"); // no error</span></span></code> </pre> <br><h3 id="ispolzovanie-kovariantov-foo--extends-t-i-kontrvariantov-foo--super-t">   (Foo &lt;? extends T&gt;)   (Foo &lt;? super T&gt;) </h3><br><p>  ,    : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;? extends Number&gt; intNumber = Integer.class; Class&lt;? super FilterReader&gt; fileReader = Reader.class;</span></span></code> </pre> <br><p>            ,    ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: Class&lt;Reader&gt; cannot be converted to Class&lt;? extends Number&gt; Class&lt;? extends Number&gt; intNumber = Reader.class; // error: Class&lt;Integer&gt; cannot be converted to Class&lt;? super FilterReader&gt; Class&lt;? super FilterReader&gt; fileReader = Integer.class;</span></span></code> </pre> <br><p>    <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var var intNumber = Integer.class; var fileReader = Reader.class;</span></span></code> </pre> <br><p>       ,     .        ‚Äì     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// this will compile just fine var intNumber = Reader.class; var fileReader = Integer.class;</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>       ¬´ <strong>var</strong> ¬ª,    Java 10.    ,           .   ,      <strong>var</strong>    ,     . </p><br><p>  <strong>var</strong>      Java! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438206/">https://habr.com/ru/post/438206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438190/index.html">¬øCu√°les son los procedimientos de adquisici√≥n (en palabras simples)</a></li>
<li><a href="../438196/index.html">Si el proyecto es "Teatro", use actores ...</a></li>
<li><a href="../438198/index.html">Profundicemos en la historia: ¬ød√≥nde crecen las patas de los cuadric√≥pteros?</a></li>
<li><a href="../438202/index.html">JavaScript: Campos de clase p√∫blicos y privados</a></li>
<li><a href="../438204/index.html">Dispositivo compilador r√°pido. Parte 1</a></li>
<li><a href="../438210/index.html">Civilizaci√≥n de Springs, 2/5</a></li>
<li><a href="../438212/index.html">Prueba de concepto: c√≥mo verificar la implementaci√≥n de ML vale la pena</a></li>
<li><a href="../438214/index.html">Las nuevas empresas tecnol√≥gicas de EE. UU. Enfrentar√°n nuevos controles gubernamentales en 2019</a></li>
<li><a href="../438218/index.html">OpenSceneGraph: manejo de eventos</a></li>
<li><a href="../438224/index.html">Barrio del gobierno. Piloto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>