<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📃 🈸 🐿️ Layanan microser on Go dengan kit Go: Pendahuluan 👩‍🚒 ⛔️ 👦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya akan menjelaskan penggunaan kit Go, seperangkat alat dan perpustakaan untuk membuat layanan mikro di Go. Artikel ini adalah peng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Layanan microser on Go dengan kit Go: Pendahuluan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430300/"><p>  Pada artikel ini saya akan menjelaskan penggunaan kit Go, seperangkat alat dan perpustakaan untuk membuat layanan mikro di Go.  Artikel ini adalah pengantar untuk perangkat Go.  Bagian pertama di blog saya, kode sumber untuk contoh tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><a name="habracut"></a><br><p> Go semakin dipilih untuk pengembangan sistem terdistribusi modern.  Ketika Anda mengembangkan sistem terdistribusi berbasis cloud, Anda mungkin perlu mendukung berbagai fungsionalitas spesifik dalam layanan Anda, seperti: berbagai protokol transportasi ( <em>dll., HTTP, gRPC, dll.</em> ) Dan format penyandian pesan untuk mereka, keandalan RPC, pencatatan , melacak, metrik dan profil, menginterupsi permintaan, membatasi jumlah permintaan, mengintegrasikan ke dalam infrastruktur, dan bahkan menggambarkan arsitektur.  Go adalah bahasa yang populer karena kesederhanaannya dan pendekatan "tanpa sihir", oleh karena itu paket Go, misalnya, perpustakaan standar, sudah lebih cocok untuk mengembangkan sistem terdistribusi daripada menggunakan kerangka kerja lengkap dengan banyak "sihir di bawah tenda".  Secara pribadi, saya [ <em>kira-kira.</em>  <em>trans.</em>  <em>Shiju Varghese</em> ] Saya tidak mendukung penggunaan kerangka kerja lengkap, saya lebih suka menggunakan perpustakaan yang memberikan lebih banyak kebebasan kepada pengembang.  Kit Go mengisi celah di ekosistem Go, sehingga memungkinkan untuk menggunakan satu set perpustakaan dan paket saat membuat layanan mikro, yang pada gilirannya memungkinkan penggunaan prinsip-prinsip yang baik untuk merancang layanan individual dalam sistem terdistribusi. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="gambar"></p><br><h3 id="vvedenie-v-go-kit">  Pengantar Go kit </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go kit</a> adalah sekumpulan paket Go yang membuatnya mudah untuk membangun layanan microser yang andal dan didukung.  Go kit menyediakan pustaka untuk mengimplementasikan berbagai komponen arsitektur aplikasi yang transparan dan andal, menggunakan lapisan seperti pencatatan, metrik, penelusuran, pembatasan, dan interupsi permintaan yang diperlukan untuk menjalankan layanan Microsoft pada prod.  Go kit bagus karena memiliki alat yang diimplementasikan dengan baik untuk berinteraksi dengan berbagai infrastruktur, format penyandian pesan, dan berbagai lapisan transportasi. </p><br><p>  Selain serangkaian perpustakaan untuk mengembangkan layanan dunia, ia menyediakan dan mendorong penggunaan prinsip-prinsip yang baik untuk merancang arsitektur layanan Anda.  Kit Go membantu Anda mematuhi prinsip-prinsip SOLID, pendekatan berorientasi subjek (DDD) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur heksagonal yang</a> diusulkan oleh <em>Alistair Cockburn</em> atau pendekatan lain dari prinsip-prinsip arsitektur yang dikenal sebagai " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur bawang</a> " oleh <em>Jeffrey Palermo</em> dan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur bersih</a> " oleh <em>Robert C. Martin</em> .  Meskipun Go kit dirancang sebagai satu set paket untuk mengembangkan layanan microser, itu juga cocok untuk mengembangkan monolit yang elegan. </p><br><h3 id="arhitektura-go-kit">  Perangkat Arsitektur Go </h3><br><p>  Tiga tingkat utama dalam arsitektur aplikasi yang dikembangkan menggunakan Go kit adalah: </p><br><ul><li>  tingkat transportasi </li><li>  tingkat titik akhir </li><li>  tingkat layanan </li></ul><br><h4 id="transportnyy-uroven">  Tingkat transportasi </h4><br><p>  Ketika Anda menulis layanan microser untuk sistem terdistribusi, layanan di dalamnya sering harus berkomunikasi satu sama lain menggunakan berbagai protokol transportasi, seperti: HTTP atau gRPC, atau menggunakan sistem pub / sub, seperti NATS.  Lapisan transport dalam kit Go terikat dengan protokol transport spesifik (selanjutnya transport).  Go kit mendukung berbagai transportasi untuk layanan Anda, seperti: HTTP, gRPC, NATS, AMQP dan Thirft ( <em>sekitar. Anda juga dapat mengembangkan transportasi Anda sendiri untuk protokol Anda</em> ).  Oleh karena itu, layanan yang ditulis menggunakan kit Go seringkali berfokus pada implementasi logika bisnis tertentu yang tidak tahu apa-apa tentang transportasi yang digunakan, Anda bebas menggunakan transportasi berbeda untuk layanan yang sama.  Sebagai contoh, satu layanan yang ditulis dalam Go kit dapat secara bersamaan memberikan akses ke sana melalui HTTP dan gRPC. </p><br><h4 id="endpointy">  Titik akhir </h4><br><p>  Titik akhir atau titik akhir adalah blok bangunan mendasar untuk layanan dan pelanggan.  Di Go kit, pola komunikasi utama adalah RPC.  Endpoint disajikan sebagai metode RPC terpisah.  Setiap metode layanan dalam kit Go dikonversi ke titik akhir, memungkinkan Anda untuk berkomunikasi antara server dan klien dalam gaya RCP.  Setiap titik akhir memperlihatkan metode layanan menggunakan layer Transport, yang pada gilirannya menggunakan berbagai protokol transport, seperti HTTP atau gRPC.  Titik akhir yang terpisah dapat ditetapkan dari layanan secara bersamaan menggunakan beberapa transportasi ( <em>kira-kira Lane HTTP dan gRPC pada port yang berbeda</em> ). </p><br><h4 id="servisy">  Layanan </h4><br><p>  Logika bisnis diimplementasikan dalam lapisan layanan.  Layanan yang ditulis dengan Go kit dirancang sebagai antarmuka.  Logika bisnis di lapisan layanan berisi inti utama dari logika bisnis, yang seharusnya tidak mengetahui apa pun tentang titik akhir yang digunakan atau protokol transportasi tertentu, seperti HTTP atau gRPC, atau tentang penyandian atau pengodean permintaan dan respons dari berbagai jenis pesan.  Ini akan memungkinkan Anda untuk mematuhi arsitektur bersih dalam layanan yang ditulis menggunakan kit Go.  Setiap metode layanan dikonversi ke titik akhir menggunakan adaptor dan diekspos di luar menggunakan transportasi tertentu.  Melalui penggunaan arsitektur bersih, satu metode dapat diatur menggunakan beberapa transport pada saat yang bersamaan. </p><br><h3 id="primery">  Contohnya </h3><br><p>  Dan sekarang mari kita lihat lapisan yang dijelaskan di atas menggunakan contoh aplikasi sederhana. </p><br><h4 id="biznes-logika-v-servise">  Logika bisnis dalam layanan </h4><br><p>  Logika bisnis dalam layanan dirancang menggunakan antarmuka.  Kami akan melihat contoh pesanan dalam e-commerce: </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Antarmuka layanan pesanan berfungsi dengan entitas domain pesanan: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Di sini kami mengimplementasikan antarmuka layanan Order: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov">  Permintaan dan Jawaban untuk Titik Akhir RPC </h4><br><p>  Metode layanan terpapar sebagai titik akhir RPC.  Jadi kita perlu menentukan jenis pesan ( <em>kira-kira Per. DTO - objek transfer data</em> ) yang akan digunakan untuk mengirim dan menerima pesan melalui titik akhir RPC.  Sekarang mari kita mendefinisikan struktur untuk tipe permintaan dan respons untuk titik akhir RPC di layanan Pesanan: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy">  Pergi endpoint kit untuk metode layanan seperti titik akhir RPC </h4><br><p>  Inti dari logika bisnis kami dipisahkan dari sisa kode dan dimasukkan ke dalam lapisan layanan, yang diekspos menggunakan titik akhir RPC, yang menggunakan abstraksi Go Kit yang disebut <code>Endpoint</code> . </p><br><p>  Beginilah tampilan titik akhir dari perangkat Go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p>  Seperti yang kami katakan di atas, titik akhir mewakili metode RPC yang terpisah.  Setiap metode layanan dikonversi ke <code>endpoint.Endpoint</code> . <code>endpoint.Endpoint</code> menggunakan adaptor.  Mari kita buat titik akhir Go kit untuk metode layanan Pemesanan: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p>  Adaptor titik akhir menerima antarmuka sebagai argumen ke input dan mengubahnya menjadi abstraksi <code>endpoint.Enpoint</code> Go kit. <code>endpoint.Enpoint</code> membuat setiap metode layanan individu sebagai titik akhir.  Fungsi adaptor ini membuat perbandingan dan mengetik konversi untuk permintaan, memanggil metode layanan dan mengembalikan pesan respons. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http">  Mengekspos layanan menggunakan HTTP </h4><br><p>  Kami menciptakan layanan kami dan menjelaskan titik akhir RPC untuk mengekspos metode layanan kami.  Sekarang kita perlu menerbitkan layanan kami di luar sehingga layanan lain dapat memanggil titik akhir RCP.  Untuk mengekspos layanan kami, kami perlu menentukan protokol transportasi untuk layanan kami, yang menurutnya akan menerima permintaan.  Go kit mendukung berbagai transportasi, seperti HTTP, gRPC, NATS, AMQP dan Thrift di luar kotak. </p><br><p>  Sebagai contoh, kami menggunakan transportasi HTTP untuk layanan kami.  Paket go kit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://github.com/go-kit/kit/transport/">github.com/go-kit/kit/transport/http</a> menyediakan kemampuan untuk melayani permintaan HTTP.  Dan fungsi <code>NewServer</code> dari paket <code>transport/http</code> akan membuat server http baru yang akan mengimplementasikan <code>http.Handler</code> dan membungkus titik akhir yang disediakan. </p><br><p>  Di bawah ini adalah kode yang mengubah titik akhir kit Go ke transport HTTP yang melayani permintaan HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p>  Kami membuat <code>http.Handler</code> menggunakan fungsi <code>NewServer</code> dari paket <code>transport/http</code> , yang menyediakan titik akhir dan meminta fungsi decoding (mengembalikan nilai <code>type DecodeRequestFunc func</code> ) dan pengkodean respons (mis. <code>type EncodeReponseFunc func</code> ). </p><br><p>  Berikut ini adalah contoh <code>DecodeRequestFunc</code> dan <code>EncodeResponseFunc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera">  Mulai server HTTP </h4><br><p>  Akhirnya, kita dapat menjalankan server HTTP untuk memproses permintaan.  Fungsi <code>NewService</code> dijelaskan di atas mengimplementasikan antarmuka <code>http.Handler</code> yang memungkinkan kita untuk menjalankannya sebagai server HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p>  Sekarang layanan kami diluncurkan dan menggunakan protokol HTTP di tingkat transportasi.  Layanan yang sama dapat mulai menggunakan transportasi lain. Misalnya, layanan dapat diekspos menggunakan gRPC atau Apache Thrift. </p><br><p>  Untuk artikel pengantar, kami telah menggunakan cukup primitif Go kit, tetapi juga menyediakan lebih banyak fungsi untuk membuat sistem yang transparan, pola yang andal, penemuan layanan, penyeimbangan beban, dll.  Kami akan membahas ini dan hal-hal lain dalam kit Go di artikel berikut. </p><br><h3 id="ishodnyy-kod">  Kode sumber </h3><br><p>  Seluruh kode sumber untuk contoh dapat dilihat di GitHub di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </p><br><h3 id="middlewares-v-go-kit">  Middlewares dalam Go kit </h3><br><p>  Go kit merupakan predisposisi untuk penggunaan prinsip-prinsip desain sistem yang baik, seperti layering.  Isolasi komponen layanan dan titik akhir dimungkinkan menggunakan Middlewares ( <em>kira-kira pola mediator Lane</em> ).  Middlewares dalam kit Go menyediakan mekanisme yang kuat di mana Anda dapat membungkus layanan dan titik akhir dan menambahkan fungsionalitas (komponen terisolasi), seperti pencatatan, gangguan permintaan, membatasi jumlah permintaan, penyeimbangan muatan, atau pelacakan terdistribusi. </p><br><p>  Di bawah ini adalah gambar dari situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go kit</a> , yang digambarkan sebagai "arsitektur bawang" khas yang menggunakan Middlewares dalam kit Go: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="gambar"></p><br><h3 id="osteregaytes-sindroma-spring-boot-misroservices">  Waspadalah terhadap Spring Boot Microservices Syndrome </h3><br><p>  Seperti Go kit, Spring Boot adalah toolkit microservice di dunia Java.  Tapi, tidak seperti Go kit, Spring Boot adalah kerangka kerja yang sangat matang.  Juga, banyak pengembang Java menggunakan Spring Boot untuk membuat layanan dunia menggunakan tumpukan Java dengan umpan balik positif dari penggunaan, beberapa dari mereka percaya bahwa layanan microser hanya tentang menggunakan Spring Boot.  Saya melihat banyak tim pengembangan yang salah mengartikan penggunaan layanan microser, bahwa mereka hanya dapat dikembangkan menggunakan Spring Boot dan Netflix OSS dan tidak menganggap layanan microser sebagai pola ketika mengembangkan sistem terdistribusi. </p><br><p>  Jadi perlu diingat bahwa dengan seperangkat alat, seperti kit Go atau semacam kerangka kerja, Anda mengarahkan pengembangan Anda ke arah mikro, sebagai pola desain.  Meskipun layanan microser memecahkan banyak masalah penskalaan baik pada perintah maupun sistem, ini juga menciptakan banyak masalah karena data dalam sistem berbasis layanan mikro tersebar di berbagai basis data, yang terkadang menciptakan banyak masalah saat membuat kueri transaksional atau data.  Itu semua tergantung pada masalah area subjek dan konteks sistem Anda.  Yang keren adalah bahwa kit Go, yang dirancang sebagai alat untuk membuat layanan microser, juga cocok untuk membuat monolit elegan yang dibuat dengan desain arsitektur yang bagus untuk sistem Anda. </p><br><p>  Dan beberapa fitur Go kit, seperti permintaan interupsi dan pembatasan, juga tersedia pada platform layanan, seperti Istio.  Jadi jika Anda menggunakan sesuatu seperti Istio untuk meluncurkan microseurises Anda, Anda mungkin tidak memerlukan beberapa hal dari kit Go, tetapi tidak semua orang akan memiliki cukup lebar saluran untuk menggunakan jala layanan untuk membuat komunikasi antar layanan, karena ini menambahkan lebih banyak satu tingkat dan kompleksitas tambahan. </p><br><h2 id="ps">  PS </h2><br><p>  Penulis terjemahan tidak boleh berbagi pendapat penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teks asli</a> , artikel ini telah diterjemahkan hanya untuk tujuan pendidikan untuk komunitas bahasa Rusia Go. </p><br><p>  <strong>UPD</strong> <br>  Ini juga artikel pertama di bagian terjemahan dan saya akan berterima kasih atas umpan balik pada terjemahan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430300/">https://habr.com/ru/post/id430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430286/index.html">Detail sisi berantakan dan gelap dari game bajak laut untuk Nintendo Switch</a></li>
<li><a href="../id430290/index.html">Upaya untuk memprediksi iterasi keempat dari proyek SpaceX BFR</a></li>
<li><a href="../id430292/index.html">Electronic Frontier Foundation: Kinerja jaringan plat polisi AS 0,5%</a></li>
<li><a href="../id430294/index.html">10 manfaat nyata dari penggunaan Rust</a></li>
<li><a href="../id430296/index.html">Jadikan ide Anda datang dengan aplikasi. Aplikasi tanpa server - petunjuk langkah demi langkah</a></li>
<li><a href="../id430302/index.html">Pengantar ptrace atau injeksi kode dalam sshd untuk bersenang-senang</a></li>
<li><a href="../id430304/index.html">Pos luar biasa di orbit</a></li>
<li><a href="../id430306/index.html">Terowongan pertama Perusahaan Boring dibor oleh Ilona Mask</a></li>
<li><a href="../id430308/index.html">Python internal. Telur paskah</a></li>
<li><a href="../id430312/index.html">Validasi bentuk kompleks React. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>