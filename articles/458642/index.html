<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜 🤜🏽 🎉 Teoría en lugar de heurística: mejorando como desarrolladores frontend 🍕 🏇🏾 🌗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Convertirse en un mejor desarrollador front-end usando fundamentos en lugar de heurística 

 Nuestra experiencia muestra que los educadores no técnico...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teoría en lugar de heurística: mejorando como desarrolladores frontend</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/458642/"><img src="https://habrastorage.org/getpro/habr/post_images/424/ed0/eec/424ed0eec08450f6be205e19896298a7.png"><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Convertirse en un mejor desarrollador front-end usando fundamentos en lugar de heurística</a></i> <br><br>  Nuestra experiencia muestra que los educadores no técnicos y las personas autodidactas a menudo confían no en principios teóricos, sino en métodos heurísticos. <br><br>  Heurística: patrones y reglas comprobadas que un desarrollador ha aprendido de la práctica.  Pueden funcionar de manera imperfecta o limitada, pero en un grado suficiente, y no requieren un pensamiento serio.  Aquí hay algunos ejemplos de heurística: <br><br><ul><li> "Use <code>$(document).ready(function(){})</code> para inicializar el código en los sitios jQuery" </li><li>  "El <code>var self = this</code> construcción es necesaria para llamar a un método en una función de devolución de llamada" </li><li>  "Las funciones de flecha no tienen <code>return</code> " <br></li></ul><br>  Al mismo tiempo, el principio teórico puede usarse para encontrar soluciones a otros problemas.  Él es invariablemente fiel y a menudo determina el dispositivo mismo de uno u otro elemento.  Los principios teóricos incluyen, por ejemplo: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La sintaxis oficial para las funciones de flecha</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentación API Lodash</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reglas de uso y funciones de alineación vertical</a> <br></li></ul><br>  Tenga en cuenta: citamos solo ejemplos heurísticos para enfatizar la naturaleza artesanal de la heurística en comparación con el rigor de los fundamentos teóricos.  Ninguno de los ejemplos heurísticos es universal para todos los casos, pero funcionan en un número suficiente de situaciones para que los desarrolladores que los usan reciban un código de trabajo sin una comprensión completa de su funcionamiento. <br><a name="habracut"></a><br><h2>  Argumentos para un enfoque teórico </h2><br>  A menudo nos encontramos con el hecho de que los desarrolladores sin educación técnica no están dispuestos a resolver problemas utilizando principios teóricos.  Como regla general, esto se explica por el hecho de que al comienzo de sus carreras no tuvieron la oportunidad de aprenderlos, y dado que los métodos heurísticos funcionan satisfactoriamente, continúan usándolos. <br><br>  Sin embargo, a pesar de la aparente complejidad, aprender una teoría puede ser muy útil.  Por qué  Entonces, esa teoría le permitirá sentirse seguro de que su solución funciona, así como mostrar de forma independiente las respuestas a nuevas preguntas, sin tener que buscar las soluciones de otra persona.  A corto plazo, los algoritmos heurísticos pueden parecer una solución simple y rápida, pero a menudo conducirán a soluciones imperfectas, si es que lo hacen. <br><br>  Además, al confiar en métodos heurísticos, nunca aprenderá a resolver problemas de verdad.  A menudo puede encontrar una solución que funcione, pero tarde o temprano se detendrá, de lo que no verá una salida.  Los programadores de C&amp;P confían en la heurística en su trabajo. <br><br><h2>  Criterios de nivel de habilidad de desarrollador </h2><br>  Al entrevistar a los desarrolladores frontend, establecemos una tarea de programación para ellos y decimos que son libres de usar cualquier fuente, ya sea Google o Stack Overflow.  De esta manera, es fácil determinar si el desarrollador es adherente a la heurística o la teoría. <br><br>  El primero, sin excepción, copia el código de ejemplos más o menos adecuados con Stack Overflow.  Solo cuando el código no funciona según lo planeado, comienzan a ajustarlo por sí mismos.  A menudo fallan. <br><br>  Estos últimos tienden a buscar respuestas en la documentación de la API.  Allí encuentran información sobre cuántos parámetros toma una función en particular, o la sintaxis específica de la forma expandida de la propiedad CSS deseada. <br><br>  Ya en los primeros cinco minutos de la entrevista puede determinar exactamente a qué tipo de programadores pertenece el candidato. <br><br><h2>  Ejemplo </h2><br>  Toma a Bill como ejemplo.  Completó varios cursos de capacitación, resolvió una serie de tareas en JavaScript y escribió sitios web en su tiempo libre, pero en realidad no aprendió JavaScript. <br><br>  Una vez que Bill se encuentra con un objeto como este: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> usersById = { <span class="hljs-string"><span class="hljs-string">"5"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adam"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"27"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"27"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bobby"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"32"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Clarence"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-string"><span class="hljs-string">"39"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"39"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Danielle"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"42"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ekaterina"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre><br>  Tal objeto puede mostrar una lista de usuarios y si se han registrado para un evento en particular. <br><br>  Supongamos que Bill necesita recuperar una lista de usuarios registrados.  En otras palabras, filtrarlos.  <code>.filter()</code> código en el que se <code>.filter()</code> método <code>.filter()</code> para filtrar la lista.  Entonces intenta algo como: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = usersById.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Y aquí está lo que obtiene: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: usersById.filter is not a <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br>  "Algo sin sentido", piensa Bill, porque vio el código en el que <code>.filter()</code> funcionaba como filtro. <br><br>  El problema es que Bill confió en el método heurístico.  No entiende que <code>filter</code> es un método definido en matrices, mientras que <code>usersById</code> es un objeto normal que no tiene un método de <code>filter</code> . <br><br>  El confundido Bill busca en Google el " <i>filtro javascript</i> ".  Encuentra muchas referencias a matrices y se da cuenta de que necesita convertir <code>usersById</code> en una matriz.  Luego, al preguntar " <i>javascript para convertir un objeto en una matriz</i> ", encuentra ejemplos usando <code>Object.keys()</code> en Stack Overflow.  Después de eso, intenta: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Esta vez no se muestra el error, pero, para sorpresa de Bill, el campo de <code>attendees</code> permanece vacío. <br><br>  El hecho es que <code>Object.keys()</code> devuelve las claves del objeto, pero no su valor.  De hecho, el nombre de la variable de <code>user</code> es fácilmente engañoso, porque no es un objeto de <code>user</code> , sino un identificador, es decir, una cadena.  Como el atributo <code>registered</code> no está definido para cadenas, el <code>filter</code> trata cada entrada como falsa y la matriz se deja vacía. <br><br>  Bill analiza más de cerca las respuestas de Stack Overflow y realiza el siguiente cambio: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id].registered);</code> </pre> <br>  Esta vez el resultado es mejor: <code>["5", "27", "39"]</code> .  Pero Bill quería obtener objetos de visitante, no su identificación. <br><br>  Para comprender cómo filtrar a los visitantes, Bill molesto busca un " <i>filtro de objetos javascript</i> ", examina los resultados de búsqueda de Stack Overflow y encuentra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta respuesta</a> con el siguiente código: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, predicate</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj) .filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function"> =&gt;</span></span> predicate(obj[key]) ) .reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, key</span></span></span><span class="hljs-function">) =&gt;</span></span> (res[key] = obj[key], res), {} );</code> </pre> <br>  Bill copia estas líneas e intenta: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter(usersById, user =&gt; user.registered);</code> </pre> <br>  Todo funciona, aunque no está claro por qué.  Bill no entiende por qué <code>reduce</code> necesita <code>reduce</code> y cómo se usa.  Además, Bill no entiende que acaba de definir un nuevo método no estándar para el <code>Object</code> global. <br><br>  Pero a Bill no le importa, ¡funciona!  Las consecuencias aún no le interesan. <br><br><h2>  ¿Qué hizo mal Bill? </h2><br>  Bill probó un método heurístico para resolver el problema y se topó con los siguientes problemas: <br><br><ol><li>  Usando <code>.filter()</code> en una variable, Bill obtuvo un <code>TypeError</code> .  No entendió que el <code>filter</code> no <code>filter</code> definido en objetos ordinarios. <br></li><li>  Utilizó <code>Object.keys()</code> para "convertir el objeto en una matriz", pero esto solo no trajo ningún resultado.  Necesitaba crear una matriz de valores de objetos. </li><li>  Incluso después de recibir los valores y usarlos como condición para el filtrado, recibió solo identificadores en lugar de los objetos de usuario asociados con estos identificadores.  Esto se debe a que la matriz filtrada contenía una ID, no objetos de usuario. </li><li>  Con el tiempo, Bill abandonó este enfoque y encontró una solución que funciona en Internet.  Sin embargo, todavía no entendía cómo funciona, y no perderá tiempo resolviéndolo, porque tiene otras cosas que hacer. <br></li></ol><br>  Este es un ejemplo artificial, pero nos hemos encontrado muchas veces con desarrolladores que resuelven problemas de la misma manera.  Para resolverlos de manera efectiva, debe alejarse de los métodos heurísticos y estudiar la teoría. <br><br><h2>  Pasemos a lo básico </h2><br>  Si Bill propugnara un enfoque teórico, el proceso se vería así: <br><br><ol><li>  Para identificar los datos de entrada dados y determinar la salida deseada, en el sentido de sus propiedades: <i>“Tengo un objeto cuyas claves son cadenas que representan ID y los valores son objetos que representan usuarios.</i>  <i>Quiero obtener una matriz cuyos valores serán objetos de usuario, pero solo objetos de usuarios registrados "</i> </li><li>  Para comprender cómo buscar dentro de un objeto: <i>“Sé que puedo obtener una matriz de claves en un objeto llamando a <code>Object.keys()</code> .</i>  <i>Quiero obtener una matriz porque las matrices admiten la enumeración "</i> . </li><li>  Para darse cuenta de que este método ayuda a obtener las claves, y necesita transformar las claves en valores, y recordar sobre el <code>map</code> , un método obvio de crear una nueva matriz mediante la transformación de los valores de otra matriz: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id])</code> </pre> </li><li>  Para ver que ahora tiene una matriz de objetos de usuario que se pueden filtrar y que contiene valores reales que desea filtrar: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id]).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered)</code> </pre> </li></ol><br>  Vaya Bill de esta manera, podría trabajar para nosotros. <br><br><h2>  ¿Por qué la gente no recurre a la teoría con más frecuencia? </h2><br>  A veces simplemente no la conocen.  En la mayoría de los casos, están demasiado ocupados y no pueden encontrar el tiempo para aprender esta forma de resolver problemas: solo necesitan todo para funcionar.  Se arriesgan a convertir este enfoque en un hábito que se convertirá en un obstáculo para el desarrollo de sus habilidades. <br><br>  Para evitar tales errores, siempre comience con una teoría.  En cada etapa del proceso, piense en qué tipo de datos está tratando.  En lugar de confiar en patrones familiares todo el tiempo, considere los tipos de datos primitivos: matriz, objeto, cadena, etc.  Cuando utilice una función o método, consulte la documentación para saber exactamente qué tipos de datos los admiten, qué argumentos toman y cuál es el resultado. <br><br>  Con este enfoque, puede encontrar una solución de trabajo en el primer intento.  Puede estar seguro de su corrección, ya que seleccionó especialmente sus acciones en función de la entrada dada y la salida deseada.  Profundice en los conceptos básicos de cada operación (tipos de datos y valores de retorno), en lugar de formulaciones comerciales confusas (como "usuarios registrados"). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458642/">https://habr.com/ru/post/458642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458632/index.html">Realmente escribiendo vue</a></li>
<li><a href="../458634/index.html">"No seas malvado" o lo que Facebook nos oculta</a></li>
<li><a href="../458636/index.html">Cintas de video de mitap DevLeads de la oficina de Tutu.ru</a></li>
<li><a href="../458638/index.html">Proyecto Intel oneAPI: muchas arquitecturas, una API</a></li>
<li><a href="../458640/index.html">Encontrar un guión largo</a></li>
<li><a href="../458646/index.html">Swaps atómicos en pocas palabras</a></li>
<li><a href="../458648/index.html">CI / CD con AWS y Bamboo</a></li>
<li><a href="../458650/index.html">Cyber ​​Challenge. Un nuevo nivel. Competencia en línea de Rostelecom Solar</a></li>
<li><a href="../458652/index.html">RamblerFront y Meetup # 7</a></li>
<li><a href="../458654/index.html">El virus Lurk hackeó bancos mientras fue escrito por trabajadores contratados ordinarios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>