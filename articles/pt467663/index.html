<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèø üëë ‚ôäÔ∏è Suporte para instru√ß√µes espec√≠ficas de hardware no .NET Core (agora n√£o apenas no SIMD) ü§† üë®üèø‚Äçüè≠ ‚õëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 


 Alguns anos atr√°s, decidimos que era hora de oferecer suporte ao c√≥digo SIMD no .NET . Introduzimos o namespace System.Numerics com ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suporte para instru√ß√µes espec√≠ficas de hardware no .NET Core (agora n√£o apenas no SIMD)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/467663/"><h2 id="vvedenie">  1. Introdu√ß√£o </h2><br><p> Alguns anos atr√°s, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">decidimos que era hora de oferecer suporte ao c√≥digo SIMD no .NET</a> .  Introduzimos o namespace <code>System.Numerics</code> com os tipos <code>Vector2</code> , <code>Vector3</code> , <code>Vector4</code> e <code>Vector&lt;T&gt;</code> .  Esses tipos representam uma API de uso geral para criar, acessar e manipular instru√ß√µes vetoriais sempre que poss√≠vel.  Eles tamb√©m fornecem compatibilidade de software para os casos em que o hardware n√£o suporta instru√ß√µes adequadas.  Isso permitiu, com refatora√ß√£o m√≠nima, vetorizar v√°rios algoritmos.  Seja como for, a generalidade dessa abordagem dificulta a aplica√ß√£o para obter todas as vantagens de todas as instru√ß√µes vetoriais dispon√≠veis, em hardware moderno.  Al√©m disso, o hardware moderno fornece v√°rias instru√ß√µes especializadas, n√£o vetoriais, que podem melhorar significativamente o desempenho.  Neste artigo, falarei sobre como contornamos essas limita√ß√µes no .NET Core 3.0. </p><br><p><img src="https://habrastorage.org/webt/4d/mx/lt/4dmxlt8xgnpgncvellsujvoe_rk.jpeg"><br>  <strong>Nota: Ainda</strong> <em>n√£o existe um termo estabelecido para a tradu√ß√£o <strong>Intrisics</strong> .</em>  <em>No final do artigo, h√° um voto para a op√ß√£o de tradu√ß√£o.</em>  <em>Se escolhermos uma boa op√ß√£o, mudaremos o artigo</em> </p><a name="habracut"></a><br><h2 id="chto-takoe-vstroennye-funkcii">  Quais s√£o as fun√ß√µes incorporadas </h2><br><p>  No .NET Core 3.0, adicionamos novas funcionalidades chamadas fun√ß√µes <em>internas espec√≠ficas do hardware</em> (WF remoto).  Essa <em>funcionalidade</em> fornece acesso a muitas instru√ß√µes espec√≠ficas de hardware que n√£o podem ser simplesmente representadas por mecanismos de uso geral.  Eles diferem das instru√ß√µes SIMD existentes por n√£o terem uma finalidade geral (os novos <em>WFs</em> n√£o s√£o multiplataforma e sua arquitetura n√£o fornece compatibilidade de software).  Em vez disso, eles fornecem diretamente funcionalidade espec√≠fica de plataforma e hardware para desenvolvedores .NET.  As fun√ß√µes SIMD existentes, por exemplo, multiplataforma, oferecem compatibilidade de software e s√£o um pouco abstra√≠das do hardware subjacente.  Essa abstra√ß√£o pode ser cara, al√©m disso, pode impedir a divulga√ß√£o de algumas funcionalidades (quando, por exemplo, a funcionalidade n√£o existe ou √© dif√≠cil de emular em todas as plataformas de destino). </p><br><p>  Novas <em>fun√ß√µes</em> internas e tipos suportados est√£o localizados no <code>System.Runtime.Intrinsics</code> .  Para o .NET Core 3.0, no momento, h√° um <code>System.Runtime.Intrinsics.X86</code> .  Estamos trabalhando no suporte <em>de fun√ß√µes internas</em> para outras plataformas, como <code>System.Runtime.Intrinsics.Arm</code> . </p><br><p>  Em espa√ßos de nome espec√≠ficos da plataforma, os <em>WFs</em> s√£o agrupados em classes que representam grupos de instru√ß√µes de hardware integradas de maneira l√≥gica (geralmente chamadas de arquitetura de conjunto de instru√ß√µes (ISA)).  Cada classe fornece uma propriedade <code>IsSupported</code> indica se o hardware no qual o c√≥digo est√° executando suporta este conjunto de instru√ß√µes.  Al√©m disso, cada uma dessas classes cont√©m um conjunto de m√©todos mapeados para um conjunto correspondente de instru√ß√µes.  √Äs vezes, h√° uma subclasse adicional que corresponde a uma parte do mesmo conjunto de instru√ß√µes, que pode ser limitada (suportada) por hardware espec√≠fico.  Por exemplo, a classe <code>Lzcnt</code> fornece acesso a <em>instru√ß√µes para contar zeros √† esquerda</em> .  Ele tem uma subclasse chamada <code>X64</code> , que cont√©m o formato dessas instru√ß√µes usadas apenas em m√°quinas com arquitetura de 64 bits. </p><br><p>  Algumas dessas classes s√£o naturalmente de natureza hier√°rquica.  Por exemplo, se <code>Lzcnt.X64.IsSupported</code> retornar true, <code>Lzcnt.IsSupported</code> tamb√©m dever√° retornar true, pois essa √© uma subclasse expl√≠cita.  Ou, por exemplo, se <code>Sse2.IsSupported</code> retornar true, <code>Sse.IsSupported</code> dever√° retornar true, porque o <code>Sse2</code> herda explicitamente do <code>Sse</code> .  No entanto, vale ressaltar que a semelhan√ßa dos nomes de classe n√£o √© um indicador de que eles pertencem √† mesma hierarquia de heran√ßa.  Por exemplo, o <code>Bmi2</code> n√£o <code>Bmi2</code> herdado do <code>Bmi1</code> , portanto, os valores retornados pelo <code>IsSupported</code> para esses dois conjuntos de instru√ß√µes ser√£o diferentes.  O princ√≠pio fundamental no desenvolvimento dessas classes foi a apresenta√ß√£o expl√≠cita das especifica√ß√µes ISA.  O SSE2 requer suporte para o SSE1, portanto, as classes que os representam s√£o relacionadas por heran√ßa.  Ao mesmo tempo, o IMC2 n√£o requer suporte para o IMC1, portanto, n√£o usamos heran√ßa.  A seguir, √© apresentado um exemplo da API acima. </p><br><pre> <code class="plaintext hljs">namespace System.Runtime.Intrinsics.X86 { public abstract class Sse { public static bool IsSupported { get; } public static Vector128&lt;float&gt; Add(Vector128&lt;float&gt; left, Vector128&lt;float&gt; right); // Additional APIs public abstract class X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;float&gt; value); // Additional APIs } } public abstract class Sse2 : Sse { public static new bool IsSupported { get; } public static Vector128&lt;byte&gt; Add(Vector128&lt;byte&gt; left, Vector128&lt;byte&gt; right); // Additional APIs public new abstract class X64 : Sse.X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;double&gt; value); // Additional APIs } } }</code> </pre> <br><p>  Voc√™ pode ver mais no c√≥digo-fonte nos seguintes links <a href="">source.dot.net ou dotnet / coreclr no GitHub</a> </p><br><p>  <code>IsSupported</code> verifica√ß√µes <code>IsSupported</code> processadas pelo compilador JIT como constantes de tempo de execu√ß√£o (quando a otimiza√ß√£o est√° ativada); portanto, voc√™ n√£o precisa de compila√ß√£o cruzada para suportar v√°rios ISAs, plataformas ou arquiteturas.  Em vez disso, basta escrever o c√≥digo usando express√µes <code>if</code> , como resultado das ramifica√ß√µes de c√≥digo n√£o utilizadas (ou seja, aquelas ramifica√ß√µes que n√£o s√£o alcan√ß√°veis ‚Äã‚Äãdevido ao valor da vari√°vel na instru√ß√£o condicional) ser√£o descartadas quando o c√≥digo nativo for gerado. </p><br><p>  √â importante que a verifica√ß√£o do <code>IsSupported</code> correspondente anteceda o uso dos comandos de hardware embutidos.  Se n√£o houver essa verifica√ß√£o, o c√≥digo que usa comandos espec√≠ficos da plataforma em execu√ß√£o nas plataformas / arquiteturas onde esses comandos n√£o s√£o suportados lan√ßar√° uma exce√ß√£o de tempo de execu√ß√£o <code>PlatformNotSupportedException</code> . </p><br><h2 id="kakie-preimuschestva-oni-dayut">  Quais benef√≠cios eles oferecem? </h2><br><p>  Obviamente, <em>fun√ß√µes internas espec√≠ficas de hardware</em> n√£o <em>s√£o</em> para todos, mas podem ser usadas para melhorar o desempenho em opera√ß√µes carregadas com c√°lculos.  <code>CoreFX</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>ML.NET</code></a> <code>CoreFX</code> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>ML.NET</code></a> usam esses m√©todos para acelerar opera√ß√µes como copiar na mem√≥ria, pesquisar o √≠ndice de um elemento em uma matriz ou string, redimensionar uma imagem ou trabalhar com vetores / matrizes / tensores.  A vetoriza√ß√£o manual de algum c√≥digo que acabou sendo um gargalo tamb√©m pode ser mais simples do que parece.  A vetoriza√ß√£o do c√≥digo, de fato, √© executar v√°rias opera√ß√µes por vez, em geral, usando instru√ß√µes SIMD (um fluxo de instru√ß√µes, fluxo de dados m√∫ltiplo). </p><br><p>  Antes de decidir vetorizar algum c√≥digo, √© necess√°rio executar a cria√ß√£o de perfil para garantir que esse c√≥digo seja realmente parte do "hot spot" (e, portanto, sua otimiza√ß√£o dar√° um aumento significativo no desempenho).  Tamb√©m √© importante realizar a cria√ß√£o de perfil em cada est√°gio da vetoriza√ß√£o, pois a vetoriza√ß√£o de nem todo o c√≥digo leva ao aumento da produtividade. </p><br><h2 id="vektorizaciya-prostogo-algoritma">  Vetoriza√ß√£o de um algoritmo simples </h2><br><p>  Para ilustrar o uso de <em>fun√ß√µes internas,</em> adotamos o algoritmo para somar todos os elementos de uma matriz ou intervalo.  Esse tipo de c√≥digo √© um candidato ideal para vetoriza√ß√£o, porque  a cada itera√ß√£o, a mesma opera√ß√£o trivial √© executada. </p><br><p>  Um exemplo de implementa√ß√£o de um algoritmo desse tipo pode ser da seguinte maneira: </p><br><pre> <code class="plaintext hljs">public int Sum(ReadOnlySpan&lt;int&gt; source) { int result = 0; for (int i = 0; i &lt; source.Length; i++) { result += source[i]; } return result; }</code> </pre> <br><p>  Esse c√≥digo √© bastante simples e direto, mas ao mesmo tempo lento o suficiente para grandes dados de entrada, como  faz apenas uma opera√ß√£o trivial por itera√ß√£o. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 AMD Ryzen 7 1800X, 1 CPU, 16 logical and 8 physical cores .NET Core SDK=3.0.100-preview9-013775 [Host] : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT [AttachedDebugger] DefaultJob : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Contagem </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Soma </td><td>  1 </td><td>  2.477 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Soma </td><td>  2 </td><td>  2.164 ns </td><td>  0,0265 ns </td><td>  0,0235 ns </td></tr><tr><td>  Soma </td><td>  4 </td><td>  3,242 ns </td><td>  0,0302 ns </td><td>  0,0267 ns </td></tr><tr><td>  Soma </td><td>  8 </td><td>  4,347 ns </td><td>  0,0665 ns </td><td>  0,0622 ns </td></tr><tr><td>  Soma </td><td>  16 </td><td>  8.444 ns </td><td>  0.2042 ns </td><td>  0,3734 ns </td></tr><tr><td>  Soma </td><td>  32. </td><td>  13,963 ns </td><td>  0,2182 ns </td><td>  0.2041 ns </td></tr><tr><td>  Soma </td><td>  64 </td><td>  50.374 ns </td><td>  0,2955 ns </td><td>  0,2620 ns </td></tr><tr><td>  Soma </td><td>  128 </td><td>  60.139 ns </td><td>  0,3890 ns </td><td>  0,3639 ns </td></tr><tr><td>  Soma </td><td>  256 </td><td>  106.416 ns </td><td>  0,6404 ns </td><td>  0,5990 ns </td></tr><tr><td>  Soma </td><td>  512 </td><td>  291,450 ns </td><td>  3.5148 ns </td><td>  3,2878 ns </td></tr><tr><td>  Soma </td><td>  1024 </td><td>  574,243 ns </td><td>  9.5851 ns </td><td>  8.4970 ns </td></tr><tr><td>  Soma </td><td>  2048 </td><td>  1 137,819 ns </td><td>  5.9363 ns </td><td>  5.5529 ns </td></tr><tr><td>  Soma </td><td>  4096 </td><td>  2 228,341 ns </td><td>  22.8882 ns </td><td>  21.4097 ns </td></tr><tr><td>  Soma </td><td>  8192 </td><td>  2 973.040 ns </td><td>  14.2863 ns </td><td>  12.6644 ns </td></tr><tr><td>  Soma </td><td>  16384 </td><td>  5 883,504 ns </td><td>  15.9619 ns </td><td>  14.9308 ns </td></tr><tr><td>  Soma </td><td>  32768 </td><td>  11 699,237 ns </td><td>  104.0970 ns </td><td>  97.3724 ns </td></tr></tbody></table></div><br><h2 id="povyshenie-proizvoditelnosti-za-schet-razvertyvaniya-ciklov">  Aumente a produtividade atrav√©s de ciclos de implanta√ß√£o </h2><br><p>  Os processadores modernos t√™m v√°rias op√ß√µes para melhorar o desempenho do c√≥digo.  Para aplicativos de encadeamento √∫nico, uma dessas op√ß√µes √© executar v√°rias opera√ß√µes primitivas em um √∫nico ciclo do processador. </p><br><p>  A maioria dos processadores modernos pode executar quatro opera√ß√µes adicionais em um ciclo de clock (em condi√ß√µes ideais), como resultado, com o "layout" correto do c√≥digo, √†s vezes voc√™ pode melhorar o desempenho, mesmo em uma implementa√ß√£o de thread √∫nico. </p><br><p>  Embora o JIT possa executar o desenrolamento de loop por conta pr√≥pria, o JIT √© conservador ao tomar esse tipo de decis√£o, devido ao tamanho do c√≥digo gerado.  Portanto, pode ser vantajoso implantar um loop, no c√≥digo, manualmente. </p><br><p>  Voc√™ pode expandir o loop no c√≥digo acima da seguinte maneira: </p><br><pre> <code class="plaintext hljs">public unsafe int SumUnrolled(ReadOnlySpan&lt;int&gt; source) { int result = 0; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); // Pin source so we can elide the bounds checks fixed (int* pSource = source) { while (i &lt; lastBlockIndex) { result += pSource[i + 0]; result += pSource[i + 1]; result += pSource[i + 2]; result += pSource[i + 3]; i += 4; } while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Esse c√≥digo √© um pouco mais complicado, mas faz melhor uso dos recursos de hardware. </p><br><p>  Para loops realmente pequenos, esse c√≥digo √© um pouco mais lento.  Mas essa tend√™ncia j√° est√° mudando para dados de entrada de oito elementos, ap√≥s os quais a velocidade de execu√ß√£o come√ßa a aumentar (o tempo de execu√ß√£o do c√≥digo otimizado, para 32 mil elementos, √© 26% menor que o tempo da vers√£o original).  Vale ressaltar que essa otimiza√ß√£o nem sempre aumenta a produtividade.  Por exemplo, ao trabalhar com cole√ß√µes com elementos do tipo <code>float</code> vers√£o "implantada" do algoritmo tem quase a mesma velocidade que a original.  Portanto, √© muito importante realizar a cria√ß√£o de perfil. </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Contagem </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumunrolled </td><td>  1 </td><td>  2.922 ns </td><td>  0,0651 ns </td><td>  0,0609 ns </td></tr><tr><td>  Sumunrolled </td><td>  2 </td><td>  3.576 ns </td><td>  0,0116 ns </td><td>  0,0109 ns </td></tr><tr><td>  Sumunrolled </td><td>  4 </td><td>  3,708 ns </td><td>  0,0157 ns </td><td>  0,0139 ns </td></tr><tr><td>  Sumunrolled </td><td>  8 </td><td>  4.832 ns </td><td>  0,0486 ns </td><td>  0,0454 ns </td></tr><tr><td>  Sumunrolled </td><td>  16 </td><td>  7.490 ns </td><td>  0.1131 ns </td><td>  0,1058 ns </td></tr><tr><td>  Sumunrolled </td><td>  32. </td><td>  11.277 ns </td><td>  0,0910 ns </td><td>  0,0851 ns </td></tr><tr><td>  Sumunrolled </td><td>  64 </td><td>  19.761 ns </td><td>  0.2016 ns </td><td>  0,1885 ns </td></tr><tr><td>  Sumunrolled </td><td>  128 </td><td>  36.639 ns </td><td>  0,3043 ns </td><td>  0,2847 ns </td></tr><tr><td>  Sumunrolled </td><td>  256 </td><td>  77.969 ns </td><td>  0.8409 ns </td><td>  0,7866 ns </td></tr><tr><td>  Sumunrolled </td><td>  512 </td><td>  146.357 ns </td><td>  1.3209 ns </td><td>  1.2356 ns </td></tr><tr><td>  Sumunrolled </td><td>  1024 </td><td>  287.354 ns </td><td>  0,9223 ns </td><td>  0,8627 ns </td></tr><tr><td>  Sumunrolled </td><td>  2048 </td><td>  566,405 ns </td><td>  4.0155 ns </td><td>  3.5596 ns </td></tr><tr><td>  Sumunrolled </td><td>  4096 </td><td>  1 131,016 ns </td><td>  7.3601 ns </td><td>  6.5246 ns </td></tr><tr><td>  Sumunrolled </td><td>  8192 </td><td>  2 259,836 ns </td><td>  8.6539 ns </td><td>  8.0949 ns </td></tr><tr><td>  Sumunrolled </td><td>  16384 </td><td>  4 501,295 ns </td><td>  6.4186 ns </td><td>  6.0040 ns </td></tr><tr><td>  Sumunrolled </td><td>  32768 </td><td>  8 979,690 ns </td><td>  19.5265 ns </td><td>  18.2651 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4b7/180/775/4b71807758bdae4be2fba1eb6af8360b.png"></p><br><h2 id="povyshenie-proizvoditelnosti-za-schet-vektorizacii-ciklov">  Aumente a produtividade atrav√©s da vetoriza√ß√£o de loop </h2><br><p>  Seja como for, mas ainda podemos otimizar ligeiramente esse c√≥digo.  As instru√ß√µes SIMD s√£o outra op√ß√£o fornecida pelos processadores modernos para melhorar o desempenho.  Usando uma √∫nica instru√ß√£o, eles permitem executar v√°rias opera√ß√µes em um √∫nico ciclo de rel√≥gio.  Isso pode ser melhor do que o desdobramento direto do loop, porque, de fato, √© feito o mesmo, mas com uma quantidade menor de c√≥digo gerado. </p><br><p>  Para esclarecer, cada opera√ß√£o de adi√ß√£o, em um ciclo implantado, leva 4 bytes.  Portanto, precisamos de 16 bytes para 4 opera√ß√µes de adi√ß√£o na forma expandida.  Ao mesmo tempo, a instru√ß√£o de adi√ß√£o SIMD tamb√©m realiza 4 opera√ß√µes de adi√ß√£o, mas leva apenas 4 bytes.  Isso significa que temos menos instru√ß√µes para a CPU.  Al√©m disso, no caso de uma instru√ß√£o SIMD, a CPU pode fazer <em>suposi√ß√µes</em> e executar otimiza√ß√µes, mas isso est√° al√©m do escopo deste artigo.  O que √© ainda melhor √© que os processadores modernos podem executar mais de uma instru√ß√£o SIMD por vez, ou seja, em alguns casos, voc√™ pode aplicar uma estrat√©gia mista, ao mesmo tempo em que executa uma varredura e vetoriza√ß√£o de ciclo parcial. </p><br><p>  Em geral, voc√™ precisa come√ßar observando a classe de uso geral <code>Vector&lt;T&gt;</code> para suas tarefas.  Ele, como os novos <em>WFs</em> , incorporar√° instru√ß√µes SIMD, mas, ao mesmo tempo, dada a versatilidade dessa classe, ele pode reduzir o n√∫mero de codifica√ß√£o "manual". </p><br><p>  O c√≥digo pode ficar assim: </p><br><pre> <code class="plaintext hljs">public int SumVectorT(ReadOnlySpan&lt;int&gt; source) { int result = 0; Vector&lt;int&gt; vresult = Vector&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % Vector&lt;int&gt;.Count); while (i &lt; lastBlockIndex) { vresult += new Vector&lt;int&gt;(source.Slice(i)); i += Vector&lt;int&gt;.Count; } for (int n = 0; n &lt; Vector&lt;int&gt;.Count; n++) { result += vresult[n]; } while (i &lt; source.Length) { result += source[i]; i += 1; } return result; }</code> </pre> <br><p>  Esse c√≥digo funciona mais r√°pido, mas somos for√ßados a nos referir a cada elemento separadamente ao calcular o valor final.  Al√©m disso, o <code>Vector&lt;T&gt;</code> n√£o possui um tamanho definido com precis√£o e pode variar, dependendo do equipamento no qual o c√≥digo est√° sendo executado.  <em>as fun√ß√µes</em> internas <em>espec√≠ficas do hardware</em> fornecem <em>funcionalidade</em> adicional que pode melhorar um pouco esse c√≥digo e torn√°-lo um pouco mais r√°pido (ao custo de complexidade adicional de c√≥digo e requisitos de manuten√ß√£o). </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Contagem </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  SumVectorT </td><td>  1 </td><td>  4.517 ns </td><td>  0,0752 ns </td><td>  0,0703 ns </td></tr><tr><td>  SumVectorT </td><td>  2 </td><td>  4.853 ns </td><td>  0,0609 ns </td><td>  0,0570 ns </td></tr><tr><td>  SumVectorT </td><td>  4 </td><td>  5.047 ns </td><td>  0,0909 ns </td><td>  0,0850 ns </td></tr><tr><td>  SumVectorT </td><td>  8 </td><td>  5.671 ns </td><td>  0,0251 ns </td><td>  0,0223 ns </td></tr><tr><td>  SumVectorT </td><td>  16 </td><td>  6.579 ns </td><td>  0,0330 ns </td><td>  0,0276 ns </td></tr><tr><td>  SumVectorT </td><td>  32. </td><td>  10.460 ns </td><td>  0,0241 ns </td><td>  0,0226 ns </td></tr><tr><td>  SumVectorT </td><td>  64 </td><td>  17.148 ns </td><td>  0,0407 ns </td><td>  0,0381 ns </td></tr><tr><td>  SumVectorT </td><td>  128 </td><td>  23.239 ns </td><td>  0,0853 ns </td><td>  0,0756 ns </td></tr><tr><td>  SumVectorT </td><td>  256 </td><td>  62.146 ns </td><td>  0,8319 ns </td><td>  0,7782 ns </td></tr><tr><td>  SumVectorT </td><td>  512 </td><td>  114.863 ns </td><td>  0,4175 ns </td><td>  0,3906 ns </td></tr><tr><td>  SumVectorT </td><td>  1024 </td><td>  172.129 ns </td><td>  1,8673 ns </td><td>  1,7467 ns </td></tr><tr><td>  SumVectorT </td><td>  2048 </td><td>  429.722 ns </td><td>  1.0461 ns </td><td>  0,9786 ns </td></tr><tr><td>  SumVectorT </td><td>  4096 </td><td>  654,209 ns </td><td>  3,6215 ns </td><td>  3.0241 ns </td></tr><tr><td>  SumVectorT </td><td>  8192 </td><td>  1 675,046 ns </td><td>  14.5231 ns </td><td>  13.5849 ns </td></tr><tr><td>  SumVectorT </td><td>  16384 </td><td>  2 514,778 ns </td><td>  5.3369 ns </td><td>  4.9921 ns </td></tr><tr><td>  SumVectorT </td><td>  32768 </td><td>  6.689.829 ns </td><td>  13.9947 ns </td><td>  13.0906 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00e/0be/5d4/00e0be5d469067af095f34beccf8c45c.png"></p><br><p>  <em>OBSERVA√á√ÉO</em> Para este artigo, fiz com for√ßa o tamanho do <code>Vector&lt;T&gt;</code> igual a 16 bytes usando o par√¢metro de configura√ß√£o interno ( <code>COMPlus_SIMD16ByteOnly=1</code> ).  Esse ajuste normalizou os resultados ao comparar <code>SumVectorT</code> com <code>SumVectorizedSse</code> e nos permitiu manter o c√≥digo simples.  Em particular, evitou gravar um salto condicional <code>if (Avx2.IsSupported) { }</code> .  Esse c√≥digo √© quase id√™ntico ao do <code>Sse2</code> , mas lida com o <code>Vector256&lt;T&gt;</code> (32 bytes) e processa ainda mais elementos em uma itera√ß√£o do loop. </p><br><p>  Assim, usando as novas <em>fun√ß√µes internas</em> , o c√≥digo pode ser reescrito da seguinte maneira: </p><br><pre> <code class="plaintext hljs">public int SumVectorized(ReadOnlySpan&lt;int&gt; source) { if (Sse2.IsSupported) { return SumVectorizedSse2(source); } else { return SumVectorT(source); } } public unsafe int SumVectorizedSse2(ReadOnlySpan&lt;int&gt; source) { int result; fixed (int* pSource = source) { Vector128&lt;int&gt; vresult = Vector128&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); while (i &lt; lastBlockIndex) { vresult = Sse2.Add(vresult, Sse2.LoadVector128(pSource + i)); i += 4; } if (Ssse3.IsSupported) { vresult = Ssse3.HorizontalAdd(vresult, vresult); vresult = Ssse3.HorizontalAdd(vresult, vresult); } else { vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0x4E)); vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0xB1)); } result = vresult.ToScalar(); while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Esse c√≥digo, novamente, √© um pouco mais complicado, mas √© significativamente mais r√°pido para todos, exceto os menores conjuntos de entradas.  Para 32 mil elementos, esse c√≥digo executa 75% mais r√°pido que o ciclo expandido e 81% mais r√°pido que o c√≥digo-fonte do exemplo. </p><br><p>  Voc√™ notou que escrevemos alguns cheques <code>IsSupported</code> .  O primeiro verifica se o hardware atual suporta o conjunto necess√°rio de <em>fun√ß√µes internas</em> ; caso contr√°rio, a otimiza√ß√£o √© realizada por meio de uma combina√ß√£o de varredura e <code>Vector&lt;T&gt;</code> .  A √∫ltima op√ß√£o ser√° selecionada para plataformas como ARM / ARM64 que n√£o suportam o conjunto de instru√ß√µes necess√°rio ou se o conjunto foi desativado para a plataforma.  O segundo teste <code>IsSupported</code> , no m√©todo <code>SumVectorizedSse2</code> , √© usado para otimiza√ß√£o adicional se o hardware suportar o <code>Ssse3</code> instru√ß√µes <code>Ssse3</code> . </p><br><p>  Caso contr√°rio, a maior parte da l√≥gica √© essencialmente a mesma do loop expandido.  <code>Vector128&lt;T&gt;</code> √© um tipo de 128 bits que cont√©m os elementos <code>Vector128&lt;T&gt;.Count</code> .  Nesse caso, o <code>uint</code> , que √© de 32 bits, pode ter 4 elementos (128/32), foi assim que lan√ßamos o loop. </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Contagem </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumvectorized </td><td>  1 </td><td>  4.555 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Sumvectorized </td><td>  2 </td><td>  4.848 ns </td><td>  0,0147 ns </td><td>  0,0137 ns </td></tr><tr><td>  Sumvectorized </td><td>  4 </td><td>  5.381 ns </td><td>  0,0210 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectorized </td><td>  8 </td><td>  4.838 ns </td><td>  0,0209 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectorized </td><td>  16 </td><td>  5.107 ns </td><td>  0,0175 ns </td><td>  0,0146 ns </td></tr><tr><td>  Sumvectorized </td><td>  32. </td><td>  5.646 ns </td><td>  0,0230 ns </td><td>  0,0204 ns </td></tr><tr><td>  Sumvectorized </td><td>  64 </td><td>  6.763 ns </td><td>  0,0338 ns </td><td>  0,0316 ns </td></tr><tr><td>  Sumvectorized </td><td>  128 </td><td>  9,308 ns </td><td>  0,1041 ns </td><td>  0,0870 ns </td></tr><tr><td>  Sumvectorized </td><td>  256 </td><td>  15.634 ns </td><td>  0,0927 ns </td><td>  0,0821 ns </td></tr><tr><td>  Sumvectorized </td><td>  512 </td><td>  34,706 ns </td><td>  0,2851 ns </td><td>  0,2231 ns </td></tr><tr><td>  Sumvectorized </td><td>  1024 </td><td>  68.110 ns </td><td>  0,4016 ns </td><td>  0,3756 ns </td></tr><tr><td>  Sumvectorized </td><td>  2048 </td><td>  136.533 ns </td><td>  1.3104 ns </td><td>  1.2257 ns </td></tr><tr><td>  Sumvectorized </td><td>  4096 </td><td>  277.930 ns </td><td>  0,5913 ns </td><td>  0,5531 ns </td></tr><tr><td>  Sumvectorized </td><td>  8192 </td><td>  554.720 ns </td><td>  3.5133 ns </td><td>  3,2864 ns </td></tr><tr><td>  Sumvectorized </td><td>  16384 </td><td>  1 110.730 ns </td><td>  3,3043 ns </td><td>  3.0909 ns </td></tr><tr><td>  Sumvectorized </td><td>  32768 </td><td>  2 200,996 ns </td><td>  21.0538 ns </td><td>  19.6938 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/311/e70/320/311e7032050337fe946103244e749076.png"></p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  As novas <em>fun√ß√µes integradas</em> oferecem a oportunidade de aproveitar a funcionalidade espec√≠fica de hardware da m√°quina na qual voc√™ executa o c√≥digo.  Existem aproximadamente 1.500 APIs para X86 e X64 distribu√≠das em 15 conjuntos; h√° muitas para descrever em um artigo.  Ao criar um perfil do c√≥digo para identificar gargalos, √© poss√≠vel determinar a parte do c√≥digo que se beneficia da vetoriza√ß√£o e observar um aumento de desempenho bastante bom.  Existem muitos cen√°rios em que a vetoriza√ß√£o pode ser aplicada e o desdobramento do loop √© apenas o come√ßo. </p><br><p>  Qualquer pessoa que queira ver mais exemplos pode procurar o uso de <em>fun√ß√µes</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">internas</a> na estrutura (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotnet</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aspnet</a> ) ou em outros artigos da comunidade.  E embora os <em>WFs</em> atuais sejam vastos, ainda h√° muitas funcionalidades que precisam ser introduzidas.  Se voc√™ tem a funcionalidade que deseja apresentar, sinta-se √† vontade para registrar sua solicita√ß√£o de API via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotnet / corefx no GitHub</a> .  O processo de revis√£o da API √© descrito <a href="">aqui</a> e h√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bom exemplo</a> de um modelo de solicita√ß√£o de API especificado na etapa 1. </p><br><h2 id="osobye-blagodarnosti">  Agradecimentos especiais </h2><br><p>  Gostaria de expressar uma gratid√£o especial aos membros da nossa comunidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fei Peng (@fiigii)</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jacek Blaszczynski (@ 4creators)</a> por sua ajuda na implementa√ß√£o do <em>WF</em> , bem como a todos os membros da comunidade por coment√°rios valiosos sobre o desenvolvimento, implementa√ß√£o e facilidade de uso dessa funcionalidade. </p><br><hr><br><h3 id="posleslovie-k-perevodu">  Posf√°cio √† tradu√ß√£o </h3><br><p>  Eu gosto de observar o desenvolvimento da plataforma .NET e, em particular, a linguagem C #.  Vindo do mundo do C ++, e tendo pouca experi√™ncia em desenvolvimento em Delphi e Java, fiquei muito confort√°vel em come√ßar a escrever programas em C #.  Em 2006, essa linguagem de programa√ß√£o (a pr√≥pria linguagem) me pareceu mais concisa e pr√°tica do que Java no mundo da coleta de lixo gerenciada e da plataforma cruzada.  Portanto, minha escolha caiu em C # e n√£o me arrependi.  O primeiro est√°gio na evolu√ß√£o de uma l√≠ngua foi simplesmente sua apar√™ncia.  Em 2006, o C # absorveu o melhor da √©poca nas melhores linguagens e plataformas: C ++ / Java / Delphi.  Em 2010, o F # tornou-se p√∫blico.  Era uma plataforma experimental para estudar o paradigma funcional com o objetivo de introduzi-lo no mundo do .NET.  O resultado dos experimentos foi o pr√≥ximo est√°gio na evolu√ß√£o do C # - a expans√£o de suas capacidades para o FP, atrav√©s da introdu√ß√£o de fun√ß√µes an√¥nimas, express√µes lambda e, finalmente, LINQ.  Essa extens√£o da linguagem fez do C # a linguagem de prop√≥sito geral mais avan√ßada, do meu ponto de vista.  O pr√≥ximo passo evolutivo foi relacionado ao apoio √† simultaneidade e assincronia.  Tarefa / Tarefa &lt;T&gt;, todo o conceito de TPL, o desenvolvimento de LINQ - PLINQ e, finalmente, ass√≠ncrono / aguardam.  ,   - ,       .NET   C# ‚Äî      .    Span&lt;T&gt;  Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct   in,  foreach, IO.Streams.         GC    .   ,       ‚Äî       .  ,     .NET   C#,  ,          .   (       )         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467663/">https://habr.com/ru/post/pt467663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467653/index.html">Habrastatistics: analisando os coment√°rios dos leitores</a></li>
<li><a href="../pt467655/index.html">Como passei o ver√£o com C # 8</a></li>
<li><a href="../pt467657/index.html">Invent√°rio de I a Z. Contamos licen√ßas de software</a></li>
<li><a href="../pt467659/index.html">Acelere significativamente a execu√ß√£o de tarefas pelo exemplo de configura√ß√£o adicional da mem√≥ria HyperX FURY DDR4 atualizada</a></li>
<li><a href="../pt467661/index.html">Dos√≠metro para Seryozha. Parte I. Polimaster - Ca√ßadores de Nucl√≠deos</a></li>
<li><a href="../pt467665/index.html">Carrinho de caminh√£o ROS. Parte 5. Trabalhando em rviz e gazebo: xacro, novos sensores</a></li>
<li><a href="../pt467667/index.html">Planejamento de projeto da organiza√ß√£o (parte 4)</a></li>
<li><a href="../pt467669/index.html">Assista-me na √≠ntegra: tire o m√°ximo proveito do v√≠deo ao vivo em plataformas m√≥veis</a></li>
<li><a href="../pt467671/index.html">Computador retro NLX</a></li>
<li><a href="../pt467673/index.html">Recursos de Go incorporados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>