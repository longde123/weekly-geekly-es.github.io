<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ» â™‚ï¸ ğŸˆ·ï¸ å¸¦ç¬¦å·è·ç¦»åœºçš„2Dç©ºé—´æ“çºµ ğŸ›ï¸ ğŸ‘‚ğŸ¾ â†™ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ä½¿ç”¨å¤šè¾¹å½¢èµ„äº§æ—¶ï¼Œä¸€æ¬¡åªèƒ½ç»˜åˆ¶ä¸€ä¸ªå¯¹è±¡ï¼ˆå¦‚æœä¸è€ƒè™‘æ‰¹å¤„ç†å’Œå®ä¾‹åŒ–ç­‰æŠ€æœ¯ï¼‰ï¼Œä½†æ˜¯å¦‚æœæ‚¨ä½¿ç”¨å¸¦ç¬¦å·çš„è·ç¦»å­—æ®µï¼ˆå¸¦ç¬¦å·è·ç¦»å­—æ®µï¼ŒSDFï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸ä»…é™äºæ­¤ã€‚ å¦‚æœä¸¤ä¸ªä½ç½®çš„åæ ‡ç›¸åŒï¼Œåˆ™å¸¦ç¬¦å·çš„è·ç¦»å‡½æ•°å°†è¿”å›ç›¸åŒçš„å€¼ï¼Œå¹¶ä¸”åœ¨ä¸€æ¬¡è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—å¤šä¸ªæ•°å­—ã€‚ è¦äº†è§£å¦‚ä½•è½¬æ¢ç”¨äºç”Ÿæˆå¸¦ç¬¦å·è·ç¦»å­—æ®µçš„ç©ºé—´ï¼Œå»º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>å¸¦ç¬¦å·è·ç¦»åœºçš„2Dç©ºé—´æ“çºµ</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439000/">ä½¿ç”¨å¤šè¾¹å½¢èµ„äº§æ—¶ï¼Œä¸€æ¬¡åªèƒ½ç»˜åˆ¶ä¸€ä¸ªå¯¹è±¡ï¼ˆå¦‚æœä¸è€ƒè™‘æ‰¹å¤„ç†å’Œå®ä¾‹åŒ–ç­‰æŠ€æœ¯ï¼‰ï¼Œä½†æ˜¯å¦‚æœæ‚¨ä½¿ç”¨å¸¦ç¬¦å·çš„è·ç¦»å­—æ®µï¼ˆå¸¦ç¬¦å·è·ç¦»å­—æ®µï¼ŒSDFï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸ä»…é™äºæ­¤ã€‚ å¦‚æœä¸¤ä¸ªä½ç½®çš„åæ ‡ç›¸åŒï¼Œåˆ™å¸¦ç¬¦å·çš„è·ç¦»å‡½æ•°å°†è¿”å›ç›¸åŒçš„å€¼ï¼Œå¹¶ä¸”åœ¨ä¸€æ¬¡è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—å¤šä¸ªæ•°å­—ã€‚ è¦äº†è§£å¦‚ä½•è½¬æ¢ç”¨äºç”Ÿæˆå¸¦ç¬¦å·è·ç¦»å­—æ®µçš„ç©ºé—´ï¼Œå»ºè®®<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">æ‚¨å¼„æ¸…æ¥š</a>å¦‚ä½•<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ä½¿ç”¨å¸¦ç¬¦å·è·ç¦»å‡½æ•°åˆ›å»ºå½¢çŠ¶</a>å¹¶<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ç»„åˆsdf shape</a> ã€‚ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><a name="habracut"></a><br><h2> æ„å‹ </h2><br> åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä¿®æ”¹äº†æ­£æ–¹å½¢å’Œåœ†å½¢ä¹‹é—´çš„é…å¯¹ï¼Œä½†æ˜¯æ‚¨å¯ä»¥å°†å…¶ç”¨äºä»»ä½•å…¶ä»–å½¢çŠ¶ã€‚ è¿™ç±»ä¼¼äºä¸Š<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ä¸€æ•™ç¨‹</a>çš„é…ç½®ã€‚ <br><br> åœ¨æ­¤é‡è¦çš„æ˜¯ï¼Œå¯ä¿®æ”¹éƒ¨åˆ†åº”åœ¨ä½¿ç”¨ä½ç½®ç”Ÿæˆå›¾å½¢ä¹‹å‰ã€‚ <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Type"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // manipulate position with cool methods here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" }</span></span></code> </pre> <br>  2D_SDF.cgincå‡½æ•°ä¸ç€è‰²å™¨ä½äºåŒä¸€æ–‡ä»¶å¤¹ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹å…¶è¿›è¡Œæ‰©å±•ï¼Œé¦–å…ˆçœ‹èµ·æ¥åƒè¿™æ ·ï¼š <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e60/788/36d/e6078836d9a222c4df1578609bdfaced.png"></div><br><h2> é‡å¤ç©ºé—´ </h2><br><h3> é•œé¢åå°„ </h3><br> æœ€ç®€å•çš„æ“ä½œä¹‹ä¸€æ˜¯å›´ç»•è½´é•œåƒä¸–ç•Œã€‚ ä¸ºäº†ä½¿å…¶ç»•yè½´é•œåƒï¼Œæˆ‘ä»¬è·å–ä½ç½®xåˆ†é‡çš„ç»å¯¹å€¼ã€‚ å› æ­¤ï¼Œè½´çº¿å·¦å³çš„åæ ‡å°†ç›¸åŒã€‚  <code>(-1, 1)</code>å˜æˆ<code>(1, 1)</code> ï¼Œå¹¶ä»¥<code>(1, 1)</code>ä¸ºåæ ‡åŸç‚¹å¹¶ä¸”åŠå¾„å¤§äº0å˜æˆåœ†å†…ã€‚ <br><br> é€šå¸¸ï¼Œä½¿ç”¨æ­¤åŠŸèƒ½çš„ä»£ç çœ‹èµ·æ¥åƒ<code>position = mirror(position);</code> æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç®€åŒ–ä¸€ä¸‹ã€‚ æˆ‘ä»¬å°†ç®€å•åœ°å°†positionå‚æ•°å£°æ˜ä¸ºinoutã€‚ å› æ­¤ï¼Œåœ¨å†™å…¥å‚æ•°æ—¶ï¼Œå®ƒè¿˜å°†æ›´æ”¹æˆ‘ä»¬ä¼ é€’ç»™å‡½æ•°çš„å˜é‡ã€‚ ç„¶åï¼Œè¯¥è¿”å›å€¼å¯ä»¥æ˜¯voidç±»å‹ï¼Œå› ä¸ºæˆ‘ä»¬ä»ç„¶ä¸ä½¿ç”¨è¯¥è¿”å›å€¼ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void mirror(inout float2 position){ position.x = abs(position.x); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function mirror(position);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62f/6b0/40e/62f6b040e1e648e7d6411ecf634571f4.png"></div><br> ç»“æœå·²ç»å¾ˆå¥½ï¼Œä½†æ˜¯é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬åªè·å¾—äº†ä¸€ä¸ªç”¨äºé•œåƒçš„è½´ã€‚ æˆ‘ä»¬å¯ä»¥åƒæ—‹è½¬å›¾å½¢æ—¶é‚£æ ·æ—‹è½¬ç©ºé—´æ¥æ‰©å±•åŠŸèƒ½ã€‚ é¦–å…ˆï¼Œæ‚¨éœ€è¦æ—‹è½¬ç©ºé—´ï¼Œç„¶åå¯¹å…¶è¿›è¡Œé•œåƒï¼Œç„¶åå†å°†å…¶æ—‹è½¬å›å»ã€‚ è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥é’ˆå¯¹ä»»ä½•è§’åº¦æ‰§è¡Œé•œåƒã€‚ è½¬ç§»ç©ºé—´å¹¶åœ¨é•œåƒåæ‰§è¡Œåå‘è½¬ç§»æ—¶ï¼Œä¹Ÿå¯ä»¥è¿™æ ·åšã€‚  ï¼ˆå¦‚æœæ‰§è¡Œè¿™ä¸¤ä¸ªæ“ä½œï¼Œåˆ™åœ¨é•œåƒä¹‹å‰ï¼Œè¯·ä¸è¦å¿˜è®°å…ˆè¿›è¡Œä¼ è¾“ï¼Œç„¶åå†è½¬å¼¯ï¼Œç„¶åå…ˆè½¬å¼¯ã€‚ï¼‰ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float rotation = _Time.y * 0.25; position = rotate(position, rotation); mirror(position); position = rotate(position, -rotation);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23a/afd/284/23aafd284c90054af5e7d8b453aac212.gif"></div><br><h2> ç»†èƒ </h2><br> å¦‚æœæ‚¨çŸ¥é“<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å™ªå£°äº§ç”Ÿçš„</a>å·¥ä½œåŸç†ï¼Œé‚£ä¹ˆæ‚¨å°±ä¼šçŸ¥é“ï¼Œå¯¹äºç¨‹åºç”Ÿæˆï¼Œæˆ‘ä»¬ç»å¸¸é‡å¤è¯¥ä½ç½®å¹¶è·å¾—åŸºæœ¬ç›¸åŒçš„å°å•å…ƒï¼Œåªæ˜¯å‚æ•°æ— å…³ç´§è¦ã€‚ æˆ‘ä»¬å¯ä»¥å¯¹è·ç¦»åœºåšåŒæ ·çš„äº‹æƒ…ã€‚ <br><br> ç”±äº<code>fmod</code>å‡½æ•°ï¼ˆä»¥åŠä½¿ç”¨ï¼…é™¤ä»¥ä½™æ•°ï¼‰ä¸ºæˆ‘ä»¬æä¾›äº†ä½™æ•°ï¼Œè€Œä¸æ˜¯ä½™æ•°çš„å®šä¹‰ï¼Œå› æ­¤æˆ‘ä»¬å°†ä¸å¾—ä¸ä½¿ç”¨æŠ€å·§ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å°†å…¶ä½™çš„æ•´æ•°é™¤ä»¥fmodå‡½æ•°ã€‚ å¯¹äºæ­£æ•°ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬éœ€è¦çš„ï¼›å¯¹äºè´Ÿæ•°ï¼Œè¿™æ˜¯æˆ‘ä»¬éœ€è¦çš„ç»“æœå‡å»å‘¨æœŸã€‚ æ‚¨å¯ä»¥é€šè¿‡æ·»åŠ å¥ç‚¹å¹¶å†æ¬¡ä½¿ç”¨é™¤æ³•çš„å…¶ä½™éƒ¨åˆ†æ¥è§£å†³æ­¤é—®é¢˜ã€‚ æ·»åŠ ä¸€ä¸ªå‘¨æœŸå°†ä¸ºè´Ÿè¾“å…¥å€¼æä¾›ç†æƒ³çš„ç»“æœï¼Œè€Œå¯¹äºæ­£è¾“å…¥å€¼ï¼Œè¯¥å€¼é«˜ä¸€ä¸ªå‘¨æœŸã€‚ é™¤æ³•çš„ç¬¬äºŒä¸ªä½™æ•°ä¸ä¼šå¯¹è´Ÿè¾“å…¥å€¼çš„å€¼æ‰§è¡Œä»»ä½•æ“ä½œï¼Œå› ä¸ºå®ƒä»¬å·²ç»åœ¨0åˆ°å‘¨æœŸä¹‹é—´çš„èŒƒå›´å†…ï¼Œè€Œå¯¹äºæ­£è¾“å…¥å€¼ï¼Œæˆ‘ä»¬å°†å®è´¨ä¸Šå‡å»ä¸€ä¸ªå‘¨æœŸã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function cells(position, float2(3, 3));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b9/3f0/b53/4b93f0b53e221b11780ed0c627ebe5c8.png"></div><br> å•å…ƒçš„é—®é¢˜åœ¨äºï¼Œæˆ‘ä»¬å¤±å»äº†æˆ‘ä»¬å–œæ¬¢è·ç¦»åœºçš„è¿ç»­æ€§ã€‚ å¦‚æœå½¢çŠ¶ä»…åœ¨å•å…ƒæ ¼çš„ä¸­é—´ï¼Œè¿™ä¹Ÿä¸é”™ï¼Œä½†æ˜¯åœ¨ä¸Šé¢æ˜¾ç¤ºçš„ç¤ºä¾‹ä¸­ï¼Œå½“å°†è·ç¦»åœºç”¨äºé€šå¸¸å¯åº”ç”¨è·ç¦»åœºçš„å„ç§ä»»åŠ¡æ—¶ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´äº§ç”Ÿæ˜æ˜¾çš„ä¼ªå½±ï¼Œåº”é¿å…ä½¿ç”¨ã€‚ <br><br> æœ‰ä¸€ç§è§£å†³æ–¹æ¡ˆå¹¶éåœ¨æ¯ç§æƒ…å†µä¸‹éƒ½æœ‰æ•ˆï¼Œä½†æ˜¯å½“å®ƒå¯è¡Œæ—¶ï¼Œè¿™å¾ˆå¦™ï¼šé•œåƒæ‰€æœ‰å…¶ä»–å•å…ƒã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåƒç´ å•å…ƒç´¢å¼•ï¼Œä½†æ˜¯å‡½æ•°ä¸­ä»ç„¶æ²¡æœ‰è¿”å›å€¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥è¿”å›å•å…ƒç´¢å¼•ã€‚ <br><br> ä¸ºäº†è®¡ç®—å•å…ƒæ ¼ç´¢å¼•ï¼Œæˆ‘ä»¬å°†ä½ç½®é™¤ä»¥å¥ç‚¹ã€‚ å› æ­¤ï¼Œ0-1æ˜¯ç¬¬ä¸€ä¸ªå•å…ƒæ ¼ï¼Œ1-2æ˜¯ç¬¬äºŒä¸ªå•å…ƒæ ¼ï¼Œä¾æ­¤ç±»æ¨...æˆ‘ä»¬å¯ä»¥è½»æ¾åœ°ç¦»æ•£åŒ–å®ƒã€‚ ä¸ºäº†è·å¾—å•å…ƒæ ¼çš„ç´¢å¼•ï¼Œæˆ‘ä»¬ç„¶åç®€å•åœ°å°†å€¼å››èˆäº”å…¥å¹¶è¿”å›ç»“æœã€‚ é‡è¦çš„æ˜¯åœ¨é™¤ä»¥å…¶ä½™éƒ¨åˆ†ä»¥é‡å¤å•å…ƒä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆè®¡ç®—å•å…ƒçš„ç´¢å¼•ï¼› å¦åˆ™ï¼Œæˆ‘ä»¬å°†åœ¨ä»»ä½•åœ°æ–¹è·å¾—ç´¢å¼•0ï¼Œå› ä¸ºå¤´å¯¸ä¸èƒ½è¶…è¿‡å¥ç‚¹ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float2 cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. float2 cellIndex = position / period; cellIndex = floor(cellIndex); return cellIndex; }</span></span></code> </pre> <br> æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç¿»è½¬å•å…ƒæ ¼ã€‚ è¦äº†è§£æ˜¯å¦ç¿»è½¬ï¼Œæˆ‘ä»¬å°†å•å…ƒç´¢å¼•å–æ¨¡2ã€‚æ­¤æ“ä½œçš„ç»“æœæ˜¯æ¯éš”2ä¸ªå•å…ƒäº¤æ›¿æ˜¾ç¤º0å’Œ1æˆ–-1ã€‚ ä¸ºäº†ä½¿æ›´æ”¹æ›´æŒä¹…ï¼Œæˆ‘ä»¬é‡‡ç”¨ç»å¯¹å€¼å¹¶è·å¾—ä¸€ä¸ªä»‹äº0å’Œ1ä¹‹é—´çš„å€¼ã€‚ <br><br> è¦ä½¿ç”¨æ­¤å€¼åœ¨æ­£å¸¸ä½ç½®å’Œç¿»è½¬ä½ç½®ä¹‹é—´è¿›è¡Œç¿»è½¬ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯¹å€¼0ä¸æ‰§è¡Œä»»ä½•æ“ä½œçš„å‡½æ•°ï¼Œå¹¶ä»ç¿»è½¬ä¸º1çš„å‘¨æœŸä¸­å‡å»è¯¥ä½ç½®ã€‚å³ï¼Œæˆ‘ä»¬ä½¿ç”¨flipå˜é‡ä»æ³•å‘ä½ç½®åˆ°ç¿»è½¬ä½ç½®æ‰§è¡Œçº¿æ€§æ’å€¼ã€‚ ç”±äºflipå˜é‡æ˜¯2då‘é‡ï¼Œå› æ­¤å…¶åˆ†é‡ä¼šå•ç‹¬ç¿»è½¬ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 3; float2 cell = cells(position, period); float2 flip = abs(fmod(cell, 2)); position = lerp(position, period - position, flip);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/c36/5a1/45ac365a1cb18e89306a5ac1f0d01b57.png"></div><br><h2> ç»†èƒ </h2><br> å¦ä¸€ä¸ªé‡è¦ç‰¹å¾æ˜¯å¾„å‘æ¨¡å¼ä¸­çš„ç©ºé—´é‡å¤ã€‚ <br><br> ä¸ºäº†è·å¾—è¿™ç§æ•ˆæœï¼Œæˆ‘ä»¬é¦–å…ˆè®¡ç®—å¾„å‘ä½ç½®ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯¹ç›¸å¯¹äºxè½´ä¸­å¿ƒçš„è§’åº¦ä»¥åŠä¸ä¸­å¿ƒæ²¿yè½´çš„è·ç¦»è¿›è¡Œç¼–ç ã€‚ <br><br><pre> <code class="cpp hljs">float2 radialPosition = float2(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(position.x, position.y), length(position));</code> </pre> <br> ç„¶åï¼Œæˆ‘ä»¬é‡å¤è§’è½ã€‚ ç”±äºä¼ è¾“é‡å¤æ¬¡æ•°æ¯”æ¯ä¸ªç‰‡æ®µçš„è§’åº¦å®¹æ˜“å¾—å¤šï¼Œå› æ­¤æˆ‘ä»¬é¦–å…ˆè®¡ç®—æ¯ä¸ªç‰‡æ®µçš„å¤§å°ã€‚ æ•´ä¸ªåœ†æ˜¯2 * piï¼Œå› æ­¤è¦å¾—åˆ°æ­£ç¡®çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†2 * pié™¤ä»¥åƒå…ƒå¤§å°ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellSize = PI * <span class="hljs-number"><span class="hljs-number">2</span></span> / cells;</code> </pre> <br> æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ¯ä¸ªcellSizeå•ä½ä¸Šé‡å¤å¾„å‘ä½ç½®çš„xåˆ†é‡ã€‚ æˆ‘ä»¬ç”¨é™¤æ•°é™¤æ³•è¿›è¡Œé‡å¤ï¼Œå› æ­¤ï¼Œåƒä»¥å‰ä¸€æ ·ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°è´Ÿæ•°çš„é—®é¢˜ï¼Œè¿™å¯ä»¥é€šè¿‡é™¤æ•°é™¤æ³•çš„ä¸¤ä¸ªå‡½æ•°æ¥æ¶ˆé™¤ã€‚ <br><br><pre> <code class="cpp hljs">radialPosition.x = <span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(radialPosition.x, cellSize) + cellSize, cellSize);</code> </pre> <br> ç„¶åï¼Œæ‚¨éœ€è¦å°†æ–°ä½ç½®ç§»å›é€šå¸¸çš„xyåæ ‡ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†sincoså‡½æ•°ä¸å¾„å‘ä½ç½®çš„xåˆ†é‡ç”¨ä½œè§’åº¦ï¼Œä»¥å°†æ­£å¼¦å†™å…¥ä½ç½®çš„xåæ ‡ï¼Œå¹¶å°†ä½™å¼¦å†™å…¥yåæ ‡ã€‚ é€šè¿‡è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªæ ‡å‡†åŒ–çš„ä½ç½®ã€‚ è¦ä»ä¸­å¿ƒè·å¾—æ­£ç¡®çš„æ–¹å‘ï¼Œè¯·å°†å…¶ä¹˜ä»¥å¾„å‘ä½ç½®çš„åˆ†é‡yï¼Œå³é•¿åº¦ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void radial_cells(inout float2 position, float cells){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, false);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/a77/c42/1dba77c426e68d224172d2587b0a3a6f.png"></div><br> ç„¶åï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åƒå¸¸è§„å•å…ƒæ ¼ä¸€æ ·æ·»åŠ å•å…ƒæ ¼ç´¢å¼•å’Œé•œåƒã€‚ <br><br> æœ‰å¿…è¦åœ¨è®¡ç®—å¾„å‘ä½ç½®ä¹‹åä½†åœ¨ä»é™¤æ³•è¿ç®—æ¥æ”¶ä½™æ•°ä¹‹å‰ï¼Œè®¡ç®—åƒå…ƒç´¢å¼•ã€‚ æˆ‘ä»¬é€šè¿‡é™¤ä»¥å¾„å‘ä½ç½®çš„xåˆ†é‡å¹¶å°†ç»“æœå››èˆäº”å…¥å¾—åˆ°å®ƒã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç´¢å¼•ä¹Ÿå¯ä»¥ä¸ºè´Ÿæ•°ï¼Œå¦‚æœå•å…ƒæ ¼æ•°ä¸ºå¥‡æ•°ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªé—®é¢˜ã€‚ ä¾‹å¦‚ï¼Œå¯¹äº3ä¸ªåƒå…ƒï¼Œæˆ‘ä»¬å¾—åˆ°1ä¸ªåƒå…ƒçš„ç´¢å¼•ä¸º0ã€1ä¸ªåƒå…ƒçš„ç´¢å¼•ä¸º-1å’Œ2ä¸ªåŠåƒå…ƒçš„ç´¢å¼•ä¸º1å’Œ-2ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°†å•å…ƒæ ¼çš„æ•°é‡åŠ åˆ°å˜é‡çš„å››èˆäº”å…¥åçš„å˜é‡ä¸­ï¼Œç„¶åé™¤ä»¥å‰©ä¸‹çš„å•å…ƒæ ¼çš„å¤§å°ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); //at the end of the function: return cellIndex;</span></span></code> </pre> <br> ä¸ºäº†åæ˜ è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ä»¥å¼§åº¦æŒ‡å®šåæ ‡ï¼Œä¸ºé¿å…åœ¨å‡½æ•°å¤–é‡æ–°è®¡ç®—å¾„å‘åæ ‡ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨boolå‚æ•°ä¸ºå…¶æ·»åŠ ä¸€ä¸ªé€‰é¡¹ã€‚ é€šå¸¸åœ¨ç€è‰²å™¨ä¸­ï¼Œä¸æ¬¢è¿åˆ†æ”¯ï¼ˆå¦‚æœæ„é€ ï¼‰ï¼Œä½†æ˜¯åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå±å¹•ä¸Šçš„æ‰€æœ‰åƒç´ éƒ½å°†æ²¿ç€ç›¸åŒçš„è·¯å¾„å‰è¿›ï¼Œå› æ­¤è¿™æ˜¯æ­£å¸¸çš„ã€‚ <br><br> é•œåƒåº”è¯¥åœ¨å¾„å‘åæ ‡å¾ªç¯ä¹‹åä½†åœ¨è½¬æ¢å›å…¶æ­£å¸¸ä½ç½®ä¹‹å‰å‘ç”Ÿã€‚ æˆ‘ä»¬æ‰¾å‡ºæ˜¯å¦éœ€è¦é€šè¿‡å°†å•å…ƒæ ¼ç´¢å¼•é™¤ä»¥2æ¥é™¤ä»¥å½“å‰å•å…ƒæ ¼ï¼Œé€šå¸¸è¿™åº”è¯¥ç»™æˆ‘ä»¬é›¶å’Œä¸€ï¼Œä½†æ˜¯åœ¨æˆ‘çš„æƒ…å†µä¸‹ä¼šå‡ºç°å‡ ä¸ªäºŒï¼Œè¿™å¾ˆå¥‡æ€ªï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥å¤„ç†å®ƒã€‚ ä¸ºäº†æ¶ˆé™¤æ¨è®ºï¼Œæˆ‘ä»¬åªéœ€ä»flipå˜é‡ä¸­å‡å»1ï¼Œç„¶åå–ç»å¯¹å€¼å³å¯ã€‚ å› æ­¤ï¼Œæ ¹æ®éœ€è¦ï¼Œé›¶å’Œå‡æ•°å°†å˜ä¸º1ï¼Œå•ä½å˜ä¸ºé›¶ï¼Œä»…ä»¥ç›¸åçš„é¡ºåºã€‚ <br><br> ç”±äºé›¶å’Œä¸€çš„é¡ºåºä¸æ­£ç¡®ï¼Œå› æ­¤æˆ‘ä»¬åƒä»¥å‰ä¸€æ ·æ‰§è¡Œä»ä¸Šå‘ä¸‹ç‰ˆæœ¬åˆ°ä¸Šå‘ä¸‹ç‰ˆæœ¬çš„çº¿æ€§æ’å€¼ï¼Œåä¹‹äº¦ç„¶ã€‚ è¦ç¿»è½¬åæ ‡ï¼Œæˆ‘ä»¬åªéœ€ä»åƒå…ƒå¤§å°ä¸­å‡å»ä½ç½®å³å¯ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, true);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/3ea/d5e/1b03ead5e0a63236e909d31a5025d8c7.png"></div><br><h2> æ‘‡æ‘†ç©ºé—´ </h2><br> ä½†æ˜¯æ”¹å˜ç©ºé—´æ˜¯æ²¡æœ‰å¿…è¦é‡å¤çš„ã€‚ ä¾‹å¦‚ï¼Œåœ¨åŸºç¡€æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯¹å…¶è¿›è¡Œäº†æ—‹è½¬ï¼Œç§»åŠ¨å’Œç¼©æ”¾ã€‚ æ‚¨è¿˜å¯ä»¥æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼šä½¿ç”¨æ­£å¼¦æ³¢åœ¨æ¯ä¸ªè½´çš„åŸºç¡€ä¸Šç§»åŠ¨æ¯ä¸ªè½´ã€‚ è¿™ä¼šä½¿å¸¦ç¬¦å·çš„è·ç¦»å‡½æ•°çš„è·ç¦»ä¸å¤ªå‡†ç¡®ï¼Œä½†æ˜¯é™¤éå®ƒä»¬æ‘†åŠ¨å¤ªå¤§ï¼Œå¦åˆ™ä¸€åˆ‡éƒ½ä¼šå¥½èµ·æ¥çš„ã€‚ <br><br> é¦–å…ˆï¼Œæˆ‘ä»¬é€šè¿‡ç¿»è½¬xå’Œyåˆ†é‡ï¼Œç„¶åå°†å®ƒä»¬ä¹˜ä»¥æ‘†é¢‘æ¥è®¡ç®—ä½ç½®å˜åŒ–çš„å¹…åº¦ã€‚ ç„¶åï¼Œæˆ‘ä»¬ä»è¯¥å€¼ä¸­è·å–æ­£å¼¦å€¼ï¼Œç„¶åå°†å…¶ä¹˜ä»¥è¦æ·»åŠ çš„æ‘†åŠ¨é‡ã€‚ ä¹‹åï¼Œæˆ‘ä»¬åªéœ€å°†æ­¤æ‘†åŠ¨å› å­æ·»åŠ åˆ°ä½ç½®ï¼Œç„¶åå†æ¬¡å°†ç»“æœåº”ç”¨äºä½ç½®ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function wobble(position, 5, .05);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01c/67e/ec8/01c67eec8726bff917f97e90a5fa8431.png"></div><br> æˆ‘ä»¬è¿˜å¯ä»¥å¯¹æ­¤æŒ¥èˆè¿›è¡ŒåŠ¨ç”»å¤„ç†ï¼Œæ›´æ”¹å…¶ä½ç½®ï¼Œåœ¨åç§»ä½ç½®åº”ç”¨æŒ¥èˆå¹¶è¿”å›è¯¥ç©ºé—´ã€‚ ä¸ºäº†ä½¿æµ®ç‚¹æ•°ä¸ä¼šå¤ªå¤§ï¼Œæˆ‘ç”¨æ‘†åŠ¨é¢‘ç‡é™¤ä»¥pi * 2çš„ä½™æ•°ï¼Œè¿™ä¸æ‘†åŠ¨ç›¸å…³ï¼ˆæ­£å¼¦æ³¢æ¯pi * 2ä¸ªå•ä½é‡å¤ä¸€æ¬¡ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬é¿å…äº†è·³è·ƒå’Œå¤ªå¤§çš„åç§»é‡ã€‚ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function const float PI = 3.14159; float frequency = 5; float offset = _Time.y; offset = fmod(offset, PI * 2 / frequency); position = translate(position, offset); wobble(position, 5, .05); position = translate(position, -offset);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><br><h2> æºä»£ç  </h2><br><h3>  2D SDFåº“ </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } // space repetition void mirror(inout float2 position){ position.x = abs(position.x); } float2 cells(inout float2 position, float2 period){ //find cell index float2 cellIndex = position / period; cellIndex = floor(cellIndex); //negative positions lead to negative modulo position = fmod(position, period); //negative positions now have correct cell coordinates, positive input positions too high position += period; //second mod doesn't change values between 0 and period, but brings down values that are above period. position = fmod(position, period); return cellIndex; } float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; } void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3> åŸºæœ¬çš„æ¼”ç¤ºç€è‰²å™¨ </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_mirror.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_cells.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_wobble.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Mirror"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // modify position here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br> ç°åœ¨æ‚¨å·²ç»çŸ¥é“äº†è®°å·è·ç¦»åŠŸèƒ½çš„æ‰€æœ‰åŸºç¡€çŸ¥è¯†ã€‚ åœ¨ä¸‹ä¸€ä¸ªæ•™ç¨‹ä¸­ï¼Œæˆ‘å°†å°è¯•å¯¹å®ƒä»¬åšä¸€äº›æœ‰è¶£çš„äº‹æƒ…ã€‚ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/5fe/d84/8425fed84e484cd150a7eba8b4d8901c.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439000/">https://habr.com/ru/post/zh-CN439000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438988/index.html">Reactæ•™ç¨‹ç¬¬15éƒ¨åˆ†ï¼šç»„ä»¶çŠ¶æ€ç ”è®¨ä¼š</a></li>
<li><a href="../zh-CN438992/index.html">å¼€å‘è€…æ—¥è®°æˆ–é”™è¯¯å†³å®š</a></li>
<li><a href="../zh-CN438994/index.html">é¼“æ‰‹é¼“æ‰‹Intel Xeon W-3175Xã€‚ æµ‹è¯•ä¸­</a></li>
<li><a href="../zh-CN438996/index.html">å…¬å¸ç½‘ç»œå’ŒMitMã€‚ ç¬¬ä¸€éƒ¨åˆ†</a></li>
<li><a href="../zh-CN438998/index.html">CGDevsè«æ–¯ç§‘èšä¼šï¼ƒ2</a></li>
<li><a href="../zh-CN439002/index.html">å¦‚ä½•åœæ­¢â€œç¼–å†™TKâ€å¹¶å¼€å§‹å·¥ä½œï¼Ÿ</a></li>
<li><a href="../zh-CN439006/index.html">AIå¦‚ä½•å¸®åŠ©å­¦ä¹ æ‰‹è¯­</a></li>
<li><a href="../zh-CN439010/index.html">å½’æ¡£åˆå¹¶åœ¨DeviceLock DLPä¸­çš„å·¥ä½œæ–¹å¼</a></li>
<li><a href="../zh-CN439012/index.html">ç»„ç»‡ç”µè¯ç°¿-å°åˆ·ç‰ˆ</a></li>
<li><a href="../zh-CN439016/index.html">é™æ€é€šç”¨è¡¨</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>