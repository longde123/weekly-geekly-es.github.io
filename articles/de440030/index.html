<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÉ üëô üöâ Pinpoint PKH-Blockierung auf einem OpenWrt-Router mit WireGuard und DNSCrypt üß° üé£ üì∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist der Unterschied zu √§hnlichen Materialien? 


- Reine OpenWrt-Implementierung 
- Verwenden von WireGuard 
- Die Konfiguration des Routers wird ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pinpoint PKH-Blockierung auf einem OpenWrt-Router mit WireGuard und DNSCrypt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440030/"><h2 id="chem-otlichaetsya-ot-podobnyh-materialov">  Was ist der Unterschied zu √§hnlichen Materialien? </h2><br><ul><li>  Reine OpenWrt-Implementierung </li><li>  Verwenden von WireGuard </li><li>  Die Konfiguration des Routers wird mithilfe von OpenWrt-Konfigurationen und nicht in einem Skript organisiert </li><li>  Es gibt Situationen beim Neustart des Netzwerks und beim Neustart </li><li>  Es verbraucht wenig Router-Ressourcen: Gesperrte Subnetze sind in iptables und nicht in Routing-Tabellen enthalten.  Was erm√∂glicht es Ihnen, dieses Gesch√§ft auch auf schwachen Ger√§ten bereitzustellen? </li><li>  Automatisieren Sie die Konfiguration mit Ansible (auf dem Router ist kein Python erforderlich). </li></ul><a name="habracut"></a><br><h2 id="videoversiya">  Videoversion </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GMvEF0PXN-w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pochemu-openwrt-i-wireguard">  Warum OpenWrt und WireGuard? </h2><br><p>  OpenWrt ist auf so vielen Modellen von Soho-Routern installiert, dass es nach Herzenslust konfiguriert und erweitert wird.  Jetzt sind viele Router-Firmwares Add-Ons √ºber OpenWrt. </p><br><p>  Wireguard wird wegen seiner schnellen und einfachen Einrichtung und auch wegen der hohen √úbertragungsgeschwindigkeit durch den Tunnel verwendet. </p><br><h2 id="nemnogo-o-wireguard">  Ein bisschen √ºber WireGuard </h2><br><p>  In unserem Fall ist der Server ein VPS au√üerhalb des ILV, der Client ist zu Hause ein OpenWrt-Router.  Wenn du gehen willst <del>  Pornolab </del>  Telegramm, Ihr Router leitet den Datenverkehr mit WireGuard √ºber einen Server. <br>  WireGuard stellt eine Site-to-Site-Verbindung her, d. H.  Sowohl der Server als auch der Client haben die Server- und Clientseite der Konfiguration.  Wenn es nicht klar ist, wird es klar, wenn Sie die Konfiguration sehen. </p><br><p>  Der Server und der Client haben ihre eigenen privaten und √∂ffentlichen Schl√ºssel. </p><br><h2 id="nastroyka-wireguard-na-servere">  WireGuard auf dem Server konfigurieren </h2><br><p>  Ich mache alles unter Ubuntu 18.04, aber in der offiziellen Dokumentation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Installationsanweisungen">Installationsanweisungen</a> f√ºr alle bekannten und nicht sehr Betriebssysteme. </p><br><h3 id="ustanovka">  Installation </h3><br><pre><code class="bash hljs">sudo add-apt-repository ppa:wireguard/wireguard</code> </pre> <br><blockquote>  Wenn ein Fehler auftritt <br><pre> <code class="bash hljs">sudo: add-apt-repository: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> not found</code> </pre> <br><br>  Installieren Sie software-properties-common - das Paket bietet die M√∂glichkeit, PPA hinzuzuf√ºgen und zu entfernen <br><pre> <code class="bash hljs">sudo apt install software-properties-common</code> </pre> <br></blockquote><br><pre> <code class="bash hljs">sudo apt update sudo apt install wireguard-dkms wireguard-tools</code> </pre> <br><p>  Wir generieren Schl√ºssel f√ºr den Server.  Wir werden die Schl√ºssel der Einfachheit halber im WireGuard-Verzeichnis speichern. </p><br><pre> <code class="plaintext hljs">cd /etc/wireguard/ wg genkey | tee privatekey-server | wg pubkey &gt; publickey-server</code> </pre> <br><p>  Dementsprechend gibt es einen privaten Schl√ºssel in der Privatekey-Server-Datei und einen √∂ffentlichen Schl√ºssel in der Publickey-Server-Datei. <br>  Wir generieren auch sofort einen Schl√ºssel f√ºr den Kunden: </p><br><pre> <code class="plaintext hljs">wg genkey | tee privatekey-client | wg pubkey &gt; publickey-client</code> </pre> <br><p><img src="https://habrastorage.org/webt/k4/xo/m5/k4xom503xmvyxdhjsvelqhaslxo.png"></p><br><h3 id="konfiguraciya">  Konfiguration </h3><br><p>  Die Konfiguration wird in /etc/wireguard/wg0.conf gespeichert.  Die Serverseite sieht folgenderma√üen aus: </p><br><pre> <code class="bash hljs">[Interface] Address = 192.168.100.1 PrivateKey = privatekey-server ListenPort = 51820 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE</code> </pre> <br><p>  <strong>Adresse</strong> - Adresse f√ºr die wg-Schnittstelle (Adresse innerhalb des Tunnels) <br>  <strong>PrivateKey</strong> - Privater Schl√ºssel (Privatekey-Server) <br>  <strong>ListenPort</strong> - Der Port, an dem der Dienst auf eine Verbindung wartet </p><br><p>  Nun, wir maskieren uns, weil wir diesen Server verwenden werden, um auf das Internet zuzugreifen <br>  Bitte beachten Sie, dass der Name der Schnittstelle in Ihrem Fall abweichen kann: </p><br><p>  Client-Teil </p><br><pre> <code class="bash hljs">[Peer] PublicKey = publickey-client AllowedIPs = 192.168.100.3/24</code> </pre> <br><p>  <strong>PublicKey</strong> - der √∂ffentliche Schl√ºssel unseres Routers (publickey-client) <br>  <strong>AllowedIPs</strong> sind die Subnetze, die √ºber diesen Tunnel verf√ºgbar sind.  Der Server ben√∂tigt nur Zugriff auf die Clientadresse. </p><br><p>  Beide Teile sind in einer Konfiguration gespeichert. </p><br><p>  Aktivieren Sie den Autostart beim Neustart: </p><br><pre> <code class="bash hljs">systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> wg-quick@wg0</code> </pre> <br><p>  Wir machen den Server zu einem Router: </p><br><pre> <code class="bash hljs">sysctl -w net.ipv4.ip_forward=1</code> </pre> <br><p>  Konfigurieren Sie die Firewall.  Angenommen, wir haben nur WireGuard und ssh auf unserem Server: </p><br><pre> <code class="bash hljs">sudo iptables -A INPUT -i lo -j ACCEPT sudo iptables -A INPUT -p udp -m udp --dport 51820 -j ACCEPT sudo iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A INPUT -p icmp -j ACCEPT sudo iptables -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT sudo iptables -A INPUT -j DROP</code> </pre> <br><p>  Speichern Sie die iptables-Konfiguration: </p><br><pre> <code class="bash hljs">sudo apt-get install iptables-persistent sudo netfilter-persistent save</code> </pre> <br><p>  Wir heben die wg-Schnittstelle zum ersten Mal manuell an: </p><br><pre> <code class="bash hljs">wg-quick up wg0</code> </pre> <br><p><img src="https://habrastorage.org/webt/1_/me/ai/1_meai1la87gto2qfa7vwmcfmju.png"></p><br><p>  Der WireGuard-Server ist bereit. </p><br><p>  <strong>UPD 27.06.19</strong> Wenn Ihr Anbieter weiterhin PPoE verwendet, m√ºssen Sie eine Regel hinzuf√ºgen.  Danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">denix123</a> </p><br><pre> <code class="plaintext hljs">iptables -t mangle -I POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</code> </pre> <br><h2 id="nastroyka-routera">  Router-Setup </h2><br><p>  Ich verwende OpenWrt Version 18.06.1 auf Xiaomi mi 3G und Asus RT-N16. </p><br><h3 id="logika-raboty-routera">  Die Logik des Routers </h3><br><p>  Wir laden die Listen, f√ºgen sie in iptables ein, iptables markiert alle Adressen aus diesen Listen mit einem 0x1-Marker.  Ferner werden alle mit 0x1 gekennzeichneten Pakete in eine separate Routing-Tabelle verschoben, wobei alle in diese Routing-Tabelle fallenden Pakete die wg-Schnittstelle durchlaufen. </p><br><p><img src="https://habrastorage.org/webt/vy/rc/ji/vyrcjihaaozo-vzf1nkm9nlxpl0.gif"></p><br><h3 id="ustanovka-paketov">  Paketinstallation </h3><br><p>  Was den belegten Platz auf dem Blitz betrifft, ben√∂tigt alles ungef√§hr 0,9 MB.  Wenn Sie einen sehr schlechten Platz haben, ersetzen Sie curl durch wget und Sie m√ºssen m√∂glicherweise dnscrypt-proxy nicht installieren. </p><br><p>  Wir legen Pakete.  In OpenWrt ist dies √ºber den opkg-Paketmanager einfach zu bewerkstelligen: </p><br><pre> <code class="bash hljs">opkg update opkg install ipset wireguard curl</code> </pre> <br><h3 id="zagruzka-spiskov">  Listen herunterladen </h3><br><p>  Alles, was mit den Standardfunktionen von OpenWrt erreicht werden kann, erfolgt √ºber sie.  Alles andere (au√üer Hotplug) habe ich in ein kleines Skript geschrieben: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh START=99 dir=/tmp/lst mkdir -p $dir echo "Run download lists" curl -z $dir/subnet.lst https://antifilter.download/list/subnet.lst --output $dir/subnet.lst curl -z $dir/ipsum.lst https://antifilter.download/list/ipsum.lst --output $dir/ipsum.lst echo "Firewall restart" /etc/init.d/firewall restart</span></span></code> </pre> <br><p>  Listen verbotener Subnetze und Adressen werden von Dateien abgerufen.  F√ºr sie erstellen wir ein Verzeichnis in / tmp.  In / tmp - da es sich um RAM handelt, ist eine solche Funktion von OpenWrt sehr praktisch.  Es lohnt sich nicht, noch einmal etwas in das ROM des Routers zu schreiben. </p><br><p>  Wir pumpen die Listen mit antifilter.download curl aus. Das z-Flag bedeutet, dass curl die Datei nur herunterl√§dt, wenn sich die entfernte Datei von der lokalen Datei unterscheidet oder wenn sie nicht vorhanden ist, wie dies beim Laden des Routers der Fall ist. </p><br><p>  <em>subnet.lst</em> - Eine Liste blockierter Subnetze, die sich nicht oft √§ndert. <br>  <em>ipsum.lst</em> ist eine Liste blockierter Adressen, die nach Maske zusammengefasst ist.  Anstelle von 150.000 Datens√§tzen erhalten wir 15.000 - bequem. </p><br><p>  Nachdem wir die Dateien haben, starten wir die Firewall neu. Dies ist erforderlich, damit ipset funktioniert und Listen zu iptables hinzugef√ºgt werden. Wir konfigurieren ipset in / etc / config / firewall. </p><br><p>  Dieses Skript, das wir in /etc/init.d/ hinzuf√ºgen, hei√üt hirkn.  Mach es ausf√ºhrbar </p><br><pre> <code class="bash hljs">chmod +x /etc/init.d/hirkn</code> </pre> <br><p>  Jetzt haben wir nicht nur ein Skript, sondern einen ganzen Dienst.  Damit es beim Booten startet, erstellen wir einen Symlink in /etc/rc.d.  Wir brauchen es, um nach allen anderen Diensten zu starten, also machen wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Pr√§fix S99">S99-Pr√§fix</a> </p><br><pre> <code class="bash hljs">ln -s /etc/init.d/hirkn /etc/rc.d/S99hirkn</code> </pre> <br><p>  Listen m√ºssen von Zeit zu Zeit aktualisiert werden, wir f√ºgen Datensatz in cron hinzu: </p><br><pre> <code class="bash hljs">crontab -e</code> </pre> <br><pre> <code class="bash hljs">0 4 * * * /etc/init.d/hirkn</code> </pre> <br><p>  Es scheint v√∂llig ausreichend, sie einmal am Tag zu aktualisieren.  Beachten Sie, dass beim Hinzuf√ºgen von Listen zu ipset das Netzwerk ausf√§llt. In meinem Fall sind es 2 Sekunden. <br>  <strong>UPD</strong> : Wenn Sie keine Pausen m√∂chten, haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">sigo73</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Grayver</a> in den Kommentaren vorgeschlagen, wie dies zu tun ist. </p><br><p>  Schalten Sie auch die Krone ein. Standardm√§√üig ist sie deaktiviert: </p><br><pre> <code class="bash hljs">/etc/init.d/cron <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> /etc/init.d/cron start</code> </pre> <br><h3 id="konfiguraciya-tablicy-marshrutizacii">  Konfiguration der Routing-Tabelle </h3><br><p>  Erstellen Sie eine Routing-Tabelle f√ºr den Verkehr durch den Tunnel, indem Sie einfach die folgende Zeile hinzuf√ºgen: </p><br><pre> <code class="bash hljs">99 vpn</code> </pre> <br><p>  in die Datei / etc / iproute2 / rt_tables. </p><br><p>  Sie k√∂nnen eine Standardroute f√ºr die Tabelle "vpn" √ºber die wg-Schnittstelle mit dem folgenden Befehl erstellen: </p><br><pre> <code class="bash hljs">ip route add table vpn default dev wg0</code> </pre> <br><p>  Wenn Sie das Netzwerk jedoch neu starten, verschwindet die Route. Daher erstellen wir die 30-Knoten-Datei im Verzeichnis /etc/hotplug.d/iface/ mit einfachem Inhalt: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ip route add table vpn default dev wg0</span></span></code> </pre> <br><p>  Dies bedeutet, dass beim Ein- und Ausschalten der Schnittstellen unsere Route hinzugef√ºgt wird.  Dementsprechend wird diese Route immer registriert. </p><br><h3 id="konfiguraciya-seti">  Netzwerkkonfiguration </h3><br><p>  Wir m√ºssen WireGuard und die Regel f√ºr Pakete mit der Bezeichnung 0x1 konfigurieren. </p><br><p>  Die WireGuard-Konfiguration befindet sich in / etc / config / network </p><br><p>  Der "Server" Teil: </p><br><pre> <code class="bash hljs">config interface <span class="hljs-string"><span class="hljs-string">'wg0'</span></span> option private_key <span class="hljs-string"><span class="hljs-string">'privatekey-client'</span></span> list addresses <span class="hljs-string"><span class="hljs-string">'192.168.100.3/24'</span></span> option listen_port <span class="hljs-string"><span class="hljs-string">'51820'</span></span> option proto <span class="hljs-string"><span class="hljs-string">'wireguard'</span></span></code> </pre> <br><p>  <strong>private_key</strong> ist der privatekey-client, den wir bei der Konfiguration des Servers generiert haben <br>  <strong>Listenadressen</strong> - wg-Schnittstellenadresse <br>  <strong>listen_port</strong> - der Port, an dem WireGuard Verbindungen akzeptiert.  Die Verbindung wird jedoch √ºber den Port auf dem Server hergestellt, sodass wir hier den Port auf der Firewall nicht daf√ºr √∂ffnen <br>  <strong>proto</strong> - Geben Sie das Protokoll an, damit openwrt versteht, dass es sich um eine WireGuard-Konfiguration handelt </p><br><p>  "Client" Teil: </p><br><pre> <code class="bash hljs">config wireguard_wg0 option public_key <span class="hljs-string"><span class="hljs-string">'publickey-server'</span></span> option allowed_ips <span class="hljs-string"><span class="hljs-string">'0.0.0.0/0'</span></span> option route_allowed_ips <span class="hljs-string"><span class="hljs-string">'0'</span></span> option endpoint_host <span class="hljs-string"><span class="hljs-string">'wg-server-ip'</span></span> option persistent_keepalive <span class="hljs-string"><span class="hljs-string">'25'</span></span> option endpoint_port <span class="hljs-string"><span class="hljs-string">'51820'</span></span></code> </pre> <br><p>  <strong>public_key</strong> - publickey-server key <br>  <strong>allow_ips</strong> - Subnetze, in die Verkehr durch den Tunnel gelangen kann. In unserem Fall sind keine Einschr√§nkungen erforderlich, daher 0.0.0.0/0 <br>  <strong>route_allowed_ips</strong> - Ein Flag, das aus dem Parameter allow_ips eine Route durch die wg-Schnittstelle f√ºr die aufgelisteten Netzwerke erstellt.  In unserem Fall ist dies nicht erforderlich, iptables erledigt diese Arbeit <br>  <strong>endpoint_host</strong> - IP / URL unseres WG-Servers <br>  <strong>persistent_keepalive</strong> - Zeitintervall, nach dem Pakete gesendet werden, um die Verbindung zu unterst√ºtzen <br>  endpoint_port - Wireguard-Port auf dem Server </p><br><p>  Wir werden der Netzwerkkonfiguration auch eine Regel hinzuf√ºgen, die den gesamten mit 0x1 gekennzeichneten Datenverkehr an die Routing-Tabelle "vpn" sendet: </p><br><pre> <code class="bash hljs">config rule option priority <span class="hljs-string"><span class="hljs-string">'100'</span></span> option lookup <span class="hljs-string"><span class="hljs-string">'vpn'</span></span> option mark <span class="hljs-string"><span class="hljs-string">'0x1'</span></span></code> </pre> <br><h3 id="konfiguraciya-firewall">  Firewall-Konfiguration </h3><br><p><del>  Wir f√ºgen zwei Regeln zum Markieren von Paketen hinzu, die nicht in die openwrt-UCI-Syntax passen. Daher f√ºgen wir sie "wie besehen" zu /etc/firewall.user hinzu. </del><br>  <strong>UPD</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Grayver</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="vorgeschlagen">schlug vor,</a> dass sie recht gut passen.  Wir setzen sie nach dem Einrichten von ipset </p><br><p>  Die Firewall-Konfiguration befindet sich in / etc / config / firewall </p><br><p>  F√ºgen Sie eine Zone f√ºr Wireguard hinzu.  In openwrt sind Zonen benutzerdefinierte Ketten in iptables.  Auf diese Weise wird eine Zone mit einer / mehreren Schnittstellen erstellt, an die bereits Regeln geh√§ngt sind.  Die Zone f√ºr wg sieht folgenderma√üen aus: </p><br><pre> <code class="bash hljs">config zone option name <span class="hljs-string"><span class="hljs-string">'wg'</span></span> option family <span class="hljs-string"><span class="hljs-string">'ipv4'</span></span> option masq <span class="hljs-string"><span class="hljs-string">'1'</span></span> option output <span class="hljs-string"><span class="hljs-string">'ACCEPT'</span></span> option forward <span class="hljs-string"><span class="hljs-string">'REJECT'</span></span> option input <span class="hljs-string"><span class="hljs-string">'REJECT'</span></span> option mtu_fix <span class="hljs-string"><span class="hljs-string">'1'</span></span> option network <span class="hljs-string"><span class="hljs-string">'wg0'</span></span></code> </pre> <br><p>  Wir erlauben nur dem Verkehr, die Schnittstelle zu verlassen und das Maskieren zu aktivieren. </p><br><p>  Jetzt m√ºssen Sie die Weiterleitung von der LAN-Zone zur WG-Zone aktivieren: </p><br><pre> <code class="bash hljs">config forwarding option src <span class="hljs-string"><span class="hljs-string">'lan'</span></span> option dest <span class="hljs-string"><span class="hljs-string">'wg'</span></span></code> </pre> <br><p>  Nun, das Letzte ist, Listen in iptables mit ipset zu erstellen: </p><br><pre> <code class="bash hljs">config ipset option name <span class="hljs-string"><span class="hljs-string">'vpn_subnets'</span></span> option storage <span class="hljs-string"><span class="hljs-string">'hash'</span></span> option loadfile <span class="hljs-string"><span class="hljs-string">'/tmp/lst/subnet.lst'</span></span> option match <span class="hljs-string"><span class="hljs-string">'dst_net'</span></span> config ipset option name <span class="hljs-string"><span class="hljs-string">'vpn_ipsum'</span></span> option storage <span class="hljs-string"><span class="hljs-string">'hash'</span></span> option loadfile <span class="hljs-string"><span class="hljs-string">'/tmp/lst/ipsum.lst'</span></span> option match <span class="hljs-string"><span class="hljs-string">'dst_net'</span></span></code> </pre> <br><p>  <strong>loadfile</strong> - die Datei, aus der wir die Liste entnehmen <br>  <strong>name</strong> - name f√ºr unsere liste <br>  <strong>Speicherung</strong> , <strong>√úbereinstimmung</strong> - hier legen wir fest, wie und welche Art von Daten gespeichert werden sollen.  Wir werden den Typ "Subnetz" speichern </p><br><p>  <strong>UPD</strong> : Wenn Sie die Liste der einzelnen IP-Adressen verwenden m√∂chten, m√ºssen Sie die Gr√∂√üe der ipset-Liste erh√∂hen.  In der Konfiguration ipset hinzuf√ºgen </p><br><pre> <code class="plaintext hljs"> option hashsize '1000000' option maxelem '1000000'</code> </pre> <br><p>  Andernfalls erhalten Sie eine Fehlermeldung </p><br><pre> <code class="plaintext hljs">ipset v6.38: Hash is full, cannot add more elements</code> </pre> <br><p>  <strong>UPD</strong> : F√ºgen Sie zwei Regeln zum Beschriften von Paketen hinzu </p><br><pre> <code class="plaintext hljs">config rule option name 'mark_subnet' option src 'lan' option proto 'all' option ipset 'vpn_subnets' option set_mark '0x1' option target 'MARK' config rule option name 'mark_ipsum' option src 'lan' option proto 'all' option ipset 'vpn_ipsum' option set_mark '0x1' option target 'MARK'</code> </pre> <br><p>  Diese Regeln implizieren, dass alle Pakete, die aus den Listen vpn_subnets und vpn_ipsum in die Subnetze gehen, mit 0x1 gekennzeichnet sein m√ºssen. </p><br><p>  Danach starten wir das Netzwerk neu: </p><br><pre> <code class="bash hljs">/etc/init.d/network restart</code> </pre> <br><p><img src="https://habrastorage.org/webt/e6/pm/m6/e6pmm6etqcw0dbz-c3ddqmzqemo.png"></p><br><p>  und f√ºhren Sie das Skript aus: </p><br><pre> <code class="bash hljs">/etc/init.d/hirkn</code> </pre> <br><p><img src="https://habrastorage.org/webt/e4/q-/6r/e4q-6rktvq2y8znvhmtpxfdsnwi.gif"></p><br><p>  Nach dem Ausarbeiten des Skripts sollte alles f√ºr Sie funktionieren.  √úberpr√ºfen Sie die Route auf dem Router-Client: </p><br><pre> <code class="bash hljs">mtr/traceroute telegram.org/linkedin.com</code> </pre> <br><p><img src="https://habrastorage.org/webt/wp/6e/jp/wp6ejpwtfwu9xkk-iizc8qj_aeu.gif"></p><br><h2 id="bonusom-nastroim-dnscrypt">  Bonus DNSCrypt konfigurieren </h2><br><p>  Warum?  Ihr Provider kann die IP-Adresse der blockierten Ressource sorgf√§ltig ersetzen und Sie so mit einem Stub auf Ihre IP umleiten. In diesem Fall hilft unser IP-Bypass nicht weiter.  F√ºr die Ersetzung ist es nicht immer erforderlich, den DNS-Server des Anbieters zu verwenden. Ihre Anforderungen k√∂nnen abgefangen werden und die Antworten werden ersetzt.  Das kann √ºbrigens nicht nur der Anbieter. </p><br><pre> <code class="bash hljs">opkg install dnscrpt-proxy</code> </pre> <br><p>  Konfigurieren Sie die Konfiguration / etc / config / dnscrypt-proxy folgenderma√üen: </p><br><pre> <code class="bash hljs">config dnscrypt-proxy ns1 option address <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span> option port <span class="hljs-string"><span class="hljs-string">'5353'</span></span> option resolver <span class="hljs-string"><span class="hljs-string">'cpunks-ru'</span></span></code> </pre> <br><p>  Wir haben also den dnscrypt-Dienst auf Port 5353 auf localhost verf√ºgbar. </p><br><p>  <strong>Resolver</strong> ist ein DNS-Server, der die Verschl√ºsselung unterst√ºtzt.  Auf dem Router enth√§lt die Datei /usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv eine Liste der verf√ºgbaren Server zum Zeitpunkt der Ver√∂ffentlichung der installierten Version von dnscrypt.  Und hier sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dnscrypt.info/public-servers/</a> im Allgemeinen alle verf√ºgbaren dnscrypt-Server.  Sie k√∂nnen einen anderen Resolver ausw√§hlen und / oder Server f√ºr die Fehlertoleranz hinzuf√ºgen.  Beachten Sie, dass DNSCrypt in dnscrypt-resolvers.csv angegeben werden muss, damit es mit dem ausgew√§hlten Resolver funktioniert. </p><br><p>  Wir konfigurieren dnsmasq f√ºr die Arbeit mit dnscrypt.  Kommentieren Sie in / etc / config / dhcp die Zeile aus: </p><br><pre> <code class="bash hljs">option resolvfile <span class="hljs-string"><span class="hljs-string">'/tmp/resolv.conf.auto'</span></span></code> </pre> <br><p>  Damit sind die DNS-Server des Anbieters nicht beteiligt. </p><br><p>  Und f√ºge hinzu: </p><br><pre> <code class="bash hljs"> list server <span class="hljs-string"><span class="hljs-string">'/pool.ntp.org/208.67.222.222'</span></span> list server <span class="hljs-string"><span class="hljs-string">'127.0.0.1#5353'</span></span></code> </pre> <br><p>  Der <strong>Eintrag 'domain / ip_dns' des Listenservers</strong> gibt an, welcher DNS-Server zum <strong>Aufl√∂sen</strong> der angegebenen Dom√§ne verwendet werden soll.  Daher verwenden wir dnscrypt nicht f√ºr die NTP-Synchronisation - es ist wichtig, dass der dnscrypt-Dienst die aktuelle Zeit hat. </p><br><p><del>  Wenn der Router geladen wird, wird das Hirkn-Skript schneller ausgef√ºhrt als der Start von dnscrypt, sodass die Dom√§ne antifilter.download nicht aufgel√∂st wird und die Listen nicht heruntergeladen werden.  Sie k√∂nnen eine Verz√∂gerung oder etwas anderes einfallen lassen, aber bisher sehe ich keinen Grund. </del><br>  <strong>UPD</strong> : muss eine Zeile hinzuf√ºgen </p><br><pre> <code class="plaintext hljs">START=99</code> </pre> <br><p>  zu hirkn Skript </p><br><p>  Als Ergebnis erhalten wir eine solche Einf√ºgung in der Konfiguration: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#option resolvfile '/tmp/resolv.conf.auto' list server '/pool.ntp.org/208.67.222.222' list server '127.0.0.1#5353'</span></span></code> </pre> <br><p>  <strong>UPD</strong> : Auf einigen Ger√§ten wird DNSCrypt trotzdem nach dem Skript gestartet.  Der einfachste Weg, dies zu beheben, besteht darin, die Zeile zu / etc / config / dhcp hinzuzuf√ºgen </p><br><pre> <code class="plaintext hljs"> list server '/antifilter.download/208.67.222.222'</code> </pre> <br><p>  Deaktivieren Sie die Verwendung von Provider-DNS f√ºr die WAN-Schnittstelle <br>  F√ºgen Sie in / etc / config / network die Zeile hinzu </p><br><pre> <code class="plaintext hljs">option peerdns '0'</code> </pre> <br><p>  zur WAN-Schnittstelle. <br>  Wir bekommen diese Konfiguration </p><br><pre> <code class="bash hljs">config interface <span class="hljs-string"><span class="hljs-string">'wan'</span></span> option ifname <span class="hljs-string"><span class="hljs-string">'eth0.2'</span></span> option proto <span class="hljs-string"><span class="hljs-string">'dhcp'</span></span> option peerdns <span class="hljs-string"><span class="hljs-string">'0'</span></span></code> </pre> <br><p>  Starten Sie das Netzwerk neu </p><br><pre> <code class="plaintext hljs">/etc/init.d/network restart</code> </pre> <br><p>  Zum Start hinzuf√ºgen und dnscrypt starten: </p><br><pre> <code class="bash hljs">/etc/init.d/dnscrypt-proxy <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> /etc/init.d/dnscrypt-proxy start</code> </pre> <br><p>  Starten Sie dnsmasq neu: </p><br><pre> <code class="bash hljs">/etc/init.d/dnsmasq restart</code> </pre> <br><p><img src="https://habrastorage.org/webt/i2/b5/90/i2b590nxr6-lqnk1h2-tq-i6t-4.gif"><br>  <em>Illustration der Arbeit ohne DNSCrypt und mit DNSCrypt</em> </p><br><h2 id="avtomaticheski-razvertyvaem-s-pomoschyu-ansible">  Automatisch mit Ansible bereitgestellt </h2><br><p>  Playbook und Vorlagen sind auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Github">Github</a> .  Es verwendet ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modul</a> , ben√∂tigt kein Python auf dem Router und es gibt Unterst√ºtzung f√ºr uci.  Ich habe versucht sicherzustellen, dass Ihre OpenWrt-Konfiguration unber√ºhrt bleibt, aber seien Sie trotzdem vorsichtig. </p><br><p>  Installieren Sie das gekmihesg / ansible-openwrt-Modul: </p><br><pre> <code class="bash hljs">ansible-galaxy install gekmihesg.openwrt</code> </pre> <br><p>  Kopieren Sie das Spielbuch und Tempeyta: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /etc/ansible git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/itdoginfo/ansible-openwrt-hirkn mv ansible-openwrt-hirkn/* . rm -rf ansible-openwrt-hirkn</code> </pre> <br><p>  F√ºgen Sie Ihren Router zu Hosts hinzu: </p><br><pre> <code class="bash hljs">[openwrt] 192.168.1.1</code> </pre> <br><p>  Ersetzen Sie Ihre Variablen in hirkn.yml: </p><br><pre> <code class="bash hljs"> vars: ansible_template_dir: /etc/ansible/templates/ wg_server_address: wg_server_ip/url wg_private_key: privatekey-client wg_public_key: publickey-server wg_listen_port: 51820 wg_client_port: 51820 wg_client_address: 192.168.100.3/24</code> </pre> <br><p>  Stellen Sie sicher, dass Sie Folgendes einstellen: </p><br><p>  <strong>wg_server_address</strong> - IP / URL-Wireguard-Server <br>  <strong>wg_private_key</strong> , <strong>wg_public_key</strong> - privater Schl√ºssel des Clients und des √∂ffentlichen Servers <br>  Der Rest kann nicht ge√§ndert werden, je nachdem, wie der WireGuard-Server konfiguriert ist </p><br><p>  Starten Sie das Playbook </p><br><pre> <code class="bash hljs">ansible-playbook playbooks/hirkn.yml</code> </pre> <br><p>  Nach Abschluss des Playbooks beginnt der Router sofort, die Sperren durch Ihren Wireguard-Server zu umgehen. </p><br><h2 id="pochemu-ne-bgp">  Warum nicht BGP? </h2><br><p>  Unter openwrt gibt es zwei Dienstprogramme, die BGP implementieren - quagga und bird.  Quagg Ich konnte keine Daten vom Antifilter sammeln.  Bird hat sich nach einem halben Kick mit dem Service angefreundet, aber leider habe ich nicht verstanden, wie man das Hinzuf√ºgen der Standardschnittstelle zu den empfangenen Subnetzen erzwingt.  (Ich werde froh sein zu wissen, wie dies umgesetzt werden kann). </p><br><p>  In den Kommentaren zu solchen Artikeln habe ich gesehen, dass die Router von Personen eine Weile ‚Äûnachdenklich‚Äú waren, als sie Listen in die Routing-Tabelle einf√ºgten.  Bei der Implementierung √ºber ipset denkt mein Xiaomi mi 3G 2 Sekunden lang nach (Asus rt-n16 5 Sekunden lang), wenn Sie ihm eine Liste mit 15.000 Subnetzen geben.  Bei weiteren Arbeiten bemerkte ich die Belastung des Prozessors nicht. </p><br><p>  <em>Alle Materialien sind kein Aufruf zum Handeln und werden vorgestellt, um sich mit der Funktionalit√§t des Linux-Betriebssystems vertraut zu machen.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440030/">https://habr.com/ru/post/de440030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440018/index.html">Dynamische lokale Belichtung</a></li>
<li><a href="../de440020/index.html">Regression oder Regression beim Testen</a></li>
<li><a href="../de440022/index.html">Ein kleiner Ferrari: Mit dem Fintech-Startup Rally Rd k√∂nnen Sie "Aktien" seltener Autos kaufen</a></li>
<li><a href="../de440024/index.html">Leiten Sie printf () von STM32 zur Qt Creator Console um</a></li>
<li><a href="../de440026/index.html">Kaggle: Ich kann nicht laufen - lass uns rennen</a></li>
<li><a href="../de440032/index.html">K√ºnstliche Intelligenz Horizon Zero Dawn</a></li>
<li><a href="../de440034/index.html">KISS Architektur. Vom Mikroservice zum Monolithen</a></li>
<li><a href="../de440036/index.html">Ber√ºhren Sie die Eingabe</a></li>
<li><a href="../de440040/index.html">In der Entwicklung - jeder f√ºr sich. Aber manchmal f√ºhrt es zu einer Sackgasse.</a></li>
<li><a href="../de440044/index.html">Qualcomm Detaillierte Geschichte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>