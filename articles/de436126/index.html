<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍮 🔧 👥 Kubernetes: Erstellen von Docker-Images in einem Cluster 🛄 🏬 👎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie können Kaniko verwenden, um Docker-Images in einem Container zu erstellen, ohne auf Docker zu verzichten. Lassen Sie uns herausfinden, wie Kaniko ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes: Erstellen von Docker-Images in einem Cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/436126/"><p>  Sie können Kaniko verwenden, um Docker-Images in einem Container zu erstellen, ohne auf Docker zu verzichten.  Lassen Sie uns herausfinden, wie Kaniko lokal und in einem Kubernetes-Cluster ausgeführt wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/699/1ac/23b/6991ac23b41241f34ce0ab774a64124d.jpg" alt="Bild"><br>  <em>Als nächstes wird ein Multi-Buch sein</em> </p><a name="habracut"></a><br><p>  Angenommen, Sie möchten Docker-Images in einem Kubernetes-Cluster erstellen (müssen Sie dies auch tun).  Schauen wir uns ein reales Beispiel genauer an. </p><br><p>  Wir werden auch über Docker-in-Docker und seine Alternative Kaniko sprechen, mit der Sie Docker-Images erstellen können, ohne Docker zu verwenden.  Abschließend erfahren Sie, wie Sie die Image-Assembly im Kubernetes-Cluster konfigurieren. </p><br><p>  Eine allgemeine Beschreibung von Kubernetes findet sich im Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Kubernetes in Action" ("Kubernetes in Action")</a> . </p><br><h3 id="realnyy-primer">  Echtes Beispiel </h3><br><p>  Im nativen Web haben wir viele private Docker-Images, die irgendwo gespeichert werden müssen.  Also haben wir einen privaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Hub</a> implementiert.  Der öffentliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Hub</a> verfügt über zwei Funktionen, die uns besonders interessieren. </p><br><p>  Zunächst wollten wir eine Warteschlange erstellen, in der Docker-Images in Kubernetes asynchron erfasst werden.  Zweitens implementieren Sie das Senden der gesammelten Bilder an die private <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-Registrierung</a> . </p><br><p>  In der Regel wird die Docker-CLI direkt zur Implementierung der folgenden Funktionen verwendet: </p><br><pre><code class="plaintext hljs">$ docker build ... $ docker push ...</code> </pre> <br><p>  Im Kubernetes-Cluster hosten wir jedoch Container, die auf kleinen und elementaren Linux-Images basieren, in denen Docker standardmäßig nicht enthalten ist.  Wenn wir jetzt Docker (z. B. <code>docker build...</code> ) in einem Container verwenden möchten, benötigen wir so etwas wie Docker-in-Docker. </p><br><h3 id="chto-ne-tak-s-docker-in-docker">  Was ist los mit Docker-in-Docker? </h3><br><p>  Um Container-Images in Docker zu erfassen, benötigen wir einen laufenden Docker-Daemon im Container, dh Docker-in-Docker.  Der Docker-Daemon ist eine virtualisierte Umgebung, und der Container in Kubernetes wird eigenständig virtualisiert.  Wenn Sie den Docker-Dämon in einem Container ausführen möchten, müssen Sie eine verschachtelte Virtualisierung verwenden.  Führen Sie dazu den Container im privilegierten Modus aus, um Zugriff auf das Hostsystem zu erhalten.  Dies wirft jedoch Sicherheitsprobleme auf: Sie müssen beispielsweise mit verschiedenen Dateisystemen (Host und Container) arbeiten oder den Build-Cache des Host-Systems verwenden.  Deshalb wollten wir Docker-in-Docker nicht berühren. </p><br><h3 id="znakomstvo-s-kaniko">  Bekanntschaft mit Kaniko </h3><br><p>  Nicht Docker-in-Docker allein ... Es gibt eine andere Lösung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaniko</a> .  Dies ist ein in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go</a> geschriebenes Tool, das Containerbilder aus einer Docker-Datei ohne Docker sammelt.  Anschließend werden sie an die angegebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-Registrierung gesendet</a> .  Es wird empfohlen, kaniko zu konfigurieren. Verwenden Sie ein fertiges <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Executor-Image</a> , das als Docker-Container oder als Container in Kubernetes ausgeführt werden kann. </p><br><p>  Denken Sie daran, dass sich kaniko noch in der Entwicklung befindet und nicht alle Dockerfile-Befehle unterstützt, z. B. <code>--chownflag</code> für den <code>COPY</code> . </p><br><h3 id="zapusk-kaniko">  Kaniko starten </h3><br><p>  Wenn Sie Kaniko ausführen möchten, müssen Sie mehrere Argumente für den Kaniko-Container angeben.  Fügen Sie zuerst die Docker-Datei mit all ihren Abhängigkeiten in den Kaniko-Container ein.  Lokal (in Docker) wird hierfür der Parameter <code>-v &lt;__&gt;:&lt;__&gt;</code> verwendet, und Kubernetes verfügt über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Volumes</a> . </p><br><p>  Nachdem Sie die Abhängigkeits-Docker-Datei in den Kaniko-Container eingefügt haben, fügen Sie das Argument <code>--context</code> . Es gibt den Pfad zum angehängten Verzeichnis (innerhalb des Containers) an.  Das nächste Argument ist <code>--dockerfile</code> .  Es gibt den Pfad zur Docker-Datei an (einschließlich des Namens).  Ein weiteres wichtiges Argument ist das <code>--destination</code> mit der vollständigen URL zur Docker-Registrierung (einschließlich Name und Image-Tag). </p><br><h3 id="lokalnyy-zapusk">  Lokaler Start </h3><br><p>  Kaniko beginnt auf verschiedene Arten.  Zum Beispiel auf dem lokalen Computer mit Docker (um sich nicht mit dem Kubernetes-Cluster herumzuschlagen).  Führen Sie kaniko mit dem folgenden Befehl aus: </p><br><pre> <code class="plaintext hljs">$ docker run \ -v $(pwd):/workspace \ gcr.io/kaniko-project/executor:latest \ --dockerfile=&lt;path-to-dockerfile&gt; \ --context=/workspace \ --destination=&lt;repo-url-with-image-name&gt;:&lt;tag&gt;</code> </pre> <br><p>  Wenn die Authentifizierung in der Docker-Registrierung aktiviert ist, muss kaniko zuerst angemeldet sein.  Verbinden Sie dazu die lokale Docker- <code>config.jsonfile</code> mit den Anmeldeinformationen für die Docker-Registrierung mit dem folgenden Befehl mit dem Kaniko-Container: </p><br><pre> <code class="plaintext hljs">$ docker run \ -v $(pwd):/workspace \ -v ~/.docker/config.json:/kaniko/.docker/config.json \ gcr.io/kaniko-project/executor:latest \ --dockerfile=&lt;path-to-dockerfile&gt; \ --context=/workspace \ --destination=&lt;repo-url-with-image-name&gt;:&lt;tag&gt;</code> </pre> <br><h3 id="zapusk-v-kubernetes">  Start in Kubernetes </h3><br><p>  Im Beispiel wollten wir Kaniko in einem Kubernetes-Cluster ausführen.  Und wir brauchten auch so etwas wie eine Warteschlange zum Zusammenstellen von Bildern.  Wenn beim Zusammenstellen oder Senden des Images an die Docker-Registrierung ein Fehler auftritt, ist es hilfreich, wenn der Prozess automatisch erneut gestartet wird.  Dafür gibt es in Kubernetes einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Job</a> .  Konfigurieren Sie <code>backoffLimit</code> indem Sie <code>backoffLimit</code> , wie oft der Prozess wiederholt werden soll. </p><br><p>  Der einfachste Weg, eine Docker-Datei mit Abhängigkeiten in einen Kaniko-Container einzubetten, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PersistentVolumeClaim-</a> Objekt (in unserem Beispiel <code>kaniko-workspace</code> ).  Es wird als Verzeichnis an den Container gebunden, und alle Daten sollten sich bereits im <code>kaniko-workspace</code> .  Angenommen, in einem anderen Container befindet sich bereits eine Docker-Datei mit Abhängigkeiten im <code>kaniko-workspace</code> <code>/my-build</code> im <code>kaniko-workspace</code> . </p><br><p>  Vergessen Sie nicht, dass bei AWS Probleme mit PersistentVolumeClaim auftreten.  Wenn Sie in AWS einen PersistentVolumeClaim erstellen, wird dieser nur auf einem Knoten im AWS-Cluster angezeigt und ist nur dort verfügbar.  (upd: Tatsächlich wird beim Erstellen eines PVC ein RDS-Volume in einer zufälligen Verfügbarkeitszone Ihres Clusters erstellt. Dementsprechend steht dieses Volume allen Computern in dieser Zone zur Verfügung. Kubernetes selbst steuert, dass es unter Verwendung dieses PVC auf einem Knoten in der Verfügbarkeitszone gestartet wird RDS volyuma. - Ca. Per.) Wenn Sie also Job kaniko ausführen und diese Aufgabe auf einem anderen Knoten ausgeführt wird, wird sie nicht gestartet, da PersistentVolumeClaim nicht verfügbar ist.  Hoffen wir, dass Amazon Elastic File System bald auf Kubernetes verfügbar sein wird und das Problem behoben ist.  (Update: EFS in Kubernetes wird vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Storage Provisioner unterstützt</a> . - <em>Ca.</em> ) </p><br><p>  Die Jobressource zum Erstellen von Docker-Images sieht normalerweise folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">apiVersion: batch/v1 kind: Job metadata: name: build-image spec: template: spec: containers: - name: build-image image: gcr.io/kaniko-project/executor:latest args: - "--context=/workspace/my-build" - "--dockerfile=/workspace/my-build/Dockerfile" - "--destination=&lt;repo-url-with-image-name&gt;:&lt;tag&gt;" volumeMounts: - name: workspace mountPath: /workspace volumes: - name: workspace persistentVolumeClaim: claimName: kaniko-workspace restartPolicy: Never backoffLimit: 3</code> </pre> <br><p>  Wenn für die Docker-Zielregistrierung eine Authentifizierung erforderlich ist, übergeben Sie die Datei <code>config.json</code> mit den Anmeldeinformationen an den Kaniko-Container.  Am einfachsten ist es, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PersistentVolumeClaim</a> mit einem Container zu verbinden, der bereits eine <code>config.json</code> Datei enthält.  Hier wird PersistentVolumeClaim nicht als Verzeichnis, sondern als Datei im Pfad <code>/kaniko/.docker/config.json</code> im <code>/kaniko/.docker/config.json</code> Container <code>/kaniko/.docker/config.json</code> : </p><br><pre> <code class="plaintext hljs">apiVersion: batch/v1 kind: Job metadata: name: build-image spec: template: spec: containers: - name: build-image image: gcr.io/kaniko-project/executor:latest args: - "--context=/workspace/my-build" - "--dockerfile=/workspace/my-build/Dockerfile" - "--destination=&lt;repo-url-with-image-name&gt;:&lt;tag&gt;" volumeMounts: - name: config-json mountPath: /kaniko/.docker/config.json subPath: config.json - name: workspace mountPath: /workspace volumes: - name: config-json persistentVolumeClaim: claimName: kaniko-credentials - name: workspace persistentVolumeClaim: claimName: kaniko-workspace restartPolicy: Never backoffLimit: 3</code> </pre> <br><p>  Wenn Sie den Status eines <code>kubectl</code> Build-Jobs überprüfen möchten, verwenden Sie <code>kubectl</code> .  Führen Sie den folgenden Befehl aus, um den Status nach <code>stdout</code> zu filtern: </p><br><pre> <code class="plaintext hljs">$ kubectl get job build-image -o go-template='{{(index .status.conditions 0).type}}'</code> </pre> <br><h3 id="itogi">  Zusammenfassung </h3><br><p>  Sie haben aus dem Artikel erfahren, dass Docker-in-Docker nicht zum Erstellen von Docker-Images in Kubernetes geeignet ist.  Ich habe eine Idee von Kaniko - eine Alternative zu Docker-in-Docker, mit der Docker-Images ohne Docker zusammengestellt werden.  Wir haben auch gelernt, wie man Jobressourcen schreibt, um Docker-Bilder in Kubernetes zu sammeln.  Und schließlich sahen sie, wie sie den Status einer laufenden Aufgabe herausfinden konnten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436126/">https://habr.com/ru/post/de436126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436116/index.html">PERDIX: Ein Algorithmus für das automatische Design von DNA-Origami unterschiedlicher Geometrie</a></li>
<li><a href="../de436118/index.html">Die Erfahrung, den ersten Roboter auf Arduino (Roboterjäger) zu erschaffen</a></li>
<li><a href="../de436120/index.html">Der schwer zu fassende Fehler in LittleBigPlanet</a></li>
<li><a href="../de436122/index.html">Intel Lakefield: Atom + Core-Hybridprozessor in 3D</a></li>
<li><a href="../de436124/index.html">Wir lesen Kommentare zu Habré mit Bequemlichkeiten</a></li>
<li><a href="../de436128/index.html">Interview mit Baghunter Artyom Moskau. Er hackte Steam und erhielt die größte Auszeichnung in der Geschichte von Valve.</a></li>
<li><a href="../de436130/index.html">Das Projekt des Ministeriums für Telekommunikation und Massenkommunikation zur Übertragung des Internetverkehrs über russische Sender erschwert die Legalisierung von OneWeb in Russland</a></li>
<li><a href="../de436132/index.html">12 seltsame Dinge, die nach der Installation des npm-Pakets passieren können</a></li>
<li><a href="../de436134/index.html">Auf Importrouter werden bis zu 20% Sperrzölle erhoben</a></li>
<li><a href="../de436136/index.html">OceanLotus: Wasserlochangriff in Südostasien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>