<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏻 🤸🏿 👊🏽 15 properti dan metode objek DOM yang kurang dikenal 👩‍👦 👱🏿 🏹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat mengembangkan situs web modern, fitur JavaScript untuk bekerja dengan DOM banyak digunakan. Skrip memungkinkan Anda untuk menampilkan dan menyemb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>15 properti dan metode objek DOM yang kurang dikenal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416539/">  Saat mengembangkan situs web modern, fitur JavaScript untuk bekerja dengan DOM banyak digunakan.  Skrip memungkinkan Anda untuk menampilkan dan menyembunyikan elemen-elemen dari mana halaman-halaman itu dibuat, mengonfigurasi properti dari elemen-elemen ini.  Objek DOM yang berinteraksi dengan dari program memiliki properti dan metode.  Praktis semua programmer web mengetahui tentang beberapa dari mereka, menurut penulis materi, terjemahan yang kami terbitkan hari ini.  Tetapi beberapa yang ingin dia bicarakan di sini jauh kurang terkenal. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/lw/k4/ct/lwk4ctoknigawiym3hgeyacp5nu.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">HTML dan DOM</font> </h2><br>  Pertama, mari kita bicara tentang perbedaan antara HTML dan DOM.  Misalnya, elemen <code>&lt;table&lt;</code> reguler jelas kode HTML.  Elemen ini dapat digunakan dalam file html, ia memiliki seperangkat atribut yang menentukan penampilan dan perilaku tabel yang dibuat dengan bantuannya.  Sebenarnya, tag <code>&lt;table&gt;</code> itu sendiri tidak ada hubungannya dengan JavaScript.  Hubungan antara elemen HTML yang ada dalam dokumen dan kode JavaScript disediakan oleh DOM (Document Object Model).  DOM memungkinkan untuk berinteraksi dengan elemen HTML dari kode JavaScript seolah-olah mereka objek. <br><br>  Semua elemen HTML memiliki "antarmuka DOM" sendiri yang menentukan properti (biasanya terkait dengan atribut elemen HTML) dan metode.  Misalnya, elemen <code>&lt;table&gt;</code> memiliki antarmuka yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTMLTableElement</a> . <br><br>  Anda bisa mendapatkan tautan ke elemen, misalnya, menggunakan konstruksi berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchBox = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'search-box'</span></span>);</code> </pre> <br>  Setelah tautan ke elemen diterima, programmer memiliki akses ke properti dan metode yang dimiliki elemen tersebut.  Misalnya, Anda bisa bekerja dengan properti <code>value</code> bidang teks tertentu, mengingat bahwa tautannya disimpan dalam variabel <code>searchBox</code> menggunakan struktur form <code>searchBox.value</code> .  Anda dapat menempatkan kursor di bidang teks ini dengan memanggil metode <code>searchBox.focus()</code> . <br><br>  Mungkin di sinilah kita dapat menyelesaikan "kursus singkat tentang DOM" dan, pada kenyataannya, ke properti dan metode antarmuka DOM dari elemen HTML yang tidak banyak diketahui. <br><br>  Jika Anda ingin membaca dan bereksperimen segera, buka alat pengembang browser.  Secara khusus, untuk mendapatkan tautan ke elemen halaman tertentu, Anda dapat memilihnya di pohon elemen, dan kemudian menggunakan konstruk <code>$0</code> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konsol</a> .  Untuk melihat item sebagai objek, ketikkan <code>dir($0)</code> di konsol.  Omong-omong, jika Anda menemukan sesuatu yang baru untuk Anda, cobalah menjelajahinya menggunakan konsol. <br><br><h2>  <font color="#3AC1EF">1: metode tabel</font> </h2><br>  Elemen <code>&lt;table&gt;</code> sederhana (yang masih memegang tempat pertama di antara teknologi yang digunakan dalam pengembangan tata letak halaman web) memiliki cukup banyak metode yang sangat baik yang sangat menyederhanakan proses membangun tabel. <br><br>  Ini beberapa di antaranya. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableEl = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'table'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerRow = tableEl.createTHead().insertRow(); headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Make'</span></span>; headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Model'</span></span>; headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Color'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newRow = tableEl.insertRow(); newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Yes'</span></span>; newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'No'</span></span>; newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Thank you'</span></span>;</code> </pre> <br>  Seperti yang Anda lihat, di sini kami tidak menggunakan perintah seperti <code>document.createElement()</code> .  Dan metode <code>.insertRow()</code> , jika Anda menyebutnya langsung di atas meja, bahkan akan memberikan tambahan <code>&lt;tbody&gt;</code> .  Luar biasa bukan? <br><br><h2>  <font color="#3AC1EF"># 2: metode scrollIntoView ()</font> </h2><br>  Anda mungkin tahu bahwa jika tautan memiliki konstruksi seperti <code>#something</code> , maka setelah memuat laman, peramban akan secara otomatis menggulir ke elemen dengan <code>ID</code> sesuai?  Metode ini nyaman, tetapi jika elemen yang menarik bagi kami diberikan setelah halaman dimuat, itu tidak akan berfungsi.  Inilah cara membuat ulang pola perilaku ini sendiri: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.querySelector</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.location</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hash</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.scrollIntoView</span></span>();</code> </pre> <br><h2>  <font color="#3AC1EF">3: properti tersembunyi</font> </h2><br>  Di sini kami mempertimbangkan sebuah properti, namun, kemungkinan besar, ketika mengakses properti ini, setter tertentu akan dipanggil, yang merupakan metode.  Bagaimanapun, ingat, pernahkah Anda menggunakan desain yang ditunjukkan di bawah ini untuk menyembunyikan elemen? <br><br><pre> <code class="hljs swift">myElement.style.display = '<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>'</code> </pre> <br>  Jika Anda menggunakannya, Anda tidak harus melakukannya lagi.  Untuk menyembunyikan elemen, cukup tulis <code>true</code> ke properti <code>hidden</code> : <br><br><pre> <code class="hljs objectivec">myElement.hidden = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF"># 4: metode toggle ()</font> </h2><br>  Sebenarnya, ini bukan metode beberapa elemen.  Ini adalah metode properti elemen.  Secara khusus, metode ini memungkinkan Anda untuk menambahkan kelas ke suatu elemen dan menghapusnya dari itu menggunakan konstruksi berikut: <br><br><pre> <code class="hljs scala">myElement.classList.toggle(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')</span></span></code> </pre> <br>  Omong-omong, jika Anda pernah menambahkan kelas menggunakan konstruk <code>if</code> , ketahuilah bahwa Anda tidak perlu melakukan ini lagi, dan lupakan konstruk ini.  Mekanisme yang sama diimplementasikan menggunakan parameter kedua metode <code>toggle()</code> .  Jika ini adalah ekspresi yang bernilai <code>true</code> , maka kelas yang diteruskan ke <code>toggle()</code> akan ditambahkan ke elemen. <br><br><pre> <code class="hljs scala">el.classList.toggle(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-orange-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">', </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">theme</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">===</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">orange</span></span></span><span class="hljs-class">')</span></span>;</code> </pre> <br>  Mungkin, di sini Anda mungkin memiliki keraguan tentang kecukupan desain ini.  Setelah semua, nama metode, "beralih", yang, mengingat fakta bahwa esensi dari tindakan yang dilakukan olehnya tersembunyi di dalamnya, dapat diterjemahkan sebagai "switch", tidak mengandung menyebutkan bahwa "switch" menyiratkan pemenuhan kondisi tertentu.  Namun, desain yang dijelaskan di atas ada dalam bentuk ini, meskipun pengembang Internet Explorer mungkin juga menganggapnya aneh.  Dalam penerapan <code>toggle()</code> parameter kedua tidak disediakan.  Oleh karena itu, walaupun dikatakan di atas bahwa mereka yang tahu tentang <code>toggle()</code> dapat melupakan konstruk <code>if</code> , lupakan saja, namun, jangan. <br><br><h2>  <font color="#3AC1EF"># 5: metode querySelector ()</font> </h2><br>  Anda pasti sudah tahu tentang keberadaan metode ini, tetapi ada kecurigaan bahwa tepatnya 17% dari Anda tidak tahu bahwa itu dapat digunakan dalam aplikasi ke elemen apa pun. <br><br>  Misalnya, konstruksi <code>myElement.querySelector('.my-class')</code> hanya memilih elemen-elemen yang memiliki kelas <code>my-class</code> dan pada saat yang sama merupakan turunan dari elemen <code>myElement</code> . <br><br><h2>  <font color="#3AC1EF"># 6: metode terdekat ()</font> </h2><br>  Semua elemen yang mendukung pencarian elemen induk memiliki metode ini.  Ini adalah sesuatu seperti kebalikan dari <code>querySelector()</code> .  Menggunakan metode ini, misalnya, Anda bisa mendapatkan judul untuk bagian saat ini: <br><br><pre> <code class="hljs cs">myElement.closest(<span class="hljs-string"><span class="hljs-string">'article'</span></span>).querySelector(<span class="hljs-string"><span class="hljs-string">'h1'</span></span>);</code> </pre> <br>  Di sini, selama pencarian, pertama elemen induk pertama <code>&lt;article&gt;</code> terdeteksi, dan kemudian elemen pertama <code>&lt;h1&gt;</code> memasukinya. <br><br><h2>  <font color="#3AC1EF"># 7: metode getBoundingClientRect ()</font> </h2><br>  Metode <code>getBoundingClientRect()</code> mengembalikan objek kecil yang dihias dengan baik berisi informasi tentang ukuran elemen yang disebut metode ini. <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">x</span></span>: <span class="hljs-number"><span class="hljs-number">604.875</span></span>, y: <span class="hljs-number"><span class="hljs-number">1312</span></span>, width: <span class="hljs-number"><span class="hljs-number">701.625</span></span>, height: <span class="hljs-number"><span class="hljs-number">31</span></span>, top: <span class="hljs-number"><span class="hljs-number">1312</span></span>, right: <span class="hljs-number"><span class="hljs-number">1306.5</span></span>, bottom: <span class="hljs-number"><span class="hljs-number">1343</span></span>, left: <span class="hljs-number"><span class="hljs-number">604.875</span></span> }</code> </pre> <br>  Namun, menggunakan metode ini, perhatian harus diberikan, khususnya, memperhatikan dua poin: <br><br><ul><li>  Memanggil metode ini menghasilkan redraw dari halaman.  Bergantung pada perangkat di mana halaman dilihat, dan pada kompleksitas halaman, operasi ini dapat memakan waktu beberapa milidetik.  Pertimbangkan ini jika Anda bermaksud memanggil metode ini dalam fragmen kode berulang, misalnya, saat melakukan animasi. </li><li>  Tidak semua browser mendukung metode ini. </li></ul><br><h2>  <font color="#3AC1EF"># 8: metode cocok ()</font> </h2><br>  Misalkan kita perlu memeriksa apakah elemen tertentu memiliki kelas tertentu. <br><br>  Inilah cara mengatasi masalah ini, tampaknya dengan cara yang paling sulit: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.className.indexOf(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">') </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">-1</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br>  Ini pilihan lain, lebih baik, tetapi juga jauh dari ideal: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.className.includes(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br>  Dan inilah cara terbaik untuk menyelesaikan masalah ini: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.matches('.some-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF"># 9: masukkan metodeAdjacentElement ()</font> </h2><br>  Metode ini mirip dengan <code>appendChild()</code> , tetapi memberikan sedikit lebih banyak kekuatan di mana tepatnya elemen anak akan ditambahkan. <br><br>  Jadi, perintah <code>parentEl.insertAdjacentElement('beforeend', newEl)</code> mirip dengan perintah <code>parentEl.appendChild(newEl)</code> , tetapi menggunakan metode <code>insertAdjacentElement()</code> , Anda dapat meneruskan <code>beforebegin</code> , <code>afterbegin</code> , dan <code>afterend</code> , menunjukkan tempat di mana Anda perlu tambahkan item. <br><br><h2>  <font color="#3AC1EF">10: berisi metode ()</font> </h2><br>  Pernahkah Anda ingin tahu apakah satu elemen ada di dalam yang lain?  Saya membutuhkannya sepanjang waktu.  Misalnya, jika selama pemrosesan peristiwa klik mouse Anda perlu mencari tahu apakah itu terjadi di dalam jendela modal atau di luarnya (yang artinya dapat ditutup), Anda dapat menggunakan konstruksi berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!modalEl.contains(e.target)) modalEl.hidden = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; };</code> </pre> <br>  Di sini <code>modalEl</code> adalah tautan ke jendela modal, dan <code>e.target</code> adalah elemen apa pun yang diklik.  Menariknya, ketika saya menggunakan teknik ini, saya tidak pernah bisa menulis semuanya dengan benar pertama kali, bahkan ketika saya ingat bahwa saya terus-menerus salah dan mencoba untuk memperbaiki kemungkinan kesalahan di muka. <br><br><h2>  <font color="#3AC1EF"># 11: metode getAttribute ()</font> </h2><br>  Mungkin metode ini bisa disebut yang paling tidak berguna, namun, ada satu situasi yang pasti bisa berguna. <br><br>  Ingat, kami katakan sebelumnya bahwa properti objek DOM biasanya dikaitkan dengan atribut elemen HTML? <br><br>  Salah satu kasus saat ini bukan kasus diwakili oleh atribut <code>href</code> , misalnya, seperti di sini: <code>&lt;a href="/animals/cat"&gt;Cat&lt;/a&gt;</code> . <br><br>  Konstruksi <code>el.href</code> tidak <code>el.href</code> kembali, seperti yang Anda harapkan, <code>/animals/cat</code> .  Ini karena elemen <code>&lt;a&gt;</code> mengimplementasikan antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTMLHyperlinkElementUtils</a> , yang memiliki banyak properti pembantu seperti <code>protocol</code> dan <code>hash</code> yang membantu Anda mengetahui detail tautan. <br>  Salah satu properti pembantu ini adalah properti <code>href</code> , yang memberikan URL lengkap yang mencakup segala sesuatu yang URL relatif tidak miliki dalam atribut. <br><br>  Akibatnya, untuk mendapatkan apa yang tertulis dalam atribut <code>href</code> , Anda perlu menggunakan <code>el.getAttribute('href')</code> . <br><br><h2>  <font color="#3AC1EF">12: tiga metode elemen &lt;dialog&gt;</font> </h2><br>  Elemen <code>&lt;dialog&gt;</code> relatif baru memiliki dua metode yang bermanfaat, tetapi cukup biasa, dan satu metode yang dapat disebut sangat bagus.  Jadi, metode <code>show()</code> dan <code>close()</code> melakukan apa yang dapat Anda harapkan dari mereka, menunjukkan dan menyembunyikan jendela.  Kami menyebutnya bermanfaat, tetapi biasa saja.  Tetapi metode <code>showModal()</code> akan menampilkan elemen <code>&lt;dialog&gt;</code> di atas segalanya, menampilkannya di tengah jendela.  Sebagai Sebenarnya, perilaku seperti itu biasanya diharapkan dari modal windows.  Saat bekerja dengan elemen-elemen seperti itu, Anda tidak perlu memikirkan properti <code>z-index</code> , secara manual menambahkan latar belakang buram, atau mendengarkan acara menekan tombol <code>Escape</code> untuk menutup jendela yang sesuai.  Browser tahu bagaimana modal windows seharusnya bekerja dan akan memastikan semuanya berjalan sebagaimana mestinya. <br><br><h2>  <font color="#3AC1EF"># 13: metode forEach ()</font> </h2><br>  Terkadang, ketika Anda mendapatkan tautan ke daftar elemen, Anda bisa <code>forEach()</code> pada elemen-elemen ini menggunakan metode <code>forEach()</code> .  Loop <code>for()</code> adalah kemarin.  Misalkan kita perlu mendaftar semua elemen <code>&lt;a&gt;</code> dari halaman dalam log.  Jika kami melakukan ini seperti yang ditunjukkan di bawah ini, kami akan menemukan pesan kesalahan: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'a'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br>  Untuk mengatasi masalah ini, Anda dapat menggunakan konstruksi berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br>  Intinya di sini adalah metode seperti <code>getElementsByTagName()</code> mengembalikan objek bertipe <code>HTMLCollection</code> , dan <code>querySelectorAll</code> objek <code>querySelectorAll</code> .  Ini adalah antarmuka objek <code>NodeList</code> memberi kita akses ke metode <code>forEach()</code> (dan juga ke metode <code>keys()</code> , <code>values()</code> dan <code>entries()</code> ). <br><br>  Bahkan, akan jauh lebih baik jika metode seperti itu hanya mengembalikan array normal, dan tidak menawarkan kepada kita sesuatu yang memiliki semacam metode yang tampaknya berguna yang tidak seperti array.  Namun, jangan kecewa karena ini, karena orang-orang pintar dari ECMA memberi kami metode yang bagus - <code>Array.from()</code> , yang memungkinkan kami mengubah segala sesuatu yang tampak seperti array menjadi array. <br><br>  Sebagai hasilnya, Anda dapat menulis yang berikut ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br>  Dan ini hal kecil yang menyenangkan.  Dengan mentransformasikannya menjadi sebuah array yang dulunya seperti itu, kita berkesempatan untuk menggunakan banyak metode array, seperti <code>map()</code> , <code>filter()</code> dan <code>reduce()</code> .  Di sini, misalnya, cara membentuk array tautan eksternal pada halaman: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.origin) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">origin</span></span></span><span class="hljs-function"> =&gt;</span></span> origin !== <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.origin) .filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>);</code> </pre> <br>  Ngomong-ngomong, saya sangat suka konstruksi <code>.filter(Boolean)</code> karena ketika saya temui suatu saat dalam kode yang saya tulis sejak lama, saya hampir tidak bisa langsung memahami maknanya. <br><br><h2>  <font color="#3AC1EF">Nomor 14: bekerja dengan formulir</font> </h2><br>  Anda sangat mungkin tahu bahwa elemen <code>&lt;form&gt;</code> memiliki metode <code>submit()</code> .  Namun, kecil kemungkinan Anda tahu bahwa formulir memiliki metode <code>reset()</code> , dan mereka memiliki metode <code>reportValidity()</code> , yang berlaku ketika validasi mengisi elemen formulir digunakan. <br><br>  Saat bekerja dengan formulir, di samping itu, Anda bisa menggunakan properti <code>elements</code> mereka, yang, melalui suatu titik, memungkinkan Anda untuk mengakses elemen formulir menggunakan atribut <code>name</code> mereka.  Misalnya, konstruk <code>myFormEl.elements.email</code> akan mengembalikan elemen <code>&lt;input name="email" /&gt;</code> yang dimiliki oleh formulir ("milik" tidak selalu berarti "menjadi keturunan"). <br><br>  Perlu dicatat di sini bahwa properti <code>elements</code> itu sendiri tidak mengembalikan daftar elemen biasa.  Ini mengembalikan daftar kontrol (dan daftar ini, tentu saja, bukan sebuah array). <br><br>  Berikut ini sebuah contoh.  Jika ada tiga tombol radio pada formulir dan semuanya memiliki nama yang sama ( <code>animal</code> ), <code>formEl.elements.animal</code> konstruksi akan memberikan tautan ke satu set tombol radio (1 kontrol, 3 elemen HTML).  Dan jika Anda menggunakan desain <code>formEl.elements.animal.value</code> , maka itu akan memberikan nilai tombol radio yang dipilih oleh pengguna. <br><br>  Jika Anda memikirkannya, maka itu semua terlihat sangat aneh, jadi mari kita berurusan dengan contoh sebelumnya: <br><br><ul><li>  <code>formEl</code> adalah sebuah elemen. </li><li>  <code>elements</code> adalah objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTMLFormControlsCollection</a> yang menyerupai array tetapi tidak.  Elemen-elemennya tidak harus elemen HTML. </li><li>  <code>animal</code> adalah seperangkat beberapa tombol radio, disajikan sebagai satu set karena fakta bahwa mereka semua memiliki atribut <code>name</code> sama (ada antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RadioNodeList yang</a> dirancang khusus untuk bekerja dengan tombol radio). </li><li>  <code>value</code> digunakan untuk mengakses atribut <code>value</code> dari tombol radio aktif dalam koleksi. </li></ul><br><h2>  <font color="#3AC1EF"># 15: pilih metode ()</font> </h2><br>  Mungkin di akhir materi akan lebih baik untuk berbicara tentang beberapa metode yang benar-benar menakjubkan, meskipun mungkin metode ini akan menjadi wahyu bagi seseorang.  Jadi, metode <code>.select()</code> memungkinkan Anda untuk memilih teks di bidang input yang dipanggil. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kami berbicara tentang metode dan properti yang sedikit diketahui yang dapat digunakan untuk bekerja dengan konten halaman web.  Kami harap Anda menemukan sesuatu yang baru di sini untuk Anda sendiri, dan mungkin tidak hanya baru, tetapi juga bermanfaat. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan sarana interaksi terprogram dengan konten halaman web yang tidak dikenal luas? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416539/">https://habr.com/ru/post/id416539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416527/index.html">Virgin Galactic telah setuju untuk menggunakan pelabuhan antariksa Italia</a></li>
<li><a href="../id416531/index.html">Pelatihan Keberlanjutan GAN</a></li>
<li><a href="../id416533/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 322 (2 - 8 Juli, 2018)</a></li>
<li><a href="../id416535/index.html">Acara digital di Moskow 9-15 Juli</a></li>
<li><a href="../id416537/index.html">Lokakarya di Wireshark</a></li>
<li><a href="../id416541/index.html">Energi Terbarukan Pertanyaan yang Sering Diajukan, Bagian 2</a></li>
<li><a href="../id416543/index.html">PHP Digest No. 134 (24 Juni - 8 Juli 2018)</a></li>
<li><a href="../id416545/index.html">Sepotong pengalaman pribadi: pengembangan, permintaan tarik, komitmen, keterampilan perangkat lunak</a></li>
<li><a href="../id416547/index.html">Rostec meninggalkan Yota Devices, sebuah smartphone dengan dua layar akan ditawarkan kepada pelanggan Kantor Berita Xinhua</a></li>
<li><a href="../id416549/index.html">Kapal selam mini rescue sedang diuji</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>