<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤤 🤳🏽 📔 Buat pustaka gaya Spring Data Repository Anda sendiri dengan Dynamic Proxy dan Spring IoC ⛔️ 🧙🏾 👩🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tetapi bagaimana jika Anda bisa membuat antarmuka, misalnya, seperti ini: 
 

@Service public interface GoogleSearchApi { /** * @return http status co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat pustaka gaya Spring Data Repository Anda sendiri dengan Dynamic Proxy dan Spring IoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458548/"><p>  Tetapi bagaimana jika Anda bisa membuat antarmuka, misalnya, seperti ini: </p><br>
<pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleSearchApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Dan kemudian menyuntikkannya dan memanggil metodenya: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommandLineRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(App.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GoogleSearchApi api; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GoogleSearchApi api)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api = api; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page status: "</span></span> + api.mainPageStatus()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } }</code> </pre> <br><p>  Ini sangat mungkin untuk diterapkan (dan tidak terlalu sulit).  Selanjutnya saya akan menunjukkan bagaimana dan mengapa melakukannya. </p><a name="habracut"></a><br><p>  Baru-baru ini, saya memiliki tugas untuk menyederhanakan interaksi pengembang dengan salah satu kerangka kerja yang digunakan.  Itu perlu untuk memberi mereka cara yang lebih sederhana dan nyaman untuk bekerja dengannya daripada yang sudah diterapkan. </p><br><p>  Properti yang ingin saya capai dari solusi seperti itu: </p><br><ul><li>  deskripsi deklaratif dari tindakan yang diinginkan </li><li>  jumlah minimum kode yang dibutuhkan </li><li>  integrasi dengan kerangka kerja injeksi ketergantungan yang digunakan (dalam kasus kami, Spring) </li></ul><br><p>  Ini diimplementasikan dalam pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Retrofit</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data Musim Semi</a> .  Di dalamnya, pengguna menggambarkan interaksi yang diinginkan dalam bentuk antarmuka java, dilengkapi dengan penjelasan.  Pengguna tidak perlu menulis sendiri implementasinya - pustaka menghasilkannya dalam runtime berdasarkan tanda tangan metode, anotasi dan tipe. </p><br><p>  Ketika saya mempelajari topik itu, saya punya banyak pertanyaan, jawaban yang tersebar di Internet.  Pada saat itu, artikel seperti ini tidak akan menyakiti saya.  Karena itu, di sini saya mencoba mengumpulkan semua informasi dan pengalaman saya di satu tempat. </p><br><p>  Dalam posting ini saya akan menunjukkan bagaimana Anda dapat mengimplementasikan ide ini, menggunakan contoh pembungkus untuk klien http.  Contoh mainan, dirancang bukan untuk penggunaan nyata, tetapi untuk menunjukkan pendekatan.  Kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://bitbucket.org/bachkovsky/dynamic-proxy-">sumber</a> proyek dapat dipelajari di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://bitbucket.org/bachkovsky/dynamic-proxy-">bitbucket</a> . </p><br><h3 id="kak-eto-vyglyadit-dlya-polzovatelya">  Bagaimana cara mencari pengguna </h3><br><p>  Pengguna menggambarkan layanan yang ia butuhkan dalam bentuk antarmuka.  Misalnya, untuk melakukan permintaan http di google: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Some Google requests */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleSearchApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> request object for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-function">HttpGet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> query search query * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> result of search request execution */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/search?q={query}"</span></span>) <span class="hljs-function"><span class="hljs-function">CloseableHttpResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String query)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> query doodle search query * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> language doodle search language * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for doodle search result */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/doodles/?q={query}&amp;hl={language}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchDoodleStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String query, String language)</span></span></span></span>; }</code> </pre> <br><p>  Apa implementasi dari antarmuka ini pada akhirnya akan dilakukan ditentukan oleh tanda tangan.  Jika jenis kembali int, permintaan http akan dieksekusi dan kode status akan dikembalikan.  Jika jenis kembali adalah CloseableHttpResponse, maka seluruh respons akan dikembalikan, dan seterusnya.  Di mana permintaan akan dibuat, kami akan mengambil Uri dari anotasi, menggantikan nilai yang ditransfer yang sama alih-alih placeholder dalam isinya. </p><br><p>  Dalam contoh ini, saya membatasi diri saya untuk mendukung tiga tipe pengembalian dan satu anotasi.  Anda juga dapat menggunakan nama metode, tipe parameter untuk memilih implementasi, menggunakan semua jenis kombinasi mereka, tetapi saya tidak akan membuka topik ini di posting ini. </p><br><p>  Saat pengguna ingin menggunakan antarmuka ini, ia menyematkannya dalam kode menggunakan Spring: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommandLineRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(App.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GoogleSearchApi api; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GoogleSearchApi api)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api = api; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page status: "</span></span> + api.mainPageStatus()); LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page request: "</span></span> + api.mainPageRequest()); LOG.info(<span class="hljs-string"><span class="hljs-string">"Doodle search status: "</span></span> + api.searchDoodleStatus(<span class="hljs-string"><span class="hljs-string">"tesla"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (CloseableHttpResponse response = api.searchSomething(<span class="hljs-string"><span class="hljs-string">"qweqwe"</span></span>)) { LOG.info(<span class="hljs-string"><span class="hljs-string">"Search result "</span></span> + response); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } }</code> </pre> <br><p>  Integrasi dengan Spring diperlukan dalam proyek kerja saya, tetapi itu, tentu saja, bukan satu-satunya yang mungkin.  Jika Anda tidak menggunakan injeksi ketergantungan, Anda bisa mendapatkan implementasinya, misalnya, melalui metode pabrik statis.  Tetapi dalam artikel ini saya akan mempertimbangkan Spring. </p><br><p>  Pendekatan ini sangat mudah: cukup tandai antarmuka Anda sebagai komponen Spring (Layanan annotation dalam kasus ini), dan siap untuk implementasi dan penggunaan. </p><br><h3 id="kak-zastavit-spring-podderzhivat-etu-magiyu">  Cara mendapatkan Spring untuk mendukung sihir ini </h3><br><p>  Aplikasi khas Spring memindai classpath saat startup dan mencari semua komponen yang ditandai dengan anotasi khusus.  Bagi mereka, ini mendaftarkan BeanDefinitions, resep yang dengannya komponen ini akan dibuat.  Tetapi jika dalam kasus kelas konkret, Spring tahu bagaimana membuat mereka, apa yang memanggil konstruktor, dan apa yang harus lulus di dalamnya, maka untuk kelas dan antarmuka abstrak itu tidak memiliki informasi seperti itu.  Karenanya, untuk GoogleSearchApi Spring kami tidak akan membuat BeanDefinition.  Dalam hal ini dia akan membutuhkan bantuan dari kami. </p><br><p>  Untuk menyelesaikan logika pemrosesan BeanDefinitions, ada antarmuka BeanDefinitionRegistryPostProcessor di musim semi.  Dengan itu, kita dapat menambahkan BeanDefinitionRegistry definisi kacang yang kita inginkan. </p><br><p>  Sayangnya, saya tidak menemukan cara untuk mengintegrasikan ke dalam logika Spring dari pemindaian classpath untuk memproses kacang biasa dan antarmuka kita dalam sekali jalan.  Oleh karena itu, saya membuat dan menggunakan turunan kelas ClassPathScanningCandidateComponentProvider untuk menemukan semua antarmuka yang ditandai dengan anotasi Layanan: </p><br><p>  Kode pindaian paket lengkap dan pendaftaran BeanDefinitions: </p><br><div class="spoiler">  <b class="spoiler_title">DynamicProxyBeanDefinitionRegistryPostProcessor</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyBeanDefinitionRegistryPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanDefinitionRegistryPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     private static final String[] SCAN_PACKAGES = {"com"}; private final InterfaceScanner classpathScanner; public DynamicProxyBeanDefinitionRegistryPostProcessor() { classpathScanner = new InterfaceScanner(); //   .      Service classpathScanner.addIncludeFilter(new AnnotationTypeFilter(Service.class)); } @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { for (String basePackage : SCAN_PACKAGES) { createRepositoryProxies(basePackage, registry); } } @SneakyThrows private void createRepositoryProxies(String basePackage, BeanDefinitionRegistry registry) { for (BeanDefinition beanDefinition : classpathScanner.findCandidateComponents(basePackage)) { Class&lt;?&gt; clazz = Class.forName(beanDefinition.getBeanClassName()); //      bean definition BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(clazz); builder.addConstructorArgValue(clazz); //,          builder.setFactoryMethodOnBean( "createDynamicProxyBean", DynamicProxyBeanFactory.DYNAMIC_PROXY_BEAN_FACTORY ); registry.registerBeanDefinition(ClassUtils.getShortNameAsProperty(clazz), builder.getBeanDefinition()); } } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { } private static class InterfaceScanner extends ClassPathScanningCandidateComponentProvider { InterfaceScanner() { super(false); } @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { return beanDefinition.getMetadata().isInterface(); } } }</span></span></code> </pre> </div></div><br><p>  Selesai!  Pada awal aplikasi, Spring akan menjalankan kode ini dan mendaftarkan semua antarmuka yang diperlukan, seperti kacang. </p><br><p>  Membuat implementasi kacang yang ditemukan didelegasikan ke komponen terpisah dari DynamicProxyBeanFactory: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(DYNAMIC_PROXY_BEAN_FACTORY) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyBeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DYNAMIC_PROXY_BEAN_FACTORY = <span class="hljs-string"><span class="hljs-string">"repositoryProxyBeanFactory"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DynamicProxyInvocationHandlerDispatcher proxy; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicProxyBeanFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DynamicProxyInvocationHandlerDispatcher proxy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.proxy = proxy; } <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unused"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDynamicProxyBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; beanClass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//noinspection unchecked return (T) Proxy.newProxyInstance(beanClass.getClassLoader(), new Class[]{beanClass}, proxy); } }</span></span></code> </pre> <br><p>  Untuk membuat implementasi, mekanisme Dynamic Proxy yang lama digunakan.  Implementasi dibuat dengan cepat menggunakan metode Proxy.newProxyInstance.  Banyak artikel telah ditulis tentang dia, jadi saya tidak akan tinggal di sini secara detail. </p><br><h3 id="poisk-nuzhnogo-obrabotchika-i-obrabotka-vyzova">  Menemukan pawang yang tepat dan memproses panggilan </h3><br><p>  Seperti yang Anda lihat, DynamicProxyBeanFactory mengalihkan metode pemrosesan ke DynamicProxyInvocationHandlerDispatcher.  Karena kami memiliki banyak potensi implementasi penangan (untuk setiap anotasi, untuk setiap jenis yang dikembalikan, dll.), Adalah logis untuk menetapkan beberapa tempat sentral untuk penyimpanan dan pencarian mereka. </p><br><p>  Untuk menentukan apakah handler cocok untuk memproses metode yang disebut, saya memperluas antarmuka InvocationHandler standar dengan metode baru </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerMatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> true} if handler is able to handle given method, {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> false} othervise */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProxyInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerMatcher</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Hasilnya adalah antarmuka ProxyInvocationHandler, implementasi yang akan menjadi penangan kami.  Juga, implementasi handler akan ditandai sebagai Komponen sehingga Spring dapat mengumpulkannya untuk kita ke dalam satu daftar besar di dalam DynamicProxyInvocationHandlerDispatcher: </p><br><div class="spoiler">  <b class="spoiler_title">DynamicProxyInvocationHandlerDispatcher</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.bachkovsky.dynproxy.lib.proxy; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.SneakyThrows; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Component; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.InvocationHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-comment"><span class="hljs-comment">/** * Top level dynamic proxy invocation handler, which finds correct implementation based and uses it for method * invocation */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyInvocationHandlerDispatcher</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;ProxyInvocationHandler&gt; proxyHandlers; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> proxyHandlers all dynamic proxy handlers found in app context */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicProxyInvocationHandlerDispatcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;ProxyInvocationHandler&gt; proxyHandlers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.proxyHandlers = proxyHandlers; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (method.getName()) { <span class="hljs-comment"><span class="hljs-comment">// three Object class methods don't have default implementation after creation with Proxy::newProxyInstance case "hashCode": return System.identityHashCode(proxy); case "toString": return proxy.getClass() + "@" + System.identityHashCode(proxy); case "equals": return proxy == args[0]; default: return doInvoke(proxy, method, args); } } @SneakyThrows private Object doInvoke(Object proxy, Method method, Object[] args) { return findHandler(method).invoke(proxy, method, args); } private ProxyInvocationHandler findHandler(Method method) { return proxyHandlers.stream() .filter(h -&gt; h.canHandle(method)) .findAny() .orElseThrow(() -&gt; new IllegalStateException("No handler was found for method: " + method)); } }</span></span></code> </pre> </div></div><br><p>  Dalam metode findHandler, kita melewati semua penangan dan mengembalikan yang pertama yang dapat menangani metode yang diteruskan.  Mekanisme pencarian ini mungkin tidak terlalu efektif ketika ada banyak implementasi handler.  Mungkin Anda perlu memikirkan struktur yang lebih cocok untuk menyimpannya daripada daftar. </p><br><h3 id="realizaciya-obrabotchikov">  Implementasi Handler </h3><br><p>  Tugas penangan meliputi membaca informasi tentang metode antarmuka yang dipanggil dan memproses panggilan itu sendiri. </p><br><p>  Apa yang harus dilakukan pawang dalam kasus ini: </p><br><ol><li>  Baca Uri anotasi, dapatkan isinya </li><li>  Ganti placeholder Uri dalam string dengan nilai nyata </li><li>  Baca jenis metode pengembalian </li><li>  Jika jenis pengembalian sesuai, proses metode dan mengembalikan hasilnya. </li></ol><br><p>  Tiga poin pertama diperlukan untuk semua tipe yang dikembalikan, jadi saya memasukkan kode umum ke dalam superclass abstrak <br>  HttpInvocationHandler: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProxyInvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HttpClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UriHandler uriHandler; HttpInvocationHandler(HttpClient client, UriHandler uriHandler) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uriHandler = uriHandler; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uriHandler.canHandle(method); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uriHandler.getUriString(method, args); } }</code> </pre> <br><p>  Kelas pembantu UriHandler mengimplementasikan kerja dengan anotasi Uri: nilai membaca, menggantikan placeholder.  Saya tidak akan memberikan kode di sini, karena  itu cukup utilitarian. <br>  Tetapi perlu dicatat bahwa untuk membaca nama parameter dari tanda tangan metode java, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda perlu menambahkan opsi "-parameters" saat kompilasi</a> . <br>  HttpClient - pembungkus atas Apachevsky CloseableHttpClient, adalah backend untuk perpustakaan ini. </p><br><p>  Sebagai contoh penangan tertentu, saya akan memberikan penangan yang mengembalikan kode respons status: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpCodeInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpCodeInvocationHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpClient client, UriHandler uriHandler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(client, uriHandler); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (CloseableHttpResponse resp = client.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpGet(getUri(method, args)))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.getStatusLine().getStatusCode(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.canHandle(method) &amp;&amp; method.getReturnType().equals(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.class); } }</code> </pre> <br><p>  Penangan lain dibuat serupa.  Menambahkan penangan baru itu sederhana dan tidak memerlukan modifikasi kode yang ada - cukup buat penangan baru dan tandai sebagai komponen Pegas. </p><br><p>  Itu saja.  Kode ditulis dan siap untuk digunakan. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Semakin saya memikirkan desain seperti itu, semakin saya melihat kekurangan di dalamnya.  Kelemahan yang saya lihat: </p><br><ul><li>  Ketik Keselamatan, yang tidak.  Atur anotasi dengan salah - sebelum bertemu dengan RuntimeException.  Digunakan kombinasi yang salah dari jenis kembali dan anotasi - hal yang sama. </li><li>  Dukungan lemah dari IDE.  Kurangnya penyelesaian otomatis.  Pengguna tidak dapat melihat tindakan apa yang tersedia baginya dalam situasinya (seolah-olah ia meletakkan "titik" setelah objek dan melihat daftar metode yang tersedia) </li><li>  Ada beberapa kemungkinan untuk aplikasi.  Klien http yang telah disebutkan muncul di benak, dan klien pergi ke database.  Tapi mengapa lagi ini bisa diterapkan? </li></ul><br><p>  Namun, dalam konsep kerja saya pendekatan ini telah mengakar dan populer.  Kelebihan yang telah saya sebutkan - kesederhanaan, sejumlah kecil kode, deklaratif, memungkinkan pengembang berkonsentrasi pada penulisan kode yang lebih penting. </p><br><p>  Apa pendapat Anda tentang pendekatan ini?  Apakah ini sepadan dengan usaha?  Masalah apa yang Anda lihat dalam pendekatan ini?  Sementara saya masih mencoba untuk memahaminya, sementara itu sedang diputar di produksi kami, saya ingin mendengar apa yang dipikirkan orang lain tentang itu.  Saya berharap materi ini bermanfaat bagi seseorang. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458548/">https://habr.com/ru/post/id458548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458524/index.html">Kata cloud VC di atas lutut</a></li>
<li><a href="../id458530/index.html">Zabbix, seri waktu dan TimescaleDB</a></li>
<li><a href="../id458532/index.html">Pelopor teknologi baru: Vadim Artsev memberi tahu bagaimana ia tidak lagi buta</a></li>
<li><a href="../id458536/index.html">Python + Pyside2 atau cukup "Kalkulator"</a></li>
<li><a href="../id458546/index.html">Hari Otomasi, atau bagaimana kami membangun lapisan autotest</a></li>
<li><a href="../id458550/index.html">Simbol GOST Library untuk DipTrace</a></li>
<li><a href="../id458552/index.html">Tentang membandingkan format penyimpanan di Hadoop: mari kita mulai dengan ORC</a></li>
<li><a href="../id458556/index.html">Kembangkan Ekstensi Chrome dengan Angular CLI</a></li>
<li><a href="../id458558/index.html">Presentasi dengan Magento Meetup Kharkiv - Video dan Presentasi</a></li>
<li><a href="../id458560/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 12. Advanced VLAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>