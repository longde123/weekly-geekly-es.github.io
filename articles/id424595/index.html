<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍡 👩‍⚖️ 🤴🏼 MVC + Skenario vs Pengontrol Lemak ⛰️ 🧘🏽 ✊🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="MVC + Skenario vs. Pengontrol Tebal 


 Kerangka kerja PHP modern (Symphony, Laravel, selanjutnya di mana-mana) secara meyakinkan menunjukkan bahwa me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVC + Skenario vs Pengontrol Lemak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424595/"><h1 id="mvc--scenario-protiv-tolstyh-kontrollerov">  MVC + Skenario vs. Pengontrol Tebal </h1><br><p> Kerangka kerja PHP modern (Symphony, Laravel, selanjutnya di mana-mana) secara meyakinkan menunjukkan bahwa menerapkan pola Model-View-Controller tidak begitu sederhana.  Semua implementasi karena alasan tertentu rentan terhadap Fat Controllers ( <code>fat controllers</code> ), dikutuk oleh semua, dan pengembang, dan kerangka kerja itu sendiri. </p><br><p>  Kenapa begitu?  Dan adakah cara untuk menangani ini?  Mari kita perbaiki. </p><a name="habracut"></a><br><h2 id="terminologiya">  Terminologi </h2><br><ul><li>  Model - model (pembentuk data yang diminta) </li><li>  Lihat - lihat (dekorator data model) </li><li>  Controller - controller (koordinator model-view seperti yang diminta) </li><li>  Templat - templat presentasi </li><li>  Rendering - rendering (pembentukan, desain gambar presentasi) </li><li>  Renderer - renderer (pembentuk, perancang gambar presentasi) </li></ul><br><h2 id="tolstyy-kontroller">  Pengontrol tebal </h2><br><p>  Berikut ini adalah Fat Controller khas: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *   *      ID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionUserHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ( ) $user = UserModel::find($userId); //       -   $name = $user-&gt;firstName.' '.$user-&gt;lastName; //         $view = new View('hello', ['name' =&gt; $name]); //  ( )     return $view-&gt;render(); } }</span></span></code> </pre> <br><p>  Apa yang kita lihat  Kami melihat vinaigrette!  Dalam controller semua yang mungkin dicampur - baik model, dan presentasi, dan, pada kenyataannya, controller itu sendiri! </p><br><p>  Kita melihat nama-nama model dan templat dengan erat terhubung ke controller.  Ini bukan buzz.  Kami melihat manipulasi dengan data model di controller - pembentukan nama lengkap dari nama depan dan belakang.  Dan ini bukan buzz. </p><br><p>  Dan satu hal lagi: kita tidak melihat contoh ini secara eksplisit, tetapi implisit.  Yaitu: hanya ada satu cara rendering (pembentukan gambar)!  Hanya satu: sesuai dengan templat di file php!  Dan jika saya ingin pdf?  Dan jika saya ingin tidak dalam file, tetapi dalam baris php?  Saya memiliki desain dengan desain rumit pada ratusan templat kecil.  Saya sendiri harus mengatakan renderer untuk templat string.  Saya tidak terlalu panas tentu saja, tetapi masalah ini pada prinsipnya. </p><br><p>  Ringkasan singkat: </p><br><blockquote>  Kerangka kerja modern memiliki kelemahan umum dalam implementasi MVC untuk semua orang: <br><ol><li>  Interpretasi sempit tampilan MVC (Tampilan) <strong><em>hanya</em></strong> sebagai <em>"Lihat dengan templat dalam file PHP" dan</em> bukan <em>"Lihat dengan penyaji apa pun</em> . <em>"</em> </li><li>  Interpretasi sempit dari model-MVC <strong><em>hanya</em></strong> sebagai "Domain Model Domain" dan bukannya <em>"Setiap kompiler data untuk presentasi</em> . <em>"</em> </li><li>  Mereka memprovokasi penggunaan apa yang disebut <em>"Pengontrol Tebal" yang</em> mengandung semua logika pada saat yang sama: bisnis, presentasi dan interaksi.  Ini sepenuhnya menghancurkan tujuan utama MVC - pembagian tanggung jawab antara komponen triad. </li></ol><br></blockquote><p>  Untuk mengatasi kekurangan ini, alangkah baiknya untuk melihat lebih dekat komponen-komponen MVC. </p><br><h2 id="predstavlenie---eto-renderer">  Lihat adalah penyaji </h2><br><p>  Lihatlah kelemahan pertama: </p><br><blockquote><ol><li>  Interpretasi sempit tampilan MVC (Tampilan) <strong><em>hanya</em></strong> sebagai <em>"Lihat dengan templat dalam file PHP"</em> alih-alih <em>"Lihat dengan penyaji apa pun</em> . <em>"</em> </li></ol><br></blockquote><p>  Di sini, semuanya cukup sederhana - solusi untuk masalah sudah ditunjukkan dalam perumusan masalah.  Kami hanya harus mengatakan bahwa penyaji mana pun dapat menggunakan tampilan.  Untuk mengimplementasikan ini, cukup tambahkan properti <code>renderer</code> baru ke kelas View: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $template, $data, $renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__costruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($template, $data, $renderer = NULL)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br><p>  Jadi, kami telah mendefinisikan properti <code>renderer</code> baru untuk tampilan.  Dalam kasus yang paling umum, nilai properti ini dapat berupa fungsi yang dapat <code>callable</code> yang membentuk gambar dari data yang ditransfer ke dalamnya menggunakan templat yang dikirim. </p><br><p>  Sebagian besar aplikasi hanya menggunakan satu renderer, dan bahkan jika mereka menggunakan beberapa, salah satunya lebih disukai.  Oleh karena itu, argumen <code>renderer</code> didefinisikan sebagai opsional, dengan asumsi ada beberapa renderer default. </p><br><p>  Apakah ini sederhana?  Sederhana  Sebenarnya tidak sesederhana itu.  Faktanya adalah bahwa <code>View</code> yang ada di MVC tidak persis <code>View</code> yang ada dalam framework.  <code>View</code> yang ada di dalam kerangka tidak bisa hidup tanpa templat.  Tapi <code>View</code> , yang di MVC, untuk beberapa alasan tidak tahu apa-apa tentang template yang sama ini.  Mengapa  Ya, karena untuk MVC <code>View</code> , ini adalah <em>konverter data model apa pun menjadi gambar</em> , dan bukan hanya mesin templat.  Ketika kami menulis sesuatu seperti ini di penangan permintaan: </p><br><pre> <code class="php hljs">$name = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello, {$name}!"</span></span>;</code> </pre> <br><p>  atau bahkan: </p><br><pre> <code class="php hljs">$return json_encode($name); <span class="hljs-comment"><span class="hljs-comment">// Ajax response</span></span></code> </pre> <br><p>  maka kita benar-benar mendefinisikan <code>View</code> yang ada di MVC, tanpa menyentuh <code>View</code> yang ada di framework! </p><br><p>  Tapi sekarang semuanya sangat sederhana: <code>View</code> , yang dalam kerangka - ini adalah bagian dari <code>View</code> , yang ada di MVC.  Selain itu, subset yang sangat sempit, yaitu, hanya mesin template yang didasarkan pada file PHP. </p><br><p>  Ringkasan: itu adalah <code></code> , mis.  dekorator gambar data apa pun adalah <code>View</code> yang ada di MVC.  Dan <code>View</code> , yang ada di dalam kerangka kerja, hanyalah semacam <code></code> . </p><br><h2 id="model-domena--model-predstavleniya-viewmodel--domainmodel">  Model Domain / Model Tampilan (ViewModel / DomainModel) </h2><br><p>  Sekarang lihat kelemahan kedua: </p><br><blockquote><ol><li>  Interpretasi sempit dari model-MVC <strong><em>hanya</em></strong> sebagai "Domain Model Domain" dan bukannya <em>"Setiap kompiler data untuk presentasi</em> . <em>"</em> </li></ol><br></blockquote><p>  Jelas bagi semua orang bahwa model MVC adalah hal yang kompleks yang terdiri dari bagian lain.  Komunitas setuju untuk menguraikan model menjadi dua komponen: model domain (DomainModel) dan model presentasi (ViewModel). </p><br><p>  Model domain adalah apa yang disimpan dalam basis data, mis.  data model dinormalisasi.  Ketik, 'nama depan' dan 'nama belakang' di berbagai bidang.  Kerangka kerja ditempati dengan bagian tertentu dari model hanya karena penyimpanan data adalah alam semesta sendiri, dipelajari dengan baik. </p><br><p>  Namun, aplikasi membutuhkan data agregat daripada normal.  Data domain harus dikompilasi menjadi gambar seperti: "Halo, Ivan!", Atau "Dear Ivan Petrov!", Atau bahkan "Untuk Ivan <strong>a</strong> Petrov <strong>a</strong> !".  Data yang dikonversi ini dirujuk ke model lain - model presentasi.  Jadi inilah bagian dari model yang masih diabaikan oleh kerangka kerja modern.  Itu diabaikan karena tidak ada kesepakatan tentang bagaimana menghadapinya.  Dan jika kerangka kerja tidak memberikan solusi, maka programmer pergi dengan cara paling sederhana - mereka membuang model tampilan ke dalam pengontrol.  Dan mereka mendapatkan Pengontrol Lemak yang dibenci tetapi tak terhindarkan! </p><br><p>  Intinya: untuk mengimplementasikan MVC, Anda perlu menerapkan model tampilan.  Tidak ada pilihan lain.  Mengingat bahwa representasi dan datanya dapat berupa apa saja, kami menyatakan bahwa kami memiliki masalah. </p><br><h2 id="scenariy-protiv-tolstyh-kontrollerov">  Skenario vs. Pengontrol Lemak </h2><br><p>  Ada satu kelemahan terakhir dari kerangka kerja: </p><br><blockquote><ol><li>  Mereka memprovokasi penggunaan apa yang disebut <em>"Pengontrol Tebal" yang</em> mengandung semua logika pada saat yang sama: bisnis, presentasi dan interaksi.  Ini sepenuhnya menghancurkan tujuan utama MVC - pembagian tanggung jawab antara komponen triad. </li></ol><br></blockquote><p>  Di sini kita sampai pada dasar-dasar MVC.  Mari kita perjelas.  Jadi, MVC mengasumsikan distribusi tanggung jawab berikut antara komponen-komponen triad: </p><br><ul><li>  Pengontrol adalah <em>logika interaksi</em> , mis.  interaksi dengan dunia luar (permintaan - respons) dan internal (Model - Presentasi), </li><li>  Modelnya adalah <em>logika bisnis</em> , mis.  menghasilkan data untuk permintaan tertentu, </li><li>  Representasi adalah <em>logika representasi</em> , mis.  dekorasi data yang dihasilkan oleh Model. </li></ul><br><p>  Silakan.  Dua tingkat tanggung jawab terlihat jelas: </p><br><ul><li>  Tingkat organisasi adalah Pengendali, </li><li>  Tingkat eksekutif adalah Model dan Representasi. </li></ul><br><p>  Secara sederhana, Controller mengarahkan, Model, dan View bajak.  Ini jika dengan cara sederhana.  Dan jika tidak dengan cara yang sederhana, tetapi lebih khusus?  Bagaimana tepatnya pengendali mengarahkan?  Dan bagaimana tepatnya Model dan View membajak? </p><br><p>  Kontroler mengarahkan seperti ini: </p><br><ul><li>  Menerima permintaan dari aplikasi, </li><li>  Tentukan Model dan Tampilan mana yang akan digunakan untuk permintaan ini, </li><li>  Panggilan Model yang dipilih dan menerima data dari itu, </li><li>  Meminta Tampilan yang dipilih dengan data yang diterima dari Model, </li><li>  Mengembalikan data yang didekorasi oleh View kembali ke aplikasi. </li></ul><br><p>  Sesuatu seperti itu.  Hal penting dalam skema ini adalah Model dan Representasi berubah menjadi tautan dalam rantai eksekusi permintaan.  Selain itu, dengan tautan berurutan: pertama, Model mengubah permintaan menjadi beberapa data, kemudian data Model ini dikonversi oleh View menjadi jawaban yang didekorasi sesuai kebutuhan untuk permintaan tertentu.  Seperti, permintaan humanoid didekorasi secara visual dengan templatizator, permintaan android didekorasi dengan enkoder JSON. </p><br><p>  Sekarang mari kita coba mencari tahu bagaimana tepatnya para pemain membajak - Model dan Presentasi.  Kami mengatakan di atas bahwa ada konsensus tentang dekomposisi Model menjadi dua sub-komponen: Model Domain dan Model Presentasi.  Ini berarti bahwa mungkin ada lebih banyak pemain - bukan dua, tetapi tiga.  Alih-alih rantai eksekusi </p><br><blockquote>  <code></code> &gt;&gt; <code></code> </blockquote><p>  mungkin ada rantai </p><br><blockquote>  <code> </code> <code> </code> &gt;&gt; <code></code> <code> </code> &gt;&gt; <code></code> </blockquote><p>  Pertanyaan itu muncul dengan sendirinya: mengapa hanya dua atau tiga?  Dan jika Anda membutuhkan lebih banyak?  Jawaban alami adalah, demi Tuhan, ambil sebanyak yang Anda butuhkan! </p><br><p>  Artis bermanfaat lainnya langsung terlihat: validator, redirectors, berbagai renderer, dan secara umum segala sesuatu yang tidak dapat diprediksi, tetapi menyenangkan. </p><br><p>  Mari kita rekap: </p><br><blockquote><ul><li>  Level eksekutif MVC ( <code></code> - <code></code> ) dapat diimplementasikan sebagai rantai tautan, di mana setiap tautan mengubah output dari tautan sebelumnya ke input untuk selanjutnya. </li><li>  Input dari tautan pertama adalah permintaan aplikasi. </li><li>  Output dari tautan terakhir adalah respons aplikasi terhadap permintaan. </li></ul><br></blockquote><p>  Saya menyebut <code>Scenario</code> rantai ini, tetapi untuk tautan rantai saya belum memutuskan nama.  Opsi saat ini adalah adegan (sebagai bagian dari skrip), filter (sebagai konverter data), aksi skrip.  Secara umum, nama tautannya tidak begitu penting, ada hal yang lebih penting. </p><br><p>  Konsekuensi dari kemunculan Skenario adalah signifikan.  Yaitu: Skenario memikul tanggung jawab utama Pengendali - untuk menentukan Model dan Presentasi yang diperlukan untuk permintaan dan untuk meluncurkannya.  Dengan demikian, pengontrol hanya memiliki dua tanggung jawab: berinteraksi dengan dunia luar (permintaan-respons) dan menjalankan skrip.  Dan ini bagus dalam arti bahwa semua komponen triad MVC secara berurutan terurai dan menjadi lebih spesifik dan mudah dikelola.  Dan masih bagus dalam hal lain - pengontrol MVCS menjadi kelas abadi internal murni, dan karena itu, bahkan pada prinsipnya, tidak bisa menjadi gemuk. </p><br><p>  Menggunakan Skenario mengarah ke variasi lain dari pola MVC; Saya menyebut variasi ini <strong><code>MVCS</code></strong> - <code>Model-View-Controller-Scenario</code> . </p><br><p>  Dan beberapa baris lagi tentang dekomposisi MVC.  Kerangka kerja modern, di mana semua fungsi khas diuraikan hingga batasnya, secara alami diambil dari bagian MVC konseptual dari tanggung jawab untuk berinteraksi dengan dunia luar.  Jadi, kelas terlatih khusus seperti <code>HTTP </code> dan <code></code> terlibat dalam pemrosesan permintaan pengguna.  Akibatnya, Pengendali tidak menerima permintaan pengguna awal, tetapi beberapa <code></code> disempurnakan, dan ini memungkinkan mengisolasi pengontrol dari spesifikasi permintaan tertentu.  Demikian pula, isolasi dari spesifik respons HTTP dibuat, memungkinkan modul MVC untuk menentukan jenis responsnya sendiri.  Selain itu, kerangka kerja sepenuhnya mengimplementasikan dua komponen MVC - Model Domain dan Template Presentasi, namun, kami sudah membahas hal ini.  Saya semua ini dengan fakta bahwa penyempurnaan dan konkretisasi MVC sedang berlangsung dan berkelanjutan, dan ini ramai. </p><br><h2 id="primer-ispolzovaniya-mvcs">  Contoh MVCS </h2><br><p>  Sekarang mari kita lihat bagaimana contoh <em>Fat Cortroller</em> di awal artikel ini dapat diimplementasikan dalam MVCS. </p><br><p>  Kami mulai dengan membuat pengontrol MVCS: </p><br><pre> <code class="php hljs">$mvcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MvcsController();</code> </pre> <br><p>  Pengontrol MVCS menerima permintaan dari router eksternal.  Biarkan router mengonversi URI dari formulir 'user / hello / XXX' menjadi parameter tindakan dan permintaan seperti itu: </p><br><pre> <code class="php hljs">$requestAction = <span class="hljs-string"><span class="hljs-string">'user/hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   $requestParams = ['XXX']; //   -  </span></span></code> </pre> <br><p>  Mempertimbangkan bahwa pengontrol MVCS menerima skrip daripada URI, kita perlu memetakan beberapa skrip untuk tindakan permintaan.  Ini paling baik dilakukan dalam wadah MVCS: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   MVCS  URI  $mvcs-&gt;set('scenarios', [ 'user/hello' =&gt; 'UserModel &gt; UserViewModel &gt; view, hello', ..., ]);</span></span></code> </pre> <br><p>  Mari kita lihat lebih dekat skenario ini.  Ini adalah rangkaian tiga konverter data yang dipisahkan oleh '&gt;': </p><br><ul><li>  'UserModel' adalah nama model domain 'Pengguna', input dari model akan menjadi parameter permintaan, output akan menjadi data aktual dari model, </li><li>  'UserViewModel' adalah nama Model Tampilan yang mengubah data domain menjadi data tampilan, </li><li>  'view, hello' adalah tampilan sistem 'templat' untuk templat PHP yang disebut 'hello'. </li></ul><br><p>  Sekarang kita hanya perlu menambahkan dua transformer yang terlibat dalam skrip sebagai fungsi penutupan ke wadah MVCS: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   UserModel $mvcs-&gt;set('UserModel', function($id) { $users = [ 1 =&gt; ['first' =&gt; '', 'last' =&gt; ''], 2 =&gt; ['first' =&gt; '', 'last' =&gt; ''], ]; return isset($users[$id]) ? $users[$id] : NULL; }); //   UserViewModel $mvcs-&gt;set('UserViewModel', function($user) { //    PHP  : 'echo "Hello, $name!"'; return ['name' =&gt; $user['first'].' '.$user['last']]; });</span></span></code> </pre> <br><p>  Dan itu saja!  Untuk setiap permintaan, perlu untuk menentukan skrip yang sesuai dan semua adegannya (kecuali yang sistem, seperti 'tampilan').  Dan tidak lebih. </p><br><p>  Dan sekarang kami siap menguji MVCS untuk berbagai permintaan: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//        $scenarios = $mvcs-&gt;get('scenarios'); $scenario = $scenarios[$requestAction]; //      ... //   'user/hello/1'  ' '   'hello' $requestParams = ['1']; $response = $mvcs-&gt;play($scenario, $requestParams); //   'user/hello/2'  ' '   'hello' $requestParams = ['2']; $response = $mvcs-&gt;play($scenario, $requestParams);</span></span></code> </pre> <br><blockquote>  <em>Implementasi PHP MVCS di-host di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com</a> .</em> <br>  <em>Contoh ini ada dalam direktori <code>example</code> MVCS.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424595/">https://habr.com/ru/post/id424595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424585/index.html">CryEngine 5.5 dirilis oleh Crytek</a></li>
<li><a href="../id424587/index.html">Ringkasan buku "Penjualan ke perusahaan besar"</a></li>
<li><a href="../id424589/index.html">Bagaimana cara mendaftar dalam program pembelajaran mesin PhD</a></li>
<li><a href="../id424591/index.html">Tidak ada yang ideal: bagaimana saya mencari bahasa pemrograman untuk diri saya sendiri</a></li>
<li><a href="../id424593/index.html">C ++ 11 dan penanganan acara</a></li>
<li><a href="../id424597/index.html">Wawancara dengan Pembicara Konferensi Ruby Rusia Marcus Schirp</a></li>
<li><a href="../id424599/index.html">Anda harus memilih perangkat lunak mana yang Anda butuhkan: ditulis tepat waktu atau berkualitas tinggi</a></li>
<li><a href="../id424601/index.html">Arsitektur informasi di Internet bagian 1</a></li>
<li><a href="../id424603/index.html">Buku “Mengapa kita salah? Berpikir Perangkap dalam Tindakan. " Kutipan Bagian 1</a></li>
<li><a href="../id424605/index.html">Dana Zuckerberg: Kolaborasi + Teknologi + Open Science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>