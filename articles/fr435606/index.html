<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔬 🤣 🛸 Comment écrire des tests unitaires pour les acteurs? Approche SObjectizer 👩🏻‍🤝‍👨🏽 💇🏿 👏🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les acteurs simplifient la programmation multithread en évitant un état mutable partagé et partagé. Chaque acteur possède ses propres données qui ne s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment écrire des tests unitaires pour les acteurs? Approche SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435606/">  Les acteurs simplifient la programmation multithread en évitant un état mutable partagé et partagé.  Chaque acteur possède ses propres données qui ne sont visibles par personne.  Les acteurs n'interagissent que par le biais de messages asynchrones.  Par conséquent, les horreurs les plus terrifiantes du multithreading sous forme de races et de blocages lors de l'utilisation d'acteurs ne sont pas effrayantes (bien que les acteurs aient leurs problèmes, mais ce n'est plus le cas maintenant). <br><br>  En général, l'écriture d'applications multi-thread à l'aide d'acteurs est facile et agréable.  Y compris parce que les acteurs eux-mêmes s'écrivent facilement et naturellement.  Vous pourriez même dire que l'écriture de code d'acteur est la partie la plus simple du travail.  Mais quand l'acteur est écrit, une très bonne question se pose: "Comment vérifier l'exactitude de son travail?" <br><br>  La question est vraiment très bonne.  On nous demande régulièrement quand on parle d'acteurs en général et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> en particulier.  Et jusqu'à récemment, nous ne pouvions répondre à cette question qu'en termes généraux. <br><br>  Mais la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version 5.5.24 a été publiée</a> , dans laquelle il y avait un support expérimental pour la possibilité de tests unitaires des acteurs.  Et dans cet article, nous allons essayer de parler de ce que c'est, comment l'utiliser et avec quoi il a été implémenté. <br><a name="habracut"></a><br><h1>  À quoi ressemblent les tests d'acteurs? </h1><br>  Nous considérerons les nouvelles fonctionnalités de SObjectizer sur quelques exemples, en passant ce qui est quoi.  Le code source des exemples discutés se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans ce référentiel</a> . <br><br>  Tout au long de l'histoire, les termes "acteur" et "agent" seront utilisés de manière interchangeable.  Ils désignent la même chose, mais dans le SObjectizer, le terme «agent» est historiquement utilisé, par conséquent, le terme «agent» sera utilisé plus souvent. <br><br><h2>  L'exemple le plus simple avec Pinger et Ponger </h2><br>  L'exemple des acteurs Pinger et Ponger est probablement l'exemple le plus courant pour les frameworks d'acteurs.  On peut dire un classique.  Eh bien, si c'est le cas, commençons par les classiques. <br><br>  Nous avons donc un agent Pinger qui, au début de son travail, envoie un message Ping à l'agent Ponger.  Et l'agent Ponger renvoie un message Pong.  Voici à quoi cela ressemble dans le code C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br>  Notre tâche consiste à écrire un test qui vérifierait qu'en enregistrant ces agents avec SObjectizer, Ponger recevra un message Ping et Pinger recevra un message Pong en réponse. <br><br>  Ok  Nous écrivons un tel test en utilisant le framework de test unitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doctest</a> et obtenons: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br>  Cela semble facile.  Voyons ce qui se passe ici. <br><br>  Tout d'abord, nous téléchargeons les descriptions des outils de support des tests d'agent: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br>  Tous ces outils sont décrits dans l'espace de noms so_5 :: experimental :: testing, mais afin de ne pas répéter un nom aussi long, nous introduisons un alias plus court et plus pratique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br>  Ce qui suit est une description d'un cas de test unique (et nous n'en avons pas besoin ici). <br><br>  À l'intérieur du scénario de test, il y a plusieurs points clés. <br><br>  Tout d'abord, il s'agit de la création et du lancement d'un environnement de test spécial pour SObjectizer: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br>  Sans cet environnement, le «test run» pour les agents ne peut pas être terminé, mais nous en parlerons un peu plus tard. <br><br>  La classe testing_env_t est très similaire à la classe wrapped_env_t dans SObjectizer.  De la même manière, le SObjectizer démarre dans le constructeur et s'arrête dans le destructeur.  Ainsi, lors de l'écriture de tests, vous n'avez pas à penser à démarrer et arrêter SObjectizer. <br><br>  Ensuite, nous devons créer et enregistrer des agents Pinger et Ponger.  Dans ce cas, nous devons utiliser ces agents pour déterminer ce que l'on appelle.  "Scénario de test."  Par conséquent, nous stockons séparément les pointeurs vers les agents: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  Et puis nous commençons à travailler avec le «scénario de test». <br><br>  Un scénario de test est une pièce constituée d'une séquence directe d'étapes qui doivent être exécutées du début à la fin.  L'expression «à partir d'une séquence directe» signifie que dans SObjectizer-5.5.24, les actions de script «fonctionnent» strictement séquentiellement, sans branchement ni boucle. <br><br>  L'écriture d'un test pour les agents est la définition d'un script de test qui doit être exécuté.  C'est-à-dire  toutes les étapes du scénario de test doivent fonctionner, de la première à la dernière. <br><br>  Par conséquent, dans notre scénario de test, nous définissons un scénario en deux étapes.  La première étape vérifie que l'agent Ponger recevra et traitera le message Ping: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br>  La deuxième étape vérifie que l'agent Pinger reçoit un message Pong: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br>  Ces deux étapes sont tout à fait suffisantes pour notre cas de test, donc, après leur détermination, nous procédons à l'exécution du script.  Nous exécutons le script et lui permettons de ne pas fonctionner plus de 100 ms: <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br>  Une centaine de millisecondes devrait être plus que suffisante pour que les deux agents échangent des messages (même si le test est exécuté à l'intérieur d'une machine virtuelle très lente, comme c'est parfois le cas avec Travis CI).  Eh bien, si nous avons fait une erreur en écrivant des agents ou décrit de manière incorrecte un script de test, alors attendre la fin d'un script erroné pendant plus de 100 ms n'a aucun sens. <br><br>  Ainsi, après son retour de run_for (), notre script peut être terminé avec succès ou non.  Par conséquent, nous vérifions simplement le résultat du script: <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br>  Si le script ne s'est pas terminé correctement, cela entraînera l'échec de notre scénario de test. <br><br><h3>  Quelques clarifications et ajouts </h3><br>  Si nous exécutons ce code dans un SObjectizer normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  puis, très probablement, les agents Pinger et Ponger parviendraient à échanger des messages et à terminer leur travail avant de revenir d'introd_coop (les miracles du multithreading sont tels).  Mais dans l'environnement de test, créé grâce à testing_env_t, cela ne se produit pas, les agents Pinger et Ponger attendent patiemment que nous exécutions notre script de test.  Comment cela se produit-il? <br><br>  Le fait est qu'à l'intérieur de l'environnement de test, les agents semblent être dans un état gelé.  C'est-à-dire  après l'enregistrement, ils sont présents dans SObjectizer, mais ils ne peuvent traiter aucun de leurs messages.  Par conséquent, même so_evt_start () n'est pas appelé pour les agents avant l'exécution du script de test. <br><br>  Lorsque nous exécutons le script de test à l'aide de la méthode run_for (), le script de test décongèle d'abord tous les agents gelés.  Et puis le script commence à recevoir des notifications du SObjectizer sur ce qui arrive aux agents.  Par exemple, que l'agent Ponger a reçu le message Ping et que l'agent Ponger a traité le message, mais ne l'a pas rejeté. <br><br>  Lorsque de telles notifications commencent à arriver au script de test, le script essaie de les «essayer» jusqu'à la toute première étape.  Donc, nous avons une notification que Ponger a reçu et traité Ping - est-ce intéressant pour nous ou non?  Il s'avère que c'est intéressant, car la description de l'étape dit exactement cela: cela fonctionne lorsque Ponger réagit à Ping.  Ce que nous voyons dans le code: <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br>  Ok  Donc, la première étape a fonctionné, passez à l'étape suivante. <br><br>  Vient ensuite une notification que l'agent Pinger a réagi à Pong.  Et c'est exactement ce dont vous avez besoin pour que la deuxième étape fonctionne: <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br>  Ok  Donc, la deuxième étape a fonctionné, avons-nous autre chose?  Non.  Cela signifie que l'intégralité du script de test est terminée et que vous pouvez retourner le contrôle à partir de run_for (). <br><br>  Voici, en principe, comment fonctionne le script de test.  En fait, tout est un peu plus compliqué, mais nous aborderons des aspects plus complexes lorsque nous considérerons un exemple plus complexe. <br><br><h2>  Exemples de philosophes de la restauration </h2><br>  Des exemples plus complexes d'agents de test peuvent être vus en résolvant la tâche bien connue "Les philosophes du dîner".  Sur les acteurs, ce problème peut être résolu de plusieurs manières.  Ensuite, nous considérerons la solution la plus triviale: les acteurs et les philosophes sont représentés sous la forme d'acteurs, pour lesquels les philosophes doivent se battre.  Chaque philosophe réfléchit un moment, puis essaie de prendre la fourchette à gauche.  Si cela réussit, il essaie de prendre la fourche à droite.  Si cela réussit, le philosophe mange pendant un certain temps, après quoi il pose les fourchettes et commence à réfléchir.  S'il n'était pas possible de prendre la fiche à droite (c'est-à-dire qu'elle a été prise par un autre philosophe), alors le philosophe renvoie la fiche à gauche et réfléchit encore un peu.  C'est-à-dire  ce n'est pas une bonne solution dans le sens où un philosophe peut mourir de faim trop longtemps.  Mais alors c'est très simple.  Et a la capacité de démontrer la capacité de tester des agents. <br><br>  Les codes sources avec l'implémentation des agents Fork et Philosopher peuvent être trouvés <a href="">ici</a> , dans l'article, nous ne les considérerons pas pour économiser de l'espace. <br><br><h3>  Test pour Fork </h3><br>  Le premier test pour les agents des philosophes de la restauration sera pour l'agent Fork. <br><br>  Cet agent fonctionne selon un schéma simple.  Il a deux états: libre et pris.  Lorsque l'agent est à l'état Libre, il répond à un message Take.  Dans ce cas, l'agent entre dans l'état Pris et répond avec un message de réponse Pris. <br><br>  Lorsque l'agent est à l'état Pris, il répond différemment au message Take: l'état de l'agent ne change pas et Occupé est envoyé comme message de réponse.  Toujours à l'état Pris, l'agent répond au message Put: l'agent revient à l'état Libre. <br><br>  Dans l'état Libre, le message Put est ignoré. <br><br>  Nous allons essayer de tester celui-ci au moyen du cas de test suivant: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br>  Il y a beaucoup de code, nous allons donc le traiter par parties, en ignorant les fragments qui devraient déjà être clairs. <br><br>  La première chose dont nous avons besoin ici est de remplacer le véritable agent philosophe.  Un agent Fork doit recevoir des messages de quelqu'un et répondre à quelqu'un.  Mais nous ne pouvons pas utiliser le vrai philosophe dans ce cas de test, car le véritable agent philosophe a sa propre logique de comportement, il envoie lui-même des messages et cette indépendance va nous interférer ici. <br><br>  Par conséquent, nous nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moquons</a> , c'est-à-dire  au lieu du vrai philosophe, nous allons lui en substituer un: un agent vide qui n'envoie rien lui-même, mais ne reçoit que les messages envoyés, sans aucun traitement utile.  Voici le pseudo-philosophe implémenté dans le code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br>  Ensuite, nous créons une collaboration entre l'agent Fork et l'agent PseudoPhilospher et commençons à déterminer le contenu de notre cas de test. <br><br>  La première étape du script consiste à vérifier que Fork, étant à l'état Libre (et c'est son état initial), ne répond pas au message Put.  Voici comment ce chèque est écrit: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br>  La première chose qui attire l'attention est la construction d'impact. <br><br>  Elle est nécessaire car notre agent Fork ne fait rien lui-même, il ne réagit qu'aux messages entrants.  Par conséquent, quelqu'un doit envoyer un message à l'agent.  Mais qui? <br><br>  Mais l'action de script elle-même envoie un impact.  En fait, l'impact est un analogue de la fonction d'envoi habituelle (et le format est le même). <br><br>  Eh bien, l'action de script elle-même enverra un message via l'impact.  Mais quand le fera-t-il? <br><br>  Et il le fera quand le tour viendra à lui.  C'est-à-dire  si l'étape du script est la première, l'impact sera exécuté immédiatement après avoir entré run_for.  Si l'étape du script n'est pas la première, l'impact sera exécuté dès que l'étape précédente aura fonctionné et le script passera à l'étape suivante. <br><br>  La deuxième chose dont nous devons discuter ici est l'appel ignore.  Cette fonction d'assistance indique que l'étape est déclenchée lorsque l'agent ne parvient pas à traiter le message.  C'est-à-dire  dans ce cas, l'agent Fork doit refuser de traiter le message Put. <br><br>  Examinons plus en détail une étape du scénario de test: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br>  Tout d'abord, nous voyons ici quand_all au lieu de quand.  En effet, pour déclencher une étape, nous devons remplir plusieurs conditions à la fois.  L'agent fork doit gérer Take.  Et Philosophe doit gérer la réponse prise.  Par conséquent, nous écrivons quand_all, pas quand.  Soit dit en passant, il y a aussi quand_any, mais nous ne le rencontrerons pas dans les exemples examinés aujourd'hui. <br><br>  Deuxièmement, nous devons également vérifier le fait qu'après le traitement Take, l'agent Fork sera dans l'état Taken.  Nous effectuons la vérification comme suit: nous indiquons d'abord que dès que l'agent Fork a fini de traiter Take, le nom de son état actuel doit être enregistré à l'aide de la balise tag «fork».  Cette construction préserve simplement le nom d'état de l'agent: <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br>  Et puis, lorsque le script est terminé avec succès, nous vérifions ce nom enregistré: <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br>  C'est-à-dire  nous demandons au script: donnez-nous le nom qui a été enregistré avec la balise fork pour l'étape nommée take_when_free, puis comparez le nom avec la valeur attendue. <br><br>  Voici peut-être tout ce qui pourrait être noté dans le cas de test pour l'agent Fork.  Si les lecteurs ont des questions, posez-les dans les commentaires, nous y répondrons avec plaisir. <br><br><h3>  Test de script réussi pour le philosophe </h3><br>  Pour l'agent Philosophe, nous ne considérerons qu'un seul cas de test - pour le cas où Philosophe peut prendre les deux fourchettes et manger. <br><br>  Ce cas de test ressemblera à ceci: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br>  Assez volumineux, mais trivial.  Tout d'abord, vérifiez que le philosophe a fini de penser et a commencé à se préparer à manger.  Puis on vérifie qu'il a essayé de prendre la fourche gauche.  Ensuite, il devrait essayer de prendre la bonne fourche.  Ensuite, il devrait manger et arrêter cette activité.  Ensuite, il doit mettre les deux fourches prises. <br><br>  En général, tout est simple.  Mais vous devez vous concentrer sur deux choses. <br><br>  Tout d'abord, la classe testing_env_t, comme son prototype, wrapped_env_t, vous permet de personnaliser l'environnement SObjectizer.  Nous allons l'utiliser pour activer le mécanisme de suivi de la remise des messages: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br>  Ce mécanisme vous permet de «visualiser» le processus de livraison des messages, ce qui aide à enquêter sur le comportement des agents (nous en avons déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlé plus en détail</a> ). <br><br>  Deuxièmement, l'agent Philosophe effectue une série d'actions non pas immédiatement, mais après un certain temps.  Ainsi, en commençant à fonctionner, l'agent doit s'envoyer un message StopThinking en attente.  Ce message devrait donc arriver à l'agent après quelques millisecondes.  Ce que nous indiquons en fixant la restriction nécessaire pour une certaine étape: <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br>  C'est-à-dire  ici, nous disons que nous ne sommes intéressés par aucune réaction de l'agent philosophe à StopThinking, mais seulement celle qui s'est produite au plus tôt 250 ms après le début du traitement de cette étape. <br><br>  Une restriction du type not_before indique au script que tous les événements qui se produisent avant l'expiration du délai spécifié doivent être ignorés. <br><br>  Il existe également une restriction de la forme not_after, cela fonctionne dans l'autre sens: seuls les événements qui se produisent jusqu'à l'expiration du délai spécifié sont pris en compte. <br><br>  Les contraintes not_before et not_after peuvent être combinées, par exemple: <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br>  mais dans ce cas, SObjectizer ne vérifie pas la cohérence des valeurs données. <br><br><h1>  Comment avez-vous réussi à mettre en œuvre cela? </h1><br>  Je voudrais dire quelques mots sur la façon dont tout cela a fonctionné.  Après tout, dans l’ensemble, nous étions confrontés à une grande question idéologique: «Comment tester les agents en principe?»  et une question plus petite, déjà technique: "Comment mettre en œuvre cela?" <br><br>  Et si à propos de l'idéologie des tests, il était possible de sortir de votre esprit, alors à propos de la mise en œuvre, la situation était plus compliquée.  Il était nécessaire de trouver une solution qui, tout d'abord, ne nécessiterait pas une modification radicale des intérieurs de SObjectizer.  Et, deuxièmement, il était censé être une solution qui pourrait être mise en œuvre dans les délais prévisibles et très souhaitables. <br><br>  À la suite du difficile processus de fumage du bambou, une solution a été trouvée.  Pour cela, il fallait, en effet, n'apporter qu'une seule petite innovation dans le comportement régulier de SObjectizer.  Et la base de la solution est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mécanisme d'enveloppe de message, qui a été ajouté dans la version 5.5.23 et dont nous avons déjà parlé</a> . <br><br>  À l'intérieur de l'environnement de test, chaque message envoyé est enveloppé dans une enveloppe spéciale.  Lorsqu'une enveloppe contenant un message est remise à l'agent pour traitement (ou, au contraire, rejetée par l'agent), le scénario de test s'en rend compte.  Grâce aux enveloppes, le script de test sait ce qui se passe et peut déterminer les moments où les étapes de script «fonctionnent». <br><br>  Mais comment faire en sorte que SObjectizer enveloppe chaque message dans une enveloppe spéciale? <br><br>  C'était une question intéressante.  Il a décidé comme suit: un concept tel que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">event_queue_hook a</a> été inventé.  Il s'agit d'un objet spécial avec deux méthodes - on_bind et on_unbind. <br><br>  Lorsqu'un agent est lié à un répartiteur spécifique, le répartiteur envoie une file d'attente d'événements à l'agent.  Grâce à cette file d'attente d'événements, les demandes de l'agent entrent dans la file d'attente nécessaire et deviennent disponibles pour le répartiteur pour traitement.  Lorsqu'un agent s'exécute dans un SObjectizer, il a un pointeur sur event_queue.  Lorsqu'un agent est supprimé d'un SObjectizer, son pointeur sur event_queue est annulé. <br><br>  Ainsi, à partir de la version 5.5.24, l'agent, à la réception de event_queue, doit appeler la méthode on_bind de event_queue_hook.  Où l'agent doit passer le pointeur reçu à event_queue.  Et event_queue_hook peut renvoyer le même pointeur ou un autre pointeur en réponse.  Et l'agent doit utiliser la valeur retournée. <br><br>  Lorsqu'un agent est supprimé d'un SObjectizer, il doit appeler on_unbind sur event_queue_hook.  Dans on_unbind, l'agent transmet la valeur renvoyée par la méthode on_bind. <br><br>  Toute cette cuisine est exécutée à l'intérieur du SObjectizer et l'utilisateur ne voit rien de tout cela.  Et, en principe, vous ne le savez peut-être pas du tout.  Mais l'environnement de test de SObjectizer, le même testing_env_t, exploite exactement event_queue_hook.  Dans testing_env_t, une implémentation spéciale de event_queue_hook est créée.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette implémentation dans on_bind enveloppe chaque event_queue dans un objet proxy spécial. </font><font style="vertical-align: inherit;">Et déjà cet objet proxy place les messages envoyés à l'agent dans une enveloppe spéciale.</font></font><br><br>  Mais ce n'est pas tout.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous vous souvenez peut-être que dans un environnement de test, les agents doivent être gelés. </font><font style="vertical-align: inherit;">Ceci est également implémenté via les objets proxy mentionnés. </font><font style="vertical-align: inherit;">Pendant que le script de test n'est pas en cours d'exécution, l'objet proxy stocke les messages envoyés à l'agent à domicile. </font><font style="vertical-align: inherit;">Mais lorsque le script est exécuté, l'objet proxy transfère tous les messages précédemment accumulés vers la file d'attente de messages actuelle de l'agent.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusion, je veux dire deux choses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous avons mis en œuvre notre point de vue sur la façon dont les agents peuvent être testés dans SObjectizer. Mon opinion parce qu'il n'y a pas tellement de bons modèles de rôle autour. Nous avons regardé vers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais Akka et SObjectizer sont </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trop différents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour porter les approches qui fonctionnent dans Akka vers SObjectizer. Et C ++ n'est pas Scala / Java, dans lequel certaines choses liées à l'introspection peuvent se faire par réflexion. J'ai donc dû trouver une approche qui tomberait sur SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la version 5.5.24, la toute première implémentation expérimentale est devenue disponible. Vous pouvez sûrement faire mieux. Mais comment comprendre ce qui sera utile et quels sont les fantasmes inutiles? Malheureusement, rien. Vous devez prendre et essayer, voir ce qui se passe dans la pratique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc fait une version minimale que vous pouvez prendre et essayer. Ce que nous proposons de faire pour tout le monde: essayez, expérimentez et partagez vos impressions avec nous. Qu'est-ce que tu as aimé, qu'est-ce que tu n'as pas aimé? Peut-être qu'il manque quelque chose? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, les mots prononcés </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">début 2017 sont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devenus encore plus pertinents </font><font style="vertical-align: inherit;">:</font></font><br><blockquote> …       ,   ,   ,    .      -      —      .             .      . :  ,   . <br><br>    ,  ,   ,       —    ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, mon conseil à ceux qui recherchent un cadre d'acteur prêt à l'emploi: faites attention non seulement à l'originalité des idées et à la beauté des exemples. </font><font style="vertical-align: inherit;">Regardez également toutes sortes de choses auxiliaires qui vous aideront à comprendre ce qui se passe dans votre application: par exemple, découvrez combien d'acteurs sont à l'intérieur maintenant, quelles sont leurs tailles de file d'attente, si le message n'atteint pas le destinataire, alors où va-t-il ... Si le cadre le fait fournit quelque chose comme ça, ce sera plus facile pour vous. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, vous aurez plus de travail.</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout ce qui précède est encore plus important pour tester les acteurs. </font><font style="vertical-align: inherit;">Par conséquent, lorsque vous choisissez un cadre d'acteur pour vous-même, faites attention à ce qu'il contient et à ce qui ne l'est pas. </font><font style="vertical-align: inherit;">Par exemple, nous avons déjà dans notre boîte à outils pour simplifier les tests :)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435606/">https://habr.com/ru/post/fr435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435592/index.html">Açores: dernière réserve de flore au milieu de l'océan Atlantique</a></li>
<li><a href="../fr435594/index.html">Graphique d'itinéraire pour Apache Camel</a></li>
<li><a href="../fr435600/index.html">Comment migrer vers un autre opérateur mobile et ne pas faire faillite (pour les propriétaires d'iOS)</a></li>
<li><a href="../fr435602/index.html">Préparation à l'examen Azure</a></li>
<li><a href="../fr435604/index.html">BlaBlaCar est devenu ce à quoi il n'était pas destiné</a></li>
<li><a href="../fr435608/index.html">Écrans de bricolage</a></li>
<li><a href="../fr435610/index.html">Oeufs de Pâques pour ZX Spectrum - dans l'album de musique et le film</a></li>
<li><a href="../fr435612/index.html">Faites confiance à Codd ou à vos installations?</a></li>
<li><a href="../fr435614/index.html">Rust News # 4 (décembre 2018)</a></li>
<li><a href="../fr435616/index.html">Comment Peer Zoning a simplifié nos vies et contribué à équilibrer la charge d'EMC VPLEX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>