<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüî¨ ü§£ üõ∏ Comment √©crire des tests unitaires pour les acteurs? Approche SObjectizer üë©üèª‚Äçü§ù‚Äçüë®üèΩ üíáüèø üëèüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les acteurs simplifient la programmation multithread en √©vitant un √©tat mutable partag√© et partag√©. Chaque acteur poss√®de ses propres donn√©es qui ne s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment √©crire des tests unitaires pour les acteurs? Approche SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435606/">  Les acteurs simplifient la programmation multithread en √©vitant un √©tat mutable partag√© et partag√©.  Chaque acteur poss√®de ses propres donn√©es qui ne sont visibles par personne.  Les acteurs n'interagissent que par le biais de messages asynchrones.  Par cons√©quent, les horreurs les plus terrifiantes du multithreading sous forme de races et de blocages lors de l'utilisation d'acteurs ne sont pas effrayantes (bien que les acteurs aient leurs probl√®mes, mais ce n'est plus le cas maintenant). <br><br>  En g√©n√©ral, l'√©criture d'applications multi-thread √† l'aide d'acteurs est facile et agr√©able.  Y compris parce que les acteurs eux-m√™mes s'√©crivent facilement et naturellement.  Vous pourriez m√™me dire que l'√©criture de code d'acteur est la partie la plus simple du travail.  Mais quand l'acteur est √©crit, une tr√®s bonne question se pose: "Comment v√©rifier l'exactitude de son travail?" <br><br>  La question est vraiment tr√®s bonne.  On nous demande r√©guli√®rement quand on parle d'acteurs en g√©n√©ral et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> en particulier.  Et jusqu'√† r√©cemment, nous ne pouvions r√©pondre √† cette question qu'en termes g√©n√©raux. <br><br>  Mais la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version 5.5.24 a √©t√© publi√©e</a> , dans laquelle il y avait un support exp√©rimental pour la possibilit√© de tests unitaires des acteurs.  Et dans cet article, nous allons essayer de parler de ce que c'est, comment l'utiliser et avec quoi il a √©t√© impl√©ment√©. <br><a name="habracut"></a><br><h1>  √Ä quoi ressemblent les tests d'acteurs? </h1><br>  Nous consid√©rerons les nouvelles fonctionnalit√©s de SObjectizer sur quelques exemples, en passant ce qui est quoi.  Le code source des exemples discut√©s se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans ce r√©f√©rentiel</a> . <br><br>  Tout au long de l'histoire, les termes "acteur" et "agent" seront utilis√©s de mani√®re interchangeable.  Ils d√©signent la m√™me chose, mais dans le SObjectizer, le terme ¬´agent¬ª est historiquement utilis√©, par cons√©quent, le terme ¬´agent¬ª sera utilis√© plus souvent. <br><br><h2>  L'exemple le plus simple avec Pinger et Ponger </h2><br>  L'exemple des acteurs Pinger et Ponger est probablement l'exemple le plus courant pour les frameworks d'acteurs.  On peut dire un classique.  Eh bien, si c'est le cas, commen√ßons par les classiques. <br><br>  Nous avons donc un agent Pinger qui, au d√©but de son travail, envoie un message Ping √† l'agent Ponger.  Et l'agent Ponger renvoie un message Pong.  Voici √† quoi cela ressemble dans le code C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br>  Notre t√¢che consiste √† √©crire un test qui v√©rifierait qu'en enregistrant ces agents avec SObjectizer, Ponger recevra un message Ping et Pinger recevra un message Pong en r√©ponse. <br><br>  Ok  Nous √©crivons un tel test en utilisant le framework de test unitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doctest</a> et obtenons: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br>  Cela semble facile.  Voyons ce qui se passe ici. <br><br>  Tout d'abord, nous t√©l√©chargeons les descriptions des outils de support des tests d'agent: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br>  Tous ces outils sont d√©crits dans l'espace de noms so_5 :: experimental :: testing, mais afin de ne pas r√©p√©ter un nom aussi long, nous introduisons un alias plus court et plus pratique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br>  Ce qui suit est une description d'un cas de test unique (et nous n'en avons pas besoin ici). <br><br>  √Ä l'int√©rieur du sc√©nario de test, il y a plusieurs points cl√©s. <br><br>  Tout d'abord, il s'agit de la cr√©ation et du lancement d'un environnement de test sp√©cial pour SObjectizer: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br>  Sans cet environnement, le ¬´test run¬ª pour les agents ne peut pas √™tre termin√©, mais nous en parlerons un peu plus tard. <br><br>  La classe testing_env_t est tr√®s similaire √† la classe wrapped_env_t dans SObjectizer.  De la m√™me mani√®re, le SObjectizer d√©marre dans le constructeur et s'arr√™te dans le destructeur.  Ainsi, lors de l'√©criture de tests, vous n'avez pas √† penser √† d√©marrer et arr√™ter SObjectizer. <br><br>  Ensuite, nous devons cr√©er et enregistrer des agents Pinger et Ponger.  Dans ce cas, nous devons utiliser ces agents pour d√©terminer ce que l'on appelle.  "Sc√©nario de test."  Par cons√©quent, nous stockons s√©par√©ment les pointeurs vers les agents: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  Et puis nous commen√ßons √† travailler avec le ¬´sc√©nario de test¬ª. <br><br>  Un sc√©nario de test est une pi√®ce constitu√©e d'une s√©quence directe d'√©tapes qui doivent √™tre ex√©cut√©es du d√©but √† la fin.  L'expression ¬´√† partir d'une s√©quence directe¬ª signifie que dans SObjectizer-5.5.24, les actions de script ¬´fonctionnent¬ª strictement s√©quentiellement, sans branchement ni boucle. <br><br>  L'√©criture d'un test pour les agents est la d√©finition d'un script de test qui doit √™tre ex√©cut√©.  C'est-√†-dire  toutes les √©tapes du sc√©nario de test doivent fonctionner, de la premi√®re √† la derni√®re. <br><br>  Par cons√©quent, dans notre sc√©nario de test, nous d√©finissons un sc√©nario en deux √©tapes.  La premi√®re √©tape v√©rifie que l'agent Ponger recevra et traitera le message Ping: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br>  La deuxi√®me √©tape v√©rifie que l'agent Pinger re√ßoit un message Pong: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br>  Ces deux √©tapes sont tout √† fait suffisantes pour notre cas de test, donc, apr√®s leur d√©termination, nous proc√©dons √† l'ex√©cution du script.  Nous ex√©cutons le script et lui permettons de ne pas fonctionner plus de 100 ms: <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br>  Une centaine de millisecondes devrait √™tre plus que suffisante pour que les deux agents √©changent des messages (m√™me si le test est ex√©cut√© √† l'int√©rieur d'une machine virtuelle tr√®s lente, comme c'est parfois le cas avec Travis CI).  Eh bien, si nous avons fait une erreur en √©crivant des agents ou d√©crit de mani√®re incorrecte un script de test, alors attendre la fin d'un script erron√© pendant plus de 100 ms n'a aucun sens. <br><br>  Ainsi, apr√®s son retour de run_for (), notre script peut √™tre termin√© avec succ√®s ou non.  Par cons√©quent, nous v√©rifions simplement le r√©sultat du script: <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br>  Si le script ne s'est pas termin√© correctement, cela entra√Ænera l'√©chec de notre sc√©nario de test. <br><br><h3>  Quelques clarifications et ajouts </h3><br>  Si nous ex√©cutons ce code dans un SObjectizer normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  puis, tr√®s probablement, les agents Pinger et Ponger parviendraient √† √©changer des messages et √† terminer leur travail avant de revenir d'introd_coop (les miracles du multithreading sont tels).  Mais dans l'environnement de test, cr√©√© gr√¢ce √† testing_env_t, cela ne se produit pas, les agents Pinger et Ponger attendent patiemment que nous ex√©cutions notre script de test.  Comment cela se produit-il? <br><br>  Le fait est qu'√† l'int√©rieur de l'environnement de test, les agents semblent √™tre dans un √©tat gel√©.  C'est-√†-dire  apr√®s l'enregistrement, ils sont pr√©sents dans SObjectizer, mais ils ne peuvent traiter aucun de leurs messages.  Par cons√©quent, m√™me so_evt_start () n'est pas appel√© pour les agents avant l'ex√©cution du script de test. <br><br>  Lorsque nous ex√©cutons le script de test √† l'aide de la m√©thode run_for (), le script de test d√©cong√®le d'abord tous les agents gel√©s.  Et puis le script commence √† recevoir des notifications du SObjectizer sur ce qui arrive aux agents.  Par exemple, que l'agent Ponger a re√ßu le message Ping et que l'agent Ponger a trait√© le message, mais ne l'a pas rejet√©. <br><br>  Lorsque de telles notifications commencent √† arriver au script de test, le script essaie de les ¬´essayer¬ª jusqu'√† la toute premi√®re √©tape.  Donc, nous avons une notification que Ponger a re√ßu et trait√© Ping - est-ce int√©ressant pour nous ou non?  Il s'av√®re que c'est int√©ressant, car la description de l'√©tape dit exactement cela: cela fonctionne lorsque Ponger r√©agit √† Ping.  Ce que nous voyons dans le code: <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br>  Ok  Donc, la premi√®re √©tape a fonctionn√©, passez √† l'√©tape suivante. <br><br>  Vient ensuite une notification que l'agent Pinger a r√©agi √† Pong.  Et c'est exactement ce dont vous avez besoin pour que la deuxi√®me √©tape fonctionne: <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br>  Ok  Donc, la deuxi√®me √©tape a fonctionn√©, avons-nous autre chose?  Non.  Cela signifie que l'int√©gralit√© du script de test est termin√©e et que vous pouvez retourner le contr√¥le √† partir de run_for (). <br><br>  Voici, en principe, comment fonctionne le script de test.  En fait, tout est un peu plus compliqu√©, mais nous aborderons des aspects plus complexes lorsque nous consid√©rerons un exemple plus complexe. <br><br><h2>  Exemples de philosophes de la restauration </h2><br>  Des exemples plus complexes d'agents de test peuvent √™tre vus en r√©solvant la t√¢che bien connue "Les philosophes du d√Æner".  Sur les acteurs, ce probl√®me peut √™tre r√©solu de plusieurs mani√®res.  Ensuite, nous consid√©rerons la solution la plus triviale: les acteurs et les philosophes sont repr√©sent√©s sous la forme d'acteurs, pour lesquels les philosophes doivent se battre.  Chaque philosophe r√©fl√©chit un moment, puis essaie de prendre la fourchette √† gauche.  Si cela r√©ussit, il essaie de prendre la fourche √† droite.  Si cela r√©ussit, le philosophe mange pendant un certain temps, apr√®s quoi il pose les fourchettes et commence √† r√©fl√©chir.  S'il n'√©tait pas possible de prendre la fiche √† droite (c'est-√†-dire qu'elle a √©t√© prise par un autre philosophe), alors le philosophe renvoie la fiche √† gauche et r√©fl√©chit encore un peu.  C'est-√†-dire  ce n'est pas une bonne solution dans le sens o√π un philosophe peut mourir de faim trop longtemps.  Mais alors c'est tr√®s simple.  Et a la capacit√© de d√©montrer la capacit√© de tester des agents. <br><br>  Les codes sources avec l'impl√©mentation des agents Fork et Philosopher peuvent √™tre trouv√©s <a href="">ici</a> , dans l'article, nous ne les consid√©rerons pas pour √©conomiser de l'espace. <br><br><h3>  Test pour Fork </h3><br>  Le premier test pour les agents des philosophes de la restauration sera pour l'agent Fork. <br><br>  Cet agent fonctionne selon un sch√©ma simple.  Il a deux √©tats: libre et pris.  Lorsque l'agent est √† l'√©tat Libre, il r√©pond √† un message Take.  Dans ce cas, l'agent entre dans l'√©tat Pris et r√©pond avec un message de r√©ponse Pris. <br><br>  Lorsque l'agent est √† l'√©tat Pris, il r√©pond diff√©remment au message Take: l'√©tat de l'agent ne change pas et Occup√© est envoy√© comme message de r√©ponse.  Toujours √† l'√©tat Pris, l'agent r√©pond au message Put: l'agent revient √† l'√©tat Libre. <br><br>  Dans l'√©tat Libre, le message Put est ignor√©. <br><br>  Nous allons essayer de tester celui-ci au moyen du cas de test suivant: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br>  Il y a beaucoup de code, nous allons donc le traiter par parties, en ignorant les fragments qui devraient d√©j√† √™tre clairs. <br><br>  La premi√®re chose dont nous avons besoin ici est de remplacer le v√©ritable agent philosophe.  Un agent Fork doit recevoir des messages de quelqu'un et r√©pondre √† quelqu'un.  Mais nous ne pouvons pas utiliser le vrai philosophe dans ce cas de test, car le v√©ritable agent philosophe a sa propre logique de comportement, il envoie lui-m√™me des messages et cette ind√©pendance va nous interf√©rer ici. <br><br>  Par cons√©quent, nous nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moquons</a> , c'est-√†-dire  au lieu du vrai philosophe, nous allons lui en substituer un: un agent vide qui n'envoie rien lui-m√™me, mais ne re√ßoit que les messages envoy√©s, sans aucun traitement utile.  Voici le pseudo-philosophe impl√©ment√© dans le code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br>  Ensuite, nous cr√©ons une collaboration entre l'agent Fork et l'agent PseudoPhilospher et commen√ßons √† d√©terminer le contenu de notre cas de test. <br><br>  La premi√®re √©tape du script consiste √† v√©rifier que Fork, √©tant √† l'√©tat Libre (et c'est son √©tat initial), ne r√©pond pas au message Put.  Voici comment ce ch√®que est √©crit: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br>  La premi√®re chose qui attire l'attention est la construction d'impact. <br><br>  Elle est n√©cessaire car notre agent Fork ne fait rien lui-m√™me, il ne r√©agit qu'aux messages entrants.  Par cons√©quent, quelqu'un doit envoyer un message √† l'agent.  Mais qui? <br><br>  Mais l'action de script elle-m√™me envoie un impact.  En fait, l'impact est un analogue de la fonction d'envoi habituelle (et le format est le m√™me). <br><br>  Eh bien, l'action de script elle-m√™me enverra un message via l'impact.  Mais quand le fera-t-il? <br><br>  Et il le fera quand le tour viendra √† lui.  C'est-√†-dire  si l'√©tape du script est la premi√®re, l'impact sera ex√©cut√© imm√©diatement apr√®s avoir entr√© run_for.  Si l'√©tape du script n'est pas la premi√®re, l'impact sera ex√©cut√© d√®s que l'√©tape pr√©c√©dente aura fonctionn√© et le script passera √† l'√©tape suivante. <br><br>  La deuxi√®me chose dont nous devons discuter ici est l'appel ignore.  Cette fonction d'assistance indique que l'√©tape est d√©clench√©e lorsque l'agent ne parvient pas √† traiter le message.  C'est-√†-dire  dans ce cas, l'agent Fork doit refuser de traiter le message Put. <br><br>  Examinons plus en d√©tail une √©tape du sc√©nario de test: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br>  Tout d'abord, nous voyons ici quand_all au lieu de quand.  En effet, pour d√©clencher une √©tape, nous devons remplir plusieurs conditions √† la fois.  L'agent fork doit g√©rer Take.  Et Philosophe doit g√©rer la r√©ponse prise.  Par cons√©quent, nous √©crivons quand_all, pas quand.  Soit dit en passant, il y a aussi quand_any, mais nous ne le rencontrerons pas dans les exemples examin√©s aujourd'hui. <br><br>  Deuxi√®mement, nous devons √©galement v√©rifier le fait qu'apr√®s le traitement Take, l'agent Fork sera dans l'√©tat Taken.  Nous effectuons la v√©rification comme suit: nous indiquons d'abord que d√®s que l'agent Fork a fini de traiter Take, le nom de son √©tat actuel doit √™tre enregistr√© √† l'aide de la balise tag ¬´fork¬ª.  Cette construction pr√©serve simplement le nom d'√©tat de l'agent: <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br>  Et puis, lorsque le script est termin√© avec succ√®s, nous v√©rifions ce nom enregistr√©: <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br>  C'est-√†-dire  nous demandons au script: donnez-nous le nom qui a √©t√© enregistr√© avec la balise fork pour l'√©tape nomm√©e take_when_free, puis comparez le nom avec la valeur attendue. <br><br>  Voici peut-√™tre tout ce qui pourrait √™tre not√© dans le cas de test pour l'agent Fork.  Si les lecteurs ont des questions, posez-les dans les commentaires, nous y r√©pondrons avec plaisir. <br><br><h3>  Test de script r√©ussi pour le philosophe </h3><br>  Pour l'agent Philosophe, nous ne consid√©rerons qu'un seul cas de test - pour le cas o√π Philosophe peut prendre les deux fourchettes et manger. <br><br>  Ce cas de test ressemblera √† ceci: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br>  Assez volumineux, mais trivial.  Tout d'abord, v√©rifiez que le philosophe a fini de penser et a commenc√© √† se pr√©parer √† manger.  Puis on v√©rifie qu'il a essay√© de prendre la fourche gauche.  Ensuite, il devrait essayer de prendre la bonne fourche.  Ensuite, il devrait manger et arr√™ter cette activit√©.  Ensuite, il doit mettre les deux fourches prises. <br><br>  En g√©n√©ral, tout est simple.  Mais vous devez vous concentrer sur deux choses. <br><br>  Tout d'abord, la classe testing_env_t, comme son prototype, wrapped_env_t, vous permet de personnaliser l'environnement SObjectizer.  Nous allons l'utiliser pour activer le m√©canisme de suivi de la remise des messages: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br>  Ce m√©canisme vous permet de ¬´visualiser¬ª le processus de livraison des messages, ce qui aide √† enqu√™ter sur le comportement des agents (nous en avons d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parl√© plus en d√©tail</a> ). <br><br>  Deuxi√®mement, l'agent Philosophe effectue une s√©rie d'actions non pas imm√©diatement, mais apr√®s un certain temps.  Ainsi, en commen√ßant √† fonctionner, l'agent doit s'envoyer un message StopThinking en attente.  Ce message devrait donc arriver √† l'agent apr√®s quelques millisecondes.  Ce que nous indiquons en fixant la restriction n√©cessaire pour une certaine √©tape: <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br>  C'est-√†-dire  ici, nous disons que nous ne sommes int√©ress√©s par aucune r√©action de l'agent philosophe √† StopThinking, mais seulement celle qui s'est produite au plus t√¥t 250 ms apr√®s le d√©but du traitement de cette √©tape. <br><br>  Une restriction du type not_before indique au script que tous les √©v√©nements qui se produisent avant l'expiration du d√©lai sp√©cifi√© doivent √™tre ignor√©s. <br><br>  Il existe √©galement une restriction de la forme not_after, cela fonctionne dans l'autre sens: seuls les √©v√©nements qui se produisent jusqu'√† l'expiration du d√©lai sp√©cifi√© sont pris en compte. <br><br>  Les contraintes not_before et not_after peuvent √™tre combin√©es, par exemple: <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br>  mais dans ce cas, SObjectizer ne v√©rifie pas la coh√©rence des valeurs donn√©es. <br><br><h1>  Comment avez-vous r√©ussi √† mettre en ≈ìuvre cela? </h1><br>  Je voudrais dire quelques mots sur la fa√ßon dont tout cela a fonctionn√©.  Apr√®s tout, dans l‚Äôensemble, nous √©tions confront√©s √† une grande question id√©ologique: ¬´Comment tester les agents en principe?¬ª  et une question plus petite, d√©j√† technique: "Comment mettre en ≈ìuvre cela?" <br><br>  Et si √† propos de l'id√©ologie des tests, il √©tait possible de sortir de votre esprit, alors √† propos de la mise en ≈ìuvre, la situation √©tait plus compliqu√©e.  Il √©tait n√©cessaire de trouver une solution qui, tout d'abord, ne n√©cessiterait pas une modification radicale des int√©rieurs de SObjectizer.  Et, deuxi√®mement, il √©tait cens√© √™tre une solution qui pourrait √™tre mise en ≈ìuvre dans les d√©lais pr√©visibles et tr√®s souhaitables. <br><br>  √Ä la suite du difficile processus de fumage du bambou, une solution a √©t√© trouv√©e.  Pour cela, il fallait, en effet, n'apporter qu'une seule petite innovation dans le comportement r√©gulier de SObjectizer.  Et la base de la solution est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©canisme d'enveloppe de message, qui a √©t√© ajout√© dans la version 5.5.23 et dont nous avons d√©j√† parl√©</a> . <br><br>  √Ä l'int√©rieur de l'environnement de test, chaque message envoy√© est envelopp√© dans une enveloppe sp√©ciale.  Lorsqu'une enveloppe contenant un message est remise √† l'agent pour traitement (ou, au contraire, rejet√©e par l'agent), le sc√©nario de test s'en rend compte.  Gr√¢ce aux enveloppes, le script de test sait ce qui se passe et peut d√©terminer les moments o√π les √©tapes de script ¬´fonctionnent¬ª. <br><br>  Mais comment faire en sorte que SObjectizer enveloppe chaque message dans une enveloppe sp√©ciale? <br><br>  C'√©tait une question int√©ressante.  Il a d√©cid√© comme suit: un concept tel que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">event_queue_hook a</a> √©t√© invent√©.  Il s'agit d'un objet sp√©cial avec deux m√©thodes - on_bind et on_unbind. <br><br>  Lorsqu'un agent est li√© √† un r√©partiteur sp√©cifique, le r√©partiteur envoie une file d'attente d'√©v√©nements √† l'agent.  Gr√¢ce √† cette file d'attente d'√©v√©nements, les demandes de l'agent entrent dans la file d'attente n√©cessaire et deviennent disponibles pour le r√©partiteur pour traitement.  Lorsqu'un agent s'ex√©cute dans un SObjectizer, il a un pointeur sur event_queue.  Lorsqu'un agent est supprim√© d'un SObjectizer, son pointeur sur event_queue est annul√©. <br><br>  Ainsi, √† partir de la version 5.5.24, l'agent, √† la r√©ception de event_queue, doit appeler la m√©thode on_bind de event_queue_hook.  O√π l'agent doit passer le pointeur re√ßu √† event_queue.  Et event_queue_hook peut renvoyer le m√™me pointeur ou un autre pointeur en r√©ponse.  Et l'agent doit utiliser la valeur retourn√©e. <br><br>  Lorsqu'un agent est supprim√© d'un SObjectizer, il doit appeler on_unbind sur event_queue_hook.  Dans on_unbind, l'agent transmet la valeur renvoy√©e par la m√©thode on_bind. <br><br>  Toute cette cuisine est ex√©cut√©e √† l'int√©rieur du SObjectizer et l'utilisateur ne voit rien de tout cela.  Et, en principe, vous ne le savez peut-√™tre pas du tout.  Mais l'environnement de test de SObjectizer, le m√™me testing_env_t, exploite exactement event_queue_hook.  Dans testing_env_t, une impl√©mentation sp√©ciale de event_queue_hook est cr√©√©e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette impl√©mentation dans on_bind enveloppe chaque event_queue dans un objet proxy sp√©cial. </font><font style="vertical-align: inherit;">Et d√©j√† cet objet proxy place les messages envoy√©s √† l'agent dans une enveloppe sp√©ciale.</font></font><br><br>  Mais ce n'est pas tout.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous vous souvenez peut-√™tre que dans un environnement de test, les agents doivent √™tre gel√©s. </font><font style="vertical-align: inherit;">Ceci est √©galement impl√©ment√© via les objets proxy mentionn√©s. </font><font style="vertical-align: inherit;">Pendant que le script de test n'est pas en cours d'ex√©cution, l'objet proxy stocke les messages envoy√©s √† l'agent √† domicile. </font><font style="vertical-align: inherit;">Mais lorsque le script est ex√©cut√©, l'objet proxy transf√®re tous les messages pr√©c√©demment accumul√©s vers la file d'attente de messages actuelle de l'agent.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusion, je veux dire deux choses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous avons mis en ≈ìuvre notre point de vue sur la fa√ßon dont les agents peuvent √™tre test√©s dans SObjectizer. Mon opinion parce qu'il n'y a pas tellement de bons mod√®les de r√¥le autour. Nous avons regard√© vers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais Akka et SObjectizer sont </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trop diff√©rents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour porter les approches qui fonctionnent dans Akka vers SObjectizer. Et C ++ n'est pas Scala / Java, dans lequel certaines choses li√©es √† l'introspection peuvent se faire par r√©flexion. J'ai donc d√ª trouver une approche qui tomberait sur SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la version 5.5.24, la toute premi√®re impl√©mentation exp√©rimentale est devenue disponible. Vous pouvez s√ªrement faire mieux. Mais comment comprendre ce qui sera utile et quels sont les fantasmes inutiles? Malheureusement, rien. Vous devez prendre et essayer, voir ce qui se passe dans la pratique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc fait une version minimale que vous pouvez prendre et essayer. Ce que nous proposons de faire pour tout le monde: essayez, exp√©rimentez et partagez vos impressions avec nous. Qu'est-ce que tu as aim√©, qu'est-ce que tu n'as pas aim√©? Peut-√™tre qu'il manque quelque chose? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxi√®mement, les mots prononc√©s </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©but 2017 sont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devenus encore plus pertinents </font><font style="vertical-align: inherit;">:</font></font><br><blockquote> ‚Ä¶       ,   ,   ,    .      -      ‚Äî      .             .      . :  ,   . <br><br>    ,  ,   ,       ‚Äî    ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, mon conseil √† ceux qui recherchent un cadre d'acteur pr√™t √† l'emploi: faites attention non seulement √† l'originalit√© des id√©es et √† la beaut√© des exemples. </font><font style="vertical-align: inherit;">Regardez √©galement toutes sortes de choses auxiliaires qui vous aideront √† comprendre ce qui se passe dans votre application: par exemple, d√©couvrez combien d'acteurs sont √† l'int√©rieur maintenant, quelles sont leurs tailles de file d'attente, si le message n'atteint pas le destinataire, alors o√π va-t-il ... Si le cadre le fait fournit quelque chose comme √ßa, ce sera plus facile pour vous. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, vous aurez plus de travail.</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout ce qui pr√©c√®de est encore plus important pour tester les acteurs. </font><font style="vertical-align: inherit;">Par cons√©quent, lorsque vous choisissez un cadre d'acteur pour vous-m√™me, faites attention √† ce qu'il contient et √† ce qui ne l'est pas. </font><font style="vertical-align: inherit;">Par exemple, nous avons d√©j√† dans notre bo√Æte √† outils pour simplifier les tests :)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435606/">https://habr.com/ru/post/fr435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435592/index.html">A√ßores: derni√®re r√©serve de flore au milieu de l'oc√©an Atlantique</a></li>
<li><a href="../fr435594/index.html">Graphique d'itin√©raire pour Apache Camel</a></li>
<li><a href="../fr435600/index.html">Comment migrer vers un autre op√©rateur mobile et ne pas faire faillite (pour les propri√©taires d'iOS)</a></li>
<li><a href="../fr435602/index.html">Pr√©paration √† l'examen Azure</a></li>
<li><a href="../fr435604/index.html">BlaBlaCar est devenu ce √† quoi il n'√©tait pas destin√©</a></li>
<li><a href="../fr435608/index.html">√âcrans de bricolage</a></li>
<li><a href="../fr435610/index.html">Oeufs de P√¢ques pour ZX Spectrum - dans l'album de musique et le film</a></li>
<li><a href="../fr435612/index.html">Faites confiance √† Codd ou √† vos installations?</a></li>
<li><a href="../fr435614/index.html">Rust News # 4 (d√©cembre 2018)</a></li>
<li><a href="../fr435616/index.html">Comment Peer Zoning a simplifi√© nos vies et contribu√© √† √©quilibrer la charge d'EMC VPLEX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>