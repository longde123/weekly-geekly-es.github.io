<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ ‚Ü™Ô∏è üë®üèø‚Äçüéì Redes en Android usando Corutin y Retrofit ‚úçüèø üíã üî©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mientras m√°s le√≠a y ve√≠a los informes sobre las corutinas en Kotlin, m√°s admiraba esta herramienta de lenguaje. Su lanzamiento estable se lanz√≥ recien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redes en Android usando Corutin y Retrofit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428994/"><p>  Mientras m√°s le√≠a y ve√≠a los informes sobre las corutinas en Kotlin, m√°s admiraba esta herramienta de lenguaje.  Su lanzamiento estable se lanz√≥ recientemente en Kotlin 1.3, lo que significa que es hora de comenzar la inmersi√≥n y probar las rutinas en acci√≥n utilizando mi c√≥digo RxJava existente como ejemplo.  En esta publicaci√≥n, nos centraremos en c√≥mo tomar las solicitudes de red existentes y convertirlas reemplazando RxJava con corutinas. </p><br><p><img src="https://habrastorage.org/webt/h-/7v/mt/h-7vmtalbemnlfsu3g8hto3x2la.png"></p><a name="habracut"></a><br><p>  Francamente, antes de probar las corutinas, pensaba que eran muy diferentes de lo que eran antes.  Sin embargo, el principio b√°sico de la corutina incluye los mismos conceptos a los que estamos acostumbrados en los flujos reactivos de RxJava.  Como ejemplo, tomemos una configuraci√≥n simple de RxJava para crear una solicitud de red desde una de mis aplicaciones: </p><br><ul><li>  Defina la interfaz de red para el Retrofit utilizando el adaptador Rx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">retrofit2: adapter-rxjava2</a> ).  Las funciones devolver√°n objetos de un marco Rx, como <strong>Single</strong> u <strong>Observable</strong> .  (En adelante, se utilizan funciones, no m√©todos, ya que se supone que el c√≥digo anterior tambi√©n se escribi√≥ en Kotlin. Bueno, o se convirti√≥ de Java a trav√©s de Android Studio). </li><li>  Llamamos a cierta funci√≥n de otra clase (por ejemplo, un repositorio o actividad). </li><li>  Determinamos para los subprocesos en qu√© Programador se ejecutar√°n y devolvemos el resultado (m√©todos <strong>.subscribeOn ()</strong> y <strong>.observeOn ()</strong> ). </li><li>  Guardamos el enlace al objeto para cancelar la suscripci√≥n (por ejemplo, en CompositeObservable). </li><li>  Suscr√≠base a la corriente de eventos. </li><li>  Darse de baja de la secuencia en funci√≥n de los eventos del ciclo de vida de la actividad. </li></ul><br><p>  Este es el algoritmo b√°sico para trabajar con Rx (sin tener en cuenta las funciones de mapeo y los detalles de otras manipulaciones de datos).  En cuanto a la corutina, el principio no cambia mucho.  El mismo concepto, solo la terminolog√≠a est√° cambiando. </p><br><ul><li>  Definimos la interfaz de red para el Retrofit usando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adaptador para la rutina</a> .  Las funciones devolver√°n objetos <strong>diferidos</strong> de la API de Corutin. </li><li>  Llamamos a estas funciones desde otra clase (por ejemplo, un repositorio o actividad).  La √∫nica diferencia: cada funci√≥n debe marcarse como <strong>suspender</strong> . </li><li>  Defina el despachador que se usar√° para la rutina. </li><li>  Guardamos el enlace al objeto <strong>Job</strong> para cancelar la suscripci√≥n. </li><li>  Ejecute la rutina de cualquier manera posible. </li><li>  Cancelamos las rutinas seg√∫n los eventos del ciclo de vida de la Actividad. </li></ul><br><p>  Como puede ver en las secuencias anteriores, el proceso de ejecuci√≥n de Rx y Corutin es muy similar.  Si no tiene en cuenta los detalles de implementaci√≥n, esto significa que podemos mantener el enfoque que tenemos: solo reemplazamos algunas cosas para que nuestra implementaci√≥n sea amigable con la rutina. </p><br><p><img src="https://habrastorage.org/webt/rx/wm/xt/rxwmxtqqqcz0_wsvmjl8tjmel7m.png"></p><br><p>  El primer paso que debemos tomar es permitir que Retrofit devuelva objetos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diferidos</a> .  Los objetos diferidos son futuros sin bloqueo que se pueden deshacer si es necesario.  Estos objetos son esencialmente un trabajo de rutina, que contiene el valor para el trabajo correspondiente.  El uso del tipo diferido nos permite mezclar la misma idea que Job, con la posibilidad de obtener estados adicionales, como √©xito o fracaso, lo que lo hace ideal para solicitudes de red. </p><br><p>  Si est√° utilizando Retrofit con RxJava, probablemente est√© utilizando RxJava Call Adapter Factory.  Afortunadamente, Jake Worton escribi√≥ su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">equivalente para la corutina</a> . </p><br><p>  Podemos usar este adaptador de llamadas en el generador de Retrofit, y luego implementar nuestra interfaz Retrofit de la misma manera que con RxJava: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(okHttpClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OkHttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: MyService { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retrofit = Retrofit.Builder() .baseUrl(<span class="hljs-string"><span class="hljs-string">"some_api"</span></span>) .client(okHttpClient) .addCallAdapterFactory(CoroutineCallAdapterFactory()) .build() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrofit.create(MyService::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  Ahora veamos la interfaz de MyService, que se usa arriba.  Debemos reemplazar los tipos de Observable devueltos con Diferido en la interfaz Retrofit.  Si sol√≠a ser as√≠: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Ahora lo reemplazamos con: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Deferred&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Cada vez que llamamos a getData (), el objeto diferido regresar√° a nosotros, un an√°logo de Job para solicitudes de red.  Anteriormente, de alguna manera llamamos a esta funci√≥n con RxJava: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myService.getData() .map { result -&gt; result.map { myDataMapper.mapFromRemote(it) } } }</code> </pre> <br><p>  En esta secuencia de RxJava, llamamos a nuestra funci√≥n de utilidad, luego aplicamos la operaci√≥n de mapeo desde la API de RxJava con el mapeo posterior de los datos devueltos de la solicitud a algo utilizado en la capa de la interfaz de usuario.  Esto cambiar√° un poco cuando usemos una implementaci√≥n con corutinas.  Para empezar, nuestra funci√≥n debe <strong>suspenderse</strong> (diferirse) para realizar una operaci√≥n diferida dentro del cuerpo de la funci√≥n.  Y para esto, la funci√≥n de llamada tambi√©n debe diferirse.  Una funci√≥n diferida no es de bloqueo, y se puede controlar despu√©s de que se llama inicialmente.  Puede iniciarlo, pausarlo, reanudarlo o cancelarlo. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { ... }</code> </pre> <br><p>  Ahora tenemos que llamar a nuestra funci√≥n de utilidad.  A primera vista, estamos haciendo lo mismo, pero debemos recordar que ahora nos <strong>aplazamos en</strong> lugar de <strong>observables</strong> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData() ... }</code> </pre> <br><p>  Debido a este cambio, ya no podemos usar la cadena de operaci√≥n del mapa desde la API RxJava.  E incluso en este punto, los datos no est√°n disponibles para nosotros, solo tenemos una instancia diferida.  Ahora debemos usar la funci√≥n <strong>await ()</strong> para esperar el resultado de la consulta y luego continuar ejecutando el c√≥digo dentro de la funci√≥n: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() ... }</code> </pre> <br><p>  En este punto, obtenemos la solicitud completa y los datos disponibles para su uso.  Por lo tanto, ahora podemos realizar operaciones de mapeo: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.map { myDataMapper.mapFromRemote(it) } }</code> </pre> <br><p>  Tomamos nuestra interfaz Retrofit junto con la clase de llamada y usamos corutinas.  Ahora queremos llamar a este c√≥digo desde nuestra Actividad o fragmentos y usar los datos que obtuvimos de la red. </p><br><p>  En nuestra Actividad, comenzaremos creando un enlace a Job, en el que podemos asignar nuestra operaci√≥n de rutina y luego usarla para controlar, por ejemplo, cancelar una solicitud, durante una llamada <strong>onDestroy ()</strong> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myJob: Job? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { myJob?.cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() }</code> </pre> <br><p>  Ahora podemos asignar algo a la variable myJob.  Veamos nuestra solicitud con corutinas: </p><br><pre> <code class="hljs pgsql">myJob = CoroutineScope(Dispatchers.IO).launch { val result = repo.getLeagues() withContext(Dispatchers.Main) { //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> result } }</code> </pre> <br><p>  En esta publicaci√≥n, no me gustar√≠a profundizar en Dispatchers o realizar operaciones dentro de las rutinas, ya que este es un tema para otras publicaciones.  En resumen, lo que sucede aqu√≠: </p><br><ul><li>  Cree una instancia de CoroutineScope utilizando IO Dispatcher como par√°metro.  Este despachador se utiliza para realizar operaciones de bloqueo de E / S, como solicitudes de red. </li><li>  Iniciamos nuestra rutina con la funci√≥n de <strong>inicio</strong> : esta funci√≥n inicia una nueva rutina y devuelve un enlace a una variable de tipo Job. </li><li>  Luego usamos el enlace a nuestro repositorio para recibir datos al realizar una solicitud de red. </li><li>  Al final, usamos el despachador principal para hacer el trabajo en el hilo de la interfaz de usuario.  Aqu√≠ podemos mostrar los datos recibidos a los usuarios. </li></ul><br><p>  En la pr√≥xima publicaci√≥n, el autor promete profundizar un poco m√°s en los detalles, pero el material actual deber√≠a ser suficiente para comenzar a estudiar las rutinas. </p><br><p>  En esta publicaci√≥n, reemplazamos la implementaci√≥n RxJava de las respuestas de Retrofit con objetos <strong>diferidos</strong> de la API de Corutin.  Llamamos a estas funciones para recibir datos de la red y luego mostrarlos en nuestra actividad.  Espero que haya visto los pocos cambios que necesita hacer para comenzar con las rutinas, y haya apreciado la simplicidad de la API, especialmente al leer y escribir c√≥digo. </p><br><p>  En los comentarios de la publicaci√≥n original, encontr√© una solicitud tradicional: mostrar el c√≥digo completo.  Por lo tanto, hice una aplicaci√≥n simple que, al inicio, recibe un horario de trenes con Yandex. Schedules API y lo muestra en RecyclerView.  Enlace: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/AndreySBer/RetrofitCoroutinesExample</a> </p><br><p>  Tambi√©n me gustar√≠a agregar que las corutinas parecen ser un reemplazo inferior para RxJava, ya que no ofrecen un conjunto equivalente de operaciones para sincronizar hilos.  En este sentido, vale la pena mirar la implementaci√≥n de ReactiveX para Kotlin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RxKotlin</a> . </p><br><p>  Si usa Android Jetpack, tambi√©n encontr√© un ejemplo con Retrofit, coroutines, LiveData y MVVM: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://codinginfinite.com/kotlin-coroutine-call-adapter-retrofit/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428994/">https://habr.com/ru/post/es428994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428984/index.html">Julia y retratos de fase de sistemas din√°micos</a></li>
<li><a href="../es428986/index.html">Conferencia ThinkJava # 8 en Jarkov</a></li>
<li><a href="../es428988/index.html">Consejos de la naturaleza: luz nocturna nublada</a></li>
<li><a href="../es428990/index.html">Ejemplos de configuraci√≥n de UIViewControllers que utilizan RouteComposer</a></li>
<li><a href="../es428992/index.html">Bypass selectivo de bloqueos en enrutadores con firmware Padavan y Keenetic OS</a></li>
<li><a href="../es428996/index.html">Club de An√≥nimos Pap√° Noel 2018-2019 en Habrahabr</a></li>
<li><a href="../es428998/index.html">C√≥mo usar la nueva funci√≥n experimental Profiler en React</a></li>
<li><a href="../es429000/index.html">¬øPor qu√© Bill Gates invent√≥ el ba√±o por $ 233 mil millones?</a></li>
<li><a href="../es429006/index.html">China: "taller de ensamblaje mundial" no es tan simple como parece</a></li>
<li><a href="../es429008/index.html">Alfa cero, ajedrez y aprendizaje del ingl√©s: el presente y el futuro de la inteligencia artificial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>