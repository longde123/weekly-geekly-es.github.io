<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏼 🎌 👩🏽‍🚒 Utilisation de hooks d'opérations pour sauvegarder des fichiers sur macOS à la volée 🧘🏻 👩🏾‍💻 👨🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je m'appelle Denis Kopyrin et aujourd'hui je veux parler de la manière dont nous avons résolu le problème de la sauvegarde à la demande...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de hooks d'opérations pour sauvegarder des fichiers sur macOS à la volée</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/484816/">  Bonjour, Habr!  Je m'appelle Denis Kopyrin et aujourd'hui je veux parler de la manière dont nous avons résolu le problème de la sauvegarde à la demande sur macOS.  En fait, une tâche intéressante que j'ai rencontrée à l'institut est finalement devenue un grand projet de recherche sur l'utilisation du système de fichiers.  Tous les détails sont sous la coupe. <br><br> <a href="https://habr.com/ru/company/acronis/blog/484816/"><img src="https://habrastorage.org/getpro/habr/post_images/e81/10c/67b/e8110c67b5fe5edb2a8259a8a68fe632.jpg" alt="image"></a> <br><a name="habracut"></a><br>  Je ne partirai pas de loin, je peux seulement dire que tout a commencé avec un projet à l'Institut de physique et de technologie de Moscou, que j'ai développé avec mon superviseur au département de base d'Acronis.  Nous étions confrontés à la tâche d'organiser le stockage de fichiers à distance, ou plutôt de maintenir l'état actuel de leurs sauvegardes. <br><br>  Pour garantir la sécurité des données, nous utilisons l'extension du noyau macOS, qui collecte des informations sur les événements du système.  KPI pour les développeurs dispose d'une API KAUTH, qui vous permet de recevoir des notifications sur l'ouverture et la fermeture d'un fichier - c'est tout.  Si vous utilisez KAUTH, vous devez enregistrer complètement le fichier lors de son ouverture pour l'écriture, car les événements d'écriture dans le fichier ne sont pas disponibles pour les développeurs.  Ces informations n'étaient pas suffisantes pour nos tâches.  En effet, afin de compléter en permanence une copie de sauvegarde des données, vous devez comprendre exactement où l'utilisateur (ou le malware :) a écrit les nouvelles données dans le fichier. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d12/250/d5e/d12250d5e699b0841d0059eb5ba8846c.png" alt="image"><br><br>  Mais lequel des développeurs a été effrayé par les restrictions du système d'exploitation?  Si l'API du noyau ne vous permet pas d'obtenir des informations sur les opérations d'écriture, vous devez trouver votre propre façon d'intercepter via d'autres outils du noyau. <br><br>  Au début, nous ne voulions pas patcher le cœur et ses structures.  Au lieu de cela, ils ont essayé de créer un volume virtuel entier qui nous permettrait d'intercepter toutes les demandes de lecture et d'écriture qui le traversaient.  Mais il s'est avéré une caractéristique désagréable de macOS: le système d'exploitation pense qu'il n'a pas 1, mais 2 lecteurs flash USB, deux disques, etc.  Et du fait que le second volume change lorsque vous travaillez avec le premier, macOS commence à ne pas fonctionner correctement avec les lecteurs.  Il y avait tellement de problèmes avec cette méthode que j'ai dû l'abandonner. <br><br><h3>  Rechercher une autre solution </h3><br>  Malgré les limites de KAUTH, ce KPI vous permet d'être averti de l'utilisation d'un fichier pour l'enregistrement avant toutes les opérations.  Les développeurs ont accès à l'abstraction du fichier BSD dans le noyau - vnode.  Curieusement, il s'est avéré que l'application de correctifs à vnode est plus facile que l'utilisation du filtrage de volume.  La structure vnode a une table de fonctions qui permettent de travailler avec de vrais fichiers.  Par conséquent, nous avons eu l'idée de remplacer ce tableau. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/6c7/a9b/6b16c7a9b87a054f0ae5898d043aa91d.png" alt="image"><br><br>  L'idée a été immédiatement considérée comme une bonne idée, mais pour sa mise en œuvre, il a fallu trouver la table elle-même dans la structure vnode, car Apple ne documente son emplacement nulle part.  Pour ce faire, il a fallu étudier le code machine du noyau, et aussi déterminer s'il est possible d'écrire à cette adresse pour que le système ne meure pas après. <br><br>  Si la table est trouvée, nous la copions simplement en mémoire, remplaçons le pointeur et collons le lien vers la nouvelle table dans le vnode existant.  Grâce à cela, toutes les opérations avec des fichiers passeront par notre pilote, et nous pourrons enregistrer toutes les demandes des utilisateurs, y compris en lecture et en écriture.  Par conséquent, la recherche de la table précieuse est devenue notre objectif principal. <br><br>  Étant donné qu'Apple ne le veut pas vraiment, pour résoudre le problème, vous devez essayer de «deviner» l'emplacement de la table à l'aide d'une heuristique pour l'emplacement relatif des champs, ou prendre une fonction déjà connue, la démonter et rechercher un décalage à partir de ces informations. <br><br>  <b>Comment rechercher un décalage: un moyen simple</b> <br><br>  Le moyen le plus simple de trouver des décalages de table dans vnode est une heuristique basée sur l'emplacement des champs dans une structure ( <a href="">lien vers Github</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnode</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (**v_op)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">/* vnode operations vector */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> v_mount; <span class="hljs-comment"><span class="hljs-comment">/* ptr to vfs we are in */</span></span> ... }</code> </pre> <br>  Nous utiliserons l'hypothèse que le champ v_op dont nous avons besoin est exactement 8 octets supprimés de v_mount.  La valeur de ce dernier peut être obtenue en utilisant un KPI public ( <a href="">lien vers Github</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> vnode_mount(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> vp);</code> </pre><br>  Connaissant la valeur de v_mount, nous commencerons à chercher une «aiguille dans la botte de foin» - nous percevrons la valeur du pointeur vers vnode 'vp' comme uintptr_t *, la valeur de vnode_mount (vp) comme uintptr_t.  Ceci est suivi d'itérations jusqu'à la valeur «raisonnable» de i, jusqu'à ce que la condition «meule de foin [i] == aiguille» soit remplie.  Et si l'hypothèse concernant l'emplacement des champs est correcte, le décalage v_op est i-1. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVOPPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vnode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> haystack = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>*) vp; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> needle = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>) vnode_mount(vp); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ATTEMPTCOUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haystack[i] == needle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> haystack + (i - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br>  <b>Comment rechercher un décalage: démontage</b> <br><br>  Malgré sa simplicité, la première méthode présente un inconvénient important.  Si Apple modifie l'ordre des champs dans la structure vnode, la méthode simple sera interrompue.  Une méthode plus universelle, mais moins triviale, consiste à démonter dynamiquement le noyau. <br><br>  Par exemple, considérons la fonction de noyau démontée VNOP_CREATE ( <a href="">lien vers Github</a> ) sur macOS 10.14.6.  Les instructions qui nous intéressent sont signalées par une flèche -&gt;. <br><br> <code>_VNOP_CREATE: <br> 1 push rbp <br> 2 mov rbp, rsp <br> 3 push r15 <br> 4 push r14 <br> 5 push r13 <br> 6 push r12 <br> 7 push rbx <br> 8 sub rsp, 0x48 <br> 9 mov r15, r8 <br> 10 mov r12, rdx <br> 11 mov r13, rsi <br> -&gt; 12 mov rbx, rdi <br> 13 lea rax, qword [___stack_chk_guard] <br> 14 mov rax, qword [rax] <br> 15 mov qword [rbp+-48], rax <br> -&gt; 16 lea rax, qword [_vnop_create_desc] ; _vnop_create_desc <br> 17 mov qword [rbp+-112], rax <br> 18 mov qword [rbp+-104], rdi <br> 19 mov qword [rbp+-96], rsi <br> 20 mov qword [rbp+-88], rdx <br> 21 mov qword [rbp+-80], rcx <br> 22 mov qword [rbp+-72], r8 <br> -&gt; 23 mov rax, qword [rdi+0xd0] <br> -&gt; 24 movsxd rcx, dword [_vnop_create_desc] <br> 25 lea rdi, qword [rbp+-112] <br> -&gt; 26 call qword [rax+rcx*8] <br> 27 mov r14d, eax <br> 28 test eax, eax <br> ….</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">errno_t</span></span> VNOP_CREATE(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> dvp, <span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> * vpp, struct componentname * cnp, struct vnode_attr * vap, <span class="hljs-keyword"><span class="hljs-keyword">vfs_context_t</span></span> ctx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _err; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnop_create_args</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> a.a_desc = &amp;vnop;_create_desc; a.a_dvp = dvp; a.a_vpp = vpp; a.a_cnp = cnp; a.a_vap = vap; a.a_context = ctx; _err = (*dvp-&gt;v_op[vnop_create_desc.vdesc_offset])(&amp;a;); …</code> </pre><br>  Nous allons scanner les instructions de l'assembleur pour trouver le décalage dans le dvp vnode.  Le «but» du code assembleur est d'appeler une fonction à partir de la table v_op.  Pour ce faire, le processeur doit suivre ces étapes: <br><br><ol><li>  Téléchargez dvp pour vous inscrire </li><li>  Déréférencer pour obtenir v_op (ligne 23) </li><li>  Obtenez vnop_create_desc.vdesc_offset (ligne 24) </li><li>  Appeler une fonction (ligne 26) </li></ol><br>  Si tout est clair avec les étapes 2 à 4, alors des difficultés surviennent avec la première étape.  Comment comprendre dans quel registre dvp a été chargé?  Pour ce faire, nous avons utilisé une méthode d'émulation d'une fonction qui surveille les mouvements du pointeur souhaité.  Selon la convention d'appel System V x86_64, le premier argument est passé dans le registre rdi.  Par conséquent, nous avons décidé de garder une trace de tous les registres contenant rdi.  Dans mon exemple, ce sont les registres rbx et rdi.  En outre, une copie du registre peut être enregistrée sur la pile, qui se trouve dans la version de débogage du noyau. <br><br>  Sachant que les registres rbx et rdi stockent dvp, nous découvrons que la ligne 23 a déréférencé vnode pour obtenir v_op.  Nous obtenons donc l'hypothèse que le déplacement dans la structure est 0xd0.  Pour confirmer la bonne décision, nous continuons à scanner et à nous assurer que la fonction est appelée correctement (lignes 24 et 26). <br><br>  Cette méthode est plus sûre, mais malheureusement, elle présente également des inconvénients.  Nous devons compter sur le fait que le modèle de la fonction (à savoir les 4 étapes dont nous avons parlé ci-dessus) sera le même.  Cependant, la probabilité de changer le motif de la fonction est d'un ordre de grandeur inférieur à la probabilité de changer l'ordre des champs.  Nous avons donc décidé de nous arrêter sur la deuxième méthode. <br><br><h3>  Remplacer les pointeurs dans le tableau </h3><br>  Après avoir trouvé v_op, la question se pose, comment utiliser ce pointeur?  Il existe deux façons différentes: remplacer la fonction dans le tableau (troisième flèche dans l'image) ou remplacer le tableau dans vnode (deuxième flèche dans l'image). <br><br>  Au début, il semble que la première option soit plus rentable, car il suffit de remplacer un pointeur.  Cependant, cette approche présente 2 inconvénients importants.  Tout d'abord, la table v_op est la même pour tous les vnode d'un système de fichiers donné (v_op pour HFS +, v_op pour APFS, ...), donc le filtrage par vnode est requis, ce qui peut être très coûteux - vous devrez filtrer le vnode supplémentaire à chaque opération d'écriture.  Deuxièmement, le tableau est écrit sur la page en lecture seule.  Cette limitation peut être contournée si vous utilisez l'enregistrement via IOMappedWrite64, en contournant les vérifications du système.  De plus, si kext avec le pilote du système de fichiers est livré, il sera difficile de comprendre comment supprimer le correctif. <br><br>  La deuxième option s'avère plus ciblée et plus sûre - l'intercepteur ne sera appelé que pour le vnode nécessaire, et la mémoire vnode permet initialement des opérations de lecture-écriture.  La table entière étant en cours de remplacement, il est nécessaire d'allouer un peu plus de mémoire (80 fonctions au lieu d'une).  Et comme le nombre de tables est généralement égal au nombre de systèmes de fichiers, la limite de mémoire est complètement négligeable. <br><br>  C'est pourquoi kext utilise la deuxième méthode, bien que, je le répète, à première vue, il semble que cette option soit pire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f6/adc/957/0f6adc957cded9d732080d3f32cfa4d1.png" alt="image"><br><br>  En conséquence, notre pilote fonctionne comme suit: <br><br><ol><li>  L'API KAUTH fournit vnode </li><li>  Nous remplaçons la table vnode.  Si nécessaire, nous n'interceptons les opérations que pour les noeuds virtuels «intéressants», par exemple, les documents utilisateur </li><li>  Lors de l'interception, nous vérifions quel processus enregistre, nous filtrons «notre» </li><li>  Nous envoyons une demande synchronisée UserSpace au client, qui décide exactement ce qui doit être enregistré. </li></ol><br><h3>  Qu'est-il arrivé? </h3><br>  Aujourd'hui, nous avons un module expérimental, qui est une extension du noyau macOS et prend en compte toute modification du système de fichiers au niveau granulaire.  Il convient de noter que dans macOS 10.15, Apple a introduit un nouveau cadre ( <a href="https://developer.apple.com/documentation/endpointsecurity%3Flanguage%3Dobjc">lien vers EndpointSecurity</a> ) pour recevoir des notifications de modifications du système de fichiers, qui est prévu pour une utilisation dans Active Protection, par conséquent, la solution décrite dans l'article a été déclarée obsolète. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484816/">https://habr.com/ru/post/fr484816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484802/index.html">Mode d'autodestruction: décomposition de la capsule endoscopique due à la lumière</a></li>
<li><a href="../fr484804/index.html">Que chiffrer dans un système d'entreprise? Et pourquoi faire ça?</a></li>
<li><a href="../fr484806/index.html">Différence entre cPanel et Plesk Obsidian</a></li>
<li><a href="../fr484812/index.html">Mon expérience avec Plesk</a></li>
<li><a href="../fr484814/index.html">6. Mise en route de Fortinet v6.0. Filtrage Web et contrôle des applications</a></li>
<li><a href="../fr484818/index.html">Le livre "C ++. La pratique de la programmation multithread "</a></li>
<li><a href="../fr484820/index.html">FAQ.Net - un programme de prise de notes gratuit pour Windows avec une conception mise à jour</a></li>
<li><a href="../fr484822/index.html">Blazor: comment empêcher un composant de tomber malade ou deux approches pour séparer le code du balisage</a></li>
<li><a href="../fr484824/index.html">La guerre pour éteindre les lumières</a></li>
<li><a href="../fr484826/index.html">L'intelligence artificielle aggrave encore plus la mauvaise médecine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>