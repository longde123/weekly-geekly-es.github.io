<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏻 🐋 😝 Python-Test mit Pytest. KAPITEL 3 Pytest-Vorrichtungen 🏍️ 👵🏼 🛅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zurück Weiter 


 Dieses Buch ist das fehlende Kapitel, das in jedem umfassenden Python-Buch fehlt. 


 Frank Ruiz 
 Principal Site Reliability Engine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Test mit Pytest. KAPITEL 3 Pytest-Vorrichtungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448786/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zurück</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weiter</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  Dieses Buch ist das fehlende Kapitel, das in jedem umfassenden Python-Buch fehlt. </p><br><p>  Frank Ruiz <br>  Principal Site Reliability Engineer, Box, Inc. </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p>  Die Beispiele in diesem Buch wurden mit Python 3.6 und pytest 3.2 geschrieben.  pytest 3.2 unterstützt Python 2.6, 2.7 und Python 3.3+ </p><br><blockquote> Der Quellcode für das Aufgabenprojekt sowie für alle in diesem Buch gezeigten Tests ist unter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">Link</a> auf der Webseite des Buches unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com verfügbar</a> .  Sie müssen den Quellcode nicht herunterladen, um den Testcode zu verstehen.  Der Testcode wird in den Beispielen in einer praktischen Form dargestellt.  Um jedoch die Aufgaben des Projekts zu verfolgen oder Testbeispiele anzupassen, um Ihr eigenes Projekt zu testen (Ihre Hände sind losgebunden!), Müssen Sie auf die Webseite des Buches gehen und die Arbeit herunterladen.  Dort, auf der Webseite des Buches, gibt es einen Link für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/errata">Errata-</a> Nachrichten und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://forums.pragprog.com/forums/438">Diskussionsforum</a> . </blockquote><p>  Unter dem Spoiler befindet sich eine Liste der Artikel dieser Reihe. </p><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Einführung</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 1: Erste Schritte mit Pytest</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 2: Schreiben von Testfunktionen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 3: Pytest-Vorrichtungen</strong></a> (Dieser Artikel) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 4: Eingebaute Vorrichtungen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 5: Plugins</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 6: Konfiguration</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 7: Verwenden von pytest mit anderen Tools</strong></a> </li></ul></div></div><br><p>  Nachdem Sie die Grundlagen von pytest kennengelernt haben, wenden wir uns den Vorrichtungen zu, die für die Strukturierung des Testcodes für fast jedes nicht triviale Softwaresystem erforderlich sind.  Vorrichtungen sind Funktionen, die von pytest vor (und manchmal nach) den eigentlichen Testfunktionen ausgeführt werden.  Der Fixture Code kann alles tun, was Sie brauchen.  Sie können Fixtures verwenden, um einen Datensatz zum Testen abzurufen.  Sie können Fixtures verwenden, um das System in einen bekannten Zustand zu versetzen, bevor Sie den Test ausführen.  Vorrichtungen werden auch verwendet, um Daten für mehrere Tests zu erhalten. </p><br><p>  Hier ist ein einfaches Beispiel für ein Gerät, das eine Zahl zurückgibt: </p><br><blockquote> <strong>ch3 / <code>test_fixtures.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest @pytest.fixture() def some_data(): """Return answer to ultimate question.""" return 42 def test_some_data(some_data): """Use fixture return value in a test.""" assert some_data == 42</code> </pre> <br><p>  Der <code>@pytest.fixture()</code> wird verwendet, um pytest mitzuteilen, dass die Funktion ein Fixture ist.  Wenn Sie den Fixture-Namen in die Parameterliste der Testfunktion aufnehmen, weiß pytest, wie er ausgeführt wird, bevor der Test ausgeführt wird.  Fixtures können die Arbeit erledigen oder Daten an eine Testfunktion zurückgeben. </p><br><p>  Der Test <code>test_some_data()</code> hat den <code>test_some_data()</code> Namen <code>some_data</code> als Parameter.  pytest erkennt dies und findet ein Gerät mit diesem Namen.  Der Name ist im Pytest von Bedeutung.  pytest sucht im Testmodul nach einem Gerät mit diesem Namen.  Er wird auch in <em>conftest.py</em> suchen, wenn er es darin nicht findet. </p><br><p>  Bevor wir mit der Erforschung von Fixtures (und der Datei conftest.py) beginnen, muss ich berücksichtigen, dass der Begriff Fixture in der Programmier- und Test-Community und sogar in der Python-Community viele Bedeutungen hat.  Ich verwende das <code>fixture</code> , die <code>fixture function</code> und die <code>fixture method</code> austauschbar, um auf die in diesem Kapitel beschriebenen <code>@pytest.fixture()</code> -Funktionen zu verweisen.  Fixture kann auch verwendet werden, um eine Ressource anzugeben, auf die von einer Fixture-Funktion verwiesen wird.  Fixture-Funktionen richten häufig Daten ein oder rufen sie ab, mit denen der Test arbeiten kann.  Manchmal werden diese Daten als Fixture angesehen.  Beispielsweise verwendet die Django-Community häufig Fixtures, um einige der Rohdaten anzugeben, die zu Beginn der Anwendung in die Datenbank geladen werden. </p><br><p>  Unabhängig von anderen Bedeutungen beziehen sich Testvorrichtungen in pytest und in diesem Buch auf den Mechanismus, den pytest bereitstellt, um den Code „Vorbereitungen für“ und „Aufräumen nach“ von Ihren Testfunktionen zu trennen. </p><br><p>  Pytest-Geräte sind eine der einzigartigen Eigenschaften, die Pytest gegenüber anderen Testumgebungen auslösen und der Grund sind, warum viele angesehene Menschen zu ... wechseln und bei Pytest bleiben.  Fixtures in Pytest unterscheiden sich jedoch von Fixtures in Django und unterscheiden sich von Setup- und Teardown-Verfahren, die in Unittest und Nase zu finden sind.  Es gibt viele Funktionen und Nuancen, wenn es um Geräte geht.  Sobald Sie ein gutes mentales Modell ihrer Funktionsweise erhalten, werden Sie sich besser fühlen.  Sie müssen jedoch eine Weile mit ihnen spielen, um hineinzufahren, also fangen wir an. </p><br><h2 id="obmen-fixtures-cherez-conftestpy">  Fixtures über conftest.py teilen </h2><br><p>  Sie können Fixtures in separaten Testdateien ablegen. <em>Um</em> Fixtures jedoch in mehreren Testdateien <em>freizugeben</em> , ist es besser, die Datei <em>conftest.py</em> an einem gemeinsamen Ort zentral für alle Tests zu verwenden.  Bei einem Task-Projekt befinden sich alle Fixtures in <code>tasks_proj/tests/conftest.py</code> . </p><br><p>  Von dort aus können die Vorrichtungen von jedem Teig geteilt werden.  Sie können Geräte in separate Testdateien einfügen, wenn das Gerät nur für Tests dieser Datei verwendet werden soll.  Ebenso können Sie andere <em>conftest.py-</em> Dateien in Unterverzeichnissen des <em>obersten</em> <em>Testverzeichnisses</em> haben.  In diesem Fall stehen die in diesen conftest.py-Dateien auf niedriger Ebene definierten Fixtures für Tests in diesem Verzeichnis und in diesen Unterverzeichnissen zur Verfügung.  Bisher wurden jedoch Geräte im Aufgabenprojekt für jeden Test entwickelt.  Daher ist es am <em>sinnvollsten</em> , alle unsere Tools in der Datei <em>conftest.py</em> im Stammverzeichnis des Tests, <code>tasks_proj/tests</code> , zu verwenden. </p><br><p>  Obwohl conftest.py ein Python-Modul ist, sollte es nicht von Testdateien importiert werden.  Conftest nicht importieren wann!  Die Datei conftest.py wird von pytest gelesen und als lokales Plug-In betrachtet. Dies wird deutlich, wenn wir in Kapitel 5 „Plug-Ins“ auf Seite 95 über Plug-Ins sprechen. Betrachten Sie zunächst <code>tests/conftest.py</code> als den Ort, an dem wir Fixtures verwenden können Alle Tests im Testverzeichnis.  Dann überarbeiten wir einige unserer Tests für <code>task_proj</code> , um die Fixtures korrekt zu verwenden. </p><br><h2 id="ispolzovanie--fixtures-dlya-setup-i-teardown">  Verwenden von Vorrichtungen zum Einrichten und Herunterfahren </h2><br><p>  Bei den meisten Tests im Aufgabenprojekt wird davon ausgegangen, dass die Aufgaben-Datenbank bereits konfiguriert, ausgeführt und bereit ist.  Und wir müssen am Ende einige Einträge entfernen, wenn eine Reinigung erforderlich ist.  Möglicherweise müssen Sie auch die Verbindung zur Datenbank trennen.  Glücklicherweise wurde das meiste im Aufgabencode mit <code>tasks.start_tasks_db(&lt;directory to store db\&gt;, 'tiny' or 'mongo')</code> und <code>tasks.stop_tasks_db()</code> ;  Wir müssen sie nur zum richtigen Zeitpunkt aufrufen und wir brauchen auch ein temporäres Verzeichnis. </p><br><p>  Glücklicherweise enthält pytest ein ausgezeichnetes Gerät namens tmpdir.  Wir können es zum Testen verwenden und müssen uns nicht um das Aufräumen kümmern.  Dies ist keine Magie, sondern nur eine gute Codierungspraxis der neugierigsten Menschen.  (Keine Sorge, wir werden tmpdir analysieren und mit tmpdir_factory im Abschnitt „Verwenden von tmpdir und tmpdir_factory“ auf Seite 71 detaillierter schreiben.) </p><br><p>  Angesichts all dieser Komponenten funktioniert dieses Gerät hervorragend: </p><br><blockquote>  <strong>ch3 / a / <code>tasks_proj</code> /tests/conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task @pytest.fixture() def tasks_db(tmpdir): """    ,  .""" # Setup : start db tasks.start_tasks_db(str(tmpdir), 'tiny') yield #    # Teardown : stop db tasks.stop_tasks_db()</code> </pre> <br><p>  Der Wert von <em>tmpdir ist</em> keine Zeichenfolge, sondern ein Objekt, das ein Verzeichnis darstellt.  Es implementiert jedoch <code>__str__</code> , sodass wir <code>str()</code> , um die Zeichenfolge an <code>start_tasks_db()</code> .  Im Moment verwenden wir noch tiny für TinyDB. </p><br><p>  Die Fixture-Funktion wird vor Tests ausgeführt, die sie verwenden.  Wenn die Funktion jedoch <em>Ausbeute hat</em> , stoppt sie dort, die Kontrolle wird an die Tests und die nächste Zeile übergeben, nachdem die <em>Ausbeute</em> ausgeführt wurde, nachdem die Tests abgeschlossen sind.  Stellen Sie sich daher den obigen Code als "Setup" und den Code nach <em>Yield</em> als "Teardown" vor.  Der Code nach dem "Teardown" wird unabhängig davon ausgeführt, was während der Tests passiert.  Wir geben keine Daten mit Ausgabe in diesem Gerät zurück.  Aber du kannst. </p><br><p>  Lassen Sie uns einen unserer <code>tasks.add()</code> Tests ändern, um dieses Gerät zu verwenden: </p><br><blockquote>  ch3 / a / <code>tasks_proj</code> / tests / <code>test_add</code> / <code>test_add</code> .py </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;)    .""" # GIVEN    # WHEN    # THEN  task_id  int new_task = Task('do something') task_id = tasks.add(new_task) assert isinstance(task_id, int)</code> </pre> <br><p>  Die wichtigste Änderung hierbei ist, dass das zusätzliche Gerät in der Datei entfernt wurde und wir der Liste der <code>tasks_db</code> hinzugefügt <code>tasks_db</code> .  Ich mag es, Tests im <em>GIVEN / WHEN / THEN-</em> Format (DANO / WHEN / AFTER) mit Kommentaren zu strukturieren, insbesondere wenn dies aus dem Code nicht ersichtlich ist, was passiert.  Ich denke, das ist in diesem Fall nützlich.  Hoffentlich helfen GIVEN initialisierte Datenbankaufgaben dabei herauszufinden, warum <code>tasks_db</code> als <code>tasks_db</code> verwendet wird. </p><br><hr><br><p>  Stellen Sie sicher, dass Tasks installiert ist. </p><br><hr><br><p>  In diesem Kapitel, das zuerst in Kapitel 2 installiert wurde, schreiben wir noch Tests für das Aufgabenprojekt. Wenn Sie dieses Kapitel übersprungen haben, müssen Sie die Aufgaben mit CD-Code installieren.  <code>pip install ./tasks_proj/</code> . </p><br><hr><br><h2 id="trassirovka-fixture-execution-s-setup-show">  Tracing Fixture Execution mit –setup-show </h2><br><p>  Wenn Sie den Test im letzten Abschnitt ausführen, sehen Sie nicht, welche Geräte ausgeführt werden: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ $ pip install ./tasks_proj/ #      $ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest -v test_add.py -k valid_id ===================== test session starts ====================== collected 3 items test_add.py::test_add_returns_valid_id PASSED ====================== 2 tests deselected ====================== ============ 1 passed, 2 deselected in 0.02 seconds ============</code> </pre> <br><p>  Wenn ich Leuchten entwerfe, muss ich sehen, was wann funktioniert.  Glücklicherweise bietet pytest ein solches Befehlszeilenflag, <code>-- setup-show</code> , das genau das tut: </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_add.py -k valid_id ============================= test session starts ============================= collected 3 items / 2 deselected test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tmpdir, tmpdir_factory). TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory =================== 1 passed, 2 deselected in 0.18 seconds ====================</code> </pre> <br><p>  Unser Test befindet sich in der Mitte und der Pytest bezeichnet den SETUP- und TEARDOWN-Teil für jedes Gerät.  Beginnend mit <code>test_add_returns_valid_id</code> Sie, dass <code>tmpdir</code> vor dem Test funktioniert hat.  Und davor <code>tmpdir_factory</code> .  <code>tmpdir</code> scheint es als Fixture <code>tmpdir</code> benutzen. </p><br><p>  <strong>F</strong> und <strong>S</strong> vor den Gerätenamen geben den Bereich an.  <strong>F</strong> für den Bereich und <strong>S</strong> für den Sitzungsbereich.  Ich werde den Bereich im Abschnitt "Scope Fixture Specification" auf Seite 56 behandeln. </p><br><h2 id="ispolzovanie-fixtures-dlya-test-data">  Verwenden von Vorrichtungen für Testdaten </h2><br><p>  Geräte sind ein großartiger Ort, um Daten zum Testen zu speichern.  Sie können alles zurückgeben.  Hier ist ein Gerät, das ein Tupel vom gemischten Typ zurückgibt: </p><br><blockquote>  <strong>ch3 / test_fixtures.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def a_tuple(): """ -  """ return (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" assert a_tuple[3]['bar'] == 32</code> </pre> <br><p>  Da <code>test_a_tuple()</code> fehlschlagen sollte <em>(23! = 32)</em> , werden wir sehen, was passiert, wenn der Fixture-Test fehlschlägt: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest test_fixtures.py::test_a_tuple ============================= test session starts ============================= collected 1 item test_fixtures.py F [100%] ================================== FAILURES =================================== ________________________________ test_a_tuple _________________________________ a_tuple = (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" &gt; assert a_tuple[3]['bar'] == 32 E assert 23 == 32 test_fixtures.py:38: AssertionError ========================== 1 failed in 0.17 seconds ===========================</code> </pre> <br><p>  Zusammen mit dem Stapelverfolgungsabschnitt zeigt pytest die Wertparameter der Funktion an, die die Ausnahme oder die fehlgeschlagene Bestätigung verursacht hat.  Bei Tests sind Vorrichtungen die Parameter für den Test, daher werden sie mithilfe der Stapelverfolgung gemeldet.  Was passiert, wenn Assert (oder Ausnahme) im Fixture auftritt? </p><br><pre> <code class="plaintext hljs">$ pytest -v test_fixtures.py::test_other_data ============================= test session starts ============================= test_fixtures.py::test_other_data ERROR [100%] =================================== ERRORS ==================================== ______________________ ERROR at setup of test_other_data ______________________ @pytest.fixture() def some_other_data(): """Raise an exception from fixture.""" x = 43 &gt; assert x == 42 E assert 43 == 42 test_fixtures.py:21: AssertionError =========================== 1 error in 0.13 seconds ===========================</code> </pre> <br><p>  Ein paar Dinge passieren.  Die Stapelverfolgung zeigt korrekt an, dass die Bestätigung in der Fixture-Funktion aufgetreten ist.  Außerdem wird <code>test_other_data</code> nicht als <strong>FAIL</strong> , sondern als <strong>ERROR</strong> gemeldet.  Dies ist ein großer Unterschied.  Wenn der Test plötzlich fehlschlägt, wissen Sie, dass der Fehler im Test selbst aufgetreten ist und nicht von einem Gerät abhängt. </p><br><p>  Aber was ist mit dem Aufgabenprojekt?  Für das Aufgabenprojekt könnten wir wahrscheinlich einige Datenvorrichtungen verwenden, möglicherweise unterschiedliche Aufgabenlisten mit unterschiedlichen Eigenschaften: </p><br><blockquote>  <strong>ch3 / a / task_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">#    Task constructor # Task(summary=None, owner=None, done=False, id=None) # summary    # owner  done   # id    @pytest.fixture() def tasks_just_a_few(): """    .""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture() def tasks_mult_per_owner(): """     .""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p>  Sie können sie direkt aus Tests oder aus anderen Geräten verwenden.  Lassen Sie uns mit ihrer Hilfe nicht leere Datenbanken zum Testen erstellen. </p><br><h2 id="ispolzovanie-multiple-fixtures">  Verwenden mehrerer Geräte </h2><br><p>  Sie haben bereits gesehen, dass tmpdir tmpdir_factory verwendet.  Und Sie haben tmpdir in unserem Fixture task_db verwendet.  Lassen Sie uns die Kette fortsetzen und einige spezielle Vorrichtungen für nicht leere Basen des Aufgabenprojekts hinzufügen: </p><br><blockquote>  <strong>ch3 / a / task_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def db_with_3_tasks(tasks_db, tasks_just_a_few): """   3 ,  .""" for t in tasks_just_a_few: tasks.add(t) @pytest.fixture() def db_with_multi_per_owner(tasks_db, tasks_mult_per_owner): """   9 , 3 owners,  3   .""" for t in tasks_mult_per_owner: tasks.add(t)</code> </pre> <br><p>  Alle diese <code>tasks_db</code> enthalten zwei <code>tasks_db</code> in ihrer Parameterliste: <code>tasks_db</code> und Datensatz.  Ein Dataset wird verwendet, um der Datenbank Aufgaben hinzuzufügen.  Jetzt können Tests sie verwenden, wenn der Test mit einer nicht leeren Datenbank beginnen soll, zum Beispiel: </p><br><blockquote>  <strong>ch3 / a / task_proj / tests / func / test_add.py</strong> </blockquote><br><pre> <code class="plaintext hljs">def test_add_increases_count(db_with_3_tasks): """Test tasks.add()    tasks.count().""" # GIVEN db  3  # WHEN     tasks.add(Task('throw a party')) # THEN    1 assert tasks.count() == 4</code> </pre> <br><p>  Dies zeigt auch einen der Hauptgründe für die Verwendung von Vorrichtungen: Den Test auf das zu konzentrieren, was Sie tatsächlich testen, anstatt auf das, was Sie tun mussten, um sich auf den Test vorzubereiten.  Ich verwende gerne Kommentare für GIVEN / WHEN / THEN und versuche aus zwei Gründen, so viele Daten (GIVEN) wie möglich in Fixtures zu pushen.  Erstens macht es den Test lesbarer und damit wartbarer.  Zweitens führt eine Bestätigung oder Ausnahme in einem Gerät zu einem Fehler (ERROR), während eine Bestätigung oder Ausnahme in einer Testfunktion zu einem Fehler (FAIL) führt.  Ich möchte nicht, dass <code>test_add_increases_count()</code> wenn die Initialisierung der Datenbank fehlschlägt.  Es ist nur verwirrend.  Ich möchte, dass der Fehler (FAIL) von <code>test_add_increases_count()</code> nur möglich ist, wenn <code>add ()</code> den Zähler wirklich nicht ändern kann.  Lassen Sie uns sehen, wie alle Geräte funktionieren: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest --setup-show test_add.py::test_add_increases_count ============================= test session starts ============================= collected 1 item test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) SETUP F tasks_just_a_few SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_just_a_few, tmpdir, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_just_a_few TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory ========================== 1 passed in 0.20 seconds ===========================</code> </pre> <br><p>  Wir haben wieder ein paar Fs und Ss für den Funktions- und Sitzungsbereich.  Mal sehen, was es ist. </p><br><h2 id="specifikaciya-oblasteyscope-fixture">  Scope Fixture Specification </h2><br><p>  Fixtures enthalten einen optionalen Parameter namens <strong>scope</strong> , der bestimmt, wie oft Fixtures eingerichtet und heruntergefahren werden.  Der <em>Bereichsparameter</em> für <code>@ pytest.fixture()</code> kann Funktions-, Klassen-, Modul- oder Sitzungswerte haben.  <em>Der Bereich</em> ist standardmäßig eine Funktion.  Die Einstellungen fürasks_db und alle Geräte definieren noch keinen Bereich.  Sie sind also funktionale Vorrichtungen. </p><br><p>  Das Folgende ist eine kurze Beschreibung jedes <em>Bereichswerts</em> : </p><br><ul><li><p>  <em>scope = 'function'</em> </p><br><p>  Es wird einmal für jede Funktion des Tests durchgeführt.  Der Setup-Teil wird vor jedem Test mit dem Gerät ausgeführt.  Der Abreißteil beginnt nach jedem Test mit der Vorrichtung.  Dies ist der Standardbereich, wenn der Bereichsparameter nicht angegeben ist. </p><br></li><li><p>  <em>scope = 'class'</em> </p><br><p>  Es wird einmal für jede Testklasse ausgeführt, unabhängig von der Anzahl der Testmethoden in der Klasse. </p><br></li><li><p>  <em>scope = 'module'</em> </p><br><p>  Es wird einmal für jedes Modul ausgeführt, unabhängig davon, wie viele Testfunktionen oder Methoden oder andere Vorrichtungen bei Verwendung des Moduls verwendet werden. </p><br></li><li><p>  <em>scope = 'session'</em> </p><br><p>  Es wird einmal pro Sitzung durchgeführt.  Alle Testmethoden und -funktionen, die Sitzungsumfangsgeräte verwenden, verwenden einen einzigen Setup- und Teardown-Aufruf. </p><br></li></ul><br><p>  So sehen die Bereichswerte in Aktion aus: </p><br><blockquote>  <strong>ch3 / test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Demo fixture scope.""" import pytest @pytest.fixture(scope='function') def func_scope(): """A function scope fixture.""" @pytest.fixture(scope='module') def mod_scope(): """A module scope fixture.""" @pytest.fixture(scope='session') def sess_scope(): """A session scope fixture.""" @pytest.fixture(scope='class') def class_scope(): """A class scope fixture.""" def test_1(sess_scope, mod_scope, func_scope): """   ,   .""" def test_2(sess_scope, mod_scope, func_scope): """     .""" @pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p>  Verwenden <code>--setup-show</code> , um zu demonstrieren, dass die Anzahl der Fixture- und Setup-Aufrufe in Verbindung mit dem Teardown je nach Region ausgeführt wird: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/ $ pytest --setup-show test_scope.py ============================= test session starts ============================= collected 4 items test_scope.py SETUP S sess_scope SETUP M mod_scope SETUP F func_scope test_scope.py::test_1 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP F func_scope test_scope.py::test_2 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP C class_scope test_scope.py::TestSomething::()::test_3 (fixtures used: class_scope). test_scope.py::TestSomething::()::test_4 (fixtures used: class_scope). TEARDOWN C class_scope TEARDOWN M mod_scope TEARDOWN S sess_scope ========================== 4 passed in 0.11 seconds ===========================</code> </pre> <br><p>  Jetzt sehen Sie nicht nur <strong>F</strong> und <strong>S</strong> für Funktion und Sitzung, sondern auch <strong>C</strong> und <strong>M</strong> für Klasse und Modul. </p><br><p>  Der Umfang wird mithilfe von Fixtures definiert.  Ich weiß, dass dies aus dem Code ersichtlich ist, aber dies ist ein wichtiger Punkt, um sicherzustellen, dass Sie vollständig stöhnen. verstehe ").  Der Bereich wird in der Fixture-Definition definiert und nicht am Ort des Aufrufs.  Testfunktionen, die Geräte verwenden, steuern nicht, wie oft (SETUP) und Geräte unterbrochen werden (TEARDOWN). </p><br><p>  Geräte können nur von anderen Geräten mit demselben oder einem erweiterten Umfang abhängen.  Daher kann das Funktionsbereichsgerät von einem anderen Funktionsbereichsgerät abhängen (standardmäßig und wird weiterhin im Aufgabenprojekt verwendet).  Der Funktionsumfang kann auch von der Klasse, dem Modul und den Geräten des Sitzungsbereichs abhängen, jedoch niemals in umgekehrter Reihenfolge. </p><br><h3 id="smena-scope-dlya-tasks-project-fixtures">  Änderungsbereich für Aufgaben Projektvorrichtungen </h3><br><p>  Angesichts dieser Kenntnis des Umfangs ändern wir nun den Umfang einiger Vorrichtungen des Task-Projekts. </p><br><p>  Bisher hatten wir keine Probleme mit der Testzeit.  Sie müssen jedoch zugeben, dass es sinnlos ist, für jeden Test ein temporäres Verzeichnis und eine neue Datenbankverbindung zu erstellen.  Solange wir bei Bedarf eine leere Datenbank bereitstellen können, sollte dies ausreichen. </p><br><p>  Um so etwas wie <code>tasks_db</code> als Sitzungsbereich zu verwenden, müssen Sie <code>tmpdir_factory</code> , da <code>tmpdir</code> der Funktionsumfang und <code>tmpdir_factory</code> der Sitzungsbereich ist.  Glücklicherweise ist dies nur eine Zeile der Codeänderung (zwei, wenn Sie <code>tmpdir-&gt;tmpdir_factory</code> in der Parameterliste berücksichtigen): </p><br><blockquote>  <strong>ch3 / b / task_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Define some fixtures to use in the project.""" import pytest import tasks from tasks import Task @pytest.fixture(scope='session') def tasks_db_session(tmpdir_factory): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), 'tiny') yield tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</code> </pre> <br><p>  Hier haben wir <code>tasks_db</code> abhängig von <code>tasks_db_session</code> geändert und alle Einträge gelöscht, um sicherzustellen, dass sie leer sind.  Da wir den Namen nicht geändert haben, sollte sich keines der Geräte oder Tests, die ihn bereits enthalten, ändern. </p><br><p>  Datenvorrichtungen geben einfach einen Wert zurück, sodass es wirklich keinen Grund gibt, ständig zu arbeiten.  Einmal pro Sitzung ist genug: </p><br><blockquote>  <strong>ch3 / b / task_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs"># Reminder of Task constructor interface # Task(summary=None, owner=None, done=False, id=None) # summary is required # owner and done are optional # id is set by database @pytest.fixture(scope='session') def tasks_just_a_few(): """All summaries and owners are unique.""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture(scope='session') def tasks_mult_per_owner(): """Several owners with several tasks each.""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p>  Nun wollen wir sehen, ob all diese Änderungen mit unseren Tests funktionieren: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest ===================== test session starts ====================== collected 55 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ....... tests/func/test_unique_id.py . tests/unit/test_task.py .... ================== 55 passed in 0.17 seconds ===================</code> </pre> <br><p>  Alles scheint in Ordnung zu sein.  Schauen wir uns die Geräte für eine einzelne Testdatei an, um zu sehen, wie verschiedene Bereiche gemäß unseren Erwartungen funktionieren: </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show tests/func/test_add.py ============================= test session starts ============================= platform win32 -- Python 3.6.5, pytest-3.9.3, py-1.7.0, pluggy-0.8.0 rootdir: c:\_BOOKS_\pytest_si\bopytest-code\code\ch3\b\tasks_proj\tests, inifile: pytest.ini collected 3 items tests\func\test_add.py SETUP S tmpdir_factory SETUP S tasks_db_session (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_added_task_has_id_set (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP S tasks_just_a_few SETUP F tasks_db (fixtures used: tasks_db_session) SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_db_session, tasks_just_a_few, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_db TEARDOWN S tasks_db_session TEARDOWN S tmpdir_factory TEARDOWN S tasks_just_a_few ========================== 3 passed in 0.24 seconds ===========================</code> </pre> <br><p>  Ja.  . <code>tasks_db_session</code>     ,    <code>task_db</code>        . </p><br><h3 id="specifying-fixtures-with-usefixtures"> Specifying Fixtures with usefixtures </h3><br><p>   ,   ,    ,       .  ,        <code>@pytest.mark.usefixtures('fixture1', 'fixture2')</code> . <em>usefixtures</em>  ,    ,  .          —     .       : </p><br><blockquote> <strong>ch3/test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p>  <em>usefixtures</em>    ,         .     ,       ,       . ,   -  <em>usefixtures</em> ,      . </p><br><h2 id="ispolzovanie--autouse-dlya-fixtures-that-always-get-used-kotorye-ispolzuyutsya-nepreryvno">  autouse  Fixtures That Always Get Used (  ) </h2><br><p>        ,  ,    (  <em>usefixtures</em>     ).     <em>autouse=True</em> ,    .     ,       ,              .    : </p><br><blockquote> <strong>ch3/test_autouse.py</strong> </blockquote><br><pre> <code class="plaintext hljs">""" autouse fixtures.""" import pytest import time @pytest.fixture(autouse=True, scope='session') def footer_session_scope(): """    session().""" yield now = time.time() print('--') print('finished : {}'.format(time.strftime('%d %b %X', time.localtime(now)))) print('-----------------') @pytest.fixture(autouse=True) def footer_function_scope(): """     .""" start = time.time() yield stop = time.time() delta = stop - start print('\ntest duration : {:0.3} seconds'.format(delta)) def test_1(): """   .""" time.sleep(1) def test_2(): """    .""" time.sleep(1.23)</code> </pre> <br><p>         ,         .     : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest -v -s test_autouse.py ===================== test session starts ====================== collected 2 items test_autouse.py::test_1 PASSED test duration : 1.0 seconds test_autouse.py::test_2 PASSED test duration : 1.24 seconds -- finished : 25 Jul 16:18:27 ----------------- =================== 2 passed in 2.25 seconds ===================</code> </pre> <br><p>  <em>autouse</em>  .    ,  .    ,          . </p><br><p> ,    <em>autouse</em>  ,   ,       <code>tasks_db</code>   .   Tasks  ,     ,  ,      API   .      .      ,     . </p><br><h2 id="pereimenovanie-fixtures">  Fixtures </h2><br><p>  ,        ,  ,      . , <em>pytest</em>       name  <code>@pytest.fixture()</code> : </p><br><blockquote> <strong>ch3/ <code>test_rename_fixture.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">""" fixture renaming.""" import pytest @pytest.fixture(name='lue') def ultimate_answer_to_life_the_universe_and_everything(): """  .""" return 42 def test_everything(lue): """   .""" assert lue == 42</code> </pre> <br><p>  <em>lue</em>    <code>fixture</code> ,   <code>fixture_with_a_name_much_longer_than_lue</code> .    ,       <code>--setup-show</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_rename_fixture.py ======================== test session starts ======================== collected 1 items test_rename_fixture.py SETUP F lue test_rename_fixture.py::test_everything (fixtures used: lue). TEARDOWN F lue ===================== 1 passed in 0.01 seconds ======================</code> </pre> <br><p>    ,   <em>lue</em> ,    pytest <code>--fixtures</code>       .     ,   ,    ,   : </p><br><pre> <code class="plaintext hljs">$ pytest --fixtures test_rename_fixture.py ======================== test session starts ======================= ... ------------------ fixtures defined from test_rename_fixture ------------------ lue Return ultimate answer. ================= no tests ran in 0.01 seconds =================</code> </pre> <br><p>      —   .  , ,   ,  ,   ,   .    ,    <em>lue</em> .      «Tasks»: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest --fixtures tests/func/test_add.py ======================== test session starts ======================== ... tmpdir_factory Return a TempdirFactory instance for the test session. tmpdir Return a temporary directory path object which is unique to each test function invocation, created as a sub directory of the base temporary directory. The returned object is a `py.path.local`_ path object. ----------------------- fixtures defined from conftest ------------------------ tasks_db An empty tasks db. tasks_just_a_few All summaries and owners are unique. tasks_mult_per_owner Several owners with several tasks each. db_with_3_tasks Connected db with 3 tasks, all unique. db_with_multi_per_owner Connected db with 9 tasks, 3 owners, all with 3 tasks. tasks_db_session Connect to db before tests, disconnect after. =================== no tests ran in 0.01 seconds ====================</code> </pre> <br><p>  Großartig!     <em>conftest.py</em> .        <code>tmpdir</code>  <code>tmpdir_factory</code> ,    . </p><br><h2 id="parametrizaciya-fikstur">   </h2><br><p>  [Parametrized Testing] ,  . 42,   .     .  -    ,      ,   : </p><br><blockquote> <code>ch3/b/tasks_proj/tests/func/test_add_variety2.py</code> <br> <br> """Test the tasks.add() API function.""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> tasks_to_try = (Task('sleep', done=True), <br> Task('wake', 'brian'), <br> Task('breathe', 'BRIAN', True), <br> Task('exercise', 'BrIaN', False)) <br><br> task_ids = ['Task({},{},{})'.format(t.summary, t.owner, t.done) <br> for t in tasks_to_try] <br><br> def equivalent(t1, t2): <br> """Check two tasks for equivalence.""" <br> return ((t1.summary == t2.summary) and <br> (t1.owner == t2.owner) and <br> (t1.done == t2.done)) </blockquote><p>  ,   ,      <code>a_task</code> : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try) <br> def a_task(request): <br> """ .""" <br> return request.param <br><br> def test_add_a(tasks_db, a_task): <br> """  a_task ( ids).""" <br> task_id = tasks.add(a_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, a_task) </blockquote><p> ,    fixture,    ,    .      .    param,      ,  params  <code>@pytest.fixture(params=tasks_to_try)</code> . </p><br><p>  <code>a_task</code>   —    <code>request.param</code>     ,  .        ,     ,       : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj/tests/func $ pytest -v test_add_variety2.py::test_add_a ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_a[a_task0] PASSED test_add_variety2.py::test_add_a[a_task1] PASSED test_add_variety2.py::test_add_a[a_task2] PASSED test_add_variety2.py::test_add_a[a_task3] PASSED =================== 4 passed in 0.03 seconds ===================</code> </pre> <br><p>    ,  pytest   ,   ()   .        ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try, ids=task_ids) <br> def b_task(request): <br> """  .""" <br> return request.param <br><br> def test_add_b(tasks_db, b_task): <br> """  b_task,  .""" <br> task_id = tasks.add(b_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, b_task) </blockquote><p>      : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_b ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_b[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_b[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_b[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_b[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>      <code>ids</code>  ,   ,   .    ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> def id_func(fixture_value): <br> """   .""" <br> t = fixture_value <br> return 'Task({},{},{})'.format(t.summary, t.owner, t.done) <br><br> @pytest.fixture(params=tasks_to_try, ids=id_func) <br> def c_task(request): <br> """  (id_func)   .""" <br> return request.param <br><br> def test_add_c(tasks_db, c_task): <br> """    .""" <br> task_id = tasks.add(c_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, c_task) </blockquote><p>         .       Task, <code>id_func()</code>     <em>Task</em> ,       <em>namedtuple</em>      <em>Task</em>      <em>Task</em>  .   ,      ,   : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_c ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_c[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_c[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_c[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_c[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>          .       ,   ,    .    , ! </p><br><h3 id="parametrizaciya-fixtures-v-tasks-project">  Fixtures  Tasks Project </h3><br><p>   ,         Tasks.      <em>TinyDB</em>   .   ,        .   ,   ,   ,   ,     <em>TinyDB</em> ,    <em>MongoDB</em> . </p><br><p>  ( ),     ,    <code>start_tasks_db()</code>   <code>tasks_db_session</code> : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ch3/b/tasks_proj/tests/conftest.py</a> <br><br> """      .""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> @pytest.fixture(scope='session') <br> def tasks_db_session(tmpdir_factory): <br> """    ,  .""" <br> temp_dir = tmpdir_factory.mktemp('temp') <br> tasks.start_tasks_db(str(temp_dir), 'tiny') <br> yield <br> tasks.stop_tasks_db() <br><br> @pytest.fixture() <br> def tasks_db(tasks_db_session): <br> """   tasks.""" <br> tasks.delete_all() </blockquote><p>  <code>db_type</code>   <code>start_tasks_db()</code>   .      ,        : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>tasks_proj/src/tasks/api.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_tasks_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db_path, db_type)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (str, str) -None """  API  .""" if not isinstance(db_path, string_types): raise TypeError('db_path must be a string') global _tasksdb if db_type == 'tiny': import tasks.tasksdb_tinydb _tasksdb = tasks.tasksdb_tinydb.start_tasks_db(db_path) elif db_type == 'mongo': import tasks.tasksdb_pymongo _tasksdb = tasks.tasksdb_pymongo.start_tasks_db(db_path) else: raise ValueError("db_type   'tiny'  'mongo'")</span></span></code> </pre> <br><p>   MongoDB,       db_type  mongo.  : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>ch3/c/tasks_proj/tests/conftest.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Task <span class="hljs-comment"><span class="hljs-comment"># @pytest.fixture(scope='session', params=['tiny',]) @pytest.fixture(scope='session', params=['tiny', 'mongo']) def tasks_db_session(tmpdir_factory, request): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), request.param) yield # this is where the testing happens tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</span></span></code> </pre> <br><p>    params=['tiny',' mongo']  -.   <code>request</code>    <em>temp_db</em>   <em>db_type</em>  <code>request.param</code>  ,    "tiny"  "mongo". </p><br><p>   <code>--verbose</code>   <code>-v</code>    pytest     , pytest        .      ,   . </p><br><hr><br><p>  <strong>MongoDB installieren</strong> </p><br><hr><br><p>    MongoDB, ,   MongoDB  <em>pymongo</em> .       MongoDB,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.mongodb.com/download-center</a> . pymongo   pip— <em>pip install pymongo</em> .   MongoDB       ;           <strong> 7</strong> . </p><br><hr><br><p>     : </p><br><pre> <code class="plaintext hljs"> $ cd /path/to/code/ch3/c/tasks_proj $ pip install pymongo $ pytest -v --tb=no ===================== test session starts ====================== collected 92 items test_add.py::test_add_returns_valid_id[tiny] PASSED test_add.py::test_added_task_has_id_set[tiny] PASSED test_add.py::test_add_increases_count[tiny] PASSED test_add_variety.py::test_add_1[tiny] PASSED test_add_variety.py::test_add_2[tiny-task0] PASSED test_add_variety.py::test_add_2[tiny-task1] PASSED ... test_add.py::test_add_returns_valid_id[mongo] FAILED test_add.py::test_added_task_has_id_set[mongo] FAILED test_add.py::test_add_increases_count[mongo] PASSED test_add_variety.py::test_add_1[mongo] FAILED test_add_variety.py::test_add_2[mongo-task0] FAILED ... ============= 42 failed, 50 passed in 4.94 seconds =============</code> </pre> <br><p>  Hm. . ,     ,     -   Mongo.  ,     pdb:   ,  . 125.        TinyDB. </p><br><h2 id="uprazhneniya">  Übungen </h2><br><ol><li>    <code>test_fixtures.py</code> . <br> 2.  fixtures—functions     <code>@pytest.fixture()</code> ,     . ,   ,  . </li><li>         ,   . </li><li>   ,       . </li><li>  <code>pytest --setup-show test_fixtures.py</code> .      ? </li><li>  <code>scope= 'module'</code>     4. </li><li>   <code>pytest --setup-show test_fixtures.py</code> .  Was hat sich geändert? </li><li>     6  <code>return &lt;data&gt;</code>  <code>yield &lt;data&gt;</code> . </li><li>       <code>yield</code> . </li><li>  <code>pytest -s -v test_fixtures.py</code> .    ? </li></ol><br><h2 id="chto-dalshe">  Was weiter </h2><br><p>  pytest fixture  ,   ,   <em>building blocks</em> ,    <em>setup</em>  <em>teardown</em> ,        (,  Mongo  TinyDB).    ,      ,         . </p><br><p>       pytest,   ,    (builtin)  tmpdir  tmpdir_factory.        (builtin) . </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zurück</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weiter</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448786/">https://habr.com/ru/post/de448786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448774/index.html">SQL zu CSV mit DBMS_SQL</a></li>
<li><a href="../de448776/index.html">RxVMS - Eine praktische Architektur für Flatteranwendungen</a></li>
<li><a href="../de448778/index.html">Einführung in das Zeitreise-Debugging für Visual Studio Enterprise 2019</a></li>
<li><a href="../de448780/index.html">Was gibt Software für die Rekrutierung in Geld</a></li>
<li><a href="../de448784/index.html">Neue Funktionen für Erweiterungsautoren in Visual Studio 2019 Version 16.1</a></li>
<li><a href="../de448788/index.html">Python-Test mit Pytest. Kapitel 2, Schreiben von Testfunktionen</a></li>
<li><a href="../de448790/index.html">SpaceVIL - plattformübergreifendes GUI-Framework für die Entwicklung auf .Net Core, .Net Standard und JVM</a></li>
<li><a href="../de448794/index.html">Python-Test mit Pytest. Plugins KAPITEL 5</a></li>
<li><a href="../de448796/index.html">Python-Test mit Pytest. Konfiguration, KAPITEL 6</a></li>
<li><a href="../de448798/index.html">Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>