<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÖ üåΩ ü§± Pengikisan web untuk pengembang web: ringkasan singkat üë©üèª‚Äç‚úàÔ∏è üö± ü§úüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengetahui hanya satu pendekatan untuk pengikisan web memecahkan masalah dalam jangka pendek, tetapi semua metode memiliki kekuatan dan kelemahannya. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengikisan web untuk pengembang web: ringkasan singkat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442258/">  Mengetahui hanya satu pendekatan untuk pengikisan web memecahkan masalah dalam jangka pendek, tetapi semua metode memiliki kekuatan dan kelemahannya.  Kesadaran akan hal ini menghemat waktu dan membantu menyelesaikan masalah dengan lebih efisien. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/b97/2ea/063b972eae7ba278cd3b26851d97fe24.jpg" alt="gambar"><br><br>  Banyak sumber berbicara tentang satu-satunya metode yang benar untuk mengambil data dari halaman web.  Tetapi kenyataannya adalah bahwa untuk ini Anda dapat menggunakan beberapa solusi dan alat. <br><br><ul><li>  Apa sajakah opsi untuk mengambil data dari suatu halaman web secara terprogram? </li><li>  Pro dan kontra dari setiap pendekatan? </li><li>  Bagaimana cara menggunakan sumber daya cloud untuk meningkatkan tingkat otomatisasi? </li></ul><br>  Artikel ini akan membantu mendapatkan jawaban atas pertanyaan-pertanyaan ini. <br><a name="habracut"></a><br>  Saya berasumsi bahwa Anda sudah tahu apa permintaan <b>HTTP</b> , <b>DOM</b> (Document Object Model), <b>HTML</b> , <b>pemilih CSS</b> dan <b>JavaScript Async</b> . <br><br>  Jika tidak, saya menyarankan Anda untuk mempelajari teorinya, dan kemudian kembali ke artikel. <br><br><h3>  Konten statis </h3><br>  <b>Sumber HTML</b> <br><br>  Mari kita mulai dengan pendekatan yang paling sederhana. <br><br>  Jika Anda berencana untuk memo halaman web, ini adalah hal pertama yang dimulai.  Ini akan membutuhkan daya komputer yang kecil dan waktu minimum. <br><cut></cut><br>  Namun, ini hanya berfungsi jika kode sumber HTML berisi data yang Anda targetkan.  Untuk mengujinya di Chrome, klik kanan pada halaman dan pilih Lihat Halaman Kode.  Anda sekarang harus melihat kode sumber HTML. <br><br>  Setelah Anda menemukan datanya, tulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemilih CSS</a> yang termasuk dalam elemen pembungkus sehingga Anda memiliki tautan nanti. <br><br>  Untuk implementasi, Anda dapat mengirim permintaan GET HTTP ke URL halaman dan mendapatkan kode sumber HTML kembali. <br><br>  Di <b>Node,</b> Anda bisa menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CheerioJS</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mem</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parsing</a> HTML mentah dan mengambil data menggunakan pemilih.  Kode akan terlihat seperti ini: <br><cut></cut><br><pre><code class="plaintext hljs">const fetch = require('node-fetch'); const cheerio = require('cheerio'); const url = 'https://example.com/'; const selector = '.example'; fetch(url) .then(res =&gt; res.text()) .then(html =&gt; { const $ = cheerio.load(html); const data = $(selector); console.log(data.text()); });</code> </pre> <br><h3>  Konten dinamis </h3><br>  Dalam banyak kasus, Anda tidak dapat mengakses informasi dari kode HTML mentah karena DOM dikendalikan oleh JavaScript yang berjalan di latar belakang.  Contoh khas dari ini adalah SPA (aplikasi satu halaman), di mana dokumen HTML berisi informasi minimal dan JavaScript mengisinya saat run time. <br><br>  Dalam situasi ini, solusinya adalah membuat DOM dan menjalankan skrip yang terletak di kode sumber HTML, seperti browser.  Setelah itu, data dapat diekstraksi dari objek ini menggunakan penyeleksi. <br><cut></cut><br>  <b>Browser Tanpa Kepala</b> <br><br>  Browser tanpa kepala sama dengan browser biasa, hanya tanpa antarmuka pengguna.  Ini berjalan di latar belakang, dan Anda dapat mengontrolnya secara terprogram alih-alih mengklik dan mengetik dari keyboard. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalang adalah</a> salah satu browser tanpa kepala paling populer.  Ini adalah Node library yang mudah digunakan yang menyediakan API tingkat tinggi untuk mengelola Chrome offline.  Dapat dikonfigurasi untuk berjalan tanpa header, yang sangat nyaman selama pengembangan.  Kode berikut melakukan hal yang sama seperti sebelumnya, tetapi akan berfungsi dengan halaman dinamis: <br><br><pre> <code class="plaintext hljs">const puppeteer = require('puppeteer'); async function getData(url, selector){ const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); const data = await page.evaluate(selector =&gt; { return document.querySelector(selector).innerText; }, selector); await browser.close(); return data; } const url = 'https://example.com'; const selector = '.example'; getData(url,selector) .then(result =&gt; console.log(result));</code> </pre> <br>  Tentu saja, Anda dapat melakukan lebih banyak hal menarik dengan Puppeteer, jadi periksalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasinya</a> .  Berikut cuplikan kode yang menavigasi URL, mengambil tangkapan layar, dan menyimpannya: <br><br><pre> <code class="plaintext hljs">const puppeteer = require('puppeteer'); async function takeScreenshot(url,path){ const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); await page.screenshot({path: path}); await browser.close(); } const url = 'https://example.com'; const path = 'example.png'; takeScreenshot(url, path);</code> </pre> <br>  Browser membutuhkan daya komputasi yang lebih besar daripada mengirimkan permintaan GET sederhana dan menganalisis respons.  Karena itu, pelaksanaannya relatif lambat.  Tidak hanya itu, tetapi juga menambahkan peramban sebagai ketergantungan membuat paket ini luar biasa. <br><cut></cut><br>  Di sisi lain, metode ini sangat fleksibel.  Anda dapat menggunakannya untuk menavigasi halaman, mensimulasikan klik, gerakan mouse dan menggunakan keyboard, mengisi formulir, membuat screenshot atau membuat halaman PDF, menjalankan perintah di konsol, memilih item untuk mengekstraksi konten teks.  Pada dasarnya, semua itu bisa dilakukan secara manual di browser. <br><br>  <b>Membangun DOM</b> <br><br>  Anda akan berpikir bahwa tidak perlu mensimulasikan keseluruhan browser hanya untuk membuat DOM.  Sebenarnya, ini benar, setidaknya dalam keadaan tertentu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jsdom</a> adalah perpustakaan Node yang mem-parsing HTML yang sedang dikirim, sama seperti browser.  Namun, ini bukan browser, tetapi <i>alat untuk membangun DOM dari kode sumber HTML yang diberikan</i> , serta untuk mengeksekusi kode JavaScript dalam HTML ini. <br><br>  Berkat abstraksi ini, Jsdom dapat berjalan lebih cepat daripada browser tanpa kepala.  Jika lebih cepat, mengapa tidak menggunakannya daripada browser tanpa kepala sepanjang waktu? <br><cut></cut><br>  <i>Kutipan dari dokumentasi</i> : <br><blockquote>  Orang sering mengalami masalah dengan memuat skrip asinkron saat menggunakan jsdom.  Banyak halaman memuat skrip secara tidak sinkron, tetapi tidak mungkin untuk menentukan kapan ini terjadi, dan karenanya kapan harus menjalankan kode dan memeriksa struktur DOM yang dihasilkan.  Ini adalah batasan mendasar. </blockquote><br>  Solusi ini ditunjukkan dalam contoh.  Setiap 100 ms, diperiksa apakah elemen telah muncul atau timeout telah terjadi (setelah 2 detik). <br><br>  Itu juga sering memberikan pesan kesalahan ketika Jsdom tidak mengimplementasikan beberapa fitur browser pada halaman, seperti: " <i>Kesalahan: Tidak diterapkan: window.alert ..." atau "Kesalahan: Tidak diterapkan: window.scrollTo ...</i> ".  Masalah ini juga dapat diselesaikan dengan beberapa solusi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konsol virtual</a> ). <br><br>  Ini biasanya API tingkat lebih rendah dari Puppeteer, jadi Anda perlu mengimplementasikan beberapa hal sendiri. <br><br>  Ini mempersulit penggunaannya, seperti yang bisa dilihat dari contoh.  <i>Jsdom</i> menawarkan solusi cepat untuk pekerjaan yang sama. <br><cut></cut><br>  Mari kita lihat contoh yang sama, tetapi menggunakan <i>Jsdom</i> : <br><br><pre> <code class="plaintext hljs">const jsdom = require("jsdom"); const { JSDOM } = jsdom; async function getData(url,selector,timeout) { const virtualConsole = new jsdom.VirtualConsole(); virtualConsole.sendTo(console, { omitJSDOMErrors: true }); const dom = await JSDOM.fromURL(url, { runScripts: "dangerously", resources: "usable", virtualConsole }); const data = await new Promise((res,rej)=&gt;{ const started = Date.now(); const timer = setInterval(() =&gt; { const element = dom.window.document.querySelector(selector) if (element) { res(element.textContent); clearInterval(timer); } else if(Date.now()-started &gt; timeout){ rej("Timed out"); clearInterval(timer); } }, 100); }); dom.window.close(); return data; } const url = "https://example.com/"; const selector = ".example"; getData(url,selector,2000).then(result =&gt; console.log(result));</code> </pre> <br>  <b>Rekayasa terbalik</b> <br><br>  Jsdom adalah solusi cepat dan mudah, tetapi Anda bisa membuatnya lebih sederhana. <br><br>  Apakah kita perlu memodelkan DOM? <br><cut></cut><br>  Halaman web yang ingin Anda memo terdiri dari HTML dan JavaScript yang sama, teknologi yang sama yang sudah Anda ketahui.  Jadi, <i>jika Anda menemukan sepotong kode dari mana data target diperoleh, Anda dapat mengulangi operasi yang sama untuk mendapatkan hasil yang sama</i> . <br><br>  Untuk mempermudah, data yang Anda cari bisa berupa: <br><br><ul><li>  bagian dari kode sumber HTML (seperti yang dapat dilihat dari bagian pertama artikel), </li><li>  bagian dari file statis yang dirujuk dalam dokumen HTML (misalnya, baris dalam file javascript), </li><li>  menanggapi permintaan jaringan (misalnya, beberapa kode JavaScript mengirim permintaan AJAX ke server yang merespons dengan string JSON). </li></ul><br>  <i>Sumber data ini dapat diakses menggunakan kueri jaringan</i> .  Tidak masalah jika halaman web menggunakan HTTP, WebSockets, atau protokol komunikasi lainnya, karena semuanya direproduksi secara teori. <br><br>  Setelah Anda menemukan sumber daya yang berisi data, Anda dapat mengirim permintaan jaringan yang sama ke server yang sama dengan halaman asli.  Akibatnya, Anda akan mendapatkan jawaban yang berisi data target, yang dapat dengan mudah diekstraksi menggunakan ekspresi reguler, metode string, JSON.parse, dll. <br><cut></cut><br>  Dengan kata sederhana, Anda dapat mengambil sumber daya tempat data berada, alih-alih memproses dan memuat semua materi.  Dengan demikian, masalah yang ditunjukkan pada contoh sebelumnya dapat diselesaikan dengan permintaan HTTP tunggal alih-alih mengendalikan browser atau objek JavaScript yang kompleks. <br><br>  Secara teori, solusi ini tampaknya sederhana, tetapi dalam banyak kasus ini dapat memakan waktu dan membutuhkan pengalaman dengan halaman web dan server. <br><br>  Mulailah dengan memonitor lalu lintas jaringan.  Alat hebat untuk ini adalah tab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jaringan di Chrome DevTools</a> .  Anda akan melihat semua permintaan keluar dengan jawaban (termasuk file statis, permintaan AJAX, dll.) Untuk mengulanginya dan mencari data. <br><br>  Jika jawabannya diubah oleh kode apa pun sebelum ditampilkan di layar, prosesnya akan lebih lambat.  Dalam hal ini, Anda harus menemukan bagian kode ini dan memahami apa yang sedang terjadi. <br><br>  Seperti yang Anda lihat, metode seperti itu mungkin membutuhkan lebih banyak pekerjaan daripada metode yang dijelaskan di atas.  Di sisi lain, ini memberikan kinerja terbaik. <br><br>  Diagram menunjukkan runtime dan ukuran paket yang diperlukan dibandingkan dengan Jsdom dan Puppeteer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90f/d44/8a2/90fd448a2eff0e71b2980b20b1ef0936.jpg" alt="gambar"><br><br>  Hasilnya tidak didasarkan pada pengukuran yang akurat dan dapat bervariasi, tetapi menunjukkan perbedaan perkiraan yang baik antara metode ini. <br><br><h3>  Integrasi layanan cloud </h3><br>  Misalkan Anda telah menerapkan salah satu solusi ini.  Salah satu cara untuk menjalankan skrip adalah dengan menyalakan komputer, buka terminal dan mulai secara manual. <br><br>  Tapi itu akan menjadi menjengkelkan dan tidak efisien, jadi akan lebih baik jika Anda bisa mengunggah skrip ke server dan itu akan mengeksekusi kode secara teratur tergantung pada pengaturan. <br><cut></cut><br>  Ini dapat dilakukan dengan memulai server yang sebenarnya dan menetapkan aturan kapan harus menjalankan skrip.  Dalam kasus lain, fungsi cloud adalah cara yang lebih mudah. <br><br>  Fungsi cloud adalah penyimpanan yang dirancang untuk mengeksekusi kode yang diunduh ketika suatu peristiwa terjadi.  Ini berarti Anda tidak perlu mengelola server, ini dilakukan secara otomatis oleh penyedia cloud Anda. <br><br>  Pemicu dapat berupa jadwal, permintaan jaringan, dan banyak acara lainnya.  Anda dapat menyimpan data yang dikumpulkan dalam database, menulisnya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar Google</a> atau mengirimnya melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">email</a> .  Itu semua tergantung pada imajinasi Anda. <br><br>  Penyedia cloud populer - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon Web Services</a> (AWS), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Cloud Platform</a> (GCP) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Azure</a> : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS Lambda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi cloud Gcp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi biru</a> </li></ul><br>  Anda dapat menggunakan layanan ini secara gratis, tetapi tidak lama. <br><br>  Jika Anda menggunakan Puppeteer, <i>fitur Google</i> Cloud adalah solusi termudah.  Ukuran paket dalam format Chrome Tanpa Kepala (~ 130 MB) melebihi ukuran arsip maksimum yang diizinkan dalam AWS Lambda (50 MB).  Ada beberapa metode untuk membuatnya berfungsi dengan Lambda, tetapi fungsi GCP secara default <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendukung Chrome tanpa header</a> , Anda hanya perlu memasukkan Puppeteer sebagai ketergantungan dalam <i>package.json</i> . <br><br>  Jika Anda ingin mempelajari lebih lanjut tentang fitur cloud secara umum, lihat informasi arsitektur tanpa server.  Banyak tutorial yang baik telah ditulis tentang topik ini, dan sebagian besar penyedia memiliki dokumentasi yang mudah dipahami. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442258/">https://habr.com/ru/post/id442258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442244/index.html">Rust 1.33 Rilis</a></li>
<li><a href="../id442248/index.html">NASA menyetujui peluncuran uji tak berawak Dragon-2</a></li>
<li><a href="../id442250/index.html">Bereaksi dan Vue: Kekuatan</a></li>
<li><a href="../id442252/index.html">Siklus Hidup Kode Python - Model Runtime CPython</a></li>
<li><a href="../id442256/index.html">Pertahanan digital dari dunia plastik regulator Internet domestik</a></li>
<li><a href="../id442260/index.html">10 Perintah Git Yang Harus Diketahui Pengembang</a></li>
<li><a href="../id442262/index.html">Rahasia firmware</a></li>
<li><a href="../id442264/index.html">Menghilangkan peluang untuk pembajakan lalu lintas</a></li>
<li><a href="../id442266/index.html">Delta Chat - messenger terdesentralisasi di atas email</a></li>
<li><a href="../id442268/index.html">AsyncIO Micropython: metode sinkronisasi dalam pemrograman asinkron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>