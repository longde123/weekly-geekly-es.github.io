<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 💎 👑 调查一个未知档案 🦃 🗾 👩🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="搬迁。 新城市。 求职。 即使对于IT专业人员，这也可能需要很长时间。 通常，一系列采访非常相似。 通常，当您找到工作后，便会宣布一个有趣的办公室。 

 很难理解她在做什么，但是，她感兴趣的领域是对其他人的软件的研究。 这听起来很吸引人，尽管当您意识到这似乎不是发行用于网络安全的软件的供应商时，您...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>调查一个未知档案</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450394/"> 搬迁。 新城市。 求职。 即使对于IT专业人员，这也可能需要很长时间。 通常，一系列采访非常相似。 通常，当您找到工作后，便会宣布一个有趣的办公室。 <br><br> 很难理解她在做什么，但是，她感兴趣的领域是对其他人的软件的研究。 这听起来很吸引人，尽管当您意识到这似乎不是发行用于网络安全的软件的供应商时，您停了一秒钟然后开始抓萝卜。 <br><br><img src="https://lh3.googleusercontent.com/Wm2cSc19nc9XsapzlEW-eGMZBZCEgSbZFCSj6hdNNlkqCa40ksCXrYv8ual-VfYF3rcn5OoM9X2OwIJY07u_dD5Lo_7mzZU4D7rQuu164GIDE2_IjBu_J1dIMsjD4uDgyep3yipN"><br><a name="habracut"></a><br> 简而言之：他们放弃了档案，并提出将其作为测试任务进行检查，并尝试根据显示的输入数据来计算某个签名。 值得注意的是，我在此类活动上的经验很少，这也许就是为什么在解决方案的第一次迭代中我只有几个小时的原因-这样做的动力还在持续。 是的，当然，我尝试在电话/仿真器上运行它的第一件事-此应用程序无效。 <br><br>  <b>我们所拥有的：</b>扩展名为<b>“ .apk”</b> <b>的</b>存档。 我将任务本身放在破坏者的下面，这样它就不会被搜索引擎索引：如果家伙们不喜欢它，该将解决方案放在Habr上怎么办？ <br><br><div class="spoiler">  <b class="spoiler_title">任务本身</b> <div class="spoiler_text">  APK包含用于为关联数组生成签名的功能。 <br> 尝试获取以下数据集的签名： <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"user"</span></span> : <span class="hljs-string"><span class="hljs-string">"LeetD3vM4st3R"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"__s33cr$$tV4lu3__"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"34765983265937875692356935636464"</span></span> }</code> </pre> <br></div></div><br><h2> 卷起袖子 </h2><br> 据说存档包含对关联数组进行签名的功能。 通过文件扩展名，我们立即了解到我们正在处理为Android编写的应用程序。 首先，我们解压缩档案。 实际上，这是一个常规的ZIP存档，任何存档者都可以轻松应对。 我使用了apktool实用程序，事实证明，它无意间绕过了几次耙。 是的，它发生了（通常相反，是吗？）。 咒语很简单： <br><br><pre> <code class="bash hljs">apktool d task.zip</code> </pre> <br> 事实证明，apk文件中的代码和资源也打包存储在单独的二进制文件中，并且需要其他软件来提取它们。  apktool隐式提取类字节，资源，并将其全部分解为自然的文件层次结构。 您可以继续。 <br><br><pre> <code class="bash hljs">├── AndroidManifest.xml ├── apktool.yml ├── lib │   └── arm64-v8a ├── original │   ├── AndroidManifest.xml │   └── META-INF ├── res │   ├── anim │   ├── color │   ├── drawable │   ├── layout │   ├── layout-watch-v20 │   ├── mipmap-anydpi-v26 │   ├── values │   └── values-af ├── smali │   ├── android │   ├── butterknife │   ├── com │   ├── net │   └── org └── unknown   └── org</code> </pre> <br> 我们看到了类似的层次结构（简化后的版本），并试图找出从哪里开始。 值得注意的是，我曾经为Android编写了两个小型应用程序，因此我对目录的一部分本质以及Android应用程序的设备原理几乎一清二楚。 <br><br> 首先，我决定只是“遍历”文件。 我打开AndroidManifest.xml并开始有意义地阅读。 我的注意力被一个奇怪的属性所吸引 <br><br><pre> <code class="xml hljs">android:supportsRtl="true"</code> </pre> <br> 事实证明，他负责在应用程序中支持字母为“从右到左”的语言。 我们开始紧张。 不好 <br><br> 此外，我的目光紧贴着未知的文件夹。 它的下面是层次结构： <b>org.apache.commons.codec.language.bm</b>和大量文本内容模糊的文本文件。 谷歌搜索包的全名，然后发现存储在这里的东西，这与单词的搜索算法有关，在语音上类似于给定的单词。 坦白说，我在这里开始更加努力。 经过一番探索，我发现了代码本身，然后开始了乐趣。 我曾经遇到过的Java字节码不是我遇到的，而是其他东西。 非常相似，但不同。 <br><br> 事实证明，Android有自己的虚拟机-Dalvik。 而且，像每个受人尊敬的虚拟机一样，它具有自己的字节码。 似乎是在第一次尝试解决这个问题的时候，正是在这个悲伤的音符上，我宣布中场休息，鞠躬，放下窗帘，将其全部扔了4个月，直到我的好奇心完全消灭了我。 <br><br><h2> 卷起袖子[2] </h2><br>  “但是，不是所有事情都变得容易吗？”  -这是我第二次开始任务时问自己的问题。 我开始在互联网上搜索从smali到Java的反编译器。 我只看到不可能明确地执行此过程。 他皱着眉头，去了Github，把几个关键短语带入了搜索行。 第一个是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">smali2java</a> 。 <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> gradle build java -jar smali2java.jar ..</code> </pre> <br> 失误 我在终端的几页上看到了巨大的堆栈跟踪和错误。 在稍微了解了内容的本质（并抑制了堆栈轨迹的大小而产生的情绪）之后，我发现该工具基于描述的某种语法运行，而她遇到的字节码显然与之不符。 我打开smali字节码，并在其中看到注释，合成方法和其他奇怪的构造。  Java字节码中没有这样的东西！ 多久 删除！ <br><br><div class="spoiler">  <b class="spoiler_title">更多细节</b> <div class="spoiler_text"> 事实证明，Dalvik虚拟机（以及JVM）并不了解诸如内部/外部类（读取嵌套类）之类的概念，并且编译器会生成所谓的“合成”方法以提供从嵌套类到例如外部字段。 <br><br><h4> 例如： </h4><br> 如果外部类（OuterClass）有一个字段 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OuterClass</span></span></span><span class="hljs-class"> </span></span>{ List a; ... }</code> </pre> <br> 为了使私有类可以访问外部类的字段，编译器将隐式生成以下方法： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> synthetic java.util.<span class="hljs-function"><span class="hljs-function">List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OuterClass p1)</span></span></span><span class="hljs-function"> </span></span>{ p1 = p1.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }</code> </pre> <br> 而且，由于有了这个“引擎室”厨房，该语言提供的其他一些机制也得以实现。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从这里</a>开始更详细地研究这个问题。 </div></div><br> 没有帮助。 他甚至发誓看似没有可疑的字节码。 我打开了反编译器的源代码，阅读并看到了一些非常奇怪的东西：即使是印度教程序员（在所有应有的尊重下）也不会编写此代码。 想法浮出水面：并非真正生成的代码。 我拒绝这个想法大约30分钟，试图了解错误所在。 复杂。 我再次打开Github-实际上是语法生成的解析器。 这是发电机本身。 收拾一切，试图从另一侧接近。 <br><br>  <i>值得注意的是，过一会儿我仍然尝试更改语法，甚至更改字节码本身，以便反编译器仍能消化它。</i>  <i>但是，即使就反编译器语法而言字节码变得有效，该程序也没有向我返回任何内容。</i>  <i>开源...</i> <br><br> 我翻阅了字节码，偶然发现了我不知道的常量。 谷歌搜索，我在关于反向Android应用程序的书中也遇到了同样的问题。 我记得这只是由编译器预处理程序分配的ID，它已分配给Android应用程序的资源（代码编写时间常数为R. *）。 在接下来的半小时内，我将简要检查哪些寄存器负责什么内容，以什么顺序传递参数，并且通常会深入研究语法。 <br><br><h2> 看起来像什么？ </h2><br><img src="https://lh4.googleusercontent.com/6vy-LnmhLmjl2TnDiAoA632c026jlrPG7zFlclZNXJRdpethXv_iFjRtzwyvQWrqkd1LUKixzHfzXAyDj4c28JAzqVYTmP9uqJTmUYgjJd8Yx5pEDkd0cad34bNg9LYDf3r2jFVj" width="350" height="496" align="left"> 我找到了主应用程序窗口的布局，从中我已经了解了应用程序中正在发生的事情：在主屏幕（活动）上有一个带有输入字段的RecyclerView（有条件的视图可以重用当前未显示的UI对象用于内存利用）键/值对，负责将新的键/值对添加到某个抽象容器的几个按钮，以及一个为该容器生成签名（签名）的按钮。 <br><br> 查看批注并观察到一定数量的可疑代码，这些代码与生成的代码类似，我开始使用google。 该项目使用ButterKnife库，该库允许使用批注自动<b>膨胀（）-&gt; bind（）</b> UI元素。 如果该类中有注释，则ButterKnife注释处理器将隐式创建另一个形式为<b>&lt;original_class&gt; __ViewBinding的</b>活页夹类，该活页夹将在<b>后台</b>进行所有脏活。 实际上，在我从一个MainActivity文件手动重新创建了Java源代码的相似性之后，我才从所有MainActivity文件中获得了所有这些信息。 半个小时后，我意识到该库的注释还可以设置按钮操作的回调，并找到了实际上负责将键/值对添加到容器并生成签名的那些键函数。 <br><br>  <i>当然，在研究期间，我不得不进入各种库和插件的“内脏”，因为即使是带有cookie的漂亮的Landos也无法涵盖所有​​用例和细节，对于任何“反向”，我认为这都是常见的做法。</i> <br><br><h2> 懒惰是程序员的朋友 </h2><br> 在第二个来源上花了更多时间后，我完全疲倦了，意识到无法煮稀饭。 我再次爬上Github，这次我更加仔细地看。 我找到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Smali2PsuedoJava</a>项目-“伪Java代码”中的反编译器。 即使使用此实用程序，至少也可以导致人的外观，但对我而言，作者还是一杯他最喜欢的啤酒（好吧，或者至少在Github上加一个星号，以供初学者使用）。 <br><br> 它确实有效！ 对脸的影响： <br><br><img src="https://lh6.googleusercontent.com/4yxBPy1Wt7_J7uLey66rp_qHwomfvAW_B1C6g3CsrS0DR73J_U42t4JgobNaGIUXVstTEVIaHriawFfRVZL4IqUEObjCL8RdLUv5VCGKiv_jeAxBclaXZlsMvmFUzFuuuuxfshw7"><br><br><h2> 认识Cipher.so </h2><br> 稍后，研究了该项目的Java伪代码并将其与smali字节码进行了难以置信的比较，我在代码中找到了一个奇怪的库-Cipher.so。 谷歌搜索，我发现这是APK归档中一组编译时间值的加密。 当应用程序使用以下形式的常量时，通常这是必需的：IP地址，用于外部数据库的凭据，用于授权的令牌等。  -可以通过应用程序的逆向工程获得什么。 确实，作者清楚地写道，他们说这个项目被放弃了。 这变得越来越有趣。 <br><br> 该库通过Java库提供对值的访问，其中特定的方法是我们关注的关键。 这只会激发我的兴趣，我开始更深入。 <br><br> 简而言之，Cipher.so是做什么的，它是如何工作的： <br><br><ul><li> 在我们项目的Gradle文件中，注册了密钥和相应的值 <br></li><li> 所有键值将自动打包到一个单独的动态库（.so）中，该库将在编译时生成。 是-是，将生成。 <br></li><li> 然后可以从Cipher.so生成的Java方法获得这些密钥 <br></li><li> 创建APK后，密钥名称将由MD5进行哈希处理（当然，这是为了提高安全性） <br></li></ul><br> 在存档文件夹中找到了我需要的动态库之后，我继续进行选择。 首先，作为一个经验丰富的反向练习（否），我尝试从一个简单的反向练习开始-我决定在具有ELF的类比二进制空间中，以常数和有趣的线条作为参考。 不幸的是，开箱即用的Mac readelf用户丢失了，在开始之前，我们要说一句珍惜的东西： <br><br><pre> <code class="bash hljs">brew install binuitls</code> </pre> <br> 并且不要忘记在PATH中将路径写入<b>/ usr / local</b> ，因为<i>brew</i>以一种绅士的方式保护您免受一切侵害... <br><br><pre> <code class="bash hljs">greadelf -p .rodata lib/arm64-v8a/libcipher-lib.so | head -n 15</code> </pre> <br> 我们将输出限制为前15行，否则可能会给准备不足的工程师带来震惊。 <br><br><img src="https://lh6.googleusercontent.com/-ka6awAjaQ6zTDJ4sogEHaqBEG2QL3il5HTS1M-HchKGBg4hK5qe__lAtEKtcL7CT0i_lhqtiEZYYRsnTpLmbc10hdpVTMcAeRP0bGJE87jUBvtkncNMJ3s5YtjgGXk0duZeHIrY"><br><br> 在较低的地址中，我们注意到可疑的行。 正如我发现的那样，在研究Cipher.so的来源时，将密钥和值放在通常的<b>std ::映射中：</b>这提供的信息很少，但是我们知道在Binar本身以及加密的密码中也存在混淆的密钥。 <br><br> 值加密如何？ 在研究源代码后，我发现加密是使用AES（标准对称加密系统）进行的。 因此，如果存在加密的值，则该密钥应该在附近...经过一段时间的研究，我在同一个项目中遇到了一个带有挑衅性标题<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“不安全的密钥存储：秘密非常容易获取”的问题</a> 。 实际上，我发现其中的密钥以明文形式存储在二进制文件中，并找到了解密算法。 在示例中，密钥位于零地址，尽管我理解编译器可以将其放在二进制文件的.rodata节中的其他位置，但我还是认为位于零地址的可疑单元是密钥。 <br><br>  <b>尝试＃1：我</b>继续解密这些值，并认为加密密钥是相同的。 错误。  OpenSSL提示某些错误。 在稍微阅读了Cipher.so的源代码之后，我了解到，如果用户在组装期间未指定键，则使用默认键<i>-Cipher.so@DEFAULT</i> 。 <br><br>  <b>尝试＃2：</b>再次错误。 嗯...这个常数真的重新定义了吗？ 弄错很简单：用Gradle格式混淆以Gradle编写的代码。 我再检查一次。 一切似乎都是如此。 <br><br> 它们的MD5哈希值不是键，而是键，然后我尝试尝试自己的运气并使用Rainbow表打开服务。  Voila-关键之一就是单词“ password”。 没有第二个。 当然，它给了我们很多。 这两个密钥分别位于地址240和2a2。 原则上，立即识别它们很容易-32个字符（MD5）。 <br><br> 我再次检查了所有内容，并尝试使用所有其他行（位于低位地址中）作为解密密钥进行解密-一切都是徒劳的。 <br> 因此，还有其他一些秘密密钥，动作算法似乎是正确的。 我把这项任务抛在一边，尽量不要埋葬自己。 <br><br> 在容器签名算法中稍作改动后，我仍然看到对Cipher.so库的调用和也使用Java库的加密功能的代码。 <br><br><h2> 一个谜语（我从未解决过） </h2><br> 在负责加密的功能中，一开始会检查容器中的密钥。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] a(java/util/Map p1) { v0 = p1.size() v1 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 != <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_0 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; :cond_0 v0 = <span class="hljs-string"><span class="hljs-string">"user"</span></span>; v0 = p1.containsKey(v0) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_1 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; ...</code> </pre><br> 从字面上看：如果有一个“用户”密钥，则此容器未签名（返回零签名）。 一种奇怪的感觉：问题似乎已经解决，但似乎有点可疑。 那为什么还要发明其他东西呢？ 误入歧途？ 那为什么以前我没流利地研究过这个代码呢？ 嗯... <br><br> 不，不是真的。 我用一个蓝色的Messenger指定了某个用户的答案，在给他分配任务时会提供给我的联系人。 进一步挖掘。 也许输入键/值集在添加到容器后会有所变化？ 我仔细阅读了代码。 <br><br> 请注意，反编译器已从smali代码中删除了注释。 如果他删除了重要的内容该怎么办？ 我检查了主文件-似乎没什么大不了的。 一切都很重要，但含义没有丢失。 我检查了负责将键/值对从条件TextBox写入内部容器的回调函数。 我没有发现任何犯罪。 <br><br> 我对每一行代码都持怀疑态度-我再也不能信任任何人了。 <br><br> 简单的解决方案2：我注意到，签名过程首先检查与应用程序签署的证书的签名中是否存在某些值（字符串中的子字符串）。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@OnClick</span></span> <span class="hljs-comment"><span class="hljs-comment">//   protected void huvot324yo873yvo837yvo() { String signature = "no data"; boolean result = some_packages.isKeyInSignature(this); if result { Map map = new HashMap(); ...</span></span></code> </pre> <br> 当然，含义本身就是在那个不幸的二进制文件中加密的。 实际上，如果此值不在签名中，则该算法将不会对任何内容进行签名，而只是返回字符串“ no data”作为签名。同样，我们将密码用于... <br><br><h2> 密钥解密最后一战 </h2><br> 为了了解这场悲剧的严重程度，我感到困惑，例如： <br><br> 我在本节进行了十六进制转储，并凝视了前两行，从一开始就没有消除对此的怀疑。 <br><br><img src="https://lh4.googleusercontent.com/J4lmChj6kk0lWWy23D8QngSgnJlNfd-xDP1XyBnw1wyQ_U1NBRLYyx2BFZ4y9D1HXEjcSeCKVvZC3xgVCpx-VSV0bIHD5dcmsfdaX4jrmH-uRFsRMc9VJrqpUEMDEEaijeSTPRbk"><br><br> 请注意，此处分隔行的字符为“ 0x00”。 标准C库在字符串函数中也经常使用它。 因此，第一行的中间是什么样的空格字符也同样有趣。 接下来，开始疯狂尝试，关键是： <br><br><ul><li> 整个第一行 <br></li><li> 空格前的第一行 <br></li><li> 从太空到终点的第一行 <br></li><li>  ... <br></li></ul><br> 偏执程度已经可以估计。 当您不了解任务的难度和难度时，便会开始努力。 然而，事实并非如此。 然后我想到了这个想法：“算法从我机器上的问题起是否可以正常工作？”。 总的来说，那里的动作顺序是合乎逻辑的，没有引起任何问题，但是问题是：我机器上的命令是否可以满足他们的要求？ 那你觉得呢？ <br><br> 手动检查了所有步骤之后，结果发现 <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"some_base64_input"</span></span> | openssl base64 -d</code> </pre> <br> 在某些输入参数上，它突然返回一个空字符串。 嗯 <br><br> 将其替换为计算机上的第一个base64解码器，然后对主要候选项进行分类，立即找到合适的密钥，并对该密钥进行相应的解密。 <br><br><h2> 从证书中检索签名 </h2><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyInSignature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(android.content.Context p1)</span></span></span><span class="hljs-function"> </span></span>{ v0 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> TRY_0{ v1 = p1.getPackageManager() p0 = p1.getPackageName() v2 = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GET_SIGNATURES PackageInfo p0 = v1.getPackageInfo(p0, v2) android.content.pm.Signature[] p0 = p0.signatures; // Order are not guaranteed v1 = p0.length; v2 = 0x0; :goto_0 if (v2 &gt;= v1) goto :cond_1 v3 = p0[v2]; String v3 = v3.toCharsString() String v4 = net.idik.lib.cipher.so.CipherClient.a() v3 = v3.contains(v4) }TRY_0 catch TRY_0 (android/content/pm/PackageManager$NameNotFoundException) goto :catch_0; if (v3 == 0) goto :cond_0 p1 = 0x1; return p1; :cond_0 v2 = v2 + 0x1; goto :goto_0 :catch_0 p0 = Thrown Exception p1.printStackTrace() :cond_1 return v0; }</span></span></code> </pre> <br> 这是我的次要编辑后生成的伪代码的样子。 混淆了两件事： <br><br><ul><li> 对密码学和设备证书的“厨房”了解不足 <br></li><li> 根据文档，此方法不能保证返回集合中证书的顺序，因此，无法以相同顺序循环-如果应用程序使用多个证书签名怎么办？ <br></li><li> 由于尚不清楚在这种情况下Android Runtime的功能，因此缺乏有关如何从APK中提取证书的知识 <br></li></ul><br> 我不得不深入研究所有这些问题，结果如下： <br><br><ul><li> 证书本身位于<i>原始</i>目录<i>/ META-INF / CERT.RSA中</i> <i><br></i> <br> 在此目录中，只有一个具有此扩展名的文件-这意味着应用程序仅使用一个证书进行了签名 <br></li><li> 在有关Android应用程序研究工程的网站上，发现了一个列表，可以像Android一样提取我们需要的签名。 据作者说，至少。 <br></li></ul><br> 通过运行此代码，我可以弄清楚签名，实际上，我们需要的密钥是一个子字符串。 来吧  2号简单解决方案已被淘汰。 <br><br> 的确，密钥在证书中，它仅是用来了解下一步的内容，因为如果我们拥有“用户”密钥，我们所有人也都将获得零签名，并且正如我们从上文中学到的，这是错误的答案。 <br><br><h2> 仔细编写文档！ </h2><br> 由于缺乏证据，因此放弃了对从文本字段输入的数据已更改的事实的进一步研究。 偏执狂以新的活力出现：也许从证书中提取签名的代码是不正确的，还是旧的Android版本的代码实现？ 我再次打开文档，然后看到以下内容：（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developer.android.com/reference/android/content/pm/Signature.html#toChars（）</a> ）： <br><br><img src="https://lh5.googleusercontent.com/1TZ3rj6hzTEWw5YHEl1EWnANjsiqpzGR-tTrXP_Nc6jt42ANPf1QW-fmP-mh7Y2MhgMcZF0Z8CpskzT_ge65C0YCcryiWjjpG0UuPeqkUCsde1qcQgm5NbeqFj4KO3QkdtvHM3v2"><br><br>  <b>注意：该</b>函数将签名编码为ASCII文本。 我上面收到的输出是数据的十六进制表示。 这个API对我来说似乎很奇怪，但是如果您相信文档，原来我就再度陷入僵局，并且加密密钥不是签名的子字符串。 在沉思了一段时间之后，我忍不住打开了该类的源代码。  <a href="">https://android.googlesource.com/platform/frameworks/base/+/e639da7/core/java/android/content/pm/Signature.java</a> <br><br> 答案很快就到了。 实际上，在代码本身中是一幅油画：输出格式是普通的十六进制字符串。 现在想想：要么我听不懂，要么文档写得“略”错误。 毫无疑问，我开始再次工作。 <br><br><h2> 总结 </h2><br> 接下来的n小时过去了： <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用RecyclerView检查代码中工作的正确性，并通过源代码确定其行为，因为 </font><font style="vertical-align: inherit;">再次，并非所有点都在扩展坞中甚至在Stackoverflow上都有详细介绍</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手动反编译负责将集合签名到已编译Java中的代码片段。</font><font style="vertical-align: inherit;">我假设我仍然错过了一些东西，并且容器中的第一个键（“用户”）被隐式地从集合中删除。</font><font style="vertical-align: inherit;">我决定将其余数据设置在代码上。</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通常，此代码甚至拒绝对其余的参数进行签名（在使用密码学的代码中，这些参数进一步隐式地将我甩开了）。 </font></font><br><br> 不行<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原来，您无法对此输入进行签名。不幸的是，我将无法通过这项工作并确定是否确实如此。真可惜有一段时间，它充满了我的思想，但我向自己保证，我已经尽了一切可能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，我在此任务上花了很多时间，同时又花了很多时间来弥补知识上的空白。真的很有帮助。您可以一路追踪，并注意一开始我是如何牢牢抓住非决定性部分的。也许这将有助于某人了解初学者如何解决此类问题，因为我们通常阅读“成功案例”，其中所有步骤都是合乎逻辑的，一致的，并能得出正确的结果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有人想尝试进一步研究该任务或提出问题，请在蓝色的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arturbrsg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信使中写信给我</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请继续关注。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450394/">https://habr.com/ru/post/zh-CN450394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450374/index.html">适用于Apple IIgs的RAM扩展板</a></li>
<li><a href="../zh-CN450376/index.html">Yandex.Taxi如何在非汽车时搜索汽车</a></li>
<li><a href="../zh-CN450378/index.html">亚搏体育app 11.10</a></li>
<li><a href="../zh-CN450384/index.html">小型遗留代码研究的故事</a></li>
<li><a href="../zh-CN450386/index.html">在Go中作为抽象数据类型进行接口</a></li>
<li><a href="../zh-CN450396/index.html">如何提高英语写作能力：实用技巧和有用工具</a></li>
<li><a href="../zh-CN450398/index.html">最无畏的毒药</a></li>
<li><a href="../zh-CN450410/index.html">Terraformer-要编码的基础结构</a></li>
<li><a href="../zh-CN450416/index.html">共享软件VPN提供商如何出售您的数据</a></li>
<li><a href="../zh-CN450418/index.html">创建有机3D模型的艺术：皮下着色器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>